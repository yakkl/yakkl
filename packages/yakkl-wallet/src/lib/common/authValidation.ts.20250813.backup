// authValidation.ts - Centralized authentication validation
import { log } from '$lib/common/logger-wrapper';
import { getMiscStore, resetStores, setMiscStore, yakklMiscStore } from '$lib/common/stores';
import { getObjectFromLocalStorage, setObjectInLocalStorage } from '$lib/common/storage';
import { STORAGE_YAKKL_SETTINGS } from '$lib/common/constants';
import { sessionManager } from '$lib/managers/SessionManager';
import { jwtManager } from '$lib/utilities/jwt';
import { getProfile } from '$lib/common/profile';
import type { Profile, ProfileData, Settings } from '$lib/common/interfaces';
import { get } from 'svelte/store';
import { decryptData } from './encryption';
import { isEncryptedData } from './misc';

export interface ValidationResult {
  isValid: boolean;
  reason?: string;
  profile?: Profile;
  hasValidSession?: boolean;
  hasValidJWT?: boolean;
}

/**
 * Performs comprehensive authentication validation
 * This is the primary security check that prevents unauthorized access
 */
export async function validateAuthentication(): Promise<ValidationResult> {
  try {
    // Step 1: Check if wallet is initialized
    const settings = await getObjectFromLocalStorage(STORAGE_YAKKL_SETTINGS) as Settings;
    if (!settings || !settings.init) {
      log.warn('Authentication failed: Wallet not initialized');
      return { isValid: false, reason: 'Wallet not initialized' };
    }

    // Step 2: Check if legal terms are accepted
    if (!settings.legal?.termsAgreed) {
      log.warn('Authentication failed: Legal terms not accepted');
      return { isValid: false, reason: 'Legal terms not accepted' };
    } else {
      log.info('Authentication: Legal terms accepted');
    }

    // Step 3: Validate digest exists and is non-empty
    // Add retry logic for race condition on initial load
    let digest = getMiscStore();

    // If digest is not immediately available, retry a few times with short delays
    // This handles the race condition where the digest might still be loading
    if (!digest || digest.length === 0) {
      const maxRetries = 3;
      const retryDelay = 100; // 100ms between retries

      for (let i = 0; i < maxRetries; i++) {
        log.debug(`Authentication: Digest not found, retry ${i + 1}/${maxRetries}`);
        await new Promise(resolve => setTimeout(resolve, retryDelay));

        // Try to get the digest again
        digest = getMiscStore();

        if (digest && digest.length > 0) {
          log.debug('Authentication: Digest found after retry');
          break;
        }
      }

      // After retries, if still no digest, then auth fails
      if (!digest || digest.length === 0) {
        log.warn('Authentication failed: No valid digest found after retries');
        return { isValid: false, reason: 'No authentication digest' };
      }
    }

    // Step 4: Verify digest matches stored value
    // const storedDigest = get(yakklMiscStore);
    // if (digest !== storedDigest) {
    //   log.warn('Authentication failed: Digest mismatch');
    //   return { isValid: false, reason: 'Invalid authentication state' };
    // }

    // Step 5: Retrieve and validate profile
    // Also add retry logic here as profile might be loading
    let profile = await getProfile();

    if (!profile) {
      // Try a couple times with short delay for profile to load
      const maxRetries = 2;
      const retryDelay = 100;

      for (let i = 0; i < maxRetries; i++) {
        log.debug(`Authentication: Profile not found, retry ${i + 1}/${maxRetries}`);
        await new Promise(resolve => setTimeout(resolve, retryDelay));

        profile = await getProfile();

        if (profile) {
          log.debug('Authentication: Profile found after retry');
          break;
        }
      }
