import { handleMessage, handlePortConnection } from './handlers/MessageHandler';
import { TransactionMonitorService } from '$lib/services/transactionMonitor.service';
import { BackgroundIntervalService } from '$lib/services/background-interval.service';
import { handleBrowserAPIPortConnection } from './handlers/browser-api-port.handler';
import { createSafeMessageHandler } from '$lib/common/messageChannelValidator';
import browser from 'webextension-polyfill';
import { log } from '$lib/common/logger-wrapper';
import { bookmarkContextMenu } from './extensions/chrome/contextMenu';
import { sessionHandlers } from './handlers/session';
import { backgroundProviderManager } from './services/provider-manager';

// Initialize background cache services on extension install/startup
// This ensures cache services run continuously from the moment the extension is installed
async function initializeCacheServices() {
  try {
    log.info('[Background] Initializing background cache services...');
    const backgroundIntervals = BackgroundIntervalService.getInstance();
    await backgroundIntervals.initialize();
    backgroundIntervals.startAll();
    log.info('[Background] Background cache services initialized and running');
  } catch (error) {
    log.error('[Background] Failed to initialize cache services:', error);
  }
}

// Listen for extension install/update events
browser.runtime.onInstalled.addListener(async (details) => {
  log.info('[Background] Extension installed/updated:', details.reason);
  
  // Initialize cache services on install or update
  if (details.reason === 'install' || details.reason === 'update') {
    await initializeCacheServices();
    
    // For new installs, set up initial configuration
    if (details.reason === 'install') {
      log.info('[Background] New installation detected, setting up initial configuration');
      // Initial setup can be added here if needed
    }
  }
});

// Listen for browser startup (when browser is opened with extension already installed)
browser.runtime.onStartup.addListener(async () => {
  log.info('[Background] Browser startup detected, initializing cache services');
  await initializeCacheServices();
});

// Also initialize immediately when background script loads
// This covers the case where the extension is already installed and enabled
initializeCacheServices();

// Initialize background context
browser.runtime.onConnect.addListener((port) => {
  if (port.name === 'YAKKL_BROWSER_API') {
    // Handle browser API port connections with encryption support
    handleBrowserAPIPortConnection(port);
  } else if (port.name === 'yakkl-client' || port.name === 'yakkl-internal') {
    // Handle both legacy 'yakkl-client' and new 'yakkl-internal' port names
    handlePortConnection(port);
  }
});

// Handle one-off messages with safe channel validation
const safeMessageHandler = createSafeMessageHandler(
  async (request, sender) => {
    // Skip GET_NATIVE_BALANCE as it's handled by the dedicated handler above
    if (request?.type === 'GET_NATIVE_BALANCE') {
      console.log('Background: safeMessageHandler - Skipping GET_NATIVE_BALANCE (handled by dedicated handler)');
      return null; // Don't process this message type in safeMessageHandler
    }
    
    console.log('Background: safeMessageHandler CALLED with:', {
      type: request?.type,
      requestFull: request,
      timestamp: Date.now()
    });
    
    // Add comprehensive error handling wrapper
    try {
      // Log ALL incoming messages for debugging
      console.log('Background: Message received (top-level):', {
        type: request?.type,
        hasData: !!request?.data,
        requestKeys: request ? Object.keys(request) : [],
        timestamp: Date.now()
      });

      // Handle special cases first
      if (request.type === 'accountChanged' || request.type === 'chainChanged') {
        console.log('Background: Account or chain changed, restarting monitoring...');

        try {
          const txMonitor = TransactionMonitorService.getInstance();
          // stop() is synchronous, no await needed
          txMonitor.stop();
          await txMonitor.start();
          return { success: true };
        } catch (error: any) {
          console.error('Background: Failed to restart monitoring:', error);
          return { success: false, error: error.message };
        }
      }

    // Handle session hash storage directly here to ensure proper response
    // if (request.type === 'STORE_SESSION_HASH') {
    //   try {
    //     log.info('[Background] Handling STORE_SESSION_HASH', false, {
    //       hasPayload: !!request?.payload,
    //       payloadType: typeof request?.payload,
    //       payloadLength: request?.payload?.length
    //     });

    //     if (!request?.payload || typeof request.payload !== 'string') {
    //       log.warn('[Background] Invalid payload for STORE_SESSION_HASH', false);
    //       return { success: false, error: 'Invalid payload' };
    //     }

    //     bgMemoryHash = request.payload;
    //     bgSessionToken = generateSessionToken();

    //     // Broadcast token after responding
    //     setTimeout(async () => {
    //       try {
    //         await browser.runtime.sendMessage({
    //           type: 'SESSION_TOKEN_BROADCAST',
    //           token: bgSessionToken!.token,
    //           expiresAt: bgSessionToken!.expiresAt
    //         });
    //       } catch (error) {
    //         log.warn('[Background] Failed to broadcast session token', false, error);
    //       }
    //     }, 0);

    //     const response: StoreHashResponse = {
    //       success: true,
    //       token: bgSessionToken.token,
    //       expiresAt: bgSessionToken.expiresAt
    //     };

    //     log.info('[Background] Returning STORE_SESSION_HASH response', false, response);
    //     return response;
    //   } catch (error) {
    //     log.error('[Background] Error handling STORE_SESSION_HASH', false, error);
    //     return { success: false, error: 'Failed to store session hash' };
    //   }
    // }

    // if (request.type === 'REFRESH_SESSION') {
    //   try {
    //     const providedToken = request?.token as string | undefined;
    //     if (bgSessionToken && providedToken === bgSessionToken.token) {
    //       bgSessionToken.expiresAt = Date.now() + SESSION_TIMEOUT_MS;

    //       // Broadcast updated token expiry after responding
    //       setTimeout(async () => {
    //         try {
    //           await browser.runtime.sendMessage({
    //             type: 'SESSION_TOKEN_BROADCAST',
    //             token: bgSessionToken!.token,
    //             expiresAt: bgSessionToken!.expiresAt
    //           });
    //         } catch (error) {
    //           log.warn('[Background] Failed to broadcast refreshed session token', false, error);
    //         }
    //       }, 0);

    //       return {
    //         success: true,
    //         token: bgSessionToken.token,
    //         expiresAt: bgSessionToken.expiresAt
    //       };
    //     } else {
    //       // Clear on invalid token
    //       bgSessionToken = null;
    //       bgMemoryHash = null;
    //       return { success: false, error: 'Unauthorized' };
    //     }
    //   } catch (error) {
    //     log.error('[Background] Error handling REFRESH_SESSION', false, error);
    //     return { success: false, error: 'Failed to refresh session' };
    //   }
    // }


    // Special handling for closeAllWindows message (for backwards compatibility)
    if (request.type === 'closeAllWindows') {
      console.log('Background: Handling closeAllWindows message');
      // Use the session handler directly
      const handler = sessionHandlers.get('closeAllWindows');
      if (handler) {
        return handler(request.payload || request);
      }
    }
    
    // Special handling for STORE_SESSION_HASH to ensure immediate response
    if (request.type === 'STORE_SESSION_HASH') {
      console.log('Background: STORE_SESSION_HASH received, routing directly to handler');
      const handler = sessionHandlers.get('STORE_SESSION_HASH');
      if (handler) {
        const response = await handler(request.payload);
        console.log('Background: STORE_SESSION_HASH response:', response);
        return response;
      }
    }
    
    // Handle all other messages through the standard handler
    console.log('Background: Received message:', {
      type: request.type,
      hasPayload: !!request.payload,
      fullRequest: request
    });
    
    // Special logging for GET_NATIVE_BALANCE
    if (request.type === 'GET_NATIVE_BALANCE') {
      console.log('Background: GET_NATIVE_BALANCE message received, forwarding to handleMessage');
      console.log('Background: GET_NATIVE_BALANCE request data:', request);
      console.log('Background: About to call handleMessage for GET_NATIVE_BALANCE');
      console.log('Background: Request structure:', {
        type: request.type,
        data: request.data,
        payload: request.payload,
        allKeys: Object.keys(request)
      });
    }

    console.log('Background: Calling handleMessage with request type:', request?.type);
    const response = await handleMessage(request, sender);
    console.log('Background: handleMessage returned:', response);
    
    // Log response for GET_NATIVE_BALANCE
    if (request.type === 'GET_NATIVE_BALANCE') {
      console.log('Background: GET_NATIVE_BALANCE response from handleMessage:', response);
      console.log('Background: GET_NATIVE_BALANCE response type:', typeof response);
      console.log('Background: GET_NATIVE_BALANCE response keys:', response ? Object.keys(response) : 'null');
    }
    
    return response;
    } catch (error) {
      // Catch any unhandled errors to ensure we always return a response
      console.error('Background: Unhandled error in message handler:', {
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
        requestType: request?.type,
        timestamp: Date.now()
      });
      
      // Always return an error response instead of throwing
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error in background handler'
      };
    }
  },
  {
    timeout: 25000,
    logPrefix: 'Background'
  }
);

// NOTE: Debug listener commented out due to TypeScript constraints
// The browser.runtime.onMessage API requires returning true for async handling
// or undefined for no handling. Our safeMessageHandler below handles all messages.

// Helper function to send Promise-based response
async function sendPromiseResponse(requestId: string, data: any, error?: string) {
  try {
    // Send response back as a new message with the request ID
    await browser.runtime.sendMessage({
      __isResponse: true,
      __requestId: requestId,
      data,
      error
    });
    console.log('🔵 Promise response sent for request:', requestId);
  } catch (err) {
    console.error('🔵 Failed to send Promise response:', err);
  }
}


// Initialize transaction monitoring in background context
// This runs independently of UI and persists across sessions
async function initializeBackgroundServices() {
  try {
    console.log('Background: Initializing background services...');

    // Initialize the background provider manager with default chain (Ethereum mainnet)
    // This ensures provider is ready before any UI requests
    try {
      console.log('Background: Initializing provider manager with default Alchemy provider...');
      
      // Try to get the last used chain from storage, default to Ethereum mainnet
      let chainId = 1;
      try {
        const stored = await browser.storage.local.get('yakkl-currently-selected');
        if (stored && stored['yakkl-currently-selected']) {
          const currentlySelected = stored['yakkl-currently-selected'] as any;
          if (currentlySelected?.shortcuts?.chainId) {
            chainId = currentlySelected.shortcuts.chainId;
            console.log('Background: Using last selected chain:', chainId);
          }
        }
      } catch (error) {
        console.log('Background: Could not read last chain, using default:', chainId);
      }
      
      await backgroundProviderManager.initialize(chainId);
      console.log('Background: Provider manager initialized successfully for chain:', chainId);
    } catch (error) {
      console.error('Background: Failed to initialize provider manager:', error);
      // Continue with other services even if provider fails
    }

    // Initialize context menu for bookmarking
    try {
      await bookmarkContextMenu.initialize();
      console.log('Background: Context menu service initialized successfully');
    } catch (error) {
      console.error('Background: Failed to initialize context menu:', error);
    }

    // Get transaction monitor instance
    const txMonitor = TransactionMonitorService.getInstance();

    // Configure background monitoring settings
    txMonitor.configure({
      pollingInterval: 30000, // 30 seconds
      notificationEnabled: true // Enable notifications
    });

    // Start monitoring - this will run continuously in background
    await txMonitor.start();

    console.log('Background: Transaction monitoring started successfully');
    console.log('Background: All background services initialized successfully');

  } catch (error) {
    console.error('Background: Failed to initialize background services:', error);
  }
}

// Initialize background services when extension starts
initializeBackgroundServices();

// Export for use in background script
export { handleMessage, handlePortConnection };
