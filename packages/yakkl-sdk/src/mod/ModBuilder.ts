/**
 * ModBuilder - Helper class for building YAKKL mods
 */

import type { 
  ModManifest, 
  ModCapabilities, 
  ModUI,
  ModBackground,
  ModStorage,
  ModCategory,
  ModPermission
} from '@yakkl/core';

export interface ModBuilderConfig {
  id: string;
  name: string;
  version: string;
  description: string;
  author: string;
  license?: string;
  tier?: 'community' | 'verified' | 'pro' | 'private' | 'enterprise';
  category?: string;
  tags?: string[];
}

// Simplified component type for SDK (will be converted to core ModComponent when loaded)
interface SDKModComponent {
  id: string;
  name: string;
  type: string;
  mountPoint: string;
  props?: Record<string, any>;
}

export class ModBuilder {
  private manifest: Partial<ModManifest> = {};
  private components: SDKModComponent[] = [];
  private capabilities: Partial<ModCapabilities> = {};

  constructor(config: ModBuilderConfig) {
    this.manifest = {
      id: config.id,
      name: config.name,
      version: config.version,
      description: config.description,
      author: config.author,
      license: config.license || 'MIT',
      tier: config.tier || 'community',
      category: (config.category || 'utility') as ModCategory,
      tags: config.tags || [],
      permissions: [],
      minimumWalletVersion: '1.0.0',
      supportedPlatforms: ['web', 'extension'],
      discoverable: true,
      enhances: [],
      conflicts: [],
      iconUrl: '',
      screenshotUrls: [],
      capabilities: {}
    };
  }

  /**
   * Add UI capabilities to the mod
   */
  withUI(components: SDKModComponent[]): ModBuilder {
    this.components.push(...components);
    this.capabilities.ui = {
      components: components as any[] // Will be converted to proper type when loaded
    };
    return this;
  }

  /**
   * Add background processing capabilities
   */
  withBackground(scripts: string[]): ModBuilder {
    this.capabilities.background = {
      scripts: scripts.map((script, index) => ({
        id: `script-${index}`,
        script,
        persistent: false,
        permissions: [] as ModPermission[]
      }))
    };
    return this;
  }

  /**
   * Add API capabilities
   */
  withAPI(endpoints: string[]): ModBuilder {
    this.capabilities.apis = [{
      name: 'ModAPI',
      version: '1.0.0',
      endpoints: endpoints.map(endpoint => ({
        path: endpoint,
        method: 'GET' as const,
        handler: endpoint,
        permissions: [] as ModPermission[],
        rateLimit: { requests: 100, period: 60 }
      }))
    }];
    return this;
  }

  /**
   * Add storage capabilities
   */
  withStorage(maxSize: number = 1024 * 1024): ModBuilder {
    this.capabilities.storage = {
      encrypted: false,
      shared: false,
      maxSize
    };
    return this;
  }

  /**
   * Add network access capabilities
   */
  withNetwork(allowedHosts: string[]): ModBuilder {
    // Network access is managed through permissions
    const permissions = allowedHosts.map(host => `network:${host}` as ModPermission);
    if (this.manifest.permissions) {
      this.manifest.permissions.push(...permissions);
    } else {
      this.manifest.permissions = permissions;
    }
    return this;
  }

  /**
   * Add permissions required by the mod
   */
  withPermissions(permissions: string[]): ModBuilder {
    const modPermissions = permissions as ModPermission[];
    this.manifest.permissions = [...(this.manifest.permissions || []), ...modPermissions];
    return this;
  }

  /**
   * Set mods that this mod enhances
   */
  enhances(modIds: string[]): ModBuilder {
    this.manifest.enhances = modIds;
    return this;
  }

  /**
   * Set mods that conflict with this mod
   */
  conflicts(modIds: string[]): ModBuilder {
    this.manifest.conflicts = modIds;
    return this;
  }

  /**
   * Set mod metadata
   */
  withMetadata(metadata: {
    iconUrl?: string;
    screenshotUrls?: string[];
    website?: string;
    repository?: string;
    documentation?: string;
  }): ModBuilder {
    Object.assign(this.manifest, metadata);
    return this;
  }

  /**
   * Build the mod manifest
   */
  buildManifest(): ModManifest {
    // Update capabilities in manifest
    this.manifest.capabilities = this.capabilities as ModCapabilities;

    // Validate required fields
    if (!this.manifest.id || !this.manifest.name || !this.manifest.version) {
      throw new Error('Mod manifest missing required fields: id, name, version');
    }

    return this.manifest as ModManifest;
  }

  /**
   * Generate mod template code
   */
  generateTemplate(): string {
    const manifest = this.buildManifest();
    
    return `/**
 * ${manifest.name} - ${manifest.description}
 * Generated by YAKKL ModBuilder
 */

import type { Mod, WalletEngine } from '@yakkl/core';

export class ${this.toPascalCase(manifest.id)}Mod implements Mod {
  manifest = ${JSON.stringify(manifest, null, 2)};
  
  private engine: WalletEngine | null = null;
  private loaded = false;
  private active = false;

  async initialize(engine: WalletEngine): Promise<void> {
    this.engine = engine;
    this.loaded = true;
    this.active = true;
    
    // TODO: Add your initialization logic here
    console.log('${manifest.name} mod initialized');
  }

  async destroy(): Promise<void> {
    this.loaded = false;
    this.active = false;
    this.engine = null;
    
    // TODO: Add your cleanup logic here
    console.log('${manifest.name} mod destroyed');
  }

  isLoaded(): boolean {
    return this.loaded;
  }

  isActive(): boolean {
    return this.active;
  }

  getComponent(id: string): any {
    // TODO: Return your UI components
    return null;
  }

  getWidget(id: string): any {
    // TODO: Return your widgets
    return null;
  }

  getBackgroundScript(id: string): any {
    // TODO: Return your background scripts
    return null;
  }

  async handleAPICall(endpoint: string, data: any): Promise<any> {
    // TODO: Handle API calls
    throw new Error('API endpoint not implemented: ' + endpoint);
  }

  emit(event: string, data: any): void {
    // TODO: Emit events
  }

  on(event: string, handler: (data: any) => void): void {
    // TODO: Listen to events
  }

  off(event: string, handler: (data: any) => void): void {
    // TODO: Remove event listeners
  }

  async enhance(otherMod: Mod): Promise<boolean> {
    // TODO: Enhance other mods
    return false;
  }

  getEnhancements(): any[] {
    // TODO: Return available enhancements
    return [];
  }
}

export default ${this.toPascalCase(manifest.id)}Mod;
`;
  }

  /**
   * Convert string to PascalCase
   */
  private toPascalCase(str: string): string {
    return str
      .split(/[-_\s]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }
}