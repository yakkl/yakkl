/**
 * ModBuilder - Helper class for building YAKKL mods
 */

import type { ModManifest, ModCapabilities, ModComponent } from '@yakkl/core';

export interface ModBuilderConfig {
  id: string;
  name: string;
  version: string;
  description: string;
  author: string;
  license?: string;
  tier?: 'community' | 'verified' | 'pro' | 'private' | 'enterprise';
  category?: string;
  tags?: string[];
}

export class ModBuilder {
  private manifest: Partial<ModManifest> = {};
  private components: ModComponent[] = [];
  private capabilities: Partial<ModCapabilities> = {};

  constructor(config: ModBuilderConfig) {
    this.manifest = {
      id: config.id,
      name: config.name,
      version: config.version,
      description: config.description,
      author: config.author,
      license: config.license || 'MIT',
      tier: config.tier || 'community',
      category: config.category || 'utility',
      tags: config.tags || [],
      permissions: [],
      minimumWalletVersion: '1.0.0',
      supportedPlatforms: ['web', 'extension'],
      discoverable: true,
      enhances: [],
      conflicts: [],
      iconUrl: '',
      screenshotUrls: [],
      capabilities: {
        ui: false,
        background: false,
        api: false,
        storage: false,
        network: false
      }
    };
  }

  /**
   * Add UI capabilities to the mod
   */
  withUI(components: ModComponent[]): ModBuilder {
    this.components.push(...components);
    this.capabilities.ui = true;
    return this;
  }

  /**
   * Add background processing capabilities
   */
  withBackground(scripts: string[]): ModBuilder {
    this.capabilities.background = true;
    return this;
  }

  /**
   * Add API capabilities
   */
  withAPI(endpoints: string[]): ModBuilder {
    this.capabilities.api = true;
    return this;
  }

  /**
   * Add storage capabilities
   */
  withStorage(maxSize: number = 1024 * 1024): ModBuilder {
    this.capabilities.storage = true;
    return this;
  }

  /**
   * Add network access capabilities
   */
  withNetwork(allowedHosts: string[]): ModBuilder {
    this.capabilities.network = true;
    return this;
  }

  /**
   * Add permissions required by the mod
   */
  withPermissions(permissions: string[]): ModBuilder {
    this.manifest.permissions = [...(this.manifest.permissions || []), ...permissions];
    return this;
  }

  /**
   * Set mods that this mod enhances
   */
  enhances(modIds: string[]): ModBuilder {
    this.manifest.enhances = modIds;
    return this;
  }

  /**
   * Set mods that conflict with this mod
   */
  conflicts(modIds: string[]): ModBuilder {
    this.manifest.conflicts = modIds;
    return this;
  }

  /**
   * Set mod metadata
   */
  withMetadata(metadata: {
    iconUrl?: string;
    screenshotUrls?: string[];
    website?: string;
    repository?: string;
    documentation?: string;
  }): ModBuilder {
    Object.assign(this.manifest, metadata);
    return this;
  }

  /**
   * Build the mod manifest
   */
  buildManifest(): ModManifest {
    // Update capabilities in manifest
    this.manifest.capabilities = this.capabilities as ModCapabilities;

    // Validate required fields
    if (!this.manifest.id || !this.manifest.name || !this.manifest.version) {
      throw new Error('Mod manifest missing required fields: id, name, version');
    }

    return this.manifest as ModManifest;
  }

  /**
   * Generate mod template code
   */
  generateTemplate(): string {
    const manifest = this.buildManifest();
    
    return `/**
 * ${manifest.name} - ${manifest.description}
 * Generated by YAKKL ModBuilder
 */

import type { Mod, WalletEngine } from '@yakkl/core';

export class ${this.toPascalCase(manifest.id)}Mod implements Mod {
  manifest = ${JSON.stringify(manifest, null, 2)};
  
  private engine: WalletEngine | null = null;
  private loaded = false;
  private active = false;

  async initialize(engine: WalletEngine): Promise<void> {
    this.engine = engine;
    this.loaded = true;
    this.active = true;
    
    // TODO: Add your initialization logic here
    console.log('${manifest.name} mod initialized');
  }

  async destroy(): Promise<void> {
    this.loaded = false;
    this.active = false;
    this.engine = null;
    
    // TODO: Add your cleanup logic here
    console.log('${manifest.name} mod destroyed');
  }

  isLoaded(): boolean {
    return this.loaded;
  }

  isActive(): boolean {
    return this.active;
  }

  getComponent(id: string): any {
    // TODO: Return your UI components
    return null;
  }

  getWidget(id: string): any {
    // TODO: Return your widgets
    return null;
  }

  getBackgroundScript(id: string): any {
    // TODO: Return your background scripts
    return null;
  }

  async handleAPICall(endpoint: string, data: any): Promise<any> {
    // TODO: Handle API calls
    throw new Error('API endpoint not implemented: ' + endpoint);
  }

  emit(event: string, data: any): void {
    // TODO: Emit events
  }

  on(event: string, handler: (data: any) => void): void {
    // TODO: Listen to events
  }

  off(event: string, handler: (data: any) => void): void {
    // TODO: Remove event listeners
  }

  async enhance(otherMod: Mod): Promise<boolean> {
    // TODO: Enhance other mods
    return false;
  }

  getEnhancements(): any[] {
    // TODO: Return available enhancements
    return [];
  }
}

export default ${this.toPascalCase(manifest.id)}Mod;
`;
  }

  /**
   * Convert string to PascalCase
   */
  private toPascalCase(str: string): string {
    return str
      .split(/[-_\s]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }
}