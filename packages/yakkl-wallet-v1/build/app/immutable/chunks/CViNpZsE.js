import{s as subscribe_to_store,g as get}from"./B2gA1VsD.js";import{n as noop,m as mutable_source,e as set,g as get$1,at as teardown,au as define_property}from"./BaS8d5lg.js";let is_store_binding=false;let IS_UNMOUNTED=Symbol();function store_get(store,store_name,stores){const entry=stores[store_name]??(stores[store_name]={store:null,source:mutable_source(void 0),unsubscribe:noop});if(entry.store!==store&&!(IS_UNMOUNTED in stores)){entry.unsubscribe();entry.store=store??null;if(store==null){entry.source.v=void 0;entry.unsubscribe=noop}else{var is_synchronous_callback=true;entry.unsubscribe=subscribe_to_store(store,v=>{if(is_synchronous_callback){entry.source.v=v}else{set(entry.source,v)}});is_synchronous_callback=false}}if(store&&IS_UNMOUNTED in stores){return get(store)}return get$1(entry.source)}function store_set(store,value){store.set(value);return value}function setup_stores(){const stores={};function cleanup(){teardown(()=>{for(var store_name in stores){const ref=stores[store_name];ref.unsubscribe()}define_property(stores,IS_UNMOUNTED,{enumerable:false,value:true})})}return[stores,cleanup]}function store_mutate(store,expression,new_value){store.set(new_value);return expression}function mark_store_binding(){is_store_binding=true}function capture_store_binding(fn){var previous_is_store_binding=is_store_binding;try{is_store_binding=false;return[fn(),is_store_binding]}finally{is_store_binding=previous_is_store_binding}}export{store_get as a,store_set as b,capture_store_binding as c,store_mutate as d,mark_store_binding as m,setup_stores as s};
//# sourceMappingURL=CViNpZsE.js.map
