{"version":3,"file":"BYboeQtC.js","sources":["../../../../../../../../node_modules/.pnpm/svelte@5.34.3/node_modules/svelte/src/internal/client/reactivity/props.js"],"sourcesContent":["/** @import { Derived, Source } from './types.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tPROPS_IS_BINDABLE,\n\tPROPS_IS_IMMUTABLE,\n\tPROPS_IS_LAZY_INITIAL,\n\tPROPS_IS_RUNES,\n\tPROPS_IS_UPDATED\n} from '../../../constants.js';\nimport { get_descriptor, is_function } from '../../shared/utils.js';\nimport { mutable_source, set, source, update } from './sources.js';\nimport { derived, derived_safe_equal } from './deriveds.js';\nimport { get, captured_signals, untrack } from '../runtime.js';\nimport { safe_equals } from './equality.js';\nimport * as e from '../errors.js';\nimport { LEGACY_DERIVED_PROP, LEGACY_PROPS, STATE_SYMBOL } from '#client/constants';\nimport { proxy } from '../proxy.js';\nimport { capture_store_binding } from './store.js';\nimport { legacy_mode_flag } from '../../flags/index.js';\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_prop(fn, d = 1) {\n\tconst value = fn();\n\tfn(value + d);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_prop(fn, d = 1) {\n\tconst value = fn() + d;\n\tfn(value);\n\treturn value;\n}\n\n/**\n * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).\n * Is passed the full `$$props` object and excludes the named props.\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}\n */\nconst rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\treturn target.props[key];\n\t},\n\tset(target, key) {\n\t\tif (DEV) {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.props_rest_readonly(`${target.name}.${String(key)}`);\n\t\t}\n\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @param {string} [name]\n * @returns {Record<string, unknown>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function rest_props(props, exclude, name) {\n\treturn new Proxy(\n\t\tDEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },\n\t\trest_props_handler\n\t);\n}\n\n/**\n * The proxy handler for legacy $$restProps and $$props\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number> }>}}\n */\nconst legacy_rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tget(target.version);\n\t\treturn key in target.special ? target.special[key]() : target.props[key];\n\t},\n\tset(target, key, value) {\n\t\tif (!(key in target.special)) {\n\t\t\t// Handle props that can temporarily get out of sync with the parent\n\t\t\t/** @type {Record<string, (v?: unknown) => unknown>} */\n\t\t\ttarget.special[key] = prop(\n\t\t\t\t{\n\t\t\t\t\tget [key]() {\n\t\t\t\t\t\treturn target.props[key];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/** @type {string} */ (key),\n\t\t\t\tPROPS_IS_UPDATED\n\t\t\t);\n\t\t}\n\n\t\ttarget.special[key](value);\n\t\tupdate(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun\n\t\treturn true;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\tdeleteProperty(target, key) {\n\t\t// Svelte 4 allowed for deletions on $$restProps\n\t\tif (target.exclude.includes(key)) return true;\n\t\ttarget.exclude.push(key);\n\t\tupdate(target.version);\n\t\treturn true;\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @returns {Record<string, unknown>}\n */\nexport function legacy_rest_props(props, exclude) {\n\treturn new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);\n}\n\n/**\n * The proxy handler for spread props. Handles the incoming array of props\n * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps\n * them so that the whole thing is passed to the component as the `$$props` argument.\n * @template {Record<string | symbol, unknown>} T\n * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}\n */\nconst spread_props_handler = {\n\tget(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return p[key];\n\t\t}\n\t},\n\tset(target, key, value) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tconst desc = get_descriptor(p, key);\n\t\t\tif (desc && desc.set) {\n\t\t\t\tdesc.set(value);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) {\n\t\t\t\tconst descriptor = get_descriptor(p, key);\n\t\t\t\tif (descriptor && !descriptor.configurable) {\n\t\t\t\t\t// Prevent a \"Non-configurability Report Error\": The target is an array, it does\n\t\t\t\t\t// not actually contain this property. If it is now described as non-configurable,\n\t\t\t\t\t// the proxy throws a validation error. Setting it to true avoids that.\n\t\t\t\t\tdescriptor.configurable = true;\n\t\t\t\t}\n\t\t\t\treturn descriptor;\n\t\t\t}\n\t\t}\n\t},\n\thas(target, key) {\n\t\t// To prevent a false positive `is_entry_props` in the `prop` function\n\t\tif (key === STATE_SYMBOL || key === LEGACY_PROPS) return false;\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (p != null && key in p) return true;\n\t\t}\n\n\t\treturn false;\n\t},\n\townKeys(target) {\n\t\t/** @type {Array<string | symbol>} */\n\t\tconst keys = [];\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (!p) continue;\n\n\t\t\tfor (const key in p) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\n\t\t\tfor (const key of Object.getOwnPropertySymbols(p)) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n};\n\n/**\n * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props\n * @returns {any}\n */\nexport function spread_props(...props) {\n\treturn new Proxy({ props }, spread_props_handler);\n}\n\n/**\n * @param {Derived} current_value\n * @returns {boolean}\n */\nfunction has_destroyed_component_ctx(current_value) {\n\treturn current_value.ctx?.d ?? false;\n}\n\n/**\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\n * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} key\n * @param {number} flags\n * @param {V | (() => V)} [fallback]\n * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}\n */\nexport function prop(props, key, flags, fallback) {\n\tvar immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;\n\tvar runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;\n\tvar bindable = (flags & PROPS_IS_BINDABLE) !== 0;\n\tvar lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;\n\tvar is_store_sub = false;\n\tvar prop_value;\n\n\tif (bindable) {\n\t\t[prop_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));\n\t} else {\n\t\tprop_value = /** @type {V} */ (props[key]);\n\t}\n\n\t// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`\n\t// or `createClassComponent(Component, props)`\n\tvar is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;\n\n\tvar setter =\n\t\t(bindable &&\n\t\t\t(get_descriptor(props, key)?.set ??\n\t\t\t\t(is_entry_props && key in props && ((v) => (props[key] = v))))) ||\n\t\tundefined;\n\n\tvar fallback_value = /** @type {V} */ (fallback);\n\tvar fallback_dirty = true;\n\tvar fallback_used = false;\n\n\tvar get_fallback = () => {\n\t\tfallback_used = true;\n\t\tif (fallback_dirty) {\n\t\t\tfallback_dirty = false;\n\t\t\tif (lazy) {\n\t\t\t\tfallback_value = untrack(/** @type {() => V} */ (fallback));\n\t\t\t} else {\n\t\t\t\tfallback_value = /** @type {V} */ (fallback);\n\t\t\t}\n\t\t}\n\n\t\treturn fallback_value;\n\t};\n\n\tif (prop_value === undefined && fallback !== undefined) {\n\t\tif (setter && runes) {\n\t\t\te.props_invalid_value(key);\n\t\t}\n\n\t\tprop_value = get_fallback();\n\t\tif (setter) setter(prop_value);\n\t}\n\n\t/** @type {() => V} */\n\tvar getter;\n\tif (runes) {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\t\t\tif (value === undefined) return get_fallback();\n\t\t\tfallback_dirty = true;\n\t\t\tfallback_used = false;\n\t\t\treturn value;\n\t\t};\n\t} else {\n\t\t// Svelte 4 did not trigger updates when a primitive value was updated to the same value.\n\t\t// Replicate that behavior through using a derived\n\t\tvar derived_getter = (immutable ? derived : derived_safe_equal)(\n\t\t\t() => /** @type {V} */ (props[key])\n\t\t);\n\t\tderived_getter.f |= LEGACY_DERIVED_PROP;\n\t\tgetter = () => {\n\t\t\tvar value = get(derived_getter);\n\t\t\tif (value !== undefined) fallback_value = /** @type {V} */ (undefined);\n\t\t\treturn value === undefined ? fallback_value : value;\n\t\t};\n\t}\n\n\t// easy mode — prop is never written to\n\tif ((flags & PROPS_IS_UPDATED) === 0 && runes) {\n\t\treturn getter;\n\t}\n\n\t// intermediate mode — prop is written to, but the parent component had\n\t// `bind:foo` which means we can just call `$$props.foo = value` directly\n\tif (setter) {\n\t\tvar legacy_parent = props.$$legacy;\n\t\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t\tif (arguments.length > 0) {\n\t\t\t\t// We don't want to notify if the value was mutated and the parent is in runes mode.\n\t\t\t\t// In that case the state proxy (if it exists) should take care of the notification.\n\t\t\t\t// If the parent is not in runes mode, we need to notify on mutation, too, that the prop\n\t\t\t\t// has changed because the parent will not be able to detect the change otherwise.\n\t\t\t\tif (!runes || !mutation || legacy_parent || is_store_sub) {\n\t\t\t\t\t/** @type {Function} */ (setter)(mutation ? getter() : value);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\treturn getter();\n\t\t\t}\n\t\t};\n\t}\n\n\t// hard mode. this is where it gets ugly — the value in the child should\n\t// synchronize with the parent, but it should also be possible to temporarily\n\t// set the value to something else locally.\n\tvar from_child = false;\n\tvar was_from_child = false;\n\n\t// The derived returns the current value. The underlying mutable\n\t// source is written to from various places to persist this value.\n\tvar inner_current_value = mutable_source(prop_value);\n\tvar current_value = derived(() => {\n\t\tvar parent_value = getter();\n\t\tvar child_value = get(inner_current_value);\n\n\t\tif (from_child) {\n\t\t\tfrom_child = false;\n\t\t\twas_from_child = true;\n\t\t\treturn child_value;\n\t\t}\n\n\t\twas_from_child = false;\n\t\treturn (inner_current_value.v = parent_value);\n\t});\n\n\t// Ensure we eagerly capture the initial value if it's bindable\n\tif (bindable) {\n\t\tget(current_value);\n\t}\n\n\tif (!immutable) current_value.equals = safe_equals;\n\n\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t// legacy nonsense — need to ensure the source is invalidated when necessary\n\t\t// also needed for when handling inspect logic so we can inspect the correct source signal\n\t\tif (captured_signals !== null) {\n\t\t\t// set this so that we don't reset to the parent value if `d`\n\t\t\t// is invalidated because of `invalidate_inner_signals` (rather\n\t\t\t// than because the parent or child value changed)\n\t\t\tfrom_child = was_from_child;\n\t\t\t// invoke getters so that signals are picked up by `invalidate_inner_signals`\n\t\t\tgetter();\n\t\t\tget(inner_current_value);\n\t\t}\n\n\t\tif (arguments.length > 0) {\n\t\t\tconst new_value = mutation ? get(current_value) : runes && bindable ? proxy(value) : value;\n\n\t\t\tif (!current_value.equals(new_value)) {\n\t\t\t\tfrom_child = true;\n\t\t\t\tset(inner_current_value, new_value);\n\t\t\t\t// To ensure the fallback value is consistent when used with proxies, we\n\t\t\t\t// update the local fallback_value, but only if the fallback is actively used\n\t\t\t\tif (fallback_used && fallback_value !== undefined) {\n\t\t\t\t\tfallback_value = new_value;\n\t\t\t\t}\n\n\t\t\t\tif (has_destroyed_component_ctx(current_value)) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\n\t\t\t\tuntrack(() => get(current_value)); // force a synchronisation immediately\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tif (has_destroyed_component_ctx(current_value)) {\n\t\t\treturn current_value.v;\n\t\t}\n\n\t\treturn get(current_value);\n\t};\n}\n"],"names":["rest_props_handler","get","target","key","exclude","includes","props","set","e.props_rest_readonly","name","String","getOwnPropertyDescriptor","enumerable","configurable","value","has","ownKeys","Reflect","filter","rest_props","Proxy","other","to_proxy","legacy_rest_props_handler","version","special","prop","PROPS_IS_UPDATED","update","deleteProperty","push","legacy_rest_props","source","spread_props_handler","i","length","p","is_function","desc","get_descriptor","descriptor","STATE_SYMBOL","LEGACY_PROPS","keys","Object","getOwnPropertySymbols","spread_props","has_destroyed_component_ctx","current_value","_a","ctx","d","flags","fallback","immutable","PROPS_IS_IMMUTABLE","runes","legacy_mode_flag","PROPS_IS_RUNES","bindable","PROPS_IS_BINDABLE","lazy","PROPS_IS_LAZY_INITIAL","is_store_sub","prop_value","capture_store_binding","is_entry_props","setter","v","fallback_value","fallback_dirty","fallback_used","get_fallback","untrack","e.props_invalid_value","getter","derived_getter","derived","derived_safe_equal","f","LEGACY_DERIVED_PROP","legacy_parent","$$legacy","mutation","arguments","from_child","was_from_child","inner_current_value","mutable_source","parent_value","child_value","equals","safe_equals","captured_signals","new_value","proxy"],"mappings":"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","x_google_ignoreList":[0]}