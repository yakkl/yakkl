var __defProp=Object.defineProperty;var __defNormalProp=(obj,key,value)=>key in obj?__defProp(obj,key,{enumerable:true,configurable:true,writable:true,value:value}):obj[key]=value;var __publicField=(obj,key,value)=>__defNormalProp(obj,typeof key!=="symbol"?key+"":key,value);import{l as log}from"./WDN37msH.js";const _AccountTokenCacheManager=class _AccountTokenCacheManager{constructor(){__publicField(this,"CACHE_KEY","yakkl_account_token_cache");__publicField(this,"CACHE_DURATION",15*60*1e3);__publicField(this,"STALE_DURATION",10*60*1e3);__publicField(this,"PORTFOLIO_CACHE_DURATION",20*60*1e3);__publicField(this,"cache",{});this.loadFromStorage()}static getInstance(){if(!_AccountTokenCacheManager.instance){_AccountTokenCacheManager.instance=new _AccountTokenCacheManager}return _AccountTokenCacheManager.instance}getCachedTokensForAccount(accountAddress){const account=this.cache[accountAddress.toLowerCase()];if(!account)return null;const age=Date.now()-account.lastUpdated;if(age>this.CACHE_DURATION){delete this.cache[accountAddress.toLowerCase()];this.saveToStorage();return null}return Array.from(account.tokens.values()).map(token=>{const{timestamp:timestamp,...tokenData}=token;return tokenData})}getCachedToken(accountAddress,tokenAddress){const account=this.cache[accountAddress.toLowerCase()];if(!account)return null;const token=account.tokens.get(tokenAddress.toLowerCase());if(!token)return null;const age=Date.now()-token.timestamp;if(age>this.CACHE_DURATION){account.tokens.delete(tokenAddress.toLowerCase());this.saveToStorage();return null}const{timestamp:timestamp,...tokenData}=token;return tokenData}isAccountTokensStale(accountAddress){const account=this.cache[accountAddress.toLowerCase()];if(!account)return false;const age=Date.now()-account.lastUpdated;return age>this.STALE_DURATION}isTokenStale(accountAddress,tokenAddress){const account=this.cache[accountAddress.toLowerCase()];if(!account)return false;const token=account.tokens.get(tokenAddress.toLowerCase());if(!token)return false;const age=Date.now()-token.timestamp;return age>this.STALE_DURATION}setCachedTokensForAccount(accountAddress,tokens){const normalizedAddress=accountAddress.toLowerCase();const timestamp=Date.now();if(!this.cache[normalizedAddress]){this.cache[normalizedAddress]={tokens:new Map,lastUpdated:timestamp}}this.cache[normalizedAddress].tokens.clear();this.cache[normalizedAddress].lastUpdated=timestamp;tokens.forEach(token=>{if(token.address){const cachedToken={...token,timestamp:timestamp,accountAddress:normalizedAddress};this.cache[normalizedAddress].tokens.set(token.address.toLowerCase(),cachedToken)}});this.saveToStorage();log.debug("[AccountTokenCacheManager] Cached tokens for account:",false,{address:normalizedAddress,tokenCount:tokens.length})}updateTokenForAccount(accountAddress,token){const normalizedAddress=accountAddress.toLowerCase();const timestamp=Date.now();if(!this.cache[normalizedAddress]){this.cache[normalizedAddress]={tokens:new Map,lastUpdated:timestamp}}if(token.address){const cachedToken={...token,timestamp:timestamp,accountAddress:normalizedAddress};this.cache[normalizedAddress].tokens.set(token.address.toLowerCase(),cachedToken);this.cache[normalizedAddress].lastUpdated=timestamp;this.saveToStorage();log.debug("[AccountTokenCacheManager] Updated token for account:",false,{address:normalizedAddress,tokenSymbol:token.symbol,tokenAddress:token.address})}}setCachedPortfolioValue(accountAddress,value,currency="USD"){const normalizedAddress=accountAddress.toLowerCase();if(!this.cache[normalizedAddress]){this.cache[normalizedAddress]={tokens:new Map,lastUpdated:Date.now()}}this.cache[normalizedAddress].portfolioValue=value;this.cache[normalizedAddress].portfolioValueCurrency=currency;this.saveToStorage();log.debug("[AccountTokenCacheManager] Cached portfolio value for account:",false,{address:normalizedAddress,value:value,currency:currency})}getCachedPortfolioValue(accountAddress){const account=this.cache[accountAddress.toLowerCase()];if(!account||account.portfolioValue===void 0)return null;const age=Date.now()-account.lastUpdated;if(age>this.PORTFOLIO_CACHE_DURATION){if(account.portfolioValue!==void 0){delete account.portfolioValue;delete account.portfolioValueCurrency;this.saveToStorage()}return null}return{value:account.portfolioValue,currency:account.portfolioValueCurrency||"USD"}}isPortfolioValueStale(accountAddress){const account=this.cache[accountAddress.toLowerCase()];if(!account||account.portfolioValue===void 0)return false;const age=Date.now()-account.lastUpdated;return age>this.STALE_DURATION}removeTokenFromAccount(accountAddress,tokenAddress){const account=this.cache[accountAddress.toLowerCase()];if(!account)return;account.tokens.delete(tokenAddress.toLowerCase());account.lastUpdated=Date.now();this.saveToStorage();log.debug("[AccountTokenCacheManager] Removed token from account cache:",false,{accountAddress:accountAddress.toLowerCase(),tokenAddress:tokenAddress.toLowerCase()})}clearAccountCache(accountAddress){delete this.cache[accountAddress.toLowerCase()];this.saveToStorage();log.info("[AccountTokenCacheManager] Cleared cache for account:",false,{address:accountAddress.toLowerCase()})}clearAllCache(){this.cache={};localStorage.removeItem(this.CACHE_KEY);log.info("[AccountTokenCacheManager] All cache cleared")}getCachedAccountAddresses(){return Object.keys(this.cache)}cleanupExpired(){const now=Date.now();let cleanedAccounts=0;let cleanedTokens=0;for(const[accountAddress,account]of Object.entries(this.cache)){if(now-account.lastUpdated>this.CACHE_DURATION){delete this.cache[accountAddress];cleanedAccounts++;continue}for(const[tokenAddress,token]of account.tokens.entries()){if(now-token.timestamp>this.CACHE_DURATION){account.tokens.delete(tokenAddress);cleanedTokens++}}if(account.portfolioValue!==void 0&&now-account.lastUpdated>this.PORTFOLIO_CACHE_DURATION){delete account.portfolioValue;delete account.portfolioValueCurrency}}if(cleanedAccounts>0||cleanedTokens>0){this.saveToStorage();log.info(`[AccountTokenCacheManager] Cleaned up ${cleanedAccounts} accounts and ${cleanedTokens} tokens`)}}preloadTokensForAccounts(accountAddresses){const preloaded=new Map;for(const address of accountAddresses){const tokens=this.getCachedTokensForAccount(address);if(tokens){preloaded.set(address.toLowerCase(),tokens)}}log.debug(`[AccountTokenCacheManager] Preloaded tokens for ${preloaded.size}/${accountAddresses.length} accounts`);return preloaded}updateTokenPricesForAllAccounts(priceUpdates){let updatedCount=0;for(const[accountAddress,account]of Object.entries(this.cache)){for(const[tokenAddress,token]of account.tokens.entries()){const priceUpdate=priceUpdates.get(tokenAddress);if(priceUpdate){token.price={price:priceUpdate.price,provider:"cache-update",lastUpdated:new Date};if(priceUpdate.change){token.change=priceUpdate.change}token.timestamp=Date.now();updatedCount++}}}if(updatedCount>0){this.saveToStorage();log.info(`[AccountTokenCacheManager] Updated prices for ${updatedCount} cached tokens`)}}getCacheStats(){const now=Date.now();let totalTokens=0;let fresh=0;let stale=0;let expired=0;for(const account of Object.values(this.cache)){totalTokens+=account.tokens.size;const age=now-account.lastUpdated;if(age>this.CACHE_DURATION){expired++}else if(age>this.STALE_DURATION){stale++}else{fresh++}}return{totalAccounts:Object.keys(this.cache).length,totalTokens:totalTokens,freshAccounts:fresh,staleAccounts:stale,expiredAccounts:expired}}loadFromStorage(){try{const stored=localStorage.getItem(this.CACHE_KEY);if(stored){const parsed=JSON.parse(stored);this.cache={};for(const[accountAddress,accountData]of Object.entries(parsed)){const typedAccountData=accountData;this.cache[accountAddress]={lastUpdated:typedAccountData.lastUpdated,portfolioValue:typedAccountData.portfolioValue,portfolioValueCurrency:typedAccountData.portfolioValueCurrency,tokens:new Map};if(typedAccountData.tokens){for(const[tokenAddress,tokenData]of Object.entries(typedAccountData.tokens)){const typedTokenData=tokenData;if(typedTokenData.balance&&typeof typedTokenData.balance==="string"){typedTokenData.balance=BigInt(typedTokenData.balance)}this.cache[accountAddress].tokens.set(tokenAddress,typedTokenData)}}}this.cleanupExpired();log.debug(`[AccountTokenCacheManager] Loaded cache for ${Object.keys(this.cache).length} accounts`)}}catch(error){log.warn("[AccountTokenCacheManager] Failed to load cache from storage:",false,error);this.cache={}}}saveToStorage(){try{const serializable={};for(const[accountAddress,account]of Object.entries(this.cache)){serializable[accountAddress]={lastUpdated:account.lastUpdated,portfolioValue:account.portfolioValue,portfolioValueCurrency:account.portfolioValueCurrency,tokens:{}};for(const[tokenAddress,token]of account.tokens.entries()){const serializableToken={...token};if(serializableToken.balance&&typeof serializableToken.balance==="bigint"){serializableToken.balance=serializableToken.balance.toString()}serializable[accountAddress].tokens[tokenAddress]=serializableToken}}localStorage.setItem(this.CACHE_KEY,JSON.stringify(serializable))}catch(error){log.warn("[AccountTokenCacheManager] Failed to save cache to storage:",false,error)}}};__publicField(_AccountTokenCacheManager,"instance",null);let AccountTokenCacheManager=_AccountTokenCacheManager;const accountTokenCacheManager=AccountTokenCacheManager.getInstance();export{accountTokenCacheManager as a};
//# sourceMappingURL=DNmXX2Qc.js.map
