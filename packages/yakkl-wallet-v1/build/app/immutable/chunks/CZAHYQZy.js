var __defProp=Object.defineProperty;var __defNormalProp=(obj,key,value)=>key in obj?__defProp(obj,key,{enumerable:true,configurable:true,writable:true,value:value}):obj[key]=value;var __publicField=(obj,key,value)=>__defNormalProp(obj,typeof key!=="symbol"?key+"":key,value);import{ap as fetchJson,aq as CoinbasePriceProvider}from"./Cb2naUpm.js";import{l as log}from"./WDN37msH.js";import"./CgCfpVku.js";import"./BaS8d5lg.js";import"./z-nmOEXa.js";import{i as splitWords}from"./CnIbzB-6.js";import"./Dw28gLPr.js";import"./D-aJ6pD4.js";class CoingeckoPriceProvider{getAPIKey(){return"CG-NXan3dhsnvnZG8NJrFjFAMDw"}getName(){return"Coingecko"}async getMarketPrice(pair){try{if(!pair){return{provider:this.getName(),price:0,lastUpdated:new Date,status:404,message:`Invalid pair - ${pair}`}}const[name,currencySymbol]=await this.getProviderPairFormat(pair);if(!name||!currencySymbol){return{provider:this.getName(),price:0,lastUpdated:new Date,status:404,message:`Invalid pair - ${pair}`}}const json=await fetchJson({url:`https://pro-api.coingecko.com/api/v3/simple/price?ids=${name}&include_last_updated_at=true&vs_currencies=${currencySymbol}`,headers:{Accept:"application/json","x-cg-pro-api-key":this.getAPIKey()}});const priceData=json[name.toLowerCase()];if(!priceData||!priceData[currencySymbol.toLowerCase()]){throw new Error("Invalid JSON structure or missing data from Coingecko")}return{provider:this.getName(),price:parseFloat(priceData[currencySymbol.toLowerCase()]),lastUpdated:new Date(priceData.last_updated_at*1e3),currency:currencySymbol,status:0,message:"Success"}}catch(e){log.error("CoingeckoPriceProvider - getPrice - error",e);let status=404;let message=`Error - ${e}`;if(e.response&&e.response.status===429){status=429;message="Too Many Requests - Rate limit exceeded"}return{provider:this.getName(),price:0,lastUpdated:new Date,status:status,message:message}}}async getProviderPairFormat(pair){let name="";const[symbol,currencySymbol]=splitWords(pair,"-");if(!symbol||!currencySymbol){return["",""]}switch(symbol){case"ETH":case"WETH":name="ethereum";break;case"BTC":name="bitcoin";break;case"USDC":name="usd-coin";break;case"DAI":name="dai";break;case"USDT":name="tether";break;case"BUSD":name="binance-usd";break;case"WBTC":name="wrapped-bitcoin";break;case"SOL":name="solana";break;case"MATIC":name="matic-network";break;case"BNB":name="binance-coin";break;case"AVAX":name="avalanche-2";break;default:name=symbol.toLowerCase();break}return[name,currencySymbol]}}class PriceManager{constructor(weightedProviders=PriceManager.getDefaultProviders()){__publicField(this,"weightedProviders");__publicField(this,"totalWeight");__publicField(this,"DEFAULT_WEIGHT",1);if(!weightedProviders||weightedProviders.length===0){throw new Error("At least one provider must be specified")}this.weightedProviders=this.normalizeWeights(weightedProviders);this.totalWeight=this.calculateTotalWeight()}static getDefaultProviders(){return[{provider:new CoinbasePriceProvider,weight:8},{provider:new CoingeckoPriceProvider,weight:5}]}normalizeWeights(providers){const allZeroWeights=providers.every(wp=>wp.weight===0);const allEqualWeights=providers.every(wp=>wp.weight===providers[0].weight);if(allZeroWeights||allEqualWeights){return providers.map(wp=>({...wp,weight:this.DEFAULT_WEIGHT}))}const smallestNonZeroWeight=Math.min(...providers.filter(wp=>wp.weight>0).map(wp=>wp.weight));return providers.map(wp=>({...wp,weight:wp.weight===0?smallestNonZeroWeight:wp.weight}))}calculateTotalWeight(){return this.weightedProviders.reduce((sum,wp)=>sum+wp.weight,0)}getAvailableProviders(){return this.weightedProviders.map(wp=>wp.provider)}async getMarketPrice(pair,availableProviders){let provider=null;let providersToUse=[];try{providersToUse=availableProviders||this.getAvailableProviders();if(providersToUse.length===0){throw new Error("No providers available to fetch market price")}provider=this.getWeightedRandomProvider(providersToUse);const price=await provider.getMarketPrice(pair);return price}catch(error){log.error(`Error fetching price from ${provider.getName()}:`,false,error);return this.getMarketPrice(pair,providersToUse.filter(p=>p!==provider))}}getWeightedRandomProvider(providers){if(!providers||providers.length===0){log.error("No providers available to fetch market price");throw new Error("No providers available to fetch market price")}if(providers.length===1){return providers[0]}try{const weightedProviders=this.weightedProviders.filter(wp=>providers.includes(wp.provider));const totalWeight=weightedProviders.reduce((sum,wp)=>sum+wp.weight,0);if(weightedProviders.every(wp=>wp.weight===weightedProviders[0].weight)){return weightedProviders[Math.floor(Math.random()*weightedProviders.length)].provider}let random=Math.random()*totalWeight;for(const wp of weightedProviders){if(random<wp.weight){return wp.provider}random-=wp.weight}return weightedProviders[0].provider}catch(error){log.error("Error selecting weighted random provider:",false,error);throw error}}}export{CoingeckoPriceProvider as C,PriceManager as P};
//# sourceMappingURL=CZAHYQZy.js.map
