{"version":3,"mappings":";yjBA6BO,MAAMA,YAAN,MAAMA,YAMJ,WAAAC,GAJkBC,cAAAC,KAAA,yBACED,cAAAC,KAAA,wBACCD,cAAAC,KAAA,oBAEP,CAEtB,kBAAOC,GACF,IAACJ,YAAWK,SAAU,CACdL,YAAAK,SAAW,IAAIL,WAAW,CAEtC,OAAOA,YAAWK,QAAA,CAMnB,mBAAMC,CACLC,OACAC,SACAC,UACAC,UAAoB,QACpBC,kBAA4B,IAExB,IACH,MAAMC,IAAMC,KAAKC,MAAMC,KAAKH,MAAQ,KAC9B,MAAAI,UAAYb,KAAKc,oBAEvB,MAAMC,OAAoB,CACzBC,IAAKhB,KAAKiB,UACVC,IAAK,OAGN,MAAMC,QAAsB,CAC3BC,IAAKhB,OACLiB,IAAKZ,IACLa,IAAKb,IAAMD,kBAAoB,GAC/Be,IAAKvB,KAAKwB,OACVC,IAAKzB,KAAK0B,SACVpB,oBACAD,kBACAE,oBACAM,qBAGD,MAAMc,cAAgB3B,KAAK4B,gBAAgBC,KAAKC,UAAUf,SAC1D,MAAMgB,eAAiB/B,KAAK4B,gBAAgBC,KAAKC,UAAUX,UAErD,MAAAa,gBAAkBhC,KAAKiC,kBAC5B,GAAGN,iBAAiBI,uBACd/B,KAAKkC,iBAGZ,MAAMC,MAAQ,GAAGR,iBAAiBI,kBAAkBC,YAEhDI,IAAAC,MAAM,sBAAuB,MAAO,CACvCjC,cACAC,kBACAG,oCACAK,sBAGM,OAAAsB,YACCG,OACJF,IAAAE,MAAM,gCAAiC,MAAOA,OAC5C,UAAIC,MAAM,0BAAyB,CAC1C,CAMD,mBAAMC,CAAcL,OACf,IACG,MAAAM,MAAQN,MAAMO,MAAM,KACtB,GAAAD,MAAME,SAAW,EAAG,CACjB,UAAIJ,MAAM,uBAAsB,CAGvC,MAAOZ,cAAeI,eAAgBC,WAAaS,MAG7C,MAAAG,iBAAmB5C,KAAKkC,gBACxB,MAAAW,wBAA0B7C,KAAKiC,kBACpC,GAAGN,iBAAiBI,iBACpBa,YAGD,GAAIZ,YAAca,kBAAmB,CAC9B,UAAIN,MAAM,0BAAyB,CAI1C,MAAMpB,QAAsBU,KAAKiB,MAAM9C,KAAK+C,gBAAgBhB,iBAG5D,MAAMtB,IAAMC,KAAKC,MAAMC,KAAKH,MAAQ,KAChC,GAAAU,QAAQG,KAAOb,IAAK,CACjB,UAAI8B,MAAM,gBAAe,CAIhC,GAAIpB,QAAQI,MAAQvB,KAAKwB,QAAUL,QAAQM,MAAQzB,KAAK0B,SAAU,CAC3D,UAAIa,MAAM,mCAAkC,CAG/CH,IAAAC,MAAM,mCAAoC,MAAO,CACpDjB,IAAKD,QAAQC,IACbf,SAAUc,QAAQd,SAClBQ,UAAWM,QAAQN,YAGb,OAAAM,cACCmB,OACJF,IAAAY,KAAK,+BAAgC,MAAOV,OACzC,YACR,CAMD,0BAAMW,CACLd,MACAe,wBAAkC,IAE9B,IACH,MAAM/B,cAAgBnB,KAAKwC,cAAcL,OACrC,IAAChB,QAAgB,YAErB,MAAMV,IAAMC,KAAKC,MAAMC,KAAKH,MAAQ,KAC9B,MAAA0C,gBAAkBhC,QAAQG,IAAMb,IAGlC,GAAA0C,iBAAmBD,wBAA0B,GAAI,CAChDd,IAAAC,MAAM,uBAAwB,MAAO,CACxCc,gCACAC,UAAWF,wBAA0B,KAGtC,aAAalD,KAAKG,cACjBgB,QAAQC,IACRD,QAAQd,UAAY,GACpBc,QAAQb,WAAa,GACrBa,QAAQZ,WAAa,QACtB,CAGM,OAAA4B,YACCG,OACJF,IAAAE,MAAM,2BAA4B,MAAOA,OACtC,YACR,CAMD,WAAAe,CAAYlB,OACP,IACG,MAAAM,MAAQN,MAAMO,MAAM,KACtB,GAAAD,MAAME,SAAW,EAAU,YAEzB,MAAA5B,OAASc,KAAKiB,MAAM9C,KAAK+C,gBAAgBN,MAAM,KAC/C,MAAAtB,QAAUU,KAAKiB,MAAM9C,KAAK+C,gBAAgBN,MAAM,KAE/C,OAAE1B,cAAQI,gBAAQ,CAClB,MACA,YACR,CAMD,sBAAAmC,CAAuBnB,OAChB,MAAAoB,QAAUvD,KAAKqD,YAAYlB,OAC7B,IAACoB,QAAgB,YAErB,MAAM9C,IAAMC,KAAKC,MAAMC,KAAKH,MAAQ,KACpC,OAAOC,KAAK8C,IAAI,EAAGD,QAAQpC,QAAQG,IAAMb,IAAG,CAMrC,iBAAAK,GACP,MAAM2C,UAAY7C,KAAKH,MAAMiD,SAAS,IAChC,MAAAC,OAASjD,KAAKiD,SAASD,SAAS,IAAIE,UAAU,GAC7C,SAAGH,aAAaE,QAAM,CAM9B,mBAAczB,GAGA,CACR,IACH,MAAQ2B,gCAAsBC,cAAAC,UAAA,MAAAF,gCAAAG,OAAO,iBAAoBC,KAAAC,KAAAC,IAAA,OAAAN,2BAAA,KAAAO,oCAAA,cAAAC,KACnD,MAAAC,eAAiBT,eAGjB,MAAAU,OAAA,IAAY3D,MAAO4D,cAAc9B,MAAM,KAAK,GAClD,MAAM+B,YAAc,IAAGH,UAAA,YAAAA,SAAUI,KAAM,aAAaH,sBAG9C,MAAAI,QAAU,IAAIC,YACd,MAAAC,KAAOF,QAAQG,OAAOL,aAC5B,MAAMM,iBAAmBC,OAAOC,OAAOC,OAAO,UAAWL,MACzD,MAAMM,UAAYC,MAAMC,KAAK,IAAIC,WAAWP,aAC5C,OAAOI,UAAUI,IAAKC,GAAMA,EAAE9B,SAAS,IAAI+B,SAAS,EAAG,MAAMC,KAAK,UAC1DpD,OACJF,IAAAY,KAAK,+DAAgE,MAAOV,MAAK,CACtF,CAIM,wDAMR,uBAAcL,CAAkB4C,KAAcc,KACvC,MAAAhB,QAAU,IAAIC,YACd,MAAAgB,QAAUjB,QAAQG,OAAOa,KACzB,MAAAE,YAAclB,QAAQG,OAAOD,MAE7B,MAAAiB,gBAAkBd,OAAOC,OAAOc,UACrC,MACAH,QACA,CAAEI,KAAM,OAAQC,KAAM,WACtB,MACA,CAAC,SAGF,MAAMjE,gBAAkBgD,OAAOC,OAAOiB,KAAK,OAAQJ,UAAWD,aAC9D,OAAO7F,KAAK4B,gBAAgB,IAAI0D,WAAWtD,WAAU,CAM9C,eAAAJ,CAAgBiD,MACjB,MAAAsB,aAAetB,OAAS,UAAW,IAAID,aAAcE,OAAOD,MAAQA,KAC1E,MAAMuB,OAASC,KAAKC,OAAOC,gBAAgBJ,QACpC,OAAAC,OAAOI,QAAQ,MAAO,KAAKA,QAAQ,MAAO,KAAKA,QAAQ,KAAM,GAAE,CAM/D,eAAAzD,CAAgB8B,MACjB,MAAAuB,OAASvB,KAAK2B,QAAQ,KAAM,KAAKA,QAAQ,KAAM,KAC/C,MAAAC,OAASL,OAAOM,OAAON,OAAOzD,QAAW,EAAKyD,OAAOzD,OAAS,GAAM,EAAI,KAC9E,OAAOgE,KAAKF,OAAM,GAjQnB1G,cADYF,YACG,WAA8B,MADvC,IAAM+G,WAAN/G,YAuQM,MAAAgH,WAAaD,WAAW3G,cCpQrC,MAAM6G,eAAgC,CACrCC,eAAgB,GAChBC,eAAgB,EAChBC,qBAAsB,GACtBC,qBAAsB,KACtBC,qBAAsB,IAGhB,MAAMC,gBAAN,MAAMA,gBAaJ,WAAAtH,GAXwBC,cAAAC,KAAA,SAAA8G,gBACY/G,cAAAC,KAAA,qBACiBD,cAAAC,KAAA,qBACAD,cAAAC,KAAA,qBAC5BD,cAAAC,KAAA,gCAGoCD,cAAAC,KAAA,yBACrBD,cAAAC,KAAA,yBACCD,cAAAC,KAAA,0BAGhDA,KAAKqH,uBAAsB,CAG5B,kBAAOpH,GACF,IAACmH,gBAAelH,SAAU,CACdkH,gBAAAlH,SAAW,IAAIkH,eAAe,CAE9C,OAAOA,gBAAelH,QAAA,CAMvB,kBAAMoH,CACLlH,OACAC,SACAC,UACAC,UAAoB,SAEhB,IAEG,MAAAgH,eAAiBV,WAAW1G,cACjCC,OACAC,SACAC,UACAC,UACAP,KAAKwH,OAAOL,sBAGP,MAAA1G,IAAMG,KAAKH,MACX,MAAAI,UAAYb,KAAKc,oBAEvBd,KAAKyH,aAAe,CACnBC,SAAU,KACVtH,cACAC,kBACAC,oBACAC,oBACAM,oBACA8G,aAAclH,IACdmH,UAAWnH,IAAMT,KAAKwH,OAAOT,eAAiB,GAAK,IACnDQ,kBACAM,aAAc,aAGT7H,KAAK8H,mBACX9H,KAAK+H,wBACL/H,KAAKgI,kBAED5F,IAAAC,MAAM,kBAAmB,MAAO,CACnCjC,cACAC,kBACAQ,oBACA+G,UAAW,IAAIhH,KAAKZ,KAAKyH,aAAaG,aAIvC,GAAIK,SAAWC,YAAa,CAC3BlI,KAAKmI,uBAAuB,kBAAmB,CAC9CtH,oBACA+G,UAAW5H,KAAKyH,aAAaG,WAC7B,CAGK,OAAAL,eACCjF,OACJF,IAAAE,MAAM,2BAA4B,MAAOA,OACvC,UAAIC,MAAM,uBAAsB,CACvC,CAMD,mBAAM6F,CAAcC,kBAA4B,IAC/C,IAAKrI,KAAKyH,eAAiBzH,KAAKyH,aAAaC,SAAU,CAChD,UAAInF,MAAM,8BAA6B,CAG1C,IACG,MAAA9B,IAAMG,KAAKH,MACX,MAAA6H,aAAe7H,IAAM4H,kBAAoB,GAAK,IAGhD,GAAArI,KAAKyH,aAAaF,SAAU,CACzB,MAAAgB,qBAAuB1B,WAAW5D,qBACvCjD,KAAKyH,aAAaF,SAClB,IAGD,GAAIgB,gBAAkBA,iBAAmBvI,KAAKyH,aAAaF,SAAU,CACpEvH,KAAKyH,aAAaF,SAAWgB,eACzBnG,IAAAC,MAAM,+CAAgD,MAAK,CAChE,CAGDrC,KAAKyH,aAAaE,aAAelH,IACjCT,KAAKyH,aAAaG,UAAYU,aAC9BtI,KAAKyH,aAAaI,aAAe,YAE3B7H,KAAK8H,mBACX9H,KAAKwI,cACLxI,KAAKgI,kBAED5F,IAAAC,MAAM,mBAAoB,MAAO,CACpCxB,UAAWb,KAAKyH,aAAa5G,UAC7BwH,oCACAC,aAAc,IAAI1H,KAAK0H,gBAGxB,GAAItI,KAAKyI,kBAAmB,CAC3BzI,KAAKyI,mBAAkB,CAIxB,GAAIR,SAAWC,YAAa,CAC3BlI,KAAKmI,uBAAuB,mBAAoB,CAC/CtH,UAAWb,KAAKyH,aAAa5G,UAC7B+G,UAAWU,cACX,QAEMhG,OACJF,IAAAE,MAAM,4BAA6B,MAAOA,OACxC,UAAIC,MAAM,2BAA0B,CAC3C,CAMD,gBAAMmG,GACL,GAAI1I,KAAKyH,aAAc,CAClBrF,IAAAC,MAAM,iBAAkB,MAAO,CAClCxB,UAAWb,KAAKyH,aAAa5G,YAI9B,GAAeqH,YAAa,CAC3BlI,KAAKmI,uBAAuB,gBAAiB,CAC5CtH,UAAWb,KAAKyH,aAAa5G,WAC7B,CACF,CAGDb,KAAKyH,aAAe,KACpBzH,KAAKwI,cACLxI,KAAK2I,0BAED,UACG3I,KAAK4I,4BACHtG,OACJF,IAAAY,KAAK,mCAAoC,MAAOV,MAAK,CAG1D,GAAItC,KAAK6I,iBAAkB,CAC1B7I,KAAK6I,kBAAiB,CACvB,CAMD,eAAAC,GACC,OAAO9I,KAAKyH,aAAe,IAAKzH,KAAKyH,cAAiB,KAMvD,kBAAAsB,UACQ,QAAAC,GAAAhJ,KAAKyH,eAAL,YAAAuB,GAAmBzB,WAAY,KAMvC,eAAA0B,GACC,IAAKjJ,KAAKyH,eAAiBzH,KAAKyH,aAAaC,SAAU,CAC/C,aAGF,MAAAjH,IAAMG,KAAKH,MACb,GAAAA,KAAOT,KAAKyH,aAAaG,UAAW,CACvC5H,KAAK0I,aACE,aAGD,YAMR,cAAAQ,GACC,IAAKlJ,KAAKyH,eAAiBzH,KAAKyH,aAAaC,SAAU,OAEjD,MAAAjH,IAAMG,KAAKH,MACjBT,KAAKyH,aAAaE,aAAelH,IAG7B,GAAAT,KAAKwH,OAAON,qBAAsB,CAC/B,MAAA/D,gBAAkBnD,KAAKyH,aAAaG,UAAYnH,IACtD,MAAM0I,iBAAmBnJ,KAAKwH,OAAOR,eAAiB,GAAK,IAE3D,GAAI7D,iBAAmBgG,mBAAqBnJ,KAAKyH,aAAaI,aAAc,CACtE7H,KAAAoI,cAAcpI,KAAKwH,OAAOT,eAAc,CAC9C,CAGD/G,KAAK8H,kBAAiB,CAMvB,YAAAsB,CAAaC,WAKPrJ,KAAAsJ,iBAAmBD,UAAUE,WAAa,KAC1CvJ,KAAA6I,iBAAmBQ,UAAUG,WAAa,KAC1CxJ,KAAAyI,kBAAoBY,UAAUI,YAAc,KAMlD,YAAAC,CAAaC,WACZ3J,KAAKwH,OAAS,IAAKxH,KAAKwH,UAAWmC,WACnCvH,IAAIC,MAAM,yBAA0B,MAAOrC,KAAKwH,OAAM,CAMvD,2BAAcH,GAGT,IACG,MAAAuC,aAAe5J,KAAK6J,mBACtB,GAAAD,QAAUA,OAAOlC,SAAU,CACxB,MAAAjH,IAAMG,KAAKH,MAGb,GAAAA,IAAMmJ,OAAOhC,UAAW,CAC3B5H,KAAKyH,aAAemC,OACpB5J,KAAK+H,wBACL/H,KAAKgI,kBAED5F,IAAAC,MAAM,gCAAiC,MAAO,CACjDxB,UAAW+I,OAAO/I,UAClBiJ,cAAepJ,KAAKqJ,OAAOH,OAAOhC,UAAYnH,KAAO,MACrD,KACK,OAEAT,KAAK4I,sBACPxG,IAAAC,MAAM,uCAAwC,MAAK,CACxD,QAEOC,OACJF,IAAAY,KAAK,6CAA8C,MAAOV,MAAK,CACpE,CAMO,eAAA0F,GACH,IAAChI,KAAKyH,aAAc,OAElB,MAAAhH,IAAMG,KAAKH,MACX,MAAAuJ,iBACLhK,KAAKyH,aAAaG,UAAYnH,IAAMT,KAAKwH,OAAOR,eAAiB,GAAK,IAEvE,GAAIgD,iBAAmB,EAAG,CACpBhK,KAAAiK,aAAeC,WAAW,KAC9BlK,KAAKmK,sBACHH,iBAAgB,KACb,CAENhK,KAAKmK,oBAAmB,CACzB,CAMO,kBAAAA,GACP,IAAKnK,KAAKyH,cAAgBzH,KAAKyH,aAAaI,aAAc,OAE1D7H,KAAKyH,aAAaI,aAAe,KAE3B,MAAApH,IAAMG,KAAKH,MACX,MAAAqJ,cAAgBpJ,KAAK8C,IAAI,EAAG9C,KAAKqJ,OAAO/J,KAAKyH,aAAaG,UAAYnH,KAAO,MAEnF2B,IAAIC,MAAM,0BAA2B,MAAO,CAAEyH,8BAE9C,GAAI9J,KAAKsJ,iBAAkB,CAC1BtJ,KAAKsJ,iBAAiBQ,cAAa,CAI/B9J,KAAAoK,aAAeF,WAAW,KAC9BlK,KAAK0I,cACHoB,cAAgB,IAAI,CAMhB,qBAAA/B,GACH,GAAY/H,KAAKqK,uBAAwB,OAE7C,MAAMC,OAAS,CAAC,YAAa,UAAW,SAAU,aAAc,aAC1D,MAAAC,eAAiB,IAAMvK,KAAKkJ,iBAE3BoB,OAAAE,QAASC,QACfC,SAASC,iBAAiBF,MAAOF,eAAgB,CAAEK,QAAS,SAG7D5K,KAAKqK,uBAAyB,KAC1BjI,IAAAC,MAAM,4BAA6B,MAAK,CAMrC,uBAAAsG,GACS,IAAC3I,KAAKqK,uBAAwB,OAE9C,MAAMC,OAAS,CAAC,YAAa,UAAW,SAAU,aAAc,aAC1D,MAAAC,eAAiB,IAAMvK,KAAKkJ,iBAE3BoB,OAAAE,QAASC,QACNC,SAAAG,oBAAoBJ,MAAOF,kBAGrCvK,KAAKqK,uBAAyB,MAC1BjI,IAAAC,MAAM,4BAA6B,MAAK,CAMrC,WAAAmG,GACP,GAAIxI,KAAKoK,aAAc,CACtBU,aAAa9K,KAAKoK,cAClBpK,KAAKoK,aAAe,KAErB,GAAIpK,KAAKiK,aAAc,CACtBa,aAAa9K,KAAKiK,cAClBjK,KAAKiK,aAAe,KACrB,CAMO,iBAAAnJ,GACP,MAAM2C,UAAY7C,KAAKH,MAAMiD,SAAS,IAChC,MAAAC,OAASjD,KAAKiD,SAASD,SAAS,IAAIE,UAAU,GAC7C,iBAAWH,aAAaE,QAAM,CAMtC,sBAAcmE,GACG,IAAC9H,KAAKyH,aAAc,OAEhC,IACH,GAAIS,YAAa,OACVA,YAAY6C,QAAQC,MAAMC,IAAI,CACnCC,aAAclL,KAAKyH,cACnB,KACK,CACN0D,aAAaC,QAAQ,eAAgBvJ,KAAKC,UAAU9B,KAAKyH,cAAa,QAE/DnF,OACJF,IAAAY,KAAK,gCAAiC,MAAOV,MAAK,CACvD,CAMD,sBAAcuH,GAGT,IACH,GAAI3B,YAAa,CACV,MAAAmD,aAAenD,YAAY6C,QAAQC,MAAMM,IAAI,CAAC,iBACpD,OAAQD,OAAOH,cAAiC,SAC1C,CACA,MAAAtB,OAASuB,aAAaI,QAAQ,gBACpC,OAAO3B,OAAS/H,KAAKiB,MAAM8G,QAAU,YAE9BtH,OACJF,IAAAY,KAAK,gCAAiC,MAAOV,OAC1C,YACR,CAMD,yBAAcsG,GAGT,IACH,GAAIV,YAAa,OACVA,YAAY6C,QAAQC,MAAMQ,OAAO,CAAC,gBAAe,KACjD,CACNL,aAAaM,WAAW,eAAc,QAE/BnJ,OACJF,IAAAY,KAAK,mCAAoC,MAAOV,MAAK,CAC1D,CAMO,sBAAA6F,CAAuBuD,KAAc7G,MACxC,IAAaqD,YAAa,OAE1B,IACHA,YAAYyD,QAAQC,YAAY,CAC/BF,KAAM,WAAWA,OACjB7G,kBAEOvC,OACJF,IAAAY,KAAK,sCAAuC,MAAOV,MAAK,CAC7D,GA/bDvC,cADYqH,gBACG,WAAkC,MAD3C,IAAMyE,eAANzE,gBAqcM,MAAA0E,eAAiBD,eAAe5L,cCvd7C,MAAM8L,iBAA8B,CACnCC,gBAAiB,MACjBC,aAAc,MACdC,QAAS,KACTvE,aAAc/G,KAAKH,MACnB0L,eAAgB,GAChBC,eAAgB,MAChB3E,aAAc,KACdF,SAAU,KACV4C,mBAAoB,MACpBkC,qBAAsB,GAGvB,SAASC,kBACR,MAAMC,UAAEA,UAAWtB,QAAAuB,OAAKA,QAAWC,SAAoBV,kBAEvD,IAAI1B,uBAAyB,MAG7B,SAASqC,wBACRZ,eAAe1C,aAAa,CAC3BG,UAAYO,gBACX0C,OAAQG,QAAW,IACfA,MACHxC,mBAAoB,KACpBkC,qBAAsBvC,iBAEvB1H,IAAIC,MAAM,4BAA6B,MAAO,CAAEyH,+BAEjDN,UAAW,KACVgD,OAAQG,QAAW,IACfA,MACHX,gBAAiB,MACjBvE,aAAc,KACdF,SAAU,KACV4C,mBAAoB,MACpB+B,QAAS,QAEVU,aAAa,IACTxK,IAAAC,MAAM,kBAAmB,QAE9BoH,WAAY,KACL,MAAAoD,gBAAkBf,eAAehD,kBACvC0D,OAAQG,QAAW,IACfA,MACHlF,aAAcoF,gBACdtF,UAAUsF,6CAAiBtF,WAAY,KACvC4C,mBAAoB,MACpBxC,aAAc/G,KAAKH,SAEhB2B,IAAAC,MAAM,mBAAoB,SAE/B,CAIF,SAASyK,uBACJ,IAAYzC,uBAAwB,CACvC,MAAMC,OAAS,CAAC,YAAa,UAAW,SAAU,aAAc,aAEhE,MAAMpB,eAAiB,KACfsD,OAACG,YAAgBA,MAAOhF,aAAc/G,KAAKH,UAG5C6J,OAAAE,QAASC,QACfC,SAASC,iBAAiBF,MAAOvB,eAAgB,CAAE0B,QAAS,SAGpCP,uBAAA,KAC1B,CAGM,OACNkC,oBAEA,gBAAMQ,UACD,IACHP,OAAQG,QAAW,IAAKA,MAAOP,eAAgB,QAEzC,MAAA9H,eAAiBT,cACvB,MAAMmJ,UAAYC,eAElB,MAAMhB,kBAAkB3H,+BAAU4I,SAAQlE,GAAA1E,UAAA,YAAAA,SAAU6I,QAAV,UAAiB,EAAAnE,GAAAoE,cAC3D,MAAMpB,oBAAqBgB,WAAaA,UAAUrK,OAAS,GAE3D6J,OAAQG,QAAW,IACfA,MACHV,2BACAD,iCACArE,aAAc/G,KAAKH,MACnB2L,eAAgB,SAIIU,uBAGCJ,wBAGhBjF,oBAAeqE,eAAehD,kBAChCrB,kBAAgBqE,eAAe7C,kBAAmB,CACrDuD,OAAQG,QAAW,IACfA,MACHlF,2BACAF,SAAUE,cAAaF,SACvByE,gBAAiB,OAChB,CAGC5J,IAAAC,MAAM,yBAA0B,MAAO,CAAE4J,2BAAcD,yCACnD1J,OACJF,IAAAE,MAAM,iCAAkC,MAAOA,OACnDkK,OAAQG,QAAW,IACfA,MACHP,eAAgB,MAChBJ,gBAAiB,MACjBC,aAAc,QACb,CAEJ,EAEA,WAAMoB,CAAMhN,SAAkBiN,iBACzB,IAEG,MAAAC,mBAAqBlN,SAASmN,cAAcC,OAAOjH,QAAQ,UAAW,IACtE,MAAAkH,YAAcH,mBAAqB,UAAYD,SAG/C,MAAApB,cAAgByB,OAAOD,aAE7B,IAAKxB,QAAS,CACP,UAAI3J,MAAM,2CAA0C,CAI3D,MAAM2C,OAAS+H,eACf,IAAK/H,OAAQ,CACN,UAAI3C,MAAM,kEAAiE,CAI5E,MAAA+B,eAAiBT,cACjB,MAAAtD,YAAYyI,GAAA1E,UAAA,YAAAA,SAAUsJ,OAAV,YAAA5E,GAAgB0C,OAAQ,QAGpCnE,sBAAiBuE,eAAexE,aACrC4E,QAAQxH,IAAMwH,QAAQ2B,SACtB3B,QAAQ2B,SACR3B,QAAQxH,IAAMwH,QAAQ2B,SACtBtN,WAGKkH,oBAAeqE,eAAehD,kBAEpC0D,OAAQG,QAAW,IACfA,MACHX,gBAAiB,KACjBE,gBACAvE,aAAc/G,KAAKH,MACnBgH,2BACAF,sBAGGnF,IAAAC,MAAM,8BAA+B,MAAO,CAC/ChC,SAAUkN,mBACV1M,UAAW4G,eAAc,YAAAqG,cAAAjN,YAEnB,OAAAqL,cACC5J,OACJF,IAAAE,MAAM,gBAAiB,MAAOA,OAC5B,MAAAA,KAAA,CAER,EAEA,YAAMyL,GACD,UAEGjC,eAAepD,aAErBkE,aAAa,IACbJ,OAAQG,QAAW,IACfA,MACHX,gBAAiB,MACjBE,QAAS,KACTvE,aAAc/G,KAAKH,MACnBgH,aAAc,KACdF,SAAU,KACV4C,mBAAoB,SAEjB/H,IAAAC,MAAM,kBAAmB,aACrBC,OACJF,IAAAE,MAAM,uBAAwB,MAAOA,MAAK,CAEhD,EAEA,YAAA0L,GACK,IACG,MAAArB,MAAQrB,IAAI2C,WACZ,MAAAxN,IAAMG,KAAKH,MACX,MAAAyN,UAAYvB,MAAMR,eAAiB,GAAK,IAE9C,GAAIQ,MAAMX,iBAAmBvL,IAAMkM,MAAMhF,aAAeuG,UAAW,CAC9D9L,IAAAY,KAAK,oCAAqC,OAC9ChD,KAAK+N,SACE,aAER,OAAOpB,MAAMX,sBACL1J,OACJF,IAAAE,MAAM,0BAA2B,MAAOA,OACrC,aAET,EAEA,kBAAA6L,GACQ3B,OAACG,YAAgBA,MAAOhF,aAAc/G,KAAKH,QACnD,EAEA,iBAAA2N,CAAkBC,SACjB7B,OAAQG,QAAW,IAAKA,MAAOR,eAAgBkC,UAChD,EAGA,+BAAMC,UACD,IACG,MAAAhK,eAAiBT,cACvB,MAAMoI,kBAAkB3H,+BAAU4I,SAAQlE,GAAA1E,UAAA,YAAAA,SAAU6I,QAAV,UAAiB,EAAAnE,GAAAoE,cAE3DZ,OAAQG,QAAW,IAAKA,MAAOV,8BACxBA,2BACC3J,OACJF,IAAAE,MAAM,wCAAyC,MAAOA,OACnD,aAET,EAGA,mBAAM8F,CAAcC,kBAA4B,IAC3C,UACGyD,eAAe1D,cAAcC,mBAE7BZ,oBAAeqE,eAAehD,kBACpC0D,OAAQG,QAAW,IACfA,MACHlF,2BACAF,UAAUE,yCAAcF,WAAY,KACpC4C,mBAAoB,MACpBxC,aAAc/G,KAAKH,eAEZ6B,OACJF,IAAAE,MAAM,4BAA6B,MAAOA,OACxC,MAAAA,KAAA,CAER,EAEA,qBAAAiM,GACC/B,OAAQG,QAAW,IACfA,MACHxC,mBAAoB,QAEtB,EAEA,kBAAApB,GACO,MAAA4D,MAAQrB,IAAI2C,WAClB,OAAOtB,MAAMpF,QACd,EAEA,uBAAAiH,GACO,MAAA7B,MAAQrB,IAAI2C,WACd,IAACtB,MAAMlF,aAAqB,SAE1B,MAAAhH,IAAMG,KAAKH,MACV,OAAAC,KAAK8C,IAAI,EAAG9C,KAAKqJ,OAAO4C,MAAMlF,aAAaG,UAAYnH,KAAO,KAAK,EAG7E,CAEO,MAAMwN,UAAY3B,kBAGlB,MAAMN,gBAAkByC,QAAQR,UAAYS,OAAUA,MAAM1C,iBACvCyC,QAAQR,UAAYS,OAAUA,MAAMzC,cACrCwC,QAAQR,UAAYS,OAAUA,MAAMxC,SACnCuC,QAAQR,UAAYS,OAAUA,MAAM/G,cAC9B8G,QAAQR,UAAYS,OAAUA,MAAMtC,gBAG1CqC,QAAQR,UAAYS,OAAUA,MAAMjH,cACxCgH,QAAQR,UAAYS,OAAUA,MAAMnH,UACrD,MAAM4C,mBAAqBsE,QAAQR,UAAYS,OAAUA,MAAMvE,oBAC/D,MAAMkC,qBAAuBoC,QAAQR,UAAYS,OAAUA,MAAMrC,sBAC7CoC,QAAQR,UAAYS,QAC1C,IAACA,MAAMnH,SAAiB,aAExB,IACH,MAAMhE,QAAUsD,WAAWxD,YAAYqL,MAAMnH,UACzC,IAAChE,QAAgB,aAErB,MAAM9C,IAAMC,KAAKC,MAAMC,KAAKH,MAAQ,KAC7B,OAAA8C,QAAQpC,QAAQG,IAAMb,GAAA,CACtB,MACA,gBAUI,CACZwN,UAAUlB,aAAa4B,MAAOrM,QACzBF,IAAAE,MAAM,wCAAyC,MAAOA,QAE5D","names":["_JWTManager","constructor","__publicField","this","getInstance","instance","generateToken","userId","username","profileId","planLevel","expirationMinutes","now","Math","floor","Date","sessionId","generateSessionId","header","alg","algorithm","typ","payload","sub","iat","exp","iss","issuer","aud","audience","encodedHeader","base64UrlEncode","JSON","stringify","encodedPayload","signature","generateSignature","getSigningKey","token","log","debug","error","Error","validateToken","parts","split","length","signingKey","expectedSignature","parse","base64UrlDecode","warn","refreshTokenIfNeeded","refreshThresholdMinutes","timeUntilExpiry","threshold","decodeToken","getTimeUntilExpiration","decoded","max","timestamp","toString","random","substring","getSettings","__vitePreload","async","import","then","n","dg","__VITE_PRELOAD__","url","settings","today","toISOString","keyMaterial","id","encoder","TextEncoder","data","encode","hashBuffer","crypto","subtle","digest","hashArray","Array","from","Uint8Array","map","b","padStart","join","key","keyData","messageData","cryptoKey","importKey","name","hash","sign","input","base64","btoa","String","fromCharCode","replace","padded","padEnd","atob","JWTManager","jwtManager","DEFAULT_CONFIG","timeoutMinutes","warningMinutes","maxInactivityMinutes","autoExtendOnActivity","jwtExpirationMinutes","_SessionManager","initializeFromStorage","startSession","jwtToken","config","sessionState","isActive","lastActivity","expiresAt","warningShown","saveSessionState","startActivityTracking","scheduleWarning","browser","browser_ext","notifyBackgroundScript","extendSession","additionalMinutes","newExpiresAt","refreshedToken","clearTimers","onSessionExtended","endSession","removeActivityListeners","clearSessionStorage","onSessionExpired","getSessionState","getCurrentJWTToken","_a","isSessionActive","updateActivity","warningThreshold","setCallbacks","callbacks","onSessionWarning","onWarning","onExpired","onExtended","updateConfig","newConfig","stored","loadSessionState","timeRemaining","round","timeUntilWarning","warningTimer","setTimeout","showSessionWarning","timeoutTimer","activityListenersAdded","events","handleActivity","forEach","event","document","addEventListener","passive","removeEventListener","clearTimeout","storage","local","set","yakklSession","localStorage","setItem","result","get","getItem","remove","removeItem","type","runtime","sendMessage","SessionManager","sessionManager","defaultAuthState","isAuthenticated","isRegistered","profile","sessionTimeout","isInitializing","sessionTimeRemaining","createAuthStore","subscribe","update","writable","setupSessionCallbacks","state","setMiscStore","newSessionState","addActivityListeners","initialize","miscStore","getMiscStore","init","legal","termsAgreed","login","password","normalizedUsername","toLowerCase","trim","loginString","verify","plan","userName","sessionState2","logout","checkSession","authStore","timeoutMs","updateLastActivity","setSessionTimeout","minutes","refreshRegistrationStatus","dismissSessionWarning","getSessionTimeRemaining","derived","$auth","catch"],"ignoreList":[],"sources":["../../../../../../src/lib/utilities/jwt.ts","../../../../../../src/lib/managers/SessionManager.ts","../../../../../../src/lib/stores/auth-store.ts"],"sourcesContent":["/**\n * JWT Token Utilities for YAKKL Wallet\n * Handles JWT token generation and validation for Cloudflare Workers API authentication\n *\n * Note: This manager uses Svelte stores and is for client contexts only.\n * For background/service worker contexts, use jwt-background.ts instead.\n */\n\nimport { browser } from '$app/environment';\nimport { log } from '$lib/common/logger-wrapper';\nimport { backgroundJWTManager } from './jwt-background';\n\nexport interface JWTPayload {\n\tsub: string; // Subject (user ID)\n\tiat: number; // Issued at\n\texp: number; // Expiration time\n\tiss: string; // Issuer\n\taud: string; // Audience\n\tprofileId?: string; // YAKKL profile ID\n\tusername?: string; // YAKKL username\n\tplanLevel?: string; // User's plan level\n\tsessionId?: string; // Session identifier\n}\n\nexport interface JWTHeader {\n\talg: string;\n\ttyp: string;\n}\n\nexport class JWTManager {\n\tprivate static instance: JWTManager | null = null;\n\tprivate readonly issuer = 'yakkl-wallet';\n\tprivate readonly audience = 'yakkl-api';\n\tprivate readonly algorithm = 'HS256';\n\n\tprivate constructor() {}\n\n\tstatic getInstance(): JWTManager {\n\t\tif (!JWTManager.instance) {\n\t\t\tJWTManager.instance = new JWTManager();\n\t\t}\n\t\treturn JWTManager.instance;\n\t}\n\n\t/**\n\t * Generate a JWT token for API authentication\n\t */\n\tasync generateToken(\n\t\tuserId: string,\n\t\tusername: string,\n\t\tprofileId: string,\n\t\tplanLevel: string = 'basic',\n\t\texpirationMinutes: number = 60\n\t): Promise<string> {\n\t\ttry {\n\t\t\tconst now = Math.floor(Date.now() / 1000);\n\t\t\tconst sessionId = this.generateSessionId();\n\n\t\t\tconst header: JWTHeader = {\n\t\t\t\talg: this.algorithm,\n\t\t\t\ttyp: 'JWT'\n\t\t\t};\n\n\t\t\tconst payload: JWTPayload = {\n\t\t\t\tsub: userId,\n\t\t\t\tiat: now,\n\t\t\t\texp: now + expirationMinutes * 60,\n\t\t\t\tiss: this.issuer,\n\t\t\t\taud: this.audience,\n\t\t\t\tprofileId,\n\t\t\t\tusername,\n\t\t\t\tplanLevel,\n\t\t\t\tsessionId\n\t\t\t};\n\n\t\t\tconst encodedHeader = this.base64UrlEncode(JSON.stringify(header));\n\t\t\tconst encodedPayload = this.base64UrlEncode(JSON.stringify(payload));\n\n\t\t\tconst signature = await this.generateSignature(\n\t\t\t\t`${encodedHeader}.${encodedPayload}`,\n\t\t\t\tawait this.getSigningKey()\n\t\t\t);\n\n\t\t\tconst token = `${encodedHeader}.${encodedPayload}.${signature}`;\n\n\t\t\tlog.debug('JWT token generated', false, {\n\t\t\t\tuserId,\n\t\t\t\tusername,\n\t\t\t\texpirationMinutes,\n\t\t\t\tsessionId\n\t\t\t});\n\n\t\t\treturn token;\n\t\t} catch (error) {\n\t\t\tlog.error('Failed to generate JWT token:', false, error);\n\t\t\tthrow new Error('Token generation failed');\n\t\t}\n\t}\n\n\t/**\n\t * Validate and decode a JWT token\n\t */\n\tasync validateToken(token: string): Promise<JWTPayload | null> {\n\t\ttry {\n\t\t\tconst parts = token.split('.');\n\t\t\tif (parts.length !== 3) {\n\t\t\t\tthrow new Error('Invalid token format');\n\t\t\t}\n\n\t\t\tconst [encodedHeader, encodedPayload, signature] = parts;\n\n\t\t\t// Verify signature\n\t\t\tconst signingKey = await this.getSigningKey();\n\t\t\tconst expectedSignature = await this.generateSignature(\n\t\t\t\t`${encodedHeader}.${encodedPayload}`,\n\t\t\t\tsigningKey\n\t\t\t);\n\n\t\t\tif (signature !== expectedSignature) {\n\t\t\t\tthrow new Error('Invalid token signature');\n\t\t\t}\n\n\t\t\t// Decode payload\n\t\t\tconst payload: JWTPayload = JSON.parse(this.base64UrlDecode(encodedPayload));\n\n\t\t\t// Check expiration\n\t\t\tconst now = Math.floor(Date.now() / 1000);\n\t\t\tif (payload.exp <= now) {\n\t\t\t\tthrow new Error('Token expired');\n\t\t\t}\n\n\t\t\t// Validate issuer and audience\n\t\t\tif (payload.iss !== this.issuer || payload.aud !== this.audience) {\n\t\t\t\tthrow new Error('Invalid token issuer or audience');\n\t\t\t}\n\n\t\t\tlog.debug('JWT token validated successfully', false, {\n\t\t\t\tsub: payload.sub,\n\t\t\t\tusername: payload.username,\n\t\t\t\tsessionId: payload.sessionId\n\t\t\t});\n\n\t\t\treturn payload;\n\t\t} catch (error) {\n\t\t\tlog.warn('JWT token validation failed:', false, error);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Refresh a token if it's close to expiration\n\t */\n\tasync refreshTokenIfNeeded(\n\t\ttoken: string,\n\t\trefreshThresholdMinutes: number = 10\n\t): Promise<string | null> {\n\t\ttry {\n\t\t\tconst payload = await this.validateToken(token);\n\t\t\tif (!payload) return null;\n\n\t\t\tconst now = Math.floor(Date.now() / 1000);\n\t\t\tconst timeUntilExpiry = payload.exp - now;\n\n\t\t\t// Refresh if token expires within threshold\n\t\t\tif (timeUntilExpiry <= refreshThresholdMinutes * 60) {\n\t\t\t\tlog.debug('Refreshing JWT token', false, {\n\t\t\t\t\ttimeUntilExpiry,\n\t\t\t\t\tthreshold: refreshThresholdMinutes * 60\n\t\t\t\t});\n\n\t\t\t\treturn await this.generateToken(\n\t\t\t\t\tpayload.sub,\n\t\t\t\t\tpayload.username || '',\n\t\t\t\t\tpayload.profileId || '',\n\t\t\t\t\tpayload.planLevel || 'basic'\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn token; // Token is still valid\n\t\t} catch (error) {\n\t\t\tlog.error('Failed to refresh token:', false, error);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Extract token information without validation\n\t */\n\tdecodeToken(token: string): { header: JWTHeader; payload: JWTPayload } | null {\n\t\ttry {\n\t\t\tconst parts = token.split('.');\n\t\t\tif (parts.length !== 3) return null;\n\n\t\t\tconst header = JSON.parse(this.base64UrlDecode(parts[0]));\n\t\t\tconst payload = JSON.parse(this.base64UrlDecode(parts[1]));\n\n\t\t\treturn { header, payload };\n\t\t} catch {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get time until token expiration\n\t */\n\tgetTimeUntilExpiration(token: string): number | null {\n\t\tconst decoded = this.decodeToken(token);\n\t\tif (!decoded) return null;\n\n\t\tconst now = Math.floor(Date.now() / 1000);\n\t\treturn Math.max(0, decoded.payload.exp - now);\n\t}\n\n\t/**\n\t * Generate a unique session ID\n\t */\n\tprivate generateSessionId(): string {\n\t\tconst timestamp = Date.now().toString(36);\n\t\tconst random = Math.random().toString(36).substring(2);\n\t\treturn `${timestamp}-${random}`;\n\t}\n\n\t/**\n\t * Get signing key (in production, this should be from secure storage)\n\t */\n\tprivate async getSigningKey(): Promise<string> {\n\t\t// In production, this should be retrieved from secure storage\n\t\t// For now, we'll generate a key based on the user's profile\n\t\tif (browser) {\n\t\t\ttry {\n\t\t\t\tconst { getSettings } = await import('$lib/common/stores');\n\t\t\t\tconst settings = await getSettings();\n\n\t\t\t\t// Create a signing key from user settings and current date (changes daily for security)\n\t\t\t\tconst today = new Date().toISOString().split('T')[0];\n\t\t\t\tconst keyMaterial = `${settings?.id || 'default'}-${today}-yakkl-jwt-key`;\n\n\t\t\t\t// Hash the key material to create a consistent signing key\n\t\t\t\tconst encoder = new TextEncoder();\n\t\t\t\tconst data = encoder.encode(keyMaterial);\n\t\t\t\tconst hashBuffer = await crypto.subtle.digest('SHA-256', data);\n\t\t\t\tconst hashArray = Array.from(new Uint8Array(hashBuffer));\n\t\t\t\treturn hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');\n\t\t\t} catch (error) {\n\t\t\t\tlog.warn('Failed to generate signing key from settings, using fallback', false, error);\n\t\t\t}\n\t\t}\n\n\t\t// Fallback key (not secure for production)\n\t\treturn 'yakkl-fallback-signing-key-change-in-production';\n\t}\n\n\t/**\n\t * Generate HMAC signature\n\t */\n\tprivate async generateSignature(data: string, key: string): Promise<string> {\n\t\tconst encoder = new TextEncoder();\n\t\tconst keyData = encoder.encode(key);\n\t\tconst messageData = encoder.encode(data);\n\n\t\tconst cryptoKey = await crypto.subtle.importKey(\n\t\t\t'raw',\n\t\t\tkeyData,\n\t\t\t{ name: 'HMAC', hash: 'SHA-256' },\n\t\t\tfalse,\n\t\t\t['sign']\n\t\t);\n\n\t\tconst signature = await crypto.subtle.sign('HMAC', cryptoKey, messageData);\n\t\treturn this.base64UrlEncode(new Uint8Array(signature));\n\t}\n\n\t/**\n\t * Base64 URL encode\n\t */\n\tprivate base64UrlEncode(data: string | Uint8Array): string {\n\t\tconst input = typeof data === 'string' ? new TextEncoder().encode(data) : data;\n\t\tconst base64 = btoa(String.fromCharCode(...input));\n\t\treturn base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n\t}\n\n\t/**\n\t * Base64 URL decode\n\t */\n\tprivate base64UrlDecode(data: string): string {\n\t\tconst base64 = data.replace(/-/g, '+').replace(/_/g, '/');\n\t\tconst padded = base64.padEnd(base64.length + ((4 - (base64.length % 4)) % 4), '=');\n\t\treturn atob(padded);\n\t}\n}\n\n// Export singleton instance\nexport const jwtManager = JWTManager.getInstance();\n\n/**\n * Context-aware JWT manager that automatically uses the appropriate implementation\n * - Uses backgroundJWTManager for service workers/background contexts\n * - Uses regular JWTManager for client contexts with Svelte stores\n */\nexport class ContextAwareJWTManager {\n\tprivate static instance: ContextAwareJWTManager | null = null;\n\n\tstatic getInstance(): ContextAwareJWTManager {\n\t\tif (!ContextAwareJWTManager.instance) {\n\t\t\tContextAwareJWTManager.instance = new ContextAwareJWTManager();\n\t\t}\n\t\treturn ContextAwareJWTManager.instance;\n\t}\n\n\t/**\n\t * Detect current execution context\n\t */\n\tprivate isBackgroundContext(): boolean {\n\t\t// Check for service worker context\n\t\ttry {\n\t\t\tif (\n\t\t\t\ttypeof self !== 'undefined' &&\n\t\t\t\t'ServiceWorkerGlobalScope' in globalThis &&\n\t\t\t\tself instanceof (globalThis as any).ServiceWorkerGlobalScope\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} catch {\n\t\t\t// ServiceWorkerGlobalScope not available\n\t\t}\n\n\t\t// Check for extension background context\n\t\tif (typeof chrome !== 'undefined' && chrome.storage && chrome.storage.local && !browser) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Generate JWT token using appropriate manager\n\t */\n\tasync generateToken(\n\t\tuserId: string,\n\t\tusername: string,\n\t\tprofileId: string,\n\t\tplanLevel: string = 'basic',\n\t\tsessionId?: string,\n\t\texpirationMinutes: number = 60\n\t): Promise<string> {\n\t\tif (this.isBackgroundContext()) {\n\t\t\treturn await backgroundJWTManager.generateToken(\n\t\t\t\tuserId,\n\t\t\t\tusername,\n\t\t\t\tprofileId,\n\t\t\t\tplanLevel,\n\t\t\t\tsessionId,\n\t\t\t\texpirationMinutes\n\t\t\t);\n\t\t} else {\n\t\t\treturn await jwtManager.generateToken(\n\t\t\t\tuserId,\n\t\t\t\tusername,\n\t\t\t\tprofileId,\n\t\t\t\tplanLevel,\n\t\t\t\texpirationMinutes\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Get current JWT token using appropriate manager\n\t */\n\tasync getCurrentToken(): Promise<string | null> {\n\t\tif (this.isBackgroundContext()) {\n\t\t\treturn await backgroundJWTManager.getCurrentToken();\n\t\t} else {\n\t\t\t// For client context, we'd need to get from auth store or session manager\n\t\t\t// This would typically be called from the auth store itself\n\t\t\tconsole.warn('getCurrentToken called from client context - use authStore instead');\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Validate token using appropriate manager\n\t */\n\tasync validateToken(token: string): Promise<boolean> {\n\t\tif (this.isBackgroundContext()) {\n\t\t\treturn await backgroundJWTManager.validateToken(token);\n\t\t} else {\n\t\t\tconst payload = await jwtManager.validateToken(token);\n\t\t\treturn payload !== null;\n\t\t}\n\t}\n\n\t/**\n\t * Clear token using appropriate manager\n\t */\n\tasync clearToken(): Promise<void> {\n\t\tif (this.isBackgroundContext()) {\n\t\t\tawait backgroundJWTManager.clearToken();\n\t\t} else {\n\t\t\t// For client context, this would be handled by auth store\n\t\t\tconsole.warn('clearToken called from client context - use authStore instead');\n\t\t}\n\t}\n}\n\n// Export context-aware instance\nexport const contextAwareJWT = ContextAwareJWTManager.getInstance();\n\n// Helper functions for easy background script usage\nexport async function getJWTForBackground(): Promise<string | null> {\n\treturn await backgroundJWTManager.getCurrentToken();\n}\n\nexport async function createJWTInBackground(\n\tuserId: string,\n\tusername: string,\n\tprofileId: string,\n\tplanLevel: string = 'basic',\n\tsessionId?: string\n): Promise<string> {\n\treturn await backgroundJWTManager.generateToken(\n\t\tuserId,\n\t\tusername,\n\t\tprofileId,\n\t\tplanLevel,\n\t\tsessionId\n\t);\n}\n","/**\n * Session Manager for YAKKL Wallet\n * Handles session lifecycle, timeouts, and JWT token management\n * Browser extension context-aware implementation\n */\n\nimport { browser } from '$app/environment';\nimport { browser_ext } from '$lib/common/environment';\nimport { log } from '$lib/common/logger-wrapper';\nimport { jwtManager, type JWTPayload } from '$lib/utilities/jwt';\n\nexport interface SessionState {\n\tisActive: boolean;\n\tuserId: string | null;\n\tusername: string | null;\n\tprofileId: string | null;\n\tplanLevel: string | null;\n\tsessionId: string | null;\n\tlastActivity: number;\n\texpiresAt: number;\n\tjwtToken: string | null;\n\twarningShown: boolean;\n}\n\nexport interface SessionConfig {\n\ttimeoutMinutes: number;\n\twarningMinutes: number;\n\tmaxInactivityMinutes: number;\n\tautoExtendOnActivity: boolean;\n\tjwtExpirationMinutes: number;\n}\n\nconst DEFAULT_CONFIG: SessionConfig = {\n\ttimeoutMinutes: 30,\n\twarningMinutes: 2,\n\tmaxInactivityMinutes: 60,\n\tautoExtendOnActivity: true,\n\tjwtExpirationMinutes: 60\n};\n\nexport class SessionManager {\n\tprivate static instance: SessionManager | null = null;\n\tprivate config: SessionConfig = DEFAULT_CONFIG;\n\tprivate sessionState: SessionState | null = null;\n\tprivate timeoutTimer: ReturnType<typeof setTimeout> | null = null;\n\tprivate warningTimer: ReturnType<typeof setTimeout> | null = null;\n\tprivate activityListenersAdded = false;\n\n\t// Event callbacks\n\tprivate onSessionWarning: ((timeRemaining: number) => void) | null = null;\n\tprivate onSessionExpired: (() => void) | null = null;\n\tprivate onSessionExtended: (() => void) | null = null;\n\n\tprivate constructor() {\n\t\tthis.initializeFromStorage();\n\t}\n\n\tstatic getInstance(): SessionManager {\n\t\tif (!SessionManager.instance) {\n\t\t\tSessionManager.instance = new SessionManager();\n\t\t}\n\t\treturn SessionManager.instance;\n\t}\n\n\t/**\n\t * Start a new session\n\t */\n\tasync startSession(\n\t\tuserId: string,\n\t\tusername: string,\n\t\tprofileId: string,\n\t\tplanLevel: string = 'basic'\n\t): Promise<string> {\n\t\ttry {\n\t\t\t// Generate JWT token\n\t\t\tconst jwtToken = await jwtManager.generateToken(\n\t\t\t\tuserId,\n\t\t\t\tusername,\n\t\t\t\tprofileId,\n\t\t\t\tplanLevel,\n\t\t\t\tthis.config.jwtExpirationMinutes\n\t\t\t);\n\n\t\t\tconst now = Date.now();\n\t\t\tconst sessionId = this.generateSessionId();\n\n\t\t\tthis.sessionState = {\n\t\t\t\tisActive: true,\n\t\t\t\tuserId,\n\t\t\t\tusername,\n\t\t\t\tprofileId,\n\t\t\t\tplanLevel,\n\t\t\t\tsessionId,\n\t\t\t\tlastActivity: now,\n\t\t\t\texpiresAt: now + this.config.timeoutMinutes * 60 * 1000,\n\t\t\t\tjwtToken,\n\t\t\t\twarningShown: false\n\t\t\t};\n\n\t\t\tawait this.saveSessionState();\n\t\t\tthis.startActivityTracking();\n\t\t\tthis.scheduleWarning();\n\n\t\t\tlog.debug('Session started', false, {\n\t\t\t\tuserId,\n\t\t\t\tusername,\n\t\t\t\tsessionId,\n\t\t\t\texpiresAt: new Date(this.sessionState.expiresAt)\n\t\t\t});\n\n\t\t\t// Notify background script if in extension\n\t\t\tif (browser && browser_ext) {\n\t\t\t\tthis.notifyBackgroundScript('SESSION_STARTED', {\n\t\t\t\t\tsessionId,\n\t\t\t\t\texpiresAt: this.sessionState.expiresAt\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn jwtToken;\n\t\t} catch (error) {\n\t\t\tlog.error('Failed to start session:', false, error);\n\t\t\tthrow new Error('Session start failed');\n\t\t}\n\t}\n\n\t/**\n\t * Extend current session\n\t */\n\tasync extendSession(additionalMinutes: number = 30): Promise<void> {\n\t\tif (!this.sessionState || !this.sessionState.isActive) {\n\t\t\tthrow new Error('No active session to extend');\n\t\t}\n\n\t\ttry {\n\t\t\tconst now = Date.now();\n\t\t\tconst newExpiresAt = now + additionalMinutes * 60 * 1000;\n\n\t\t\t// Refresh JWT token if needed\n\t\t\tif (this.sessionState.jwtToken) {\n\t\t\t\tconst refreshedToken = await jwtManager.refreshTokenIfNeeded(\n\t\t\t\t\tthis.sessionState.jwtToken,\n\t\t\t\t\t10 // Refresh if expires within 10 minutes\n\t\t\t\t);\n\n\t\t\t\tif (refreshedToken && refreshedToken !== this.sessionState.jwtToken) {\n\t\t\t\t\tthis.sessionState.jwtToken = refreshedToken;\n\t\t\t\t\tlog.debug('JWT token refreshed during session extension', false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.sessionState.lastActivity = now;\n\t\t\tthis.sessionState.expiresAt = newExpiresAt;\n\t\t\tthis.sessionState.warningShown = false;\n\n\t\t\tawait this.saveSessionState();\n\t\t\tthis.clearTimers();\n\t\t\tthis.scheduleWarning();\n\n\t\t\tlog.debug('Session extended', false, {\n\t\t\t\tsessionId: this.sessionState.sessionId,\n\t\t\t\tadditionalMinutes,\n\t\t\t\tnewExpiresAt: new Date(newExpiresAt)\n\t\t\t});\n\n\t\t\tif (this.onSessionExtended) {\n\t\t\t\tthis.onSessionExtended();\n\t\t\t}\n\n\t\t\t// Notify background script\n\t\t\tif (browser && browser_ext) {\n\t\t\t\tthis.notifyBackgroundScript('SESSION_EXTENDED', {\n\t\t\t\t\tsessionId: this.sessionState.sessionId,\n\t\t\t\t\texpiresAt: newExpiresAt\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlog.error('Failed to extend session:', false, error);\n\t\t\tthrow new Error('Session extension failed');\n\t\t}\n\t}\n\n\t/**\n\t * End current session\n\t */\n\tasync endSession(): Promise<void> {\n\t\tif (this.sessionState) {\n\t\t\tlog.debug('Ending session', false, {\n\t\t\t\tsessionId: this.sessionState.sessionId\n\t\t\t});\n\n\t\t\t// Notify background script before clearing state\n\t\t\tif (browser && browser_ext) {\n\t\t\t\tthis.notifyBackgroundScript('SESSION_ENDED', {\n\t\t\t\t\tsessionId: this.sessionState.sessionId\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tthis.sessionState = null;\n\t\tthis.clearTimers();\n\t\tthis.removeActivityListeners();\n\n\t\ttry {\n\t\t\tawait this.clearSessionStorage();\n\t\t} catch (error) {\n\t\t\tlog.warn('Failed to clear session storage:', false, error);\n\t\t}\n\n\t\tif (this.onSessionExpired) {\n\t\t\tthis.onSessionExpired();\n\t\t}\n\t}\n\n\t/**\n\t * Get current session state\n\t */\n\tgetSessionState(): SessionState | null {\n\t\treturn this.sessionState ? { ...this.sessionState } : null;\n\t}\n\n\t/**\n\t * Get current JWT token\n\t */\n\tgetCurrentJWTToken(): string | null {\n\t\treturn this.sessionState?.jwtToken || null;\n\t}\n\n\t/**\n\t * Check if session is active and valid\n\t */\n\tisSessionActive(): boolean {\n\t\tif (!this.sessionState || !this.sessionState.isActive) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst now = Date.now();\n\t\tif (now >= this.sessionState.expiresAt) {\n\t\t\tthis.endSession();\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Update activity timestamp\n\t */\n\tupdateActivity(): void {\n\t\tif (!this.sessionState || !this.sessionState.isActive) return;\n\n\t\tconst now = Date.now();\n\t\tthis.sessionState.lastActivity = now;\n\n\t\t// Auto-extend session if configured and close to expiration\n\t\tif (this.config.autoExtendOnActivity) {\n\t\t\tconst timeUntilExpiry = this.sessionState.expiresAt - now;\n\t\t\tconst warningThreshold = this.config.warningMinutes * 60 * 1000;\n\n\t\t\tif (timeUntilExpiry <= warningThreshold && !this.sessionState.warningShown) {\n\t\t\t\tthis.extendSession(this.config.timeoutMinutes);\n\t\t\t}\n\t\t}\n\n\t\tthis.saveSessionState(); // Save updated activity time\n\t}\n\n\t/**\n\t * Set event callbacks\n\t */\n\tsetCallbacks(callbacks: {\n\t\tonWarning?: (timeRemaining: number) => void;\n\t\tonExpired?: () => void;\n\t\tonExtended?: () => void;\n\t}): void {\n\t\tthis.onSessionWarning = callbacks.onWarning || null;\n\t\tthis.onSessionExpired = callbacks.onExpired || null;\n\t\tthis.onSessionExtended = callbacks.onExtended || null;\n\t}\n\n\t/**\n\t * Update session configuration\n\t */\n\tupdateConfig(newConfig: Partial<SessionConfig>): void {\n\t\tthis.config = { ...this.config, ...newConfig };\n\t\tlog.debug('Session config updated', false, this.config);\n\t}\n\n\t/**\n\t * Initialize session from storage\n\t */\n\tprivate async initializeFromStorage(): Promise<void> {\n\t\tif (!browser) return;\n\n\t\ttry {\n\t\t\tconst stored = await this.loadSessionState();\n\t\t\tif (stored && stored.isActive) {\n\t\t\t\tconst now = Date.now();\n\n\t\t\t\t// Check if session is still valid\n\t\t\t\tif (now < stored.expiresAt) {\n\t\t\t\t\tthis.sessionState = stored;\n\t\t\t\t\tthis.startActivityTracking();\n\t\t\t\t\tthis.scheduleWarning();\n\n\t\t\t\t\tlog.debug('Session restored from storage', false, {\n\t\t\t\t\t\tsessionId: stored.sessionId,\n\t\t\t\t\t\ttimeRemaining: Math.round((stored.expiresAt - now) / 1000)\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// Session expired, clean up\n\t\t\t\t\tawait this.clearSessionStorage();\n\t\t\t\t\tlog.debug('Expired session cleared from storage', false);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlog.warn('Failed to initialize session from storage:', false, error);\n\t\t}\n\t}\n\n\t/**\n\t * Schedule session warning\n\t */\n\tprivate scheduleWarning(): void {\n\t\tif (!this.sessionState) return;\n\n\t\tconst now = Date.now();\n\t\tconst timeUntilWarning =\n\t\t\tthis.sessionState.expiresAt - now - this.config.warningMinutes * 60 * 1000;\n\n\t\tif (timeUntilWarning > 0) {\n\t\t\tthis.warningTimer = setTimeout(() => {\n\t\t\t\tthis.showSessionWarning();\n\t\t\t}, timeUntilWarning);\n\t\t} else {\n\t\t\t// Should show warning immediately\n\t\t\tthis.showSessionWarning();\n\t\t}\n\t}\n\n\t/**\n\t * Show session warning\n\t */\n\tprivate showSessionWarning(): void {\n\t\tif (!this.sessionState || this.sessionState.warningShown) return;\n\n\t\tthis.sessionState.warningShown = true;\n\n\t\tconst now = Date.now();\n\t\tconst timeRemaining = Math.max(0, Math.round((this.sessionState.expiresAt - now) / 1000));\n\n\t\tlog.debug('Showing session warning', false, { timeRemaining });\n\n\t\tif (this.onSessionWarning) {\n\t\t\tthis.onSessionWarning(timeRemaining);\n\t\t}\n\n\t\t// Schedule automatic logout\n\t\tthis.timeoutTimer = setTimeout(() => {\n\t\t\tthis.endSession();\n\t\t}, timeRemaining * 1000);\n\t}\n\n\t/**\n\t * Start activity tracking\n\t */\n\tprivate startActivityTracking(): void {\n\t\tif (!browser || this.activityListenersAdded) return;\n\n\t\tconst events = ['mousedown', 'keydown', 'scroll', 'touchstart', 'mousemove'];\n\t\tconst handleActivity = () => this.updateActivity();\n\n\t\tevents.forEach((event) => {\n\t\t\tdocument.addEventListener(event, handleActivity, { passive: true });\n\t\t});\n\n\t\tthis.activityListenersAdded = true;\n\t\tlog.debug('Activity tracking started', false);\n\t}\n\n\t/**\n\t * Remove activity listeners\n\t */\n\tprivate removeActivityListeners(): void {\n\t\tif (!browser || !this.activityListenersAdded) return;\n\n\t\tconst events = ['mousedown', 'keydown', 'scroll', 'touchstart', 'mousemove'];\n\t\tconst handleActivity = () => this.updateActivity();\n\n\t\tevents.forEach((event) => {\n\t\t\tdocument.removeEventListener(event, handleActivity);\n\t\t});\n\n\t\tthis.activityListenersAdded = false;\n\t\tlog.debug('Activity tracking stopped', false);\n\t}\n\n\t/**\n\t * Clear all timers\n\t */\n\tprivate clearTimers(): void {\n\t\tif (this.timeoutTimer) {\n\t\t\tclearTimeout(this.timeoutTimer);\n\t\t\tthis.timeoutTimer = null;\n\t\t}\n\t\tif (this.warningTimer) {\n\t\t\tclearTimeout(this.warningTimer);\n\t\t\tthis.warningTimer = null;\n\t\t}\n\t}\n\n\t/**\n\t * Generate unique session ID\n\t */\n\tprivate generateSessionId(): string {\n\t\tconst timestamp = Date.now().toString(36);\n\t\tconst random = Math.random().toString(36).substring(2);\n\t\treturn `session-${timestamp}-${random}`;\n\t}\n\n\t/**\n\t * Save session state to storage\n\t */\n\tprivate async saveSessionState(): Promise<void> {\n\t\tif (!browser || !this.sessionState) return;\n\n\t\ttry {\n\t\t\tif (browser_ext) {\n\t\t\t\tawait browser_ext.storage.local.set({\n\t\t\t\t\tyakklSession: this.sessionState\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlocalStorage.setItem('yakklSession', JSON.stringify(this.sessionState));\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlog.warn('Failed to save session state:', false, error);\n\t\t}\n\t}\n\n\t/**\n\t * Load session state from storage\n\t */\n\tprivate async loadSessionState(): Promise<SessionState | null> {\n\t\tif (!browser) return null;\n\n\t\ttry {\n\t\t\tif (browser_ext) {\n\t\t\t\tconst result = await browser_ext.storage.local.get(['yakklSession']);\n\t\t\t\treturn (result.yakklSession as SessionState) || null;\n\t\t\t} else {\n\t\t\t\tconst stored = localStorage.getItem('yakklSession');\n\t\t\t\treturn stored ? JSON.parse(stored) : null;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlog.warn('Failed to load session state:', false, error);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Clear session storage\n\t */\n\tprivate async clearSessionStorage(): Promise<void> {\n\t\tif (!browser) return;\n\n\t\ttry {\n\t\t\tif (browser_ext) {\n\t\t\t\tawait browser_ext.storage.local.remove(['yakklSession']);\n\t\t\t} else {\n\t\t\t\tlocalStorage.removeItem('yakklSession');\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlog.warn('Failed to clear session storage:', false, error);\n\t\t}\n\t}\n\n\t/**\n\t * Notify background script of session events\n\t */\n\tprivate notifyBackgroundScript(type: string, data: any): void {\n\t\tif (!browser || !browser_ext) return;\n\n\t\ttry {\n\t\t\tbrowser_ext.runtime.sendMessage({\n\t\t\t\ttype: `SESSION_${type}`,\n\t\t\t\tdata\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlog.warn('Failed to notify background script:', false, error);\n\t\t}\n\t}\n}\n\n// Export singleton instance\nexport const sessionManager = SessionManager.getInstance();\n","import { writable, derived, get } from 'svelte/store';\nimport { browser } from '$app/environment';\nimport { verify } from '$lib/common/security';\nimport { getSettings, getMiscStore, setMiscStore } from '$lib/common/stores';\nimport type { Profile } from '$lib/common/interfaces';\nimport { log } from '$lib/common/logger-wrapper';\nimport { sessionManager, type SessionState } from '$lib/managers/SessionManager';\nimport { jwtManager } from '$lib/utilities/jwt';\n\ninterface AuthState {\n\tisAuthenticated: boolean;\n\tisRegistered: boolean;\n\tprofile: Profile | null;\n\tlastActivity: number;\n\tsessionTimeout: number; // in minutes\n\tisInitializing: boolean;\n\tsessionState: SessionState | null;\n\tjwtToken: string | null;\n\tshowSessionWarning: boolean;\n\tsessionTimeRemaining: number; // seconds until session expires\n}\n\nconst defaultAuthState: AuthState = {\n\tisAuthenticated: false,\n\tisRegistered: false,\n\tprofile: null,\n\tlastActivity: Date.now(),\n\tsessionTimeout: 30, // 30 minutes default\n\tisInitializing: false,\n\tsessionState: null,\n\tjwtToken: null,\n\tshowSessionWarning: false,\n\tsessionTimeRemaining: 0\n};\n\nfunction createAuthStore() {\n\tconst { subscribe, set, update } = writable<AuthState>(defaultAuthState);\n\n\tlet activityListenersAdded = false;\n\n\t// Setup session management callbacks\n\tfunction setupSessionCallbacks() {\n\t\tsessionManager.setCallbacks({\n\t\t\tonWarning: (timeRemaining: number) => {\n\t\t\t\tupdate((state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tshowSessionWarning: true,\n\t\t\t\t\tsessionTimeRemaining: timeRemaining\n\t\t\t\t}));\n\t\t\t\tlog.debug('Session warning triggered', false, { timeRemaining });\n\t\t\t},\n\t\t\tonExpired: () => {\n\t\t\t\tupdate((state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tisAuthenticated: false,\n\t\t\t\t\tsessionState: null,\n\t\t\t\t\tjwtToken: null,\n\t\t\t\t\tshowSessionWarning: false,\n\t\t\t\t\tprofile: null\n\t\t\t\t}));\n\t\t\t\tsetMiscStore('');\n\t\t\t\tlog.debug('Session expired', false);\n\t\t\t},\n\t\t\tonExtended: () => {\n\t\t\t\tconst newSessionState = sessionManager.getSessionState();\n\t\t\t\tupdate((state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tsessionState: newSessionState,\n\t\t\t\t\tjwtToken: newSessionState?.jwtToken || null,\n\t\t\t\t\tshowSessionWarning: false,\n\t\t\t\t\tlastActivity: Date.now()\n\t\t\t\t}));\n\t\t\t\tlog.debug('Session extended', false);\n\t\t\t}\n\t\t});\n\t}\n\n\t// Activity tracker - only add listeners once\n\tfunction addActivityListeners() {\n\t\tif (browser && !activityListenersAdded) {\n\t\t\tconst events = ['mousedown', 'keydown', 'scroll', 'touchstart', 'mousemove'];\n\n\t\t\tconst updateActivity = () => {\n\t\t\t\tupdate((state) => ({ ...state, lastActivity: Date.now() }));\n\t\t\t};\n\n\t\t\tevents.forEach((event) => {\n\t\t\t\tdocument.addEventListener(event, updateActivity, { passive: true });\n\t\t\t});\n\n\t\t\tactivityListenersAdded = true;\n\t\t}\n\t}\n\n\treturn {\n\t\tsubscribe,\n\n\t\tasync initialize() {\n\t\t\ttry {\n\t\t\t\tupdate((state) => ({ ...state, isInitializing: true }));\n\n\t\t\t\tconst settings = await getSettings();\n\t\t\t\tconst miscStore = getMiscStore();\n\n\t\t\t\tconst isRegistered = !!(settings?.init && settings?.legal?.termsAgreed);\n\t\t\t\tconst isAuthenticated = !!(miscStore && miscStore.length > 0);\n\n\t\t\t\tupdate((state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tisRegistered,\n\t\t\t\t\tisAuthenticated,\n\t\t\t\t\tlastActivity: Date.now(),\n\t\t\t\t\tisInitializing: false\n\t\t\t\t}));\n\n\t\t\t\t// Add activity listeners after initialization\n\t\t\t\taddActivityListeners();\n\n\t\t\t\t// Setup session management callbacks\n\t\t\t\tsetupSessionCallbacks();\n\n\t\t\t\t// Check for existing session\n\t\t\t\tconst sessionState = sessionManager.getSessionState();\n\t\t\t\tif (sessionState && sessionManager.isSessionActive()) {\n\t\t\t\t\tupdate((state) => ({\n\t\t\t\t\t\t...state,\n\t\t\t\t\t\tsessionState,\n\t\t\t\t\t\tjwtToken: sessionState.jwtToken,\n\t\t\t\t\t\tisAuthenticated: true\n\t\t\t\t\t}));\n\t\t\t\t}\n\n\t\t\t\tlog.debug('Auth store initialized', false, { isRegistered, isAuthenticated });\n\t\t\t} catch (error) {\n\t\t\t\tlog.error('Error initializing auth store:', false, error);\n\t\t\t\tupdate((state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tisInitializing: false,\n\t\t\t\t\tisAuthenticated: false,\n\t\t\t\t\tisRegistered: false\n\t\t\t\t}));\n\t\t\t}\n\t\t},\n\n\t\tasync login(username: string, password: string): Promise<Profile> {\n\t\t\ttry {\n\t\t\t\t// Format the username properly (removing .nfs.id if already present, then adding it)\n\t\t\t\tconst normalizedUsername = username.toLowerCase().trim().replace('.nfs.id', '');\n\t\t\t\tconst loginString = normalizedUsername + '.nfs.id' + password;\n\n\t\t\t\t// Call the existing verify function - this is the core authentication\n\t\t\t\tconst profile = await verify(loginString);\n\n\t\t\t\tif (!profile) {\n\t\t\t\t\tthrow new Error('Invalid credentials or profile not found');\n\t\t\t\t}\n\n\t\t\t\t// Get the digest that was set during verification\n\t\t\t\tconst digest = getMiscStore();\n\t\t\t\tif (!digest) {\n\t\t\t\t\tthrow new Error('Authentication succeeded but failed to retrieve security digest');\n\t\t\t\t}\n\n\t\t\t\t// Get user's plan level for JWT\n\t\t\t\tconst settings = await getSettings();\n\t\t\t\tconst planLevel = settings?.plan?.type || 'basic';\n\n\t\t\t\t// Start session with JWT token generation\n\t\t\t\tconst jwtToken = await sessionManager.startSession(\n\t\t\t\t\tprofile.id || profile.userName,\n\t\t\t\t\tprofile.userName,\n\t\t\t\t\tprofile.id || profile.userName,\n\t\t\t\t\tplanLevel\n\t\t\t\t);\n\n\t\t\t\tconst sessionState = sessionManager.getSessionState();\n\n\t\t\t\tupdate((state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tisAuthenticated: true,\n\t\t\t\t\tprofile,\n\t\t\t\t\tlastActivity: Date.now(),\n\t\t\t\t\tsessionState,\n\t\t\t\t\tjwtToken\n\t\t\t\t}));\n\n\t\t\t\tlog.debug('User logged in successfully', false, {\n\t\t\t\t\tusername: normalizedUsername,\n\t\t\t\t\tsessionId: sessionState?.sessionId\n\t\t\t\t});\n\t\t\t\treturn profile;\n\t\t\t} catch (error) {\n\t\t\t\tlog.error('Login failed:', false, error);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t},\n\n\t\tasync logout() {\n\t\t\ttry {\n\t\t\t\t// End session\n\t\t\t\tawait sessionManager.endSession();\n\n\t\t\t\tsetMiscStore('');\n\t\t\t\tupdate((state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tisAuthenticated: false,\n\t\t\t\t\tprofile: null,\n\t\t\t\t\tlastActivity: Date.now(),\n\t\t\t\t\tsessionState: null,\n\t\t\t\t\tjwtToken: null,\n\t\t\t\t\tshowSessionWarning: false\n\t\t\t\t}));\n\t\t\t\tlog.debug('User logged out', false);\n\t\t\t} catch (error) {\n\t\t\t\tlog.error('Error during logout:', false, error);\n\t\t\t}\n\t\t},\n\n\t\tcheckSession(): boolean {\n\t\t\ttry {\n\t\t\t\tconst state = get(authStore);\n\t\t\t\tconst now = Date.now();\n\t\t\t\tconst timeoutMs = state.sessionTimeout * 60 * 1000;\n\n\t\t\t\tif (state.isAuthenticated && now - state.lastActivity > timeoutMs) {\n\t\t\t\t\tlog.warn('Session expired due to inactivity', false);\n\t\t\t\t\tthis.logout();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn state.isAuthenticated;\n\t\t\t} catch (error) {\n\t\t\t\tlog.error('Error checking session:', false, error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\t\tupdateLastActivity() {\n\t\t\tupdate((state) => ({ ...state, lastActivity: Date.now() }));\n\t\t},\n\n\t\tsetSessionTimeout(minutes: number) {\n\t\t\tupdate((state) => ({ ...state, sessionTimeout: minutes }));\n\t\t},\n\n\t\t// Helper method to refresh registration status\n\t\tasync refreshRegistrationStatus() {\n\t\t\ttry {\n\t\t\t\tconst settings = await getSettings();\n\t\t\t\tconst isRegistered = !!(settings?.init && settings?.legal?.termsAgreed);\n\n\t\t\t\tupdate((state) => ({ ...state, isRegistered }));\n\t\t\t\treturn isRegistered;\n\t\t\t} catch (error) {\n\t\t\t\tlog.error('Error refreshing registration status:', false, error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\t\t// Session management methods\n\t\tasync extendSession(additionalMinutes: number = 30): Promise<void> {\n\t\t\ttry {\n\t\t\t\tawait sessionManager.extendSession(additionalMinutes);\n\n\t\t\t\tconst sessionState = sessionManager.getSessionState();\n\t\t\t\tupdate((state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tsessionState,\n\t\t\t\t\tjwtToken: sessionState?.jwtToken || null,\n\t\t\t\t\tshowSessionWarning: false,\n\t\t\t\t\tlastActivity: Date.now()\n\t\t\t\t}));\n\t\t\t} catch (error) {\n\t\t\t\tlog.error('Failed to extend session:', false, error);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t},\n\n\t\tdismissSessionWarning() {\n\t\t\tupdate((state) => ({\n\t\t\t\t...state,\n\t\t\t\tshowSessionWarning: false\n\t\t\t}));\n\t\t},\n\n\t\tgetCurrentJWTToken(): string | null {\n\t\t\tconst state = get(authStore);\n\t\t\treturn state.jwtToken;\n\t\t},\n\n\t\tgetSessionTimeRemaining(): number {\n\t\t\tconst state = get(authStore);\n\t\t\tif (!state.sessionState) return 0;\n\n\t\t\tconst now = Date.now();\n\t\t\treturn Math.max(0, Math.round((state.sessionState.expiresAt - now) / 1000));\n\t\t}\n\t};\n}\n\nexport const authStore = createAuthStore();\n\n// Derived stores for convenient access\nexport const isAuthenticated = derived(authStore, ($auth) => $auth.isAuthenticated);\nexport const isRegistered = derived(authStore, ($auth) => $auth.isRegistered);\nexport const authProfile = derived(authStore, ($auth) => $auth.profile);\nexport const lastActivity = derived(authStore, ($auth) => $auth.lastActivity);\nexport const isAuthInitializing = derived(authStore, ($auth) => $auth.isInitializing);\n\n// Session management derived stores\nexport const sessionState = derived(authStore, ($auth) => $auth.sessionState);\nexport const jwtToken = derived(authStore, ($auth) => $auth.jwtToken);\nexport const showSessionWarning = derived(authStore, ($auth) => $auth.showSessionWarning);\nexport const sessionTimeRemaining = derived(authStore, ($auth) => $auth.sessionTimeRemaining);\nexport const hasValidJWT = derived(authStore, ($auth) => {\n\tif (!$auth.jwtToken) return false;\n\n\ttry {\n\t\tconst decoded = jwtManager.decodeToken($auth.jwtToken);\n\t\tif (!decoded) return false;\n\n\t\tconst now = Math.floor(Date.now() / 1000);\n\t\treturn decoded.payload.exp > now;\n\t} catch {\n\t\treturn false;\n\t}\n});\n\n// Helper function to get current auth state\nexport function getAuthState() {\n\treturn get(authStore);\n}\n\n// Auto-initialize on import if in browser\nif (browser) {\n\tauthStore.initialize().catch((error) => {\n\t\tlog.error('Failed to auto-initialize auth store:', false, error);\n\t});\n}\n"],"file":"app/immutable/chunks/DmxAnVWO.js"}