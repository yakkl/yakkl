{"version":3,"file":"z-nmOEXa.js","sources":["../../../../../../src/lib/managers/UnifiedTimerManager.ts"],"sourcesContent":["import { log } from '$lib/managers/Logger';\n\ntype TimerCallback = () => void;\ntype DebouncedFunction<T extends (...args: any[]) => void> = T & { cancel: () => void };\n\n// Use ReturnType to get the actual return type of setTimeout/setInterval in the current environment\ntype TimerId = ReturnType<typeof setTimeout>;\n\nexport interface Timer {\n\tid: string;\n\tcallback: TimerCallback;\n\tduration: number;\n\thandle: TimerId | null;\n\ttype: 'interval' | 'timeout';\n}\n\n// Simple singleton pattern - no events needed for service worker compatibility\n\nexport class UnifiedTimerManager {\n\tprivate intervals: Map<string, Timer> = new Map();\n\tprivate timeouts: Map<string, Timer> = new Map();\n\tprivate static instance: UnifiedTimerManager | null = null;\n\n\tconstructor() {\n\t\tif (UnifiedTimerManager.instance) {\n\t\t\treturn UnifiedTimerManager.instance;\n\t\t}\n\t\tUnifiedTimerManager.instance = this;\n\t}\n\n\tpublic static getInstance(): UnifiedTimerManager {\n\t\treturn UnifiedTimerManager.instance ?? new UnifiedTimerManager();\n\t}\n\n\tpublic static clearInstance(): void {\n\t\tif (this.instance) {\n\t\t\tthis.instance.clearAll();\n\t\t}\n\t\tthis.instance = null;\n\t}\n\n\tpublic static resetInstance(): UnifiedTimerManager {\n\t\tthis.clearInstance();\n\t\treturn this.getInstance();\n\t}\n\n\t// Interval methods\n\taddInterval(id: string, callback: TimerCallback, duration: number): void {\n\t\tif (this.intervals.has(id)) {\n\t\t\tlog.warn(`Interval \"${id}\" already exists.`);\n\t\t\treturn;\n\t\t}\n\t\tthis.intervals.set(id, { id, callback, duration, handle: null, type: 'interval' });\n\t}\n\n\tstartInterval(id: string, immediate = false): void {\n\t\tconst timer = this.intervals.get(id);\n\t\tif (!timer) return log.error(`Interval \"${id}\" not found.`);\n\t\tif (timer.handle) return log.warn(`Interval \"${id}\" is already running.`);\n\n\t\tif (immediate) {\n\t\t\ttimer.callback();\n\t\t}\n\t\ttimer.handle = setInterval(timer.callback, timer.duration);\n\t}\n\n\tstopInterval(id: string): void {\n\t\tconst timer = this.intervals.get(id);\n\t\tif (!timer) return log.warn(`Interval \"${id}\" not found.`);\n\t\tif (!timer.handle) return log.warn(`Interval \"${id}\" is not running.`);\n\n\t\tclearInterval(timer.handle);\n\t\ttimer.handle = null;\n\t}\n\n\tremoveInterval(id: string): void {\n\t\tthis.stopInterval(id);\n\t\tthis.intervals.delete(id);\n\t}\n\n\t// Timeout methods\n\taddTimeout(id: string, callback: TimerCallback, duration: number): void {\n\t\tif (this.timeouts.has(id)) {\n\t\t\tlog.warn(`Timeout \"${id}\" already exists.`);\n\t\t\treturn;\n\t\t}\n\t\tthis.timeouts.set(id, { id, callback, duration, handle: null, type: 'timeout' });\n\t}\n\n\tstartTimeout(id: string): void {\n\t\tconst timer = this.timeouts.get(id);\n\t\tif (!timer) return log.error(`Timeout \"${id}\" not found.`);\n\t\tif (timer.handle) return log.warn(`Timeout \"${id}\" is already running.`);\n\n\t\ttimer.handle = setTimeout(() => {\n\t\t\ttimer.callback();\n\t\t\ttimer.handle = null;\n\t\t}, timer.duration);\n\t}\n\n\tstopTimeout(id: string): void {\n\t\tconst timer = this.timeouts.get(id);\n\t\tif (!timer) return log.warn(`Timeout \"${id}\" not found.`);\n\t\tif (!timer.handle) return log.warn(`Timeout \"${id}\" is not running.`);\n\n\t\tclearTimeout(timer.handle);\n\t\ttimer.handle = null;\n\t}\n\n\tremoveTimeout(id: string): void {\n\t\tthis.stopTimeout(id);\n\t\tthis.timeouts.delete(id);\n\t}\n\n\t// Utility methods\n\tclearAll(): void {\n\t\t// Stop all intervals\n\t\tthis.intervals.forEach((_, id) => this.stopInterval(id));\n\t\tthis.intervals.clear();\n\n\t\t// Stop all timeouts\n\t\tthis.timeouts.forEach((_, id) => this.stopTimeout(id));\n\t\tthis.timeouts.clear();\n\t}\n\n\tgetRunningTimers(): { intervals: string[]; timeouts: string[] } {\n\t\tconst intervals = Array.from(this.intervals.entries())\n\t\t\t.filter(([_, timer]) => timer.handle !== null)\n\t\t\t.map(([id]) => id);\n\n\t\tconst timeouts = Array.from(this.timeouts.entries())\n\t\t\t.filter(([_, timer]) => timer.handle !== null)\n\t\t\t.map(([id]) => id);\n\n\t\treturn { intervals, timeouts };\n\t}\n\n\tisIntervalRunning(id: string): boolean {\n\t\treturn !!this.intervals.get(id)?.handle;\n\t}\n\n\tisTimeoutRunning(id: string): boolean {\n\t\treturn !!this.timeouts.get(id)?.handle;\n\t}\n\n\t// Backward compatibility methods (delegates to interval methods)\n\taddTimer(id: string, callback: TimerCallback, duration: number): void {\n\t\tthis.addInterval(id, callback, duration);\n\t}\n\n\tstartTimer(id: string): void {\n\t\tthis.startInterval(id);\n\t}\n\n\tstopTimer(id: string): void {\n\t\tthis.stopInterval(id);\n\t}\n\n\tremoveTimer(id: string): void {\n\t\tthis.removeInterval(id);\n\t}\n\n\thasTimer(id: string): boolean {\n\t\treturn this.intervals.has(id);\n\t}\n\n\tisRunning(id: string): boolean {\n\t\treturn this.isIntervalRunning(id);\n\t}\n\n\t// Debounce utility\n\tstatic createDebounce<T extends (...args: any[]) => void>(\n\t\tfunc: T,\n\t\tdelay: number\n\t): DebouncedFunction<T> {\n\t\tlet timeoutId: TimerId | null = null;\n\n\t\tconst debounced = ((...args: Parameters<T>) => {\n\t\t\tif (timeoutId) {\n\t\t\t\tclearTimeout(timeoutId);\n\t\t\t}\n\t\t\ttimeoutId = setTimeout(() => {\n\t\t\t\tfunc(...args);\n\t\t\t\ttimeoutId = null;\n\t\t\t}, delay);\n\t\t}) as DebouncedFunction<T>;\n\n\t\tdebounced.cancel = () => {\n\t\t\tif (timeoutId) {\n\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\ttimeoutId = null;\n\t\t\t}\n\t\t};\n\n\t\treturn debounced;\n\t}\n\n\t// Throttle utility\n\tstatic createThrottle<T extends (...args: any[]) => void>(func: T, limit: number): T {\n\t\tlet inThrottle = false;\n\n\t\treturn ((...args: Parameters<T>) => {\n\t\t\tif (!inThrottle) {\n\t\t\t\tfunc(...args);\n\t\t\t\tinThrottle = true;\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tinThrottle = false;\n\t\t\t\t}, limit);\n\t\t\t}\n\t\t}) as T;\n\t}\n}\n\n// Singleton instance\nexport const unifiedTimerManager = UnifiedTimerManager.getInstance();\n"],"names":["_UnifiedTimerManager","constructor","__publicField","this","Map","instance","getInstance","clearInstance","clearAll","resetInstance","addInterval","id","callback","duration","intervals","has","log","warn","set","handle","type","startInterval","immediate","timer","get","error","setInterval","stopInterval","clearInterval","removeInterval","delete","addTimeout","timeouts","startTimeout","setTimeout","stopTimeout","clearTimeout","removeTimeout","forEach","_","clear","getRunningTimers","Array","from","entries","filter","map","isIntervalRunning","_a","isTimeoutRunning","addTimer","startTimer","stopTimer","removeTimer","hasTimer","isRunning","createDebounce","func","delay","timeoutId","debounced","args","cancel","createThrottle","limit","inThrottle","UnifiedTimerManager"],"mappings":"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"}