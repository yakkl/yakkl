{"version":3,"file":"DiU70Is3.js","sources":["../../../../../../../../node_modules/.pnpm/svelte@5.34.3/node_modules/svelte/src/internal/client/dom/elements/misc.js","../../../../../../../../node_modules/.pnpm/svelte@5.34.3/node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js","../../../../../../../../node_modules/.pnpm/svelte@5.34.3/node_modules/svelte/src/internal/client/dom/elements/events.js"],"sourcesContent":["import { hydrating } from '../hydration.js';\nimport { clear_text_content, get_first_child } from '../operations.js';\nimport { queue_micro_task } from '../task.js';\n\n/**\n * @param {HTMLElement} dom\n * @param {boolean} value\n * @returns {void}\n */\nexport function autofocus(dom, value) {\n\tif (value) {\n\t\tconst body = document.body;\n\t\tdom.autofocus = true;\n\n\t\tqueue_micro_task(() => {\n\t\t\tif (document.activeElement === body) {\n\t\t\t\tdom.focus();\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * The child of a textarea actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLTextAreaElement} dom\n * @returns {void}\n */\nexport function remove_textarea_child(dom) {\n\tif (hydrating && get_first_child(dom) !== null) {\n\t\tclear_text_content(dom);\n\t}\n}\n\nlet listening_to_form_reset = false;\n\nexport function add_form_reset_listener() {\n\tif (!listening_to_form_reset) {\n\t\tlistening_to_form_reset = true;\n\t\tdocument.addEventListener(\n\t\t\t'reset',\n\t\t\t(evt) => {\n\t\t\t\t// Needs to happen one tick later or else the dom properties of the form\n\t\t\t\t// elements have not updated to their reset values yet\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tif (!evt.defaultPrevented) {\n\t\t\t\t\t\tfor (const e of /**@type {HTMLFormElement} */ (evt.target).elements) {\n\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\te.__on_r?.();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t// In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)\n\t\t\t{ capture: true }\n\t\t);\n\t}\n}\n","import { teardown } from '../../../reactivity/effects.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tset_active_effect,\n\tset_active_reaction\n} from '../../../runtime.js';\nimport { add_form_reset_listener } from '../misc.js';\n\n/**\n * Fires the handler once immediately (unless corresponding arg is set to `false`),\n * then listens to the given events until the render effect context is destroyed\n * @param {EventTarget} target\n * @param {Array<string>} events\n * @param {(event?: Event) => void} handler\n * @param {any} call_handler_immediately\n */\nexport function listen(target, events, handler, call_handler_immediately = true) {\n\tif (call_handler_immediately) {\n\t\thandler();\n\t}\n\n\tfor (var name of events) {\n\t\ttarget.addEventListener(name, handler);\n\t}\n\n\tteardown(() => {\n\t\tfor (var name of events) {\n\t\t\ttarget.removeEventListener(name, handler);\n\t\t}\n\t});\n}\n\n/**\n * @template T\n * @param {() => T} fn\n */\nexport function without_reactive_context(fn) {\n\tvar previous_reaction = active_reaction;\n\tvar previous_effect = active_effect;\n\tset_active_reaction(null);\n\tset_active_effect(null);\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tset_active_reaction(previous_reaction);\n\t\tset_active_effect(previous_effect);\n\t}\n}\n\n/**\n * Listen to the given event, and then instantiate a global form reset listener if not already done,\n * to notify all bindings when the form is reset\n * @param {HTMLElement} element\n * @param {string} event\n * @param {(is_reset?: true) => void} handler\n * @param {(is_reset?: true) => void} [on_reset]\n */\nexport function listen_to_event_and_reset_event(element, event, handler, on_reset = handler) {\n\telement.addEventListener(event, () => without_reactive_context(handler));\n\t// @ts-expect-error\n\tconst prev = element.__on_r;\n\tif (prev) {\n\t\t// special case for checkbox that can have multiple binds (group & checked)\n\t\t// @ts-expect-error\n\t\telement.__on_r = () => {\n\t\t\tprev();\n\t\t\ton_reset(true);\n\t\t};\n\t} else {\n\t\t// @ts-expect-error\n\t\telement.__on_r = () => on_reset(true);\n\t}\n\n\tadd_form_reset_listener();\n}\n","import { teardown } from '../../reactivity/effects.js';\nimport { define_property, is_array } from '../../../shared/utils.js';\nimport { hydrating } from '../hydration.js';\nimport { queue_micro_task } from '../task.js';\nimport { FILENAME } from '../../../../constants.js';\nimport * as w from '../../warnings.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tset_active_effect,\n\tset_active_reaction\n} from '../../runtime.js';\nimport { without_reactive_context } from './bindings/shared.js';\n\n/** @type {Set<string>} */\nexport const all_registered_events = new Set();\n\n/** @type {Set<(events: Array<string>) => void>} */\nexport const root_event_handles = new Set();\n\n/**\n * SSR adds onload and onerror attributes to catch those events before the hydration.\n * This function detects those cases, removes the attributes and replays the events.\n * @param {HTMLElement} dom\n */\nexport function replay_events(dom) {\n\tif (!hydrating) return;\n\n\tdom.removeAttribute('onload');\n\tdom.removeAttribute('onerror');\n\t// @ts-expect-error\n\tconst event = dom.__e;\n\tif (event !== undefined) {\n\t\t// @ts-expect-error\n\t\tdom.__e = undefined;\n\t\tqueueMicrotask(() => {\n\t\t\tif (dom.isConnected) {\n\t\t\t\tdom.dispatchEvent(event);\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * @param {string} event_name\n * @param {EventTarget} dom\n * @param {EventListener} [handler]\n * @param {AddEventListenerOptions} [options]\n */\nexport function create_event(event_name, dom, handler, options = {}) {\n\t/**\n\t * @this {EventTarget}\n\t */\n\tfunction target_handler(/** @type {Event} */ event) {\n\t\tif (!options.capture) {\n\t\t\t// Only call in the bubble phase, else delegated events would be called before the capturing events\n\t\t\thandle_event_propagation.call(dom, event);\n\t\t}\n\t\tif (!event.cancelBubble) {\n\t\t\treturn without_reactive_context(() => {\n\t\t\t\treturn handler?.call(this, event);\n\t\t\t});\n\t\t}\n\t}\n\n\t// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned\n\t// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we\n\t// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes\n\t// this bug. The same applies to wheel events and touch events.\n\tif (\n\t\tevent_name.startsWith('pointer') ||\n\t\tevent_name.startsWith('touch') ||\n\t\tevent_name === 'wheel'\n\t) {\n\t\tqueue_micro_task(() => {\n\t\t\tdom.addEventListener(event_name, target_handler, options);\n\t\t});\n\t} else {\n\t\tdom.addEventListener(event_name, target_handler, options);\n\t}\n\n\treturn target_handler;\n}\n\n/**\n * Attaches an event handler to an element and returns a function that removes the handler. Using this\n * rather than `addEventListener` will preserve the correct order relative to handlers added declaratively\n * (with attributes like `onclick`), which use event delegation for performance reasons\n *\n * @param {EventTarget} element\n * @param {string} type\n * @param {EventListener} handler\n * @param {AddEventListenerOptions} [options]\n */\nexport function on(element, type, handler, options = {}) {\n\tvar target_handler = create_event(type, element, handler, options);\n\n\treturn () => {\n\t\telement.removeEventListener(type, target_handler, options);\n\t};\n}\n\n/**\n * @param {string} event_name\n * @param {Element} dom\n * @param {EventListener} [handler]\n * @param {boolean} [capture]\n * @param {boolean} [passive]\n * @returns {void}\n */\nexport function event(event_name, dom, handler, capture, passive) {\n\tvar options = { capture, passive };\n\tvar target_handler = create_event(event_name, dom, handler, options);\n\n\tif (\n\t\tdom === document.body ||\n\t\t// @ts-ignore\n\t\tdom === window ||\n\t\t// @ts-ignore\n\t\tdom === document ||\n\t\t// Firefox has quirky behavior, it can happen that we still get \"canplay\" events when the element is already removed\n\t\tdom instanceof HTMLMediaElement\n\t) {\n\t\tteardown(() => {\n\t\t\tdom.removeEventListener(event_name, target_handler, options);\n\t\t});\n\t}\n}\n\n/**\n * @param {Array<string>} events\n * @returns {void}\n */\nexport function delegate(events) {\n\tfor (var i = 0; i < events.length; i++) {\n\t\tall_registered_events.add(events[i]);\n\t}\n\n\tfor (var fn of root_event_handles) {\n\t\tfn(events);\n\t}\n}\n\n/**\n * @this {EventTarget}\n * @param {Event} event\n * @returns {void}\n */\nexport function handle_event_propagation(event) {\n\tvar handler_element = this;\n\tvar owner_document = /** @type {Node} */ (handler_element).ownerDocument;\n\tvar event_name = event.type;\n\tvar path = event.composedPath?.() || [];\n\tvar current_target = /** @type {null | Element} */ (path[0] || event.target);\n\n\t// composedPath contains list of nodes the event has propagated through.\n\t// We check __root to skip all nodes below it in case this is a\n\t// parent of the __root node, which indicates that there's nested\n\t// mounted apps. In this case we don't want to trigger events multiple times.\n\tvar path_idx = 0;\n\n\t// @ts-expect-error is added below\n\tvar handled_at = event.__root;\n\n\tif (handled_at) {\n\t\tvar at_idx = path.indexOf(handled_at);\n\t\tif (\n\t\t\tat_idx !== -1 &&\n\t\t\t(handler_element === document || handler_element === /** @type {any} */ (window))\n\t\t) {\n\t\t\t// This is the fallback document listener or a window listener, but the event was already handled\n\t\t\t// -> ignore, but set handle_at to document/window so that we're resetting the event\n\t\t\t// chain in case someone manually dispatches the same event object again.\n\t\t\t// @ts-expect-error\n\t\t\tevent.__root = handler_element;\n\t\t\treturn;\n\t\t}\n\n\t\t// We're deliberately not skipping if the index is higher, because\n\t\t// someone could create an event programmatically and emit it multiple times,\n\t\t// in which case we want to handle the whole propagation chain properly each time.\n\t\t// (this will only be a false negative if the event is dispatched multiple times and\n\t\t// the fallback document listener isn't reached in between, but that's super rare)\n\t\tvar handler_idx = path.indexOf(handler_element);\n\t\tif (handler_idx === -1) {\n\t\t\t// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)\n\t\t\t// so guard against that, too, and assume that everything was handled at this point.\n\t\t\treturn;\n\t\t}\n\n\t\tif (at_idx <= handler_idx) {\n\t\t\tpath_idx = at_idx;\n\t\t}\n\t}\n\n\tcurrent_target = /** @type {Element} */ (path[path_idx] || event.target);\n\t// there can only be one delegated event per element, and we either already handled the current target,\n\t// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe\n\t// to handle a possible delegated event on it later (through the root delegation listener for example).\n\tif (current_target === handler_element) return;\n\n\t// Proxy currentTarget to correct target\n\tdefine_property(event, 'currentTarget', {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn current_target || owner_document;\n\t\t}\n\t});\n\n\t// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,\n\t// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic\n\t// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,\n\t// it's probably best that all event handled by Svelte have this behaviour, as we don't really want\n\t// an event handler to run in the context of another reaction or effect.\n\tvar previous_reaction = active_reaction;\n\tvar previous_effect = active_effect;\n\tset_active_reaction(null);\n\tset_active_effect(null);\n\n\ttry {\n\t\t/**\n\t\t * @type {unknown}\n\t\t */\n\t\tvar throw_error;\n\t\t/**\n\t\t * @type {unknown[]}\n\t\t */\n\t\tvar other_errors = [];\n\n\t\twhile (current_target !== null) {\n\t\t\t/** @type {null | Element} */\n\t\t\tvar parent_element =\n\t\t\t\tcurrent_target.assignedSlot ||\n\t\t\t\tcurrent_target.parentNode ||\n\t\t\t\t/** @type {any} */ (current_target).host ||\n\t\t\t\tnull;\n\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvar delegated = current_target['__' + event_name];\n\n\t\t\t\tif (\n\t\t\t\t\tdelegated != null &&\n\t\t\t\t\t(!(/** @type {any} */ (current_target).disabled) ||\n\t\t\t\t\t\t// DOM could've been updated already by the time this is reached, so we check this as well\n\t\t\t\t\t\t// -> the target could not have been disabled because it emits the event in the first place\n\t\t\t\t\t\tevent.target === current_target)\n\t\t\t\t) {\n\t\t\t\t\tif (is_array(delegated)) {\n\t\t\t\t\t\tvar [fn, ...data] = delegated;\n\t\t\t\t\t\tfn.apply(current_target, [event, ...data]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelegated.call(current_target, event);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (throw_error) {\n\t\t\t\t\tother_errors.push(error);\n\t\t\t\t} else {\n\t\t\t\t\tthrow_error = error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (event.cancelBubble || parent_element === handler_element || parent_element === null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_target = parent_element;\n\t\t}\n\n\t\tif (throw_error) {\n\t\t\tfor (let error of other_errors) {\n\t\t\t\t// Throw the rest of the errors, one-by-one on a microtask\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t\t}\n\t\t\tthrow throw_error;\n\t\t}\n\t} finally {\n\t\t// @ts-expect-error is used above\n\t\tevent.__root = handler_element;\n\t\t// @ts-ignore remove proxy on currentTarget\n\t\tdelete event.currentTarget;\n\t\tset_active_reaction(previous_reaction);\n\t\tset_active_effect(previous_effect);\n\t}\n}\n\n/**\n * In dev, warn if an event handler is not a function, as it means the\n * user probably called the handler or forgot to add a `() =>`\n * @param {() => (event: Event, ...args: any) => void} thunk\n * @param {EventTarget} element\n * @param {[Event, ...any]} args\n * @param {any} component\n * @param {[number, number]} [loc]\n * @param {boolean} [remove_parens]\n */\nexport function apply(\n\tthunk,\n\telement,\n\targs,\n\tcomponent,\n\tloc,\n\thas_side_effects = false,\n\tremove_parens = false\n) {\n\tlet handler;\n\tlet error;\n\n\ttry {\n\t\thandler = thunk();\n\t} catch (e) {\n\t\terror = e;\n\t}\n\n\tif (typeof handler !== 'function' && (has_side_effects || handler != null || error)) {\n\t\tconst filename = component?.[FILENAME];\n\t\tconst location = loc ? ` at ${filename}:${loc[0]}:${loc[1]}` : ` in ${filename}`;\n\t\tconst phase = args[0]?.eventPhase < Event.BUBBLING_PHASE ? 'capture' : '';\n\t\tconst event_name = args[0]?.type + phase;\n\t\tconst description = `\\`${event_name}\\` handler${location}`;\n\t\tconst suggestion = remove_parens ? 'remove the trailing `()`' : 'add a leading `() =>`';\n\n\t\tw.event_handler_invalid(description, suggestion);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\t}\n\thandler?.apply(element, args);\n}\n"],"names":["autofocus","dom","value","body","document","queue_micro_task","activeElement","focus","remove_textarea_child","hydrating","get_first_child","clear_text_content","listening_to_form_reset","add_form_reset_listener","addEventListener","evt","Promise","resolve","then","defaultPrevented","e","target","elements","_a","__on_r","call","capture","without_reactive_context","fn","previous_reaction","active_reaction","previous_effect","active_effect","set_active_reaction","set_active_effect","listen_to_event_and_reset_event","element","event","handler","on_reset","prev","all_registered_events","Set","root_event_handles","replay_events","removeAttribute","__e","queueMicrotask","isConnected","dispatchEvent","create_event","event_name","options","target_handler","handle_event_propagation","cancelBubble","this","startsWith","passive","window","HTMLMediaElement","teardown","removeEventListener","delegate","events","i","length","add","handler_element","owner_document","type","path","composedPath","current_target","path_idx","handled_at","__root","at_idx","indexOf","handler_idx","define_property","configurable","get","throw_error","other_errors","parent_element","assignedSlot","parentNode","host","delegated","disabled","is_array","data","apply","error","push","currentTarget","thunk","args","component","loc","has_side_effects","remove_parens","filename","FILENAME","location","phase","eventPhase","Event","BUBBLING_PHASE","_b","description","suggestion","w.event_handler_invalid"],"mappings":"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","x_google_ignoreList":[0,1,2]}