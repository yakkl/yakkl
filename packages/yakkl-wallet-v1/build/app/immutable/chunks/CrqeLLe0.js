const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./DpKLkluw.js","./WDN37msH.js"])))=>i.map(i=>d[i]);
import{as as TIMER_TOKEN_PRICE_CYCLE_TIME,aj as yakklCombinedTokenStore,at as setYakklCombinedTokenStorage,_ as __vitePreload}from"./Cb2naUpm.js";import{w as writable,g as get}from"./B2gA1VsD.js";import{l as log}from"./WDN37msH.js";import{P as PriceManager}from"./CZAHYQZy.js";import{T as TimerManager}from"./BKVO1wI8.js";function createPriceUpdater(priceManager2){const tokens=writable([]);const{subscribe:subscribe,set:set}=tokens;async function fetchPrices(tokensArray){const BATCH_SIZE=8;const updatedTokens=[];if(!tokensArray||tokensArray.length===0){log.error("fetchPrices - No tokens to process. Exiting early.");return[]}for(let i=0;i<tokensArray.length;i+=BATCH_SIZE){const batch=tokensArray.slice(i,i+BATCH_SIZE);try{const batchResults=await Promise.all(batch.map(async token=>fetchTokenData(token,priceManager2)));updatedTokens.push(...batchResults)}catch(error){log.error("fetchPrices - Error processing batch:",false,batch,false,error)}}return updatedTokens}async function fetchTokenData(token,priceManager22){const pair=`${token.symbol}-USD`;try{const marketPrice=await priceManager22.getMarketPrice(pair);const price=(marketPrice==null?void 0:marketPrice.price)??0;const adjustedBalance=token.balance?Number(token.balance)/10**token.decimals:0;const value=adjustedBalance*price;return{...token,price:{price:price,provider:(marketPrice==null?void 0:marketPrice.provider)??"",lastUpdated:new Date},value:value,formattedValue:new Intl.NumberFormat("en-US",{style:"currency",currency:"USD"}).format(value)}}catch(error){log.error(`fetchTokenData - Failed to fetch price for ${token.symbol}`,false,error);return{...token,price:{price:0,provider:"",lastUpdated:new Date},value:0}}}return{subscribe:subscribe,fetchPrices:fetchPrices}}let priceManager=null;let priceUpdater=null;const fetchingActive=writable(false);async function updateTokenPrices(){if(get(fetchingActive))return;fetchingActive.set(true);try{log.info("updateTokenPrices: Starting price update");const tokens=get(yakklCombinedTokenStore);if(tokens.length===0){log.info("updateTokenPrices: No tokens to update");return}const updatedTokens=await priceUpdater.fetchPrices(tokens);if(!updatedTokens||updatedTokens.length===0){log.warn("updateTokenPrices: Fetched prices returned empty.");return}yakklCombinedTokenStore.update(()=>updatedTokens);await setYakklCombinedTokenStorage(updatedTokens);const{balanceCacheManager:balanceCacheManager}=await __vitePreload(async()=>{const{balanceCacheManager:balanceCacheManager2}=await import("./DpKLkluw.js");return{balanceCacheManager:balanceCacheManager2}},true?__vite__mapDeps([0,1]):void 0,import.meta.url);const ethToken=updatedTokens.find(token=>token.isNative&&token.symbol==="ETH");if(ethToken&&ethToken.value&&ethToken.value>0){balanceCacheManager.updatePriceForAllEntries(ethToken.value);log.debug("[updateTokenPrices] Updated cached entries with ETH price:",false,{newPrice:ethToken.value})}log.info("updateTokenPrices: Successfully updated and persisted token prices")}catch(error){log.error("updateTokenPrices: Failed to update token prices",false,error)}finally{fetchingActive.set(false)}}const timerManager=TimerManager.getInstance();if(!timerManager.hasTimer("tokenPriceUpdater")){log.info("Setting up token price updater timer");if(!priceManager){priceManager=new PriceManager}if(!priceUpdater){priceUpdater=createPriceUpdater(priceManager)}timerManager.addTimer("tokenPriceUpdater",async()=>{await updateTokenPrices()},TIMER_TOKEN_PRICE_CYCLE_TIME)}if(!timerManager.isRunning("tokenPriceUpdater")){log.info("Starting token price updater timer");timerManager.startTimer("tokenPriceUpdater")}export{updateTokenPrices as u};
//# sourceMappingURL=CrqeLLe0.js.map
