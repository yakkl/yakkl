{"version":3,"file":"DraJ8LN-.js","sources":["../../../../../../../../node_modules/.pnpm/svelte@5.34.3/node_modules/svelte/src/internal/client/dom/blocks/each.js"],"sourcesContent":["/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */\nimport {\n\tEACH_INDEX_REACTIVE,\n\tEACH_IS_ANIMATED,\n\tEACH_IS_CONTROLLED,\n\tEACH_ITEM_IMMUTABLE,\n\tEACH_ITEM_REACTIVE,\n\tHYDRATION_END,\n\tHYDRATION_START_ELSE\n} from '../../../../constants.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tread_hydration_instruction,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport {\n\tclear_text_content,\n\tcreate_text,\n\tget_first_child,\n\tget_next_sibling\n} from '../operations.js';\nimport {\n\tblock,\n\tbranch,\n\tdestroy_effect,\n\trun_out_transitions,\n\tpause_children,\n\tpause_effect,\n\tresume_effect\n} from '../../reactivity/effects.js';\nimport { source, mutable_source, internal_set } from '../../reactivity/sources.js';\nimport { array_from, is_array } from '../../../shared/utils.js';\nimport { INERT } from '#client/constants';\nimport { queue_micro_task } from '../task.js';\nimport { active_effect, get } from '../../runtime.js';\nimport { DEV } from 'esm-env';\nimport { derived_safe_equal } from '../../reactivity/deriveds.js';\n\n/**\n * The row of a keyed each block that is currently updating. We track this\n * so that `animate:` directives have something to attach themselves to\n * @type {EachItem | null}\n */\nexport let current_each_item = null;\n\n/** @param {EachItem | null} item */\nexport function set_current_each_item(item) {\n\tcurrent_each_item = item;\n}\n\n/**\n * @param {any} _\n * @param {number} i\n */\nexport function index(_, i) {\n\treturn i;\n}\n\n/**\n * Pause multiple effects simultaneously, and coordinate their\n * subsequent destruction. Used in each blocks\n * @param {EachState} state\n * @param {EachItem[]} items\n * @param {null | Node} controlled_anchor\n * @param {Map<any, EachItem>} items_map\n */\nfunction pause_effects(state, items, controlled_anchor, items_map) {\n\t/** @type {TransitionManager[]} */\n\tvar transitions = [];\n\tvar length = items.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tpause_children(items[i].e, transitions, true);\n\t}\n\n\tvar is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;\n\t// If we have a controlled anchor, it means that the each block is inside a single\n\t// DOM element, so we can apply a fast-path for clearing the contents of the element.\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (\n\t\t\t/** @type {Element} */ (controlled_anchor).parentNode\n\t\t);\n\t\tclear_text_content(parent_node);\n\t\tparent_node.append(/** @type {Element} */ (controlled_anchor));\n\t\titems_map.clear();\n\t\tlink(state, items[0].prev, items[length - 1].next);\n\t}\n\n\trun_out_transitions(transitions, () => {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar item = items[i];\n\t\t\tif (!is_controlled) {\n\t\t\t\titems_map.delete(item.k);\n\t\t\t\tlink(state, item.prev, item.next);\n\t\t\t}\n\t\t\tdestroy_effect(item.e, !is_controlled);\n\t\t}\n\t});\n}\n\n/**\n * @template V\n * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @param {(value: V, index: number) => any} get_key\n * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @returns {void}\n */\nexport function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {\n\tvar anchor = node;\n\n\t/** @type {EachState} */\n\tvar state = { flags, items: new Map(), first: null };\n\n\tvar is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (node);\n\n\t\tanchor = hydrating\n\t\t\t? set_hydrate_node(/** @type {Comment | Text} */ (get_first_child(parent_node)))\n\t\t\t: parent_node.appendChild(create_text());\n\t}\n\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\t/** @type {Effect | null} */\n\tvar fallback = null;\n\n\tvar was_empty = false;\n\n\t// TODO: ideally we could use derived for runes mode but because of the ability\n\t// to use a store which can be mutated, we can't do that here as mutating a store\n\t// will still result in the collection array being the same from the store\n\tvar each_array = derived_safe_equal(() => {\n\t\tvar collection = get_collection();\n\n\t\treturn is_array(collection) ? collection : collection == null ? [] : array_from(collection);\n\t});\n\n\tblock(() => {\n\t\tvar array = get(each_array);\n\t\tvar length = array.length;\n\n\t\tif (was_empty && length === 0) {\n\t\t\t// ignore updates if the array is empty,\n\t\t\t// and it already was empty on previous run\n\t\t\treturn;\n\t\t}\n\t\twas_empty = length === 0;\n\n\t\t/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tvar is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;\n\n\t\t\tif (is_else !== (length === 0)) {\n\t\t\t\t// hydration mismatch â€” remove the server-rendered DOM and start over\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\t// this is separate to the previous block because `hydrating` might change\n\t\tif (hydrating) {\n\t\t\t/** @type {EachItem | null} */\n\t\t\tvar prev = null;\n\n\t\t\t/** @type {EachItem} */\n\t\t\tvar item;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tif (\n\t\t\t\t\thydrate_node.nodeType === 8 &&\n\t\t\t\t\t/** @type {Comment} */ (hydrate_node).data === HYDRATION_END\n\t\t\t\t) {\n\t\t\t\t\t// The server rendered fewer items than expected,\n\t\t\t\t\t// so break out and continue appending non-hydrated items\n\t\t\t\t\tanchor = /** @type {Comment} */ (hydrate_node);\n\t\t\t\t\tmismatch = true;\n\t\t\t\t\tset_hydrating(false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvar value = array[i];\n\t\t\t\tvar key = get_key(value, i);\n\t\t\t\titem = create_item(\n\t\t\t\t\thydrate_node,\n\t\t\t\t\tstate,\n\t\t\t\t\tprev,\n\t\t\t\t\tnull,\n\t\t\t\t\tvalue,\n\t\t\t\t\tkey,\n\t\t\t\t\ti,\n\t\t\t\t\trender_fn,\n\t\t\t\t\tflags,\n\t\t\t\t\tget_collection\n\t\t\t\t);\n\t\t\t\tstate.items.set(key, item);\n\n\t\t\t\tprev = item;\n\t\t\t}\n\n\t\t\t// remove excess nodes\n\t\t\tif (length > 0) {\n\t\t\t\tset_hydrate_node(remove_nodes());\n\t\t\t}\n\t\t}\n\n\t\tif (!hydrating) {\n\t\t\treconcile(array, state, anchor, render_fn, flags, get_key, get_collection);\n\t\t}\n\n\t\tif (fallback_fn !== null) {\n\t\t\tif (length === 0) {\n\t\t\t\tif (fallback) {\n\t\t\t\t\tresume_effect(fallback);\n\t\t\t\t} else {\n\t\t\t\t\tfallback = branch(() => fallback_fn(anchor));\n\t\t\t\t}\n\t\t\t} else if (fallback !== null) {\n\t\t\t\tpause_effect(fallback, () => {\n\t\t\t\t\tfallback = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\n\t\t// When we mount the each block for the first time, the collection won't be\n\t\t// connected to this effect as the effect hasn't finished running yet and its deps\n\t\t// won't be assigned. However, it's possible that when reconciling the each block\n\t\t// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the\n\t\t// collection again can provide consistency to the reactive graph again as the deriveds\n\t\t// will now be `CLEAN`.\n\t\tget(each_array);\n\t});\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n\n/**\n * Add, remove, or reorder items output by an each block as its input changes\n * @template V\n * @param {Array<V>} array\n * @param {EachState} state\n * @param {Element | Comment | Text} anchor\n * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>, collection: () => V[]) => void} render_fn\n * @param {number} flags\n * @param {(value: V, index: number) => any} get_key\n * @param {() => V[]} get_collection\n * @returns {void}\n */\nfunction reconcile(array, state, anchor, render_fn, flags, get_key, get_collection) {\n\tvar is_animated = (flags & EACH_IS_ANIMATED) !== 0;\n\tvar should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;\n\n\tvar length = array.length;\n\tvar items = state.items;\n\tvar first = state.first;\n\tvar current = first;\n\n\t/** @type {undefined | Set<EachItem>} */\n\tvar seen;\n\n\t/** @type {EachItem | null} */\n\tvar prev = null;\n\n\t/** @type {undefined | Set<EachItem>} */\n\tvar to_animate;\n\n\t/** @type {EachItem[]} */\n\tvar matched = [];\n\n\t/** @type {EachItem[]} */\n\tvar stashed = [];\n\n\t/** @type {V} */\n\tvar value;\n\n\t/** @type {any} */\n\tvar key;\n\n\t/** @type {EachItem | undefined} */\n\tvar item;\n\n\t/** @type {number} */\n\tvar i;\n\n\tif (is_animated) {\n\t\tfor (i = 0; i < length; i += 1) {\n\t\t\tvalue = array[i];\n\t\t\tkey = get_key(value, i);\n\t\t\titem = items.get(key);\n\n\t\t\tif (item !== undefined) {\n\t\t\t\titem.a?.measure();\n\t\t\t\t(to_animate ??= new Set()).add(item);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < length; i += 1) {\n\t\tvalue = array[i];\n\t\tkey = get_key(value, i);\n\t\titem = items.get(key);\n\n\t\tif (item === undefined) {\n\t\t\tvar child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;\n\n\t\t\tprev = create_item(\n\t\t\t\tchild_anchor,\n\t\t\t\tstate,\n\t\t\t\tprev,\n\t\t\t\tprev === null ? state.first : prev.next,\n\t\t\t\tvalue,\n\t\t\t\tkey,\n\t\t\t\ti,\n\t\t\t\trender_fn,\n\t\t\t\tflags,\n\t\t\t\tget_collection\n\t\t\t);\n\n\t\t\titems.set(key, prev);\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\tcurrent = prev.next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (should_update) {\n\t\t\tupdate_item(item, value, i, flags);\n\t\t}\n\n\t\tif ((item.e.f & INERT) !== 0) {\n\t\t\tresume_effect(item.e);\n\t\t\tif (is_animated) {\n\t\t\t\titem.a?.unfix();\n\t\t\t\t(to_animate ??= new Set()).delete(item);\n\t\t\t}\n\t\t}\n\n\t\tif (item !== current) {\n\t\t\tif (seen !== undefined && seen.has(item)) {\n\t\t\t\tif (matched.length < stashed.length) {\n\t\t\t\t\t// more efficient to move later items to the front\n\t\t\t\t\tvar start = stashed[0];\n\t\t\t\t\tvar j;\n\n\t\t\t\t\tprev = start.prev;\n\n\t\t\t\t\tvar a = matched[0];\n\t\t\t\t\tvar b = matched[matched.length - 1];\n\n\t\t\t\t\tfor (j = 0; j < matched.length; j += 1) {\n\t\t\t\t\t\tmove(matched[j], start, anchor);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (j = 0; j < stashed.length; j += 1) {\n\t\t\t\t\t\tseen.delete(stashed[j]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlink(state, a.prev, b.next);\n\t\t\t\t\tlink(state, prev, a);\n\t\t\t\t\tlink(state, b, start);\n\n\t\t\t\t\tcurrent = start;\n\t\t\t\t\tprev = b;\n\t\t\t\t\ti -= 1;\n\n\t\t\t\t\tmatched = [];\n\t\t\t\t\tstashed = [];\n\t\t\t\t} else {\n\t\t\t\t\t// more efficient to move earlier items to the back\n\t\t\t\t\tseen.delete(item);\n\t\t\t\t\tmove(item, current, anchor);\n\n\t\t\t\t\tlink(state, item.prev, item.next);\n\t\t\t\t\tlink(state, item, prev === null ? state.first : prev.next);\n\t\t\t\t\tlink(state, prev, item);\n\n\t\t\t\t\tprev = item;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\twhile (current !== null && current.k !== key) {\n\t\t\t\t// If the each block isn't inert and an item has an effect that is already inert,\n\t\t\t\t// skip over adding it to our seen Set as the item is already being handled\n\t\t\t\tif ((current.e.f & INERT) === 0) {\n\t\t\t\t\t(seen ??= new Set()).add(current);\n\t\t\t\t}\n\t\t\t\tstashed.push(current);\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titem = current;\n\t\t}\n\n\t\tmatched.push(item);\n\t\tprev = item;\n\t\tcurrent = item.next;\n\t}\n\n\tif (current !== null || seen !== undefined) {\n\t\tvar to_destroy = seen === undefined ? [] : array_from(seen);\n\n\t\twhile (current !== null) {\n\t\t\t// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished\n\t\t\tif ((current.e.f & INERT) === 0) {\n\t\t\t\tto_destroy.push(current);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\n\t\tvar destroy_length = to_destroy.length;\n\n\t\tif (destroy_length > 0) {\n\t\t\tvar controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;\n\n\t\t\tif (is_animated) {\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].a?.measure();\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].a?.fix();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpause_effects(state, to_destroy, controlled_anchor, items);\n\t\t}\n\t}\n\n\tif (is_animated) {\n\t\tqueue_micro_task(() => {\n\t\t\tif (to_animate === undefined) return;\n\t\t\tfor (item of to_animate) {\n\t\t\t\titem.a?.apply();\n\t\t\t}\n\t\t});\n\t}\n\n\t/** @type {Effect} */ (active_effect).first = state.first && state.first.e;\n\t/** @type {Effect} */ (active_effect).last = prev && prev.e;\n}\n\n/**\n * @param {EachItem} item\n * @param {any} value\n * @param {number} index\n * @param {number} type\n * @returns {void}\n */\nfunction update_item(item, value, index, type) {\n\tif ((type & EACH_ITEM_REACTIVE) !== 0) {\n\t\tinternal_set(item.v, value);\n\t}\n\n\tif ((type & EACH_INDEX_REACTIVE) !== 0) {\n\t\tinternal_set(/** @type {Value<number>} */ (item.i), index);\n\t} else {\n\t\titem.i = index;\n\t}\n}\n\n/**\n * @template V\n * @param {Node} anchor\n * @param {EachState} state\n * @param {EachItem | null} prev\n * @param {EachItem | null} next\n * @param {V} value\n * @param {unknown} key\n * @param {number} index\n * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>, collection: () => V[]) => void} render_fn\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @returns {EachItem}\n */\nfunction create_item(\n\tanchor,\n\tstate,\n\tprev,\n\tnext,\n\tvalue,\n\tkey,\n\tindex,\n\trender_fn,\n\tflags,\n\tget_collection\n) {\n\tvar previous_each_item = current_each_item;\n\tvar reactive = (flags & EACH_ITEM_REACTIVE) !== 0;\n\tvar mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;\n\n\tvar v = reactive ? (mutable ? mutable_source(value, false, false) : source(value)) : value;\n\tvar i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);\n\n\tif (DEV && reactive) {\n\t\t// For tracing purposes, we need to link the source signal we create with the\n\t\t// collection + index so that tracing works as intended\n\t\t/** @type {Value} */ (v).trace = () => {\n\t\t\tvar collection_index = typeof i === 'number' ? index : i.v;\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-expressions\n\t\t\tget_collection()[collection_index];\n\t\t};\n\t}\n\n\t/** @type {EachItem} */\n\tvar item = {\n\t\ti,\n\t\tv,\n\t\tk: key,\n\t\ta: null,\n\t\t// @ts-expect-error\n\t\te: null,\n\t\tprev,\n\t\tnext\n\t};\n\n\tcurrent_each_item = item;\n\n\ttry {\n\t\titem.e = branch(() => render_fn(anchor, v, i, get_collection), hydrating);\n\n\t\titem.e.prev = prev && prev.e;\n\t\titem.e.next = next && next.e;\n\n\t\tif (prev === null) {\n\t\t\tstate.first = item;\n\t\t} else {\n\t\t\tprev.next = item;\n\t\t\tprev.e.next = item.e;\n\t\t}\n\n\t\tif (next !== null) {\n\t\t\tnext.prev = item;\n\t\t\tnext.e.prev = item.e;\n\t\t}\n\n\t\treturn item;\n\t} finally {\n\t\tcurrent_each_item = previous_each_item;\n\t}\n}\n\n/**\n * @param {EachItem} item\n * @param {EachItem | null} next\n * @param {Text | Element | Comment} anchor\n */\nfunction move(item, next, anchor) {\n\tvar end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;\n\n\tvar dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;\n\tvar node = /** @type {TemplateNode} */ (item.e.nodes_start);\n\n\twhile (node !== end) {\n\t\tvar next_node = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\tdest.before(node);\n\t\tnode = next_node;\n\t}\n}\n\n/**\n * @param {EachState} state\n * @param {EachItem | null} prev\n * @param {EachItem | null} next\n */\nfunction link(state, prev, next) {\n\tif (prev === null) {\n\t\tstate.first = next;\n\t} else {\n\t\tprev.next = next;\n\t\tprev.e.next = next && next.e;\n\t}\n\n\tif (next !== null) {\n\t\tnext.prev = prev;\n\t\tnext.e.prev = prev && prev.e;\n\t}\n}\n"],"names":["index","_","i","pause_effects","state","items","controlled_anchor","items_map","transitions","length","pause_children","e","is_controlled","parent_node","clear_text_content","append","clear","link","prev","next","run_out_transitions","item","delete","k","destroy_effect","each","node","flags","get_collection","get_key","render_fn","fallback_fn","anchor","Map","first","EACH_IS_CONTROLLED","hydrating","set_hydrate_node","get_first_child","appendChild","create_text","hydrate_next","fallback","was_empty","each_array","derived_safe_equal","collection","is_array","array_from","block","array","get","mismatch","is_else","read_hydration_instruction","HYDRATION_START_ELSE","remove_nodes","set_hydrating","hydrate_node","nodeType","data","HYDRATION_END","value","key","create_item","set","reconcile","resume_effect","branch","pause_effect","is_animated","EACH_IS_ANIMATED","should_update","EACH_ITEM_REACTIVE","EACH_INDEX_REACTIVE","current","seen","to_animate","matched","stashed","_a","a","measure","Set","add","child_anchor","update_item","f","INERT","_b","unfix","has","start","j","b","move","push","to_destroy","destroy_length","_c","_d","fix","queue_micro_task","apply","active_effect","last","type","internal_set","v","reactive","mutable","EACH_ITEM_IMMUTABLE","mutable_source","source","trace","collection_index","end","dest","next_node","get_next_sibling","before"],"mappings":"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","x_google_ignoreList":[0]}