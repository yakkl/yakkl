{"version":3,"file":"yYzfI9LL.js","sources":["../../../../../../../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/ws.js","../../../../../../../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js","../../../../../../../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/global.js","../../../../../../../../node_modules/.pnpm/websocket@1.0.35/node_modules/websocket/lib/version.js","../../../../../../../../node_modules/.pnpm/websocket@1.0.35/node_modules/websocket/lib/browser.js","../../../../../../../../node_modules/.pnpm/sturdy-websocket@0.2.1/node_modules/sturdy-websocket/dist/index.js","../../../../../../../../node_modules/.pnpm/alchemy-sdk@3.6.0_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10/node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-98da5bb0.js"],"sourcesContent":["\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nlet WS = null;\ntry {\n    WS = WebSocket;\n    if (WS == null) {\n        throw new Error(\"inject please\");\n    }\n}\ncatch (error) {\n    const logger = new Logger(version);\n    WS = function () {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    };\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n//# sourceMappingURL=ws.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\nlet NextId = 1;\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\nexport class WebSocketProvider extends JsonRpcProvider {\n    constructor(url, network) {\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n        if (typeof (url) === \"string\") {\n            super(url, network);\n        }\n        else {\n            super(\"_websocket\", network);\n        }\n        this._pollingInterval = -1;\n        this._wsReady = false;\n        if (typeof (url) === \"string\") {\n            defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        }\n        else {\n            defineReadOnly(this, \"_websocket\", url);\n        }\n        defineReadOnly(this, \"_requests\", {});\n        defineReadOnly(this, \"_subs\", {});\n        defineReadOnly(this, \"_subIds\", {});\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n        // Stall sending requests until the socket is open...\n        this.websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this.websocket.send(this._requests[id].payload);\n            });\n        };\n        this.websocket.onmessage = (messageEvent) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n                }\n                else {\n                    let error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(error, \"code\", result.error.code || null);\n                        defineReadOnly(error, \"response\", data);\n                    }\n                    else {\n                        error = new Error(\"unknown error\");\n                    }\n                    request.callback(error, undefined);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n                }\n            }\n            else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result);\n                }\n            }\n            else {\n                console.warn(\"this should not happen\");\n            }\n        };\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) {\n            fauxPoll.unref();\n        }\n    }\n    // Cannot narrow the type of _websocket, as that is not backwards compatible\n    // so we add a getter and let the WebSocket be a public API.\n    get websocket() { return this._websocket; }\n    detectNetwork() {\n        return this._detectNetwork;\n    }\n    get pollingInterval() {\n        return 0;\n    }\n    resetEventsBlock(blockNumber) {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n    set pollingInterval(value) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return null;\n        });\n    }\n    set polling(value) {\n        if (!value) {\n            return;\n        }\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n    send(method, params) {\n        const rid = NextId++;\n        return new Promise((resolve, reject) => {\n            function callback(error, result) {\n                if (error) {\n                    return reject(error);\n                }\n                return resolve(result);\n            }\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n            this._requests[String(rid)] = { callback, payload };\n            if (this._wsReady) {\n                this.websocket.send(payload);\n            }\n        });\n    }\n    static defaultUrl() {\n        return \"ws:/\\/localhost:8546\";\n    }\n    _subscribe(tag, param, processFunc) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let subIdPromise = this._subIds[tag];\n            if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then((param) => {\n                    return this.send(\"eth_subscribe\", param);\n                });\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            this._subs[subId] = { tag, processFunc };\n        });\n    }\n    _startEvent(event) {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [\"newHeads\"], (result) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n            case \"pending\":\n                this._subscribe(\"pending\", [\"newPendingTransactions\"], (result) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n            case \"filter\":\n                this._subscribe(event.tag, [\"logs\", this._getFilter(event.filter)], (result) => {\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n            case \"tx\": {\n                const emitReceipt = (event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) {\n                            return;\n                        }\n                        this.emit(hash, receipt);\n                    });\n                };\n                // In case it is already mined\n                emitReceipt(event);\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [\"newHeads\"], (result) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n    _stopEvent(event) {\n        let tag = event.tag;\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        }\n        else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        const subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        subId.then((subId) => {\n            if (!this._subs[subId]) {\n                return;\n            }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [subId]);\n        });\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Wait until we have connected before trying to disconnect\n            if (this.websocket.readyState === WebSocket.CONNECTING) {\n                yield (new Promise((resolve) => {\n                    this.websocket.onopen = function () {\n                        resolve(true);\n                    };\n                    this.websocket.onerror = function () {\n                        resolve(false);\n                    };\n                }));\n            }\n            // Hangup\n            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n            this.websocket.close(1000);\n        });\n    }\n}\n//# sourceMappingURL=websocket-provider.js.map","var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Fallback to standard globalThis if available\n\tif (typeof globalThis === \"object\" && globalThis) return globalThis;\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of updates to Object.prototype being restricted\n\t\t// via preventExtensions, seal or freeze\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ works, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n","module.exports = require('../package.json').version;\n","var _globalThis;\nif (typeof globalThis === 'object') {\n\t_globalThis = globalThis;\n} else {\n\ttry {\n\t\t_globalThis = require('es5-ext/global');\n\t} catch (error) {\n\t} finally {\n\t\tif (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }\n\t\tif (!_globalThis) { throw new Error('Could not determine global this'); }\n\t}\n}\n\nvar NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\nvar websocket_version = require('./version');\n\n\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */\nfunction W3CWebSocket(uri, protocols) {\n\tvar native_instance;\n\n\tif (protocols) {\n\t\tnative_instance = new NativeWebSocket(uri, protocols);\n\t}\n\telse {\n\t\tnative_instance = new NativeWebSocket(uri);\n\t}\n\n\t/**\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t * class). Since it is an Object it will be returned as it is when creating an\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t *\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t */\n\treturn native_instance;\n}\nif (NativeWebSocket) {\n\t['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {\n\t\tObject.defineProperty(W3CWebSocket, prop, {\n\t\t\tget: function() { return NativeWebSocket[prop]; }\n\t\t});\n\t});\n}\n\n/**\n * Module exports.\n */\nmodule.exports = {\n    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,\n    'version'      : websocket_version\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\nvar SturdyWebSocket = /** @class */ (function () {\n    function SturdyWebSocket(url, protocolsOrOptions, options) {\n        if (options === void 0) { options = {}; }\n        this.url = url;\n        this.onclose = null;\n        this.onerror = null;\n        this.onmessage = null;\n        this.onopen = null;\n        this.ondown = null;\n        this.onreopen = null;\n        this.CONNECTING = SturdyWebSocket.CONNECTING;\n        this.OPEN = SturdyWebSocket.OPEN;\n        this.CLOSING = SturdyWebSocket.CLOSING;\n        this.CLOSED = SturdyWebSocket.CLOSED;\n        this.hasBeenOpened = false;\n        this.isClosed = false;\n        this.messageBuffer = [];\n        this.nextRetryTime = 0;\n        this.reconnectCount = 0;\n        this.lastKnownExtensions = \"\";\n        this.lastKnownProtocol = \"\";\n        this.listeners = {};\n        if (protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)) {\n            this.protocols = protocolsOrOptions;\n        }\n        else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            }\n            else {\n                throw new Error(\"WebSocket not present in global scope and no \" +\n                    \"wsConstructor option was provided.\");\n            }\n        }\n        this.openNewWebSocket();\n    }\n    Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n        get: function () {\n            return this.binaryTypeInternal || \"blob\";\n        },\n        set: function (binaryType) {\n            this.binaryTypeInternal = binaryType;\n            if (this.ws) {\n                this.ws.binaryType = binaryType;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n        get: function () {\n            var sum = this.ws ? this.ws.bufferedAmount : 0;\n            var hasUnknownAmount = false;\n            this.messageBuffer.forEach(function (data) {\n                var byteLength = getDataByteLength(data);\n                if (byteLength != null) {\n                    sum += byteLength;\n                }\n                else {\n                    hasUnknownAmount = true;\n                }\n            });\n            if (hasUnknownAmount) {\n                this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\");\n            }\n            return sum;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n        get: function () {\n            return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n        get: function () {\n            return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n        get: function () {\n            return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SturdyWebSocket.prototype.close = function (code, reason) {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    };\n    SturdyWebSocket.prototype.send = function (data) {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        }\n        else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        }\n        else {\n            this.messageBuffer.push(data);\n        }\n    };\n    SturdyWebSocket.prototype.reconnect = function () {\n        if (this.isClosed) {\n            throw new Error(\"Cannot call reconnect() on socket which is permanently closed.\");\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    };\n    SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    };\n    SturdyWebSocket.prototype.dispatchEvent = function (event) {\n        return this.dispatchEventOfType(event.type, event);\n    };\n    SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(function (l) { return l !== listener; });\n        }\n    };\n    SturdyWebSocket.prototype.openNewWebSocket = function () {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, connectTimeout = _a.connectTimeout, wsConstructor = _a.wsConstructor;\n        this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n        var ws = new wsConstructor(this.url, this.protocols);\n        ws.onclose = function (event) { return _this.handleClose(event); };\n        ws.onerror = function (event) { return _this.handleError(event); };\n        ws.onmessage = function (event) { return _this.handleMessage(event); };\n        ws.onopen = function (event) { return _this.handleOpen(event); };\n        this.connectTimeoutId = setTimeout(function () {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            _this.clearConnectTimeout();\n            _this.disposeSocket();\n            _this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    };\n    SturdyWebSocket.prototype.handleOpen = function (event) {\n        var _this = this;\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        var allClearResetTime = this.options.allClearResetTime;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        }\n        else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        }\n        else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(function (message) { return _this.send(message); });\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(function () {\n            _this.clearAllClearTimeout();\n            _this.nextRetryTime = 0;\n            _this.reconnectCount = 0;\n            var openTime = (allClearResetTime / 1000) | 0;\n            _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" +\n                \" retry time and count.\");\n        }, allClearResetTime);\n    };\n    SturdyWebSocket.prototype.handleMessage = function (event) {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    };\n    SturdyWebSocket.prototype.handleClose = function (event) {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, maxReconnectAttempts = _a.maxReconnectAttempts, shouldReconnect = _a.shouldReconnect;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n            return;\n        }\n        var willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n        }\n        else {\n            willReconnect.then(function (willReconnectResolved) {\n                if (_this.isClosed) {\n                    return;\n                }\n                _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n            });\n        }\n    };\n    SturdyWebSocket.prototype.handleError = function (event) {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    };\n    SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n        if (willReconnect) {\n            this.reestablishConnection();\n        }\n        else {\n            this.stopReconnecting(event, denialReason);\n        }\n    };\n    SturdyWebSocket.prototype.reestablishConnection = function () {\n        var _this = this;\n        var _a = this.options, minReconnectDelay = _a.minReconnectDelay, maxReconnectDelay = _a.maxReconnectDelay, reconnectBackoffFactor = _a.reconnectBackoffFactor;\n        this.reconnectCount++;\n        var retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n        setTimeout(function () { return _this.openNewWebSocket(); }, retryTime);\n        var retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n    };\n    SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    };\n    SturdyWebSocket.prototype.shutdown = function () {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    };\n    SturdyWebSocket.prototype.disposeSocket = function (closeCode, reason) {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    };\n    SturdyWebSocket.prototype.clearAllTimeouts = function () {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    };\n    SturdyWebSocket.prototype.clearConnectTimeout = function () {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n        var _this = this;\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(function (listener) { return _this.callListener(listener, event); });\n        }\n        return !event || !event.defaultPrevented;\n    };\n    SturdyWebSocket.prototype.callListener = function (listener, event) {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        }\n        else {\n            listener.handleEvent.call(this, event);\n        }\n    };\n    SturdyWebSocket.prototype.debugLog = function (message) {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    };\n    SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n        var maxReconnectAttempts = this.options.maxReconnectAttempts;\n        return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n    };\n    SturdyWebSocket.DEFAULT_OPTIONS = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: function () { return true; },\n        wsConstructor: undefined,\n    };\n    SturdyWebSocket.CONNECTING = 0;\n    SturdyWebSocket.OPEN = 1;\n    SturdyWebSocket.CLOSING = 2;\n    SturdyWebSocket.CLOSED = 3;\n    return SturdyWebSocket;\n}());\nexports.default = SturdyWebSocket;\nfunction applyDefaultOptions(options) {\n    var result = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(function (key) {\n        var value = options[key];\n        result[key] =\n            value === undefined\n                ? SturdyWebSocket.DEFAULT_OPTIONS[key]\n                : value;\n    });\n    return result;\n}\nfunction getDataByteLength(data) {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    }\n    else if (data instanceof Blob) {\n        return data.size;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction pluralize(s, n) {\n    return n === 1 ? s : s + \"s\";\n}\nfunction noop() {\n    // Nothing.\n}\n//# sourceMappingURL=index.js.map","import { _ as __awaiter, f as fromHex, t as toHex, n as noop, C as CustomNetworks, i as isAlchemyEvent, v as verifyAlchemyEventName, c as EthersEvent, e as getAlchemyEventTag, D as DEFAULT_ALCHEMY_API_KEY, A as ALCHEMY_EVENT_TYPES, h as ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE, j as AlchemySubscription, k as ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE, V as VERSION, E as EthersNetwork } from './index-643dc9bc.js';\nimport SturdyWebSocket from 'sturdy-websocket';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { getNetwork } from '@ethersproject/networks';\nimport { WebSocketProvider } from '@ethersproject/providers';\nimport { AlchemyProvider } from './alchemy-provider-0066b792.js';\nimport './api/utils';\nimport 'axios';\nimport '@ethersproject/abstract-provider';\nimport '@ethersproject/wallet';\nimport '@ethersproject/contracts';\nimport '@ethersproject/web';\n\n/**\r\n * The maximum number of blocks to backfill. If more than this many blocks have\r\n * been missed, then we'll sadly miss data, but we want to make sure we don't\r\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\r\n */\r\nconst MAX_BACKFILL_BLOCKS = 120;\r\n/**\r\n * The WebsocketBackfiller fetches events that were sent since a provided block\r\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\r\n * events that were transmitted while the websocket connection was down.\r\n *\r\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\r\n *\r\n * @internal\r\n */\r\nclass WebsocketBackfiller {\r\n    constructor(provider) {\r\n        this.provider = provider;\r\n        // TODO: Use HTTP provider to do backfill.\r\n        this.maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\r\n    }\r\n    /**\r\n     * Runs backfill for `newHeads` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param previousHeads Previous head requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     * @returns A list of `newHeads` events that were sent since the last backfill.\r\n     */\r\n    getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous heads to fetch, return new heads since\r\n            // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\r\n            if (previousHeads.length === 0) {\r\n                return this.getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted event is too far back in the past, there's no need\r\n            // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\r\n            // new heads.\r\n            const lastSeenBlockNumber = fromHex(previousHeads[previousHeads.length - 1].number);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber <= minBlockNumber) {\r\n                return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // To capture all `newHeads` events, return all head events from the last\r\n            // seen block number to current + any of the previous heads that were re-orged.\r\n            const reorgHeads = yield this.getReorgHeads(isCancelled, previousHeads);\r\n            throwIfCancelled(isCancelled);\r\n            const intermediateHeads = yield this.getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1);\r\n            throwIfCancelled(isCancelled);\r\n            return [...reorgHeads, ...intermediateHeads];\r\n        });\r\n    }\r\n    /**\r\n     * Runs backfill for `logs` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param filter The filter object that accompanies a logs subscription.\r\n     * @param previousLogs Previous log requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     */\r\n    getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous logs to fetch, return new logs since\r\n            // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\r\n            if (previousLogs.length === 0) {\r\n                return this.getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted log is too far back in the past, there's no need\r\n            // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\r\n            // worth of logs.\r\n            const lastSeenBlockNumber = fromHex(previousLogs[previousLogs.length - 1].blockNumber);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber < minBlockNumber) {\r\n                return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // Return all log events that have happened along with log events that have\r\n            // been removed due to a chain reorg.\r\n            const commonAncestor = yield this.getCommonAncestor(isCancelled, previousLogs);\r\n            throwIfCancelled(isCancelled);\r\n            // All previous logs with a block number greater than the common ancestor\r\n            // were part of a re-org, so mark them as such.\r\n            const removedLogs = previousLogs\r\n                .filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber)\r\n                .map(log => (Object.assign(Object.assign({}, log), { removed: true })));\r\n            // If no common ancestor was found, start backfill from the oldest log's\r\n            // block number.\r\n            const fromBlockInclusive = commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\r\n                ? fromHex(previousLogs[0].blockNumber)\r\n                : commonAncestor.blockNumber;\r\n            let addedLogs = yield this.getLogsInRange(filter, fromBlockInclusive, toBlockNumber + 1);\r\n            // De-dupe any logs that were already emitted.\r\n            addedLogs = addedLogs.filter(log => log &&\r\n                (fromHex(log.blockNumber) > commonAncestor.blockNumber ||\r\n                    fromHex(log.logIndex) > commonAncestor.logIndex));\r\n            throwIfCancelled(isCancelled);\r\n            return [...removedLogs, ...addedLogs];\r\n        });\r\n    }\r\n    /**\r\n     * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */\r\n    setMaxBackfillBlock(newMax) {\r\n        this.maxBackfillBlocks = newMax;\r\n    }\r\n    /**\r\n     * Gets the current block number as a number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockNumber() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const blockNumberHex = yield this.provider.send('eth_blockNumber');\r\n            return fromHex(blockNumberHex);\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `newHead` events in the provided range. Note that the returned\r\n     * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\r\n     * that were part of a re-org.\r\n     *\r\n     * @private\r\n     */\r\n    getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const batchParts = [];\r\n            for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\r\n                batchParts.push({\r\n                    method: 'eth_getBlockByNumber',\r\n                    params: [toHex(i), false]\r\n                });\r\n            }\r\n            // TODO: handle errors\r\n            const blockHeads = yield this.provider.sendBatch(batchParts);\r\n            return blockHeads.map(toNewHeadsEvent);\r\n        });\r\n    }\r\n    /**\r\n     * Returns all heads that were part of a reorg event.\r\n     *\r\n     * @private\r\n     */\r\n    getReorgHeads(isCancelled, previousHeads) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const result = [];\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            for (let i = previousHeads.length - 1; i >= 0; i--) {\r\n                const oldEvent = previousHeads[i];\r\n                const blockHead = yield this.getBlockByNumber(fromHex(oldEvent.number));\r\n                throwIfCancelled(isCancelled);\r\n                // If the hashes match, then current head in the iteration was not re-orged.\r\n                if (oldEvent.hash === blockHead.hash) {\r\n                    break;\r\n                }\r\n                result.push(toNewHeadsEvent(blockHead));\r\n            }\r\n            return result.reverse();\r\n        });\r\n    }\r\n    /**\r\n     * Simple wrapper around `eth_getBlockByNumber` that returns the complete\r\n     * block information for the provided block number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockByNumber(blockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this.provider.send('eth_getBlockByNumber', [\r\n                toHex(blockNumber),\r\n                false\r\n            ]);\r\n        });\r\n    }\r\n    /**\r\n     * Given a list of previous log events, finds the common block number from the\r\n     * logs that matches the block head.\r\n     *\r\n     * This can be used to identify which logs are part of a re-org.\r\n     *\r\n     * Returns 1 less than the oldest log's block number if no common ancestor was found.\r\n     *\r\n     * @private\r\n     */\r\n    getCommonAncestor(isCancelled, previousLogs) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            let blockHead = yield this.getBlockByNumber(fromHex(previousLogs[previousLogs.length - 1].blockNumber));\r\n            throwIfCancelled(isCancelled);\r\n            for (let i = previousLogs.length - 1; i >= 0; i--) {\r\n                const oldLog = previousLogs[i];\r\n                // Ensure that updated blocks are fetched every time the log's block number\r\n                // changes.\r\n                if (oldLog.blockNumber !== blockHead.number) {\r\n                    blockHead = yield this.getBlockByNumber(fromHex(oldLog.blockNumber));\r\n                }\r\n                // Since logs are ordered in ascending order, the first log that matches\r\n                // the hash should be the largest logIndex.\r\n                if (oldLog.blockHash === blockHead.hash) {\r\n                    return {\r\n                        blockNumber: fromHex(oldLog.blockNumber),\r\n                        logIndex: fromHex(oldLog.logIndex)\r\n                    };\r\n                }\r\n            }\r\n            return {\r\n                blockNumber: Number.NEGATIVE_INFINITY,\r\n                logIndex: Number.NEGATIVE_INFINITY\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `logs` events in the provided range. Note that the returned logs\r\n     * do not include removed logs.\r\n     *\r\n     * @private\r\n     */ getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const rangeFilter = Object.assign(Object.assign({}, filter), { fromBlock: toHex(fromBlockInclusive), toBlock: toHex(toBlockExclusive - 1) });\r\n            return this.provider.send('eth_getLogs', [rangeFilter]);\r\n        });\r\n    }\r\n}\r\nfunction toNewHeadsEvent(head) {\r\n    const result = Object.assign({}, head);\r\n    delete result.totalDifficulty;\r\n    delete result.transactions;\r\n    delete result.uncles;\r\n    return result;\r\n}\r\nfunction dedupeNewHeads(events) {\r\n    return dedupe(events, event => event.hash);\r\n}\r\nfunction dedupeLogs(events) {\r\n    return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\r\n}\r\nfunction dedupe(items, getKey) {\r\n    const keysSeen = new Set();\r\n    const result = [];\r\n    items.forEach(item => {\r\n        const key = getKey(item);\r\n        if (!keysSeen.has(key)) {\r\n            keysSeen.add(key);\r\n            result.push(item);\r\n        }\r\n    });\r\n    return result;\r\n}\r\nconst CANCELLED = new Error('Cancelled');\r\nfunction throwIfCancelled(isCancelled) {\r\n    if (isCancelled()) {\r\n        throw CANCELLED;\r\n    }\r\n}\n\nconst HEARTBEAT_INTERVAL = 30000;\r\nconst HEARTBEAT_WAIT_TIME = 10000;\r\nconst BACKFILL_TIMEOUT = 60000;\r\nconst BACKFILL_RETRIES = 5;\r\n/**\r\n * Subscriptions have a memory of recent events they have sent so that in the\r\n * event that they disconnect and need to backfill, they can detect re-orgs.\r\n * Keep a buffer that goes back at least these many blocks, the maximum amount\r\n * at which we might conceivably see a re-org.\r\n *\r\n * Note that while our buffer goes back this many blocks, it may contain more\r\n * than this many elements, since in the case of logs subscriptions more than\r\n * one event may be emitted for a block.\r\n */\r\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\r\n/**\r\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\r\n *\r\n * @public\r\n */\r\nclass AlchemyWebSocketProvider extends WebSocketProvider {\r\n    /** @internal */\r\n    constructor(config, wsConstructor) {\r\n        var _a;\r\n        // Normalize the API Key to a string.\r\n        const apiKey = AlchemyProvider.getApiKey(config.apiKey);\r\n        // Generate our own connection info with the correct endpoint URLs.\r\n        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\r\n        const connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'wss');\r\n        const protocol = `alchemy-sdk-${VERSION}`;\r\n        // Use the provided config URL override if it exists, otherwise use the created one.\r\n        const ws = new SturdyWebSocket((_a = config.url) !== null && _a !== void 0 ? _a : connection.url, protocol, {\r\n            wsConstructor: wsConstructor !== null && wsConstructor !== void 0 ? wsConstructor : getWebsocketConstructor()\r\n        });\r\n        // Normalize the Alchemy named network input to the network names used by\r\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\r\n        // correctly set the network.\r\n        const ethersNetwork = EthersNetwork[alchemyNetwork];\r\n        super(ws, ethersNetwork !== null && ethersNetwork !== void 0 ? ethersNetwork : undefined);\r\n        this._events = [];\r\n        // In the case of a WebSocket reconnection, all subscriptions are lost and we\r\n        // create new ones to replace them, but we want to create the illusion that\r\n        // the original subscriptions persist. Thus, maintain a mapping from the\r\n        // \"virtual\" subscription ids which are visible to the consumer to the\r\n        // \"physical\" subscription ids of the actual connections. This terminology is\r\n        // borrowed from virtual and physical memory, which has a similar mapping.\r\n        /** @internal */\r\n        this.virtualSubscriptionsById = new Map();\r\n        /** @internal */\r\n        this.virtualIdsByPhysicalId = new Map();\r\n        /**\r\n         * The underlying ethers {@link WebSocketProvider} already handles and emits\r\n         * messages. To allow backfilling, track all messages that are emitted.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleMessage = (event) => {\r\n            const message = JSON.parse(event.data);\r\n            if (!isSubscriptionEvent(message)) {\r\n                return;\r\n            }\r\n            const physicalId = message.params.subscription;\r\n            const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\r\n            if (!virtualId) {\r\n                return;\r\n            }\r\n            const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n            if (subscription.method !== 'eth_subscribe') {\r\n                return;\r\n            }\r\n            switch (subscription.params[0]) {\r\n                case 'newHeads': {\r\n                    const newHeadsSubscription = subscription;\r\n                    const newHeadsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = newHeadsSubscription;\r\n                    const { result } = newHeadsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToNewHeadsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    else {\r\n                        // Ethers subscription mapping will emit the event, just store it.\r\n                        this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                case 'logs': {\r\n                    const logsSubscription = subscription;\r\n                    const logsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = logsSubscription;\r\n                    const { result } = logsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToLogsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (virtualId !== physicalId) {\r\n                        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    else {\r\n                        this.rememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        const { result } = message.params;\r\n                        this.emitEvent(virtualId, result);\r\n                    }\r\n            }\r\n        };\r\n        /**\r\n         * When the websocket connection reopens:\r\n         *\r\n         * 1. Resubscribe to all existing subscriptions and start backfilling\r\n         * 2. Restart heart beat.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleReopen = () => {\r\n            this.virtualIdsByPhysicalId.clear();\r\n            const { cancel, isCancelled } = makeCancelToken();\r\n            this.cancelBackfill = cancel;\r\n            for (const subscription of this.virtualSubscriptionsById.values()) {\r\n                void (() => __awaiter(this, void 0, void 0, function* () {\r\n                    try {\r\n                        yield this.resubscribeAndBackfill(isCancelled, subscription);\r\n                    }\r\n                    catch (error) {\r\n                        if (!isCancelled()) {\r\n                            console.error(`Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`, error);\r\n                        }\r\n                    }\r\n                }))();\r\n            }\r\n            this.startHeartbeat();\r\n        };\r\n        /**\r\n         * Cancels the heartbeat and any pending backfills being performed. This is\r\n         * called when the websocket connection goes down or is disconnected.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.stopHeartbeatAndBackfill = () => {\r\n            if (this.heartbeatIntervalId != null) {\r\n                clearInterval(this.heartbeatIntervalId);\r\n                this.heartbeatIntervalId = undefined;\r\n            }\r\n            this.cancelBackfill();\r\n        };\r\n        this.apiKey = apiKey;\r\n        // Start heartbeat and backfiller for the websocket connection.\r\n        this.backfiller = new WebsocketBackfiller(this);\r\n        this.addSocketListeners();\r\n        this.startHeartbeat();\r\n        this.cancelBackfill = noop;\r\n    }\r\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getNetwork(network) {\r\n        if (typeof network === 'string' && network in CustomNetworks) {\r\n            return CustomNetworks[network];\r\n        }\r\n        // Call the standard ethers.js getNetwork method for other networks.\r\n        return getNetwork(network);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based subscriptions.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    on(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, false);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based\r\n     * subscriptions. Adds a listener to the triggered for only the next\r\n     * {@link eventName} event, after which it will be removed.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    once(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, true);\r\n    }\r\n    /**\r\n     * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n     * listener is provided, all listeners for the event will be removed.\r\n     *\r\n     * @param eventName Event to unlisten to.\r\n     * @param listener The listener function to remove.\r\n     * @override\r\n     * @public\r\n     */\r\n    off(eventName, listener) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            return this._off(eventName, listener);\r\n        }\r\n        else {\r\n            return super.off(eventName, listener);\r\n        }\r\n    }\r\n    /**\r\n     * Remove all listeners for the provided {@link eventName} event. If no event\r\n     * is provided, all events and their listeners are removed.\r\n     *\r\n     * @param eventName The event to remove all listeners for.\r\n     * @override\r\n     * @public\r\n     */\r\n    removeAllListeners(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._removeAllListeners(eventName);\r\n        }\r\n        else {\r\n            return super.removeAllListeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the number of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, the total number of listeners for all events is returned.\r\n     *\r\n     * @param eventName The event to get the number of listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listenerCount(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._listenerCount(eventName);\r\n        }\r\n        else {\r\n            return super.listenerCount(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns an array of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, all listeners will be included.\r\n     *\r\n     * @param eventName The event to get the listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listeners(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._listeners(eventName);\r\n        }\r\n        else {\r\n            return super.listeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the method in `BaseProvider` in order to properly format the\r\n     * Alchemy subscription events.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _addEventListener(eventName, listener, once) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            verifyAlchemyEventName(eventName);\r\n            const event = new EthersEvent(getAlchemyEventTag(eventName), listener, once);\r\n            this._events.push(event);\r\n            this._startEvent(event);\r\n            return this;\r\n        }\r\n        else {\r\n            return super._addEventListener(eventName, listener, once);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the `_startEvent()` method in ethers.js's\r\n     * {@link WebSocketProvider} to include additional alchemy methods.\r\n     *\r\n     * @param event\r\n     * @override\r\n     * @internal\r\n     */\r\n    _startEvent(event) {\r\n        // Check if the event type is a custom Alchemy subscription.\r\n        const customLogicTypes = [...ALCHEMY_EVENT_TYPES, 'block', 'filter'];\r\n        if (customLogicTypes.includes(event.type)) {\r\n            this.customStartEvent(event);\r\n        }\r\n        else {\r\n            super._startEvent(event);\r\n        }\r\n    }\r\n    /**\r\n     * Overridden from ethers.js's {@link WebSocketProvider}\r\n     *\r\n     * Modified in order to add mappings for backfilling.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _subscribe(tag, param, processFunc, event) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let subIdPromise = this._subIds[tag];\r\n            // BEGIN MODIFIED CODE\r\n            const startingBlockNumber = yield this.getBlockNumber();\r\n            // END MODIFIED CODE\r\n            if (subIdPromise == null) {\r\n                subIdPromise = Promise.all(param).then(param => {\r\n                    return this.send('eth_subscribe', param);\r\n                });\r\n                this._subIds[tag] = subIdPromise;\r\n            }\r\n            const subId = yield subIdPromise;\r\n            // BEGIN MODIFIED CODE\r\n            const resolvedParams = yield Promise.all(param);\r\n            this.virtualSubscriptionsById.set(subId, {\r\n                event: event,\r\n                method: 'eth_subscribe',\r\n                params: resolvedParams,\r\n                startingBlockNumber,\r\n                virtualId: subId,\r\n                physicalId: subId,\r\n                sentEvents: [],\r\n                isBackfilling: false,\r\n                backfillBuffer: []\r\n            });\r\n            this.virtualIdsByPhysicalId.set(subId, subId);\r\n            // END MODIFIED CODE\r\n            this._subs[subId] = { tag, processFunc };\r\n        });\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    emit(eventName, ...args) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            let result = false;\r\n            const stopped = [];\r\n            // This line is the only modified line from the original method.\r\n            const eventTag = getAlchemyEventTag(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                setTimeout(() => {\r\n                    event.listener.apply(this, args);\r\n                }, 0);\r\n                result = true;\r\n                if (event.once) {\r\n                    stopped.push(event);\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n            stopped.forEach(event => {\r\n                this._stopEvent(event);\r\n            });\r\n            return result;\r\n        }\r\n        else {\r\n            return super.emit(eventName, ...args);\r\n        }\r\n    }\r\n    /** @internal */\r\n    sendBatch(parts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let nextId = 0;\r\n            const payload = parts.map(({ method, params }) => {\r\n                return {\r\n                    method,\r\n                    params,\r\n                    jsonrpc: '2.0',\r\n                    id: `alchemy-sdk:${nextId++}`\r\n                };\r\n            });\r\n            return this.sendBatchConcurrently(payload);\r\n        });\r\n    }\r\n    /** @override */\r\n    destroy() {\r\n        this.removeSocketListeners();\r\n        this.stopHeartbeatAndBackfill();\r\n        return super.destroy();\r\n    }\r\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\r\n    isCommunityResource() {\r\n        return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\r\n     *\r\n     * This method is copied over directly in order to support Alchemy's\r\n     * subscription type by allowing the provider to properly stop Alchemy's\r\n     * subscription events.\r\n     *\r\n     * @internal\r\n     */\r\n    _stopEvent(event) {\r\n        let tag = event.tag;\r\n        // START MODIFIED CODE\r\n        if (ALCHEMY_EVENT_TYPES.includes(event.type)) {\r\n            // There are remaining pending transaction listeners.\r\n            if (this._events.filter(e => ALCHEMY_EVENT_TYPES.includes(e.type)).length) {\r\n                return;\r\n            }\r\n            // END MODIFIED CODE\r\n        }\r\n        else if (event.type === 'tx') {\r\n            // There are remaining transaction event listeners\r\n            if (this._events.filter(e => e.type === 'tx').length) {\r\n                return;\r\n            }\r\n            tag = 'tx';\r\n        }\r\n        else if (this.listenerCount(event.event)) {\r\n            // There are remaining event listeners\r\n            return;\r\n        }\r\n        const subId = this._subIds[tag];\r\n        if (!subId) {\r\n            return;\r\n        }\r\n        delete this._subIds[tag];\r\n        void subId.then(subId => {\r\n            if (!this._subs[subId]) {\r\n                return;\r\n            }\r\n            delete this._subs[subId];\r\n            void this.send('eth_unsubscribe', [subId]);\r\n        });\r\n    }\r\n    /** @internal */\r\n    addSocketListeners() {\r\n        this._websocket.addEventListener('message', this.handleMessage);\r\n        this._websocket.addEventListener('reopen', this.handleReopen);\r\n        this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /** @internal */\r\n    removeSocketListeners() {\r\n        this._websocket.removeEventListener('message', this.handleMessage);\r\n        this._websocket.removeEventListener('reopen', this.handleReopen);\r\n        this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /**\r\n     * Reopens the backfill based on\r\n     *\r\n     * @param isCancelled\r\n     * @param subscription\r\n     * @internal\r\n     */\r\n    resubscribeAndBackfill(isCancelled, subscription) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { virtualId, method, params, sentEvents, backfillBuffer, startingBlockNumber } = subscription;\r\n            subscription.isBackfilling = true;\r\n            backfillBuffer.length = 0;\r\n            try {\r\n                const physicalId = yield this.send(method, params);\r\n                throwIfCancelled(isCancelled);\r\n                subscription.physicalId = physicalId;\r\n                this.virtualIdsByPhysicalId.set(physicalId, virtualId);\r\n                switch (params[0]) {\r\n                    case 'newHeads': {\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    case 'logs': {\r\n                        const filter = params[1] || {};\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getLogsBackfill(isCancelled, filter, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitLogsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n            finally {\r\n                subscription.isBackfilling = false;\r\n                backfillBuffer.length = 0;\r\n            }\r\n        });\r\n    }\r\n    /** @internal */\r\n    emitNewHeadsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitLogsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n    }\r\n    /**\r\n     * Emits an event to consumers, but also remembers it in its subscriptions's\r\n     * `sentEvents` buffer so that we can detect re-orgs if the connection drops\r\n     * and needs to be reconnected.\r\n     *\r\n     * @internal\r\n     */\r\n    emitAndRememberEvent(virtualId, result, getBlockNumber) {\r\n        this.rememberEvent(virtualId, result, getBlockNumber);\r\n        this.emitEvent(virtualId, result);\r\n    }\r\n    emitEvent(virtualId, result) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        this.emitGenericEvent(subscription, result);\r\n    }\r\n    /** @internal */\r\n    rememberEvent(virtualId, result, getBlockNumber) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        // Web3 modifies these event objects once we pass them on (changing hex\r\n        // numbers to numbers). We want the original event, so make a defensive\r\n        // copy.\r\n        addToPastEventsBuffer(subscription.sentEvents, Object.assign({}, result), getBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitGenericEvent(subscription, result) {\r\n        const emitFunction = this.emitProcessFn(subscription.event);\r\n        emitFunction(result);\r\n    }\r\n    /**\r\n     * Starts a heartbeat that pings the websocket server periodically to ensure\r\n     * that the connection stays open.\r\n     *\r\n     * @internal\r\n     */\r\n    startHeartbeat() {\r\n        if (this.heartbeatIntervalId != null) {\r\n            return;\r\n        }\r\n        this.heartbeatIntervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                yield withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\r\n            }\r\n            catch (_a) {\r\n                this._websocket.reconnect();\r\n            }\r\n        }), HEARTBEAT_INTERVAL);\r\n    }\r\n    /**\r\n     * This method sends the batch concurrently as individual requests rather than\r\n     * as a batch, which was the original implementation. The original batch logic\r\n     * is preserved in this implementation in order for faster porting.\r\n     *\r\n     * @param payload\r\n     * @internal\r\n     */\r\n    // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\r\n    // TODO(errors): Use allSettled() once we have more error handling.\r\n    sendBatchConcurrently(payload) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return Promise.all(payload.map(req => this.send(req.method, req.params)));\r\n        });\r\n    }\r\n    /** @internal */\r\n    customStartEvent(event) {\r\n        if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\r\n            const { fromAddress, toAddress, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                AlchemySubscription.PENDING_TRANSACTIONS,\r\n                { fromAddress, toAddress, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\r\n            const { addresses, includeRemoved, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                AlchemySubscription.MINED_TRANSACTIONS,\r\n                { addresses, includeRemoved, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'block') {\r\n            void this._subscribe('block', ['newHeads'], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'filter') {\r\n            void this._subscribe(event.tag, ['logs', this._getFilter(event.filter)], this.emitProcessFn(event), event);\r\n        }\r\n    }\r\n    /** @internal */\r\n    emitProcessFn(event) {\r\n        switch (event.type) {\r\n            case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\r\n                return result => this.emit({\r\n                    method: AlchemySubscription.PENDING_TRANSACTIONS,\r\n                    fromAddress: event.fromAddress,\r\n                    toAddress: event.toAddress,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\r\n                return result => this.emit({\r\n                    method: AlchemySubscription.MINED_TRANSACTIONS,\r\n                    addresses: event.addresses,\r\n                    includeRemoved: event.includeRemoved,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case 'block':\r\n                return result => {\r\n                    const blockNumber = BigNumber.from(result.number).toNumber();\r\n                    this._emitted.block = blockNumber;\r\n                    this.emit('block', blockNumber);\r\n                };\r\n            case 'filter':\r\n                return result => {\r\n                    if (result.removed == null) {\r\n                        result.removed = false;\r\n                    }\r\n                    this.emit(event.filter, this.formatter.filterLog(result));\r\n                };\r\n            default:\r\n                throw new Error('Invalid event type to `emitProcessFn()`');\r\n        }\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.off()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _off(eventName, listener) {\r\n        if (listener == null) {\r\n            return this.removeAllListeners(eventName);\r\n        }\r\n        const stopped = [];\r\n        let found = false;\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        this._events = this._events.filter(event => {\r\n            if (event.tag !== eventTag || event.listener != listener) {\r\n                return true;\r\n            }\r\n            if (found) {\r\n                return true;\r\n            }\r\n            found = true;\r\n            stopped.push(event);\r\n            return false;\r\n        });\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _removeAllListeners(eventName) {\r\n        let stopped = [];\r\n        if (eventName == null) {\r\n            stopped = this._events;\r\n            this._events = [];\r\n        }\r\n        else {\r\n            const eventTag = getAlchemyEventTag(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                stopped.push(event);\r\n                return false;\r\n            });\r\n        }\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listenerCount(eventName) {\r\n        if (!eventName) {\r\n            return this._events.length;\r\n        }\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        return this._events.filter(event => {\r\n            return event.tag === eventTag;\r\n        }).length;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listeners(eventName) {\r\n        if (eventName == null) {\r\n            return this._events.map(event => event.listener);\r\n        }\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        return this._events\r\n            .filter(event => event.tag === eventTag)\r\n            .map(event => event.listener);\r\n    }\r\n}\r\nfunction getWebsocketConstructor() {\r\n    return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\r\n}\r\nfunction isNodeEnvironment() {\r\n    return (typeof process !== 'undefined' &&\r\n        process != null &&\r\n        process.versions != null &&\r\n        process.versions.node != null);\r\n}\r\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\r\nfunction makeCancelToken() {\r\n    let cancelled = false;\r\n    return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\r\n}\r\n// TODO(cleanup): replace with SDK's backoff implementation\r\nconst MIN_RETRY_DELAY = 1000;\r\nconst RETRY_BACKOFF_FACTOR = 2;\r\nconst MAX_RETRY_DELAY = 30000;\r\nfunction withBackoffRetries(f, retryCount, shouldRetry = () => true) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let nextWaitTime = 0;\r\n        let i = 0;\r\n        while (true) {\r\n            try {\r\n                return yield f();\r\n            }\r\n            catch (error) {\r\n                i++;\r\n                if (i >= retryCount || !shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                yield delay(nextWaitTime);\r\n                if (!shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                nextWaitTime =\r\n                    nextWaitTime === 0\r\n                        ? MIN_RETRY_DELAY\r\n                        : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction delay(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\nfunction withTimeout(promise, ms) {\r\n    return Promise.race([\r\n        promise,\r\n        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), ms))\r\n    ]);\r\n}\r\nfunction getNewHeadsBlockNumber(event) {\r\n    return fromHex(event.number);\r\n}\r\nfunction getLogsBlockNumber(event) {\r\n    return fromHex(event.blockNumber);\r\n}\r\nfunction isResponse(message) {\r\n    return (Array.isArray(message) ||\r\n        (message.jsonrpc === '2.0' && message.id !== undefined));\r\n}\r\nfunction isSubscriptionEvent(message) {\r\n    return !isResponse(message);\r\n}\r\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\r\n}\r\nfunction addToLogsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\r\n}\r\n/**\r\n * Adds a new event to an array of events, evicting any events which are so old\r\n * that they will no longer feasibly be part of a reorg.\r\n */\r\nfunction addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\r\n    const currentBlockNumber = getBlockNumber(event);\r\n    // Find first index of an event recent enough to retain, then drop everything\r\n    // at a lower index.\r\n    const firstGoodIndex = pastEvents.findIndex(e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT);\r\n    if (firstGoodIndex === -1) {\r\n        pastEvents.length = 0;\r\n    }\r\n    else {\r\n        pastEvents.splice(0, firstGoodIndex);\r\n    }\r\n    pastEvents.push(event);\r\n}\n\nexport { AlchemyWebSocketProvider };\n//# sourceMappingURL=alchemy-websocket-provider-98da5bb0.js.map\n"],"names":["WS","WebSocket","Error","error","logger","Logger","version","throwError","errors","UNSUPPORTED_OPERATION","operation","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","NextId","WebSocketProvider","JsonRpcProvider","constructor","url","network","super","this","_pollingInterval","_wsReady","defineReadOnly","connection","detectNetwork","websocket","onopen","Object","keys","_requests","forEach","id","send","payload","onmessage","messageEvent","data","JSON","parse","String","request","callback","emit","action","response","provider","message","code","method","sub","_subs","params","subscription","processFunc","console","warn","fauxPoll","setInterval","unref","_websocket","_detectNetwork","pollingInterval","resetEventsBlock","blockNumber","poll","polling","rid","stringify","jsonrpc","defaultUrl","_subscribe","tag","param","subIdPromise","_subIds","all","subId","_startEvent","event","type","BigNumber","from","number","toNumber","_emitted","block","_getFilter","filter","removed","formatter","filterLog","emitReceipt","hash","getTransactionReceipt","receipt","_events","log","_stopEvent","length","listenerCount","destroy","readyState","CONNECTING","onerror","close","naiveFallback","self","window","global","globalThis","defineProperty","prototype","get","configurable","__global__","require$$0","_globalThis","NativeWebSocket","MozWebSocket","websocket_version","require$$1","W3CWebSocket","uri","protocols","native_instance","prop","browser","w3cwebsocket","dist","SHOULD_RECONNECT_FALSE_MESSAGE","SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE","SturdyWebSocket","protocolsOrOptions","options","onclose","ondown","onreopen","OPEN","CLOSING","CLOSED","hasBeenOpened","isClosed","messageBuffer","nextRetryTime","reconnectCount","lastKnownExtensions","lastKnownProtocol","listeners","Array","isArray","applyDefaultOptions","wsConstructor","openNewWebSocket","binaryTypeInternal","set","binaryType","ws","enumerable","sum","bufferedAmount","hasUnknownAmount","byteLength","getDataByteLength","debugLog","extensions","protocol","reason","disposeSocket","shutdown","push","reconnect","handleClose","addEventListener","listener","dispatchEvent","dispatchEventOfType","removeEventListener","l","_this","_a","connectTimeout","handleError","handleMessage","handleOpen","connectTimeoutId","setTimeout","clearConnectTimeout","allClearResetTime","allClearTimeoutId","clearAllClearTimeout","openTime","maxReconnectAttempts","shouldReconnect","stopReconnecting","getTooManyFailedReconnectsMessage","willReconnect","handleWillReconnect","willReconnectResolved","denialReason","reestablishConnection","minReconnectDelay","maxReconnectDelay","reconnectBackoffFactor","retryTime","Math","max","min","retryTimeSeconds","debugReason","clearAllTimeouts","closeCode","noop","clearTimeout","slice","callListener","defaultPrevented","call","handleEvent","debug","pluralize","DEFAULT_OPTIONS","Number","POSITIVE_INFINITY","default","key","ArrayBuffer","Blob","size","s","n","MAX_BACKFILL_BLOCKS","WebsocketBackfiller","maxBackfillBlocks","getNewHeadsBackfill","isCancelled","previousHeads","fromBlockNumber","throwIfCancelled","toBlockNumber","getBlockNumber","getHeadEventsInRange","lastSeenBlockNumber","fromHex","minBlockNumber","reorgHeads","getReorgHeads","intermediateHeads","getLogsBackfill","previousLogs","getLogsInRange","commonAncestor","getCommonAncestor","removedLogs","map","assign","fromBlockInclusive","NEGATIVE_INFINITY","addedLogs","logIndex","setMaxBackfillBlock","newMax","blockNumberHex","toBlockExclusive","batchParts","i","toHex","blockHeads","sendBatch","toNewHeadsEvent","oldEvent","blockHead","getBlockByNumber","reverse","oldLog","blockHash","rangeFilter","fromBlock","toBlock","head","totalDifficulty","transactions","uncles","dedupeNewHeads","events","dedupe","dedupeLogs","items","getKey","keysSeen","Set","item","has","add","CANCELLED","HEARTBEAT_INTERVAL","HEARTBEAT_WAIT_TIME","BACKFILL_TIMEOUT","BACKFILL_RETRIES","RETAINED_EVENT_BLOCK_COUNT","AlchemyWebSocketProvider","config","apiKey","AlchemyProvider","getApiKey","alchemyNetwork","getAlchemyNetwork","getAlchemyConnectionInfo","VERSION","getWebsocketConstructor","ethersNetwork","EthersNetwork","virtualSubscriptionsById","Map","virtualIdsByPhysicalId","isSubscriptionEvent","physicalId","virtualId","newHeadsSubscription","newHeadsMessage","isBackfilling","backfillBuffer","addToNewHeadsEventsBuffer","emitAndRememberEvent","getNewHeadsBlockNumber","rememberEvent","logsSubscription","logsMessage","addToLogsEventsBuffer","getLogsBlockNumber","emitEvent","handleReopen","clear","cancel","makeCancelToken","cancelBackfill","values","resubscribeAndBackfill","startHeartbeat","stopHeartbeatAndBackfill","heartbeatIntervalId","clearInterval","backfiller","addSocketListeners","getNetwork","CustomNetworks","on","eventName","_addEventListener","once","off","isAlchemyEvent","_off","removeAllListeners","_removeAllListeners","_listenerCount","_listeners","verifyAlchemyEventName","EthersEvent","getAlchemyEventTag","customLogicTypes","ALCHEMY_EVENT_TYPES","includes","customStartEvent","startingBlockNumber","resolvedParams","sentEvents","args","stopped","eventTag","parts","nextId","sendBatchConcurrently","removeSocketListeners","isCommunityResource","DEFAULT_ALCHEMY_API_KEY","backfillEvents","withBackoffRetries","withTimeout","emitNewHeadsEvent","emitLogsEvent","emitGenericEvent","addToPastEventsBuffer","emitFunction","emitProcessFn","req","ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE","fromAddress","toAddress","hashesOnly","AlchemySubscription","PENDING_TRANSACTIONS","ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE","addresses","includeRemoved","MINED_TRANSACTIONS","found","isNodeEnvironment","process","versions","node","cancelled","MIN_RETRY_DELAY","RETRY_BACKOFF_FACTOR","MAX_RETRY_DELAY","f","retryCount","shouldRetry","nextWaitTime","delay","ms","promise","race","_","isResponse","pastEvents","currentBlockNumber","firstGoodIndex","findIndex","splice"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}