{"version":3,"file":"z_jpiecc.js","sources":["../../../../../../src/lib/common/security.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { decryptData, digestMessage } from '$lib/common/encryption';\nimport type {\n\tAccountData,\n\tCurrentlySelectedData,\n\tProfile,\n\tProfileData,\n\tSessionToken\n} from '$lib/common/interfaces';\nimport { isEncryptedData } from '$lib/common/misc';\nimport {\n\tgetProfile,\n\tsetMiscStore,\n\tgetYakklCurrentlySelected,\n\tgetMiscStore\n} from '$lib/common/stores';\nimport { log } from '$lib/common/logger-wrapper';\nimport { storeEncryptedHash, storeSessionToken } from './auth/session';\n\nexport interface AccountKey {\n\taddress: string;\n\tprivateKey: string;\n}\n\nexport async function verify(id: string): Promise<Profile | undefined> {\n\ttry {\n\t\tif (!id) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst profile = await getProfile();\n\t\tconst digest = await digestMessage(id);\n\t\tif (!profile || !digest) {\n\t\t\treturn undefined; // Don't set the store to anything here\n\t\t} else {\n\t\t\tif (isEncryptedData(profile.data)) {\n\t\t\t\tconst profileData = (await decryptData(profile.data, digest)) as ProfileData;\n\t\t\t\tif (profileData) {\n\t\t\t\t\tsetMiscStore(digest); // Works for client side\n\n\t\t\t\t\tconst sessionToken: SessionToken = await storeEncryptedHash(digest); // Works for background context\n\n\t\t\t\t\tif (sessionToken) {\n\t\t\t\t\t\tstoreSessionToken(sessionToken.token, sessionToken.expiresAt);\n\t\t\t\t\t}\n\t\t\t\t\tlog.info('verify - sessionToken', false, sessionToken);\n\t\t\t\t} else {\n\t\t\t\t\tthrow 'Verification failed!';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn profile;\n\t\t}\n\t} catch (e) {\n\t\tlog.error('Verification failed!', false, e);\n\t\tthrow `Verification failed! - ${e}`;\n\t}\n}\n\nexport async function getYakklCurrentlySelectedAccountKey(): Promise<AccountKey | null> {\n\ttry {\n\t\tconst currentlySelected = await getYakklCurrentlySelected();\n\t\tconst yakklMiscStore = getMiscStore();\n\t\tlet accountKey: AccountKey | null = null;\n\t\tlet address: string | null = null;\n\t\tlet privateKey: string | null | undefined = null;\n\n\t\tif (!yakklMiscStore || !currentlySelected) {\n\t\t\treturn null;\n\t\t}\n\t\t// May want to put this in a function\n\t\tif (isEncryptedData(currentlySelected.data)) {\n\t\t\tconst result = await decryptData(currentlySelected.data, yakklMiscStore);\n\t\t\tconst data = result as CurrentlySelectedData;\n\t\t\taddress = data?.account?.address || null;\n\t\t\tif (isEncryptedData(data?.account?.data)) {\n\t\t\t\tconst result = await decryptData(data.account.data, yakklMiscStore);\n\t\t\t\tconst accountData = result as AccountData;\n\t\t\t\tprivateKey = accountData.privateKey;\n\t\t\t} else {\n\t\t\t\tprivateKey = data ? data.account?.data.privateKey : null;\n\t\t\t}\n\t\t} else {\n\t\t\tprivateKey = currentlySelected.data\n\t\t\t\t? (((currentlySelected.data as CurrentlySelectedData).account?.data as AccountData)\n\t\t\t\t\t\t?.privateKey ?? null)\n\t\t\t\t: null;\n\t\t}\n\n\t\tif (privateKey && address) {\n\t\t\taccountKey = {\n\t\t\t\taddress: address,\n\t\t\t\tprivateKey: privateKey\n\t\t\t};\n\t\t}\n\t\treturn accountKey;\n\t} catch (e: any) {\n\t\t// error_log(e);\n\t\tlog.errorStack(e);\n\t\tthrow `Error getting account key - ${e}`;\n\t}\n}\n\nexport function extractSecureDomain(url: string): string | null {\n\ttry {\n\t\t// Parse the URL\n\t\tconst parsedUrl = new URL(url);\n\n\t\t// Check if the protocol is secure (https) or if it's a special case\n\t\tconst isSecure = parsedUrl.protocol === 'https:';\n\t\tconst isLocalhost = parsedUrl.hostname === 'localhost' || parsedUrl.hostname === '127.0.0.1';\n\t\tconst isChromeExtension = parsedUrl.protocol === 'chrome:';\n\n\t\tif (!isSecure && !isLocalhost && !isChromeExtension) {\n\t\t\tthrow new Error(\n\t\t\t\t'Insecure protocol detected. Only HTTPS, localhost, and chrome:// are allowed.'\n\t\t\t);\n\t\t}\n\n\t\t// Return just the hostname (domain)\n\t\treturn parsedUrl.hostname;\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\tthrow new Error(`Invalid URL or security violation: ${error.message}`);\n\t\t}\n\t\tthrow new Error('Invalid URL format');\n\t}\n}\n"],"names":["async","verify","id","profile","getProfile","digest","digestMessage","isEncryptedData","data","profileData","decryptData","setMiscStore","sessionToken","storeEncryptedHash","storeSessionToken","token","expiresAt","log","info","e","error","getYakklCurrentlySelectedAccountKey","currentlySelected","getYakklCurrentlySelected","yakklMiscStore","getMiscStore","accountKey","address","privateKey","result","_a","account","_b","accountData","_c","_e","_d","errorStack"],"mappings":"0PAwBAA,eAAsBC,OAAOC,IACxB,IACH,IAAKA,GAAI,CACD,YAAA,CAAA,CAEF,MAAAC,cAAgBC,aAChB,MAAAC,aAAeC,cAAcJ,IAC/B,IAACC,UAAYE,OAAQ,CACjB,YAAA,CAAA,KACD,CACF,GAAAE,gBAAgBJ,QAAQK,MAAO,CAClC,MAAMC,kBAAqBC,YAAYP,QAAQK,KAAMH,QACrD,GAAII,YAAa,CAChBE,aAAaN,QAEP,MAAAO,mBAAmCC,mBAAmBR,QAE5D,GAAIO,aAAc,CACCE,kBAAAF,aAAaG,MAAOH,aAAaI,UAAS,CAEzDC,IAAAC,KAAK,wBAAyB,MAAON,aAAY,KAC/C,CACA,KAAA,sBAAA,CACP,CAEM,OAAAT,OAAA,QAEAgB,GACJF,IAAAG,MAAM,uBAAwB,MAAOD,GACzC,KAAM,0BAA0BA,GAAC,CAEnC,CAEAnB,eAAsBqB,yDACjB,IACG,MAAAC,wBAA0BC,4BAChC,MAAMC,eAAiBC,eACvB,IAAIC,WAAgC,KACpC,IAAIC,QAAyB,KAC7B,IAAIC,WAAwC,KAExC,IAACJ,iBAAmBF,kBAAmB,CACnC,OAAA,IAAA,CAGJ,GAAAf,gBAAgBe,kBAAkBd,MAAO,CAC5C,MAAMqB,aAAenB,YAAYY,kBAAkBd,KAAMgB,gBACzD,MAAMhB,KAAOqB,OACHF,UAAAG,GAAAtB,MAAA,UAAA,EAAAA,KAAMuB,UAAN,UAAA,EAAAD,GAAeH,UAAW,KACpC,GAAIpB,iBAAgByB,GAAAxB,MAAA,UAAA,EAAAA,KAAMuB,UAAN,UAAA,EAAAC,GAAexB,MAAO,CACzC,MAAMqB,cAAenB,YAAYF,KAAKuB,QAAQvB,KAAMgB,gBACpD,MAAMS,YAAcJ,QACpBD,WAAaK,YAAYL,UAAA,KACnB,CACNA,WAAapB,MAAO0B,GAAA1B,KAAKuB,UAAL,UAAA,EAAAG,GAAc1B,KAAKoB,WAAa,IAAA,CACrD,KACM,CACOA,WAAAN,kBAAkBd,OACzB2B,IAAkBC,GAAAd,kBAAAd,KAA+BuB,UAAjD,UAA0D,EAAAK,GAAA5B,OAA1D,UACD,EAAA2B,GAAAP,aAAc,KAChB,IAAA,CAGJ,GAAIA,YAAcD,QAAS,CACbD,WAAA,CACZC,gBACAC,sBACD,CAEM,OAAAF,iBACCP,GAERF,IAAIoB,WAAWlB,GACf,KAAM,+BAA+BA,GAAC,CAExC"}