{"version":3,"file":"BOosul_h.js","sources":["../../../../../../../../node_modules/.pnpm/vite-plugin-node-polyfills@0.22.0_rollup@4.43.0_vite@6.3.5_@types+node@20.19.1_jiti@1.21.7_terser@5.43.0_yaml@2.7.0_/node_modules/vite-plugin-node-polyfills/shims/buffer/dist/index.js"],"sourcesContent":["var buffer = {};\n\nvar base64Js = {};\n\nbase64Js.byteLength = byteLength;\nbase64Js.toByteArray = toByteArray;\nbase64Js.fromByteArray = fromByteArray;\n\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62;\nrevLookup['_'.charCodeAt(0)] = 63;\n\nfunction getLens (b64) {\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=');\n  if (validLen === -1) validLen = len;\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4);\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp;\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n\n  var curByte = 0;\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen;\n\n  var i;\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = (tmp >> 16) & 0xFF;\n    arr[curByte++] = (tmp >> 8) & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4);\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2);\n    arr[curByte++] = (tmp >> 8) & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    );\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    );\n  }\n\n  return parts.join('')\n}\n\nvar ieee754 = {};\n\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n\nieee754.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = (nBytes * 8) - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? (nBytes - 1) : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n};\n\nieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = (nBytes * 8) - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n  var i = isLE ? 0 : (nBytes - 1);\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n(function (exports) {\n\n\tconst base64 = base64Js;\n\tconst ieee754$1 = ieee754;\n\tconst customInspectSymbol =\n\t  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n\t    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n\t    : null;\n\n\texports.Buffer = Buffer;\n\texports.SlowBuffer = SlowBuffer;\n\texports.INSPECT_MAX_BYTES = 50;\n\n\tconst K_MAX_LENGTH = 0x7fffffff;\n\texports.kMaxLength = K_MAX_LENGTH;\n\tconst { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;\n\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n\t *               implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * We report that the browser does not support typed arrays if the are not subclassable\n\t * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n\t * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n\t * for __proto__ and has a buggy typed array implementation.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n\n\tif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n\t    typeof console.error === 'function') {\n\t  console.error(\n\t    'This browser lacks typed array (Uint8Array) support which is required by ' +\n\t    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n\t  );\n\t}\n\n\tfunction typedArraySupport () {\n\t  // Can typed array instances can be augmented?\n\t  try {\n\t    const arr = new GlobalUint8Array(1);\n\t    const proto = { foo: function () { return 42 } };\n\t    Object.setPrototypeOf(proto, GlobalUint8Array.prototype);\n\t    Object.setPrototypeOf(arr, proto);\n\t    return arr.foo() === 42\n\t  } catch (e) {\n\t    return false\n\t  }\n\t}\n\n\tObject.defineProperty(Buffer.prototype, 'parent', {\n\t  enumerable: true,\n\t  get: function () {\n\t    if (!Buffer.isBuffer(this)) return undefined\n\t    return this.buffer\n\t  }\n\t});\n\n\tObject.defineProperty(Buffer.prototype, 'offset', {\n\t  enumerable: true,\n\t  get: function () {\n\t    if (!Buffer.isBuffer(this)) return undefined\n\t    return this.byteOffset\n\t  }\n\t});\n\n\tfunction createBuffer (length) {\n\t  if (length > K_MAX_LENGTH) {\n\t    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n\t  }\n\t  // Return an augmented `Uint8Array` instance\n\t  const buf = new GlobalUint8Array(length);\n\t  Object.setPrototypeOf(buf, Buffer.prototype);\n\t  return buf\n\t}\n\n\t/**\n\t * The Buffer constructor returns instances of `Uint8Array` that have their\n\t * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n\t * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n\t * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n\t * returns a single octet.\n\t *\n\t * The `Uint8Array` prototype remains unmodified.\n\t */\n\n\tfunction Buffer (arg, encodingOrOffset, length) {\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    if (typeof encodingOrOffset === 'string') {\n\t      throw new TypeError(\n\t        'The \"string\" argument must be of type string. Received type number'\n\t      )\n\t    }\n\t    return allocUnsafe(arg)\n\t  }\n\t  return from(arg, encodingOrOffset, length)\n\t}\n\n\tBuffer.poolSize = 8192; // not used by this implementation\n\n\tfunction from (value, encodingOrOffset, length) {\n\t  if (typeof value === 'string') {\n\t    return fromString(value, encodingOrOffset)\n\t  }\n\n\t  if (GlobalArrayBuffer.isView(value)) {\n\t    return fromArrayView(value)\n\t  }\n\n\t  if (value == null) {\n\t    throw new TypeError(\n\t      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n\t      'or Array-like Object. Received type ' + (typeof value)\n\t    )\n\t  }\n\n\t  if (isInstance(value, GlobalArrayBuffer) ||\n\t      (value && isInstance(value.buffer, GlobalArrayBuffer))) {\n\t    return fromArrayBuffer(value, encodingOrOffset, length)\n\t  }\n\n\t  if (typeof GlobalSharedArrayBuffer !== 'undefined' &&\n\t      (isInstance(value, GlobalSharedArrayBuffer) ||\n\t      (value && isInstance(value.buffer, GlobalSharedArrayBuffer)))) {\n\t    return fromArrayBuffer(value, encodingOrOffset, length)\n\t  }\n\n\t  if (typeof value === 'number') {\n\t    throw new TypeError(\n\t      'The \"value\" argument must not be of type number. Received type number'\n\t    )\n\t  }\n\n\t  const valueOf = value.valueOf && value.valueOf();\n\t  if (valueOf != null && valueOf !== value) {\n\t    return Buffer.from(valueOf, encodingOrOffset, length)\n\t  }\n\n\t  const b = fromObject(value);\n\t  if (b) return b\n\n\t  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n\t      typeof value[Symbol.toPrimitive] === 'function') {\n\t    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n\t  }\n\n\t  throw new TypeError(\n\t    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n\t    'or Array-like Object. Received type ' + (typeof value)\n\t  )\n\t}\n\n\t/**\n\t * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n\t * if value is a number.\n\t * Buffer.from(str[, encoding])\n\t * Buffer.from(array)\n\t * Buffer.from(buffer)\n\t * Buffer.from(arrayBuffer[, byteOffset[, length]])\n\t **/\n\tBuffer.from = function (value, encodingOrOffset, length) {\n\t  return from(value, encodingOrOffset, length)\n\t};\n\n\t// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n\t// https://github.com/feross/buffer/pull/148\n\tObject.setPrototypeOf(Buffer.prototype, GlobalUint8Array.prototype);\n\tObject.setPrototypeOf(Buffer, GlobalUint8Array);\n\n\tfunction assertSize (size) {\n\t  if (typeof size !== 'number') {\n\t    throw new TypeError('\"size\" argument must be of type number')\n\t  } else if (size < 0) {\n\t    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n\t  }\n\t}\n\n\tfunction alloc (size, fill, encoding) {\n\t  assertSize(size);\n\t  if (size <= 0) {\n\t    return createBuffer(size)\n\t  }\n\t  if (fill !== undefined) {\n\t    // Only pay attention to encoding if it's a string. This\n\t    // prevents accidentally sending in a number that would\n\t    // be interpreted as a start offset.\n\t    return typeof encoding === 'string'\n\t      ? createBuffer(size).fill(fill, encoding)\n\t      : createBuffer(size).fill(fill)\n\t  }\n\t  return createBuffer(size)\n\t}\n\n\t/**\n\t * Creates a new filled Buffer instance.\n\t * alloc(size[, fill[, encoding]])\n\t **/\n\tBuffer.alloc = function (size, fill, encoding) {\n\t  return alloc(size, fill, encoding)\n\t};\n\n\tfunction allocUnsafe (size) {\n\t  assertSize(size);\n\t  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n\t}\n\n\t/**\n\t * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n\t * */\n\tBuffer.allocUnsafe = function (size) {\n\t  return allocUnsafe(size)\n\t};\n\t/**\n\t * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n\t */\n\tBuffer.allocUnsafeSlow = function (size) {\n\t  return allocUnsafe(size)\n\t};\n\n\tfunction fromString (string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') {\n\t    encoding = 'utf8';\n\t  }\n\n\t  if (!Buffer.isEncoding(encoding)) {\n\t    throw new TypeError('Unknown encoding: ' + encoding)\n\t  }\n\n\t  const length = byteLength(string, encoding) | 0;\n\t  let buf = createBuffer(length);\n\n\t  const actual = buf.write(string, encoding);\n\n\t  if (actual !== length) {\n\t    // Writing a hex string, for example, that contains invalid characters will\n\t    // cause everything after the first invalid character to be ignored. (e.g.\n\t    // 'abxxcd' will be treated as 'ab')\n\t    buf = buf.slice(0, actual);\n\t  }\n\n\t  return buf\n\t}\n\n\tfunction fromArrayLike (array) {\n\t  const length = array.length < 0 ? 0 : checked(array.length) | 0;\n\t  const buf = createBuffer(length);\n\t  for (let i = 0; i < length; i += 1) {\n\t    buf[i] = array[i] & 255;\n\t  }\n\t  return buf\n\t}\n\n\tfunction fromArrayView (arrayView) {\n\t  if (isInstance(arrayView, GlobalUint8Array)) {\n\t    const copy = new GlobalUint8Array(arrayView);\n\t    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n\t  }\n\t  return fromArrayLike(arrayView)\n\t}\n\n\tfunction fromArrayBuffer (array, byteOffset, length) {\n\t  if (byteOffset < 0 || array.byteLength < byteOffset) {\n\t    throw new RangeError('\"offset\" is outside of buffer bounds')\n\t  }\n\n\t  if (array.byteLength < byteOffset + (length || 0)) {\n\t    throw new RangeError('\"length\" is outside of buffer bounds')\n\t  }\n\n\t  let buf;\n\t  if (byteOffset === undefined && length === undefined) {\n\t    buf = new GlobalUint8Array(array);\n\t  } else if (length === undefined) {\n\t    buf = new GlobalUint8Array(array, byteOffset);\n\t  } else {\n\t    buf = new GlobalUint8Array(array, byteOffset, length);\n\t  }\n\n\t  // Return an augmented `Uint8Array` instance\n\t  Object.setPrototypeOf(buf, Buffer.prototype);\n\n\t  return buf\n\t}\n\n\tfunction fromObject (obj) {\n\t  if (Buffer.isBuffer(obj)) {\n\t    const len = checked(obj.length) | 0;\n\t    const buf = createBuffer(len);\n\n\t    if (buf.length === 0) {\n\t      return buf\n\t    }\n\n\t    obj.copy(buf, 0, 0, len);\n\t    return buf\n\t  }\n\n\t  if (obj.length !== undefined) {\n\t    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n\t      return createBuffer(0)\n\t    }\n\t    return fromArrayLike(obj)\n\t  }\n\n\t  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n\t    return fromArrayLike(obj.data)\n\t  }\n\t}\n\n\tfunction checked (length) {\n\t  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= K_MAX_LENGTH) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\n\tfunction SlowBuffer (length) {\n\t  if (+length != length) { // eslint-disable-line eqeqeq\n\t    length = 0;\n\t  }\n\t  return Buffer.alloc(+length)\n\t}\n\n\tBuffer.isBuffer = function isBuffer (b) {\n\t  return b != null && b._isBuffer === true &&\n\t    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n\t};\n\n\tBuffer.compare = function compare (a, b) {\n\t  if (isInstance(a, GlobalUint8Array)) a = Buffer.from(a, a.offset, a.byteLength);\n\t  if (isInstance(b, GlobalUint8Array)) b = Buffer.from(b, b.offset, b.byteLength);\n\t  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t    throw new TypeError(\n\t      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n\t    )\n\t  }\n\n\t  if (a === b) return 0\n\n\t  let x = a.length;\n\t  let y = b.length;\n\n\t  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n\t    if (a[i] !== b[i]) {\n\t      x = a[i];\n\t      y = b[i];\n\t      break\n\t    }\n\t  }\n\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t};\n\n\tBuffer.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'latin1':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t};\n\n\tBuffer.concat = function concat (list, length) {\n\t  if (!Array.isArray(list)) {\n\t    throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t  }\n\n\t  if (list.length === 0) {\n\t    return Buffer.alloc(0)\n\t  }\n\n\t  let i;\n\t  if (length === undefined) {\n\t    length = 0;\n\t    for (i = 0; i < list.length; ++i) {\n\t      length += list[i].length;\n\t    }\n\t  }\n\n\t  const buffer = Buffer.allocUnsafe(length);\n\t  let pos = 0;\n\t  for (i = 0; i < list.length; ++i) {\n\t    let buf = list[i];\n\t    if (isInstance(buf, GlobalUint8Array)) {\n\t      if (pos + buf.length > buffer.length) {\n\t        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);\n\t        buf.copy(buffer, pos);\n\t      } else {\n\t        GlobalUint8Array.prototype.set.call(\n\t          buffer,\n\t          buf,\n\t          pos\n\t        );\n\t      }\n\t    } else if (!Buffer.isBuffer(buf)) {\n\t      throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t    } else {\n\t      buf.copy(buffer, pos);\n\t    }\n\t    pos += buf.length;\n\t  }\n\t  return buffer\n\t};\n\n\tfunction byteLength (string, encoding) {\n\t  if (Buffer.isBuffer(string)) {\n\t    return string.length\n\t  }\n\t  if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {\n\t    return string.byteLength\n\t  }\n\t  if (typeof string !== 'string') {\n\t    throw new TypeError(\n\t      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n\t      'Received type ' + typeof string\n\t    )\n\t  }\n\n\t  const len = string.length;\n\t  const mustMatch = (arguments.length > 2 && arguments[2] === true);\n\t  if (!mustMatch && len === 0) return 0\n\n\t  // Use a for loop to avoid recursion\n\t  let loweredCase = false;\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'latin1':\n\t      case 'binary':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) {\n\t          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n\t        }\n\t        encoding = ('' + encoding).toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t}\n\tBuffer.byteLength = byteLength;\n\n\tfunction slowToString (encoding, start, end) {\n\t  let loweredCase = false;\n\n\t  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n\t  // property of a typed array.\n\n\t  // This behaves neither like String nor Uint8Array in that we set start/end\n\t  // to their upper/lower bounds if the value passed is out of range.\n\t  // undefined is handled specially as per ECMA-262 6th Edition,\n\t  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\t  if (start === undefined || start < 0) {\n\t    start = 0;\n\t  }\n\t  // Return early if start > this.length. Done here to prevent potential uint32\n\t  // coercion fail below.\n\t  if (start > this.length) {\n\t    return ''\n\t  }\n\n\t  if (end === undefined || end > this.length) {\n\t    end = this.length;\n\t  }\n\n\t  if (end <= 0) {\n\t    return ''\n\t  }\n\n\t  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n\t  end >>>= 0;\n\t  start >>>= 0;\n\n\t  if (end <= start) {\n\t    return ''\n\t  }\n\n\t  if (!encoding) encoding = 'utf8';\n\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Slice(this, start, end)\n\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t}\n\n\t// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n\t// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n\t// reliably in a browserify context because there could be multiple different\n\t// copies of the 'buffer' package in use. This method works even for Buffer\n\t// instances that were created from another copy of the `buffer` package.\n\t// See: https://github.com/feross/buffer/issues/154\n\tBuffer.prototype._isBuffer = true;\n\n\tfunction swap (b, n, m) {\n\t  const i = b[n];\n\t  b[n] = b[m];\n\t  b[m] = i;\n\t}\n\n\tBuffer.prototype.swap16 = function swap16 () {\n\t  const len = this.length;\n\t  if (len % 2 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 16-bits')\n\t  }\n\t  for (let i = 0; i < len; i += 2) {\n\t    swap(this, i, i + 1);\n\t  }\n\t  return this\n\t};\n\n\tBuffer.prototype.swap32 = function swap32 () {\n\t  const len = this.length;\n\t  if (len % 4 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 32-bits')\n\t  }\n\t  for (let i = 0; i < len; i += 4) {\n\t    swap(this, i, i + 3);\n\t    swap(this, i + 1, i + 2);\n\t  }\n\t  return this\n\t};\n\n\tBuffer.prototype.swap64 = function swap64 () {\n\t  const len = this.length;\n\t  if (len % 8 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 64-bits')\n\t  }\n\t  for (let i = 0; i < len; i += 8) {\n\t    swap(this, i, i + 7);\n\t    swap(this, i + 1, i + 6);\n\t    swap(this, i + 2, i + 5);\n\t    swap(this, i + 3, i + 4);\n\t  }\n\t  return this\n\t};\n\n\tBuffer.prototype.toString = function toString () {\n\t  const length = this.length;\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t};\n\n\tBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\n\tBuffer.prototype.equals = function equals (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer.compare(this, b) === 0\n\t};\n\n\tBuffer.prototype.inspect = function inspect () {\n\t  let str = '';\n\t  const max = exports.INSPECT_MAX_BYTES;\n\t  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n\t  if (this.length > max) str += ' ... ';\n\t  return '<Buffer ' + str + '>'\n\t};\n\tif (customInspectSymbol) {\n\t  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;\n\t}\n\n\tBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n\t  if (isInstance(target, GlobalUint8Array)) {\n\t    target = Buffer.from(target, target.offset, target.byteLength);\n\t  }\n\t  if (!Buffer.isBuffer(target)) {\n\t    throw new TypeError(\n\t      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n\t      'Received type ' + (typeof target)\n\t    )\n\t  }\n\n\t  if (start === undefined) {\n\t    start = 0;\n\t  }\n\t  if (end === undefined) {\n\t    end = target ? target.length : 0;\n\t  }\n\t  if (thisStart === undefined) {\n\t    thisStart = 0;\n\t  }\n\t  if (thisEnd === undefined) {\n\t    thisEnd = this.length;\n\t  }\n\n\t  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n\t    throw new RangeError('out of range index')\n\t  }\n\n\t  if (thisStart >= thisEnd && start >= end) {\n\t    return 0\n\t  }\n\t  if (thisStart >= thisEnd) {\n\t    return -1\n\t  }\n\t  if (start >= end) {\n\t    return 1\n\t  }\n\n\t  start >>>= 0;\n\t  end >>>= 0;\n\t  thisStart >>>= 0;\n\t  thisEnd >>>= 0;\n\n\t  if (this === target) return 0\n\n\t  let x = thisEnd - thisStart;\n\t  let y = end - start;\n\t  const len = Math.min(x, y);\n\n\t  const thisCopy = this.slice(thisStart, thisEnd);\n\t  const targetCopy = target.slice(start, end);\n\n\t  for (let i = 0; i < len; ++i) {\n\t    if (thisCopy[i] !== targetCopy[i]) {\n\t      x = thisCopy[i];\n\t      y = targetCopy[i];\n\t      break\n\t    }\n\t  }\n\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t};\n\n\t// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n\t// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n\t//\n\t// Arguments:\n\t// - buffer - a Buffer to search\n\t// - val - a string, Buffer, or number\n\t// - byteOffset - an index into `buffer`; will be clamped to an int32\n\t// - encoding - an optional encoding, relevant is val is a string\n\t// - dir - true for indexOf, false for lastIndexOf\n\tfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n\t  // Empty buffer means no match\n\t  if (buffer.length === 0) return -1\n\n\t  // Normalize byteOffset\n\t  if (typeof byteOffset === 'string') {\n\t    encoding = byteOffset;\n\t    byteOffset = 0;\n\t  } else if (byteOffset > 0x7fffffff) {\n\t    byteOffset = 0x7fffffff;\n\t  } else if (byteOffset < -0x80000000) {\n\t    byteOffset = -0x80000000;\n\t  }\n\t  byteOffset = +byteOffset; // Coerce to Number.\n\t  if (numberIsNaN(byteOffset)) {\n\t    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n\t    byteOffset = dir ? 0 : (buffer.length - 1);\n\t  }\n\n\t  // Normalize byteOffset: negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\t  if (byteOffset >= buffer.length) {\n\t    if (dir) return -1\n\t    else byteOffset = buffer.length - 1;\n\t  } else if (byteOffset < 0) {\n\t    if (dir) byteOffset = 0;\n\t    else return -1\n\t  }\n\n\t  // Normalize val\n\t  if (typeof val === 'string') {\n\t    val = Buffer.from(val, encoding);\n\t  }\n\n\t  // Finally, search either indexOf (if dir is true) or lastIndexOf\n\t  if (Buffer.isBuffer(val)) {\n\t    // Special case: looking for empty string/buffer always fails\n\t    if (val.length === 0) {\n\t      return -1\n\t    }\n\t    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n\t  } else if (typeof val === 'number') {\n\t    val = val & 0xFF; // Search for a byte value [0-255]\n\t    if (typeof GlobalUint8Array.prototype.indexOf === 'function') {\n\t      if (dir) {\n\t        return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n\t      } else {\n\t        return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n\t      }\n\t    }\n\t    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n\t  }\n\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\n\tfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n\t  let indexSize = 1;\n\t  let arrLength = arr.length;\n\t  let valLength = val.length;\n\n\t  if (encoding !== undefined) {\n\t    encoding = String(encoding).toLowerCase();\n\t    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n\t        encoding === 'utf16le' || encoding === 'utf-16le') {\n\t      if (arr.length < 2 || val.length < 2) {\n\t        return -1\n\t      }\n\t      indexSize = 2;\n\t      arrLength /= 2;\n\t      valLength /= 2;\n\t      byteOffset /= 2;\n\t    }\n\t  }\n\n\t  function read (buf, i) {\n\t    if (indexSize === 1) {\n\t      return buf[i]\n\t    } else {\n\t      return buf.readUInt16BE(i * indexSize)\n\t    }\n\t  }\n\n\t  let i;\n\t  if (dir) {\n\t    let foundIndex = -1;\n\t    for (i = byteOffset; i < arrLength; i++) {\n\t      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n\t        if (foundIndex === -1) foundIndex = i;\n\t        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n\t      } else {\n\t        if (foundIndex !== -1) i -= i - foundIndex;\n\t        foundIndex = -1;\n\t      }\n\t    }\n\t  } else {\n\t    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\t    for (i = byteOffset; i >= 0; i--) {\n\t      let found = true;\n\t      for (let j = 0; j < valLength; j++) {\n\t        if (read(arr, i + j) !== read(val, j)) {\n\t          found = false;\n\t          break\n\t        }\n\t      }\n\t      if (found) return i\n\t    }\n\t  }\n\n\t  return -1\n\t}\n\n\tBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n\t  return this.indexOf(val, byteOffset, encoding) !== -1\n\t};\n\n\tBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n\t};\n\n\tBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n\t};\n\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0;\n\t  const remaining = buf.length - offset;\n\t  if (!length) {\n\t    length = remaining;\n\t  } else {\n\t    length = Number(length);\n\t    if (length > remaining) {\n\t      length = remaining;\n\t    }\n\t  }\n\n\t  const strLen = string.length;\n\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2;\n\t  }\n\t  let i;\n\t  for (i = 0; i < length; ++i) {\n\t    const parsed = parseInt(string.substr(i * 2, 2), 16);\n\t    if (numberIsNaN(parsed)) return i\n\t    buf[offset + i] = parsed;\n\t  }\n\t  return i\n\t}\n\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\n\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8';\n\t    length = this.length;\n\t    offset = 0;\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset;\n\t    length = this.length;\n\t    offset = 0;\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset >>> 0;\n\t    if (isFinite(length)) {\n\t      length = length >>> 0;\n\t      if (encoding === undefined) encoding = 'utf8';\n\t    } else {\n\t      encoding = length;\n\t      length = undefined;\n\t    }\n\t  } else {\n\t    throw new Error(\n\t      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n\t    )\n\t  }\n\n\t  const remaining = this.length - offset;\n\t  if (length === undefined || length > remaining) length = remaining;\n\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('Attempt to write outside buffer bounds')\n\t  }\n\n\t  if (!encoding) encoding = 'utf8';\n\n\t  let loweredCase = false;\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\n\t      case 'ascii':\n\t      case 'latin1':\n\t      case 'binary':\n\t        return asciiWrite(this, string, offset, length)\n\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t};\n\n\tBuffer.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t};\n\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return base64.fromByteArray(buf)\n\t  } else {\n\t    return base64.fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end);\n\t  const res = [];\n\n\t  let i = start;\n\t  while (i < end) {\n\t    const firstByte = buf[i];\n\t    let codePoint = null;\n\t    let bytesPerSequence = (firstByte > 0xEF)\n\t      ? 4\n\t      : (firstByte > 0xDF)\n\t          ? 3\n\t          : (firstByte > 0xBF)\n\t              ? 2\n\t              : 1;\n\n\t    if (i + bytesPerSequence <= end) {\n\t      let secondByte, thirdByte, fourthByte, tempCodePoint;\n\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte;\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1];\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1];\n\t          thirdByte = buf[i + 2];\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1];\n\t          thirdByte = buf[i + 2];\n\t          fourthByte = buf[i + 3];\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t      }\n\t    }\n\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD;\n\t      bytesPerSequence = 1;\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000;\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n\t      codePoint = 0xDC00 | codePoint & 0x3FF;\n\t    }\n\n\t    res.push(codePoint);\n\t    i += bytesPerSequence;\n\t  }\n\n\t  return decodeCodePointsArray(res)\n\t}\n\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tconst MAX_ARGUMENTS_LENGTH = 0x1000;\n\n\tfunction decodeCodePointsArray (codePoints) {\n\t  const len = codePoints.length;\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  let res = '';\n\t  let i = 0;\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    );\n\t  }\n\t  return res\n\t}\n\n\tfunction asciiSlice (buf, start, end) {\n\t  let ret = '';\n\t  end = Math.min(buf.length, end);\n\n\t  for (let i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F);\n\t  }\n\t  return ret\n\t}\n\n\tfunction latin1Slice (buf, start, end) {\n\t  let ret = '';\n\t  end = Math.min(buf.length, end);\n\n\t  for (let i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i]);\n\t  }\n\t  return ret\n\t}\n\n\tfunction hexSlice (buf, start, end) {\n\t  const len = buf.length;\n\n\t  if (!start || start < 0) start = 0;\n\t  if (!end || end < 0 || end > len) end = len;\n\n\t  let out = '';\n\t  for (let i = start; i < end; ++i) {\n\t    out += hexSliceLookupTable[buf[i]];\n\t  }\n\t  return out\n\t}\n\n\tfunction utf16leSlice (buf, start, end) {\n\t  const bytes = buf.slice(start, end);\n\t  let res = '';\n\t  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n\t  for (let i = 0; i < bytes.length - 1; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));\n\t  }\n\t  return res\n\t}\n\n\tBuffer.prototype.slice = function slice (start, end) {\n\t  const len = this.length;\n\t  start = ~~start;\n\t  end = end === undefined ? len : ~~end;\n\n\t  if (start < 0) {\n\t    start += len;\n\t    if (start < 0) start = 0;\n\t  } else if (start > len) {\n\t    start = len;\n\t  }\n\n\t  if (end < 0) {\n\t    end += len;\n\t    if (end < 0) end = 0;\n\t  } else if (end > len) {\n\t    end = len;\n\t  }\n\n\t  if (end < start) end = start;\n\n\t  const newBuf = this.subarray(start, end);\n\t  // Return an augmented `Uint8Array` instance\n\t  Object.setPrototypeOf(newBuf, Buffer.prototype);\n\n\t  return newBuf\n\t};\n\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\n\tBuffer.prototype.readUintLE =\n\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  let val = this[offset];\n\t  let mul = 1;\n\t  let i = 0;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul;\n\t  }\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readUintBE =\n\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length);\n\t  }\n\n\t  let val = this[offset + --byteLength];\n\t  let mul = 1;\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul;\n\t  }\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readUint8 =\n\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 1, this.length);\n\t  return this[offset]\n\t};\n\n\tBuffer.prototype.readUint16LE =\n\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  return this[offset] | (this[offset + 1] << 8)\n\t};\n\n\tBuffer.prototype.readUint16BE =\n\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  return (this[offset] << 8) | this[offset + 1]\n\t};\n\n\tBuffer.prototype.readUint32LE =\n\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t};\n\n\tBuffer.prototype.readUint32BE =\n\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t};\n\n\tBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n\t  offset = offset >>> 0;\n\t  validateNumber(offset, 'offset');\n\t  const first = this[offset];\n\t  const last = this[offset + 7];\n\t  if (first === undefined || last === undefined) {\n\t    boundsError(offset, this.length - 8);\n\t  }\n\n\t  const lo = first +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 24;\n\n\t  const hi = this[++offset] +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset] * 2 ** 16 +\n\t    last * 2 ** 24;\n\n\t  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n\t});\n\n\tBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n\t  offset = offset >>> 0;\n\t  validateNumber(offset, 'offset');\n\t  const first = this[offset];\n\t  const last = this[offset + 7];\n\t  if (first === undefined || last === undefined) {\n\t    boundsError(offset, this.length - 8);\n\t  }\n\n\t  const hi = first * 2 ** 24 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset];\n\n\t  const lo = this[++offset] * 2 ** 24 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 8 +\n\t    last;\n\n\t  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n\t});\n\n\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  let val = this[offset];\n\t  let mul = 1;\n\t  let i = 0;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul;\n\t  }\n\t  mul *= 0x80;\n\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  let i = byteLength;\n\t  let mul = 1;\n\t  let val = this[offset + --i];\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul;\n\t  }\n\t  mul *= 0x80;\n\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 1, this.length);\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t};\n\n\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  const val = this[offset] | (this[offset + 1] << 8);\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t};\n\n\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  const val = this[offset + 1] | (this[offset] << 8);\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t};\n\n\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t};\n\n\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t};\n\n\tBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n\t  offset = offset >>> 0;\n\t  validateNumber(offset, 'offset');\n\t  const first = this[offset];\n\t  const last = this[offset + 7];\n\t  if (first === undefined || last === undefined) {\n\t    boundsError(offset, this.length - 8);\n\t  }\n\n\t  const val = this[offset + 4] +\n\t    this[offset + 5] * 2 ** 8 +\n\t    this[offset + 6] * 2 ** 16 +\n\t    (last << 24); // Overflow\n\n\t  return (BigInt(val) << BigInt(32)) +\n\t    BigInt(first +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 24)\n\t});\n\n\tBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n\t  offset = offset >>> 0;\n\t  validateNumber(offset, 'offset');\n\t  const first = this[offset];\n\t  const last = this[offset + 7];\n\t  if (first === undefined || last === undefined) {\n\t    boundsError(offset, this.length - 8);\n\t  }\n\n\t  const val = (first << 24) + // Overflow\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset];\n\n\t  return (BigInt(val) << BigInt(32)) +\n\t    BigInt(this[++offset] * 2 ** 24 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 8 +\n\t    last)\n\t});\n\n\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\t  return ieee754$1.read(this, offset, true, 23, 4)\n\t};\n\n\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\t  return ieee754$1.read(this, offset, false, 23, 4)\n\t};\n\n\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 8, this.length);\n\t  return ieee754$1.read(this, offset, true, 52, 8)\n\t};\n\n\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 8, this.length);\n\t  return ieee754$1.read(this, offset, false, 52, 8)\n\t};\n\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t}\n\n\tBuffer.prototype.writeUintLE =\n\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) {\n\t    const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0);\n\t  }\n\n\t  let mul = 1;\n\t  let i = 0;\n\t  this[offset] = value & 0xFF;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeUintBE =\n\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) {\n\t    const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0);\n\t  }\n\n\t  let i = byteLength - 1;\n\t  let mul = 1;\n\t  this[offset + i] = value & 0xFF;\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeUint8 =\n\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n\t  this[offset] = (value & 0xff);\n\t  return offset + 1\n\t};\n\n\tBuffer.prototype.writeUint16LE =\n\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\t  this[offset] = (value & 0xff);\n\t  this[offset + 1] = (value >>> 8);\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeUint16BE =\n\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\t  this[offset] = (value >>> 8);\n\t  this[offset + 1] = (value & 0xff);\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeUint32LE =\n\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\t  this[offset + 3] = (value >>> 24);\n\t  this[offset + 2] = (value >>> 16);\n\t  this[offset + 1] = (value >>> 8);\n\t  this[offset] = (value & 0xff);\n\t  return offset + 4\n\t};\n\n\tBuffer.prototype.writeUint32BE =\n\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\t  this[offset] = (value >>> 24);\n\t  this[offset + 1] = (value >>> 16);\n\t  this[offset + 2] = (value >>> 8);\n\t  this[offset + 3] = (value & 0xff);\n\t  return offset + 4\n\t};\n\n\tfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n\t  checkIntBI(value, min, max, buf, offset, 7);\n\n\t  let lo = Number(value & BigInt(0xffffffff));\n\t  buf[offset++] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset++] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset++] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset++] = lo;\n\t  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n\t  buf[offset++] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset++] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset++] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset++] = hi;\n\t  return offset\n\t}\n\n\tfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n\t  checkIntBI(value, min, max, buf, offset, 7);\n\n\t  let lo = Number(value & BigInt(0xffffffff));\n\t  buf[offset + 7] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset + 6] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset + 5] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset + 4] = lo;\n\t  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n\t  buf[offset + 3] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset + 2] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset + 1] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset] = hi;\n\t  return offset + 8\n\t}\n\n\tBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n\t  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n\t});\n\n\tBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n\t  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n\t});\n\n\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) {\n\t    const limit = Math.pow(2, (8 * byteLength) - 1);\n\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n\t  }\n\n\t  let i = 0;\n\t  let mul = 1;\n\t  let sub = 0;\n\t  this[offset] = value & 0xFF;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n\t      sub = 1;\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) {\n\t    const limit = Math.pow(2, (8 * byteLength) - 1);\n\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n\t  }\n\n\t  let i = byteLength - 1;\n\t  let mul = 1;\n\t  let sub = 0;\n\t  this[offset + i] = value & 0xFF;\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n\t      sub = 1;\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n\t  if (value < 0) value = 0xff + value + 1;\n\t  this[offset] = (value & 0xff);\n\t  return offset + 1\n\t};\n\n\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\t  this[offset] = (value & 0xff);\n\t  this[offset + 1] = (value >>> 8);\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\t  this[offset] = (value >>> 8);\n\t  this[offset + 1] = (value & 0xff);\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\t  this[offset] = (value & 0xff);\n\t  this[offset + 1] = (value >>> 8);\n\t  this[offset + 2] = (value >>> 16);\n\t  this[offset + 3] = (value >>> 24);\n\t  return offset + 4\n\t};\n\n\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\t  if (value < 0) value = 0xffffffff + value + 1;\n\t  this[offset] = (value >>> 24);\n\t  this[offset + 1] = (value >>> 16);\n\t  this[offset + 2] = (value >>> 8);\n\t  this[offset + 3] = (value & 0xff);\n\t  return offset + 4\n\t};\n\n\tBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n\t  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n\t});\n\n\tBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n\t  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n\t});\n\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t  if (offset < 0) throw new RangeError('Index out of range')\n\t}\n\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4);\n\t  }\n\t  ieee754$1.write(buf, value, offset, littleEndian, 23, 4);\n\t  return offset + 4\n\t}\n\n\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t};\n\n\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t};\n\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8);\n\t  }\n\t  ieee754$1.write(buf, value, offset, littleEndian, 52, 8);\n\t  return offset + 8\n\t}\n\n\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t};\n\n\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t};\n\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n\t  if (!start) start = 0;\n\t  if (!end && end !== 0) end = this.length;\n\t  if (targetStart >= target.length) targetStart = target.length;\n\t  if (!targetStart) targetStart = 0;\n\t  if (end > 0 && end < start) end = start;\n\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length;\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start;\n\t  }\n\n\t  const len = end - start;\n\n\t  if (this === target && typeof GlobalUint8Array.prototype.copyWithin === 'function') {\n\t    // Use built-in when available, missing from IE11\n\t    this.copyWithin(targetStart, start, end);\n\t  } else {\n\t    GlobalUint8Array.prototype.set.call(\n\t      target,\n\t      this.subarray(start, end),\n\t      targetStart\n\t    );\n\t  }\n\n\t  return len\n\t};\n\n\t// Usage:\n\t//    buffer.fill(number[, offset[, end]])\n\t//    buffer.fill(buffer[, offset[, end]])\n\t//    buffer.fill(string[, offset[, end]][, encoding])\n\tBuffer.prototype.fill = function fill (val, start, end, encoding) {\n\t  // Handle string cases:\n\t  if (typeof val === 'string') {\n\t    if (typeof start === 'string') {\n\t      encoding = start;\n\t      start = 0;\n\t      end = this.length;\n\t    } else if (typeof end === 'string') {\n\t      encoding = end;\n\t      end = this.length;\n\t    }\n\t    if (encoding !== undefined && typeof encoding !== 'string') {\n\t      throw new TypeError('encoding must be a string')\n\t    }\n\t    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n\t      throw new TypeError('Unknown encoding: ' + encoding)\n\t    }\n\t    if (val.length === 1) {\n\t      const code = val.charCodeAt(0);\n\t      if ((encoding === 'utf8' && code < 128) ||\n\t          encoding === 'latin1') {\n\t        // Fast path: If `val` fits into a single byte, use that numeric value.\n\t        val = code;\n\t      }\n\t    }\n\t  } else if (typeof val === 'number') {\n\t    val = val & 255;\n\t  } else if (typeof val === 'boolean') {\n\t    val = Number(val);\n\t  }\n\n\t  // Invalid ranges are not set to a default, so can range check early.\n\t  if (start < 0 || this.length < start || this.length < end) {\n\t    throw new RangeError('Out of range index')\n\t  }\n\n\t  if (end <= start) {\n\t    return this\n\t  }\n\n\t  start = start >>> 0;\n\t  end = end === undefined ? this.length : end >>> 0;\n\n\t  if (!val) val = 0;\n\n\t  let i;\n\t  if (typeof val === 'number') {\n\t    for (i = start; i < end; ++i) {\n\t      this[i] = val;\n\t    }\n\t  } else {\n\t    const bytes = Buffer.isBuffer(val)\n\t      ? val\n\t      : Buffer.from(val, encoding);\n\t    const len = bytes.length;\n\t    if (len === 0) {\n\t      throw new TypeError('The value \"' + val +\n\t        '\" is invalid for argument \"value\"')\n\t    }\n\t    for (i = 0; i < end - start; ++i) {\n\t      this[i + start] = bytes[i % len];\n\t    }\n\t  }\n\n\t  return this\n\t};\n\n\t// CUSTOM ERRORS\n\t// =============\n\n\t// Simplified versions from Node, changed for Buffer-only usage\n\tconst errors = {};\n\tfunction E (sym, getMessage, Base) {\n\t  errors[sym] = class NodeError extends Base {\n\t    constructor () {\n\t      super();\n\n\t      Object.defineProperty(this, 'message', {\n\t        value: getMessage.apply(this, arguments),\n\t        writable: true,\n\t        configurable: true\n\t      });\n\n\t      // Add the error code to the name to include it in the stack trace.\n\t      this.name = `${this.name} [${sym}]`;\n\t      // Access the stack to generate the error message including the error code\n\t      // from the name.\n\t      this.stack; // eslint-disable-line no-unused-expressions\n\t      // Reset the name to the actual name.\n\t      delete this.name;\n\t    }\n\n\t    get code () {\n\t      return sym\n\t    }\n\n\t    set code (value) {\n\t      Object.defineProperty(this, 'code', {\n\t        configurable: true,\n\t        enumerable: true,\n\t        value,\n\t        writable: true\n\t      });\n\t    }\n\n\t    toString () {\n\t      return `${this.name} [${sym}]: ${this.message}`\n\t    }\n\t  };\n\t}\n\n\tE('ERR_BUFFER_OUT_OF_BOUNDS',\n\t  function (name) {\n\t    if (name) {\n\t      return `${name} is outside of buffer bounds`\n\t    }\n\n\t    return 'Attempt to access memory outside buffer bounds'\n\t  }, RangeError);\n\tE('ERR_INVALID_ARG_TYPE',\n\t  function (name, actual) {\n\t    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n\t  }, TypeError);\n\tE('ERR_OUT_OF_RANGE',\n\t  function (str, range, input) {\n\t    let msg = `The value of \"${str}\" is out of range.`;\n\t    let received = input;\n\t    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n\t      received = addNumericalSeparator(String(input));\n\t    } else if (typeof input === 'bigint') {\n\t      received = String(input);\n\t      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n\t        received = addNumericalSeparator(received);\n\t      }\n\t      received += 'n';\n\t    }\n\t    msg += ` It must be ${range}. Received ${received}`;\n\t    return msg\n\t  }, RangeError);\n\n\tfunction addNumericalSeparator (val) {\n\t  let res = '';\n\t  let i = val.length;\n\t  const start = val[0] === '-' ? 1 : 0;\n\t  for (; i >= start + 4; i -= 3) {\n\t    res = `_${val.slice(i - 3, i)}${res}`;\n\t  }\n\t  return `${val.slice(0, i)}${res}`\n\t}\n\n\t// CHECK FUNCTIONS\n\t// ===============\n\n\tfunction checkBounds (buf, offset, byteLength) {\n\t  validateNumber(offset, 'offset');\n\t  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n\t    boundsError(offset, buf.length - (byteLength + 1));\n\t  }\n\t}\n\n\tfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n\t  if (value > max || value < min) {\n\t    const n = typeof min === 'bigint' ? 'n' : '';\n\t    let range;\n\t    if (byteLength > 3) {\n\t      if (min === 0 || min === BigInt(0)) {\n\t        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n\t      } else {\n\t        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n\t                `${(byteLength + 1) * 8 - 1}${n}`;\n\t      }\n\t    } else {\n\t      range = `>= ${min}${n} and <= ${max}${n}`;\n\t    }\n\t    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n\t  }\n\t  checkBounds(buf, offset, byteLength);\n\t}\n\n\tfunction validateNumber (value, name) {\n\t  if (typeof value !== 'number') {\n\t    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n\t  }\n\t}\n\n\tfunction boundsError (value, length, type) {\n\t  if (Math.floor(value) !== value) {\n\t    validateNumber(value, type);\n\t    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n\t  }\n\n\t  if (length < 0) {\n\t    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n\t  }\n\n\t  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n\t                                    `>= ${type ? 1 : 0} and <= ${length}`,\n\t                                    value)\n\t}\n\n\t// HELPER FUNCTIONS\n\t// ================\n\n\tconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n\n\tfunction base64clean (str) {\n\t  // Node takes equal signs as end of the Base64 encoding\n\t  str = str.split('=')[0];\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = str.trim().replace(INVALID_BASE64_RE, '');\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '=';\n\t  }\n\t  return str\n\t}\n\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity;\n\t  let codePoint;\n\t  const length = string.length;\n\t  let leadSurrogate = null;\n\t  const bytes = [];\n\n\t  for (let i = 0; i < length; ++i) {\n\t    codePoint = string.charCodeAt(i);\n\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t          continue\n\t        }\n\n\t        // valid lead\n\t        leadSurrogate = codePoint;\n\n\t        continue\n\t      }\n\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t        leadSurrogate = codePoint;\n\t        continue\n\t      }\n\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t    }\n\n\t    leadSurrogate = null;\n\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint);\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\n\t  return bytes\n\t}\n\n\tfunction asciiToBytes (str) {\n\t  const byteArray = [];\n\t  for (let i = 0; i < str.length; ++i) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF);\n\t  }\n\t  return byteArray\n\t}\n\n\tfunction utf16leToBytes (str, units) {\n\t  let c, hi, lo;\n\t  const byteArray = [];\n\t  for (let i = 0; i < str.length; ++i) {\n\t    if ((units -= 2) < 0) break\n\n\t    c = str.charCodeAt(i);\n\t    hi = c >> 8;\n\t    lo = c % 256;\n\t    byteArray.push(lo);\n\t    byteArray.push(hi);\n\t  }\n\n\t  return byteArray\n\t}\n\n\tfunction base64ToBytes (str) {\n\t  return base64.toByteArray(base64clean(str))\n\t}\n\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  let i;\n\t  for (i = 0; i < length; ++i) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i];\n\t  }\n\t  return i\n\t}\n\n\t// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n\t// the `instanceof` check but they should be treated as of that type.\n\t// See: https://github.com/feross/buffer/issues/166\n\tfunction isInstance (obj, type) {\n\t  return obj instanceof type ||\n\t    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n\t      obj.constructor.name === type.name)\n\t}\n\tfunction numberIsNaN (obj) {\n\t  // For IE11 support\n\t  return obj !== obj // eslint-disable-line no-self-compare\n\t}\n\n\t// Create lookup table for `toString('hex')`\n\t// See: https://github.com/feross/buffer/issues/219\n\tconst hexSliceLookupTable = (function () {\n\t  const alphabet = '0123456789abcdef';\n\t  const table = new Array(256);\n\t  for (let i = 0; i < 16; ++i) {\n\t    const i16 = i * 16;\n\t    for (let j = 0; j < 16; ++j) {\n\t      table[i16 + j] = alphabet[i] + alphabet[j];\n\t    }\n\t  }\n\t  return table\n\t})();\n\n\t// Return not function with Error if BigInt not supported\n\tfunction defineBigIntMethod (fn) {\n\t  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n\t}\n\n\tfunction BufferBigIntNotDefined () {\n\t  throw new Error('BigInt not supported')\n\t} \n} (buffer));\n\nconst Buffer = buffer.Buffer;\n\nconst Blob = buffer.Blob;\nconst BlobOptions = buffer.BlobOptions;\nconst Buffer$1 = buffer.Buffer;\nconst File = buffer.File;\nconst FileOptions = buffer.FileOptions;\nconst INSPECT_MAX_BYTES = buffer.INSPECT_MAX_BYTES;\nconst SlowBuffer = buffer.SlowBuffer;\nconst TranscodeEncoding = buffer.TranscodeEncoding;\nconst atob = buffer.atob;\nconst btoa = buffer.btoa;\nconst constants = buffer.constants;\nconst isAscii = buffer.isAscii;\nconst isUtf8 = buffer.isUtf8;\nconst kMaxLength = buffer.kMaxLength;\nconst kStringMaxLength = buffer.kStringMaxLength;\nconst resolveObjectURL = buffer.resolveObjectURL;\nconst transcode = buffer.transcode;\nexport { Blob, BlobOptions, Buffer$1 as Buffer, File, FileOptions, INSPECT_MAX_BYTES, SlowBuffer, TranscodeEncoding, atob, btoa, constants, Buffer as default, isAscii, isUtf8, kMaxLength, kStringMaxLength, resolveObjectURL, transcode };\n//# sourceMappingURL=index.js.map\n"],"names":["buffer","base64Js","byteLength","toByteArray","fromByteArray","lookup","revLookup","Arr","Uint8Array","Array","code","i","len","length","charCodeAt","getLens","b64","Error","validLen","indexOf","placeHoldersLen","lens","_byteLength","tmp","arr","curByte","tripletToBase64","num","encodeChunk","uint8","start","end","output","push","join","extraBytes","parts","maxChunkLength","len2","ieee754","read","offset","isLE","mLen","nBytes","e","m","eLen","eMax","eBias","nBits","d","s","NaN","Infinity","Math","pow","write","value","c","rt","abs","isNaN","floor","log","LN2","exports","base64","ieee754$1","customInspectSymbol","Symbol","Buffer","SlowBuffer","INSPECT_MAX_BYTES","K_MAX_LENGTH","kMaxLength","GlobalUint8Array","ArrayBuffer","GlobalArrayBuffer","SharedArrayBuffer","GlobalSharedArrayBuffer","globalThis","TYPED_ARRAY_SUPPORT","typedArraySupport","console","error","proto","foo","Object","setPrototypeOf","prototype","defineProperty","enumerable","get","isBuffer","this","byteOffset","createBuffer","RangeError","buf","arg","encodingOrOffset","TypeError","allocUnsafe","from","poolSize","fromString","isView","fromArrayView","isInstance","fromArrayBuffer","valueOf","b","fromObject","toPrimitive","assertSize","size","alloc","fill","encoding","checked","allocUnsafeSlow","string","isEncoding","actual","slice","fromArrayLike","array","arrayView","copy","obj","numberIsNaN","type","isArray","data","toString","_isBuffer","compare","a","x","y","min","String","toLowerCase","concat","list","pos","set","call","mustMatch","arguments","loweredCase","utf8ToBytes","base64ToBytes","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","n","swap16","swap32","swap64","apply","toLocaleString","equals","inspect","str","max","replace","trim","target","thisStart","thisEnd","thisCopy","targetCopy","bidirectionalIndexOf","val","dir","arrayIndexOf","lastIndexOf","indexSize","arrLength","valLength","readUInt16BE","foundIndex","found","j","includes","hexWrite","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","asciiToBytes","base64Write","ucs2Write","utf16leToBytes","isFinite","toJSON","_arr","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","MAX_ARGUMENTS_LENGTH","codePoints","fromCharCode","ret","out","hexSliceLookupTable","bytes","newBuf","subarray","checkOffset","ext","readUintLE","readUIntLE","noAssert","mul","readUintBE","readUIntBE","readUint8","readUInt8","readUint16LE","readUInt16LE","readUint16BE","readUint32LE","readUInt32LE","readUint32BE","readUInt32BE","readBigUInt64LE","defineBigIntMethod","validateNumber","first","last","boundsError","lo","hi","BigInt","readBigUInt64BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readBigInt64LE","readBigInt64BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","checkInt","writeUintLE","writeUIntLE","maxBytes","writeUintBE","writeUIntBE","writeUint8","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","wrtBigUInt64LE","checkIntBI","wrtBigUInt64BE","writeBigUInt64LE","writeBigUInt64BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeBigInt64LE","writeBigInt64BE","checkIEEE754","writeFloat","littleEndian","writeFloatLE","writeFloatBE","writeDouble","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","errors","E","sym","getMessage","Base","NodeError","constructor","super","writable","configurable","name","stack","message","range","input","msg","received","isInteger","addNumericalSeparator","checkBounds","ERR_OUT_OF_RANGE","ERR_INVALID_ARG_TYPE","ERR_BUFFER_OUT_OF_BOUNDS","INVALID_BASE64_RE","base64clean","split","units","leadSurrogate","byteArray","src","dst","alphabet","table","i16","fn","BufferBigIntNotDefined","Buffer$1"],"mappings":"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","x_google_ignoreList":[0]}