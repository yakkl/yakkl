/*! For license information please see node_modules_pnpm_alchemy-sdk_3_5_1_bufferutil_4_0_9_utf-8-validate_5_0_10_node_modules_alche-9b54f3.js.LICENSE.txt */
(self['webpackChunkyakkl_wallet'] = self['webpackChunkyakkl_wallet'] || []).push([
	[
		'node_modules_pnpm_alchemy-sdk_3_5_1_bufferutil_4_0_9_utf-8-validate_5_0_10_node_modules_alche-9b54f3'
	],
	{
		'../../node_modules/.pnpm/@ethersproject+constants@5.7.0/node_modules/@ethersproject/constants/lib.esm/addresses.js':
			(e, t, r) => {
				'use strict';
				r.r(t);
				r.d(t, { AddressZero: () => s });
				const s = '0x0000000000000000000000000000000000000000';
			},
		'../../node_modules/.pnpm/@ethersproject+constants@5.7.0/node_modules/@ethersproject/constants/lib.esm/hashes.js':
			(e, t, r) => {
				'use strict';
				r.r(t);
				r.d(t, { HashZero: () => s });
				const s = '0x0000000000000000000000000000000000000000000000000000000000000000';
			},
		'../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js':
			(e, t, r) => {
				'use strict';
				r.r(t);
				r.d(t, {
					decode_arithmetic: () => decode_arithmetic,
					read_compressed_payload: () => read_compressed_payload,
					read_emoji_trie: () => read_emoji_trie,
					read_mapped_map: () => read_mapped_map,
					read_member_array: () => read_member_array,
					read_payload: () => read_payload,
					read_zero_terminated_array: () => read_zero_terminated_array,
					signed: () => signed
				});
				function flat(e, t) {
					if (t == null) {
						t = 1;
					}
					const r = [];
					const s = r.forEach;
					const flatDeep = function (e, t) {
						s.call(e, function (e) {
							if (t > 0 && Array.isArray(e)) {
								flatDeep(e, t - 1);
							} else {
								r.push(e);
							}
						});
					};
					flatDeep(e, t);
					return r;
				}
				function fromEntries(e) {
					const t = {};
					for (let r = 0; r < e.length; r++) {
						const s = e[r];
						t[s[0]] = s[1];
					}
					return t;
				}
				function decode_arithmetic(e) {
					let t = 0;
					function u16() {
						return (e[t++] << 8) | e[t++];
					}
					let r = u16();
					let s = 1;
					let n = [0, 1];
					for (let e = 1; e < r; e++) {
						n.push((s += u16()));
					}
					let o = u16();
					let i = t;
					t += o;
					let l = 0;
					let a = 0;
					function read_bit() {
						if (l == 0) {
							a = (a << 8) | e[t++];
							l = 8;
						}
						return (a >> --l) & 1;
					}
					const c = 31;
					const u = Math.pow(2, c);
					const d = u >>> 1;
					const h = d >> 1;
					const f = u - 1;
					let m = 0;
					for (let e = 0; e < c; e++) m = (m << 1) | read_bit();
					let p = [];
					let g = 0;
					let b = u;
					while (true) {
						let e = Math.floor(((m - g + 1) * s - 1) / b);
						let t = 0;
						let o = r;
						while (o - t > 1) {
							let r = (t + o) >>> 1;
							if (e < n[r]) {
								o = r;
							} else {
								t = r;
							}
						}
						if (t == 0) break;
						p.push(t);
						let i = g + Math.floor((b * n[t]) / s);
						let l = g + Math.floor((b * n[t + 1]) / s) - 1;
						while (((i ^ l) & d) == 0) {
							m = ((m << 1) & f) | read_bit();
							i = (i << 1) & f;
							l = ((l << 1) & f) | 1;
						}
						while (i & ~l & h) {
							m = (m & d) | ((m << 1) & (f >>> 1)) | read_bit();
							i = (i << 1) ^ d;
							l = ((l ^ d) << 1) | d | 1;
						}
						g = i;
						b = 1 + l - i;
					}
					let A = r - 4;
					return p.map((t) => {
						switch (t - A) {
							case 3:
								return A + 65792 + ((e[i++] << 16) | (e[i++] << 8) | e[i++]);
							case 2:
								return A + 256 + ((e[i++] << 8) | e[i++]);
							case 1:
								return A + e[i++];
							default:
								return t - 1;
						}
					});
				}
				function read_payload(e) {
					let t = 0;
					return () => e[t++];
				}
				function read_compressed_payload(e) {
					return read_payload(decode_arithmetic(e));
				}
				function signed(e) {
					return e & 1 ? ~e >> 1 : e >> 1;
				}
				function read_counts(e, t) {
					let r = Array(e);
					for (let s = 0; s < e; s++) r[s] = 1 + t();
					return r;
				}
				function read_ascending(e, t) {
					let r = Array(e);
					for (let s = 0, n = -1; s < e; s++) r[s] = n += 1 + t();
					return r;
				}
				function read_deltas(e, t) {
					let r = Array(e);
					for (let s = 0, n = 0; s < e; s++) r[s] = n += signed(t());
					return r;
				}
				function read_member_array(e, t) {
					let r = read_ascending(e(), e);
					let s = e();
					let n = read_ascending(s, e);
					let o = read_counts(s, e);
					for (let e = 0; e < s; e++) {
						for (let t = 0; t < o[e]; t++) {
							r.push(n[e] + t);
						}
					}
					return t ? r.map((e) => t[e]) : r;
				}
				function read_mapped_map(e) {
					let t = [];
					while (true) {
						let r = e();
						if (r == 0) break;
						t.push(read_linear_table(r, e));
					}
					while (true) {
						let r = e() - 1;
						if (r < 0) break;
						t.push(read_replacement_table(r, e));
					}
					return fromEntries(flat(t));
				}
				function read_zero_terminated_array(e) {
					let t = [];
					while (true) {
						let r = e();
						if (r == 0) break;
						t.push(r);
					}
					return t;
				}
				function read_transposed(e, t, r) {
					let s = Array(e)
						.fill(undefined)
						.map(() => []);
					for (let n = 0; n < t; n++) {
						read_deltas(e, r).forEach((e, t) => s[t].push(e));
					}
					return s;
				}
				function read_linear_table(e, t) {
					let r = 1 + t();
					let s = t();
					let n = read_zero_terminated_array(t);
					let o = read_transposed(n.length, 1 + e, t);
					return flat(
						o.map((e, t) => {
							const o = e[0],
								i = e.slice(1);
							return Array(n[t])
								.fill(undefined)
								.map((e, t) => {
									let n = t * s;
									return [o + t * r, i.map((e) => e + n)];
								});
						})
					);
				}
				function read_replacement_table(e, t) {
					let r = 1 + t();
					let s = read_transposed(r, 1 + e, t);
					return s.map((e) => [e[0], e.slice(1)]);
				}
				function read_emoji_trie(e) {
					let t = read_member_array(e).sort((e, t) => e - t);
					return read();
					function read() {
						let r = [];
						while (true) {
							let s = read_member_array(e, t);
							if (s.length == 0) break;
							r.push({ set: new Set(s), node: read() });
						}
						r.sort((e, t) => t.set.size - e.set.size);
						let s = e();
						let n = s % 3;
						s = (s / 3) | 0;
						let o = !!(s & 1);
						s >>= 1;
						let i = s == 1;
						let l = s == 2;
						return { branches: r, valid: n, fe0f: o, save: i, check: l };
					}
				}
			},
		'../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js':
			(e, t, r) => {
				'use strict';
				r.r(t);
				r.d(t, { getData: () => getData });
				var s = r(
					'../../node_modules/.pnpm/@ethersproject+base64@5.7.0/node_modules/@ethersproject/base64/lib.esm/base64.js'
				);
				var n = r(
					'../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js'
				);
				function getData() {
					return (0, n.read_compressed_payload)(
						(0, s.decode)(
							'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'
						)
					);
				}
			},
		'../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js':
			(e, t, r) => {
				'use strict';
				r.r(t);
				r.d(t, {
					ens_normalize: () => ens_normalize,
					ens_normalize_post_check: () => ens_normalize_post_check
				});
				var s = r(
					'../../node_modules/.pnpm/@ethersproject+strings@5.7.0/node_modules/@ethersproject/strings/lib.esm/utf8.js'
				);
				var n = r(
					'../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js'
				);
				var o = r(
					'../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js'
				);
				const i = (0, n.getData)();
				const l = new Set((0, o.read_member_array)(i));
				const a = new Set((0, o.read_member_array)(i));
				const c = (0, o.read_mapped_map)(i);
				const u = (0, o.read_emoji_trie)(i);
				const d = 45;
				const h = 95;
				function explode_cp(e) {
					return (0, s.toUtf8CodePoints)(e);
				}
				function filter_fe0f(e) {
					return e.filter((e) => e != 65039);
				}
				function ens_normalize_post_check(e) {
					for (let t of e.split('.')) {
						let e = explode_cp(t);
						try {
							for (let t = e.lastIndexOf(h) - 1; t >= 0; t--) {
								if (e[t] !== h) {
									throw new Error(`underscore only allowed at start`);
								}
							}
							if (e.length >= 4 && e.every((e) => e < 128) && e[2] === d && e[3] === d) {
								throw new Error(`invalid label extension`);
							}
						} catch (e) {
							throw new Error(`Invalid label "${t}": ${e.message}`);
						}
					}
					return e;
				}
				function ens_normalize(e) {
					return ens_normalize_post_check(normalize(e, filter_fe0f));
				}
				function normalize(e, t) {
					let r = explode_cp(e).reverse();
					let s = [];
					while (r.length) {
						let e = consume_emoji_reversed(r);
						if (e) {
							s.push(...t(e));
							continue;
						}
						let n = r.pop();
						if (l.has(n)) {
							s.push(n);
							continue;
						}
						if (a.has(n)) {
							continue;
						}
						let o = c[n];
						if (o) {
							s.push(...o);
							continue;
						}
						throw new Error(`Disallowed codepoint: 0x${n.toString(16).toUpperCase()}`);
					}
					return ens_normalize_post_check(nfc(String.fromCodePoint(...s)));
				}
				function nfc(e) {
					return e.normalize('NFC');
				}
				function consume_emoji_reversed(e, t) {
					var r;
					let s = u;
					let n;
					let o;
					let i = [];
					let l = e.length;
					if (t) t.length = 0;
					while (l) {
						let a = e[--l];
						s =
							(r = s.branches.find((e) => e.set.has(a))) === null || r === void 0 ? void 0 : r.node;
						if (!s) break;
						if (s.save) {
							o = a;
						} else if (s.check) {
							if (a === o) break;
						}
						i.push(a);
						if (s.fe0f) {
							i.push(65039);
							if (l > 0 && e[l - 1] == 65039) l--;
						}
						if (s.valid) {
							n = i.slice();
							if (s.valid == 2) n.splice(1, 1);
							if (t) t.push(...e.slice(l).reverse());
							e.length = l;
						}
					}
					return n;
				}
			},
		'../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/namehash.js':
			(e, t, r) => {
				'use strict';
				r.r(t);
				r.d(t, {
					dnsEncode: () => dnsEncode,
					ensNormalize: () => ensNormalize,
					isValidName: () => isValidName,
					namehash: () => namehash
				});
				var s = r(
					'../../node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/index.js'
				);
				var n = r(
					'../../node_modules/.pnpm/@ethersproject+strings@5.7.0/node_modules/@ethersproject/strings/lib.esm/utf8.js'
				);
				var o = r(
					'../../node_modules/.pnpm/@ethersproject+keccak256@5.7.0/node_modules/@ethersproject/keccak256/lib.esm/index.js'
				);
				var i = r(
					'../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js'
				);
				var l = r(
					'../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/_version.js'
				);
				var a = r(
					'../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js'
				);
				const c = new i.Logger(l.version);
				const u = new Uint8Array(32);
				u.fill(0);
				function checkComponent(e) {
					if (e.length === 0) {
						throw new Error('invalid ENS name; empty component');
					}
					return e;
				}
				function ensNameSplit(e) {
					const t = (0, n.toUtf8Bytes)((0, a.ens_normalize)(e));
					const r = [];
					if (e.length === 0) {
						return r;
					}
					let s = 0;
					for (let e = 0; e < t.length; e++) {
						const n = t[e];
						if (n === 46) {
							r.push(checkComponent(t.slice(s, e)));
							s = e + 1;
						}
					}
					if (s >= t.length) {
						throw new Error('invalid ENS name; empty component');
					}
					r.push(checkComponent(t.slice(s)));
					return r;
				}
				function ensNormalize(e) {
					return ensNameSplit(e)
						.map((e) => (0, n.toUtf8String)(e))
						.join('.');
				}
				function isValidName(e) {
					try {
						return ensNameSplit(e).length !== 0;
					} catch (e) {}
					return false;
				}
				function namehash(e) {
					if (typeof e !== 'string') {
						c.throwArgumentError('invalid ENS name; not a string', 'name', e);
					}
					let t = u;
					const r = ensNameSplit(e);
					while (r.length) {
						t = (0, o.keccak256)((0, s.concat)([t, (0, o.keccak256)(r.pop())]));
					}
					return (0, s.hexlify)(t);
				}
				function dnsEncode(e) {
					return (
						(0, s.hexlify)(
							(0, s.concat)(
								ensNameSplit(e).map((e) => {
									if (e.length > 63) {
										throw new Error('invalid DNS encoded entry; length exceeds 63 bytes');
									}
									const t = new Uint8Array(e.length + 1);
									t.set(e, 1);
									t[0] = t.length - 1;
									return t;
								})
							)
						) + '00'
					);
				}
			},
		'../../node_modules/.pnpm/@ethersproject+networks@5.7.1/node_modules/@ethersproject/networks/lib.esm/_version.js':
			(e, t, r) => {
				'use strict';
				r.r(t);
				r.d(t, { version: () => s });
				const s = 'networks/5.7.1';
			},
		'../../node_modules/.pnpm/@ethersproject+networks@5.7.1/node_modules/@ethersproject/networks/lib.esm/index.js':
			(e, t, r) => {
				'use strict';
				r.r(t);
				r.d(t, { getNetwork: () => getNetwork });
				var s = r(
					'../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js'
				);
				var n = r(
					'../../node_modules/.pnpm/@ethersproject+networks@5.7.1/node_modules/@ethersproject/networks/lib.esm/_version.js'
				);
				const o = new s.Logger(n.version);
				function isRenetworkable(e) {
					return e && typeof e.renetwork === 'function';
				}
				function ethDefaultProvider(e) {
					const func = function (t, r) {
						if (r == null) {
							r = {};
						}
						const s = [];
						if (t.InfuraProvider && r.infura !== '-') {
							try {
								s.push(new t.InfuraProvider(e, r.infura));
							} catch (e) {}
						}
						if (t.EtherscanProvider && r.etherscan !== '-') {
							try {
								s.push(new t.EtherscanProvider(e, r.etherscan));
							} catch (e) {}
						}
						if (t.AlchemyProvider && r.alchemy !== '-') {
							try {
								s.push(new t.AlchemyProvider(e, r.alchemy));
							} catch (e) {}
						}
						if (t.PocketProvider && r.pocket !== '-') {
							const n = ['goerli', 'ropsten', 'rinkeby', 'sepolia'];
							try {
								const o = new t.PocketProvider(e, r.pocket);
								if (o.network && n.indexOf(o.network.name) === -1) {
									s.push(o);
								}
							} catch (e) {}
						}
						if (t.CloudflareProvider && r.cloudflare !== '-') {
							try {
								s.push(new t.CloudflareProvider(e));
							} catch (e) {}
						}
						if (t.AnkrProvider && r.ankr !== '-') {
							try {
								const n = ['ropsten'];
								const o = new t.AnkrProvider(e, r.ankr);
								if (o.network && n.indexOf(o.network.name) === -1) {
									s.push(o);
								}
							} catch (e) {}
						}
						if (s.length === 0) {
							return null;
						}
						if (t.FallbackProvider) {
							let n = 1;
							if (r.quorum != null) {
								n = r.quorum;
							} else if (e === 'homestead') {
								n = 2;
							}
							return new t.FallbackProvider(s, n);
						}
						return s[0];
					};
					func.renetwork = function (e) {
						return ethDefaultProvider(e);
					};
					return func;
				}
				function etcDefaultProvider(e, t) {
					const func = function (r, s) {
						if (r.JsonRpcProvider) {
							return new r.JsonRpcProvider(e, t);
						}
						return null;
					};
					func.renetwork = function (t) {
						return etcDefaultProvider(e, t);
					};
					return func;
				}
				const i = {
					chainId: 1,
					ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
					name: 'homestead',
					_defaultProvider: ethDefaultProvider('homestead')
				};
				const l = {
					chainId: 3,
					ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
					name: 'ropsten',
					_defaultProvider: ethDefaultProvider('ropsten')
				};
				const a = {
					chainId: 63,
					name: 'classicMordor',
					_defaultProvider: etcDefaultProvider(
						'https://www.ethercluster.com/mordor',
						'classicMordor'
					)
				};
				const c = {
					unspecified: { chainId: 0, name: 'unspecified' },
					homestead: i,
					mainnet: i,
					morden: { chainId: 2, name: 'morden' },
					ropsten: l,
					testnet: l,
					rinkeby: {
						chainId: 4,
						ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
						name: 'rinkeby',
						_defaultProvider: ethDefaultProvider('rinkeby')
					},
					kovan: { chainId: 42, name: 'kovan', _defaultProvider: ethDefaultProvider('kovan') },
					goerli: {
						chainId: 5,
						ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
						name: 'goerli',
						_defaultProvider: ethDefaultProvider('goerli')
					},
					kintsugi: { chainId: 1337702, name: 'kintsugi' },
					sepolia: {
						chainId: 11155111,
						name: 'sepolia',
						_defaultProvider: ethDefaultProvider('sepolia')
					},
					classic: {
						chainId: 61,
						name: 'classic',
						_defaultProvider: etcDefaultProvider('https://www.ethercluster.com/etc', 'classic')
					},
					classicMorden: { chainId: 62, name: 'classicMorden' },
					classicMordor: a,
					classicTestnet: a,
					classicKotti: {
						chainId: 6,
						name: 'classicKotti',
						_defaultProvider: etcDefaultProvider(
							'https://www.ethercluster.com/kotti',
							'classicKotti'
						)
					},
					xdai: { chainId: 100, name: 'xdai' },
					matic: { chainId: 137, name: 'matic', _defaultProvider: ethDefaultProvider('matic') },
					maticmum: { chainId: 80001, name: 'maticmum' },
					optimism: {
						chainId: 10,
						name: 'optimism',
						_defaultProvider: ethDefaultProvider('optimism')
					},
					'optimism-kovan': { chainId: 69, name: 'optimism-kovan' },
					'optimism-goerli': { chainId: 420, name: 'optimism-goerli' },
					arbitrum: { chainId: 42161, name: 'arbitrum' },
					'arbitrum-rinkeby': { chainId: 421611, name: 'arbitrum-rinkeby' },
					'arbitrum-goerli': { chainId: 421613, name: 'arbitrum-goerli' },
					bnb: { chainId: 56, name: 'bnb' },
					bnbt: { chainId: 97, name: 'bnbt' }
				};
				function getNetwork(e) {
					if (e == null) {
						return null;
					}
					if (typeof e === 'number') {
						for (const t in c) {
							const r = c[t];
							if (r.chainId === e) {
								return {
									name: r.name,
									chainId: r.chainId,
									ensAddress: r.ensAddress || null,
									_defaultProvider: r._defaultProvider || null
								};
							}
						}
						return { chainId: e, name: 'unknown' };
					}
					if (typeof e === 'string') {
						const t = c[e];
						if (t == null) {
							return null;
						}
						return {
							name: t.name,
							chainId: t.chainId,
							ensAddress: t.ensAddress,
							_defaultProvider: t._defaultProvider || null
						};
					}
					const t = c[e.name];
					if (!t) {
						if (typeof e.chainId !== 'number') {
							o.throwArgumentError('invalid network chainId', 'network', e);
						}
						return e;
					}
					if (e.chainId !== 0 && e.chainId !== t.chainId) {
						o.throwArgumentError('network chainId mismatch', 'network', e);
					}
					let r = e._defaultProvider || null;
					if (r == null && t._defaultProvider) {
						if (isRenetworkable(t._defaultProvider)) {
							r = t._defaultProvider.renetwork(e);
						} else {
							r = t._defaultProvider;
						}
					}
					return {
						name: e.name,
						chainId: t.chainId,
						ensAddress: e.ensAddress || t.ensAddress || null,
						_defaultProvider: r
					};
				}
			},
		'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/_version.js':
			(e, t, r) => {
				'use strict';
				r.r(t);
				r.d(t, { version: () => s });
				const s = 'providers/5.7.2';
			},
		'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/base-provider.js':
			(e, t, r) => {
				'use strict';
				r.r(t);
				r.d(t, { BaseProvider: () => BaseProvider, Event: () => Event, Resolver: () => Resolver });
				var s = r(
					'../../node_modules/.pnpm/@ethersproject+abstract-provider@5.7.0/node_modules/@ethersproject/abstract-provider/lib.esm/index.js'
				);
				var n = r(
					'../../node_modules/.pnpm/@ethersproject+base64@5.7.0/node_modules/@ethersproject/base64/lib.esm/base64.js'
				);
				var o = r(
					'../../node_modules/.pnpm/@ethersproject+basex@5.7.0/node_modules/@ethersproject/basex/lib.esm/index.js'
				);
				var i = r(
					'../../node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js'
				);
				var l = r(
					'../../node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/index.js'
				);
				var a = r(
					'../../node_modules/.pnpm/@ethersproject+constants@5.7.0/node_modules/@ethersproject/constants/lib.esm/hashes.js'
				);
				var c = r(
					'../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/namehash.js'
				);
				var u = r(
					'../../node_modules/.pnpm/@ethersproject+networks@5.7.1/node_modules/@ethersproject/networks/lib.esm/index.js'
				);
				var d = r(
					'../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/index.js'
				);
				var h = r(
					'../../node_modules/.pnpm/@ethersproject+sha2@5.7.0/node_modules/@ethersproject/sha2/lib.esm/sha2.js'
				);
				var f = r(
					'../../node_modules/.pnpm/@ethersproject+strings@5.7.0/node_modules/@ethersproject/strings/lib.esm/utf8.js'
				);
				var m = r(
					'../../node_modules/.pnpm/@ethersproject+web@5.7.1/node_modules/@ethersproject/web/lib.esm/index.js'
				);
				var p = r('../../node_modules/.pnpm/bech32@1.1.4/node_modules/bech32/index.js');
				var g = r.n(p);
				var b = r(
					'../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js'
				);
				var A = r(
					'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/_version.js'
				);
				var v = r(
					'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/formatter.js'
				);
				var w =
					(undefined && undefined.__awaiter) ||
					function (e, t, r, s) {
						function adopt(e) {
							return e instanceof r
								? e
								: new r(function (t) {
										t(e);
									});
						}
						return new (r || (r = Promise))(function (r, n) {
							function fulfilled(e) {
								try {
									step(s.next(e));
								} catch (e) {
									n(e);
								}
							}
							function rejected(e) {
								try {
									step(s['throw'](e));
								} catch (e) {
									n(e);
								}
							}
							function step(e) {
								e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected);
							}
							step((s = s.apply(e, t || [])).next());
						});
					};
				const y = new b.Logger(A.version);
				const k = 10;
				function checkTopic(e) {
					if (e == null) {
						return 'null';
					}
					if ((0, l.hexDataLength)(e) !== 32) {
						y.throwArgumentError('invalid topic', 'topic', e);
					}
					return e.toLowerCase();
				}
				function serializeTopics(e) {
					e = e.slice();
					while (e.length > 0 && e[e.length - 1] == null) {
						e.pop();
					}
					return e
						.map((e) => {
							if (Array.isArray(e)) {
								const t = {};
								e.forEach((e) => {
									t[checkTopic(e)] = true;
								});
								const r = Object.keys(t);
								r.sort();
								return r.join('|');
							} else {
								return checkTopic(e);
							}
						})
						.join('&');
				}
				function deserializeTopics(e) {
					if (e === '') {
						return [];
					}
					return e.split(/&/g).map((e) => {
						if (e === '') {
							return [];
						}
						const t = e.split('|').map((e) => (e === 'null' ? null : e));
						return t.length === 1 ? t[0] : t;
					});
				}
				function getEventTag(e) {
					if (typeof e === 'string') {
						e = e.toLowerCase();
						if ((0, l.hexDataLength)(e) === 32) {
							return 'tx:' + e;
						}
						if (e.indexOf(':') === -1) {
							return e;
						}
					} else if (Array.isArray(e)) {
						return 'filter:*:' + serializeTopics(e);
					} else if (s.ForkEvent.isForkEvent(e)) {
						y.warn('not implemented');
						throw new Error('not implemented');
					} else if (e && typeof e === 'object') {
						return 'filter:' + (e.address || '*') + ':' + serializeTopics(e.topics || []);
					}
					throw new Error('invalid event - ' + e);
				}
				function getTime() {
					return new Date().getTime();
				}
				function stall(e) {
					return new Promise((t) => {
						setTimeout(t, e);
					});
				}
				const _ = ['block', 'network', 'pending', 'poll'];
				class Event {
					constructor(e, t, r) {
						(0, d.defineReadOnly)(this, 'tag', e);
						(0, d.defineReadOnly)(this, 'listener', t);
						(0, d.defineReadOnly)(this, 'once', r);
						this._lastBlockNumber = -2;
						this._inflight = false;
					}
					get event() {
						switch (this.type) {
							case 'tx':
								return this.hash;
							case 'filter':
								return this.filter;
						}
						return this.tag;
					}
					get type() {
						return this.tag.split(':')[0];
					}
					get hash() {
						const e = this.tag.split(':');
						if (e[0] !== 'tx') {
							return null;
						}
						return e[1];
					}
					get filter() {
						const e = this.tag.split(':');
						if (e[0] !== 'filter') {
							return null;
						}
						const t = e[1];
						const r = deserializeTopics(e[2]);
						const s = {};
						if (r.length > 0) {
							s.topics = r;
						}
						if (t && t !== '*') {
							s.address = t;
						}
						return s;
					}
					pollable() {
						return this.tag.indexOf(':') >= 0 || _.indexOf(this.tag) >= 0;
					}
				}
				const E = {
					0: { symbol: 'btc', p2pkh: 0, p2sh: 5, prefix: 'bc' },
					2: { symbol: 'ltc', p2pkh: 48, p2sh: 50, prefix: 'ltc' },
					3: { symbol: 'doge', p2pkh: 30, p2sh: 22 },
					60: { symbol: 'eth', ilk: 'eth' },
					61: { symbol: 'etc', ilk: 'eth' },
					700: { symbol: 'xdai', ilk: 'eth' }
				};
				function bytes32ify(e) {
					return (0, l.hexZeroPad)(i.BigNumber.from(e).toHexString(), 32);
				}
				function base58Encode(e) {
					return o.Base58.encode(
						(0, l.concat)([e, (0, l.hexDataSlice)((0, h.sha256)((0, h.sha256)(e)), 0, 4)])
					);
				}
				const N = new RegExp('^(ipfs)://(.*)$', 'i');
				const B = [
					new RegExp('^(https)://(.*)$', 'i'),
					new RegExp('^(data):(.*)$', 'i'),
					N,
					new RegExp('^eip155:[0-9]+/(erc[0-9]+):(.*)$', 'i')
				];
				function _parseString(e, t) {
					try {
						return (0, f.toUtf8String)(_parseBytes(e, t));
					} catch (e) {}
					return null;
				}
				function _parseBytes(e, t) {
					if (e === '0x') {
						return null;
					}
					const r = i.BigNumber.from((0, l.hexDataSlice)(e, t, t + 32)).toNumber();
					const s = i.BigNumber.from((0, l.hexDataSlice)(e, r, r + 32)).toNumber();
					return (0, l.hexDataSlice)(e, r + 32, r + 32 + s);
				}
				function getIpfsLink(e) {
					if (e.match(/^ipfs:\/\/ipfs\//i)) {
						e = e.substring(12);
					} else if (e.match(/^ipfs:\/\//i)) {
						e = e.substring(7);
					} else {
						y.throwArgumentError('unsupported IPFS format', 'link', e);
					}
					return `https://gateway.ipfs.io/ipfs/${e}`;
				}
				function numPad(e) {
					const t = (0, l.arrayify)(e);
					if (t.length > 32) {
						throw new Error('internal; should not happen');
					}
					const r = new Uint8Array(32);
					r.set(t, 32 - t.length);
					return r;
				}
				function bytesPad(e) {
					if (e.length % 32 === 0) {
						return e;
					}
					const t = new Uint8Array(Math.ceil(e.length / 32) * 32);
					t.set(e);
					return t;
				}
				function encodeBytes(e) {
					const t = [];
					let r = 0;
					for (let s = 0; s < e.length; s++) {
						t.push(null);
						r += 32;
					}
					for (let s = 0; s < e.length; s++) {
						const n = (0, l.arrayify)(e[s]);
						t[s] = numPad(r);
						t.push(numPad(n.length));
						t.push(bytesPad(n));
						r += 32 + Math.ceil(n.length / 32) * 32;
					}
					return (0, l.hexConcat)(t);
				}
				class Resolver {
					constructor(e, t, r, s) {
						(0, d.defineReadOnly)(this, 'provider', e);
						(0, d.defineReadOnly)(this, 'name', r);
						(0, d.defineReadOnly)(this, 'address', e.formatter.address(t));
						(0, d.defineReadOnly)(this, '_resolvedAddress', s);
					}
					supportsWildcard() {
						if (!this._supportsEip2544) {
							this._supportsEip2544 = this.provider
								.call({
									to: this.address,
									data: '0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000'
								})
								.then((e) => i.BigNumber.from(e).eq(1))
								.catch((e) => {
									if (e.code === b.Logger.errors.CALL_EXCEPTION) {
										return false;
									}
									this._supportsEip2544 = null;
									throw e;
								});
						}
						return this._supportsEip2544;
					}
					_fetch(e, t) {
						return w(this, void 0, void 0, function* () {
							const r = {
								to: this.address,
								ccipReadEnabled: true,
								data: (0, l.hexConcat)([e, (0, c.namehash)(this.name), t || '0x'])
							};
							let s = false;
							if (yield this.supportsWildcard()) {
								s = true;
								r.data = (0, l.hexConcat)([
									'0x9061b923',
									encodeBytes([(0, c.dnsEncode)(this.name), r.data])
								]);
							}
							try {
								let e = yield this.provider.call(r);
								if ((0, l.arrayify)(e).length % 32 === 4) {
									y.throwError('resolver threw error', b.Logger.errors.CALL_EXCEPTION, {
										transaction: r,
										data: e
									});
								}
								if (s) {
									e = _parseBytes(e, 0);
								}
								return e;
							} catch (e) {
								if (e.code === b.Logger.errors.CALL_EXCEPTION) {
									return null;
								}
								throw e;
							}
						});
					}
					_fetchBytes(e, t) {
						return w(this, void 0, void 0, function* () {
							const r = yield this._fetch(e, t);
							if (r != null) {
								return _parseBytes(r, 0);
							}
							return null;
						});
					}
					_getAddress(e, t) {
						const r = E[String(e)];
						if (r == null) {
							y.throwError(`unsupported coin type: ${e}`, b.Logger.errors.UNSUPPORTED_OPERATION, {
								operation: `getAddress(${e})`
							});
						}
						if (r.ilk === 'eth') {
							return this.provider.formatter.address(t);
						}
						const s = (0, l.arrayify)(t);
						if (r.p2pkh != null) {
							const e = t.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
							if (e) {
								const t = parseInt(e[1], 16);
								if (e[2].length === t * 2 && t >= 1 && t <= 75) {
									return base58Encode((0, l.concat)([[r.p2pkh], '0x' + e[2]]));
								}
							}
						}
						if (r.p2sh != null) {
							const e = t.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
							if (e) {
								const t = parseInt(e[1], 16);
								if (e[2].length === t * 2 && t >= 1 && t <= 75) {
									return base58Encode((0, l.concat)([[r.p2sh], '0x' + e[2]]));
								}
							}
						}
						if (r.prefix != null) {
							const e = s[1];
							let t = s[0];
							if (t === 0) {
								if (e !== 20 && e !== 32) {
									t = -1;
								}
							} else {
								t = -1;
							}
							if (t >= 0 && s.length === 2 + e && e >= 1 && e <= 75) {
								const e = g().toWords(s.slice(2));
								e.unshift(t);
								return g().encode(r.prefix, e);
							}
						}
						return null;
					}
					getAddress(e) {
						return w(this, void 0, void 0, function* () {
							if (e == null) {
								e = 60;
							}
							if (e === 60) {
								try {
									const e = yield this._fetch('0x3b3b57de');
									if (e === '0x' || e === a.HashZero) {
										return null;
									}
									return this.provider.formatter.callAddress(e);
								} catch (e) {
									if (e.code === b.Logger.errors.CALL_EXCEPTION) {
										return null;
									}
									throw e;
								}
							}
							const t = yield this._fetchBytes('0xf1cb7e06', bytes32ify(e));
							if (t == null || t === '0x') {
								return null;
							}
							const r = this._getAddress(e, t);
							if (r == null) {
								y.throwError(
									`invalid or unsupported coin data`,
									b.Logger.errors.UNSUPPORTED_OPERATION,
									{ operation: `getAddress(${e})`, coinType: e, data: t }
								);
							}
							return r;
						});
					}
					getAvatar() {
						return w(this, void 0, void 0, function* () {
							const e = [{ type: 'name', content: this.name }];
							try {
								const t = yield this.getText('avatar');
								if (t == null) {
									return null;
								}
								for (let r = 0; r < B.length; r++) {
									const s = t.match(B[r]);
									if (s == null) {
										continue;
									}
									const n = s[1].toLowerCase();
									switch (n) {
										case 'https':
											e.push({ type: 'url', content: t });
											return { linkage: e, url: t };
										case 'data':
											e.push({ type: 'data', content: t });
											return { linkage: e, url: t };
										case 'ipfs':
											e.push({ type: 'ipfs', content: t });
											return { linkage: e, url: getIpfsLink(t) };
										case 'erc721':
										case 'erc1155': {
											const r = n === 'erc721' ? '0xc87b56dd' : '0x0e89341c';
											e.push({ type: n, content: t });
											const o = this._resolvedAddress || (yield this.getAddress());
											const a = (s[2] || '').split('/');
											if (a.length !== 2) {
												return null;
											}
											const c = yield this.provider.formatter.address(a[0]);
											const u = (0, l.hexZeroPad)(i.BigNumber.from(a[1]).toHexString(), 32);
											if (n === 'erc721') {
												const t = this.provider.formatter.callAddress(
													yield this.provider.call({
														to: c,
														data: (0, l.hexConcat)(['0x6352211e', u])
													})
												);
												if (o !== t) {
													return null;
												}
												e.push({ type: 'owner', content: t });
											} else if (n === 'erc1155') {
												const t = i.BigNumber.from(
													yield this.provider.call({
														to: c,
														data: (0, l.hexConcat)(['0x00fdd58e', (0, l.hexZeroPad)(o, 32), u])
													})
												);
												if (t.isZero()) {
													return null;
												}
												e.push({ type: 'balance', content: t.toString() });
											}
											const d = {
												to: this.provider.formatter.address(a[0]),
												data: (0, l.hexConcat)([r, u])
											};
											let h = _parseString(yield this.provider.call(d), 0);
											if (h == null) {
												return null;
											}
											e.push({ type: 'metadata-url-base', content: h });
											if (n === 'erc1155') {
												h = h.replace('{id}', u.substring(2));
												e.push({ type: 'metadata-url-expanded', content: h });
											}
											if (h.match(/^ipfs:/i)) {
												h = getIpfsLink(h);
											}
											e.push({ type: 'metadata-url', content: h });
											const f = yield (0, m.fetchJson)(h);
											if (!f) {
												return null;
											}
											e.push({ type: 'metadata', content: JSON.stringify(f) });
											let p = f.image;
											if (typeof p !== 'string') {
												return null;
											}
											if (p.match(/^(https:\/\/|data:)/i)) {
											} else {
												const t = p.match(N);
												if (t == null) {
													return null;
												}
												e.push({ type: 'url-ipfs', content: p });
												p = getIpfsLink(p);
											}
											e.push({ type: 'url', content: p });
											return { linkage: e, url: p };
										}
									}
								}
							} catch (e) {}
							return null;
						});
					}
					getContentHash() {
						return w(this, void 0, void 0, function* () {
							const e = yield this._fetchBytes('0xbc1c58d1');
							if (e == null || e === '0x') {
								return null;
							}
							const t = e.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
							if (t) {
								const e = parseInt(t[3], 16);
								if (t[4].length === e * 2) {
									return 'ipfs://' + o.Base58.encode('0x' + t[1]);
								}
							}
							const r = e.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
							if (r) {
								const e = parseInt(r[3], 16);
								if (r[4].length === e * 2) {
									return 'ipns://' + o.Base58.encode('0x' + r[1]);
								}
							}
							const s = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
							if (s) {
								if (s[1].length === 32 * 2) {
									return 'bzz://' + s[1];
								}
							}
							const i = e.match(/^0x90b2c605([0-9a-f]*)$/);
							if (i) {
								if (i[1].length === 34 * 2) {
									const e = { '=': '', '+': '-', '/': '_' };
									const t = (0, n.encode)('0x' + i[1]).replace(/[=+\/]/g, (t) => e[t]);
									return 'sia://' + t;
								}
							}
							return y.throwError(
								`invalid or unsupported content hash data`,
								b.Logger.errors.UNSUPPORTED_OPERATION,
								{ operation: 'getContentHash()', data: e }
							);
						});
					}
					getText(e) {
						return w(this, void 0, void 0, function* () {
							let t = (0, f.toUtf8Bytes)(e);
							t = (0, l.concat)([bytes32ify(64), bytes32ify(t.length), t]);
							if (t.length % 32 !== 0) {
								t = (0, l.concat)([t, (0, l.hexZeroPad)('0x', 32 - (e.length % 32))]);
							}
							const r = yield this._fetchBytes('0x59d1d43c', (0, l.hexlify)(t));
							if (r == null || r === '0x') {
								return null;
							}
							return (0, f.toUtf8String)(r);
						});
					}
				}
				let C = null;
				let I = 1;
				class BaseProvider extends s.Provider {
					constructor(e) {
						super();
						this._events = [];
						this._emitted = { block: -2 };
						this.disableCcipRead = false;
						this.formatter = new.target.getFormatter();
						(0, d.defineReadOnly)(this, 'anyNetwork', e === 'any');
						if (this.anyNetwork) {
							e = this.detectNetwork();
						}
						if (e instanceof Promise) {
							this._networkPromise = e;
							e.catch((e) => {});
							this._ready().catch((e) => {});
						} else {
							const t = (0, d.getStatic)(new.target, 'getNetwork')(e);
							if (t) {
								(0, d.defineReadOnly)(this, '_network', t);
								this.emit('network', t, null);
							} else {
								y.throwArgumentError('invalid network', 'network', e);
							}
						}
						this._maxInternalBlockNumber = -1024;
						this._lastBlockNumber = -2;
						this._maxFilterBlockRange = 10;
						this._pollingInterval = 4e3;
						this._fastQueryDate = 0;
					}
					_ready() {
						return w(this, void 0, void 0, function* () {
							if (this._network == null) {
								let e = null;
								if (this._networkPromise) {
									try {
										e = yield this._networkPromise;
									} catch (e) {}
								}
								if (e == null) {
									e = yield this.detectNetwork();
								}
								if (!e) {
									y.throwError('no network detected', b.Logger.errors.UNKNOWN_ERROR, {});
								}
								if (this._network == null) {
									if (this.anyNetwork) {
										this._network = e;
									} else {
										(0, d.defineReadOnly)(this, '_network', e);
									}
									this.emit('network', e, null);
								}
							}
							return this._network;
						});
					}
					get ready() {
						return (0, m.poll)(() =>
							this._ready().then(
								(e) => e,
								(e) => {
									if (e.code === b.Logger.errors.NETWORK_ERROR && e.event === 'noNetwork') {
										return undefined;
									}
									throw e;
								}
							)
						);
					}
					static getFormatter() {
						if (C == null) {
							C = new v.Formatter();
						}
						return C;
					}
					static getNetwork(e) {
						return (0, u.getNetwork)(e == null ? 'homestead' : e);
					}
					ccipReadFetch(e, t, r) {
						return w(this, void 0, void 0, function* () {
							if (this.disableCcipRead || r.length === 0) {
								return null;
							}
							const s = e.to.toLowerCase();
							const n = t.toLowerCase();
							const o = [];
							for (let e = 0; e < r.length; e++) {
								const t = r[e];
								const i = t.replace('{sender}', s).replace('{data}', n);
								const l = t.indexOf('{data}') >= 0 ? null : JSON.stringify({ data: n, sender: s });
								const a = yield (0, m.fetchJson)({ url: i, errorPassThrough: true }, l, (e, t) => {
									e.status = t.statusCode;
									return e;
								});
								if (a.data) {
									return a.data;
								}
								const c = a.message || 'unknown error';
								if (a.status >= 400 && a.status < 500) {
									return y.throwError(
										`response not found during CCIP fetch: ${c}`,
										b.Logger.errors.SERVER_ERROR,
										{ url: t, errorMessage: c }
									);
								}
								o.push(c);
							}
							return y.throwError(
								`error encountered during CCIP fetch: ${o.map((e) => JSON.stringify(e)).join(', ')}`,
								b.Logger.errors.SERVER_ERROR,
								{ urls: r, errorMessages: o }
							);
						});
					}
					_getInternalBlockNumber(e) {
						return w(this, void 0, void 0, function* () {
							yield this._ready();
							if (e > 0) {
								while (this._internalBlockNumber) {
									const t = this._internalBlockNumber;
									try {
										const r = yield t;
										if (getTime() - r.respTime <= e) {
											return r.blockNumber;
										}
										break;
									} catch (e) {
										if (this._internalBlockNumber === t) {
											break;
										}
									}
								}
							}
							const t = getTime();
							const r = (0, d.resolveProperties)({
								blockNumber: this.perform('getBlockNumber', {}),
								networkError: this.getNetwork().then(
									(e) => null,
									(e) => e
								)
							}).then(({ blockNumber: e, networkError: s }) => {
								if (s) {
									if (this._internalBlockNumber === r) {
										this._internalBlockNumber = null;
									}
									throw s;
								}
								const n = getTime();
								e = i.BigNumber.from(e).toNumber();
								if (e < this._maxInternalBlockNumber) {
									e = this._maxInternalBlockNumber;
								}
								this._maxInternalBlockNumber = e;
								this._setFastBlockNumber(e);
								return { blockNumber: e, reqTime: t, respTime: n };
							});
							this._internalBlockNumber = r;
							r.catch((e) => {
								if (this._internalBlockNumber === r) {
									this._internalBlockNumber = null;
								}
							});
							return (yield r).blockNumber;
						});
					}
					poll() {
						return w(this, void 0, void 0, function* () {
							const e = I++;
							const t = [];
							let r = null;
							try {
								r = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
							} catch (e) {
								this.emit('error', e);
								return;
							}
							this._setFastBlockNumber(r);
							this.emit('poll', e, r);
							if (r === this._lastBlockNumber) {
								this.emit('didPoll', e);
								return;
							}
							if (this._emitted.block === -2) {
								this._emitted.block = r - 1;
							}
							if (Math.abs(this._emitted.block - r) > 1e3) {
								y.warn(
									`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${r})`
								);
								this.emit(
									'error',
									y.makeError('network block skew detected', b.Logger.errors.NETWORK_ERROR, {
										blockNumber: r,
										event: 'blockSkew',
										previousBlockNumber: this._emitted.block
									})
								);
								this.emit('block', r);
							} else {
								for (let e = this._emitted.block + 1; e <= r; e++) {
									this.emit('block', e);
								}
							}
							if (this._emitted.block !== r) {
								this._emitted.block = r;
								Object.keys(this._emitted).forEach((e) => {
									if (e === 'block') {
										return;
									}
									const t = this._emitted[e];
									if (t === 'pending') {
										return;
									}
									if (r - t > 12) {
										delete this._emitted[e];
									}
								});
							}
							if (this._lastBlockNumber === -2) {
								this._lastBlockNumber = r - 1;
							}
							this._events.forEach((e) => {
								switch (e.type) {
									case 'tx': {
										const r = e.hash;
										let s = this.getTransactionReceipt(r)
											.then((e) => {
												if (!e || e.blockNumber == null) {
													return null;
												}
												this._emitted['t:' + r] = e.blockNumber;
												this.emit(r, e);
												return null;
											})
											.catch((e) => {
												this.emit('error', e);
											});
										t.push(s);
										break;
									}
									case 'filter': {
										if (!e._inflight) {
											e._inflight = true;
											if (e._lastBlockNumber === -2) {
												e._lastBlockNumber = r - 1;
											}
											const s = e.filter;
											s.fromBlock = e._lastBlockNumber + 1;
											s.toBlock = r;
											const n = s.toBlock - this._maxFilterBlockRange;
											if (n > s.fromBlock) {
												s.fromBlock = n;
											}
											if (s.fromBlock < 0) {
												s.fromBlock = 0;
											}
											const o = this.getLogs(s)
												.then((t) => {
													e._inflight = false;
													if (t.length === 0) {
														return;
													}
													t.forEach((t) => {
														if (t.blockNumber > e._lastBlockNumber) {
															e._lastBlockNumber = t.blockNumber;
														}
														this._emitted['b:' + t.blockHash] = t.blockNumber;
														this._emitted['t:' + t.transactionHash] = t.blockNumber;
														this.emit(s, t);
													});
												})
												.catch((t) => {
													this.emit('error', t);
													e._inflight = false;
												});
											t.push(o);
										}
										break;
									}
								}
							});
							this._lastBlockNumber = r;
							Promise.all(t)
								.then(() => {
									this.emit('didPoll', e);
								})
								.catch((e) => {
									this.emit('error', e);
								});
							return;
						});
					}
					resetEventsBlock(e) {
						this._lastBlockNumber = e - 1;
						if (this.polling) {
							this.poll();
						}
					}
					get network() {
						return this._network;
					}
					detectNetwork() {
						return w(this, void 0, void 0, function* () {
							return y.throwError(
								'provider does not support network detection',
								b.Logger.errors.UNSUPPORTED_OPERATION,
								{ operation: 'provider.detectNetwork' }
							);
						});
					}
					getNetwork() {
						return w(this, void 0, void 0, function* () {
							const e = yield this._ready();
							const t = yield this.detectNetwork();
							if (e.chainId !== t.chainId) {
								if (this.anyNetwork) {
									this._network = t;
									this._lastBlockNumber = -2;
									this._fastBlockNumber = null;
									this._fastBlockNumberPromise = null;
									this._fastQueryDate = 0;
									this._emitted.block = -2;
									this._maxInternalBlockNumber = -1024;
									this._internalBlockNumber = null;
									this.emit('network', t, e);
									yield stall(0);
									return this._network;
								}
								const r = y.makeError('underlying network changed', b.Logger.errors.NETWORK_ERROR, {
									event: 'changed',
									network: e,
									detectedNetwork: t
								});
								this.emit('error', r);
								throw r;
							}
							return e;
						});
					}
					get blockNumber() {
						this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(
							(e) => {
								this._setFastBlockNumber(e);
							},
							(e) => {}
						);
						return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
					}
					get polling() {
						return this._poller != null;
					}
					set polling(e) {
						if (e && !this._poller) {
							this._poller = setInterval(() => {
								this.poll();
							}, this.pollingInterval);
							if (!this._bootstrapPoll) {
								this._bootstrapPoll = setTimeout(() => {
									this.poll();
									this._bootstrapPoll = setTimeout(() => {
										if (!this._poller) {
											this.poll();
										}
										this._bootstrapPoll = null;
									}, this.pollingInterval);
								}, 0);
							}
						} else if (!e && this._poller) {
							clearInterval(this._poller);
							this._poller = null;
						}
					}
					get pollingInterval() {
						return this._pollingInterval;
					}
					set pollingInterval(e) {
						if (typeof e !== 'number' || e <= 0 || parseInt(String(e)) != e) {
							throw new Error('invalid polling interval');
						}
						this._pollingInterval = e;
						if (this._poller) {
							clearInterval(this._poller);
							this._poller = setInterval(() => {
								this.poll();
							}, this._pollingInterval);
						}
					}
					_getFastBlockNumber() {
						const e = getTime();
						if (e - this._fastQueryDate > 2 * this._pollingInterval) {
							this._fastQueryDate = e;
							this._fastBlockNumberPromise = this.getBlockNumber().then((e) => {
								if (this._fastBlockNumber == null || e > this._fastBlockNumber) {
									this._fastBlockNumber = e;
								}
								return this._fastBlockNumber;
							});
						}
						return this._fastBlockNumberPromise;
					}
					_setFastBlockNumber(e) {
						if (this._fastBlockNumber != null && e < this._fastBlockNumber) {
							return;
						}
						this._fastQueryDate = getTime();
						if (this._fastBlockNumber == null || e > this._fastBlockNumber) {
							this._fastBlockNumber = e;
							this._fastBlockNumberPromise = Promise.resolve(e);
						}
					}
					waitForTransaction(e, t, r) {
						return w(this, void 0, void 0, function* () {
							return this._waitForTransaction(e, t == null ? 1 : t, r || 0, null);
						});
					}
					_waitForTransaction(e, t, r, s) {
						return w(this, void 0, void 0, function* () {
							const n = yield this.getTransactionReceipt(e);
							if ((n ? n.confirmations : 0) >= t) {
								return n;
							}
							return new Promise((n, o) => {
								const i = [];
								let l = false;
								const alreadyDone = function () {
									if (l) {
										return true;
									}
									l = true;
									i.forEach((e) => {
										e();
									});
									return false;
								};
								const minedHandler = (e) => {
									if (e.confirmations < t) {
										return;
									}
									if (alreadyDone()) {
										return;
									}
									n(e);
								};
								this.on(e, minedHandler);
								i.push(() => {
									this.removeListener(e, minedHandler);
								});
								if (s) {
									let r = s.startBlock;
									let n = null;
									const replaceHandler = (i) =>
										w(this, void 0, void 0, function* () {
											if (l) {
												return;
											}
											yield stall(1e3);
											this.getTransactionCount(s.from).then(
												(a) =>
													w(this, void 0, void 0, function* () {
														if (l) {
															return;
														}
														if (a <= s.nonce) {
															r = i;
														} else {
															{
																const t = yield this.getTransaction(e);
																if (t && t.blockNumber != null) {
																	return;
																}
															}
															if (n == null) {
																n = r - 3;
																if (n < s.startBlock) {
																	n = s.startBlock;
																}
															}
															while (n <= i) {
																if (l) {
																	return;
																}
																const r = yield this.getBlockWithTransactions(n);
																for (let n = 0; n < r.transactions.length; n++) {
																	const i = r.transactions[n];
																	if (i.hash === e) {
																		return;
																	}
																	if (i.from === s.from && i.nonce === s.nonce) {
																		if (l) {
																			return;
																		}
																		const r = yield this.waitForTransaction(i.hash, t);
																		if (alreadyDone()) {
																			return;
																		}
																		let n = 'replaced';
																		if (i.data === s.data && i.to === s.to && i.value.eq(s.value)) {
																			n = 'repriced';
																		} else if (
																			i.data === '0x' &&
																			i.from === i.to &&
																			i.value.isZero()
																		) {
																			n = 'cancelled';
																		}
																		o(
																			y.makeError(
																				'transaction was replaced',
																				b.Logger.errors.TRANSACTION_REPLACED,
																				{
																					cancelled: n === 'replaced' || n === 'cancelled',
																					reason: n,
																					replacement: this._wrapTransaction(i),
																					hash: e,
																					receipt: r
																				}
																			)
																		);
																		return;
																	}
																}
																n++;
															}
														}
														if (l) {
															return;
														}
														this.once('block', replaceHandler);
													}),
												(e) => {
													if (l) {
														return;
													}
													this.once('block', replaceHandler);
												}
											);
										});
									if (l) {
										return;
									}
									this.once('block', replaceHandler);
									i.push(() => {
										this.removeListener('block', replaceHandler);
									});
								}
								if (typeof r === 'number' && r > 0) {
									const e = setTimeout(() => {
										if (alreadyDone()) {
											return;
										}
										o(y.makeError('timeout exceeded', b.Logger.errors.TIMEOUT, { timeout: r }));
									}, r);
									if (e.unref) {
										e.unref();
									}
									i.push(() => {
										clearTimeout(e);
									});
								}
							});
						});
					}
					getBlockNumber() {
						return w(this, void 0, void 0, function* () {
							return this._getInternalBlockNumber(0);
						});
					}
					getGasPrice() {
						return w(this, void 0, void 0, function* () {
							yield this.getNetwork();
							const e = yield this.perform('getGasPrice', {});
							try {
								return i.BigNumber.from(e);
							} catch (t) {
								return y.throwError('bad result from backend', b.Logger.errors.SERVER_ERROR, {
									method: 'getGasPrice',
									result: e,
									error: t
								});
							}
						});
					}
					getBalance(e, t) {
						return w(this, void 0, void 0, function* () {
							yield this.getNetwork();
							const r = yield (0, d.resolveProperties)({
								address: this._getAddress(e),
								blockTag: this._getBlockTag(t)
							});
							const s = yield this.perform('getBalance', r);
							try {
								return i.BigNumber.from(s);
							} catch (e) {
								return y.throwError('bad result from backend', b.Logger.errors.SERVER_ERROR, {
									method: 'getBalance',
									params: r,
									result: s,
									error: e
								});
							}
						});
					}
					getTransactionCount(e, t) {
						return w(this, void 0, void 0, function* () {
							yield this.getNetwork();
							const r = yield (0, d.resolveProperties)({
								address: this._getAddress(e),
								blockTag: this._getBlockTag(t)
							});
							const s = yield this.perform('getTransactionCount', r);
							try {
								return i.BigNumber.from(s).toNumber();
							} catch (e) {
								return y.throwError('bad result from backend', b.Logger.errors.SERVER_ERROR, {
									method: 'getTransactionCount',
									params: r,
									result: s,
									error: e
								});
							}
						});
					}
					getCode(e, t) {
						return w(this, void 0, void 0, function* () {
							yield this.getNetwork();
							const r = yield (0, d.resolveProperties)({
								address: this._getAddress(e),
								blockTag: this._getBlockTag(t)
							});
							const s = yield this.perform('getCode', r);
							try {
								return (0, l.hexlify)(s);
							} catch (e) {
								return y.throwError('bad result from backend', b.Logger.errors.SERVER_ERROR, {
									method: 'getCode',
									params: r,
									result: s,
									error: e
								});
							}
						});
					}
					getStorageAt(e, t, r) {
						return w(this, void 0, void 0, function* () {
							yield this.getNetwork();
							const s = yield (0, d.resolveProperties)({
								address: this._getAddress(e),
								blockTag: this._getBlockTag(r),
								position: Promise.resolve(t).then((e) => (0, l.hexValue)(e))
							});
							const n = yield this.perform('getStorageAt', s);
							try {
								return (0, l.hexlify)(n);
							} catch (e) {
								return y.throwError('bad result from backend', b.Logger.errors.SERVER_ERROR, {
									method: 'getStorageAt',
									params: s,
									result: n,
									error: e
								});
							}
						});
					}
					_wrapTransaction(e, t, r) {
						if (t != null && (0, l.hexDataLength)(t) !== 32) {
							throw new Error('invalid response - sendTransaction');
						}
						const s = e;
						if (t != null && e.hash !== t) {
							y.throwError(
								'Transaction hash mismatch from Provider.sendTransaction.',
								b.Logger.errors.UNKNOWN_ERROR,
								{ expectedHash: e.hash, returnedHash: t }
							);
						}
						s.wait = (t, s) =>
							w(this, void 0, void 0, function* () {
								if (t == null) {
									t = 1;
								}
								if (s == null) {
									s = 0;
								}
								let n = undefined;
								if (t !== 0 && r != null) {
									n = {
										data: e.data,
										from: e.from,
										nonce: e.nonce,
										to: e.to,
										value: e.value,
										startBlock: r
									};
								}
								const o = yield this._waitForTransaction(e.hash, t, s, n);
								if (o == null && t === 0) {
									return null;
								}
								this._emitted['t:' + e.hash] = o.blockNumber;
								if (o.status === 0) {
									y.throwError('transaction failed', b.Logger.errors.CALL_EXCEPTION, {
										transactionHash: e.hash,
										transaction: e,
										receipt: o
									});
								}
								return o;
							});
						return s;
					}
					sendTransaction(e) {
						return w(this, void 0, void 0, function* () {
							yield this.getNetwork();
							const t = yield Promise.resolve(e).then((e) => (0, l.hexlify)(e));
							const r = this.formatter.transaction(e);
							if (r.confirmations == null) {
								r.confirmations = 0;
							}
							const s = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
							try {
								const e = yield this.perform('sendTransaction', { signedTransaction: t });
								return this._wrapTransaction(r, e, s);
							} catch (e) {
								e.transaction = r;
								e.transactionHash = r.hash;
								throw e;
							}
						});
					}
					_getTransactionRequest(e) {
						return w(this, void 0, void 0, function* () {
							const t = yield e;
							const r = {};
							['from', 'to'].forEach((e) => {
								if (t[e] == null) {
									return;
								}
								r[e] = Promise.resolve(t[e]).then((e) => (e ? this._getAddress(e) : null));
							});
							['gasLimit', 'gasPrice', 'maxFeePerGas', 'maxPriorityFeePerGas', 'value'].forEach(
								(e) => {
									if (t[e] == null) {
										return;
									}
									r[e] = Promise.resolve(t[e]).then((e) => (e ? i.BigNumber.from(e) : null));
								}
							);
							['type'].forEach((e) => {
								if (t[e] == null) {
									return;
								}
								r[e] = Promise.resolve(t[e]).then((e) => (e != null ? e : null));
							});
							if (t.accessList) {
								r.accessList = this.formatter.accessList(t.accessList);
							}
							['data'].forEach((e) => {
								if (t[e] == null) {
									return;
								}
								r[e] = Promise.resolve(t[e]).then((e) => (e ? (0, l.hexlify)(e) : null));
							});
							return this.formatter.transactionRequest(yield (0, d.resolveProperties)(r));
						});
					}
					_getFilter(e) {
						return w(this, void 0, void 0, function* () {
							e = yield e;
							const t = {};
							if (e.address != null) {
								t.address = this._getAddress(e.address);
							}
							['blockHash', 'topics'].forEach((r) => {
								if (e[r] == null) {
									return;
								}
								t[r] = e[r];
							});
							['fromBlock', 'toBlock'].forEach((r) => {
								if (e[r] == null) {
									return;
								}
								t[r] = this._getBlockTag(e[r]);
							});
							return this.formatter.filter(yield (0, d.resolveProperties)(t));
						});
					}
					_call(e, t, r) {
						return w(this, void 0, void 0, function* () {
							if (r >= k) {
								y.throwError(
									'CCIP read exceeded maximum redirections',
									b.Logger.errors.SERVER_ERROR,
									{ redirects: r, transaction: e }
								);
							}
							const s = e.to;
							const n = yield this.perform('call', { transaction: e, blockTag: t });
							if (
								r >= 0 &&
								t === 'latest' &&
								s != null &&
								n.substring(0, 10) === '0x556f1830' &&
								(0, l.hexDataLength)(n) % 32 === 4
							) {
								try {
									const o = (0, l.hexDataSlice)(n, 4);
									const a = (0, l.hexDataSlice)(o, 0, 32);
									if (!i.BigNumber.from(a).eq(s)) {
										y.throwError('CCIP Read sender did not match', b.Logger.errors.CALL_EXCEPTION, {
											name: 'OffchainLookup',
											signature: 'OffchainLookup(address,string[],bytes,bytes4,bytes)',
											transaction: e,
											data: n
										});
									}
									const c = [];
									const u = i.BigNumber.from((0, l.hexDataSlice)(o, 32, 64)).toNumber();
									const d = i.BigNumber.from((0, l.hexDataSlice)(o, u, u + 32)).toNumber();
									const h = (0, l.hexDataSlice)(o, u + 32);
									for (let t = 0; t < d; t++) {
										const r = _parseString(h, t * 32);
										if (r == null) {
											y.throwError(
												'CCIP Read contained corrupt URL string',
												b.Logger.errors.CALL_EXCEPTION,
												{
													name: 'OffchainLookup',
													signature: 'OffchainLookup(address,string[],bytes,bytes4,bytes)',
													transaction: e,
													data: n
												}
											);
										}
										c.push(r);
									}
									const f = _parseBytes(o, 64);
									if (!i.BigNumber.from((0, l.hexDataSlice)(o, 100, 128)).isZero()) {
										y.throwError(
											'CCIP Read callback selector included junk',
											b.Logger.errors.CALL_EXCEPTION,
											{
												name: 'OffchainLookup',
												signature: 'OffchainLookup(address,string[],bytes,bytes4,bytes)',
												transaction: e,
												data: n
											}
										);
									}
									const m = (0, l.hexDataSlice)(o, 96, 100);
									const p = _parseBytes(o, 128);
									const g = yield this.ccipReadFetch(e, f, c);
									if (g == null) {
										y.throwError(
											'CCIP Read disabled or provided no URLs',
											b.Logger.errors.CALL_EXCEPTION,
											{
												name: 'OffchainLookup',
												signature: 'OffchainLookup(address,string[],bytes,bytes4,bytes)',
												transaction: e,
												data: n
											}
										);
									}
									const A = { to: s, data: (0, l.hexConcat)([m, encodeBytes([g, p])]) };
									return this._call(A, t, r + 1);
								} catch (e) {
									if (e.code === b.Logger.errors.SERVER_ERROR) {
										throw e;
									}
								}
							}
							try {
								return (0, l.hexlify)(n);
							} catch (r) {
								return y.throwError('bad result from backend', b.Logger.errors.SERVER_ERROR, {
									method: 'call',
									params: { transaction: e, blockTag: t },
									result: n,
									error: r
								});
							}
						});
					}
					call(e, t) {
						return w(this, void 0, void 0, function* () {
							yield this.getNetwork();
							const r = yield (0, d.resolveProperties)({
								transaction: this._getTransactionRequest(e),
								blockTag: this._getBlockTag(t),
								ccipReadEnabled: Promise.resolve(e.ccipReadEnabled)
							});
							return this._call(r.transaction, r.blockTag, r.ccipReadEnabled ? 0 : -1);
						});
					}
					estimateGas(e) {
						return w(this, void 0, void 0, function* () {
							yield this.getNetwork();
							const t = yield (0, d.resolveProperties)({
								transaction: this._getTransactionRequest(e)
							});
							const r = yield this.perform('estimateGas', t);
							try {
								return i.BigNumber.from(r);
							} catch (e) {
								return y.throwError('bad result from backend', b.Logger.errors.SERVER_ERROR, {
									method: 'estimateGas',
									params: t,
									result: r,
									error: e
								});
							}
						});
					}
					_getAddress(e) {
						return w(this, void 0, void 0, function* () {
							e = yield e;
							if (typeof e !== 'string') {
								y.throwArgumentError('invalid address or ENS name', 'name', e);
							}
							const t = yield this.resolveName(e);
							if (t == null) {
								y.throwError('ENS name not configured', b.Logger.errors.UNSUPPORTED_OPERATION, {
									operation: `resolveName(${JSON.stringify(e)})`
								});
							}
							return t;
						});
					}
					_getBlock(e, t) {
						return w(this, void 0, void 0, function* () {
							yield this.getNetwork();
							e = yield e;
							let r = -128;
							const s = { includeTransactions: !!t };
							if ((0, l.isHexString)(e, 32)) {
								s.blockHash = e;
							} else {
								try {
									s.blockTag = yield this._getBlockTag(e);
									if ((0, l.isHexString)(s.blockTag)) {
										r = parseInt(s.blockTag.substring(2), 16);
									}
								} catch (t) {
									y.throwArgumentError('invalid block hash or block tag', 'blockHashOrBlockTag', e);
								}
							}
							return (0, m.poll)(
								() =>
									w(this, void 0, void 0, function* () {
										const e = yield this.perform('getBlock', s);
										if (e == null) {
											if (s.blockHash != null) {
												if (this._emitted['b:' + s.blockHash] == null) {
													return null;
												}
											}
											if (s.blockTag != null) {
												if (r > this._emitted.block) {
													return null;
												}
											}
											return undefined;
										}
										if (t) {
											let t = null;
											for (let r = 0; r < e.transactions.length; r++) {
												const s = e.transactions[r];
												if (s.blockNumber == null) {
													s.confirmations = 0;
												} else if (s.confirmations == null) {
													if (t == null) {
														t = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
													}
													let e = t - s.blockNumber + 1;
													if (e <= 0) {
														e = 1;
													}
													s.confirmations = e;
												}
											}
											const r = this.formatter.blockWithTransactions(e);
											r.transactions = r.transactions.map((e) => this._wrapTransaction(e));
											return r;
										}
										return this.formatter.block(e);
									}),
								{ oncePoll: this }
							);
						});
					}
					getBlock(e) {
						return this._getBlock(e, false);
					}
					getBlockWithTransactions(e) {
						return this._getBlock(e, true);
					}
					getTransaction(e) {
						return w(this, void 0, void 0, function* () {
							yield this.getNetwork();
							e = yield e;
							const t = { transactionHash: this.formatter.hash(e, true) };
							return (0, m.poll)(
								() =>
									w(this, void 0, void 0, function* () {
										const r = yield this.perform('getTransaction', t);
										if (r == null) {
											if (this._emitted['t:' + e] == null) {
												return null;
											}
											return undefined;
										}
										const s = this.formatter.transactionResponse(r);
										if (s.blockNumber == null) {
											s.confirmations = 0;
										} else if (s.confirmations == null) {
											const e = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
											let t = e - s.blockNumber + 1;
											if (t <= 0) {
												t = 1;
											}
											s.confirmations = t;
										}
										return this._wrapTransaction(s);
									}),
								{ oncePoll: this }
							);
						});
					}
					getTransactionReceipt(e) {
						return w(this, void 0, void 0, function* () {
							yield this.getNetwork();
							e = yield e;
							const t = { transactionHash: this.formatter.hash(e, true) };
							return (0, m.poll)(
								() =>
									w(this, void 0, void 0, function* () {
										const r = yield this.perform('getTransactionReceipt', t);
										if (r == null) {
											if (this._emitted['t:' + e] == null) {
												return null;
											}
											return undefined;
										}
										if (r.blockHash == null) {
											return undefined;
										}
										const s = this.formatter.receipt(r);
										if (s.blockNumber == null) {
											s.confirmations = 0;
										} else if (s.confirmations == null) {
											const e = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
											let t = e - s.blockNumber + 1;
											if (t <= 0) {
												t = 1;
											}
											s.confirmations = t;
										}
										return s;
									}),
								{ oncePoll: this }
							);
						});
					}
					getLogs(e) {
						return w(this, void 0, void 0, function* () {
							yield this.getNetwork();
							const t = yield (0, d.resolveProperties)({ filter: this._getFilter(e) });
							const r = yield this.perform('getLogs', t);
							r.forEach((e) => {
								if (e.removed == null) {
									e.removed = false;
								}
							});
							return v.Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(r);
						});
					}
					getEtherPrice() {
						return w(this, void 0, void 0, function* () {
							yield this.getNetwork();
							return this.perform('getEtherPrice', {});
						});
					}
					_getBlockTag(e) {
						return w(this, void 0, void 0, function* () {
							e = yield e;
							if (typeof e === 'number' && e < 0) {
								if (e % 1) {
									y.throwArgumentError('invalid BlockTag', 'blockTag', e);
								}
								let t = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
								t += e;
								if (t < 0) {
									t = 0;
								}
								return this.formatter.blockTag(t);
							}
							return this.formatter.blockTag(e);
						});
					}
					getResolver(e) {
						return w(this, void 0, void 0, function* () {
							let t = e;
							while (true) {
								if (t === '' || t === '.') {
									return null;
								}
								if (e !== 'eth' && t === 'eth') {
									return null;
								}
								const r = yield this._getResolver(t, 'getResolver');
								if (r != null) {
									const s = new Resolver(this, r, e);
									if (t !== e && !(yield s.supportsWildcard())) {
										return null;
									}
									return s;
								}
								t = t.split('.').slice(1).join('.');
							}
						});
					}
					_getResolver(e, t) {
						return w(this, void 0, void 0, function* () {
							if (t == null) {
								t = 'ENS';
							}
							const r = yield this.getNetwork();
							if (!r.ensAddress) {
								y.throwError(
									'network does not support ENS',
									b.Logger.errors.UNSUPPORTED_OPERATION,
									{ operation: t, network: r.name }
								);
							}
							try {
								const t = yield this.call({
									to: r.ensAddress,
									data: '0x0178b8bf' + (0, c.namehash)(e).substring(2)
								});
								return this.formatter.callAddress(t);
							} catch (e) {}
							return null;
						});
					}
					resolveName(e) {
						return w(this, void 0, void 0, function* () {
							e = yield e;
							try {
								return Promise.resolve(this.formatter.address(e));
							} catch (t) {
								if ((0, l.isHexString)(e)) {
									throw t;
								}
							}
							if (typeof e !== 'string') {
								y.throwArgumentError('invalid ENS name', 'name', e);
							}
							const t = yield this.getResolver(e);
							if (!t) {
								return null;
							}
							return yield t.getAddress();
						});
					}
					lookupAddress(e) {
						return w(this, void 0, void 0, function* () {
							e = yield e;
							e = this.formatter.address(e);
							const t = e.substring(2).toLowerCase() + '.addr.reverse';
							const r = yield this._getResolver(t, 'lookupAddress');
							if (r == null) {
								return null;
							}
							const s = _parseString(
								yield this.call({ to: r, data: '0x691f3431' + (0, c.namehash)(t).substring(2) }),
								0
							);
							const n = yield this.resolveName(s);
							if (n != e) {
								return null;
							}
							return s;
						});
					}
					getAvatar(e) {
						return w(this, void 0, void 0, function* () {
							let t = null;
							if ((0, l.isHexString)(e)) {
								const r = this.formatter.address(e);
								const s = r.substring(2).toLowerCase() + '.addr.reverse';
								const n = yield this._getResolver(s, 'getAvatar');
								if (!n) {
									return null;
								}
								t = new Resolver(this, n, s);
								try {
									const e = yield t.getAvatar();
									if (e) {
										return e.url;
									}
								} catch (e) {
									if (e.code !== b.Logger.errors.CALL_EXCEPTION) {
										throw e;
									}
								}
								try {
									const e = _parseString(
										yield this.call({
											to: n,
											data: '0x691f3431' + (0, c.namehash)(s).substring(2)
										}),
										0
									);
									t = yield this.getResolver(e);
								} catch (e) {
									if (e.code !== b.Logger.errors.CALL_EXCEPTION) {
										throw e;
									}
									return null;
								}
							} else {
								t = yield this.getResolver(e);
								if (!t) {
									return null;
								}
							}
							const r = yield t.getAvatar();
							if (r == null) {
								return null;
							}
							return r.url;
						});
					}
					perform(e, t) {
						return y.throwError(e + ' not implemented', b.Logger.errors.NOT_IMPLEMENTED, {
							operation: e
						});
					}
					_startEvent(e) {
						this.polling = this._events.filter((e) => e.pollable()).length > 0;
					}
					_stopEvent(e) {
						this.polling = this._events.filter((e) => e.pollable()).length > 0;
					}
					_addEventListener(e, t, r) {
						const s = new Event(getEventTag(e), t, r);
						this._events.push(s);
						this._startEvent(s);
						return this;
					}
					on(e, t) {
						return this._addEventListener(e, t, false);
					}
					once(e, t) {
						return this._addEventListener(e, t, true);
					}
					emit(e, ...t) {
						let r = false;
						let s = [];
						let n = getEventTag(e);
						this._events = this._events.filter((e) => {
							if (e.tag !== n) {
								return true;
							}
							setTimeout(() => {
								e.listener.apply(this, t);
							}, 0);
							r = true;
							if (e.once) {
								s.push(e);
								return false;
							}
							return true;
						});
						s.forEach((e) => {
							this._stopEvent(e);
						});
						return r;
					}
					listenerCount(e) {
						if (!e) {
							return this._events.length;
						}
						let t = getEventTag(e);
						return this._events.filter((e) => e.tag === t).length;
					}
					listeners(e) {
						if (e == null) {
							return this._events.map((e) => e.listener);
						}
						let t = getEventTag(e);
						return this._events.filter((e) => e.tag === t).map((e) => e.listener);
					}
					off(e, t) {
						if (t == null) {
							return this.removeAllListeners(e);
						}
						const r = [];
						let s = false;
						let n = getEventTag(e);
						this._events = this._events.filter((e) => {
							if (e.tag !== n || e.listener != t) {
								return true;
							}
							if (s) {
								return true;
							}
							s = true;
							r.push(e);
							return false;
						});
						r.forEach((e) => {
							this._stopEvent(e);
						});
						return this;
					}
					removeAllListeners(e) {
						let t = [];
						if (e == null) {
							t = this._events;
							this._events = [];
						} else {
							const r = getEventTag(e);
							this._events = this._events.filter((e) => {
								if (e.tag !== r) {
									return true;
								}
								t.push(e);
								return false;
							});
						}
						t.forEach((e) => {
							this._stopEvent(e);
						});
						return this;
					}
				}
			},
		'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/formatter.js':
			(e, t, r) => {
				'use strict';
				r.r(t);
				r.d(t, {
					Formatter: () => Formatter,
					isCommunityResourcable: () => isCommunityResourcable,
					isCommunityResource: () => isCommunityResource,
					showThrottleMessage: () => showThrottleMessage
				});
				var s = r(
					'../../node_modules/.pnpm/@ethersproject+address@5.7.0/node_modules/@ethersproject/address/lib.esm/index.js'
				);
				var n = r(
					'../../node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js'
				);
				var o = r(
					'../../node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/index.js'
				);
				var i = r(
					'../../node_modules/.pnpm/@ethersproject+constants@5.7.0/node_modules/@ethersproject/constants/lib.esm/addresses.js'
				);
				var l = r(
					'../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/index.js'
				);
				var a = r(
					'../../node_modules/.pnpm/@ethersproject+transactions@5.7.0/node_modules/@ethersproject/transactions/lib.esm/index.js'
				);
				var c = r(
					'../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js'
				);
				var u = r(
					'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/_version.js'
				);
				const d = new c.Logger(u.version);
				class Formatter {
					constructor() {
						this.formats = this.getDefaultFormats();
					}
					getDefaultFormats() {
						const e = {};
						const t = this.address.bind(this);
						const r = this.bigNumber.bind(this);
						const s = this.blockTag.bind(this);
						const n = this.data.bind(this);
						const o = this.hash.bind(this);
						const i = this.hex.bind(this);
						const a = this.number.bind(this);
						const c = this.type.bind(this);
						const strictData = (e) => this.data(e, true);
						e.transaction = {
							hash: o,
							type: c,
							accessList: Formatter.allowNull(this.accessList.bind(this), null),
							blockHash: Formatter.allowNull(o, null),
							blockNumber: Formatter.allowNull(a, null),
							transactionIndex: Formatter.allowNull(a, null),
							confirmations: Formatter.allowNull(a, null),
							from: t,
							gasPrice: Formatter.allowNull(r),
							maxPriorityFeePerGas: Formatter.allowNull(r),
							maxFeePerGas: Formatter.allowNull(r),
							gasLimit: r,
							to: Formatter.allowNull(t, null),
							value: r,
							nonce: a,
							data: n,
							r: Formatter.allowNull(this.uint256),
							s: Formatter.allowNull(this.uint256),
							v: Formatter.allowNull(a),
							creates: Formatter.allowNull(t, null),
							raw: Formatter.allowNull(n)
						};
						e.transactionRequest = {
							from: Formatter.allowNull(t),
							nonce: Formatter.allowNull(a),
							gasLimit: Formatter.allowNull(r),
							gasPrice: Formatter.allowNull(r),
							maxPriorityFeePerGas: Formatter.allowNull(r),
							maxFeePerGas: Formatter.allowNull(r),
							to: Formatter.allowNull(t),
							value: Formatter.allowNull(r),
							data: Formatter.allowNull(strictData),
							type: Formatter.allowNull(a),
							accessList: Formatter.allowNull(this.accessList.bind(this), null)
						};
						e.receiptLog = {
							transactionIndex: a,
							blockNumber: a,
							transactionHash: o,
							address: t,
							topics: Formatter.arrayOf(o),
							data: n,
							logIndex: a,
							blockHash: o
						};
						e.receipt = {
							to: Formatter.allowNull(this.address, null),
							from: Formatter.allowNull(this.address, null),
							contractAddress: Formatter.allowNull(t, null),
							transactionIndex: a,
							root: Formatter.allowNull(i),
							gasUsed: r,
							logsBloom: Formatter.allowNull(n),
							blockHash: o,
							transactionHash: o,
							logs: Formatter.arrayOf(this.receiptLog.bind(this)),
							blockNumber: a,
							confirmations: Formatter.allowNull(a, null),
							cumulativeGasUsed: r,
							effectiveGasPrice: Formatter.allowNull(r),
							status: Formatter.allowNull(a),
							type: c
						};
						e.block = {
							hash: Formatter.allowNull(o),
							parentHash: o,
							number: a,
							timestamp: a,
							nonce: Formatter.allowNull(i),
							difficulty: this.difficulty.bind(this),
							gasLimit: r,
							gasUsed: r,
							miner: Formatter.allowNull(t),
							extraData: n,
							transactions: Formatter.allowNull(Formatter.arrayOf(o)),
							baseFeePerGas: Formatter.allowNull(r)
						};
						e.blockWithTransactions = (0, l.shallowCopy)(e.block);
						e.blockWithTransactions.transactions = Formatter.allowNull(
							Formatter.arrayOf(this.transactionResponse.bind(this))
						);
						e.filter = {
							fromBlock: Formatter.allowNull(s, undefined),
							toBlock: Formatter.allowNull(s, undefined),
							blockHash: Formatter.allowNull(o, undefined),
							address: Formatter.allowNull(t, undefined),
							topics: Formatter.allowNull(this.topics.bind(this), undefined)
						};
						e.filterLog = {
							blockNumber: Formatter.allowNull(a),
							blockHash: Formatter.allowNull(o),
							transactionIndex: a,
							removed: Formatter.allowNull(this.boolean.bind(this)),
							address: t,
							data: Formatter.allowFalsish(n, '0x'),
							topics: Formatter.arrayOf(o),
							transactionHash: o,
							logIndex: a
						};
						return e;
					}
					accessList(e) {
						return (0, a.accessListify)(e || []);
					}
					number(e) {
						if (e === '0x') {
							return 0;
						}
						return n.BigNumber.from(e).toNumber();
					}
					type(e) {
						if (e === '0x' || e == null) {
							return 0;
						}
						return n.BigNumber.from(e).toNumber();
					}
					bigNumber(e) {
						return n.BigNumber.from(e);
					}
					boolean(e) {
						if (typeof e === 'boolean') {
							return e;
						}
						if (typeof e === 'string') {
							e = e.toLowerCase();
							if (e === 'true') {
								return true;
							}
							if (e === 'false') {
								return false;
							}
						}
						throw new Error('invalid boolean - ' + e);
					}
					hex(e, t) {
						if (typeof e === 'string') {
							if (!t && e.substring(0, 2) !== '0x') {
								e = '0x' + e;
							}
							if ((0, o.isHexString)(e)) {
								return e.toLowerCase();
							}
						}
						return d.throwArgumentError('invalid hash', 'value', e);
					}
					data(e, t) {
						const r = this.hex(e, t);
						if (r.length % 2 !== 0) {
							throw new Error('invalid data; odd-length - ' + e);
						}
						return r;
					}
					address(e) {
						return (0, s.getAddress)(e);
					}
					callAddress(e) {
						if (!(0, o.isHexString)(e, 32)) {
							return null;
						}
						const t = (0, s.getAddress)((0, o.hexDataSlice)(e, 12));
						return t === i.AddressZero ? null : t;
					}
					contractAddress(e) {
						return (0, s.getContractAddress)(e);
					}
					blockTag(e) {
						if (e == null) {
							return 'latest';
						}
						if (e === 'earliest') {
							return '0x0';
						}
						switch (e) {
							case 'earliest':
								return '0x0';
							case 'latest':
							case 'pending':
							case 'safe':
							case 'finalized':
								return e;
						}
						if (typeof e === 'number' || (0, o.isHexString)(e)) {
							return (0, o.hexValue)(e);
						}
						throw new Error('invalid blockTag');
					}
					hash(e, t) {
						const r = this.hex(e, t);
						if ((0, o.hexDataLength)(r) !== 32) {
							return d.throwArgumentError('invalid hash', 'value', e);
						}
						return r;
					}
					difficulty(e) {
						if (e == null) {
							return null;
						}
						const t = n.BigNumber.from(e);
						try {
							return t.toNumber();
						} catch (e) {}
						return null;
					}
					uint256(e) {
						if (!(0, o.isHexString)(e)) {
							throw new Error('invalid uint256');
						}
						return (0, o.hexZeroPad)(e, 32);
					}
					_block(e, t) {
						if (e.author != null && e.miner == null) {
							e.miner = e.author;
						}
						const r = e._difficulty != null ? e._difficulty : e.difficulty;
						const s = Formatter.check(t, e);
						s._difficulty = r == null ? null : n.BigNumber.from(r);
						return s;
					}
					block(e) {
						return this._block(e, this.formats.block);
					}
					blockWithTransactions(e) {
						return this._block(e, this.formats.blockWithTransactions);
					}
					transactionRequest(e) {
						return Formatter.check(this.formats.transactionRequest, e);
					}
					transactionResponse(e) {
						if (e.gas != null && e.gasLimit == null) {
							e.gasLimit = e.gas;
						}
						if (e.to && n.BigNumber.from(e.to).isZero()) {
							e.to = '0x0000000000000000000000000000000000000000';
						}
						if (e.input != null && e.data == null) {
							e.data = e.input;
						}
						if (e.to == null && e.creates == null) {
							e.creates = this.contractAddress(e);
						}
						if ((e.type === 1 || e.type === 2) && e.accessList == null) {
							e.accessList = [];
						}
						const t = Formatter.check(this.formats.transaction, e);
						if (e.chainId != null) {
							let r = e.chainId;
							if ((0, o.isHexString)(r)) {
								r = n.BigNumber.from(r).toNumber();
							}
							t.chainId = r;
						} else {
							let r = e.networkId;
							if (r == null && t.v == null) {
								r = e.chainId;
							}
							if ((0, o.isHexString)(r)) {
								r = n.BigNumber.from(r).toNumber();
							}
							if (typeof r !== 'number' && t.v != null) {
								r = (t.v - 35) / 2;
								if (r < 0) {
									r = 0;
								}
								r = parseInt(r);
							}
							if (typeof r !== 'number') {
								r = 0;
							}
							t.chainId = r;
						}
						if (t.blockHash && t.blockHash.replace(/0/g, '') === 'x') {
							t.blockHash = null;
						}
						return t;
					}
					transaction(e) {
						return (0, a.parse)(e);
					}
					receiptLog(e) {
						return Formatter.check(this.formats.receiptLog, e);
					}
					receipt(e) {
						const t = Formatter.check(this.formats.receipt, e);
						if (t.root != null) {
							if (t.root.length <= 4) {
								const e = n.BigNumber.from(t.root).toNumber();
								if (e === 0 || e === 1) {
									if (t.status != null && t.status !== e) {
										d.throwArgumentError('alt-root-status/status mismatch', 'value', {
											root: t.root,
											status: t.status
										});
									}
									t.status = e;
									delete t.root;
								} else {
									d.throwArgumentError('invalid alt-root-status', 'value.root', t.root);
								}
							} else if (t.root.length !== 66) {
								d.throwArgumentError('invalid root hash', 'value.root', t.root);
							}
						}
						if (t.status != null) {
							t.byzantium = true;
						}
						return t;
					}
					topics(e) {
						if (Array.isArray(e)) {
							return e.map((e) => this.topics(e));
						} else if (e != null) {
							return this.hash(e, true);
						}
						return null;
					}
					filter(e) {
						return Formatter.check(this.formats.filter, e);
					}
					filterLog(e) {
						return Formatter.check(this.formats.filterLog, e);
					}
					static check(e, t) {
						const r = {};
						for (const s in e) {
							try {
								const n = e[s](t[s]);
								if (n !== undefined) {
									r[s] = n;
								}
							} catch (e) {
								e.checkKey = s;
								e.checkValue = t[s];
								throw e;
							}
						}
						return r;
					}
					static allowNull(e, t) {
						return function (r) {
							if (r == null) {
								return t;
							}
							return e(r);
						};
					}
					static allowFalsish(e, t) {
						return function (r) {
							if (!r) {
								return t;
							}
							return e(r);
						};
					}
					static arrayOf(e) {
						return function (t) {
							if (!Array.isArray(t)) {
								throw new Error('not an array');
							}
							const r = [];
							t.forEach(function (t) {
								r.push(e(t));
							});
							return r;
						};
					}
				}
				function isCommunityResourcable(e) {
					return e && typeof e.isCommunityResource === 'function';
				}
				function isCommunityResource(e) {
					return isCommunityResourcable(e) && e.isCommunityResource();
				}
				let h = false;
				function showThrottleMessage() {
					if (h) {
						return;
					}
					h = true;
					console.log('========= NOTICE =========');
					console.log('Request-Rate Exceeded  (this message will not be repeated)');
					console.log('');
					console.log('The default API keys for each service are provided as a highly-throttled,');
					console.log('community resource for low-traffic projects and early prototyping.');
					console.log('');
					console.log('While your application will continue to function, we highly recommended');
					console.log('signing up for your own API keys to improve performance, increase your');
					console.log(
						'request rate/limit and enable other perks, such as metrics and advanced APIs.'
					);
					console.log('');
					console.log('For more details: https://docs.ethers.io/api-keys/');
					console.log('==========================');
				}
			},
		'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js':
			(e, t, r) => {
				'use strict';
				r.r(t);
				r.d(t, { JsonRpcProvider: () => JsonRpcProvider, JsonRpcSigner: () => JsonRpcSigner });
				var s = r(
					'../../node_modules/.pnpm/@ethersproject+abstract-signer@5.7.0/node_modules/@ethersproject/abstract-signer/lib.esm/index.js'
				);
				var n = r(
					'../../node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js'
				);
				var o = r(
					'../../node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/index.js'
				);
				var i = r(
					'../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/typed-data.js'
				);
				var l = r(
					'../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/index.js'
				);
				var a = r(
					'../../node_modules/.pnpm/@ethersproject+strings@5.7.0/node_modules/@ethersproject/strings/lib.esm/utf8.js'
				);
				var c = r(
					'../../node_modules/.pnpm/@ethersproject+transactions@5.7.0/node_modules/@ethersproject/transactions/lib.esm/index.js'
				);
				var u = r(
					'../../node_modules/.pnpm/@ethersproject+web@5.7.1/node_modules/@ethersproject/web/lib.esm/index.js'
				);
				var d = r(
					'../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js'
				);
				var h = r(
					'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/_version.js'
				);
				var f = r(
					'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/base-provider.js'
				);
				var m =
					(undefined && undefined.__awaiter) ||
					function (e, t, r, s) {
						function adopt(e) {
							return e instanceof r
								? e
								: new r(function (t) {
										t(e);
									});
						}
						return new (r || (r = Promise))(function (r, n) {
							function fulfilled(e) {
								try {
									step(s.next(e));
								} catch (e) {
									n(e);
								}
							}
							function rejected(e) {
								try {
									step(s['throw'](e));
								} catch (e) {
									n(e);
								}
							}
							function step(e) {
								e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected);
							}
							step((s = s.apply(e, t || [])).next());
						});
					};
				const p = new d.Logger(h.version);
				const g = ['call', 'estimateGas'];
				function spelunk(e, t) {
					if (e == null) {
						return null;
					}
					if (typeof e.message === 'string' && e.message.match('reverted')) {
						const r = (0, o.isHexString)(e.data) ? e.data : null;
						if (!t || r) {
							return { message: e.message, data: r };
						}
					}
					if (typeof e === 'object') {
						for (const r in e) {
							const s = spelunk(e[r], t);
							if (s) {
								return s;
							}
						}
						return null;
					}
					if (typeof e === 'string') {
						try {
							return spelunk(JSON.parse(e), t);
						} catch (e) {}
					}
					return null;
				}
				function checkError(e, t, r) {
					const s = r.transaction || r.signedTransaction;
					if (e === 'call') {
						const e = spelunk(t, true);
						if (e) {
							return e.data;
						}
						p.throwError(
							'missing revert data in call exception; Transaction reverted without a reason string',
							d.Logger.errors.CALL_EXCEPTION,
							{ data: '0x', transaction: s, error: t }
						);
					}
					if (e === 'estimateGas') {
						let r = spelunk(t.body, false);
						if (r == null) {
							r = spelunk(t, false);
						}
						if (r) {
							p.throwError(
								'cannot estimate gas; transaction may fail or may require manual gas limit',
								d.Logger.errors.UNPREDICTABLE_GAS_LIMIT,
								{ reason: r.message, method: e, transaction: s, error: t }
							);
						}
					}
					let n = t.message;
					if (
						t.code === d.Logger.errors.SERVER_ERROR &&
						t.error &&
						typeof t.error.message === 'string'
					) {
						n = t.error.message;
					} else if (typeof t.body === 'string') {
						n = t.body;
					} else if (typeof t.responseText === 'string') {
						n = t.responseText;
					}
					n = (n || '').toLowerCase();
					if (n.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {
						p.throwError(
							'insufficient funds for intrinsic transaction cost',
							d.Logger.errors.INSUFFICIENT_FUNDS,
							{ error: t, method: e, transaction: s }
						);
					}
					if (n.match(/nonce (is )?too low/i)) {
						p.throwError('nonce has already been used', d.Logger.errors.NONCE_EXPIRED, {
							error: t,
							method: e,
							transaction: s
						});
					}
					if (n.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
						p.throwError('replacement fee too low', d.Logger.errors.REPLACEMENT_UNDERPRICED, {
							error: t,
							method: e,
							transaction: s
						});
					}
					if (n.match(/only replay-protected/i)) {
						p.throwError(
							'legacy pre-eip-155 transactions not supported',
							d.Logger.errors.UNSUPPORTED_OPERATION,
							{ error: t, method: e, transaction: s }
						);
					}
					if (
						g.indexOf(e) >= 0 &&
						n.match(
							/gas required exceeds allowance|always failing transaction|execution reverted|revert/
						)
					) {
						p.throwError(
							'cannot estimate gas; transaction may fail or may require manual gas limit',
							d.Logger.errors.UNPREDICTABLE_GAS_LIMIT,
							{ error: t, method: e, transaction: s }
						);
					}
					throw t;
				}
				function timer(e) {
					return new Promise(function (t) {
						setTimeout(t, e);
					});
				}
				function getResult(e) {
					if (e.error) {
						const t = new Error(e.error.message);
						t.code = e.error.code;
						t.data = e.error.data;
						throw t;
					}
					return e.result;
				}
				function getLowerCase(e) {
					if (e) {
						return e.toLowerCase();
					}
					return e;
				}
				const b = {};
				class JsonRpcSigner extends s.Signer {
					constructor(e, t, r) {
						super();
						if (e !== b) {
							throw new Error(
								'do not call the JsonRpcSigner constructor directly; use provider.getSigner'
							);
						}
						(0, l.defineReadOnly)(this, 'provider', t);
						if (r == null) {
							r = 0;
						}
						if (typeof r === 'string') {
							(0, l.defineReadOnly)(this, '_address', this.provider.formatter.address(r));
							(0, l.defineReadOnly)(this, '_index', null);
						} else if (typeof r === 'number') {
							(0, l.defineReadOnly)(this, '_index', r);
							(0, l.defineReadOnly)(this, '_address', null);
						} else {
							p.throwArgumentError('invalid address or index', 'addressOrIndex', r);
						}
					}
					connect(e) {
						return p.throwError(
							'cannot alter JSON-RPC Signer connection',
							d.Logger.errors.UNSUPPORTED_OPERATION,
							{ operation: 'connect' }
						);
					}
					connectUnchecked() {
						return new UncheckedJsonRpcSigner(b, this.provider, this._address || this._index);
					}
					getAddress() {
						if (this._address) {
							return Promise.resolve(this._address);
						}
						return this.provider.send('eth_accounts', []).then((e) => {
							if (e.length <= this._index) {
								p.throwError(
									'unknown account #' + this._index,
									d.Logger.errors.UNSUPPORTED_OPERATION,
									{ operation: 'getAddress' }
								);
							}
							return this.provider.formatter.address(e[this._index]);
						});
					}
					sendUncheckedTransaction(e) {
						e = (0, l.shallowCopy)(e);
						const t = this.getAddress().then((e) => {
							if (e) {
								e = e.toLowerCase();
							}
							return e;
						});
						if (e.gasLimit == null) {
							const r = (0, l.shallowCopy)(e);
							r.from = t;
							e.gasLimit = this.provider.estimateGas(r);
						}
						if (e.to != null) {
							e.to = Promise.resolve(e.to).then((e) =>
								m(this, void 0, void 0, function* () {
									if (e == null) {
										return null;
									}
									const t = yield this.provider.resolveName(e);
									if (t == null) {
										p.throwArgumentError('provided ENS name resolves to null', 'tx.to', e);
									}
									return t;
								})
							);
						}
						return (0, l.resolveProperties)({ tx: (0, l.resolveProperties)(e), sender: t }).then(
							({ tx: t, sender: r }) => {
								if (t.from != null) {
									if (t.from.toLowerCase() !== r) {
										p.throwArgumentError('from address mismatch', 'transaction', e);
									}
								} else {
									t.from = r;
								}
								const s = this.provider.constructor.hexlifyTransaction(t, { from: true });
								return this.provider.send('eth_sendTransaction', [s]).then(
									(e) => e,
									(e) => {
										if (typeof e.message === 'string' && e.message.match(/user denied/i)) {
											p.throwError('user rejected transaction', d.Logger.errors.ACTION_REJECTED, {
												action: 'sendTransaction',
												transaction: t
											});
										}
										return checkError('sendTransaction', e, s);
									}
								);
							}
						);
					}
					signTransaction(e) {
						return p.throwError(
							'signing transactions is unsupported',
							d.Logger.errors.UNSUPPORTED_OPERATION,
							{ operation: 'signTransaction' }
						);
					}
					sendTransaction(e) {
						return m(this, void 0, void 0, function* () {
							const t = yield this.provider._getInternalBlockNumber(
								100 + 2 * this.provider.pollingInterval
							);
							const r = yield this.sendUncheckedTransaction(e);
							try {
								return yield (0, u.poll)(
									() =>
										m(this, void 0, void 0, function* () {
											const e = yield this.provider.getTransaction(r);
											if (e === null) {
												return undefined;
											}
											return this.provider._wrapTransaction(e, r, t);
										}),
									{ oncePoll: this.provider }
								);
							} catch (e) {
								e.transactionHash = r;
								throw e;
							}
						});
					}
					signMessage(e) {
						return m(this, void 0, void 0, function* () {
							const t = typeof e === 'string' ? (0, a.toUtf8Bytes)(e) : e;
							const r = yield this.getAddress();
							try {
								return yield this.provider.send('personal_sign', [
									(0, o.hexlify)(t),
									r.toLowerCase()
								]);
							} catch (t) {
								if (typeof t.message === 'string' && t.message.match(/user denied/i)) {
									p.throwError('user rejected signing', d.Logger.errors.ACTION_REJECTED, {
										action: 'signMessage',
										from: r,
										messageData: e
									});
								}
								throw t;
							}
						});
					}
					_legacySignMessage(e) {
						return m(this, void 0, void 0, function* () {
							const t = typeof e === 'string' ? (0, a.toUtf8Bytes)(e) : e;
							const r = yield this.getAddress();
							try {
								return yield this.provider.send('eth_sign', [r.toLowerCase(), (0, o.hexlify)(t)]);
							} catch (t) {
								if (typeof t.message === 'string' && t.message.match(/user denied/i)) {
									p.throwError('user rejected signing', d.Logger.errors.ACTION_REJECTED, {
										action: '_legacySignMessage',
										from: r,
										messageData: e
									});
								}
								throw t;
							}
						});
					}
					_signTypedData(e, t, r) {
						return m(this, void 0, void 0, function* () {
							const s = yield i.TypedDataEncoder.resolveNames(e, t, r, (e) =>
								this.provider.resolveName(e)
							);
							const n = yield this.getAddress();
							try {
								return yield this.provider.send('eth_signTypedData_v4', [
									n.toLowerCase(),
									JSON.stringify(i.TypedDataEncoder.getPayload(s.domain, t, s.value))
								]);
							} catch (e) {
								if (typeof e.message === 'string' && e.message.match(/user denied/i)) {
									p.throwError('user rejected signing', d.Logger.errors.ACTION_REJECTED, {
										action: '_signTypedData',
										from: n,
										messageData: { domain: s.domain, types: t, value: s.value }
									});
								}
								throw e;
							}
						});
					}
					unlock(e) {
						return m(this, void 0, void 0, function* () {
							const t = this.provider;
							const r = yield this.getAddress();
							return t.send('personal_unlockAccount', [r.toLowerCase(), e, null]);
						});
					}
				}
				class UncheckedJsonRpcSigner extends JsonRpcSigner {
					sendTransaction(e) {
						return this.sendUncheckedTransaction(e).then((e) => ({
							hash: e,
							nonce: null,
							gasLimit: null,
							gasPrice: null,
							data: null,
							value: null,
							chainId: null,
							confirmations: 0,
							from: null,
							wait: (t) => this.provider.waitForTransaction(e, t)
						}));
					}
				}
				const A = {
					chainId: true,
					data: true,
					gasLimit: true,
					gasPrice: true,
					nonce: true,
					to: true,
					value: true,
					type: true,
					accessList: true,
					maxFeePerGas: true,
					maxPriorityFeePerGas: true
				};
				class JsonRpcProvider extends f.BaseProvider {
					constructor(e, t) {
						let r = t;
						if (r == null) {
							r = new Promise((e, t) => {
								setTimeout(() => {
									this.detectNetwork().then(
										(t) => {
											e(t);
										},
										(e) => {
											t(e);
										}
									);
								}, 0);
							});
						}
						super(r);
						if (!e) {
							e = (0, l.getStatic)(this.constructor, 'defaultUrl')();
						}
						if (typeof e === 'string') {
							(0, l.defineReadOnly)(this, 'connection', Object.freeze({ url: e }));
						} else {
							(0, l.defineReadOnly)(this, 'connection', Object.freeze((0, l.shallowCopy)(e)));
						}
						this._nextId = 42;
					}
					get _cache() {
						if (this._eventLoopCache == null) {
							this._eventLoopCache = {};
						}
						return this._eventLoopCache;
					}
					static defaultUrl() {
						return 'http://localhost:8545';
					}
					detectNetwork() {
						if (!this._cache['detectNetwork']) {
							this._cache['detectNetwork'] = this._uncachedDetectNetwork();
							setTimeout(() => {
								this._cache['detectNetwork'] = null;
							}, 0);
						}
						return this._cache['detectNetwork'];
					}
					_uncachedDetectNetwork() {
						return m(this, void 0, void 0, function* () {
							yield timer(0);
							let e = null;
							try {
								e = yield this.send('eth_chainId', []);
							} catch (t) {
								try {
									e = yield this.send('net_version', []);
								} catch (e) {}
							}
							if (e != null) {
								const t = (0, l.getStatic)(this.constructor, 'getNetwork');
								try {
									return t(n.BigNumber.from(e).toNumber());
								} catch (t) {
									return p.throwError('could not detect network', d.Logger.errors.NETWORK_ERROR, {
										chainId: e,
										event: 'invalidNetwork',
										serverError: t
									});
								}
							}
							return p.throwError('could not detect network', d.Logger.errors.NETWORK_ERROR, {
								event: 'noNetwork'
							});
						});
					}
					getSigner(e) {
						return new JsonRpcSigner(b, this, e);
					}
					getUncheckedSigner(e) {
						return this.getSigner(e).connectUnchecked();
					}
					listAccounts() {
						return this.send('eth_accounts', []).then((e) =>
							e.map((e) => this.formatter.address(e))
						);
					}
					send(e, t) {
						const r = { method: e, params: t, id: this._nextId++, jsonrpc: '2.0' };
						this.emit('debug', { action: 'request', request: (0, l.deepCopy)(r), provider: this });
						const s = ['eth_chainId', 'eth_blockNumber'].indexOf(e) >= 0;
						if (s && this._cache[e]) {
							return this._cache[e];
						}
						const n = (0, u.fetchJson)(this.connection, JSON.stringify(r), getResult).then(
							(e) => {
								this.emit('debug', { action: 'response', request: r, response: e, provider: this });
								return e;
							},
							(e) => {
								this.emit('debug', { action: 'response', error: e, request: r, provider: this });
								throw e;
							}
						);
						if (s) {
							this._cache[e] = n;
							setTimeout(() => {
								this._cache[e] = null;
							}, 0);
						}
						return n;
					}
					prepareRequest(e, t) {
						switch (e) {
							case 'getBlockNumber':
								return ['eth_blockNumber', []];
							case 'getGasPrice':
								return ['eth_gasPrice', []];
							case 'getBalance':
								return ['eth_getBalance', [getLowerCase(t.address), t.blockTag]];
							case 'getTransactionCount':
								return ['eth_getTransactionCount', [getLowerCase(t.address), t.blockTag]];
							case 'getCode':
								return ['eth_getCode', [getLowerCase(t.address), t.blockTag]];
							case 'getStorageAt':
								return [
									'eth_getStorageAt',
									[getLowerCase(t.address), (0, o.hexZeroPad)(t.position, 32), t.blockTag]
								];
							case 'sendTransaction':
								return ['eth_sendRawTransaction', [t.signedTransaction]];
							case 'getBlock':
								if (t.blockTag) {
									return ['eth_getBlockByNumber', [t.blockTag, !!t.includeTransactions]];
								} else if (t.blockHash) {
									return ['eth_getBlockByHash', [t.blockHash, !!t.includeTransactions]];
								}
								return null;
							case 'getTransaction':
								return ['eth_getTransactionByHash', [t.transactionHash]];
							case 'getTransactionReceipt':
								return ['eth_getTransactionReceipt', [t.transactionHash]];
							case 'call': {
								const e = (0, l.getStatic)(this.constructor, 'hexlifyTransaction');
								return ['eth_call', [e(t.transaction, { from: true }), t.blockTag]];
							}
							case 'estimateGas': {
								const e = (0, l.getStatic)(this.constructor, 'hexlifyTransaction');
								return ['eth_estimateGas', [e(t.transaction, { from: true })]];
							}
							case 'getLogs':
								if (t.filter && t.filter.address != null) {
									t.filter.address = getLowerCase(t.filter.address);
								}
								return ['eth_getLogs', [t.filter]];
							default:
								break;
						}
						return null;
					}
					perform(e, t) {
						return m(this, void 0, void 0, function* () {
							if (e === 'call' || e === 'estimateGas') {
								const e = t.transaction;
								if (e && e.type != null && n.BigNumber.from(e.type).isZero()) {
									if (e.maxFeePerGas == null && e.maxPriorityFeePerGas == null) {
										const r = yield this.getFeeData();
										if (r.maxFeePerGas == null && r.maxPriorityFeePerGas == null) {
											t = (0, l.shallowCopy)(t);
											t.transaction = (0, l.shallowCopy)(e);
											delete t.transaction.type;
										}
									}
								}
							}
							const r = this.prepareRequest(e, t);
							if (r == null) {
								p.throwError(e + ' not implemented', d.Logger.errors.NOT_IMPLEMENTED, {
									operation: e
								});
							}
							try {
								return yield this.send(r[0], r[1]);
							} catch (r) {
								return checkError(e, r, t);
							}
						});
					}
					_startEvent(e) {
						if (e.tag === 'pending') {
							this._startPending();
						}
						super._startEvent(e);
					}
					_startPending() {
						if (this._pendingFilter != null) {
							return;
						}
						const e = this;
						const t = this.send('eth_newPendingTransactionFilter', []);
						this._pendingFilter = t;
						t.then(function (r) {
							function poll() {
								e.send('eth_getFilterChanges', [r])
									.then(function (r) {
										if (e._pendingFilter != t) {
											return null;
										}
										let s = Promise.resolve();
										r.forEach(function (t) {
											e._emitted['t:' + t.toLowerCase()] = 'pending';
											s = s.then(function () {
												return e.getTransaction(t).then(function (t) {
													e.emit('pending', t);
													return null;
												});
											});
										});
										return s.then(function () {
											return timer(1e3);
										});
									})
									.then(function () {
										if (e._pendingFilter != t) {
											e.send('eth_uninstallFilter', [r]);
											return;
										}
										setTimeout(function () {
											poll();
										}, 0);
										return null;
									})
									.catch((e) => {});
							}
							poll();
							return r;
						}).catch((e) => {});
					}
					_stopEvent(e) {
						if (e.tag === 'pending' && this.listenerCount('pending') === 0) {
							this._pendingFilter = null;
						}
						super._stopEvent(e);
					}
					static hexlifyTransaction(e, t) {
						const r = (0, l.shallowCopy)(A);
						if (t) {
							for (const e in t) {
								if (t[e]) {
									r[e] = true;
								}
							}
						}
						(0, l.checkProperties)(e, r);
						const s = {};
						[
							'chainId',
							'gasLimit',
							'gasPrice',
							'type',
							'maxFeePerGas',
							'maxPriorityFeePerGas',
							'nonce',
							'value'
						].forEach(function (t) {
							if (e[t] == null) {
								return;
							}
							const r = (0, o.hexValue)(n.BigNumber.from(e[t]));
							if (t === 'gasLimit') {
								t = 'gas';
							}
							s[t] = r;
						});
						['from', 'to', 'data'].forEach(function (t) {
							if (e[t] == null) {
								return;
							}
							s[t] = (0, o.hexlify)(e[t]);
						});
						if (e.accessList) {
							s['accessList'] = (0, c.accessListify)(e.accessList);
						}
						return s;
					}
				}
			},
		'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js':
			(e, t, r) => {
				'use strict';
				r.r(t);
				r.d(t, { WebSocketProvider: () => WebSocketProvider });
				var s = r(
					'../../node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js'
				);
				var n = r(
					'../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/index.js'
				);
				var o = r(
					'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js'
				);
				var i = r(
					'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/ws.js'
				);
				var l = r(
					'../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js'
				);
				var a = r(
					'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/_version.js'
				);
				var c =
					(undefined && undefined.__awaiter) ||
					function (e, t, r, s) {
						function adopt(e) {
							return e instanceof r
								? e
								: new r(function (t) {
										t(e);
									});
						}
						return new (r || (r = Promise))(function (r, n) {
							function fulfilled(e) {
								try {
									step(s.next(e));
								} catch (e) {
									n(e);
								}
							}
							function rejected(e) {
								try {
									step(s['throw'](e));
								} catch (e) {
									n(e);
								}
							}
							function step(e) {
								e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected);
							}
							step((s = s.apply(e, t || [])).next());
						});
					};
				const u = new l.Logger(a.version);
				let d = 1;
				class WebSocketProvider extends o.JsonRpcProvider {
					constructor(e, t) {
						if (t === 'any') {
							u.throwError(
								"WebSocketProvider does not support 'any' network yet",
								l.Logger.errors.UNSUPPORTED_OPERATION,
								{ operation: 'network:any' }
							);
						}
						if (typeof e === 'string') {
							super(e, t);
						} else {
							super('_websocket', t);
						}
						this._pollingInterval = -1;
						this._wsReady = false;
						if (typeof e === 'string') {
							(0, n.defineReadOnly)(this, '_websocket', new i.WebSocket(this.connection.url));
						} else {
							(0, n.defineReadOnly)(this, '_websocket', e);
						}
						(0, n.defineReadOnly)(this, '_requests', {});
						(0, n.defineReadOnly)(this, '_subs', {});
						(0, n.defineReadOnly)(this, '_subIds', {});
						(0, n.defineReadOnly)(this, '_detectNetwork', super.detectNetwork());
						this.websocket.onopen = () => {
							this._wsReady = true;
							Object.keys(this._requests).forEach((e) => {
								this.websocket.send(this._requests[e].payload);
							});
						};
						this.websocket.onmessage = (e) => {
							const t = e.data;
							const r = JSON.parse(t);
							if (r.id != null) {
								const e = String(r.id);
								const s = this._requests[e];
								delete this._requests[e];
								if (r.result !== undefined) {
									s.callback(null, r.result);
									this.emit('debug', {
										action: 'response',
										request: JSON.parse(s.payload),
										response: r.result,
										provider: this
									});
								} else {
									let e = null;
									if (r.error) {
										e = new Error(r.error.message || 'unknown error');
										(0, n.defineReadOnly)(e, 'code', r.error.code || null);
										(0, n.defineReadOnly)(e, 'response', t);
									} else {
										e = new Error('unknown error');
									}
									s.callback(e, undefined);
									this.emit('debug', {
										action: 'response',
										error: e,
										request: JSON.parse(s.payload),
										provider: this
									});
								}
							} else if (r.method === 'eth_subscription') {
								const e = this._subs[r.params.subscription];
								if (e) {
									e.processFunc(r.params.result);
								}
							} else {
								console.warn('this should not happen');
							}
						};
						const r = setInterval(() => {
							this.emit('poll');
						}, 1e3);
						if (r.unref) {
							r.unref();
						}
					}
					get websocket() {
						return this._websocket;
					}
					detectNetwork() {
						return this._detectNetwork;
					}
					get pollingInterval() {
						return 0;
					}
					resetEventsBlock(e) {
						u.throwError(
							'cannot reset events block on WebSocketProvider',
							l.Logger.errors.UNSUPPORTED_OPERATION,
							{ operation: 'resetEventBlock' }
						);
					}
					set pollingInterval(e) {
						u.throwError(
							'cannot set polling interval on WebSocketProvider',
							l.Logger.errors.UNSUPPORTED_OPERATION,
							{ operation: 'setPollingInterval' }
						);
					}
					poll() {
						return c(this, void 0, void 0, function* () {
							return null;
						});
					}
					set polling(e) {
						if (!e) {
							return;
						}
						u.throwError(
							'cannot set polling on WebSocketProvider',
							l.Logger.errors.UNSUPPORTED_OPERATION,
							{ operation: 'setPolling' }
						);
					}
					send(e, t) {
						const r = d++;
						return new Promise((s, n) => {
							function callback(e, t) {
								if (e) {
									return n(e);
								}
								return s(t);
							}
							const o = JSON.stringify({ method: e, params: t, id: r, jsonrpc: '2.0' });
							this.emit('debug', { action: 'request', request: JSON.parse(o), provider: this });
							this._requests[String(r)] = { callback, payload: o };
							if (this._wsReady) {
								this.websocket.send(o);
							}
						});
					}
					static defaultUrl() {
						return 'ws://localhost:8546';
					}
					_subscribe(e, t, r) {
						return c(this, void 0, void 0, function* () {
							let s = this._subIds[e];
							if (s == null) {
								s = Promise.all(t).then((e) => this.send('eth_subscribe', e));
								this._subIds[e] = s;
							}
							const n = yield s;
							this._subs[n] = { tag: e, processFunc: r };
						});
					}
					_startEvent(e) {
						switch (e.type) {
							case 'block':
								this._subscribe('block', ['newHeads'], (e) => {
									const t = s.BigNumber.from(e.number).toNumber();
									this._emitted.block = t;
									this.emit('block', t);
								});
								break;
							case 'pending':
								this._subscribe('pending', ['newPendingTransactions'], (e) => {
									this.emit('pending', e);
								});
								break;
							case 'filter':
								this._subscribe(e.tag, ['logs', this._getFilter(e.filter)], (t) => {
									if (t.removed == null) {
										t.removed = false;
									}
									this.emit(e.filter, this.formatter.filterLog(t));
								});
								break;
							case 'tx': {
								const emitReceipt = (e) => {
									const t = e.hash;
									this.getTransactionReceipt(t).then((e) => {
										if (!e) {
											return;
										}
										this.emit(t, e);
									});
								};
								emitReceipt(e);
								this._subscribe('tx', ['newHeads'], (e) => {
									this._events.filter((e) => e.type === 'tx').forEach(emitReceipt);
								});
								break;
							}
							case 'debug':
							case 'poll':
							case 'willPoll':
							case 'didPoll':
							case 'error':
								break;
							default:
								console.log('unhandled:', e);
								break;
						}
					}
					_stopEvent(e) {
						let t = e.tag;
						if (e.type === 'tx') {
							if (this._events.filter((e) => e.type === 'tx').length) {
								return;
							}
							t = 'tx';
						} else if (this.listenerCount(e.event)) {
							return;
						}
						const r = this._subIds[t];
						if (!r) {
							return;
						}
						delete this._subIds[t];
						r.then((e) => {
							if (!this._subs[e]) {
								return;
							}
							delete this._subs[e];
							this.send('eth_unsubscribe', [e]);
						});
					}
					destroy() {
						return c(this, void 0, void 0, function* () {
							if (this.websocket.readyState === i.WebSocket.CONNECTING) {
								yield new Promise((e) => {
									this.websocket.onopen = function () {
										e(true);
									};
									this.websocket.onerror = function () {
										e(false);
									};
								});
							}
							this.websocket.close(1e3);
						});
					}
				}
			},
		'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/ws.js':
			(e, t, r) => {
				'use strict';
				r.r(t);
				r.d(t, { WebSocket: () => o });
				var s = r(
					'../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js'
				);
				var n = r(
					'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/_version.js'
				);
				let o = null;
				try {
					o = WebSocket;
					if (o == null) {
						throw new Error('inject please');
					}
				} catch (e) {
					const t = new s.Logger(n.version);
					o = function () {
						t.throwError(
							'WebSockets not supported in this environment',
							s.Logger.errors.UNSUPPORTED_OPERATION,
							{ operation: 'new WebSocket()' }
						);
					};
				}
			},
		'../../node_modules/.pnpm/alchemy-sdk@3.5.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/alchemy-sdk/dist/esm/alchemy-provider-8b0c3e20.js':
			(e, t, r) => {
				'use strict';
				r.r(t);
				r.d(t, { AlchemyProvider: () => AlchemyProvider });
				var s = r(
					'../../node_modules/.pnpm/alchemy-sdk@3.5.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/alchemy-sdk/dist/esm/index-1789de96.js'
				);
				var n = r(
					'../../node_modules/.pnpm/@ethersproject+networks@5.7.1/node_modules/@ethersproject/networks/lib.esm/index.js'
				);
				var o = r(
					'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js'
				);
				var i = r(
					'../../node_modules/.pnpm/@ethersproject+web@5.7.1/node_modules/@ethersproject/web/lib.esm/index.js'
				);
				const l = 100;
				const a = 10;
				class RequestBatcher {
					constructor(e, t = l) {
						this.sendBatchFn = e;
						this.maxBatchSize = t;
						this.pendingBatch = [];
					}
					enqueueRequest(e) {
						return (0, s._)(this, void 0, void 0, function* () {
							const t = { request: e, resolve: undefined, reject: undefined };
							const r = new Promise((e, r) => {
								t.resolve = e;
								t.reject = r;
							});
							this.pendingBatch.push(t);
							if (this.pendingBatch.length === this.maxBatchSize) {
								void this.sendBatchRequest();
							} else if (!this.pendingBatchTimer) {
								this.pendingBatchTimer = setTimeout(() => this.sendBatchRequest(), a);
							}
							return r;
						});
					}
					sendBatchRequest() {
						return (0, s._)(this, void 0, void 0, function* () {
							const e = this.pendingBatch;
							this.pendingBatch = [];
							if (this.pendingBatchTimer) {
								clearTimeout(this.pendingBatchTimer);
								this.pendingBatchTimer = undefined;
							}
							const t = e.map((e) => e.request);
							return this.sendBatchFn(t).then(
								(t) => {
									e.forEach((e, r) => {
										const s = t[r];
										if (s.error) {
											const t = new Error(s.error.message);
											t.code = s.error.code;
											t.data = s.error.data;
											e.reject(t);
										} else {
											e.resolve(s.result);
										}
									});
								},
								(t) => {
									e.forEach((e) => {
										e.reject(t);
									});
								}
							);
						});
					}
				}
				class AlchemyProvider extends o.JsonRpcProvider {
					constructor(e) {
						const t = AlchemyProvider.getApiKey(e.apiKey);
						const r = AlchemyProvider.getAlchemyNetwork(e.network);
						let n = AlchemyProvider.getAlchemyConnectionInfo(r, t, 'http');
						if (e.url !== undefined) {
							n.url = e.url;
						}
						n.throttleLimit = e.maxRetries;
						if (e.connectionInfoOverrides) {
							n = Object.assign(Object.assign({}, n), e.connectionInfoOverrides);
						}
						const o = s.E[r];
						super(n, o);
						this.apiKey = e.apiKey;
						this.maxRetries = e.maxRetries;
						this.batchRequests = e.batchRequests;
						const l = Object.assign(Object.assign({}, this.connection), {
							headers: Object.assign(Object.assign({}, this.connection.headers), {
								'Alchemy-Ethers-Sdk-Method': 'batchSend'
							})
						});
						const sendBatchFn = (e) => (0, i.fetchJson)(l, JSON.stringify(e));
						this.batcher = new RequestBatcher(sendBatchFn);
						this.modifyFormatter();
					}
					static getApiKey(e) {
						if (e == null) {
							return s.D;
						}
						if (e && typeof e !== 'string') {
							throw new Error(`Invalid apiKey '${e}' provided. apiKey must be a string.`);
						}
						return e;
					}
					static getNetwork(e) {
						if (typeof e === 'string' && e in s.C) {
							return s.C[e];
						}
						return (0, n.getNetwork)(e);
					}
					static getAlchemyNetwork(e) {
						if (e === undefined) {
							return s.a;
						}
						if (typeof e === 'number') {
							throw new Error(`Invalid network '${e}' provided. Network must be a string.`);
						}
						const t = Object.values(s.N).includes(e);
						if (!t) {
							throw new Error(
								`Invalid network '${e}' provided. Network must be one of: ` +
									`${Object.values(s.N).join(', ')}.`
							);
						}
						return e;
					}
					static getAlchemyConnectionInfo(e, t, r) {
						const n = r === 'http' ? (0, s.g)(e, t) : (0, s.b)(e, t);
						return {
							headers: s.I
								? { 'Alchemy-Ethers-Sdk-Version': s.V }
								: { 'Alchemy-Ethers-Sdk-Version': s.V, 'Accept-Encoding': 'gzip' },
							allowGzip: true,
							url: n
						};
					}
					detectNetwork() {
						const e = Object.create(null, { detectNetwork: { get: () => super.detectNetwork } });
						return (0, s._)(this, void 0, void 0, function* () {
							let t = this.network;
							if (t == null) {
								t = yield e.detectNetwork.call(this);
								if (!t) {
									throw new Error('No network detected');
								}
							}
							return t;
						});
					}
					_startPending() {
						(0, s.l)('WARNING: Alchemy Provider does not support pending filters');
					}
					isCommunityResource() {
						return this.apiKey === s.D;
					}
					send(e, t) {
						return this._send(e, t, 'send');
					}
					_send(e, t, r, n = false) {
						const o = { method: e, params: t, id: this._nextId++, jsonrpc: '2.0' };
						const l = Object.assign({}, this.connection);
						l.headers['Alchemy-Ethers-Sdk-Method'] = r;
						if (this.batchRequests || n) {
							return this.batcher.enqueueRequest(o);
						}
						this.emit('debug', { action: 'request', request: (0, s.d)(o), provider: this });
						const a = ['eth_chainId', 'eth_blockNumber'].indexOf(e) >= 0;
						if (a && this._cache[e]) {
							return this._cache[e];
						}
						const c = (0, i.fetchJson)(this.connection, JSON.stringify(o), getResult).then(
							(e) => {
								this.emit('debug', { action: 'response', request: o, response: e, provider: this });
								return e;
							},
							(e) => {
								this.emit('debug', { action: 'response', error: e, request: o, provider: this });
								throw e;
							}
						);
						if (a) {
							this._cache[e] = c;
							setTimeout(() => {
								this._cache[e] = null;
							}, 0);
						}
						return c;
					}
					modifyFormatter() {
						this.formatter.formats['receiptLog']['removed'] = (e) => {
							if (typeof e === 'boolean') {
								return e;
							}
							return undefined;
						};
					}
				}
				function getResult(e) {
					if (e.error) {
						const t = new Error(e.error.message);
						t.code = e.error.code;
						t.data = e.error.data;
						throw t;
					}
					return e.result;
				}
			},
		'../../node_modules/.pnpm/alchemy-sdk@3.5.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-948c1ea8.js':
			(e, t, r) => {
				'use strict';
				r.r(t);
				r.d(t, { AlchemyWebSocketProvider: () => AlchemyWebSocketProvider });
				var s = r(
					'../../node_modules/.pnpm/alchemy-sdk@3.5.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/alchemy-sdk/dist/esm/index-1789de96.js'
				);
				var n = r(
					'../../node_modules/.pnpm/sturdy-websocket@0.2.1/node_modules/sturdy-websocket/dist/index.js'
				);
				var o = r(
					'../../node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js'
				);
				var i = r(
					'../../node_modules/.pnpm/@ethersproject+networks@5.7.1/node_modules/@ethersproject/networks/lib.esm/index.js'
				);
				var l = r(
					'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js'
				);
				var a = r(
					'../../node_modules/.pnpm/alchemy-sdk@3.5.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/alchemy-sdk/dist/esm/alchemy-provider-8b0c3e20.js'
				);
				var c = r('../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js');
				const u = 120;
				class WebsocketBackfiller {
					constructor(e) {
						this.provider = e;
						this.maxBackfillBlocks = u;
					}
					getNewHeadsBackfill(e, t, r) {
						return (0, s._)(this, void 0, void 0, function* () {
							throwIfCancelled(e);
							const n = yield this.getBlockNumber();
							throwIfCancelled(e);
							if (t.length === 0) {
								return this.getHeadEventsInRange(
									Math.max(r, n - this.maxBackfillBlocks) + 1,
									n + 1
								);
							}
							const o = (0, s.f)(t[t.length - 1].number);
							const i = n - this.maxBackfillBlocks + 1;
							if (o <= i) {
								return this.getHeadEventsInRange(i, n + 1);
							}
							const l = yield this.getReorgHeads(e, t);
							throwIfCancelled(e);
							const a = yield this.getHeadEventsInRange(o + 1, n + 1);
							throwIfCancelled(e);
							return [...l, ...a];
						});
					}
					getLogsBackfill(e, t, r, n) {
						return (0, s._)(this, void 0, void 0, function* () {
							throwIfCancelled(e);
							const o = yield this.getBlockNumber();
							throwIfCancelled(e);
							if (r.length === 0) {
								return this.getLogsInRange(t, Math.max(n, o - this.maxBackfillBlocks) + 1, o + 1);
							}
							const i = (0, s.f)(r[r.length - 1].blockNumber);
							const l = o - this.maxBackfillBlocks + 1;
							if (i < l) {
								return this.getLogsInRange(t, l, o + 1);
							}
							const a = yield this.getCommonAncestor(e, r);
							throwIfCancelled(e);
							const c = r
								.filter((e) => (0, s.f)(e.blockNumber) > a.blockNumber)
								.map((e) => Object.assign(Object.assign({}, e), { removed: true }));
							const u =
								a.blockNumber === Number.NEGATIVE_INFINITY
									? (0, s.f)(r[0].blockNumber)
									: a.blockNumber;
							let d = yield this.getLogsInRange(t, u, o + 1);
							d = d.filter(
								(e) =>
									e &&
									((0, s.f)(e.blockNumber) > a.blockNumber || (0, s.f)(e.logIndex) > a.logIndex)
							);
							throwIfCancelled(e);
							return [...c, ...d];
						});
					}
					setMaxBackfillBlock(e) {
						this.maxBackfillBlocks = e;
					}
					getBlockNumber() {
						return (0, s._)(this, void 0, void 0, function* () {
							const e = yield this.provider.send('eth_blockNumber');
							return (0, s.f)(e);
						});
					}
					getHeadEventsInRange(e, t) {
						return (0, s._)(this, void 0, void 0, function* () {
							if (e >= t) {
								return [];
							}
							const r = [];
							for (let n = e; n < t; n++) {
								r.push({ method: 'eth_getBlockByNumber', params: [(0, s.t)(n), false] });
							}
							const n = yield this.provider.sendBatch(r);
							return n.map(toNewHeadsEvent);
						});
					}
					getReorgHeads(e, t) {
						return (0, s._)(this, void 0, void 0, function* () {
							const r = [];
							for (let n = t.length - 1; n >= 0; n--) {
								const o = t[n];
								const i = yield this.getBlockByNumber((0, s.f)(o.number));
								throwIfCancelled(e);
								if (o.hash === i.hash) {
									break;
								}
								r.push(toNewHeadsEvent(i));
							}
							return r.reverse();
						});
					}
					getBlockByNumber(e) {
						return (0, s._)(this, void 0, void 0, function* () {
							return this.provider.send('eth_getBlockByNumber', [(0, s.t)(e), false]);
						});
					}
					getCommonAncestor(e, t) {
						return (0, s._)(this, void 0, void 0, function* () {
							let r = yield this.getBlockByNumber((0, s.f)(t[t.length - 1].blockNumber));
							throwIfCancelled(e);
							for (let e = t.length - 1; e >= 0; e--) {
								const n = t[e];
								if (n.blockNumber !== r.number) {
									r = yield this.getBlockByNumber((0, s.f)(n.blockNumber));
								}
								if (n.blockHash === r.hash) {
									return { blockNumber: (0, s.f)(n.blockNumber), logIndex: (0, s.f)(n.logIndex) };
								}
							}
							return { blockNumber: Number.NEGATIVE_INFINITY, logIndex: Number.NEGATIVE_INFINITY };
						});
					}
					getLogsInRange(e, t, r) {
						return (0, s._)(this, void 0, void 0, function* () {
							if (t >= r) {
								return [];
							}
							const n = Object.assign(Object.assign({}, e), {
								fromBlock: (0, s.t)(t),
								toBlock: (0, s.t)(r - 1)
							});
							return this.provider.send('eth_getLogs', [n]);
						});
					}
				}
				function toNewHeadsEvent(e) {
					const t = Object.assign({}, e);
					delete t.totalDifficulty;
					delete t.transactions;
					delete t.uncles;
					return t;
				}
				function dedupeNewHeads(e) {
					return dedupe(e, (e) => e.hash);
				}
				function dedupeLogs(e) {
					return dedupe(e, (e) => `${e.blockHash}/${e.logIndex}`);
				}
				function dedupe(e, t) {
					const r = new Set();
					const s = [];
					e.forEach((e) => {
						const n = t(e);
						if (!r.has(n)) {
							r.add(n);
							s.push(e);
						}
					});
					return s;
				}
				const d = new Error('Cancelled');
				function throwIfCancelled(e) {
					if (e()) {
						throw d;
					}
				}
				const h = 3e4;
				const f = 1e4;
				const m = 6e4;
				const p = 5;
				const g = 10;
				class AlchemyWebSocketProvider extends l.WebSocketProvider {
					constructor(e, t) {
						var r;
						const o = a.AlchemyProvider.getApiKey(e.apiKey);
						const i = a.AlchemyProvider.getAlchemyNetwork(e.network);
						const l = a.AlchemyProvider.getAlchemyConnectionInfo(i, o, 'wss');
						const c = `alchemy-sdk-${s.V}`;
						const u = new n['default']((r = e.url) !== null && r !== void 0 ? r : l.url, c, {
							wsConstructor: t !== null && t !== void 0 ? t : getWebsocketConstructor()
						});
						const d = s.E[i];
						super(u, d);
						this._events = [];
						this.virtualSubscriptionsById = new Map();
						this.virtualIdsByPhysicalId = new Map();
						this.handleMessage = (e) => {
							const t = JSON.parse(e.data);
							if (!isSubscriptionEvent(t)) {
								return;
							}
							const r = t.params.subscription;
							const s = this.virtualIdsByPhysicalId.get(r);
							if (!s) {
								return;
							}
							const n = this.virtualSubscriptionsById.get(s);
							if (n.method !== 'eth_subscribe') {
								return;
							}
							switch (n.params[0]) {
								case 'newHeads': {
									const e = n;
									const o = t;
									const { isBackfilling: i, backfillBuffer: l } = e;
									const { result: a } = o.params;
									if (i) {
										addToNewHeadsEventsBuffer(l, a);
									} else if (r !== s) {
										this.emitAndRememberEvent(s, a, getNewHeadsBlockNumber);
									} else {
										this.rememberEvent(s, a, getNewHeadsBlockNumber);
									}
									break;
								}
								case 'logs': {
									const e = n;
									const o = t;
									const { isBackfilling: i, backfillBuffer: l } = e;
									const { result: a } = o.params;
									if (i) {
										addToLogsEventsBuffer(l, a);
									} else if (s !== r) {
										this.emitAndRememberEvent(s, a, getLogsBlockNumber);
									} else {
										this.rememberEvent(s, a, getLogsBlockNumber);
									}
									break;
								}
								default:
									if (r !== s) {
										const { result: e } = t.params;
										this.emitEvent(s, e);
									}
							}
						};
						this.handleReopen = () => {
							this.virtualIdsByPhysicalId.clear();
							const { cancel: e, isCancelled: t } = makeCancelToken();
							this.cancelBackfill = e;
							for (const e of this.virtualSubscriptionsById.values()) {
								void (() =>
									(0, s._)(this, void 0, void 0, function* () {
										try {
											yield this.resubscribeAndBackfill(t, e);
										} catch (r) {
											if (!t()) {
												console.error(
													`Error while backfilling "${e.params[0]}" subscription. Some events may be missing.`,
													r
												);
											}
										}
									}))();
							}
							this.startHeartbeat();
						};
						this.stopHeartbeatAndBackfill = () => {
							if (this.heartbeatIntervalId != null) {
								clearInterval(this.heartbeatIntervalId);
								this.heartbeatIntervalId = undefined;
							}
							this.cancelBackfill();
						};
						this.apiKey = o;
						this.backfiller = new WebsocketBackfiller(this);
						this.addSocketListeners();
						this.startHeartbeat();
						this.cancelBackfill = s.n;
					}
					static getNetwork(e) {
						if (typeof e === 'string' && e in s.C) {
							return s.C[e];
						}
						return (0, i.getNetwork)(e);
					}
					on(e, t) {
						return this._addEventListener(e, t, false);
					}
					once(e, t) {
						return this._addEventListener(e, t, true);
					}
					off(e, t) {
						if ((0, s.i)(e)) {
							return this._off(e, t);
						} else {
							return super.off(e, t);
						}
					}
					removeAllListeners(e) {
						if (e !== undefined && (0, s.i)(e)) {
							return this._removeAllListeners(e);
						} else {
							return super.removeAllListeners(e);
						}
					}
					listenerCount(e) {
						if (e !== undefined && (0, s.i)(e)) {
							return this._listenerCount(e);
						} else {
							return super.listenerCount(e);
						}
					}
					listeners(e) {
						if (e !== undefined && (0, s.i)(e)) {
							return this._listeners(e);
						} else {
							return super.listeners(e);
						}
					}
					_addEventListener(e, t, r) {
						if ((0, s.i)(e)) {
							(0, s.v)(e);
							const n = new s.c((0, s.e)(e), t, r);
							this._events.push(n);
							this._startEvent(n);
							return this;
						} else {
							return super._addEventListener(e, t, r);
						}
					}
					_startEvent(e) {
						const t = [...s.A, 'block', 'filter'];
						if (t.includes(e.type)) {
							this.customStartEvent(e);
						} else {
							super._startEvent(e);
						}
					}
					_subscribe(e, t, r, n) {
						return (0, s._)(this, void 0, void 0, function* () {
							let s = this._subIds[e];
							const o = yield this.getBlockNumber();
							if (s == null) {
								s = Promise.all(t).then((e) => this.send('eth_subscribe', e));
								this._subIds[e] = s;
							}
							const i = yield s;
							const l = yield Promise.all(t);
							this.virtualSubscriptionsById.set(i, {
								event: n,
								method: 'eth_subscribe',
								params: l,
								startingBlockNumber: o,
								virtualId: i,
								physicalId: i,
								sentEvents: [],
								isBackfilling: false,
								backfillBuffer: []
							});
							this.virtualIdsByPhysicalId.set(i, i);
							this._subs[i] = { tag: e, processFunc: r };
						});
					}
					emit(e, ...t) {
						if ((0, s.i)(e)) {
							let r = false;
							const n = [];
							const o = (0, s.e)(e);
							this._events = this._events.filter((e) => {
								if (e.tag !== o) {
									return true;
								}
								setTimeout(() => {
									e.listener.apply(this, t);
								}, 0);
								r = true;
								if (e.once) {
									n.push(e);
									return false;
								}
								return true;
							});
							n.forEach((e) => {
								this._stopEvent(e);
							});
							return r;
						} else {
							return super.emit(e, ...t);
						}
					}
					sendBatch(e) {
						return (0, s._)(this, void 0, void 0, function* () {
							let t = 0;
							const r = e.map(({ method: e, params: r }) => ({
								method: e,
								params: r,
								jsonrpc: '2.0',
								id: `alchemy-sdk:${t++}`
							}));
							return this.sendBatchConcurrently(r);
						});
					}
					destroy() {
						this.removeSocketListeners();
						this.stopHeartbeatAndBackfill();
						return super.destroy();
					}
					isCommunityResource() {
						return this.apiKey === s.D;
					}
					_stopEvent(e) {
						let t = e.tag;
						if (s.A.includes(e.type)) {
							if (this._events.filter((e) => s.A.includes(e.type)).length) {
								return;
							}
						} else if (e.type === 'tx') {
							if (this._events.filter((e) => e.type === 'tx').length) {
								return;
							}
							t = 'tx';
						} else if (this.listenerCount(e.event)) {
							return;
						}
						const r = this._subIds[t];
						if (!r) {
							return;
						}
						delete this._subIds[t];
						void r.then((e) => {
							if (!this._subs[e]) {
								return;
							}
							delete this._subs[e];
							void this.send('eth_unsubscribe', [e]);
						});
					}
					addSocketListeners() {
						this._websocket.addEventListener('message', this.handleMessage);
						this._websocket.addEventListener('reopen', this.handleReopen);
						this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);
					}
					removeSocketListeners() {
						this._websocket.removeEventListener('message', this.handleMessage);
						this._websocket.removeEventListener('reopen', this.handleReopen);
						this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);
					}
					resubscribeAndBackfill(e, t) {
						return (0, s._)(this, void 0, void 0, function* () {
							const {
								virtualId: r,
								method: s,
								params: n,
								sentEvents: o,
								backfillBuffer: i,
								startingBlockNumber: l
							} = t;
							t.isBackfilling = true;
							i.length = 0;
							try {
								const a = yield this.send(s, n);
								throwIfCancelled(e);
								t.physicalId = a;
								this.virtualIdsByPhysicalId.set(a, r);
								switch (n[0]) {
									case 'newHeads': {
										const t = yield withBackoffRetries(
											() => withTimeout(this.backfiller.getNewHeadsBackfill(e, o, l), m),
											p,
											() => !e()
										);
										throwIfCancelled(e);
										const s = dedupeNewHeads([...t, ...i]);
										s.forEach((e) => this.emitNewHeadsEvent(r, e));
										break;
									}
									case 'logs': {
										const t = n[1] || {};
										const s = yield withBackoffRetries(
											() => withTimeout(this.backfiller.getLogsBackfill(e, t, o, l), m),
											p,
											() => !e()
										);
										throwIfCancelled(e);
										const a = dedupeLogs([...s, ...i]);
										a.forEach((e) => this.emitLogsEvent(r, e));
										break;
									}
									default:
										break;
								}
							} finally {
								t.isBackfilling = false;
								i.length = 0;
							}
						});
					}
					emitNewHeadsEvent(e, t) {
						this.emitAndRememberEvent(e, t, getNewHeadsBlockNumber);
					}
					emitLogsEvent(e, t) {
						this.emitAndRememberEvent(e, t, getLogsBlockNumber);
					}
					emitAndRememberEvent(e, t, r) {
						this.rememberEvent(e, t, r);
						this.emitEvent(e, t);
					}
					emitEvent(e, t) {
						const r = this.virtualSubscriptionsById.get(e);
						if (!r) {
							return;
						}
						this.emitGenericEvent(r, t);
					}
					rememberEvent(e, t, r) {
						const s = this.virtualSubscriptionsById.get(e);
						if (!s) {
							return;
						}
						addToPastEventsBuffer(s.sentEvents, Object.assign({}, t), r);
					}
					emitGenericEvent(e, t) {
						const r = this.emitProcessFn(e.event);
						r(t);
					}
					startHeartbeat() {
						if (this.heartbeatIntervalId != null) {
							return;
						}
						this.heartbeatIntervalId = setInterval(
							() =>
								(0, s._)(this, void 0, void 0, function* () {
									try {
										yield withTimeout(this.send('net_version'), f);
									} catch (e) {
										this._websocket.reconnect();
									}
								}),
							h
						);
					}
					sendBatchConcurrently(e) {
						return (0, s._)(this, void 0, void 0, function* () {
							return Promise.all(e.map((e) => this.send(e.method, e.params)));
						});
					}
					customStartEvent(e) {
						if (e.type === s.h) {
							const { fromAddress: t, toAddress: r, hashesOnly: n } = e;
							void this._subscribe(
								e.tag,
								[s.j.PENDING_TRANSACTIONS, { fromAddress: t, toAddress: r, hashesOnly: n }],
								this.emitProcessFn(e),
								e
							);
						} else if (e.type === s.k) {
							const { addresses: t, includeRemoved: r, hashesOnly: n } = e;
							void this._subscribe(
								e.tag,
								[s.j.MINED_TRANSACTIONS, { addresses: t, includeRemoved: r, hashesOnly: n }],
								this.emitProcessFn(e),
								e
							);
						} else if (e.type === 'block') {
							void this._subscribe('block', ['newHeads'], this.emitProcessFn(e), e);
						} else if (e.type === 'filter') {
							void this._subscribe(
								e.tag,
								['logs', this._getFilter(e.filter)],
								this.emitProcessFn(e),
								e
							);
						}
					}
					emitProcessFn(e) {
						switch (e.type) {
							case s.h:
								return (t) =>
									this.emit(
										{
											method: s.j.PENDING_TRANSACTIONS,
											fromAddress: e.fromAddress,
											toAddress: e.toAddress,
											hashesOnly: e.hashesOnly
										},
										t
									);
							case s.k:
								return (t) =>
									this.emit(
										{
											method: s.j.MINED_TRANSACTIONS,
											addresses: e.addresses,
											includeRemoved: e.includeRemoved,
											hashesOnly: e.hashesOnly
										},
										t
									);
							case 'block':
								return (e) => {
									const t = o.BigNumber.from(e.number).toNumber();
									this._emitted.block = t;
									this.emit('block', t);
								};
							case 'filter':
								return (t) => {
									if (t.removed == null) {
										t.removed = false;
									}
									this.emit(e.filter, this.formatter.filterLog(t));
								};
							default:
								throw new Error('Invalid event type to `emitProcessFn()`');
						}
					}
					_off(e, t) {
						if (t == null) {
							return this.removeAllListeners(e);
						}
						const r = [];
						let n = false;
						const o = (0, s.e)(e);
						this._events = this._events.filter((e) => {
							if (e.tag !== o || e.listener != t) {
								return true;
							}
							if (n) {
								return true;
							}
							n = true;
							r.push(e);
							return false;
						});
						r.forEach((e) => {
							this._stopEvent(e);
						});
						return this;
					}
					_removeAllListeners(e) {
						let t = [];
						if (e == null) {
							t = this._events;
							this._events = [];
						} else {
							const r = (0, s.e)(e);
							this._events = this._events.filter((e) => {
								if (e.tag !== r) {
									return true;
								}
								t.push(e);
								return false;
							});
						}
						t.forEach((e) => {
							this._stopEvent(e);
						});
						return this;
					}
					_listenerCount(e) {
						if (!e) {
							return this._events.length;
						}
						const t = (0, s.e)(e);
						return this._events.filter((e) => e.tag === t).length;
					}
					_listeners(e) {
						if (e == null) {
							return this._events.map((e) => e.listener);
						}
						const t = (0, s.e)(e);
						return this._events.filter((e) => e.tag === t).map((e) => e.listener);
					}
				}
				function getWebsocketConstructor() {
					return isNodeEnvironment()
						? r('../../node_modules/.pnpm/websocket@1.0.35/node_modules/websocket/lib/browser.js')
								.w3cwebsocket
						: WebSocket;
				}
				function isNodeEnvironment() {
					return (
						typeof c !== 'undefined' && c != null && c.versions != null && c.versions.node != null
					);
				}
				function makeCancelToken() {
					let e = false;
					return { cancel: () => (e = true), isCancelled: () => e };
				}
				const b = 1e3;
				const A = 2;
				const v = 3e4;
				function withBackoffRetries(e, t, r = () => true) {
					return (0, s._)(this, void 0, void 0, function* () {
						let s = 0;
						let n = 0;
						while (true) {
							try {
								return yield e();
							} catch (e) {
								n++;
								if (n >= t || !r(e)) {
									throw e;
								}
								yield delay(s);
								if (!r(e)) {
									throw e;
								}
								s = s === 0 ? b : Math.min(v, A * s);
							}
						}
					});
				}
				function delay(e) {
					return new Promise((t) => setTimeout(t, e));
				}
				function withTimeout(e, t) {
					return Promise.race([
						e,
						new Promise((e, r) => setTimeout(() => r(new Error('Timeout')), t))
					]);
				}
				function getNewHeadsBlockNumber(e) {
					return (0, s.f)(e.number);
				}
				function getLogsBlockNumber(e) {
					return (0, s.f)(e.blockNumber);
				}
				function isResponse(e) {
					return Array.isArray(e) || (e.jsonrpc === '2.0' && e.id !== undefined);
				}
				function isSubscriptionEvent(e) {
					return !isResponse(e);
				}
				function addToNewHeadsEventsBuffer(e, t) {
					addToPastEventsBuffer(e, t, getNewHeadsBlockNumber);
				}
				function addToLogsEventsBuffer(e, t) {
					addToPastEventsBuffer(e, t, getLogsBlockNumber);
				}
				function addToPastEventsBuffer(e, t, r) {
					const s = r(t);
					const n = e.findIndex((e) => r(e) > s - g);
					if (n === -1) {
						e.length = 0;
					} else {
						e.splice(0, n);
					}
					e.push(t);
				}
			},
		'../../node_modules/.pnpm/bech32@1.1.4/node_modules/bech32/index.js': (e) => {
			'use strict';
			var t = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
			var r = {};
			for (var s = 0; s < t.length; s++) {
				var n = t.charAt(s);
				if (r[n] !== undefined) throw new TypeError(n + ' is ambiguous');
				r[n] = s;
			}
			function polymodStep(e) {
				var t = e >> 25;
				return (
					((e & 33554431) << 5) ^
					(-((t >> 0) & 1) & 996825010) ^
					(-((t >> 1) & 1) & 642813549) ^
					(-((t >> 2) & 1) & 513874426) ^
					(-((t >> 3) & 1) & 1027748829) ^
					(-((t >> 4) & 1) & 705979059)
				);
			}
			function prefixChk(e) {
				var t = 1;
				for (var r = 0; r < e.length; ++r) {
					var s = e.charCodeAt(r);
					if (s < 33 || s > 126) return 'Invalid prefix (' + e + ')';
					t = polymodStep(t) ^ (s >> 5);
				}
				t = polymodStep(t);
				for (r = 0; r < e.length; ++r) {
					var n = e.charCodeAt(r);
					t = polymodStep(t) ^ (n & 31);
				}
				return t;
			}
			function encode(e, r, s) {
				s = s || 90;
				if (e.length + 7 + r.length > s) throw new TypeError('Exceeds length limit');
				e = e.toLowerCase();
				var n = prefixChk(e);
				if (typeof n === 'string') throw new Error(n);
				var o = e + '1';
				for (var i = 0; i < r.length; ++i) {
					var l = r[i];
					if (l >> 5 !== 0) throw new Error('Non 5-bit word');
					n = polymodStep(n) ^ l;
					o += t.charAt(l);
				}
				for (i = 0; i < 6; ++i) {
					n = polymodStep(n);
				}
				n ^= 1;
				for (i = 0; i < 6; ++i) {
					var a = (n >> ((5 - i) * 5)) & 31;
					o += t.charAt(a);
				}
				return o;
			}
			function __decode(e, t) {
				t = t || 90;
				if (e.length < 8) return e + ' too short';
				if (e.length > t) return 'Exceeds length limit';
				var s = e.toLowerCase();
				var n = e.toUpperCase();
				if (e !== s && e !== n) return 'Mixed-case string ' + e;
				e = s;
				var o = e.lastIndexOf('1');
				if (o === -1) return 'No separator character for ' + e;
				if (o === 0) return 'Missing prefix for ' + e;
				var i = e.slice(0, o);
				var l = e.slice(o + 1);
				if (l.length < 6) return 'Data too short';
				var a = prefixChk(i);
				if (typeof a === 'string') return a;
				var c = [];
				for (var u = 0; u < l.length; ++u) {
					var d = l.charAt(u);
					var h = r[d];
					if (h === undefined) return 'Unknown character ' + d;
					a = polymodStep(a) ^ h;
					if (u + 6 >= l.length) continue;
					c.push(h);
				}
				if (a !== 1) return 'Invalid checksum for ' + e;
				return { prefix: i, words: c };
			}
			function decodeUnsafe() {
				var e = __decode.apply(null, arguments);
				if (typeof e === 'object') return e;
			}
			function decode(e) {
				var t = __decode.apply(null, arguments);
				if (typeof t === 'object') return t;
				throw new Error(t);
			}
			function convert(e, t, r, s) {
				var n = 0;
				var o = 0;
				var i = (1 << r) - 1;
				var l = [];
				for (var a = 0; a < e.length; ++a) {
					n = (n << t) | e[a];
					o += t;
					while (o >= r) {
						o -= r;
						l.push((n >> o) & i);
					}
				}
				if (s) {
					if (o > 0) {
						l.push((n << (r - o)) & i);
					}
				} else {
					if (o >= t) return 'Excess padding';
					if ((n << (r - o)) & i) return 'Non-zero padding';
				}
				return l;
			}
			function toWordsUnsafe(e) {
				var t = convert(e, 8, 5, true);
				if (Array.isArray(t)) return t;
			}
			function toWords(e) {
				var t = convert(e, 8, 5, true);
				if (Array.isArray(t)) return t;
				throw new Error(t);
			}
			function fromWordsUnsafe(e) {
				var t = convert(e, 5, 8, false);
				if (Array.isArray(t)) return t;
			}
			function fromWords(e) {
				var t = convert(e, 5, 8, false);
				if (Array.isArray(t)) return t;
				throw new Error(t);
			}
			e.exports = {
				decodeUnsafe,
				decode,
				encode,
				toWordsUnsafe,
				toWords,
				fromWordsUnsafe,
				fromWords
			};
		},
		'../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/global.js': (e) => {
			var naiveFallback = function () {
				if (typeof self === 'object' && self) return self;
				if (typeof window === 'object' && window) return window;
				throw new Error('Unable to resolve global `this`');
			};
			e.exports = (function () {
				if (this) return this;
				if (typeof globalThis === 'object' && globalThis) return globalThis;
				try {
					Object.defineProperty(Object.prototype, '__global__', {
						get: function () {
							return this;
						},
						configurable: true
					});
				} catch (e) {
					return naiveFallback();
				}
				try {
					if (!__global__) return naiveFallback();
					return __global__;
				} finally {
					delete Object.prototype.__global__;
				}
			})();
		},
		'../../node_modules/.pnpm/sturdy-websocket@0.2.1/node_modules/sturdy-websocket/dist/index.js': (
			e,
			t
		) => {
			'use strict';
			Object.defineProperty(t, '__esModule', { value: true });
			var r = 'Provided shouldReconnect() returned false. Closing permanently.';
			var s = 'Provided shouldReconnect() resolved to false. Closing permanently.';
			var n = (function () {
				function SturdyWebSocket(e, t, r) {
					if (r === void 0) {
						r = {};
					}
					this.url = e;
					this.onclose = null;
					this.onerror = null;
					this.onmessage = null;
					this.onopen = null;
					this.ondown = null;
					this.onreopen = null;
					this.CONNECTING = SturdyWebSocket.CONNECTING;
					this.OPEN = SturdyWebSocket.OPEN;
					this.CLOSING = SturdyWebSocket.CLOSING;
					this.CLOSED = SturdyWebSocket.CLOSED;
					this.hasBeenOpened = false;
					this.isClosed = false;
					this.messageBuffer = [];
					this.nextRetryTime = 0;
					this.reconnectCount = 0;
					this.lastKnownExtensions = '';
					this.lastKnownProtocol = '';
					this.listeners = {};
					if (t == null || typeof t === 'string' || Array.isArray(t)) {
						this.protocols = t;
					} else {
						r = t;
					}
					this.options = applyDefaultOptions(r);
					if (!this.options.wsConstructor) {
						if (typeof WebSocket !== 'undefined') {
							this.options.wsConstructor = WebSocket;
						} else {
							throw new Error(
								'WebSocket not present in global scope and no ' +
									'wsConstructor option was provided.'
							);
						}
					}
					this.openNewWebSocket();
				}
				Object.defineProperty(SturdyWebSocket.prototype, 'binaryType', {
					get: function () {
						return this.binaryTypeInternal || 'blob';
					},
					set: function (e) {
						this.binaryTypeInternal = e;
						if (this.ws) {
							this.ws.binaryType = e;
						}
					},
					enumerable: true,
					configurable: true
				});
				Object.defineProperty(SturdyWebSocket.prototype, 'bufferedAmount', {
					get: function () {
						var e = this.ws ? this.ws.bufferedAmount : 0;
						var t = false;
						this.messageBuffer.forEach(function (r) {
							var s = getDataByteLength(r);
							if (s != null) {
								e += s;
							} else {
								t = true;
							}
						});
						if (t) {
							this.debugLog(
								'Some buffered data had unknown length. bufferedAmount()' +
									' return value may be below the correct amount.'
							);
						}
						return e;
					},
					enumerable: true,
					configurable: true
				});
				Object.defineProperty(SturdyWebSocket.prototype, 'extensions', {
					get: function () {
						return this.ws ? this.ws.extensions : this.lastKnownExtensions;
					},
					enumerable: true,
					configurable: true
				});
				Object.defineProperty(SturdyWebSocket.prototype, 'protocol', {
					get: function () {
						return this.ws ? this.ws.protocol : this.lastKnownProtocol;
					},
					enumerable: true,
					configurable: true
				});
				Object.defineProperty(SturdyWebSocket.prototype, 'readyState', {
					get: function () {
						return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;
					},
					enumerable: true,
					configurable: true
				});
				SturdyWebSocket.prototype.close = function (e, t) {
					this.disposeSocket(e, t);
					this.shutdown();
					this.debugLog('WebSocket permanently closed by client.');
				};
				SturdyWebSocket.prototype.send = function (e) {
					if (this.isClosed) {
						throw new Error('WebSocket is already in CLOSING or CLOSED state.');
					} else if (this.ws && this.ws.readyState === this.OPEN) {
						this.ws.send(e);
					} else {
						this.messageBuffer.push(e);
					}
				};
				SturdyWebSocket.prototype.reconnect = function () {
					if (this.isClosed) {
						throw new Error('Cannot call reconnect() on socket which is permanently closed.');
					}
					this.disposeSocket(1e3, 'Client requested reconnect.');
					this.handleClose(undefined);
				};
				SturdyWebSocket.prototype.addEventListener = function (e, t) {
					if (!this.listeners[e]) {
						this.listeners[e] = [];
					}
					this.listeners[e].push(t);
				};
				SturdyWebSocket.prototype.dispatchEvent = function (e) {
					return this.dispatchEventOfType(e.type, e);
				};
				SturdyWebSocket.prototype.removeEventListener = function (e, t) {
					if (this.listeners[e]) {
						this.listeners[e] = this.listeners[e].filter(function (e) {
							return e !== t;
						});
					}
				};
				SturdyWebSocket.prototype.openNewWebSocket = function () {
					var e = this;
					if (this.isClosed) {
						return;
					}
					var t = this.options,
						r = t.connectTimeout,
						s = t.wsConstructor;
					this.debugLog('Opening new WebSocket to ' + this.url + '.');
					var n = new s(this.url, this.protocols);
					n.onclose = function (t) {
						return e.handleClose(t);
					};
					n.onerror = function (t) {
						return e.handleError(t);
					};
					n.onmessage = function (t) {
						return e.handleMessage(t);
					};
					n.onopen = function (t) {
						return e.handleOpen(t);
					};
					this.connectTimeoutId = setTimeout(function () {
						e.clearConnectTimeout();
						e.disposeSocket();
						e.handleClose(undefined);
					}, r);
					this.ws = n;
				};
				SturdyWebSocket.prototype.handleOpen = function (e) {
					var t = this;
					if (!this.ws || this.isClosed) {
						return;
					}
					var r = this.options.allClearResetTime;
					this.debugLog('WebSocket opened.');
					if (this.binaryTypeInternal != null) {
						this.ws.binaryType = this.binaryTypeInternal;
					} else {
						this.binaryTypeInternal = this.ws.binaryType;
					}
					this.clearConnectTimeout();
					if (this.hasBeenOpened) {
						this.dispatchEventOfType('reopen', e);
					} else {
						this.dispatchEventOfType('open', e);
						this.hasBeenOpened = true;
					}
					this.messageBuffer.forEach(function (e) {
						return t.send(e);
					});
					this.messageBuffer = [];
					this.allClearTimeoutId = setTimeout(function () {
						t.clearAllClearTimeout();
						t.nextRetryTime = 0;
						t.reconnectCount = 0;
						var e = (r / 1e3) | 0;
						t.debugLog(
							'WebSocket remained open for ' + e + ' seconds. Resetting' + ' retry time and count.'
						);
					}, r);
				};
				SturdyWebSocket.prototype.handleMessage = function (e) {
					if (this.isClosed) {
						return;
					}
					this.dispatchEventOfType('message', e);
				};
				SturdyWebSocket.prototype.handleClose = function (e) {
					var t = this;
					if (this.isClosed) {
						return;
					}
					var n = this.options,
						o = n.maxReconnectAttempts,
						i = n.shouldReconnect;
					this.clearConnectTimeout();
					this.clearAllClearTimeout();
					if (this.ws) {
						this.lastKnownExtensions = this.ws.extensions;
						this.lastKnownProtocol = this.ws.protocol;
						this.disposeSocket();
					}
					this.dispatchEventOfType('down', e);
					if (this.reconnectCount >= o) {
						this.stopReconnecting(e, this.getTooManyFailedReconnectsMessage());
						return;
					}
					var l = !e || i(e);
					if (typeof l === 'boolean') {
						this.handleWillReconnect(l, e, r);
					} else {
						l.then(function (r) {
							if (t.isClosed) {
								return;
							}
							t.handleWillReconnect(r, e, s);
						});
					}
				};
				SturdyWebSocket.prototype.handleError = function (e) {
					this.dispatchEventOfType('error', e);
					this.debugLog('WebSocket encountered an error.');
				};
				SturdyWebSocket.prototype.handleWillReconnect = function (e, t, r) {
					if (e) {
						this.reestablishConnection();
					} else {
						this.stopReconnecting(t, r);
					}
				};
				SturdyWebSocket.prototype.reestablishConnection = function () {
					var e = this;
					var t = this.options,
						r = t.minReconnectDelay,
						s = t.maxReconnectDelay,
						n = t.reconnectBackoffFactor;
					this.reconnectCount++;
					var o = this.nextRetryTime;
					this.nextRetryTime = Math.max(r, Math.min(this.nextRetryTime * n, s));
					setTimeout(function () {
						return e.openNewWebSocket();
					}, o);
					var i = (o / 1e3) | 0;
					this.debugLog('WebSocket was closed. Re-opening in ' + i + ' seconds.');
				};
				SturdyWebSocket.prototype.stopReconnecting = function (e, t) {
					this.debugLog(t);
					this.shutdown();
					if (e) {
						this.dispatchEventOfType('close', e);
					}
				};
				SturdyWebSocket.prototype.shutdown = function () {
					this.isClosed = true;
					this.clearAllTimeouts();
					this.messageBuffer = [];
					this.disposeSocket();
				};
				SturdyWebSocket.prototype.disposeSocket = function (e, t) {
					if (!this.ws) {
						return;
					}
					this.ws.onerror = noop;
					this.ws.onclose = noop;
					this.ws.onmessage = noop;
					this.ws.onopen = noop;
					this.ws.close(e, t);
					this.ws = undefined;
				};
				SturdyWebSocket.prototype.clearAllTimeouts = function () {
					this.clearConnectTimeout();
					this.clearAllClearTimeout();
				};
				SturdyWebSocket.prototype.clearConnectTimeout = function () {
					if (this.connectTimeoutId != null) {
						clearTimeout(this.connectTimeoutId);
						this.connectTimeoutId = undefined;
					}
				};
				SturdyWebSocket.prototype.clearAllClearTimeout = function () {
					if (this.allClearTimeoutId != null) {
						clearTimeout(this.allClearTimeoutId);
						this.allClearTimeoutId = undefined;
					}
				};
				SturdyWebSocket.prototype.dispatchEventOfType = function (e, t) {
					var r = this;
					switch (e) {
						case 'close':
							if (this.onclose) {
								this.onclose(t);
							}
							break;
						case 'error':
							if (this.onerror) {
								this.onerror(t);
							}
							break;
						case 'message':
							if (this.onmessage) {
								this.onmessage(t);
							}
							break;
						case 'open':
							if (this.onopen) {
								this.onopen(t);
							}
							break;
						case 'down':
							if (this.ondown) {
								this.ondown(t);
							}
							break;
						case 'reopen':
							if (this.onreopen) {
								this.onreopen(t);
							}
							break;
					}
					if (e in this.listeners) {
						this.listeners[e].slice().forEach(function (e) {
							return r.callListener(e, t);
						});
					}
					return !t || !t.defaultPrevented;
				};
				SturdyWebSocket.prototype.callListener = function (e, t) {
					if (typeof e === 'function') {
						e.call(this, t);
					} else {
						e.handleEvent.call(this, t);
					}
				};
				SturdyWebSocket.prototype.debugLog = function (e) {
					if (this.options.debug) {
						console.log(e);
					}
				};
				SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {
					var e = this.options.maxReconnectAttempts;
					return (
						'Failed to reconnect after ' +
						e +
						' ' +
						pluralize('attempt', e) +
						'. Closing permanently.'
					);
				};
				SturdyWebSocket.DEFAULT_OPTIONS = {
					allClearResetTime: 5e3,
					connectTimeout: 5e3,
					debug: false,
					minReconnectDelay: 1e3,
					maxReconnectDelay: 3e4,
					maxReconnectAttempts: Number.POSITIVE_INFINITY,
					reconnectBackoffFactor: 1.5,
					shouldReconnect: function () {
						return true;
					},
					wsConstructor: undefined
				};
				SturdyWebSocket.CONNECTING = 0;
				SturdyWebSocket.OPEN = 1;
				SturdyWebSocket.CLOSING = 2;
				SturdyWebSocket.CLOSED = 3;
				return SturdyWebSocket;
			})();
			t['default'] = n;
			function applyDefaultOptions(e) {
				var t = {};
				Object.keys(n.DEFAULT_OPTIONS).forEach(function (r) {
					var s = e[r];
					t[r] = s === undefined ? n.DEFAULT_OPTIONS[r] : s;
				});
				return t;
			}
			function getDataByteLength(e) {
				if (typeof e === 'string') {
					return 2 * e.length;
				} else if (e instanceof ArrayBuffer) {
					return e.byteLength;
				} else if (e instanceof Blob) {
					return e.size;
				} else {
					return undefined;
				}
			}
			function pluralize(e, t) {
				return t === 1 ? e : e + 's';
			}
			function noop() {}
		},
		'../../node_modules/.pnpm/websocket@1.0.35/node_modules/websocket/lib/browser.js': (
			e,
			t,
			r
		) => {
			var s;
			if (typeof globalThis === 'object') {
				s = globalThis;
			} else {
				try {
					s = r('../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/global.js');
				} catch (e) {
				} finally {
					if (!s && typeof window !== 'undefined') {
						s = window;
					}
					if (!s) {
						throw new Error('Could not determine global this');
					}
				}
			}
			var n = s.WebSocket || s.MozWebSocket;
			var o = r('../../node_modules/.pnpm/websocket@1.0.35/node_modules/websocket/lib/version.js');
			function W3CWebSocket(e, t) {
				var r;
				if (t) {
					r = new n(e, t);
				} else {
					r = new n(e);
				}
				return r;
			}
			if (n) {
				['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function (e) {
					Object.defineProperty(W3CWebSocket, e, {
						get: function () {
							return n[e];
						}
					});
				});
			}
			e.exports = { w3cwebsocket: n ? W3CWebSocket : null, version: o };
		},
		'../../node_modules/.pnpm/websocket@1.0.35/node_modules/websocket/lib/version.js': (
			e,
			t,
			r
		) => {
			e.exports = r(
				'../../node_modules/.pnpm/websocket@1.0.35/node_modules/websocket/package.json'
			).version;
		},
		'../../node_modules/.pnpm/websocket@1.0.35/node_modules/websocket/package.json': (e) => {
			'use strict';
			e.exports = JSON.parse(
				'{"name":"websocket","description":"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.","keywords":["websocket","websockets","socket","networking","comet","push","RFC-6455","realtime","server","client"],"author":"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)","contributors":["Iñaki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"],"version":"1.0.35","repository":{"type":"git","url":"https://github.com/theturtle32/WebSocket-Node.git"},"homepage":"https://github.com/theturtle32/WebSocket-Node","engines":{"node":">=4.0.0"},"dependencies":{"bufferutil":"^4.0.1","debug":"^2.2.0","es5-ext":"^0.10.63","typedarray-to-buffer":"^3.1.5","utf-8-validate":"^5.0.2","yaeti":"^0.0.6"},"devDependencies":{"buffer-equal":"^1.0.0","gulp":"^4.0.2","gulp-jshint":"^2.0.4","jshint-stylish":"^2.2.1","jshint":"^2.0.0","tape":"^4.9.1"},"config":{"verbose":false},"scripts":{"test":"tape test/unit/*.js","gulp":"gulp"},"main":"index","directories":{"lib":"./lib"},"browser":"lib/browser.js","license":"Apache-2.0"}'
			);
		}
	}
]);
//# sourceMappingURL=node_modules_pnpm_alchemy-sdk_3_5_1_bufferutil_4_0_9_utf-8-validate_5_0_10_node_modules_alche-9b54f3.js.map
