{"version":3,"file":"257.js","mappings":"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","sources":["webpack://yakkl-wallet/../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/ws.js","webpack://yakkl-wallet/../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js","webpack://yakkl-wallet/../../node_modules/.pnpm/alchemy-sdk@3.5.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-948c1ea8.js","webpack://yakkl-wallet/../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/global.js","webpack://yakkl-wallet/../../node_modules/.pnpm/sturdy-websocket@0.2.1/node_modules/sturdy-websocket/dist/index.js","webpack://yakkl-wallet/../../node_modules/.pnpm/websocket@1.0.35/node_modules/websocket/lib/browser.js","webpack://yakkl-wallet/../../node_modules/.pnpm/websocket@1.0.35/node_modules/websocket/lib/version.js"],"sourcesContent":["\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nlet WS = null;\ntry {\n    WS = WebSocket;\n    if (WS == null) {\n        throw new Error(\"inject please\");\n    }\n}\ncatch (error) {\n    const logger = new Logger(version);\n    WS = function () {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    };\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n//# sourceMappingURL=ws.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\nlet NextId = 1;\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\nexport class WebSocketProvider extends JsonRpcProvider {\n    constructor(url, network) {\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n        if (typeof (url) === \"string\") {\n            super(url, network);\n        }\n        else {\n            super(\"_websocket\", network);\n        }\n        this._pollingInterval = -1;\n        this._wsReady = false;\n        if (typeof (url) === \"string\") {\n            defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        }\n        else {\n            defineReadOnly(this, \"_websocket\", url);\n        }\n        defineReadOnly(this, \"_requests\", {});\n        defineReadOnly(this, \"_subs\", {});\n        defineReadOnly(this, \"_subIds\", {});\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n        // Stall sending requests until the socket is open...\n        this.websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this.websocket.send(this._requests[id].payload);\n            });\n        };\n        this.websocket.onmessage = (messageEvent) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n                }\n                else {\n                    let error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(error, \"code\", result.error.code || null);\n                        defineReadOnly(error, \"response\", data);\n                    }\n                    else {\n                        error = new Error(\"unknown error\");\n                    }\n                    request.callback(error, undefined);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n                }\n            }\n            else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result);\n                }\n            }\n            else {\n                console.warn(\"this should not happen\");\n            }\n        };\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) {\n            fauxPoll.unref();\n        }\n    }\n    // Cannot narrow the type of _websocket, as that is not backwards compatible\n    // so we add a getter and let the WebSocket be a public API.\n    get websocket() { return this._websocket; }\n    detectNetwork() {\n        return this._detectNetwork;\n    }\n    get pollingInterval() {\n        return 0;\n    }\n    resetEventsBlock(blockNumber) {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n    set pollingInterval(value) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return null;\n        });\n    }\n    set polling(value) {\n        if (!value) {\n            return;\n        }\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n    send(method, params) {\n        const rid = NextId++;\n        return new Promise((resolve, reject) => {\n            function callback(error, result) {\n                if (error) {\n                    return reject(error);\n                }\n                return resolve(result);\n            }\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n            this._requests[String(rid)] = { callback, payload };\n            if (this._wsReady) {\n                this.websocket.send(payload);\n            }\n        });\n    }\n    static defaultUrl() {\n        return \"ws:/\\/localhost:8546\";\n    }\n    _subscribe(tag, param, processFunc) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let subIdPromise = this._subIds[tag];\n            if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then((param) => {\n                    return this.send(\"eth_subscribe\", param);\n                });\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            this._subs[subId] = { tag, processFunc };\n        });\n    }\n    _startEvent(event) {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [\"newHeads\"], (result) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n            case \"pending\":\n                this._subscribe(\"pending\", [\"newPendingTransactions\"], (result) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n            case \"filter\":\n                this._subscribe(event.tag, [\"logs\", this._getFilter(event.filter)], (result) => {\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n            case \"tx\": {\n                const emitReceipt = (event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) {\n                            return;\n                        }\n                        this.emit(hash, receipt);\n                    });\n                };\n                // In case it is already mined\n                emitReceipt(event);\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [\"newHeads\"], (result) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n    _stopEvent(event) {\n        let tag = event.tag;\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        }\n        else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        const subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        subId.then((subId) => {\n            if (!this._subs[subId]) {\n                return;\n            }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [subId]);\n        });\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Wait until we have connected before trying to disconnect\n            if (this.websocket.readyState === WebSocket.CONNECTING) {\n                yield (new Promise((resolve) => {\n                    this.websocket.onopen = function () {\n                        resolve(true);\n                    };\n                    this.websocket.onerror = function () {\n                        resolve(false);\n                    };\n                }));\n            }\n            // Hangup\n            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n            this.websocket.close(1000);\n        });\n    }\n}\n//# sourceMappingURL=websocket-provider.js.map","import { _ as __awaiter, f as fromHex, t as toHex, n as noop, C as CustomNetworks, i as isAlchemyEvent, v as verifyAlchemyEventName, c as EthersEvent, e as getAlchemyEventTag, D as DEFAULT_ALCHEMY_API_KEY, A as ALCHEMY_EVENT_TYPES, h as ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE, j as AlchemySubscription, k as ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE, V as VERSION, E as EthersNetwork } from './index-1789de96.js';\nimport SturdyWebSocket from 'sturdy-websocket';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { getNetwork } from '@ethersproject/networks';\nimport { WebSocketProvider } from '@ethersproject/providers';\nimport { AlchemyProvider } from './alchemy-provider-8b0c3e20.js';\nimport './api/utils';\nimport 'axios';\nimport '@ethersproject/abstract-provider';\nimport '@ethersproject/wallet';\nimport '@ethersproject/contracts';\nimport '@ethersproject/web';\n\n/**\r\n * The maximum number of blocks to backfill. If more than this many blocks have\r\n * been missed, then we'll sadly miss data, but we want to make sure we don't\r\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\r\n */\r\nconst MAX_BACKFILL_BLOCKS = 120;\r\n/**\r\n * The WebsocketBackfiller fetches events that were sent since a provided block\r\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\r\n * events that were transmitted while the websocket connection was down.\r\n *\r\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\r\n *\r\n * @internal\r\n */\r\nclass WebsocketBackfiller {\r\n    constructor(provider) {\r\n        this.provider = provider;\r\n        // TODO: Use HTTP provider to do backfill.\r\n        this.maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\r\n    }\r\n    /**\r\n     * Runs backfill for `newHeads` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param previousHeads Previous head requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     * @returns A list of `newHeads` events that were sent since the last backfill.\r\n     */\r\n    getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous heads to fetch, return new heads since\r\n            // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\r\n            if (previousHeads.length === 0) {\r\n                return this.getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted event is too far back in the past, there's no need\r\n            // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\r\n            // new heads.\r\n            const lastSeenBlockNumber = fromHex(previousHeads[previousHeads.length - 1].number);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber <= minBlockNumber) {\r\n                return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // To capture all `newHeads` events, return all head events from the last\r\n            // seen block number to current + any of the previous heads that were re-orged.\r\n            const reorgHeads = yield this.getReorgHeads(isCancelled, previousHeads);\r\n            throwIfCancelled(isCancelled);\r\n            const intermediateHeads = yield this.getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1);\r\n            throwIfCancelled(isCancelled);\r\n            return [...reorgHeads, ...intermediateHeads];\r\n        });\r\n    }\r\n    /**\r\n     * Runs backfill for `logs` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param filter The filter object that accompanies a logs subscription.\r\n     * @param previousLogs Previous log requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     */\r\n    getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous logs to fetch, return new logs since\r\n            // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\r\n            if (previousLogs.length === 0) {\r\n                return this.getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted log is too far back in the past, there's no need\r\n            // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\r\n            // worth of logs.\r\n            const lastSeenBlockNumber = fromHex(previousLogs[previousLogs.length - 1].blockNumber);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber < minBlockNumber) {\r\n                return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // Return all log events that have happened along with log events that have\r\n            // been removed due to a chain reorg.\r\n            const commonAncestor = yield this.getCommonAncestor(isCancelled, previousLogs);\r\n            throwIfCancelled(isCancelled);\r\n            // All previous logs with a block number greater than the common ancestor\r\n            // were part of a re-org, so mark them as such.\r\n            const removedLogs = previousLogs\r\n                .filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber)\r\n                .map(log => (Object.assign(Object.assign({}, log), { removed: true })));\r\n            // If no common ancestor was found, start backfill from the oldest log's\r\n            // block number.\r\n            const fromBlockInclusive = commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\r\n                ? fromHex(previousLogs[0].blockNumber)\r\n                : commonAncestor.blockNumber;\r\n            let addedLogs = yield this.getLogsInRange(filter, fromBlockInclusive, toBlockNumber + 1);\r\n            // De-dupe any logs that were already emitted.\r\n            addedLogs = addedLogs.filter(log => log &&\r\n                (fromHex(log.blockNumber) > commonAncestor.blockNumber ||\r\n                    fromHex(log.logIndex) > commonAncestor.logIndex));\r\n            throwIfCancelled(isCancelled);\r\n            return [...removedLogs, ...addedLogs];\r\n        });\r\n    }\r\n    /**\r\n     * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */\r\n    setMaxBackfillBlock(newMax) {\r\n        this.maxBackfillBlocks = newMax;\r\n    }\r\n    /**\r\n     * Gets the current block number as a number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockNumber() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const blockNumberHex = yield this.provider.send('eth_blockNumber');\r\n            return fromHex(blockNumberHex);\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `newHead` events in the provided range. Note that the returned\r\n     * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\r\n     * that were part of a re-org.\r\n     *\r\n     * @private\r\n     */\r\n    getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const batchParts = [];\r\n            for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\r\n                batchParts.push({\r\n                    method: 'eth_getBlockByNumber',\r\n                    params: [toHex(i), false]\r\n                });\r\n            }\r\n            // TODO: handle errors\r\n            const blockHeads = yield this.provider.sendBatch(batchParts);\r\n            return blockHeads.map(toNewHeadsEvent);\r\n        });\r\n    }\r\n    /**\r\n     * Returns all heads that were part of a reorg event.\r\n     *\r\n     * @private\r\n     */\r\n    getReorgHeads(isCancelled, previousHeads) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const result = [];\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            for (let i = previousHeads.length - 1; i >= 0; i--) {\r\n                const oldEvent = previousHeads[i];\r\n                const blockHead = yield this.getBlockByNumber(fromHex(oldEvent.number));\r\n                throwIfCancelled(isCancelled);\r\n                // If the hashes match, then current head in the iteration was not re-orged.\r\n                if (oldEvent.hash === blockHead.hash) {\r\n                    break;\r\n                }\r\n                result.push(toNewHeadsEvent(blockHead));\r\n            }\r\n            return result.reverse();\r\n        });\r\n    }\r\n    /**\r\n     * Simple wrapper around `eth_getBlockByNumber` that returns the complete\r\n     * block information for the provided block number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockByNumber(blockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this.provider.send('eth_getBlockByNumber', [\r\n                toHex(blockNumber),\r\n                false\r\n            ]);\r\n        });\r\n    }\r\n    /**\r\n     * Given a list of previous log events, finds the common block number from the\r\n     * logs that matches the block head.\r\n     *\r\n     * This can be used to identify which logs are part of a re-org.\r\n     *\r\n     * Returns 1 less than the oldest log's block number if no common ancestor was found.\r\n     *\r\n     * @private\r\n     */\r\n    getCommonAncestor(isCancelled, previousLogs) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            let blockHead = yield this.getBlockByNumber(fromHex(previousLogs[previousLogs.length - 1].blockNumber));\r\n            throwIfCancelled(isCancelled);\r\n            for (let i = previousLogs.length - 1; i >= 0; i--) {\r\n                const oldLog = previousLogs[i];\r\n                // Ensure that updated blocks are fetched every time the log's block number\r\n                // changes.\r\n                if (oldLog.blockNumber !== blockHead.number) {\r\n                    blockHead = yield this.getBlockByNumber(fromHex(oldLog.blockNumber));\r\n                }\r\n                // Since logs are ordered in ascending order, the first log that matches\r\n                // the hash should be the largest logIndex.\r\n                if (oldLog.blockHash === blockHead.hash) {\r\n                    return {\r\n                        blockNumber: fromHex(oldLog.blockNumber),\r\n                        logIndex: fromHex(oldLog.logIndex)\r\n                    };\r\n                }\r\n            }\r\n            return {\r\n                blockNumber: Number.NEGATIVE_INFINITY,\r\n                logIndex: Number.NEGATIVE_INFINITY\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `logs` events in the provided range. Note that the returned logs\r\n     * do not include removed logs.\r\n     *\r\n     * @private\r\n     */ getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const rangeFilter = Object.assign(Object.assign({}, filter), { fromBlock: toHex(fromBlockInclusive), toBlock: toHex(toBlockExclusive - 1) });\r\n            return this.provider.send('eth_getLogs', [rangeFilter]);\r\n        });\r\n    }\r\n}\r\nfunction toNewHeadsEvent(head) {\r\n    const result = Object.assign({}, head);\r\n    delete result.totalDifficulty;\r\n    delete result.transactions;\r\n    delete result.uncles;\r\n    return result;\r\n}\r\nfunction dedupeNewHeads(events) {\r\n    return dedupe(events, event => event.hash);\r\n}\r\nfunction dedupeLogs(events) {\r\n    return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\r\n}\r\nfunction dedupe(items, getKey) {\r\n    const keysSeen = new Set();\r\n    const result = [];\r\n    items.forEach(item => {\r\n        const key = getKey(item);\r\n        if (!keysSeen.has(key)) {\r\n            keysSeen.add(key);\r\n            result.push(item);\r\n        }\r\n    });\r\n    return result;\r\n}\r\nconst CANCELLED = new Error('Cancelled');\r\nfunction throwIfCancelled(isCancelled) {\r\n    if (isCancelled()) {\r\n        throw CANCELLED;\r\n    }\r\n}\n\nconst HEARTBEAT_INTERVAL = 30000;\r\nconst HEARTBEAT_WAIT_TIME = 10000;\r\nconst BACKFILL_TIMEOUT = 60000;\r\nconst BACKFILL_RETRIES = 5;\r\n/**\r\n * Subscriptions have a memory of recent events they have sent so that in the\r\n * event that they disconnect and need to backfill, they can detect re-orgs.\r\n * Keep a buffer that goes back at least these many blocks, the maximum amount\r\n * at which we might conceivably see a re-org.\r\n *\r\n * Note that while our buffer goes back this many blocks, it may contain more\r\n * than this many elements, since in the case of logs subscriptions more than\r\n * one event may be emitted for a block.\r\n */\r\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\r\n/**\r\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\r\n *\r\n * @public\r\n */\r\nclass AlchemyWebSocketProvider extends WebSocketProvider {\r\n    /** @internal */\r\n    constructor(config, wsConstructor) {\r\n        var _a;\r\n        // Normalize the API Key to a string.\r\n        const apiKey = AlchemyProvider.getApiKey(config.apiKey);\r\n        // Generate our own connection info with the correct endpoint URLs.\r\n        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\r\n        const connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'wss');\r\n        const protocol = `alchemy-sdk-${VERSION}`;\r\n        // Use the provided config URL override if it exists, otherwise use the created one.\r\n        const ws = new SturdyWebSocket((_a = config.url) !== null && _a !== void 0 ? _a : connection.url, protocol, {\r\n            wsConstructor: wsConstructor !== null && wsConstructor !== void 0 ? wsConstructor : getWebsocketConstructor()\r\n        });\r\n        // Normalize the Alchemy named network input to the network names used by\r\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\r\n        // correctly set the network.\r\n        const ethersNetwork = EthersNetwork[alchemyNetwork];\r\n        super(ws, ethersNetwork);\r\n        this._events = [];\r\n        // In the case of a WebSocket reconnection, all subscriptions are lost and we\r\n        // create new ones to replace them, but we want to create the illusion that\r\n        // the original subscriptions persist. Thus, maintain a mapping from the\r\n        // \"virtual\" subscription ids which are visible to the consumer to the\r\n        // \"physical\" subscription ids of the actual connections. This terminology is\r\n        // borrowed from virtual and physical memory, which has a similar mapping.\r\n        /** @internal */\r\n        this.virtualSubscriptionsById = new Map();\r\n        /** @internal */\r\n        this.virtualIdsByPhysicalId = new Map();\r\n        /**\r\n         * The underlying ethers {@link WebSocketProvider} already handles and emits\r\n         * messages. To allow backfilling, track all messages that are emitted.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleMessage = (event) => {\r\n            const message = JSON.parse(event.data);\r\n            if (!isSubscriptionEvent(message)) {\r\n                return;\r\n            }\r\n            const physicalId = message.params.subscription;\r\n            const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\r\n            if (!virtualId) {\r\n                return;\r\n            }\r\n            const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n            if (subscription.method !== 'eth_subscribe') {\r\n                return;\r\n            }\r\n            switch (subscription.params[0]) {\r\n                case 'newHeads': {\r\n                    const newHeadsSubscription = subscription;\r\n                    const newHeadsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = newHeadsSubscription;\r\n                    const { result } = newHeadsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToNewHeadsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    else {\r\n                        // Ethers subscription mapping will emit the event, just store it.\r\n                        this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                case 'logs': {\r\n                    const logsSubscription = subscription;\r\n                    const logsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = logsSubscription;\r\n                    const { result } = logsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToLogsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (virtualId !== physicalId) {\r\n                        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    else {\r\n                        this.rememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        const { result } = message.params;\r\n                        this.emitEvent(virtualId, result);\r\n                    }\r\n            }\r\n        };\r\n        /**\r\n         * When the websocket connection reopens:\r\n         *\r\n         * 1. Resubscribe to all existing subscriptions and start backfilling\r\n         * 2. Restart heart beat.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleReopen = () => {\r\n            this.virtualIdsByPhysicalId.clear();\r\n            const { cancel, isCancelled } = makeCancelToken();\r\n            this.cancelBackfill = cancel;\r\n            for (const subscription of this.virtualSubscriptionsById.values()) {\r\n                void (() => __awaiter(this, void 0, void 0, function* () {\r\n                    try {\r\n                        yield this.resubscribeAndBackfill(isCancelled, subscription);\r\n                    }\r\n                    catch (error) {\r\n                        if (!isCancelled()) {\r\n                            console.error(`Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`, error);\r\n                        }\r\n                    }\r\n                }))();\r\n            }\r\n            this.startHeartbeat();\r\n        };\r\n        /**\r\n         * Cancels the heartbeat and any pending backfills being performed. This is\r\n         * called when the websocket connection goes down or is disconnected.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.stopHeartbeatAndBackfill = () => {\r\n            if (this.heartbeatIntervalId != null) {\r\n                clearInterval(this.heartbeatIntervalId);\r\n                this.heartbeatIntervalId = undefined;\r\n            }\r\n            this.cancelBackfill();\r\n        };\r\n        this.apiKey = apiKey;\r\n        // Start heartbeat and backfiller for the websocket connection.\r\n        this.backfiller = new WebsocketBackfiller(this);\r\n        this.addSocketListeners();\r\n        this.startHeartbeat();\r\n        this.cancelBackfill = noop;\r\n    }\r\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getNetwork(network) {\r\n        if (typeof network === 'string' && network in CustomNetworks) {\r\n            return CustomNetworks[network];\r\n        }\r\n        // Call the standard ethers.js getNetwork method for other networks.\r\n        return getNetwork(network);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based subscriptions.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    on(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, false);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based\r\n     * subscriptions. Adds a listener to the triggered for only the next\r\n     * {@link eventName} event, after which it will be removed.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    once(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, true);\r\n    }\r\n    /**\r\n     * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n     * listener is provided, all listeners for the event will be removed.\r\n     *\r\n     * @param eventName Event to unlisten to.\r\n     * @param listener The listener function to remove.\r\n     * @override\r\n     * @public\r\n     */\r\n    off(eventName, listener) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            return this._off(eventName, listener);\r\n        }\r\n        else {\r\n            return super.off(eventName, listener);\r\n        }\r\n    }\r\n    /**\r\n     * Remove all listeners for the provided {@link eventName} event. If no event\r\n     * is provided, all events and their listeners are removed.\r\n     *\r\n     * @param eventName The event to remove all listeners for.\r\n     * @override\r\n     * @public\r\n     */\r\n    removeAllListeners(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._removeAllListeners(eventName);\r\n        }\r\n        else {\r\n            return super.removeAllListeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the number of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, the total number of listeners for all events is returned.\r\n     *\r\n     * @param eventName The event to get the number of listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listenerCount(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._listenerCount(eventName);\r\n        }\r\n        else {\r\n            return super.listenerCount(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns an array of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, all listeners will be included.\r\n     *\r\n     * @param eventName The event to get the listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listeners(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._listeners(eventName);\r\n        }\r\n        else {\r\n            return super.listeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the method in `BaseProvider` in order to properly format the\r\n     * Alchemy subscription events.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _addEventListener(eventName, listener, once) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            verifyAlchemyEventName(eventName);\r\n            const event = new EthersEvent(getAlchemyEventTag(eventName), listener, once);\r\n            this._events.push(event);\r\n            this._startEvent(event);\r\n            return this;\r\n        }\r\n        else {\r\n            return super._addEventListener(eventName, listener, once);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the `_startEvent()` method in ethers.js's\r\n     * {@link WebSocketProvider} to include additional alchemy methods.\r\n     *\r\n     * @param event\r\n     * @override\r\n     * @internal\r\n     */\r\n    _startEvent(event) {\r\n        // Check if the event type is a custom Alchemy subscription.\r\n        const customLogicTypes = [...ALCHEMY_EVENT_TYPES, 'block', 'filter'];\r\n        if (customLogicTypes.includes(event.type)) {\r\n            this.customStartEvent(event);\r\n        }\r\n        else {\r\n            super._startEvent(event);\r\n        }\r\n    }\r\n    /**\r\n     * Overridden from ethers.js's {@link WebSocketProvider}\r\n     *\r\n     * Modified in order to add mappings for backfilling.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _subscribe(tag, param, processFunc, event) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let subIdPromise = this._subIds[tag];\r\n            // BEGIN MODIFIED CODE\r\n            const startingBlockNumber = yield this.getBlockNumber();\r\n            // END MODIFIED CODE\r\n            if (subIdPromise == null) {\r\n                subIdPromise = Promise.all(param).then(param => {\r\n                    return this.send('eth_subscribe', param);\r\n                });\r\n                this._subIds[tag] = subIdPromise;\r\n            }\r\n            const subId = yield subIdPromise;\r\n            // BEGIN MODIFIED CODE\r\n            const resolvedParams = yield Promise.all(param);\r\n            this.virtualSubscriptionsById.set(subId, {\r\n                event: event,\r\n                method: 'eth_subscribe',\r\n                params: resolvedParams,\r\n                startingBlockNumber,\r\n                virtualId: subId,\r\n                physicalId: subId,\r\n                sentEvents: [],\r\n                isBackfilling: false,\r\n                backfillBuffer: []\r\n            });\r\n            this.virtualIdsByPhysicalId.set(subId, subId);\r\n            // END MODIFIED CODE\r\n            this._subs[subId] = { tag, processFunc };\r\n        });\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    emit(eventName, ...args) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            let result = false;\r\n            const stopped = [];\r\n            // This line is the only modified line from the original method.\r\n            const eventTag = getAlchemyEventTag(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                setTimeout(() => {\r\n                    event.listener.apply(this, args);\r\n                }, 0);\r\n                result = true;\r\n                if (event.once) {\r\n                    stopped.push(event);\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n            stopped.forEach(event => {\r\n                this._stopEvent(event);\r\n            });\r\n            return result;\r\n        }\r\n        else {\r\n            return super.emit(eventName, ...args);\r\n        }\r\n    }\r\n    /** @internal */\r\n    sendBatch(parts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let nextId = 0;\r\n            const payload = parts.map(({ method, params }) => {\r\n                return {\r\n                    method,\r\n                    params,\r\n                    jsonrpc: '2.0',\r\n                    id: `alchemy-sdk:${nextId++}`\r\n                };\r\n            });\r\n            return this.sendBatchConcurrently(payload);\r\n        });\r\n    }\r\n    /** @override */\r\n    destroy() {\r\n        this.removeSocketListeners();\r\n        this.stopHeartbeatAndBackfill();\r\n        return super.destroy();\r\n    }\r\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\r\n    isCommunityResource() {\r\n        return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\r\n     *\r\n     * This method is copied over directly in order to support Alchemy's\r\n     * subscription type by allowing the provider to properly stop Alchemy's\r\n     * subscription events.\r\n     *\r\n     * @internal\r\n     */\r\n    _stopEvent(event) {\r\n        let tag = event.tag;\r\n        // START MODIFIED CODE\r\n        if (ALCHEMY_EVENT_TYPES.includes(event.type)) {\r\n            // There are remaining pending transaction listeners.\r\n            if (this._events.filter(e => ALCHEMY_EVENT_TYPES.includes(e.type)).length) {\r\n                return;\r\n            }\r\n            // END MODIFIED CODE\r\n        }\r\n        else if (event.type === 'tx') {\r\n            // There are remaining transaction event listeners\r\n            if (this._events.filter(e => e.type === 'tx').length) {\r\n                return;\r\n            }\r\n            tag = 'tx';\r\n        }\r\n        else if (this.listenerCount(event.event)) {\r\n            // There are remaining event listeners\r\n            return;\r\n        }\r\n        const subId = this._subIds[tag];\r\n        if (!subId) {\r\n            return;\r\n        }\r\n        delete this._subIds[tag];\r\n        void subId.then(subId => {\r\n            if (!this._subs[subId]) {\r\n                return;\r\n            }\r\n            delete this._subs[subId];\r\n            void this.send('eth_unsubscribe', [subId]);\r\n        });\r\n    }\r\n    /** @internal */\r\n    addSocketListeners() {\r\n        this._websocket.addEventListener('message', this.handleMessage);\r\n        this._websocket.addEventListener('reopen', this.handleReopen);\r\n        this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /** @internal */\r\n    removeSocketListeners() {\r\n        this._websocket.removeEventListener('message', this.handleMessage);\r\n        this._websocket.removeEventListener('reopen', this.handleReopen);\r\n        this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /**\r\n     * Reopens the backfill based on\r\n     *\r\n     * @param isCancelled\r\n     * @param subscription\r\n     * @internal\r\n     */\r\n    resubscribeAndBackfill(isCancelled, subscription) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { virtualId, method, params, sentEvents, backfillBuffer, startingBlockNumber } = subscription;\r\n            subscription.isBackfilling = true;\r\n            backfillBuffer.length = 0;\r\n            try {\r\n                const physicalId = yield this.send(method, params);\r\n                throwIfCancelled(isCancelled);\r\n                subscription.physicalId = physicalId;\r\n                this.virtualIdsByPhysicalId.set(physicalId, virtualId);\r\n                switch (params[0]) {\r\n                    case 'newHeads': {\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    case 'logs': {\r\n                        const filter = params[1] || {};\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getLogsBackfill(isCancelled, filter, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitLogsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n            finally {\r\n                subscription.isBackfilling = false;\r\n                backfillBuffer.length = 0;\r\n            }\r\n        });\r\n    }\r\n    /** @internal */\r\n    emitNewHeadsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitLogsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n    }\r\n    /**\r\n     * Emits an event to consumers, but also remembers it in its subscriptions's\r\n     * `sentEvents` buffer so that we can detect re-orgs if the connection drops\r\n     * and needs to be reconnected.\r\n     *\r\n     * @internal\r\n     */\r\n    emitAndRememberEvent(virtualId, result, getBlockNumber) {\r\n        this.rememberEvent(virtualId, result, getBlockNumber);\r\n        this.emitEvent(virtualId, result);\r\n    }\r\n    emitEvent(virtualId, result) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        this.emitGenericEvent(subscription, result);\r\n    }\r\n    /** @internal */\r\n    rememberEvent(virtualId, result, getBlockNumber) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        // Web3 modifies these event objects once we pass them on (changing hex\r\n        // numbers to numbers). We want the original event, so make a defensive\r\n        // copy.\r\n        addToPastEventsBuffer(subscription.sentEvents, Object.assign({}, result), getBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitGenericEvent(subscription, result) {\r\n        const emitFunction = this.emitProcessFn(subscription.event);\r\n        emitFunction(result);\r\n    }\r\n    /**\r\n     * Starts a heartbeat that pings the websocket server periodically to ensure\r\n     * that the connection stays open.\r\n     *\r\n     * @internal\r\n     */\r\n    startHeartbeat() {\r\n        if (this.heartbeatIntervalId != null) {\r\n            return;\r\n        }\r\n        this.heartbeatIntervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                yield withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\r\n            }\r\n            catch (_a) {\r\n                this._websocket.reconnect();\r\n            }\r\n        }), HEARTBEAT_INTERVAL);\r\n    }\r\n    /**\r\n     * This method sends the batch concurrently as individual requests rather than\r\n     * as a batch, which was the original implementation. The original batch logic\r\n     * is preserved in this implementation in order for faster porting.\r\n     *\r\n     * @param payload\r\n     * @internal\r\n     */\r\n    // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\r\n    // TODO(errors): Use allSettled() once we have more error handling.\r\n    sendBatchConcurrently(payload) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return Promise.all(payload.map(req => this.send(req.method, req.params)));\r\n        });\r\n    }\r\n    /** @internal */\r\n    customStartEvent(event) {\r\n        if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\r\n            const { fromAddress, toAddress, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                AlchemySubscription.PENDING_TRANSACTIONS,\r\n                { fromAddress, toAddress, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\r\n            const { addresses, includeRemoved, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                AlchemySubscription.MINED_TRANSACTIONS,\r\n                { addresses, includeRemoved, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'block') {\r\n            void this._subscribe('block', ['newHeads'], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'filter') {\r\n            void this._subscribe(event.tag, ['logs', this._getFilter(event.filter)], this.emitProcessFn(event), event);\r\n        }\r\n    }\r\n    /** @internal */\r\n    emitProcessFn(event) {\r\n        switch (event.type) {\r\n            case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\r\n                return result => this.emit({\r\n                    method: AlchemySubscription.PENDING_TRANSACTIONS,\r\n                    fromAddress: event.fromAddress,\r\n                    toAddress: event.toAddress,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\r\n                return result => this.emit({\r\n                    method: AlchemySubscription.MINED_TRANSACTIONS,\r\n                    addresses: event.addresses,\r\n                    includeRemoved: event.includeRemoved,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case 'block':\r\n                return result => {\r\n                    const blockNumber = BigNumber.from(result.number).toNumber();\r\n                    this._emitted.block = blockNumber;\r\n                    this.emit('block', blockNumber);\r\n                };\r\n            case 'filter':\r\n                return result => {\r\n                    if (result.removed == null) {\r\n                        result.removed = false;\r\n                    }\r\n                    this.emit(event.filter, this.formatter.filterLog(result));\r\n                };\r\n            default:\r\n                throw new Error('Invalid event type to `emitProcessFn()`');\r\n        }\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.off()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _off(eventName, listener) {\r\n        if (listener == null) {\r\n            return this.removeAllListeners(eventName);\r\n        }\r\n        const stopped = [];\r\n        let found = false;\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        this._events = this._events.filter(event => {\r\n            if (event.tag !== eventTag || event.listener != listener) {\r\n                return true;\r\n            }\r\n            if (found) {\r\n                return true;\r\n            }\r\n            found = true;\r\n            stopped.push(event);\r\n            return false;\r\n        });\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _removeAllListeners(eventName) {\r\n        let stopped = [];\r\n        if (eventName == null) {\r\n            stopped = this._events;\r\n            this._events = [];\r\n        }\r\n        else {\r\n            const eventTag = getAlchemyEventTag(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                stopped.push(event);\r\n                return false;\r\n            });\r\n        }\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listenerCount(eventName) {\r\n        if (!eventName) {\r\n            return this._events.length;\r\n        }\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        return this._events.filter(event => {\r\n            return event.tag === eventTag;\r\n        }).length;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listeners(eventName) {\r\n        if (eventName == null) {\r\n            return this._events.map(event => event.listener);\r\n        }\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        return this._events\r\n            .filter(event => event.tag === eventTag)\r\n            .map(event => event.listener);\r\n    }\r\n}\r\nfunction getWebsocketConstructor() {\r\n    return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\r\n}\r\nfunction isNodeEnvironment() {\r\n    return (typeof process !== 'undefined' &&\r\n        process != null &&\r\n        process.versions != null &&\r\n        process.versions.node != null);\r\n}\r\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\r\nfunction makeCancelToken() {\r\n    let cancelled = false;\r\n    return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\r\n}\r\n// TODO(cleanup): replace with SDK's backoff implementation\r\nconst MIN_RETRY_DELAY = 1000;\r\nconst RETRY_BACKOFF_FACTOR = 2;\r\nconst MAX_RETRY_DELAY = 30000;\r\nfunction withBackoffRetries(f, retryCount, shouldRetry = () => true) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let nextWaitTime = 0;\r\n        let i = 0;\r\n        while (true) {\r\n            try {\r\n                return yield f();\r\n            }\r\n            catch (error) {\r\n                i++;\r\n                if (i >= retryCount || !shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                yield delay(nextWaitTime);\r\n                if (!shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                nextWaitTime =\r\n                    nextWaitTime === 0\r\n                        ? MIN_RETRY_DELAY\r\n                        : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction delay(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\nfunction withTimeout(promise, ms) {\r\n    return Promise.race([\r\n        promise,\r\n        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), ms))\r\n    ]);\r\n}\r\nfunction getNewHeadsBlockNumber(event) {\r\n    return fromHex(event.number);\r\n}\r\nfunction getLogsBlockNumber(event) {\r\n    return fromHex(event.blockNumber);\r\n}\r\nfunction isResponse(message) {\r\n    return (Array.isArray(message) ||\r\n        (message.jsonrpc === '2.0' && message.id !== undefined));\r\n}\r\nfunction isSubscriptionEvent(message) {\r\n    return !isResponse(message);\r\n}\r\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\r\n}\r\nfunction addToLogsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\r\n}\r\n/**\r\n * Adds a new event to an array of events, evicting any events which are so old\r\n * that they will no longer feasibly be part of a reorg.\r\n */\r\nfunction addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\r\n    const currentBlockNumber = getBlockNumber(event);\r\n    // Find first index of an event recent enough to retain, then drop everything\r\n    // at a lower index.\r\n    const firstGoodIndex = pastEvents.findIndex(e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT);\r\n    if (firstGoodIndex === -1) {\r\n        pastEvents.length = 0;\r\n    }\r\n    else {\r\n        pastEvents.splice(0, firstGoodIndex);\r\n    }\r\n    pastEvents.push(event);\r\n}\n\nexport { AlchemyWebSocketProvider };\n//# sourceMappingURL=alchemy-websocket-provider-948c1ea8.js.map\n","var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Fallback to standard globalThis if available\n\tif (typeof globalThis === \"object\" && globalThis) return globalThis;\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of updates to Object.prototype being restricted\n\t\t// via preventExtensions, seal or freeze\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ works, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\nvar SturdyWebSocket = /** @class */ (function () {\n    function SturdyWebSocket(url, protocolsOrOptions, options) {\n        if (options === void 0) { options = {}; }\n        this.url = url;\n        this.onclose = null;\n        this.onerror = null;\n        this.onmessage = null;\n        this.onopen = null;\n        this.ondown = null;\n        this.onreopen = null;\n        this.CONNECTING = SturdyWebSocket.CONNECTING;\n        this.OPEN = SturdyWebSocket.OPEN;\n        this.CLOSING = SturdyWebSocket.CLOSING;\n        this.CLOSED = SturdyWebSocket.CLOSED;\n        this.hasBeenOpened = false;\n        this.isClosed = false;\n        this.messageBuffer = [];\n        this.nextRetryTime = 0;\n        this.reconnectCount = 0;\n        this.lastKnownExtensions = \"\";\n        this.lastKnownProtocol = \"\";\n        this.listeners = {};\n        if (protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)) {\n            this.protocols = protocolsOrOptions;\n        }\n        else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            }\n            else {\n                throw new Error(\"WebSocket not present in global scope and no \" +\n                    \"wsConstructor option was provided.\");\n            }\n        }\n        this.openNewWebSocket();\n    }\n    Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n        get: function () {\n            return this.binaryTypeInternal || \"blob\";\n        },\n        set: function (binaryType) {\n            this.binaryTypeInternal = binaryType;\n            if (this.ws) {\n                this.ws.binaryType = binaryType;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n        get: function () {\n            var sum = this.ws ? this.ws.bufferedAmount : 0;\n            var hasUnknownAmount = false;\n            this.messageBuffer.forEach(function (data) {\n                var byteLength = getDataByteLength(data);\n                if (byteLength != null) {\n                    sum += byteLength;\n                }\n                else {\n                    hasUnknownAmount = true;\n                }\n            });\n            if (hasUnknownAmount) {\n                this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\");\n            }\n            return sum;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n        get: function () {\n            return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n        get: function () {\n            return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n        get: function () {\n            return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SturdyWebSocket.prototype.close = function (code, reason) {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    };\n    SturdyWebSocket.prototype.send = function (data) {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        }\n        else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        }\n        else {\n            this.messageBuffer.push(data);\n        }\n    };\n    SturdyWebSocket.prototype.reconnect = function () {\n        if (this.isClosed) {\n            throw new Error(\"Cannot call reconnect() on socket which is permanently closed.\");\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    };\n    SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    };\n    SturdyWebSocket.prototype.dispatchEvent = function (event) {\n        return this.dispatchEventOfType(event.type, event);\n    };\n    SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(function (l) { return l !== listener; });\n        }\n    };\n    SturdyWebSocket.prototype.openNewWebSocket = function () {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, connectTimeout = _a.connectTimeout, wsConstructor = _a.wsConstructor;\n        this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n        var ws = new wsConstructor(this.url, this.protocols);\n        ws.onclose = function (event) { return _this.handleClose(event); };\n        ws.onerror = function (event) { return _this.handleError(event); };\n        ws.onmessage = function (event) { return _this.handleMessage(event); };\n        ws.onopen = function (event) { return _this.handleOpen(event); };\n        this.connectTimeoutId = setTimeout(function () {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            _this.clearConnectTimeout();\n            _this.disposeSocket();\n            _this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    };\n    SturdyWebSocket.prototype.handleOpen = function (event) {\n        var _this = this;\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        var allClearResetTime = this.options.allClearResetTime;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        }\n        else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        }\n        else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(function (message) { return _this.send(message); });\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(function () {\n            _this.clearAllClearTimeout();\n            _this.nextRetryTime = 0;\n            _this.reconnectCount = 0;\n            var openTime = (allClearResetTime / 1000) | 0;\n            _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" +\n                \" retry time and count.\");\n        }, allClearResetTime);\n    };\n    SturdyWebSocket.prototype.handleMessage = function (event) {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    };\n    SturdyWebSocket.prototype.handleClose = function (event) {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, maxReconnectAttempts = _a.maxReconnectAttempts, shouldReconnect = _a.shouldReconnect;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n            return;\n        }\n        var willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n        }\n        else {\n            willReconnect.then(function (willReconnectResolved) {\n                if (_this.isClosed) {\n                    return;\n                }\n                _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n            });\n        }\n    };\n    SturdyWebSocket.prototype.handleError = function (event) {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    };\n    SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n        if (willReconnect) {\n            this.reestablishConnection();\n        }\n        else {\n            this.stopReconnecting(event, denialReason);\n        }\n    };\n    SturdyWebSocket.prototype.reestablishConnection = function () {\n        var _this = this;\n        var _a = this.options, minReconnectDelay = _a.minReconnectDelay, maxReconnectDelay = _a.maxReconnectDelay, reconnectBackoffFactor = _a.reconnectBackoffFactor;\n        this.reconnectCount++;\n        var retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n        setTimeout(function () { return _this.openNewWebSocket(); }, retryTime);\n        var retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n    };\n    SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    };\n    SturdyWebSocket.prototype.shutdown = function () {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    };\n    SturdyWebSocket.prototype.disposeSocket = function (closeCode, reason) {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    };\n    SturdyWebSocket.prototype.clearAllTimeouts = function () {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    };\n    SturdyWebSocket.prototype.clearConnectTimeout = function () {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n        var _this = this;\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(function (listener) { return _this.callListener(listener, event); });\n        }\n        return !event || !event.defaultPrevented;\n    };\n    SturdyWebSocket.prototype.callListener = function (listener, event) {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        }\n        else {\n            listener.handleEvent.call(this, event);\n        }\n    };\n    SturdyWebSocket.prototype.debugLog = function (message) {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    };\n    SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n        var maxReconnectAttempts = this.options.maxReconnectAttempts;\n        return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n    };\n    SturdyWebSocket.DEFAULT_OPTIONS = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: function () { return true; },\n        wsConstructor: undefined,\n    };\n    SturdyWebSocket.CONNECTING = 0;\n    SturdyWebSocket.OPEN = 1;\n    SturdyWebSocket.CLOSING = 2;\n    SturdyWebSocket.CLOSED = 3;\n    return SturdyWebSocket;\n}());\nexports.default = SturdyWebSocket;\nfunction applyDefaultOptions(options) {\n    var result = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(function (key) {\n        var value = options[key];\n        result[key] =\n            value === undefined\n                ? SturdyWebSocket.DEFAULT_OPTIONS[key]\n                : value;\n    });\n    return result;\n}\nfunction getDataByteLength(data) {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    }\n    else if (data instanceof Blob) {\n        return data.size;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction pluralize(s, n) {\n    return n === 1 ? s : s + \"s\";\n}\nfunction noop() {\n    // Nothing.\n}\n//# sourceMappingURL=index.js.map","var _globalThis;\nif (typeof globalThis === 'object') {\n\t_globalThis = globalThis;\n} else {\n\ttry {\n\t\t_globalThis = require('es5-ext/global');\n\t} catch (error) {\n\t} finally {\n\t\tif (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }\n\t\tif (!_globalThis) { throw new Error('Could not determine global this'); }\n\t}\n}\n\nvar NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\nvar websocket_version = require('./version');\n\n\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */\nfunction W3CWebSocket(uri, protocols) {\n\tvar native_instance;\n\n\tif (protocols) {\n\t\tnative_instance = new NativeWebSocket(uri, protocols);\n\t}\n\telse {\n\t\tnative_instance = new NativeWebSocket(uri);\n\t}\n\n\t/**\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t * class). Since it is an Object it will be returned as it is when creating an\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t *\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t */\n\treturn native_instance;\n}\nif (NativeWebSocket) {\n\t['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {\n\t\tObject.defineProperty(W3CWebSocket, prop, {\n\t\t\tget: function() { return NativeWebSocket[prop]; }\n\t\t});\n\t});\n}\n\n/**\n * Module exports.\n */\nmodule.exports = {\n    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,\n    'version'      : websocket_version\n};\n","module.exports = require('../package.json').version;\n"],"names":["WS","WebSocket","Error","error","logger","throwError","errors","UNSUPPORTED_OPERATION","operation","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","NextId","WebSocketProvider","constructor","url","network","super","this","_pollingInterval","_wsReady","connection","detectNetwork","websocket","onopen","Object","keys","_requests","forEach","id","send","payload","onmessage","messageEvent","data","JSON","parse","String","request","undefined","callback","emit","action","response","provider","message","code","method","sub","_subs","params","subscription","processFunc","console","warn","fauxPoll","setInterval","unref","_websocket","_detectNetwork","pollingInterval","resetEventsBlock","blockNumber","poll","polling","rid","stringify","jsonrpc","defaultUrl","_subscribe","tag","param","subIdPromise","_subIds","all","subId","_startEvent","event","type","from","number","toNumber","_emitted","block","_getFilter","filter","removed","formatter","filterLog","emitReceipt","hash","getTransactionReceipt","receipt","_events","log","_stopEvent","length","listenerCount","destroy","readyState","CONNECTING","onerror","close","MAX_BACKFILL_BLOCKS","WebsocketBackfiller","maxBackfillBlocks","getNewHeadsBackfill","isCancelled","previousHeads","fromBlockNumber","_","throwIfCancelled","toBlockNumber","getBlockNumber","getHeadEventsInRange","Math","max","lastSeenBlockNumber","f","minBlockNumber","reorgHeads","getReorgHeads","intermediateHeads","getLogsBackfill","previousLogs","getLogsInRange","commonAncestor","getCommonAncestor","removedLogs","map","assign","fromBlockInclusive","Number","NEGATIVE_INFINITY","addedLogs","logIndex","setMaxBackfillBlock","newMax","blockNumberHex","toBlockExclusive","batchParts","i","push","t","blockHeads","sendBatch","toNewHeadsEvent","oldEvent","blockHead","getBlockByNumber","reverse","oldLog","blockHash","rangeFilter","fromBlock","toBlock","head","totalDifficulty","transactions","uncles","dedupeNewHeads","events","dedupe","dedupeLogs","items","getKey","keysSeen","Set","item","key","has","add","CANCELLED","HEARTBEAT_INTERVAL","HEARTBEAT_WAIT_TIME","BACKFILL_TIMEOUT","BACKFILL_RETRIES","RETAINED_EVENT_BLOCK_COUNT","AlchemyWebSocketProvider","config","wsConstructor","_a","apiKey","AlchemyProvider","getApiKey","alchemyNetwork","getAlchemyNetwork","getAlchemyConnectionInfo","protocol","V","ws","getWebsocketConstructor","ethersNetwork","E","virtualSubscriptionsById","Map","virtualIdsByPhysicalId","handleMessage","isSubscriptionEvent","physicalId","virtualId","get","newHeadsSubscription","newHeadsMessage","isBackfilling","backfillBuffer","addToNewHeadsEventsBuffer","emitAndRememberEvent","getNewHeadsBlockNumber","rememberEvent","logsSubscription","logsMessage","addToLogsEventsBuffer","getLogsBlockNumber","emitEvent","handleReopen","clear","cancel","makeCancelToken","cancelBackfill","values","resubscribeAndBackfill","startHeartbeat","stopHeartbeatAndBackfill","heartbeatIntervalId","clearInterval","backfiller","addSocketListeners","n","getNetwork","C","on","eventName","listener","_addEventListener","once","off","_off","removeAllListeners","_removeAllListeners","_listenerCount","listeners","_listeners","v","customLogicTypes","A","includes","customStartEvent","startingBlockNumber","resolvedParams","set","sentEvents","args","stopped","eventTag","setTimeout","parts","nextId","sendBatchConcurrently","removeSocketListeners","isCommunityResource","D","addEventListener","removeEventListener","backfillEvents","withBackoffRetries","withTimeout","emitNewHeadsEvent","emitLogsEvent","emitGenericEvent","addToPastEventsBuffer","emitFunction","emitProcessFn","reconnect","req","fromAddress","toAddress","hashesOnly","PENDING_TRANSACTIONS","addresses","includeRemoved","MINED_TRANSACTIONS","found","isNodeEnvironment","process","versions","node","cancelled","MIN_RETRY_DELAY","RETRY_BACKOFF_FACTOR","MAX_RETRY_DELAY","retryCount","shouldRetry","nextWaitTime","delay","min","ms","promise","race","isResponse","Array","isArray","pastEvents","currentBlockNumber","firstGoodIndex","findIndex","splice","naiveFallback","self","window","module","exports","globalThis","defineProperty","prototype","configurable","__global__","SHOULD_RECONNECT_FALSE_MESSAGE","SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE","SturdyWebSocket","protocolsOrOptions","options","onclose","ondown","onreopen","OPEN","CLOSING","CLOSED","hasBeenOpened","isClosed","messageBuffer","nextRetryTime","reconnectCount","lastKnownExtensions","lastKnownProtocol","protocols","applyDefaultOptions","openNewWebSocket","binaryTypeInternal","binaryType","enumerable","sum","bufferedAmount","hasUnknownAmount","byteLength","getDataByteLength","debugLog","extensions","reason","disposeSocket","shutdown","handleClose","dispatchEvent","dispatchEventOfType","l","_this","connectTimeout","handleError","handleOpen","connectTimeoutId","clearConnectTimeout","allClearResetTime","allClearTimeoutId","clearAllClearTimeout","openTime","maxReconnectAttempts","shouldReconnect","stopReconnecting","getTooManyFailedReconnectsMessage","willReconnect","handleWillReconnect","willReconnectResolved","denialReason","reestablishConnection","minReconnectDelay","maxReconnectDelay","reconnectBackoffFactor","retryTime","retryTimeSeconds","debugReason","clearAllTimeouts","closeCode","noop","clearTimeout","slice","callListener","defaultPrevented","call","handleEvent","debug","pluralize","DEFAULT_OPTIONS","POSITIVE_INFINITY","ArrayBuffer","Blob","size","s","_globalThis","NativeWebSocket","MozWebSocket","websocket_version","W3CWebSocket","uri","native_instance","prop"],"sourceRoot":""}