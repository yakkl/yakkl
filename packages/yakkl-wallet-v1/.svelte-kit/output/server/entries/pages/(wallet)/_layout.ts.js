import{l as log,aj as MessageType,ak as activeTabUIStore,v as getObjectFromLocalStorage}from"../../../chunks/encryption.js";import{a as browser_ext,b as browserSvelte}from"../../../chunks/environment.js";import{g as get}from"../../../chunks/index.js";import{i as isServerSide}from"../../../chunks/utils2.js";import{g as getBrowserExt}from"../../../chunks/browser-polyfill-wrapper.js";var ConnectionType=(ConnectionType2=>{ConnectionType2["UI"]="ui-connection";ConnectionType2["POPUP"]="popup-connection";ConnectionType2["CONTENT"]="content-connection";return ConnectionType2})(ConnectionType||{});class BackgroundManager{static instance=null;connections;messageQueue;MAX_QUEUE_SIZE=100;STORAGE_PREFIX="bg_msg_";initialized=false;constructor(){this.connections=new Map;this.messageQueue=[];this.initialize().catch(error=>{log.error("Failed to initialize BackgroundManager:",false,error)})}static getInstance(){if(!BackgroundManager.instance){BackgroundManager.instance=new BackgroundManager}return BackgroundManager.instance}async initialize(){if(!browser_ext)return;if(this.initialized)return;try{browser_ext.runtime.onConnect.addListener(port=>{if(this.isValidConnectionType(port.name)){this.handleNewConnection(port)}});await this.restoreQueuedMessages();this.initialized=true}catch(error){log.error("BackgroundManager initialization failed:",false,error);throw error}}isValidConnectionType(type){return Object.values(ConnectionType).includes(type)}handleNewConnection(port){try{const connectionInfo={type:port.name,port:port,connectedAt:Date.now()};this.connections.set(port.name,connectionInfo);port.onDisconnect.addListener(()=>{this.handleDisconnection(port)});this.processQueuedMessages().catch(error=>{log.error("Failed to process queued messages:",false,error)})}catch(error){log.error("Error handling new connection:",false,error)}}handleDisconnection(port){try{this.connections.delete(port.name)}catch(error){log.error("Error handling disconnection:",false,error)}}hasConnections(){return this.connections.size>0}hasUIConnection(){return this.connections.has("ui-connection")}getConnectionInfo(type){return this.connections.get(type)}async sendMessage(type,data){try{if(!this.hasConnections()){await this.handleNoConnections(type,data);return}const message={type:type,data:data};const sendPromises=[];this.connections.forEach(({port:port})=>{sendPromises.push(new Promise((resolve,reject)=>{try{port.postMessage(message);resolve()}catch(error){reject(error)}}))});await Promise.allSettled(sendPromises)}catch(error){log.error("Failed to send message:",false,error);await this.handleMessageError(type,data,error)}}async handleNoConnections(type,data){try{await Promise.all([this.queueMessage(type,data),this.saveToStorage(type,data)])}catch(error){log.error("Failed to handle no connections case:",false,error)}}async handleMessageError(type,data,error){try{await this.queueMessage(type,data);log.error("Message queued due to error:",false,{type:type,error:error})}catch(queueError){log.error("Failed to queue message after error:",false,queueError)}}async queueMessage(type,data){const queuedMessage={type:type,data:data,timestamp:Date.now()};this.messageQueue.push(queuedMessage);if(this.messageQueue.length>this.MAX_QUEUE_SIZE){this.messageQueue.shift()}await this.persistQueue()}async persistQueue(){if(!browser_ext)return;try{await browser_ext.storage.local.set({[`${this.STORAGE_PREFIX}queue`]:this.messageQueue})}catch(error){log.error("Failed to persist message queue:",false,error)}}async restoreQueuedMessages(){if(!browser_ext)return;try{const result=await browser_ext.storage.local.get(`${this.STORAGE_PREFIX}queue`);const storedQueue=result[`${this.STORAGE_PREFIX}queue`];if(Array.isArray(storedQueue)){this.messageQueue=storedQueue.filter(message=>typeof message==="object"&&message!==null&&"type"in message&&"data"in message&&"timestamp"in message&&typeof message.type==="string"&&typeof message.timestamp==="number")}else{this.messageQueue=[];log.debug("No valid queued messages found in storage")}}catch(error){log.error("Failed to restore queued messages:",false,error);this.messageQueue=[]}}async saveToStorage(type,data){if(!browser_ext)return;try{await browser_ext.storage.local.set({[`${this.STORAGE_PREFIX}${type}`]:{data:data,timestamp:Date.now()}})}catch(error){log.error("Failed to save to storage:",false,error)}}async processQueuedMessages(){if(!this.hasConnections()){return}try{const messages=[...this.messageQueue];this.messageQueue=[];for(const message of messages){await this.sendMessage(message.type,message.data)}await this.persistQueue()}catch(error){log.error("Failed to process queued messages:",false,error)}}async clearQueue(){try{this.messageQueue=[];await this.persistQueue()}catch(error){log.error("Failed to clear message queue:",false,error)}}getQueueSize(){return this.messageQueue.length}isInitialized(){return this.initialized}}BackgroundManager.getInstance();const MAX_RETRIES=5;const INITIAL_RETRY_DELAY=1e3;const MAX_RETRY_DELAY=32e3;const state={retryCount:0,retryTimeout:void 0,isConnecting:false};function calculateBackoffDelay(retryCount){const exponentialDelay=INITIAL_RETRY_DELAY*Math.pow(2,retryCount);const maxDelay=Math.min(exponentialDelay,MAX_RETRY_DELAY);const jitter=maxDelay*.2*(Math.random()*2-1);return Math.floor(maxDelay+jitter)}function cleanupConnection(){if(state.retryTimeout){clearTimeout(state.retryTimeout);state.retryTimeout=void 0}state.isConnecting=false}async function retryConnection(){if(browserSvelte){if(state.retryCount>=MAX_RETRIES){log.error("Maximum reconnection attempts reached",true,{attempts:state.retryCount});cleanupConnection();return}const delay=calculateBackoffDelay(state.retryCount);log.info("Attempting to reconnect",false,{attempt:state.retryCount+1,delay:`${delay}ms`});if(typeof window!=="undefined"){state.retryTimeout=window.setTimeout(async()=>{try{state.retryCount++;await initializeUIConnection()}catch(error){log.error("Reconnection attempt failed:",false,{attempt:state.retryCount,error:error});await retryConnection()}},delay)}}}async function initializeUIConnection(){if(state.isConnecting){log.warn("Connection attempt already in progress");return}try{state.isConnecting=true;if(browserSvelte&&browser_ext){const port=browser_ext.runtime.connect({name:ConnectionType.UI});if(!port){log.error("Failed to establish connection with UI",true);throw new Error("Connection failed")}port.onMessage.addListener(message=>{try{if(isValidMessage(message)){handleMessage(message)}else{log.warn("Invalid message format received:",false,message)}}catch(error){log.error("Error handling message:",false,error)}});port.onDisconnect.addListener(()=>{if(browserSvelte&&browser_ext){const error=browser_ext.runtime.lastError;log.warn("UI connection disconnected",false,{error:error});cleanupConnection();if(browser_ext&&!browser_ext.runtime.lastError){retryConnection().catch(error2=>{log.error("Failed to initiate reconnection:",true,error2)})}else{log.warn("Extension context invalid, skipping reconnection")}}});state.retryCount=0;state.isConnecting=false;log.info("UI connection established successfully");return port}}catch(error){log.error("Failed to initialize UI connection:",true,error);throw error}}let connectionMonitorInterval;function startConnectionMonitor(){if(typeof window!=="undefined"){connectionMonitorInterval=window.setInterval(()=>{if(!state.isConnecting&&state.retryCount<MAX_RETRIES){if(browserSvelte&&browser_ext){browser_ext.runtime.getPlatformInfo().then(()=>{}).catch(()=>{log.warn("Connection check failed, initiating reconnect");initializeUIConnection().catch(error=>{log.error("Connection monitor reconnect failed:",false,error)})})}}},3e4)}}function stopConnectionMonitor(){if(connectionMonitorInterval){clearInterval(connectionMonitorInterval);connectionMonitorInterval=void 0}}function cleanup(){cleanupConnection();stopConnectionMonitor()}startConnectionMonitor();function handleMessage(message){try{log.debug("handleMessage:[connectionStore]",false,message);switch(message.type){case MessageType.ACTIVE_TAB_CHANGED:if(isTabChangeData(message.data)){handleActiveTabChange(message.data)}break;case MessageType.TAB_UPDATED:if(isTabChangeData(message.data)){handleTabUpdate(message.data)}break;case MessageType.TAB_REMOVED:if(isTabChangeData(message.data)){handleTabRemove(null)}break;case MessageType.WINDOW_FOCUSED:if(isWindowFocusData(message.data)){handleWindowFocus(message.data)}break;default:log.info("Unhandled message type. Letting it pass:",false,message.type)}}catch(error){throw error}}function isValidMessage(message){return typeof message==="object"&&message!==null&&"type"in message&&"data"in message&&typeof message.type==="string"}function isTabChangeData(data){return typeof data==="object"&&data!==null&&"tabId"in data&&typeof data.tabId==="number"}function isWindowFocusData(data){return typeof data==="object"&&data!==null&&"windowId"in data&&typeof data.windowId==="number"}function handleActiveTabChange(data){log.debug("handleActiveTabChange:--------------------\x3e>>>>>>>>>",false,data);if(data?.windowType==="normal"){activeTabUIStore.set(data);log.debug("Active tab changed:",false,data)}}function handleTabRemove(data){}function handleTabUpdate(data){activeTabUIStore.set(data);log.debug("Tab removed:",false,data)}async function handleWindowFocus(data){try{if(!(browserSvelte&&browser_ext))return;log.debug("handleWindowFocus:>>>>>>>>>>>>>>>>>>>>>>",false,data);if(data?.type==="normal"){const activeTab={tabId:0,windowId:data.windowId,windowType:data.type,url:"",title:"",favIconUrl:"",dateTime:(new Date).toISOString()};const tabs=await browser_ext.tabs.query({active:true,windowId:data.windowId});if(tabs.length>0){activeTab.tabId=tabs[0].id??0;activeTab.url=tabs[0].url??"";activeTab.title=tabs[0].title??"";activeTab.favIconUrl=tabs[0].favIconUrl??"";if(activeTab.tabId>0){activeTabUIStore.set(activeTab);log.debug("Window focused changed: [connectionStore]",false,activeTab)}}}else{}}catch(error){log.error("Error handling window focus:",false,error);throw error}}async function load(){if(isServerSide()){log.info("+layout.ts is running in SSR, skipping browser_ext usage.");return{}}try{log.debug("/+layout.ts - Initializing UI connection...");await initializeUIConnection();const activeTab=get(activeTabUIStore);if(!activeTab){const ext=getBrowserExt();if(ext){try{const response=await ext.runtime.sendMessage({type:"getActiveTab"});if(response?.activeTab){activeTabUIStore.set(response.activeTab)}else{log.debug("No active tab found, getting from local storage:",false,await getObjectFromLocalStorage("activeTabBackground"))}log.debug("Active tab:",false,activeTab,response,activeTabUIStore)}catch(error){log.error("Failed to initialize UI connection:",false,error)}}else{log.warn("browser_ext is not available.")}}}catch(error){log.error("Failed to initialize UI connection:",false,error)}return{destroy(){cleanup()}}}export{load};
//# sourceMappingURL=_layout.ts.js.map
