{"version":3,"file":"_layout.ts.js","sources":["../../../../../../src/lib/managers/BackgroundManager.ts","../../../../../../src/lib/common/stores/connectionStore.ts","../../../../../../src/routes/(wallet)/+layout.ts"],"sourcesContent":["import { browser_ext } from '$lib/common/environment';\nimport { log } from '$lib/common/logger-wrapper';\nimport type { Runtime } from 'webextension-polyfill';\n\nexport interface QueuedMessage<T = unknown> {\n\ttype: string;\n\tdata: T;\n\ttimestamp: number;\n}\n\nexport interface StorageData {\n\t[key: string]: unknown;\n}\n\nexport enum ConnectionType {\n\tUI = 'ui-connection',\n\tPOPUP = 'popup-connection',\n\tCONTENT = 'content-connection'\n}\n\nexport interface ConnectionInfo {\n\ttype: ConnectionType;\n\tport: Runtime.Port;\n\tconnectedAt: number;\n}\n\nexport class BackgroundManager {\n\tprivate static instance: BackgroundManager | null = null;\n\tprivate connections: Map<string, ConnectionInfo>;\n\tprivate messageQueue: QueuedMessage[];\n\tprivate readonly MAX_QUEUE_SIZE = 100;\n\tprivate readonly STORAGE_PREFIX = 'bg_msg_';\n\tprivate initialized: boolean = false;\n\n\tprivate constructor() {\n\t\tthis.connections = new Map();\n\t\tthis.messageQueue = [];\n\t\tthis.initialize().catch((error) => {\n\t\t\tlog.error('Failed to initialize BackgroundManager:', false, error);\n\t\t});\n\t}\n\n\tpublic static getInstance(): BackgroundManager {\n\t\tif (!BackgroundManager.instance) {\n\t\t\tBackgroundManager.instance = new BackgroundManager();\n\t\t}\n\t\treturn BackgroundManager.instance;\n\t}\n\n\tprivate async initialize(): Promise<void> {\n\t\tif (!browser_ext) return;\n\t\tif (this.initialized) return;\n\n\t\ttry {\n\t\t\tbrowser_ext.runtime.onConnect.addListener((port) => {\n\t\t\t\tif (this.isValidConnectionType(port.name)) {\n\t\t\t\t\tthis.handleNewConnection(port);\n\t\t\t\t}\n\t\t\t\t// Note: Only handle specific connection types that you have defined and let the rest flow through\n\t\t\t\t// log.warn('Invalid connection type attempted:', false, { portName: port.name });\n\t\t\t\t// port.disconnect();\n\t\t\t});\n\n\t\t\tawait this.restoreQueuedMessages();\n\n\t\t\tthis.initialized = true;\n\t\t\t// log.info('BackgroundManager initialized');\n\t\t} catch (error) {\n\t\t\tlog.error('BackgroundManager initialization failed:', false, error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate isValidConnectionType(type: string): type is ConnectionType {\n\t\treturn Object.values(ConnectionType).includes(type as ConnectionType);\n\t}\n\n\tprivate handleNewConnection(port: Runtime.Port): void {\n\t\ttry {\n\t\t\tconst connectionInfo: ConnectionInfo = {\n\t\t\t\ttype: port.name as ConnectionType,\n\t\t\t\tport,\n\t\t\t\tconnectedAt: Date.now()\n\t\t\t};\n\n\t\t\tthis.connections.set(port.name, connectionInfo);\n\t\t\t// log.debug('New connection established:', false, {\n\t\t\t//   type: port.name,\n\t\t\t//   timestamp: connectionInfo.connectedAt\n\t\t\t// });\n\n\t\t\tport.onDisconnect.addListener(() => {\n\t\t\t\tthis.handleDisconnection(port);\n\t\t\t});\n\n\t\t\t// Process queued messages for new connection\n\t\t\tthis.processQueuedMessages().catch((error) => {\n\t\t\t\tlog.error('Failed to process queued messages:', false, error);\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlog.error('Error handling new connection:', false, error);\n\t\t}\n\t}\n\n\tprivate handleDisconnection(port: Runtime.Port): void {\n\t\ttry {\n\t\t\tthis.connections.delete(port.name);\n\t\t\t// log.debug('Connection closed:', false, { type: port.name });\n\t\t} catch (error) {\n\t\t\tlog.error('Error handling disconnection:', false, error);\n\t\t}\n\t}\n\n\tpublic hasConnections(): boolean {\n\t\treturn this.connections.size > 0;\n\t}\n\n\tpublic hasUIConnection(): boolean {\n\t\treturn this.connections.has(ConnectionType.UI);\n\t}\n\n\tpublic getConnectionInfo(type: ConnectionType): ConnectionInfo | undefined {\n\t\treturn this.connections.get(type);\n\t}\n\n\tpublic async sendMessage<T>(type: string, data: T): Promise<void> {\n\t\ttry {\n\t\t\tif (!this.hasConnections()) {\n\t\t\t\tawait this.handleNoConnections(type, data);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst message = { type, data };\n\t\t\tconst sendPromises: Promise<void>[] = [];\n\n\t\t\tthis.connections.forEach(({ port }) => {\n\t\t\t\tsendPromises.push(\n\t\t\t\t\tnew Promise<void>((resolve, reject) => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tport.postMessage(message);\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tawait Promise.allSettled(sendPromises);\n\t\t} catch (error) {\n\t\t\tlog.error('Failed to send message:', false, error);\n\t\t\tawait this.handleMessageError(type, data, error);\n\t\t}\n\t}\n\n\tprivate async handleNoConnections<T>(type: string, data: T): Promise<void> {\n\t\ttry {\n\t\t\tawait Promise.all([this.queueMessage(type, data), this.saveToStorage(type, data)]);\n\t\t} catch (error) {\n\t\t\tlog.error('Failed to handle no connections case:', false, error);\n\t\t}\n\t}\n\n\tprivate async handleMessageError<T>(type: string, data: T, error: unknown): Promise<void> {\n\t\ttry {\n\t\t\tawait this.queueMessage(type, data);\n\t\t\tlog.error('Message queued due to error:', false, { type, error });\n\t\t} catch (queueError) {\n\t\t\tlog.error('Failed to queue message after error:', false, queueError);\n\t\t}\n\t}\n\n\tprivate async queueMessage<T>(type: string, data: T): Promise<void> {\n\t\tconst queuedMessage: QueuedMessage<T> = {\n\t\t\ttype,\n\t\t\tdata,\n\t\t\ttimestamp: Date.now()\n\t\t};\n\n\t\tthis.messageQueue.push(queuedMessage);\n\n\t\tif (this.messageQueue.length > this.MAX_QUEUE_SIZE) {\n\t\t\tthis.messageQueue.shift();\n\t\t}\n\n\t\tawait this.persistQueue();\n\t}\n\n\tprivate async persistQueue(): Promise<void> {\n\t\tif (!browser_ext) return;\n\n\t\ttry {\n\t\t\tawait browser_ext.storage.local.set({\n\t\t\t\t[`${this.STORAGE_PREFIX}queue`]: this.messageQueue\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlog.error('Failed to persist message queue:', false, error);\n\t\t}\n\t}\n\n\tprivate async restoreQueuedMessages(): Promise<void> {\n\t\tif (!browser_ext) return;\n\n\t\ttry {\n\t\t\tconst result = await browser_ext.storage.local.get(`${this.STORAGE_PREFIX}queue`);\n\t\t\tconst storedQueue = result[`${this.STORAGE_PREFIX}queue`];\n\n\t\t\t// Type guard to ensure array of QueuedMessage\n\t\t\tif (Array.isArray(storedQueue)) {\n\t\t\t\tthis.messageQueue = storedQueue.filter((message): message is QueuedMessage => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\ttypeof message === 'object' &&\n\t\t\t\t\t\tmessage !== null &&\n\t\t\t\t\t\t'type' in message &&\n\t\t\t\t\t\t'data' in message &&\n\t\t\t\t\t\t'timestamp' in message &&\n\t\t\t\t\t\ttypeof message.type === 'string' &&\n\t\t\t\t\t\ttypeof message.timestamp === 'number'\n\t\t\t\t\t);\n\t\t\t\t});\n\n\t\t\t\t// log.debug('Restored queued messages:', false, { count: this.messageQueue.length });\n\t\t\t} else {\n\t\t\t\tthis.messageQueue = [];\n\t\t\t\tlog.debug('No valid queued messages found in storage');\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlog.error('Failed to restore queued messages:', false, error);\n\t\t\tthis.messageQueue = []; // Ensure valid state on error\n\t\t}\n\t}\n\n\tprivate async saveToStorage<T>(type: string, data: T): Promise<void> {\n\t\tif (!browser_ext) return;\n\n\t\ttry {\n\t\t\tawait browser_ext.storage.local.set({\n\t\t\t\t[`${this.STORAGE_PREFIX}${type}`]: {\n\t\t\t\t\tdata,\n\t\t\t\t\ttimestamp: Date.now()\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlog.error('Failed to save to storage:', false, error);\n\t\t}\n\t}\n\n\tpublic async processQueuedMessages(): Promise<void> {\n\t\tif (!this.hasConnections()) {\n\t\t\t// log.debug('No connections available to process queue');\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst messages = [...this.messageQueue];\n\t\t\tthis.messageQueue = [];\n\n\t\t\tfor (const message of messages) {\n\t\t\t\tawait this.sendMessage(message.type, message.data);\n\t\t\t}\n\n\t\t\tawait this.persistQueue();\n\t\t\t// log.debug('Processed queued messages:', false, { count: messages.length });\n\t\t} catch (error) {\n\t\t\tlog.error('Failed to process queued messages:', false, error);\n\t\t}\n\t}\n\n\tpublic async clearQueue(): Promise<void> {\n\t\ttry {\n\t\t\tthis.messageQueue = [];\n\t\t\tawait this.persistQueue();\n\t\t\t// log.debug('Message queue cleared');\n\t\t} catch (error) {\n\t\t\tlog.error('Failed to clear message queue:', false, error);\n\t\t}\n\t}\n\n\tpublic getQueueSize(): number {\n\t\treturn this.messageQueue.length;\n\t}\n\n\tpublic isInitialized(): boolean {\n\t\treturn this.initialized;\n\t}\n}\n\n// Export singleton instance\nexport const backgroundManager = BackgroundManager.getInstance();\n\n// Example how to use:\n\n// +layout.ts\n// import { initializeUIConnection } from '$lib/stores/connectionStore';\n\n// export async function load() {\n//   try {\n//     await initializeUIConnection();\n//   } catch (error) {\n//     log.error('Failed to initialize UI connection:', false, error);\n//   }\n// }\n\n// +background.ts\n// browser_ext.tabs.onActivated.addListener(async (activeInfo) => {\n//   try {\n//     const tab = await browser_ext.tabs.get(activeInfo.tabId);\n//     const activeTab = {\n//       tabId: activeInfo.tabId,\n//       url: tab.url\n//     };\n\n//     await backgroundManager.sendMessage('ACTIVE_TAB_CHANGED', activeTab);\n//     log.debug('Active tab change processed:', false, activeTab);\n//   } catch (error) {\n//     log.error('Failed to handle tab activation:', false, error);\n//   }\n// });\n","import { browser_ext, browserSvelte } from '$lib/common/environment';\nimport { ConnectionType } from '$managers/BackgroundManager';\nimport { log } from '$lib/common/logger-wrapper';\nimport type { MessageTypes, TabChangeData, WindowFocusData } from '$lib/common/types';\nimport { MessageType } from '$lib/common/types';\nimport { activeTabUIStore } from '../stores';\n\ninterface ConnectionState {\n\tretryCount: number;\n\tretryTimeout?: number;\n\tisConnecting: boolean;\n}\n\nconst MAX_RETRIES = 5;\nconst INITIAL_RETRY_DELAY = 1000; // 1 second\nconst MAX_RETRY_DELAY = 32000; // 32 seconds\nconst state: ConnectionState = {\n\tretryCount: 0,\n\tretryTimeout: undefined,\n\tisConnecting: false\n};\n\nfunction calculateBackoffDelay(retryCount: number): number {\n\t// Exponential backoff with jitter\n\tconst exponentialDelay = INITIAL_RETRY_DELAY * Math.pow(2, retryCount);\n\tconst maxDelay = Math.min(exponentialDelay, MAX_RETRY_DELAY);\n\t// Add random jitter (±20%)\n\tconst jitter = maxDelay * 0.2 * (Math.random() * 2 - 1);\n\treturn Math.floor(maxDelay + jitter);\n}\n\nfunction cleanupConnection() {\n\tif (state.retryTimeout) {\n\t\tclearTimeout(state.retryTimeout);\n\t\tstate.retryTimeout = undefined;\n\t}\n\tstate.isConnecting = false;\n}\n\nasync function retryConnection(): Promise<void> {\n\tif (browserSvelte) {\n\t\tif (state.retryCount >= MAX_RETRIES) {\n\t\t\tlog.error('Maximum reconnection attempts reached', true, {\n\t\t\t\tattempts: state.retryCount\n\t\t\t});\n\t\t\tcleanupConnection();\n\t\t\treturn;\n\t\t}\n\n\t\tconst delay = calculateBackoffDelay(state.retryCount);\n\t\tlog.info('Attempting to reconnect', false, {\n\t\t\tattempt: state.retryCount + 1,\n\t\t\tdelay: `${delay}ms`\n\t\t});\n\n\t\tif (typeof window !== 'undefined') {\n\t\t\tstate.retryTimeout = window.setTimeout(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tstate.retryCount++;\n\t\t\t\t\tawait initializeUIConnection();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tlog.error('Reconnection attempt failed:', false, {\n\t\t\t\t\t\tattempt: state.retryCount,\n\t\t\t\t\t\terror\n\t\t\t\t\t});\n\t\t\t\t\tawait retryConnection();\n\t\t\t\t}\n\t\t\t}, delay);\n\t\t}\n\t}\n}\n\nexport async function initializeUIConnection() {\n\t// Prevent multiple simultaneous connection attempts\n\tif (state.isConnecting) {\n\t\tlog.warn('Connection attempt already in progress');\n\t\treturn;\n\t}\n\n\ttry {\n\t\tstate.isConnecting = true;\n\t\tif (browserSvelte && browser_ext) {\n\t\t\tconst port = browser_ext.runtime.connect({ name: ConnectionType.UI });\n\n\t\t\tif (!port) {\n\t\t\t\tlog.error('Failed to establish connection with UI', true);\n\t\t\t\tthrow new Error('Connection failed');\n\t\t\t}\n\n\t\t\tport.onMessage.addListener((message: unknown) => {\n\t\t\t\ttry {\n\t\t\t\t\t// Type guard function to check if message is valid\n\t\t\t\t\tif (isValidMessage(message)) {\n\t\t\t\t\t\thandleMessage(message);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog.warn('Invalid message format received:', false, message);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tlog.error('Error handling message:', false, error);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tport.onDisconnect.addListener(() => {\n\t\t\t\tif (browserSvelte && browser_ext) {\n\t\t\t\t\tconst error = browser_ext.runtime.lastError;\n\t\t\t\t\tlog.warn('UI connection disconnected', false, { error });\n\n\t\t\t\t\tcleanupConnection();\n\n\t\t\t\t\t// Check if extension is still available before attempting reconnect\n\t\t\t\t\tif (browser_ext && !browser_ext.runtime.lastError) {\n\t\t\t\t\t\tretryConnection().catch((error) => {\n\t\t\t\t\t\t\tlog.error('Failed to initiate reconnection:', true, error);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog.warn('Extension context invalid, skipping reconnection');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Connection successful, reset retry count\n\t\t\tstate.retryCount = 0;\n\t\t\tstate.isConnecting = false;\n\t\t\tlog.info('UI connection established successfully');\n\t\t\treturn port;\n\t\t}\n\t} catch (error) {\n\t\tlog.error('Failed to initialize UI connection:', true, error);\n\t\tthrow error;\n\t}\n}\n\n// Optional: Add connection status monitoring\nlet connectionMonitorInterval: number;\n\nfunction startConnectionMonitor() {\n\tif (typeof window !== 'undefined') {\n\t\tconnectionMonitorInterval = window.setInterval(() => {\n\t\t\tif (!state.isConnecting && state.retryCount < MAX_RETRIES) {\n\t\t\t\tif (browserSvelte && browser_ext) {\n\t\t\t\t\tbrowser_ext.runtime\n\t\t\t\t\t\t.getPlatformInfo()\n\t\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t\t// Extension is responding, connection might be alive\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(() => {\n\t\t\t\t\t\t\tlog.warn('Connection check failed, initiating reconnect');\n\t\t\t\t\t\t\tinitializeUIConnection().catch((error) => {\n\t\t\t\t\t\t\t\tlog.error('Connection monitor reconnect failed:', false, error);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}, 30000); // Check every 30 seconds\n\t}\n}\n\nfunction stopConnectionMonitor() {\n\tif (connectionMonitorInterval) {\n\t\tclearInterval(connectionMonitorInterval);\n\t\tconnectionMonitorInterval = undefined;\n\t}\n}\n\n// Cleanup function for unmounting\nexport function cleanup() {\n\tcleanupConnection();\n\tstopConnectionMonitor();\n}\n\n// Initialize connection monitoring when the extension starts\nstartConnectionMonitor();\n\n// Do not enable this unless needed and then put a guard around it for browser_ext\n// Optional: Add cleanup logic for extension lifecycle events\n// Handle extension lifecycle events\n// browser_ext.runtime.onSuspend.addListener(() => {\n//   cleanup();\n// });\n\nfunction handleMessage(message: MessageTypes) {\n\ttry {\n\t\tlog.debug('handleMessage:[connectionStore]', false, message);\n\n\t\tswitch (message.type) {\n\t\t\tcase MessageType.ACTIVE_TAB_CHANGED:\n\t\t\t\tif (isTabChangeData(message.data)) {\n\t\t\t\t\thandleActiveTabChange(message.data);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MessageType.TAB_UPDATED:\n\t\t\t\tif (isTabChangeData(message.data)) {\n\t\t\t\t\thandleTabUpdate(message.data);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MessageType.TAB_REMOVED:\n\t\t\t\tif (isTabChangeData(message.data)) {\n\t\t\t\t\thandleTabRemove(null);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MessageType.WINDOW_FOCUSED:\n\t\t\t\tif (isWindowFocusData(message.data)) {\n\t\t\t\t\thandleWindowFocus(message.data);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlog.info('Unhandled message type. Letting it pass:', false, message.type);\n\t\t}\n\t} catch (error) {\n\t\tthrow error;\n\t}\n}\n\n// Type guard functions\nfunction isValidMessage(message: unknown): message is MessageTypes {\n\treturn (\n\t\ttypeof message === 'object' &&\n\t\tmessage !== null &&\n\t\t'type' in message &&\n\t\t'data' in message &&\n\t\ttypeof (message as MessageTypes).type === 'string'\n\t);\n}\n\nfunction isTabChangeData(data: unknown): data is TabChangeData {\n\treturn (\n\t\ttypeof data === 'object' &&\n\t\tdata !== null &&\n\t\t'tabId' in data &&\n\t\ttypeof (data as TabChangeData).tabId === 'number'\n\t);\n}\n\nfunction isWindowFocusData(data: unknown): data is WindowFocusData {\n\treturn (\n\t\ttypeof data === 'object' &&\n\t\tdata !== null &&\n\t\t'windowId' in data &&\n\t\ttypeof (data as WindowFocusData).windowId === 'number'\n\t);\n}\n\n// Handler functions with proper typing\nfunction handleActiveTabChange(data: TabChangeData) {\n\tlog.debug('handleActiveTabChange:-------------------->>>>>>>>>>', false, data);\n\n\tif (data?.windowType === 'normal') {\n\t\tactiveTabUIStore.set(data);\n\t\tlog.debug('Active tab changed:', false, data);\n\t} else {\n\t\t// log.debug('Active tab did not change (windowType should only be \"normal\"):', false, data);\n\t}\n}\n\nfunction handleTabRemove(data: TabChangeData) {\n\t// We don't need to update the active tab on tab update\n\t// if (data?.windowType === 'normal') {\n\t//   activeTabUIStore.set(data);\n\t//   log.debug('Tab updated:', false, data);\n\t// } else {\n\t// log.debug('Tab did not change (windowType should only be \"normal\"):', false, data);\n\t// }\n}\n\nfunction handleTabUpdate(data: TabChangeData | null) {\n\tactiveTabUIStore.set(data);\n\tlog.debug('Tab removed:', false, data);\n}\n\nasync function handleWindowFocus(data: WindowFocusData) {\n\ttry {\n\t\tif (!(browserSvelte && browser_ext)) return;\n\n\t\tlog.debug('handleWindowFocus:>>>>>>>>>>>>>>>>>>>>>>', false, data);\n\n\t\t// Implement window focus logic if needed\n\t\tif (data?.type === 'normal') {\n\t\t\t// This should set the active tab to the focused window if it is normal and not a popup or other type\n\t\t\tconst activeTab = {\n\t\t\t\ttabId: 0,\n\t\t\t\twindowId: data.windowId,\n\t\t\t\twindowType: data.type,\n\t\t\t\turl: '',\n\t\t\t\ttitle: '',\n\t\t\t\tfavIconUrl: '',\n\t\t\t\tdateTime: new Date().toISOString()\n\t\t\t};\n\t\t\tconst tabs = await browser_ext.tabs.query({ active: true, windowId: data.windowId });\n\t\t\tif (tabs.length > 0) {\n\t\t\t\tactiveTab.tabId = tabs[0].id ?? 0;\n\t\t\t\tactiveTab.url = tabs[0].url ?? '';\n\t\t\t\tactiveTab.title = tabs[0].title ?? '';\n\t\t\t\tactiveTab.favIconUrl = tabs[0].favIconUrl ?? '';\n\n\t\t\t\tif (activeTab.tabId > 0) {\n\t\t\t\t\tactiveTabUIStore.set(activeTab);\n\t\t\t\t\tlog.debug('Window focused changed: [connectionStore]', false, activeTab);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// NOTE: Could add logic to handle different window types...\n\t\t\t// log.debug('Window focus did not change (type should only be \"normal\"):', false, data);\n\t\t}\n\t} catch (error) {\n\t\tlog.error('Error handling window focus:', false, error);\n\t\tthrow error;\n\t}\n}\n","// export const ssr = false;\n\nimport { log } from '$lib/common/logger-wrapper';\nimport { cleanup, initializeUIConnection } from '$lib/common/stores/connectionStore';\nimport { get } from 'svelte/store';\nimport { activeTabUIStore } from '$lib/common/stores';\nimport type { GetActiveTabResponse } from '$lib/common/interfaces';\nimport { isServerSide } from '$lib/common/utils';\nimport { getBrowserExt } from '$lib/browser-polyfill-wrapper';\nimport { getObjectFromLocalStorage } from '$lib/common/storage';\n\nexport async function load() {\n\tif (isServerSide()) {\n\t\tlog.info('+layout.ts is running in SSR, skipping browser_ext usage.');\n\t\treturn {}; // Prevents execution during SSR\n\t}\n\n\ttry {\n\t\tlog.debug('/+layout.ts - Initializing UI connection...');\n\n\t\tawait initializeUIConnection();\n\t\tconst activeTab = get(activeTabUIStore);\n\t\tif (!activeTab) {\n\t\t\tconst ext = getBrowserExt();\n\t\t\tif (ext) {\n\t\t\t\ttry {\n\t\t\t\t\tconst response = (await ext.runtime.sendMessage({\n\t\t\t\t\t\ttype: 'getActiveTab'\n\t\t\t\t\t})) as GetActiveTabResponse;\n\t\t\t\t\tif (response?.activeTab) {\n\t\t\t\t\t\tactiveTabUIStore.set(response.activeTab);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog.debug(\n\t\t\t\t\t\t\t'No active tab found, getting from local storage:',\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tawait getObjectFromLocalStorage('activeTabBackground')\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tlog.debug('Active tab:', false, activeTab, response, activeTabUIStore);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tlog.error('Failed to initialize UI connection:', false, error);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog.warn('browser_ext is not available.');\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\tlog.error('Failed to initialize UI connection:', false, error);\n\t}\n\n\treturn {\n\t\tdestroy() {\n\t\t\tcleanup();\n\t\t}\n\t};\n}\n"],"names":["ConnectionType","BackgroundManager","static","connections","messageQueue","MAX_QUEUE_SIZE","STORAGE_PREFIX","initialized","constructor","this","Map","initialize","catch","error","log","getInstance","instance","browser_ext","runtime","onConnect","addListener","port","isValidConnectionType","name","handleNewConnection","restoreQueuedMessages","type","Object","values","includes","connectionInfo","connectedAt","Date","now","set","onDisconnect","handleDisconnection","processQueuedMessages","delete","hasConnections","size","hasUIConnection","has","getConnectionInfo","get","sendMessage","data","handleNoConnections","message","sendPromises","forEach","push","Promise","resolve","reject","postMessage","allSettled","handleMessageError","all","queueMessage","saveToStorage","queueError","queuedMessage","timestamp","length","shift","persistQueue","storage","local","result","storedQueue","Array","isArray","filter","debug","messages","clearQueue","getQueueSize","isInitialized","MAX_RETRIES","INITIAL_RETRY_DELAY","MAX_RETRY_DELAY","state","retryCount","retryTimeout","isConnecting","calculateBackoffDelay","exponentialDelay","Math","pow","maxDelay","min","jitter","random","floor","cleanupConnection","clearTimeout","async","retryConnection","browserSvelte","attempts","delay","info","attempt","window","setTimeout","initializeUIConnection","warn","connect","UI","Error","onMessage","isValidMessage","handleMessage","lastError","connectionMonitorInterval","startConnectionMonitor","setInterval","getPlatformInfo","then","stopConnectionMonitor","clearInterval","cleanup","MessageType","ACTIVE_TAB_CHANGED","isTabChangeData","handleActiveTabChange","TAB_UPDATED","handleTabUpdate","TAB_REMOVED","handleTabRemove","WINDOW_FOCUSED","isWindowFocusData","handleWindowFocus","tabId","windowId","windowType","activeTabUIStore","activeTab","url","title","favIconUrl","dateTime","toISOString","tabs","query","active","id","load","isServerSide","ext","getBrowserExt","response","getObjectFromLocalStorage","destroy"],"mappings":"gYAcY,IAAAA,gBAAAA,kBACXA,gBAAA,MAAK,gBACLA,gBAAA,SAAQ,mBACRA,gBAAA,WAAU,qBAHCA,OAAAA,eAAA,GAAAA,gBAAA,CAAA,GAYL,MAAMC,kBACZC,gBAAoD,KAC5CC,YACAC,aACSC,eAAiB,IACjBC,eAAiB,UAC1BC,YAAuB,MAEvB,WAAAC,GACFC,KAAAN,gBAAkBO,IACvBD,KAAKL,aAAe,GACpBK,KAAKE,aAAaC,MAAOC,QACpBC,IAAAD,MAAM,0CAA2C,MAAOA,QAC5D,CAGF,kBAAcE,GACT,IAACd,kBAAkBe,SAAU,CACdf,kBAAAe,SAAW,IAAIf,iBAAkB,CAEpD,OAAOA,kBAAkBe,QAAA,CAG1B,gBAAcL,GACb,IAAKM,YAAa,OAClB,GAAIR,KAAKF,YAAa,OAElB,IACHU,YAAYC,QAAQC,UAAUC,YAAaC,OAC1C,GAAIZ,KAAKa,sBAAsBD,KAAKE,MAAO,CAC1Cd,KAAKe,oBAAoBH,KAAI,UAOzBZ,KAAKgB,wBAEXhB,KAAKF,YAAc,WAEXM,OACJC,IAAAD,MAAM,2CAA4C,MAAOA,OACvD,MAAAA,KAAA,CACP,CAGO,qBAAAS,CAAsBI,MAC7B,OAAOC,OAAOC,OAAO5B,gBAAgB6B,SAASH,KAAsB,CAG7D,mBAAAF,CAAoBH,MACvB,IACH,MAAMS,eAAiC,CACtCJ,KAAML,KAAKE,KACXF,UACAU,YAAaC,KAAKC,OAGnBxB,KAAKN,YAAY+B,IAAIb,KAAKE,KAAMO,gBAM3BT,KAAAc,aAAaf,YAAY,KAC7BX,KAAK2B,oBAAoBf,QAI1BZ,KAAK4B,wBAAwBzB,MAAOC,QAC/BC,IAAAD,MAAM,qCAAsC,MAAOA,eAEhDA,OACJC,IAAAD,MAAM,iCAAkC,MAAOA,MAAK,CACzD,CAGO,mBAAAuB,CAAoBf,MACvB,IACEZ,KAAAN,YAAYmC,OAAOjB,KAAKE,YAErBV,OACJC,IAAAD,MAAM,gCAAiC,MAAOA,MAAK,CACxD,CAGM,cAAA0B,GACC,OAAA9B,KAAKN,YAAYqC,KAAO,CAAA,CAGzB,eAAAC,GACC,OAAAhC,KAAKN,YAAYuC,IAAI,gBAAiB,CAGvC,iBAAAC,CAAkBjB,MACjB,OAAAjB,KAAKN,YAAYyC,IAAIlB,KAAI,CAGjC,iBAAamB,CAAenB,KAAcoB,MACrC,IACC,IAACrC,KAAK8B,iBAAkB,OACrB9B,KAAKsC,oBAAoBrB,KAAMoB,MACrC,MAAA,CAGK,MAAAE,QAAU,CAAEtB,UAAMoB,WACxB,MAAMG,aAAgC,GAEtCxC,KAAKN,YAAY+C,QAAQ,EAAG7B,cACd4B,aAAAE,KACZ,IAAIC,QAAc,CAACC,QAASC,UACvB,IACHjC,KAAKkC,YAAYP,SACTK,gBACAxC,OACRyC,OAAOzC,MAAK,aAMVuC,QAAQI,WAAWP,oBACjBpC,OACJC,IAAAD,MAAM,0BAA2B,MAAOA,aACtCJ,KAAKgD,mBAAmB/B,KAAMoB,KAAMjC,MAAK,CAChD,CAGD,yBAAckC,CAAuBrB,KAAcoB,MAC9C,UACGM,QAAQM,IAAI,CAACjD,KAAKkD,aAAajC,KAAMoB,MAAOrC,KAAKmD,cAAclC,KAAMoB,cACnEjC,OACJC,IAAAD,MAAM,wCAAyC,MAAOA,MAAK,CAChE,CAGD,wBAAc4C,CAAsB/B,KAAcoB,KAASjC,OACtD,UACGJ,KAAKkD,aAAajC,KAAMoB,MAC9BhC,IAAID,MAAM,+BAAgC,MAAO,CAAEa,UAAMb,oBACjDgD,YACJ/C,IAAAD,MAAM,uCAAwC,MAAOgD,WAAU,CACpE,CAGD,kBAAcF,CAAgBjC,KAAcoB,MAC3C,MAAMgB,cAAkC,CACvCpC,UACAoB,UACAiB,UAAW/B,KAAKC,OAGZxB,KAAAL,aAAa+C,KAAKW,eAEvB,GAAIrD,KAAKL,aAAa4D,OAASvD,KAAKJ,eAAgB,CACnDI,KAAKL,aAAa6D,OAAM,OAGnBxD,KAAKyD,cAAa,CAGzB,kBAAcA,GACb,IAAKjD,YAAa,OAEd,UACGA,YAAYkD,QAAQC,MAAMlC,IAAI,CACnC,CAAC,GAAGzB,KAAKH,uBAAwBG,KAAKL,qBAE/BS,OACJC,IAAAD,MAAM,mCAAoC,MAAOA,MAAK,CAC3D,CAGD,2BAAcY,GACb,IAAKR,YAAa,OAEd,IACG,MAAAoD,aAAepD,YAAYkD,QAAQC,MAAMxB,IAAI,GAAGnC,KAAKH,uBAC3D,MAAMgE,YAAcD,OAAO,GAAG5D,KAAKH,uBAG/B,GAAAiE,MAAMC,QAAQF,aAAc,CAC/B7D,KAAKL,aAAekE,YAAYG,OAAQzB,gBAE/BA,UAAY,UACnBA,UAAY,MACZ,SAAUA,SACV,SAAUA,SACV,cAAeA,gBACRA,QAAQtB,OAAS,iBACjBsB,QAAQe,YAAc,SAE9B,KAGK,CACNtD,KAAKL,aAAe,GACpBU,IAAI4D,MAAM,4CAA2C,QAE9C7D,OACJC,IAAAD,MAAM,qCAAsC,MAAOA,OACvDJ,KAAKL,aAAe,EAAC,CACtB,CAGD,mBAAcwD,CAAiBlC,KAAcoB,MAC5C,IAAK7B,YAAa,OAEd,UACGA,YAAYkD,QAAQC,MAAMlC,IAAI,CACnC,CAAC,GAAGzB,KAAKH,iBAAiBoB,QAAS,CAClCoB,UACAiB,UAAW/B,KAAKC,eAGVpB,OACJC,IAAAD,MAAM,6BAA8B,MAAOA,MAAK,CACrD,CAGD,2BAAawB,GACR,IAAC5B,KAAK8B,iBAAkB,CAE3B,MAAA,CAGG,IACH,MAAMoC,SAAW,IAAIlE,KAAKL,cAC1BK,KAAKL,aAAe,GAEpB,IAAA,MAAW4C,WAAW2B,SAAU,OACzBlE,KAAKoC,YAAYG,QAAQtB,KAAMsB,QAAQF,KAAI,OAG5CrC,KAAKyD,qBAEHrD,OACJC,IAAAD,MAAM,qCAAsC,MAAOA,MAAK,CAC7D,CAGD,gBAAa+D,GACR,IACHnE,KAAKL,aAAe,SACdK,KAAKyD,qBAEHrD,OACJC,IAAAD,MAAM,iCAAkC,MAAOA,MAAK,CACzD,CAGM,YAAAgE,GACN,OAAOpE,KAAKL,aAAa4D,MAAA,CAGnB,aAAAc,GACN,OAAOrE,KAAKF,WAAA,EAKmBN,kBAAkBc,cCnRnD,MAAMgE,YAAc,EACpB,MAAMC,oBAAsB,IAC5B,MAAMC,gBAAkB,KACxB,MAAMC,MAAyB,CAC9BC,WAAY,EACZC,kBAAc,EACdC,aAAc,OAGf,SAASC,sBAAsBH,YAE9B,MAAMI,iBAAmBP,oBAAsBQ,KAAKC,IAAI,EAAGN,YAC3D,MAAMO,SAAWF,KAAKG,IAAIJ,iBAAkBN,iBAE5C,MAAMW,OAASF,SAAW,IAAOF,KAAKK,SAAW,EAAI,GAC9C,OAAAL,KAAKM,MAAMJ,SAAWE,OAC9B,CAEA,SAASG,oBACR,GAAIb,MAAME,aAAc,CACvBY,aAAad,MAAME,cACnBF,MAAME,kBAAe,CAAA,CAEtBF,MAAMG,aAAe,KACtB,CAEAY,eAAeC,kBACd,GAAIC,cAAe,CACd,GAAAjB,MAAMC,YAAcJ,YAAa,CAChCjE,IAAAD,MAAM,wCAAyC,KAAM,CACxDuF,SAAUlB,MAAMC,aAECY,oBAClB,MAAA,CAGK,MAAAM,MAAQf,sBAAsBJ,MAAMC,YACtCrE,IAAAwF,KAAK,0BAA2B,MAAO,CAC1CC,QAASrB,MAAMC,WAAa,EAC5BkB,MAAO,GAAGA,YAGP,UAAOG,SAAW,YAAa,CAC5BtB,MAAAE,aAAeoB,OAAOC,WAAWR,UAClC,IACGf,MAAAC,mBACAuB,+BACE7F,OACJC,IAAAD,MAAM,+BAAgC,MAAO,CAChD0F,QAASrB,MAAMC,WACftE,oBAEKqF,iBAAgB,GAErBG,MAAK,CACT,CAEF,CAEAJ,eAAsBS,yBAErB,GAAIxB,MAAMG,aAAc,CACvBvE,IAAI6F,KAAK,0CACT,MAAA,CAGG,IACHzB,MAAMG,aAAe,KACrB,GAAIc,eAAiBlF,YAAa,CAC3B,MAAAI,KAAOJ,YAAYC,QAAQ0F,QAAQ,CAAErF,KAAMvB,eAAe6G,KAEhE,IAAKxF,KAAM,CACNP,IAAAD,MAAM,yCAA0C,MAC9C,MAAA,IAAIiG,MAAM,oBAAmB,CAG/BzF,KAAA0F,UAAU3F,YAAa4B,UACvB,IAEC,GAAAgE,eAAehE,SAAU,CAC5BiE,cAAcjE,QAAO,KACf,CACFlC,IAAA6F,KAAK,mCAAoC,MAAO3D,QAAO,QAEpDnC,OACJC,IAAAD,MAAM,0BAA2B,MAAOA,MAAK,IAI9CQ,KAAAc,aAAaf,YAAY,KAC7B,GAAI+E,eAAiBlF,YAAa,CAC3B,MAAAJ,MAAQI,YAAYC,QAAQgG,UAClCpG,IAAI6F,KAAK,6BAA8B,MAAO,CAAE9F,cAE9BkF,oBAGlB,GAAI9E,cAAgBA,YAAYC,QAAQgG,UAAW,CAClChB,kBAAEtF,MAAOC,SACpBC,IAAAD,MAAM,mCAAoC,KAAMA,SACpD,KACK,CACNC,IAAI6F,KAAK,mDAAkD,CAC5D,IAKFzB,MAAMC,WAAa,EACnBD,MAAMG,aAAe,MACrBvE,IAAIwF,KAAK,0CACF,OAAAjF,IAAA,QAEAR,OACJC,IAAAD,MAAM,sCAAuC,KAAMA,OACjD,MAAAA,KAAA,CAER,CAGA,IAAIsG,0BAEJ,SAASC,yBACJ,UAAOZ,SAAW,YAAa,CACNW,0BAAAX,OAAOa,YAAY,KAC9C,IAAKnC,MAAMG,cAAgBH,MAAMC,WAAaJ,YAAa,CAC1D,GAAIoB,eAAiBlF,YAAa,CACjCA,YAAYC,QACVoG,kBACAC,KAAK,QAGL3G,MAAM,KACNE,IAAI6F,KAAK,iDACcD,yBAAE9F,MAAOC,QAC3BC,IAAAD,MAAM,uCAAwC,MAAOA,UAE1D,CACH,GAEC,IAAK,CAEV,CAEA,SAAS2G,wBACR,GAAIL,0BAA2B,CAC9BM,cAAcN,2BACcA,+BAAA,CAAA,CAE9B,CAGO,SAASO,UACG3B,oBACIyB,uBACvB,CAGAJ,yBASA,SAASH,cAAcjE,SAClB,IACClC,IAAA4D,MAAM,kCAAmC,MAAO1B,SAEpD,OAAQA,QAAQtB,MACf,KAAKiG,YAAYC,mBACZ,GAAAC,gBAAgB7E,QAAQF,MAAO,CAClCgF,sBAAsB9E,QAAQF,KAAI,CAEnC,MACD,KAAK6E,YAAYI,YACZ,GAAAF,gBAAgB7E,QAAQF,MAAO,CAClCkF,gBAAgBhF,QAAQF,KAAI,CAE7B,MACD,KAAK6E,YAAYM,YACZ,GAAAJ,gBAAgB7E,QAAQF,MAAO,CAClCoF,gBAAgB,KAAI,CAErB,MACD,KAAKP,YAAYQ,eACZ,GAAAC,kBAAkBpF,QAAQF,MAAO,CACpCuF,kBAAkBrF,QAAQF,KAAI,CAE/B,MACD,QACChC,IAAIwF,KAAK,2CAA4C,MAAOtD,QAAQtB,aAE9Db,OACF,MAAAA,KAAA,CAER,CAGA,SAASmG,eAAehE,SAEtB,cAAOA,UAAY,UACnBA,UAAY,MACZ,SAAUA,SACV,SAAUA,gBACFA,QAAyBtB,OAAS,QAE5C,CAEA,SAASmG,gBAAgB/E,MAEvB,cAAOA,OAAS,UAChBA,OAAS,MACT,UAAWA,aACHA,KAAuBwF,QAAU,QAE3C,CAEA,SAASF,kBAAkBtF,MAEzB,cAAOA,OAAS,UAChBA,OAAS,MACT,aAAcA,aACNA,KAAyByF,WAAa,QAEhD,CAGA,SAAST,sBAAsBhF,MAC1BhC,IAAA4D,MAAM,0DAAwD,MAAO5B,MAErE,GAAAA,MAAM0F,aAAe,SAAU,CAClCC,iBAAiBvG,IAAIY,MACjBhC,IAAA4D,MAAM,sBAAuB,MAAO5B,KAAI,CAI9C,CAEA,SAASoF,gBAAgBpF,MAQzB,CAEA,SAASkF,gBAAgBlF,MACxB2F,iBAAiBvG,IAAIY,MACjBhC,IAAA4D,MAAM,eAAgB,MAAO5B,KAClC,CAEAmD,eAAeoC,kBAAkBvF,MAC5B,IACC,KAAEqD,eAAiBlF,aAAc,OAEjCH,IAAA4D,MAAM,2CAA4C,MAAO5B,MAGzD,GAAAA,MAAMpB,OAAS,SAAU,CAE5B,MAAMgH,UAAY,CACjBJ,MAAO,EACPC,SAAUzF,KAAKyF,SACfC,WAAY1F,KAAKpB,KACjBiH,IAAK,GACLC,MAAO,GACPC,WAAY,GACZC,UAAU,IAAI9G,MAAO+G,eAEhB,MAAAC,WAAa/H,YAAY+H,KAAKC,MAAM,CAAEC,OAAQ,KAAMX,SAAUzF,KAAKyF,WACrE,GAAAS,KAAKhF,OAAS,EAAG,CACpB0E,UAAUJ,MAAQU,KAAK,GAAGG,IAAM,EAChCT,UAAUC,IAAMK,KAAK,GAAGL,KAAO,GAC/BD,UAAUE,MAAQI,KAAK,GAAGJ,OAAS,GACnCF,UAAUG,WAAaG,KAAK,GAAGH,YAAc,GAEzC,GAAAH,UAAUJ,MAAQ,EAAG,CACxBG,iBAAiBvG,IAAIwG,WACjB5H,IAAA4D,MAAM,4CAA6C,MAAOgE,UAAS,CACxE,CACD,KACM,CAAA,QAIC7H,OACJC,IAAAD,MAAM,+BAAgC,MAAOA,OAC3C,MAAAA,KAAA,CAER,CCxSAoF,eAAsBmD,OACrB,GAAIC,eAAgB,CACnBvI,IAAIwF,KAAK,6DACT,MAAO,CAAC,CAAA,CAGL,IACHxF,IAAI4D,MAAM,qDAEJgC,yBACA,MAAAgC,UAAY9F,IAAI6F,kBACtB,IAAKC,UAAW,CACf,MAAMY,IAAMC,gBACZ,GAAID,IAAK,CACJ,IACH,MAAME,eAAkBF,IAAIpI,QAAQ2B,YAAY,CAC/CnB,KAAM,iBAEP,GAAI8H,UAAUd,UAAW,CACPD,iBAAAvG,IAAIsH,SAASd,UAAS,KACjC,CACF5H,IAAA4D,MACH,mDACA,YACM+E,0BAA0B,uBACjC,CAED3I,IAAI4D,MAAM,cAAe,MAAOgE,UAAWc,SAAUf,wBAC7C5H,OACJC,IAAAD,MAAM,sCAAuC,MAAOA,MAAK,CAC9D,KACM,CACNC,IAAI6F,KAAK,gCAA+B,CACzC,QAEO9F,OACJC,IAAAD,MAAM,sCAAuC,MAAOA,MAAK,CAGvD,MAAA,CACN,OAAA6I,GACShC,SAAA,EAGX"}