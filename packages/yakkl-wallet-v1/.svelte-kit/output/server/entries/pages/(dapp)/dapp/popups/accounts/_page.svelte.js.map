{"version":3,"file":"_page.svelte.js","sources":["../../../../../../../../../src/lib/extensions/chrome/verifyDomainConnected.ts","../../../../../../../../../src/routes/(dapp)/dapp/popups/accounts/+page.svelte"],"sourcesContent":["import { requestManager } from '$lib/extensions/chrome/requestManager';\nimport { log } from '$lib/managers/Logger';\n// import { getYakklConnectedDomains } from \"$lib/common/stores\";\nimport { getObjectFromLocalStorage, setObjectInLocalStorage } from '$lib/common/storage';\nimport { STORAGE_YAKKL_CONNECTED_DOMAINS, STORAGE_YAKKL_ACCOUNTS } from '$lib/common/constants';\nimport type { YakklAccount } from '$lib/common/interfaces';\n\ninterface YakklConnectedDomain {\n\tdomain: string;\n\tstatus: 'approved' | 'pending' | 'rejected';\n\taddresses?: string[];\n}\n\n// NOTE: This only works for requests that are in the background context.\nexport async function verifyDomainConnected(\n\tdomain: string | null,\n\tmethod?: string\n): Promise<boolean> {\n\ttry {\n\t\tif (!domain) {\n\t\t\tlog.warn('verifyDomainConnected: Domain is null', false);\n\t\t\treturn false;\n\t\t}\n\n\t\t// For eth_accounts, we need to check if domain is registered and approved\n\t\tif (method === 'eth_accounts') {\n\t\t\tconst connectedDomains = await getObjectFromLocalStorage<YakklConnectedDomain[]>(\n\t\t\t\tSTORAGE_YAKKL_CONNECTED_DOMAINS\n\t\t\t);\n\t\t\tif (!connectedDomains) {\n\t\t\t\tlog.debug('verifyDomainConnected: No connected domains found', false);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst domainInfo = connectedDomains.find((d) => d.domain === domain);\n\t\t\tif (!domainInfo) {\n\t\t\t\tlog.debug('verifyDomainConnected: Domain not found in connected domains', false, {\n\t\t\t\t\tdomain\n\t\t\t\t});\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Check if domain is approved\n\t\t\tif (domainInfo.status !== 'approved') {\n\t\t\t\tlog.debug('verifyDomainConnected: Domain not approved', false, {\n\t\t\t\t\tdomain,\n\t\t\t\t\tstatus: domainInfo.status\n\t\t\t\t});\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// For other methods, just check if domain exists in connected domains\n\t\tconst connectedDomains = await getObjectFromLocalStorage<YakklConnectedDomain[]>(\n\t\t\tSTORAGE_YAKKL_CONNECTED_DOMAINS\n\t\t);\n\t\tif (!connectedDomains) {\n\t\t\tlog.debug('verifyDomainConnected: No connected domains found', false);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst exists = connectedDomains.some((d) => d.domain === domain);\n\t\tlog.debug('verifyDomainConnected: Domain check result', false, { domain, exists });\n\t\treturn exists;\n\t} catch (error) {\n\t\tlog.error('Error in verifyDomainConnected:', false, error);\n\t\treturn false;\n\t}\n}\n\nexport function verifyDomainConnectedBackground(requestId: string) {\n\ttry {\n\t\tconst request = requestManager.getRequest(requestId);\n\t\tif (!request) {\n\t\t\treturn false;\n\t\t}\n\t\tconst domain = request.data.metaData.metaData.domain;\n\t\tif (!domain) {\n\t\t\treturn false;\n\t\t}\n\t\treturn verifyDomainConnected(domain);\n\t} catch (error) {\n\t\tlog.error(error);\n\t\treturn false;\n\t}\n}\n\nexport async function revokeDomainConnection(domain: string) {\n\ttry {\n\t\t// First, remove from connected domains\n\t\tconst connectedDomains = await getObjectFromLocalStorage<YakklConnectedDomain[]>(\n\t\t\tSTORAGE_YAKKL_CONNECTED_DOMAINS\n\t\t);\n\t\tif (connectedDomains) {\n\t\t\tconst existingDomainIndex = connectedDomains.findIndex((d) => d.domain === domain);\n\t\t\tif (existingDomainIndex !== -1) {\n\t\t\t\tconnectedDomains.splice(existingDomainIndex, 1);\n\t\t\t\tawait setObjectInLocalStorage(STORAGE_YAKKL_CONNECTED_DOMAINS, connectedDomains);\n\t\t\t}\n\t\t}\n\n\t\t// Then, remove domain from all accounts' connectedDomains array\n\t\tconst accounts = await getObjectFromLocalStorage<YakklAccount[]>(STORAGE_YAKKL_ACCOUNTS);\n\t\tif (accounts) {\n\t\t\tlet accountsModified = false;\n\t\t\taccounts.forEach((account) => {\n\t\t\t\tif (Array.isArray(account.connectedDomains)) {\n\t\t\t\t\tconst domainIndex = account.connectedDomains.indexOf(domain);\n\t\t\t\t\tif (domainIndex !== -1) {\n\t\t\t\t\t\taccount.connectedDomains.splice(domainIndex, 1);\n\t\t\t\t\t\taccountsModified = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (accountsModified) {\n\t\t\t\tawait setObjectInLocalStorage(STORAGE_YAKKL_ACCOUNTS, accounts);\n\t\t\t\tlog.info('Removed domain from accounts:', false, { domain, accounts });\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\tlog.error('Error in revokeDomainConnection:', false, error);\n\t}\n}\n\nexport async function getAddressesForDomain(domain: string) {\n\tconst connectedDomains = await getObjectFromLocalStorage<YakklConnectedDomain[]>(\n\t\tSTORAGE_YAKKL_CONNECTED_DOMAINS\n\t);\n\tif (connectedDomains) {\n\t\tconst existingDomainIndex = connectedDomains.findIndex((d) => d.domain === domain);\n\t\tif (existingDomainIndex !== -1) {\n\t\t\treturn connectedDomains[existingDomainIndex].addresses;\n\t\t}\n\t}\n\treturn [];\n}\n\nexport async function getDomainForRequestId(requestId: string) {\n\tconst request = requestManager.getRequest(requestId);\n\tif (!request) {\n\t\treturn null;\n\t}\n\treturn request.data.metaData.metaData.domain;\n}\n","<script lang=\"ts\">\n\timport { browser_ext, browserSvelte } from '$lib/common/environment';\n\timport {\n\t\tgetYakklAccounts,\n\t\tsetYakklConnectedDomainsStorage,\n\t\tsetYakklAccountsStorage,\n\t\tyakklDappConnectRequestStore,\n\t\tgetYakklCurrentlySelected,\n\t\tgetYakklConnectedDomains,\n\t\tgetSettings\n\t} from '$lib/common/stores';\n\timport { YAKKL_DAPP, DEFAULT_TITLE, DEFAULT_PERSONA } from '$lib/common/constants';\n\timport { onMount } from 'svelte';\n\timport { page } from '$app/state';\n\timport {\n\t\ttype AccountAddress,\n\t\ttype JsonRpcResponse,\n\t\ttype SessionInfo,\n\t\ttype YakklAccount,\n\t\ttype YakklConnectedDomain,\n\t\ttype YakklCurrentlySelected\n\t} from '$lib/common';\n\timport type { Runtime } from 'webextension-polyfill';\n\timport { dateString } from '$lib/common/datetime';\n\timport { log } from '$lib/managers/Logger';\n\timport Confirmation from '$lib/components/Confirmation.svelte';\n\timport type { BackgroundPendingRequest } from '$lib/extensions/chrome/background';\n\timport Warning from '$lib/components/Warning.svelte';\n\timport Failed from '$lib/components/Failed.svelte';\n\timport {\n\t\tcreatePortManagerWithStream,\n\t\tPortManagerWithStream\n\t} from '$lib/managers/PortManagerWithStream';\n\timport type { PortDuplexStream } from '$lib/managers/PortStreamManager';\n\timport { safeLogout } from '$lib/common/safeNavigate';\n\timport { sessionToken, verifySessionToken } from '$lib/common/auth/session';\n\timport {\n\t\trevokeDomainConnection,\n\t\tverifyDomainConnected\n\t} from '$lib/extensions/chrome/verifyDomainConnected';\n\n\ttype RuntimePort = Runtime.Port | undefined;\n\n\t// Define the ConnectedDomainAddress interface locally\n\tinterface ConnectedDomainAddress {\n\t\tid?: string;\n\t\tpersona?: string;\n\t\taddress: string;\n\t\tselected: boolean;\n\t\tchecked: boolean;\n\t\tname: string;\n\t\talias: string;\n\t\tblockchain: string;\n\t\tchainId: number;\n\t}\n\n\tinterface FilteredAddress {\n\t\tid?: string;\n\t\tpersona?: string;\n\t\taddress: string;\n\t\tname: string;\n\t\talias: string;\n\t\tblockchain: string;\n\t\tchainId: number;\n\t\tselected: boolean;\n\t\tchecked: boolean;\n\t}\n\n\tinterface AddressWithSelection {\n\t\tid?: string;\n\t\tpersona?: string;\n\t\taddress: string;\n\t\tselected?: boolean;\n\t\talias?: string;\n\t\tblockchain?: string;\n\t\tchainId?: number;\n\t\tname?: string;\n\t\tchecked?: boolean;\n\t}\n\n\t// DappInterface type definition\n\tinterface DappInterface {\n\t\tsendResponse: (response: any) => void;\n\t\tsendError: (error: any) => void;\n\t\tmethod: string;\n\t\tparams: any[];\n\t\torigin: string;\n\t}\n\n\tlet currentlySelected: YakklCurrentlySelected;\n\tlet yakklAccountsStore: YakklAccount[] = [];\n\tlet yakklConnectedDomainsStore: YakklConnectedDomain[] = [];\n\n\tlet accounts: AccountAddress[] = [];\n\tlet accountsPicked = $state(0);\n\tlet showConfirm = $state(false);\n\tlet showFailure = $state(false);\n\tlet errorValue = $state('No domain/site name was found. Access to YAKKL® is rejected.');\n\tlet domain: string = $state('');\n\tlet domainLogo: string = $state('');\n\tlet domainTitle: string = $state('');\n\tlet requestId: string | null;\n\tlet pass = false;\n\tlet filteredAddressesArray: AddressWithSelection[] = $state([]);\n\tlet currentlySelectedAddress: string = $state('');\n\tlet request: BackgroundPendingRequest;\n\tlet title: string = $state(DEFAULT_TITLE);\n\n\tlet portManager: PortManagerWithStream | null = null;\n\tlet stream: PortDuplexStream | null = null;\n\tlet dappInterface: DappInterface | null = null;\n\n\tif (browserSvelte) {\n\t\ttry {\n\t\t\trequestId = page.url.searchParams.get('requestId');\n\t\t\t$yakklDappConnectRequestStore = requestId as string;\n\n\t\t\tlog.info('Dapp - accounts page loading:', false, { requestId });\n\n\t\t\tif (requestId) {\n\t\t\t\tpass = true;\n\t\t\t}\n\t\t\t// NOTE: The internal check now makes sure the requestId is valid\n\t\t} catch (e) {\n\t\t\tlog.error(e);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\t// NOTE: We need to think through the id and persona for each store and any wrappers and how best to handle them.\n\tasync function getAccounts() {\n\t\ttry {\n\t\t\t// Get current connected domains\n\t\t\tconst connectedDomains = await getYakklConnectedDomains();\n\t\t\tconst domainExists = connectedDomains.find((d) => d.domain === domain); // && d.id === currentlySelected?.id && d.persona === currentlySelected?.persona);\n\n\t\t\t// Get primary accounts\n\t\t\tconst accounts = await getYakklAccounts();\n\t\t\tif (!accounts || accounts.length === 0) {\n\t\t\t\tawait handleReject('No accounts available. Access to YAKKL® is rejected.');\n\t\t\t}\n\n\t\t\tyakklAccountsStore = accounts;\n\n\t\t\t// Map accounts to the filtered addresses array\n\t\t\tfilteredAddressesArray = accounts.map((account: YakklAccount) => {\n\t\t\t\t// Check if this account has previously connected to the current domain\n\t\t\t\tconst hasConnectedToDomain =\n\t\t\t\t\tArray.isArray(account.connectedDomains) && account.connectedDomains.includes(domain);\n\n\t\t\t\treturn {\n\t\t\t\t\tid: account.id || '',\n\t\t\t\t\tpersona: account.persona || DEFAULT_PERSONA,\n\t\t\t\t\taddress: account.address,\n\t\t\t\t\tname: account.name,\n\t\t\t\t\talias: account.alias || account.address,\n\t\t\t\t\tblockchain: account.blockchain || 'ethereum',\n\t\t\t\t\tchainId: account.chainIds?.[0] || 1,\n\t\t\t\t\tselected: hasConnectedToDomain,\n\t\t\t\t\tchecked: hasConnectedToDomain\n\t\t\t\t};\n\t\t\t}) as AddressWithSelection[];\n\n\t\t\t// Check if currentlySelected.shortcuts.account matches any accounts.address\n\t\t\tif (currentlySelected?.shortcuts?.address) {\n\t\t\t\tconst matchingAccount = accounts.find(\n\t\t\t\t\t(account) => account.address === currentlySelected.shortcuts.address\n\t\t\t\t);\n\t\t\t\tif (matchingAccount) {\n\t\t\t\t\tcurrentlySelectedAddress = matchingAccount.address;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Update accountsPicked count\n\t\t\taccountsPicked = filteredAddressesArray.filter((addr) => addr.selected).length;\n\t\t} catch (error) {\n\t\t\tlog.error('Error in getAccounts:', false, error);\n\t\t\tshowFailure = true;\n\t\t\terrorValue = 'Failed to load accounts. Please try again.';\n\t\t}\n\t}\n\n\tasync function handleReject(message: string = 'User rejected the request.') {\n\t\ttry {\n\t\t\tshowConfirm = false;\n\t\t\tshowFailure = false;\n\t\t\tif (dappInterface) {\n\t\t\t\tdappInterface.sendError({\n\t\t\t\t\tcode: 4001,\n\t\t\t\t\tmessage\n\t\t\t\t});\n\t\t\t} else if (stream) {\n\t\t\t\tstream.write({\n\t\t\t\t\ttype: 'YAKKL_RESPONSE:EIP6963',\n\t\t\t\t\tjsonrpc: '2.0',\n\t\t\t\t\tid: requestId,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tcode: 4001,\n\t\t\t\t\t\tmessage\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tlog.error(e);\n\t\t} finally {\n\t\t\tif (browserSvelte) {\n\t\t\t\tawait close();\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction toggleAddress(address: string) {\n\t\tconst index = filteredAddressesArray.findIndex((addr) => addr.address === address);\n\t\tif (index !== -1) {\n\t\t\tconst currentAddress = filteredAddressesArray[index];\n\t\t\tfilteredAddressesArray[index] = {\n\t\t\t\t...currentAddress,\n\t\t\t\tselected: !(currentAddress.selected ?? false)\n\t\t\t};\n\t\t\tfilteredAddressesArray = [...filteredAddressesArray];\n\t\t}\n\t\taccountsPicked = filteredAddressesArray.filter((addr) => addr.selected).length;\n\t}\n\n\tasync function handleProcess(confirmed: boolean = true) {\n\t\ttry {\n\t\t\tif (!domain) {\n\t\t\t\tawait handleReject('No domain name is present. Access to YAKKL® is rejected.');\n\t\t\t}\n\n\t\t\tif (!verifySessionToken($sessionToken)) {\n\t\t\t\tawait handleReject('Session token is invalid. Login again.');\n\t\t\t}\n\n\t\t\t// Get selected addresses from filteredAddressesArray\n\t\t\tconst accounts = filteredAddressesArray\n\t\t\t\t.filter((addr) => addr.selected)\n\t\t\t\t.map((addr) => ({\n\t\t\t\t\tid: addr.id || '',\n\t\t\t\t\tpersona: addr.persona || DEFAULT_PERSONA,\n\t\t\t\t\taddress: addr.address,\n\t\t\t\t\tname: addr.name,\n\t\t\t\t\talias: addr.alias,\n\t\t\t\t\tblockchain: addr.blockchain,\n\t\t\t\t\tchainId: addr.chainId\n\t\t\t\t}));\n\n\t\t\tlet addresses = filteredAddressesArray\n\t\t\t\t.filter((addr) => addr.selected)\n\t\t\t\t.map((addr) => addr.address);\n\n\t\t\taccountsPicked = accounts.length;\n\n\t\t\tif (accounts.length === 0) {\n\t\t\t\t// Check if the domain is connected\n\t\t\t\tconst isConnected = await verifyDomainConnected(domain);\n\t\t\t\tif (!isConnected) {\n\t\t\t\t\tawait handleReject('No accounts were selected. Access to YAKKL® is rejected.');\n\t\t\t\t} else {\n\t\t\t\t\trevokeDomainConnection(domain);\n\t\t\t\t\tawait handleReject(\n\t\t\t\t\t\t'The domain is not connected to any accounts. Access to YAKKL® is rejected.'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!Array.isArray(addresses)) {\n\t\t\t\taddresses = Object.values(addresses);\n\t\t\t}\n\n\t\t\t// Update the connected domains store\n\t\t\tconst existingDomainIndex = yakklConnectedDomainsStore.findIndex((d) => d.domain === domain); // && d.id === currentlySelected?.id && d.persona === currentlySelected?.persona);\n\n\t\t\tif (existingDomainIndex === -1) {\n\t\t\t\t// Create a new domain entry if it doesn't exist\n\t\t\t\tconst newDomain: YakklConnectedDomain = {\n\t\t\t\t\tid: currentlySelected?.id || '',\n\t\t\t\t\tpersona: currentlySelected?.persona || DEFAULT_PERSONA,\n\t\t\t\t\tdomain: domain,\n\t\t\t\t\tname: domainTitle || domain,\n\t\t\t\t\ticon: domainLogo,\n\t\t\t\t\taddresses: accounts,\n\t\t\t\t\tpermissions: {}, // We do not set permissions here. This is handled in the permissions page.\n\t\t\t\t\tchainId: currentlySelected?.shortcuts?.chainId || 1,\n\t\t\t\t\turl: domain,\n\t\t\t\t\tstatus: 'approved', // The status is a first line of defense for incoming requests.\n\t\t\t\t\trevoked: {},\n\t\t\t\t\tversion: currentlySelected?.version || '',\n\t\t\t\t\tcreateDate: dateString(),\n\t\t\t\t\tupdateDate: dateString()\n\t\t\t\t};\n\n\t\t\t\tyakklConnectedDomainsStore = [...yakklConnectedDomainsStore, newDomain];\n\t\t\t} else {\n\t\t\t\t// Update existing domain\n\t\t\t\tconst existingDomain = yakklConnectedDomainsStore[existingDomainIndex];\n\t\t\t\texistingDomain.id = currentlySelected?.id || '';\n\t\t\t\texistingDomain.persona = currentlySelected?.persona || DEFAULT_PERSONA;\n\t\t\t\texistingDomain.name = domainTitle || domain;\n\t\t\t\texistingDomain.icon = domainLogo;\n\t\t\t\texistingDomain.addresses = accounts;\n\t\t\t\texistingDomain.updateDate = dateString();\n\t\t\t\texistingDomain.version = currentlySelected?.version || existingDomain.version;\n\t\t\t\texistingDomain.chainId = currentlySelected?.shortcuts?.chainId || 1;\n\t\t\t\texistingDomain.url = domain;\n\t\t\t\texistingDomain.status = 'approved'; // The status is a first line of defense for incoming requests.\n\n\t\t\t\t// Update the store with the modified domain\n\t\t\t\tyakklConnectedDomainsStore = [\n\t\t\t\t\t...yakklConnectedDomainsStore.slice(0, existingDomainIndex),\n\t\t\t\t\texistingDomain,\n\t\t\t\t\t...yakklConnectedDomainsStore.slice(existingDomainIndex + 1)\n\t\t\t\t];\n\t\t\t}\n\n\t\t\tawait setYakklConnectedDomainsStorage(yakklConnectedDomainsStore);\n\n\t\t\t// Update accounts store with connected domains\n\t\t\tfor (const account of yakklAccountsStore) {\n\t\t\t\tconst accountIndex = yakklAccountsStore.findIndex((a) => a.address === account.address); // && a.id === currentlySelected?.id && a.persona === currentlySelected?.persona);\n\t\t\t\tif (accountIndex !== -1) {\n\t\t\t\t\tconst existingAccount = yakklAccountsStore[accountIndex];\n\t\t\t\t\tif (!Array.isArray(existingAccount.connectedDomains)) {\n\t\t\t\t\t\texistingAccount.connectedDomains = [];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if this account is in the selected accounts\n\t\t\t\t\tconst isSelected = accounts.some((acc) => acc.address === account.address); // && acc.id === currentlySelected?.id && acc.persona === currentlySelected?.persona);\n\n\t\t\t\t\tif (isSelected) {\n\t\t\t\t\t\t// Add domain if not already present\n\t\t\t\t\t\tif (!existingAccount.connectedDomains.includes(domain)) {\n\t\t\t\t\t\t\texistingAccount.connectedDomains.push(domain);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Remove domain if present\n\t\t\t\t\t\tconst domainIndex = existingAccount.connectedDomains.indexOf(domain);\n\t\t\t\t\t\tif (domainIndex !== -1) {\n\t\t\t\t\t\t\texistingAccount.connectedDomains.splice(domainIndex, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tyakklAccountsStore[accountIndex] = existingAccount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait setYakklAccountsStorage(yakklAccountsStore);\n\n\t\t\t// Send response to dapp\n\t\t\tif (dappInterface) {\n\t\t\t\tlog.debug('Dapp - accounts process: Sending response to dapp:', false, {\n\t\t\t\t\trequestId,\n\t\t\t\t\taddresses\n\t\t\t\t});\n\n\t\t\t\tdappInterface.sendResponse({\n\t\t\t\t\tid: requestId,\n\t\t\t\t\ttype: 'YAKKL_RESPONSE:EIP6963',\n\t\t\t\t\tjsonrpc: '2.0',\n\t\t\t\t\tresult: addresses,\n\t\t\t\t\tmethod: dappInterface.method\n\t\t\t\t});\n\t\t\t} else if (stream) {\n\t\t\t\tlog.debug('Dapp - accounts process: Sending response via stream:', false, {\n\t\t\t\t\trequestId,\n\t\t\t\t\taddresses\n\t\t\t\t});\n\n\t\t\t\tconst response: JsonRpcResponse = {\n\t\t\t\t\ttype: 'YAKKL_RESPONSE:EIP6963',\n\t\t\t\t\tjsonrpc: '2.0',\n\t\t\t\t\tid: requestId,\n\t\t\t\t\tresult: addresses\n\t\t\t\t};\n\t\t\t\tstream.write(response);\n\t\t\t} else {\n\t\t\t\tawait handleReject(\n\t\t\t\t\t'Request failed to send to dapp due to missing port stream. Access to YAKKL® is rejected.'\n\t\t\t\t);\n\t\t\t}\n\t\t\tawait close();\n\t\t} catch (error: any) {\n\t\t\tlog.error('Dapp - accounts process error:', true, error);\n\t\t\terrorValue = error as string;\n\t\t}\n\t}\n\n\t// We no longer need to do get_params since we can access the request data directly\n\tasync function onMessageListener(event: any) {\n\t\ttry {\n\t\t\tif (!domainLogo) domainLogo = '/images/failIcon48x48.png'; // Set default logo but change if favicon is present\n\n\t\t\tif (event.method === 'get_params') {\n\t\t\t\trequest = event.result;\n\t\t\t\tif (!request || !request.data) {\n\t\t\t\t\tawait handleReject('No requested data was found. Access to YAKKL® is rejected.');\n\t\t\t\t}\n\n\t\t\t\tconst requestData = request.data;\n\t\t\t\tif (!requestData || !requestData.metaData) {\n\t\t\t\t\tawait handleReject('Invalid request data. Access to YAKKL® is rejected.');\n\t\t\t\t}\n\n\t\t\t\t// Create dappInterface from the request data\n\t\t\t\tdappInterface = {\n\t\t\t\t\tsendResponse: (response: any) => {\n\t\t\t\t\t\tif (stream) {\n\t\t\t\t\t\t\tstream.write(response);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tsendError: (error: any) => {\n\t\t\t\t\t\tif (stream) {\n\t\t\t\t\t\t\tstream.write({\n\t\t\t\t\t\t\t\ttype: 'YAKKL_RESPONSE:EIP6963',\n\t\t\t\t\t\t\t\tjsonrpc: '2.0',\n\t\t\t\t\t\t\t\tid: requestId,\n\t\t\t\t\t\t\t\terror\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tmethod: requestData.method || 'eth_requestAccounts',\n\t\t\t\t\tparams: requestData.params || [],\n\t\t\t\t\torigin: requestData.metaData?.metaData?.origin || domain\n\t\t\t\t};\n\n\t\t\t\t// These needs to be fixed upstream\n\t\t\t\tdomainTitle = requestData.metaData.metaData.title;\n\t\t\t\tdomain = requestData.metaData.metaData.domain;\n\t\t\t\tdomainLogo = requestData.metaData.metaData.icon;\n\n\t\t\t\t// Set the page title\n\t\t\t\ttitle = domainTitle || domain || DEFAULT_TITLE;\n\n\t\t\t\tif (!requestId) requestId = requestData?.id ?? null;\n\t\t\t\tif (!requestId) {\n\t\t\t\t\tshowFailure = true;\n\t\t\t\t\terrorValue = 'No request ID was found. Access to YAKKL® is rejected.';\n\t\t\t\t} else {\n\t\t\t\t\t// Call getAccounts to handle domain checking and account setup\n\t\t\t\t\tawait getAccounts();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tlog.error(e);\n\t\t\thandleReject(\n\t\t\t\t'An error occurred while processing the request. Access to YAKKL® is rejected.'\n\t\t\t);\n\t\t}\n\t}\n\n\tonMount(async () => {\n\t\ttry {\n\t\t\tif (browserSvelte) {\n\t\t\t\tlog.info('Dapp - accounts page mounted:', false);\n\n\t\t\t\tconst settings = await getSettings();\n\t\t\t\tif (!settings.init || !settings.legal.termsAgreed) {\n\t\t\t\t\terrorValue =\n\t\t\t\t\t\t\"You must register and agree to the terms of service before using YAKKL®. Click on 'Open Wallet' to register.\";\n\t\t\t\t\tshowFailure = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlog.info('Dapp - accounts page getting settings:', false, settings);\n\n\t\t\t\tcurrentlySelected = await getYakklCurrentlySelected();\n\t\t\t\tlog.info('Dapp - accounts page getting currently selected:', false, currentlySelected);\n\n\t\t\t\t// Since we're 1:1 we can attach to the known port name\n\t\t\t\tconst sessionInfo = (await browser_ext.runtime.sendMessage({\n\t\t\t\t\ttype: 'REQUEST_SESSION_PORT',\n\t\t\t\t\trequestId\n\t\t\t\t})) as SessionInfo;\n\n\t\t\t\tconsole.log('sessionInfo - debugger', sessionInfo);\n\t\t\t\tconsole.log('Received session info:', sessionInfo, sessionInfo?.portName);\n\n\t\t\t\t// Guard against null response\n\t\t\t\tif (!sessionInfo || !sessionInfo.success) {\n\t\t\t\t\tlog.warn('Failed to verify session port. No response received. Using YAKKL_DAPP.');\n\t\t\t\t}\n\n\t\t\t\t// Create port manager with the original port name\n\t\t\t\tportManager = createPortManagerWithStream(sessionInfo?.portName ?? YAKKL_DAPP);\n\t\t\t\tportManager.setRequestId(requestId);\n\n\t\t\t\tconst success = await portManager.createPort();\n\t\t\t\tif (!success) {\n\t\t\t\t\terrorValue = 'Failed to connect to session port.';\n\t\t\t\t\tshowFailure = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tstream = portManager.getStream();\n\t\t\t\tif (!stream) {\n\t\t\t\t\terrorValue = 'Stream is not available.';\n\t\t\t\t\tshowFailure = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tstream.on('data', onMessageListener);\n\t\t\t\tstream.write({ method: 'get_params', id: requestId });\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tlog.error(e);\n\t\t}\n\t});\n\n\tasync function close() {\n\t\tif (browserSvelte) {\n\t\t\ttry {\n\t\t\t\tif (portManager) {\n\t\t\t\t\tawait portManager.waitForIdle(1500);\n\t\t\t\t\tportManager.disconnect();\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tlog.warn('Port did not go idle in time', false, e);\n\t\t\t}\n\t\t\tsafeLogout();\n\t\t}\n\t}\n</script>\n\n<svelte:head>\n\t<title>{title}</title>\n</svelte:head>\n\n<!-- <Warning bind:show={showFailure} title=\"Error\" value={errorValue} /> -->\n<Failed bind:show={showFailure} title=\"Failed!\" content={errorValue} onReject={handleReject} />\n<Confirmation\n\tbind:show={showConfirm}\n\ttitle=\"Connect to {domain}\"\n\tmessage=\"This will connect {domain} to {accountsPicked} of your addresses! Do you wish to continue?\"\n\tonConfirm={handleProcess}\n/>\n\n<!-- {#if showConfirm}\n<div class=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center\">\n  <div class=\"bg-base-100 rounded-xl p-6 max-w-sm w-full mx-4 shadow-xl\">\n    <h3 class=\"text-lg font-bold mb-4\">Connect to {domain}</h3>\n    <p class=\"mb-6\">Connect <span class=\"font-bold text-primary\">{accountsPicked}</span> address{accountsPicked > 1 ? 'es' : ''} to {domain}?</p>\n    <div class=\"mt-4 flex justify-end space-x-2\">\n      <button\n        class=\"px-4 py-2 bg-gray-200 rounded\"\n        onclick={() => window.close()}\n      >\n        Cancel\n      </button>\n      <button\n        class=\"px-4 py-2 bg-blue-500 text-white rounded\"\n        onclick={handleProcess}\n      >\n        Connect\n      </button>\n    </div>\n  </div>\n</div>\n{/if} -->\n\n<!-- {#if showFailure}\n  <div class=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center\">\n    <div class=\"bg-base-100 rounded-xl p-6 max-w-sm w-full mx-4 shadow-xl\">\n      <h3 class=\"text-lg font-bold mb-4 text-error\">Failed!</h3>\n      <p class=\"mb-6\">{errorValue}</p>\n      <div class=\"flex justify-end\">\n        <button\n          class=\"btn btn-primary\"\n          onclick={() => handleReject()}\n        >\n          Close\n        </button>\n      </div>\n    </div>\n  </div>\n{:else} -->\n<div class=\"flex flex-col h-full max-h-screen overflow-hidden\">\n\t<!-- Header -->\n\t<div class=\"p-4 border-b border-base-300 flex-shrink-0\">\n\t\t<div class=\"flex items-center justify-between\">\n\t\t\t<div class=\"flex items-center gap-2 min-w-0\">\n\t\t\t\t<img\n\t\t\t\t\tid=\"dappImageId\"\n\t\t\t\t\tcrossorigin=\"anonymous\"\n\t\t\t\t\tsrc={domainLogo}\n\t\t\t\t\talt=\"Dapp logo\"\n\t\t\t\t\tclass=\"w-8 h-8 rounded-full flex-shrink-0\"\n\t\t\t\t/>\n\t\t\t\t<span class=\"font-semibold truncate\">{title}</span>\n\t\t\t</div>\n\t\t\t<button\n\t\t\t\tonclick={() => handleReject()}\n\t\t\t\tclass=\"btn btn-ghost btn-sm flex-shrink-0\"\n\t\t\t\taria-label=\"Close\"\n\t\t\t>\n\t\t\t\t<svg\n\t\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\t\t\tclass=\"h-5 w-5\"\n\t\t\t\t\tviewBox=\"0 0 20 20\"\n\t\t\t\t\tfill=\"currentColor\"\n\t\t\t\t>\n\t\t\t\t\t<path\n\t\t\t\t\t\tfill-rule=\"evenodd\"\n\t\t\t\t\t\td=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\"\n\t\t\t\t\t\tclip-rule=\"evenodd\"\n\t\t\t\t\t/>\n\t\t\t\t</svg>\n\t\t\t</button>\n\t\t</div>\n\t</div>\n\n\t<!-- Content -->\n\t<div class=\"flex-1 p-6 overflow-hidden flex flex-col max-w-[428px]\">\n\t\t<div class=\"text-center mb-4 flex-shrink-0\">\n\t\t\t<h2 class=\"text-xl font-bold mb-2\">Select Accounts</h2>\n\t\t\t<p class=\"text-base-content/80\">Choose which accounts to connect to {domain}</p>\n\t\t</div>\n\n\t\t<div class=\"overflow-y-auto flex-1 min-h-0 mb-4\">\n\t\t\t{#each filteredAddressesArray as address}\n\t\t\t\t{#if address.address === currentlySelectedAddress}\n\t\t\t\t\t<!-- Column layout for currentlySelectedAddress -->\n\t\t\t\t\t<div class=\"flex items-start gap-3 p-3 bg-base-200 rounded-lg mb-2\">\n\t\t\t\t\t\t<input\n\t\t\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\t\t\tclass=\"checkbox checkbox-primary w-5 h-5 flex-shrink-0 text-2xl\"\n\t\t\t\t\t\t\tchecked={address.checked}\n\t\t\t\t\t\t\tonchange={() => toggleAddress(address.address)}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<div class=\"flex flex-col\">\n\t\t\t\t\t\t\t<span class=\"font-mono text-sm truncate\" title={address.address}\n\t\t\t\t\t\t\t\t>{address.address}</span\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<span class=\"badge badge-primary text-xs mt-1\">Default account</span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t{:else}\n\t\t\t\t\t<!-- Row layout for other addresses -->\n\t\t\t\t\t<div class=\"flex items-center gap-3 p-3 bg-base-200 rounded-lg mb-2\">\n\t\t\t\t\t\t<input\n\t\t\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\t\t\tclass=\"checkbox checkbox-primary w-5 h-5 flex-shrink-0 text-2xl\"\n\t\t\t\t\t\t\tchecked={address.checked}\n\t\t\t\t\t\t\tonchange={() => toggleAddress(address.address)}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<span class=\"font-mono text-sm truncate\" title={address.address}>{address.address}</span\n\t\t\t\t\t\t>\n\t\t\t\t\t</div>\n\t\t\t\t{/if}\n\t\t\t{/each}\n\t\t</div>\n\t</div>\n\n\t<!-- Footer -->\n\t<div class=\"p-4 border-t border-base-300 flex-shrink-0\">\n\t\t<div class=\"flex gap-4 justify-end\">\n\t\t\t<button onclick={() => handleReject()} class=\"btn btn-outline\"> Reject </button>\n\t\t\t<button\n\t\t\t\tonclick={() => {\n\t\t\t\t\tshowConfirm = true;\n\t\t\t\t}}\n\t\t\t\tclass=\"btn btn-primary\"\n\t\t\t>\n\t\t\t\tConnect\n\t\t\t</button>\n\t\t</div>\n\t</div>\n</div>\n\n<!-- {/if} -->\n\n<style>\n\t/* Smooth transitions */\n\t.btn {\n\t\ttransition: all 0.2s ease;\n\t}\n\n\t.btn:hover {\n\t\ttransform: translateY(-1px);\n\t}\n\n\t/* Custom scrollbar */\n\t.overflow-y-auto {\n\t\tscrollbar-width: thin;\n\t\tscrollbar-color: hsl(var(--p)) transparent;\n\t}\n\n\t.overflow-y-auto::-webkit-scrollbar {\n\t\twidth: 6px;\n\t}\n\n\t.overflow-y-auto::-webkit-scrollbar-track {\n\t\tbackground: transparent;\n\t}\n\n\t.overflow-y-auto::-webkit-scrollbar-thumb {\n\t\tbackground-color: hsl(var(--p));\n\t\tborder-radius: 3px;\n\t}\n</style>\n"],"names":["async","verifyDomainConnected","domain","method","log","warn","connectedDomains","getObjectFromLocalStorage","STORAGE_YAKKL_CONNECTED_DOMAINS","debug","exists","some","d","error","revokeDomainConnection","existingDomainIndex","findIndex","splice","setObjectInLocalStorage","accounts","STORAGE_YAKKL_ACCOUNTS","accountsModified","forEach","account","Array","isArray","domainIndex","indexOf","info","currentlySelected","yakklAccountsStore","yakklConnectedDomainsStore","accountsPicked","showConfirm","showFailure","errorValue","domainLogo","domainTitle","requestId","pass","filteredAddressesArray","currentlySelectedAddress","title","DEFAULT_TITLE","portManager","stream","dappInterface","browserSvelte","page","url","searchParams","get","$.store_set","yakklDappConnectRequestStore","e","handleReject","message","close","handleProcess","confirmed","verifySessionToken","$.store_get","$$store_subs","sessionToken","filter","addr","selected","map","id","persona","DEFAULT_PERSONA","address","name","alias","blockchain","chainId","addresses","length","isConnected","Object","values","newDomain","icon","permissions","shortcuts","status","revoked","version","createDate","dateString","updateDate","existingDomain","slice","setYakklConnectedDomainsStorage","accountIndex","a","existingAccount","isSelected","acc","includes","push","setYakklAccountsStorage","safeLogout","$$value","$.stringify","each_array","$$index","$$payload","out","$.attr","checked","$.escape"],"mappings":"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"}