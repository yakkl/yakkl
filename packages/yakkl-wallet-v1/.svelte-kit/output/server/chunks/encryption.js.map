{"version":3,"file":"encryption.js","sources":["../../../../src/lib/common/logger-wrapper.ts","../../../../src/lib/common/types.ts","../../../../src/lib/common/constants.ts","../../../../src/lib/common/errors.ts","../../../../src/lib/common/bignumber.ts","../../../../src/lib/common/misc.ts","../../../../src/lib/common/math.ts","../../../../src/lib/common/storage.ts","../../../../src/lib/common/datetime.ts","../../../../src/lib/models/dataModels.ts","../../../../src/lib/common/bignumber-ethereum.ts","../../../../src/lib/managers/utilities/EthersConverter.ts","../../../../src/lib/managers/FeeManager.ts","../../../../src/lib/common/gas-types.ts","../../../../src/lib/managers/AnalyticsBase.ts","../../../../src/lib/managers/blockchains/evm/ethereum/EthereumAnalytics.ts","../../../../src/lib/managers/providers/fees/ethereum/EthereumGasProvider.ts","../../../../src/lib/managers/providers/price/coinbase/CoinbasePriceProvider.ts","../../../../src/lib/managers/Blockchain.ts","../../../../src/lib/managers/Contract.ts","../../../../src/lib/managers/blockchains/evm/ethereum/EthereumContract.ts","../../../../src/lib/managers/blockchains/evm/ethereum/Ethereum.ts","../../../../src/lib/managers/contracts/evm/constants-evm.ts","../../../../src/lib/managers/Wallet.ts","../../../../src/lib/common/stores/tokens.ts","../../../../src/lib/common/stores.ts","../../../../src/lib/common/encryption.ts"],"sourcesContent":["// $lib/common/logger-wrapper.ts\nimport { log as LoggerInstance, LogLevel } from '$managers/Logger';\n\n// Production-safe logger that tree-shakes debug and info calls\nexport const log = {\n\t// These will be completely removed in production builds\n\tdebug: __DEV__ ? LoggerInstance.debug.bind(LoggerInstance) : () => {},\n\tdebugStack: __DEV__ ? LoggerInstance.debugStack.bind(LoggerInstance) : () => {},\n\twarn: __DEV__ ? LoggerInstance.warn.bind(LoggerInstance) : () => {},\n\terrorStack: __DEV__ ? LoggerInstance.errorStack.bind(LoggerInstance) : () => {},\n\tinfo: __DEV__ ? LoggerInstance.info.bind(LoggerInstance) : () => {},\n\tinfoStack: __DEV__ ? LoggerInstance.infoStack.bind(LoggerInstance) : () => {},\n\ttrace: __DEV__ ? LoggerInstance.trace.bind(LoggerInstance) : () => {},\n\n\t// NOTE: For shaking out unused code, we can add to the top the LoggerInstance.debug.bind(LoggerInstance)\n\t// and then remove it from the bottom. Debug is used for illustration only in LoggerInstance.\n\n\t// These remain in production\n\t// warn: LoggerInstance.warn.bind(LoggerInstance),\n\terror: LoggerInstance.error.bind(LoggerInstance),\n\t// errorStack: LoggerInstance.errorStack.bind(LoggerInstance),\n\t// trace: LoggerInstance.trace.bind(LoggerInstance),\n\n\t// Utility methods should remain available\n\tsetLevel: LoggerInstance.setLevel.bind(LoggerInstance),\n\tsetLogFilterEnabled: LoggerInstance.setLogFilterEnabled.bind(LoggerInstance),\n\tsetLogFilterRegex: LoggerInstance.setLogFilterRegex.bind(LoggerInstance),\n\tsetStackIndex: LoggerInstance.setStackIndex.bind(LoggerInstance),\n\tsetBackend: LoggerInstance.setBackend.bind(LoggerInstance),\n\tclearPersistedLogs: LoggerInstance.clearPersistedLogs.bind(LoggerInstance),\n\tgetPersistedLogs: LoggerInstance.getPersistedLogs.bind(LoggerInstance)\n};\n\n// Re-export types\nexport { LogLevel, LogLevelDirection } from '$managers/Logger';\nexport type { LogEntry } from '$managers/Logger';\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {\n\tEventFilter,\n\tAddressable,\n\tYakklAccount,\n\tYakklChat,\n\tYakklConnectedDomain,\n\tYakklPrimaryAccount,\n\tYakklContact,\n\tNetwork,\n\tBigNumberish,\n\tTokenData,\n\tActiveTab\n} from '$lib/common';\n\nexport type SimulatedTx = {\n\ttoken: string;\n\tamount: number;\n\trequiresApproval?: boolean;\n};\n\nexport type NotificationType = 'basic' | 'image' | 'list' | 'progress';\n\nexport interface NotificationBase {\n\ttype: NotificationType;\n\ttitle: string;\n\tmessage: string;\n\trequireInteraction?: boolean;\n\tsilent?: boolean;\n\tpriority?: -2 | -1 | 0 | 1 | 2;\n\tcontextMessage?: string;\n\tbuttons?: Array<{ title: string; iconUrl?: string }>;\n\teventTime?: number;\n}\n\nexport interface BasicNotificationOptions extends NotificationBase {\n\ttype: 'basic';\n}\n\nexport interface ListNotificationOptions extends NotificationBase {\n\ttype: 'list';\n\titems: Array<{ title: string; message: string }>;\n}\n\nexport interface ImageNotificationOptions extends NotificationBase {\n\ttype: 'image';\n\timageUrl: string;\n}\n\nexport interface ProgressNotificationOptions extends NotificationBase {\n\ttype: 'progress';\n\tprogress: number;\n}\n\nexport type NotificationOptions =\n\t| BasicNotificationOptions\n\t| ListNotificationOptions\n\t| ImageNotificationOptions\n\t| ProgressNotificationOptions;\n\nexport type CreateNotificationOptions = NotificationOptions & {\n\ticonUrl: string;\n};\n\nexport interface NotificationOptionsExample {\n\t// Priority affects how the notification is displayed (-2 to 2)\n\tpriority?: number;\n\t// -2: Lowest priority - might be hidden in notification center\n\t// -1: Low priority - shown in notification center\n\t//  0: Default priority\n\t//  1: High priority - more prominent display\n\t//  2: Highest priority - most prominent, might bypass \"quiet hours\"\n\n\t// If true, notification stays visible until user interacts\n\trequireInteraction?: boolean;\n\t// false (default): Notification may auto-dismiss\n\t// true: Notification persists until clicked/dismissed\n\n\t// For progress notifications (0 to 100)\n\tprogress?: number;\n\t// Shows a progress bar, useful for operations like:\n\t// - Loading/saving data\n\t// - Download progress\n\t// - Operation completion percentage\n\n\t// If true, notification appears without sound\n\tsilent?: boolean;\n\t// false (default): Play system notification sound\n\t// true: No sound on notification\n\n\t// Additional context shown below main message\n\tcontextMessage?: string;\n\t// Smaller text below the main message\n\t// Example: \"Last updated: 2 minutes ago\"\n\n\t// Action buttons (max 2 buttons)\n\tbuttons?: Array<{\n\t\ttitle: string; // Button text\n\t\ticonUrl?: string; // Button icon\n\t}>;\n\n\t// Timestamp for the notification\n\teventTime?: number;\n\t// Unix timestamp in milliseconds\n\t// Shows when the event occurred\n}\n\nexport type AccountType = YakklAccount | YakklPrimaryAccount;\nexport type YakklAccounts = [YakklAccount];\n// export type YakklAssets = [YakklAsset];\nexport type YakklChats = [YakklChat];\nexport type YakklConnectedDomains = [YakklConnectedDomain];\nexport type YakklPrimaryAccounts = [YakklPrimaryAccount];\n// export type YakklTransactions = [YakklTransaction];\nexport type YakklContacts = [YakklContact];\nexport type YakklNetworks = [Network];\n\nexport type ErrorBody = {\n\terror?: string;\n\treason?: string;\n\tbody?: string; // Ensure body is a string\n\t[key: string]: unknown; // Use `unknown` instead of `any` for better type safety\n};\n\nexport enum SystemTheme {\n\tDARK = 'dark',\n\tLIGHT = 'light',\n\tSYSTEM = 'system'\n}\n\nexport enum AccountTypeCategory {\n\tPRIMARY = 'primary',\n\tSUB = 'sub',\n\tCONTRACT = 'contract',\n\tIMPORTED = 'imported'\n}\n\nexport enum AccountTypeStatus {\n\tACTIVE = 'active',\n\tINACTIVE = 'inactive',\n\tDELETED = 'deleted'\n}\n\nexport enum RegisteredType {\n\tBASIC_MEMBER = 'basic_member',\n\tFOUNDING_MEMBER = 'founding_member',\n\tEARLY_ADOPTER = 'early_adopter',\n\tYAKKL_PRO = 'yakkl_pro',\n\tINSTITUTION = 'institution',\n\tBUSINESS = 'business',\n\tENTERPRISE = 'enterprise'\n}\n\nexport enum PlanType {\n\tTRIAL = 'trial',\n\tBASIC_MEMBER = 'basic_member',\n\tFOUNDING_MEMBER = 'founding_member',\n\tEARLY_ADOPTER = 'early_adopter',\n\tYAKKL_PRO = 'yakkl_pro',\n\tINSTITUTION = 'institution',\n\tBUSINESS = 'business',\n\tENTERPRISE = 'enterprise'\n}\n\n// accessSource?: AccessSourceType\nexport enum AccessSourceType {\n\tSTANDARD = 'standard', // normal free user\n\tSUBSCRIBED = 'subscribed', // paid user\n\tTRIAL = 'trial', // X-day trial\n\tPROMO = 'promo' // manual influencer / employee / etc\n}\n\n// trialEndDate?: string (ISO format)\n\n// promoType?: PromoClassificationType\nexport enum PromoClassificationType {\n\tFOUNDING_MEMBER = 'founding_member',\n\tEARLY_ADOPTER = 'early_adopter',\n\tYAKKL_PRO = 'yakkl_pro',\n\tINFLUENCER = 'influencer',\n\tEMPLOYEE = 'employee',\n\tSPECIAL = 'special',\n\tEVENT = 'event',\n\tOTHER = 'other',\n\tNONE = 'none'\n} // Use for analytics, targeting, feature flags, etc.\n\nexport enum NetworkType {\n\tMAINNET = 'mainnet',\n\tTESTNET = 'testnet',\n\tPRIVATE = 'private',\n\tOTHER = 'other'\n}\n\n// Used for checking prices of asset pairs from different providers such as coinbase, coingecko, etc.\nexport type PricingStore = {\n\tprovider: string; // e.g. \"coinbase\"\n\tid: string; // profile id\n\tpair?: string; // e.g. \"ETH/USD\"\n\tprice: number; // e.g. 2000\n\tprevPrice?: number; // e.g. 1990 - set prevPrice = price before getting new price\n};\n\n// Sub-classes of Signer may optionally extend this interface to indicate\n// they have a private key available synchronously\nexport interface ExternallyOwnedAccount {\n\treadonly address: string;\n\treadonly privateKey: string;\n}\n\nexport type ParsedError = ErrorBody | string | null;\n\nexport type EventType = string | Array<string | Array<string>> | EventFilter; // | ForkEvent;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Listener = (...args: Array<any>) => void;\n\n// export type Numeric = number | bigint;\n// export type BigNumberish = string | Numeric | null;\nexport type BigNumberishLegacy = string | number | bigint;\nexport type Numberish = string | number;\nexport type Address = string;\nexport type Hash = string;\n\nexport type BlockTag = BigNumberish | string;\n\n// Allows us to creates a new type that takes a generic type T and transforms it such that each property of T can either be its original type or a promise of its original type.\nexport type Deferrable<T> = {\n\t[K in keyof T]: T[K] | Promise<T[K]>;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Result = { key: string; value: any };\n\n/**\n *  Anything that can be used to return or resolve an address.\n */\nexport type AddressLike = string | Promise<string> | Addressable;\n\n/**\n *  A [[HexString]] whose length is even, which ensures it is a valid\n *  representation of binary data.\n */\nexport type DataHexString = string;\n\n/**\n *  A string which is prefixed with ``0x`` and followed by any number\n *  of case-agnostic hexadecimal characters.\n *\n *  It must match the regular expression ``/0x[0-9A-Fa-f]*\\/``.\n */\nexport type HexString = string;\n\n/**\n *  An object that can be used to represent binary data.\n */\nexport type BytesLike = DataHexString | Uint8Array;\n\nexport type PermissionRequest = {\n\tkey: string;\n\torigin: string;\n\tfaviconUrl: string;\n\tchainId: string;\n\ttitle: string;\n\tstate: string; //\"request\" | \"allow\" | \"deny\"\n\taccountAddress: string;\n};\n\nexport type URI = string;\nexport type URL = string;\nexport type DomainName = string;\n\nexport type IMAGEPATH = string; // This is a path to a file or directory, URL, or base64 encoded string of an image\n\nimport type { YakklCurrentlySelected, Settings, Preferences } from '$lib/common';\nimport type { Blockchain } from '$lib/managers/Blockchain';\nimport type { TokenService } from '$lib/managers/blockchains/evm/TokenService';\nimport type { Provider } from '$lib/managers/Provider';\nimport type { Wallet } from '$lib/managers/Wallet';\n\nexport interface LayoutData {\n\tcurrentlySelected: YakklCurrentlySelected | null;\n\tyakklSettings: Settings | null;\n\tyakklMiscStore: string;\n\tyakklPrimaryAccountsStore: YakklPrimaryAccount[];\n\tyakklPreferences: Preferences | null;\n\tinstances: [Wallet | null, Provider | null, Blockchain | null, TokenService<any> | null];\n\tyakklTokenDataStore: TokenData[];\n}\n\n// Used by the BackgroundManager to store messages in local storage\nexport interface BaseMessage<T = unknown> {\n\ttype: string;\n\tdata: T;\n}\n\n// alias for the active tab data\nexport interface TabChangeData extends ActiveTab {}\n\nexport interface WindowFocusData {\n\twindowId: number;\n\ttype?: string;\n}\n\n// Define all possible message types\nexport type MessageTypes = BaseMessage<TabChangeData> | BaseMessage<WindowFocusData>;\n// Add other message types here\n\n// Create an enum for message type strings\nexport enum MessageType {\n\tACTIVE_TAB_CHANGED = 'ACTIVE_TAB_CHANGED',\n\tTAB_UPDATED = 'TAB_UPDATED',\n\tTAB_REMOVED = 'TAB_REMOVED',\n\tWINDOW_FOCUSED = 'WINDOW_FOCUSED'\n\t// ... other message types\n}\n","// IMPORTANT NOTE: Edit 'constants.mustache' since it is the template for 'constants.ts'\n\n// Global shared constants. Network specifics are in the network/<whatever>/contants.js file\nexport const VERSION = \"2.0.0\";\n\nexport const YEAR = \"2025\"; // Instead of computing year since user can change date on system - use a constant\n\nexport const TRIAL_DAYS = 14;\nexport const PRO_ELIGIBLE_PROMO_TYPES = [\n  'investor',\n  'influencer',\n  'employee',\n  'special',\n  'founding', // Founding members\n  'early',  // Early adopters\n  'partner',\n  'founder',\n  'internal',\n  'press'\n];\n\nexport const FOUNDING_MEMBER_DEADLINE = '2025-08-15T04:00:00.000Z'; // UTC time with 4 hour difference for est\nexport const EARLY_ADOPTER_DEADLINES = [\n  { date: '2025-10-01T04:00:00.000Z', price: 120 },\n  { date: '2025-11-15T04:00:00.000Z', price: 132 },\n  { date: '2026-01-01T04:00:00.000Z', price: 144 }\n];\n\nexport const YAKKL_PRO_ANNUAL_FEE = 144;\n\nexport const DEFAULT_PERSONA = \"default\";\nexport const GAS_PER_BLOB = 131072; // 2**17\n\nexport const TIMELINES = ['1h', '24h', '7d', '30d'] as const;\nexport const NUM_OF_SPLASH_IMAGES = 3;\nexport const SPLASH_DELAY = 3000; //milliseconds\nexport const ALERT_DELAY = 3000; //milliseconds\nexport const IDLE_AUTO_LOCK_CYCLE = 2; // multiplier of seconds (e.g., 60000*1 = 1 minute)\nexport const IDLE_AUTO_LOCK_CYCLE_TIME = 60000; //milliseconds\nexport const DEBUG_ALL_LOGS = true; // NOTE: Make sure it is set to false for production\nexport const TIMER_CHECK_PRICE_INTERVAL_TIME = 10000 // 10 seconds\nexport const TIMER_PRICE_INTERVAL_TIME = 10000 // 10 seconds\nexport const TIMER_CHECK_GAS_PRICE_INTERVAL_TIME = 10000; //milliseconds (10 seconds)\nexport const TIMER_CONNECTION_INTERVAL_TIME = 30000;\nexport const TIMER_TOKEN_PRICE_CYCLE_TIME = 15000; //milliseconds (30 seconds)\nexport const TIMER_SWAP_FETCH_PRICES_TIME = 60000;\nexport const TIMER_ICON_CHECK_TIME = 60000;\nexport const TIMER_IDLE_THRESHOLD = 120000; //milliseconds (2 minutes)\nexport const TIMER_IDLE_LOCK_DELAY = 60000; //milliseconds (1 minute)\nexport const TIMER_IDLE_CHECK_INTERVAL = 15000; //milliseconds (15 seconds)\nexport const TIMER_IDLE_CHECK_INTERVAL_APP_WIDE = 15000; //milliseconds (15 seconds)\nexport const TIMER_GAS_PRICE_CHECK = 'gas_checkGasPrices';\n\n\nexport const TIMEOUT_COPY_TO_CLIPBOARD = 20000; //milliseconds - redacts the clipboard after this time\n\n// Retry and backoff constants\nexport const DEV_MAX_RETRIES = 5;\nexport const DEV_BASE_DELAY = 1000; //milliseconds\n\nexport const ETH_BASE_EOA_GAS_UNITS = 21000; // Base amount of gas units it takes for a EOA transaction\nexport const ETH_BASE_SCA_GAS_UNITS = 45000; // Base amount of gas units it takes for a Smart Contract transaction\nexport const ETH_BASE_SWAP_GAS_UNITS = 500000n; // Base amount of gas units it takes for a Uniswap transaction\nexport const ETH_BASE_FORCANCEL_GAS_UNITS = ETH_BASE_EOA_GAS_UNITS * 3;\n\nexport const WETH_ADDRESS = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'; // WETH address on Ethereum mainnet\n\nexport const YAKKL_GAS_ESTIMATE_MIN_USD = 3.50;\nexport const YAKKL_GAS_ESTIMATE_MULTIHOP_SWAP_DEFAULT = 3750000;\nexport const YAKKL_GAS_ESTIMATE_MULTIPLIER_BASIS_POINTS = 30000n; // 300%\nexport const YAKKL_FEE_BASIS_POINTS = 42.25; //875; // 0.875%\nexport const YAKKL_FEE_BASIS_POINTS_DIVISOR = 10_000;\nexport const YAKKL_FEE_ACCEPTABLE_TOKENS = [\"ETH\", \"WETH\", \"YAKKL\", \"USDC\", \"USDT\", \"DAI\", \"WBTC\"] // Tokens that are acceptable for fee payment\n\nexport const YAKKL_ZERO_ADDRESS = \"0x0000000000000000000000000000000000000000\";\nexport const YAKKL_ZERO_ACCOUNT_NAME = \"YAKKL - Zero Account - YAKKL\";\nexport const YAKKL_ZERO_ACCOUNT_TYPE = \"NA\"; // Not applicable - default value\n\nexport const YAKKL_INTERNAL = \"yakkl-internal\";\nexport const YAKKL_EXTERNAL = \"yakkl-external\";\nexport const YAKKL_PROVIDER_EIP6963 = \"yakkl-provider-eip6963\";\nexport const YAKKL_PROVIDER = \"yakkl-provider\";\nexport const YAKKL_PROVIDER_ETHEREUM = \"yakkl-provider-ethereum\";\nexport const YAKKL_SPLASH = \"yakkl-splash\";\nexport const YAKKL_DAPP = \"yakkl-dapp\";\nexport const YAKKL_UNIFIED_PORT = 'yakkl-unified';\nexport const YAKKL_ETH = \"yakkl-eth\";\n\n// Logical viewport size of iPhone pro max\nexport const DEFAULT_POPUP_WIDTH = 428; //394;\nexport const DEFAULT_POPUP_HEIGHT = 926; //620;\nexport const DEFAULT_EXT_HEIGHT = 926; //600;\nexport const DEFAULT_TITLE = \"YAKKL® Smart Wallet\";\nexport const DEFAULT_UPGRADE_LABEL = \"Pro - \";\n\nexport const DEFAULT_DERIVED_PATH_ETH = \"m/44'/60'/\"; // '0'/0/0' - First of these three represents the account. Last of these three represents index and gets dynamically created. Middle one of these three is always '0'\n\nexport const DEFAULT_YAKKL_ASSETS = \"yakklAssets\"; // Not stored in local storage but static json.\n\nexport const CURRENT_STORAGE_VERSION = 1; // Increment this value when the storage format changes for migration purposes. Secure storage keys are versioned.\nexport const STORAGE_YAKKL_PREFERENCES = \"preferences\";\nexport const STORAGE_YAKKL_SETTINGS = \"settings\";\nexport const STORAGE_YAKKL_SECURITY = \"yakklSecurity\";\nexport const STORAGE_YAKKL_PORTFOLIO = \"yakklPortfolio\";\nexport const STORAGE_YAKKL_CURRENTLY_SELECTED = \"yakklCurrentlySelected\";\nexport const STORAGE_YAKKL_REGISTERED_DATA = \"yakklRegisteredData\";\n\nexport const STORAGE_YAKKL_PROFILE = \"profile\";\nexport const STORAGE_YAKKL_PROFILES = \"profiles\";\nexport const STORAGE_YAKKL_ACCOUNTS = \"yakklAccounts\";\nexport const STORAGE_YAKKL_PRIMARY_ACCOUNTS = \"yakklPrimaryAccounts\";\nexport const STORAGE_YAKKL_CONTACTS = \"yakklContacts\";\n//export const STORAGE_YAKKL_TOKENS = \"yakklTokens\";\nexport const STORAGE_YAKKL_TOKENDATA = \"yakklTokenData\";\nexport const STORAGE_YAKKL_TOKENDATA_CUSTOM = \"yakklTokenDataCustom\";\nexport const STORAGE_YAKKL_COMBINED_TOKENS = \"yakklCombinedTokens\";\nexport const STORAGE_YAKKL_CHATS = \"yakklChats\";\nexport const STORAGE_YAKKL_WATCHLIST = \"yakklWatchList\";\nexport const STORAGE_YAKKL_BLOCKEDLIST = \"yakklBlockedList\";\nexport const STORAGE_YAKKL_CONNECTED_DOMAINS = \"yakklConnectedDomains\";\n\nexport const STORAGE_YAKKL_WALLET_PROVIDERS = \"yakklWalletProviders\";\nexport const STORAGE_YAKKL_WALLET_BLOCKCHAINS = \"yakklWalletBlockchains\";\nexport const STORAGE_YAKKL_WALLET_ACTIVE_TAB = \"yakklWalletActiveTab\";\n\nexport const STORAGE_YAKKL_MEMPOOL = \"yakklMemPool\";\n\nexport const PASSKEY_HINTS_MIN = 3;\n\nexport const PATH_HOME = \"/\";\nexport const PATH_REGISTER = \"/register/Register\";\nexport const PATH_LOGIN = \"/login/Login\";\nexport const PATH_LOCK = \"/lock\";\nexport const PATH_CONTACTS = \"/contacts\";\nexport const PATH_WELCOME = \"/welcome/welcome\";\nexport const PATH_DASHBOARD = \"/dashboard\";\nexport const PATH_LOGOUT = \"/logout\";\nexport const PATH_IMPORT_EMERGENCYKIT = \"/import/import-emergencykit\";\nexport const PATH_IMPORT_PRIVATEKEY = \"/import/import-privatekey\";\nexport const PATH_IMPORT_WATCH = \"/import/import-watch\";\nexport const PATH_IMPORT_PHRASE = \"/import/import-phrase\";\nexport const PATH_EXPORT = \"/export\";\nexport const PATH_EXPORT_EXPORT = \"/export/export\";\nexport const PATH_ACCOUNTS = \"/accounts\";\nexport const PATH_ACCOUNTS_ETHEREUM_CREATE_PRIMARY = \"/accounts/ethereum/create/primary\";\nexport const PATH_ACCOUNTS_ETHEREUM_CREATE_DERIVED = \"/accounts/ethereum/create/derived\";\nexport const PATH_ACCOUNT_MAINTENANCE = \"/accounts/ethereum/maintenance\";\nexport const PATH_LEGAL = \"/legal/Legal\";\nexport const PATH_PROFILE = \"/components/profile\";\nexport const PATH_ACTIVITIES = \"/activities\";\nexport const PATH_CRYPTO = \"/crypto\";\nexport const PATH_NFTS = \"/nfts\";\nexport const PATH_UNIVERSITY = \"/university\";\nexport const PATH_SECURITY = \"/security\";\nexport const PATH_SECURITY_PASSWORD = \"/security/password\";\nexport const PATH_SECURITY_2FA = \"/security/2fa\";\nexport const PATH_SECURITY_USERNAME = \"/security/username\";\nexport const PATH_SECURITY_SECRET = \"/security/secret\";\nexport const PATH_SECURITY_RESET = \"/security/reset\";\nexport const PATH_SETTINGS = \"/settings\";\nexport const PATH_SETTINGS_PREFERENCES = \"/settings/preferences\";\nexport const PATH_SETTINGS_SETTINGS = \"/settings/settings\";\nexport const PATH_TOKENS = \"/tokens\";\nexport const PATH_WEB3 = \"/web3\";\nexport const PATH_DAPP_TRANSACTIONS = \"/dapp/popups/transactions\";\nexport const PATH_DAPP_ACCOUNTS = \"/dapp/popups/accounts\";\nexport const PATH_DAPP_POPUPS = \"/dapp/popups\"; // base for all popups specific for dapps\nexport const PATH_ETHEREUM_TRANSACTIONS_SEND = \"/accounts/ethereum/transactions/send\";\nexport const PATH_ETHEREUM_TRANSACTIONS_RECV = \"/accounts/ethereum/transactions/recv\";\nexport const PATH_ETHEREUM_TRANSACTIONS_SWAP = \"/accounts/ethereum/transactions/swap\";\nexport const PATH_ETHEREUM_TRANSACTIONS_SELL = \"/accounts/ethereum/transactions/sell\";\nexport const PATH_ETHEREUM_TRANSACTIONS_STAKE = \"/accounts/ethereum/transactions/stake\";\nexport const PATH_ETHEREUM_TRANSACTIONS_BUY = \"/accounts/ethereum/transactions/buy\";\n\nexport enum EVMDenominations {\n  ETH = 'ETH',\n  GWEI = 'GWEI',\n  WEI = 'WEI',\n}\n\n// Add other blockchain denominations\n\n\n// Just temporary...\nexport const WEB3_SVG = '<svg height=\"512\" viewBox=\"0 0 512 512\" width=\"512\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" aria-hidden=\"true\" focusable=\"false\" style=\"width: 28px; height: 28px;\"><radialGradient id=\"injected-a\" cx=\"1.813132%\" cy=\"50%\" r=\"98.186868%\"><stop offset=\"0\" stop-color=\"#424242\"></stop><stop offset=\"1\"></stop></radialGradient><g fill=\"none\" fill-rule=\"evenodd\"><path d=\"m256 0c141.384896 0 256 114.615104 256 256 0 141.384896-114.615104 256-256 256-141.384896 0-256-114.615104-256-256 0-141.384896 114.615104-256 256-256z\" fill=\"url(#injected-a)\"></path><path d=\"m137.902344 242.761719-15.820313 55.957031h-16.699219l-22.382812-84.550781h18.398438l13.183593 59.589843h.9375l15.410157-59.589843h14.941406l15.703125 59.589843h.9375l13.066406-59.589843h18.28125l-22.441406 84.550781h-16.582031l-15.996094-55.957031zm127.324218 40.839843v15.117188h-56.015624v-84.550781h56.015624v15.117187h-38.320312v19.746094h36.152344v14.003906h-36.152344v20.566406zm56.601563 15.117188h-37.96875v-84.550781h36.972656c16.40625 0 26.191407 8.027343 26.191407 21.09375 0 8.964843-6.621094 16.757812-15.292969 18.046875v1.054687c11.191406.820313 19.335937 9.257813 19.335937 20.15625 0 14.824219-11.191406 24.199219-29.238281 24.199219zm-20.273437-71.015625v21.503906h13.300781c9.550781 0 14.765625-3.925781 14.765625-10.722656 0-6.738281-4.863282-10.78125-13.300782-10.78125zm0 57.480469h15.761718c10.195313 0 15.703125-4.277344 15.703125-12.1875 0-7.734375-5.683593-11.835938-16.113281-11.835938h-15.351562zm84.433593-23.144532v-13.183593h10.3125c8.027344 0 13.476563-4.6875 13.476563-11.601563 0-6.796875-5.273438-11.132812-13.535156-11.132812-8.203126 0-13.652344 4.628906-14.121094 11.953125h-16.347656c.585937-15.996094 12.480468-26.074219 30.9375-26.074219 17.34375 0 29.824218 9.492188 29.824218 22.792969 0 9.785156-6.152344 17.402343-15.585937 19.335937v1.054688c11.601562 1.289062 18.867187 9.023437 18.867187 20.15625 0 14.824218-13.945312 25.546875-33.222656 25.546875-18.867188 0-31.640625-10.429688-32.402344-26.367188h16.933594c.527344 7.148438 6.5625 11.660157 15.644531 11.660157 8.847657 0 15-4.980469 15-12.1875 0-7.382813-5.800781-11.953126-15.292969-11.953126z\" fill=\"#fff\"></path></g></svg>';\n\nexport const WEB3_SVG_DATA = 'data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIHdpZHRoPSI1MTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIGFyaWEtaGlkZGVuPSJ0cnVlIiBmb2N1c2FibGU9ImZhbHNlIiBzdHlsZT0id2lkdGg6IDQ4cHg7IGhlaWdodDogNDhweDsiPjxyYWRpYWxHcmFkaWVudCBpZD0iaW5qZWN0ZWQtYSIgY3g9IjEuODEzMTMyJSIgY3k9IjUwJSIgcj0iOTguMTg2ODY4JSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjNDI0MjQyIj48L3N0b3A+PHN0b3Agb2Zmc2V0PSIxIj48L3N0b3A+PC9yYWRpYWxHcmFkaWVudD48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjxwYXRoIGQ9Im0yNTYgMGMxNDEuMzg0ODk2IDAgMjU2IDExNC42MTUxMDQgMjU2IDI1NiAwIDE0MS4zODQ4OTYtMTE0LjYxNTEwNCAyNTYtMjU2IDI1Ni0xNDEuMzg0ODk2IDAtMjU2LTExNC42MTUxMDQtMjU2LTI1NiAwLTE0MS4zODQ4OTYgMTE0LjYxNTEwNC0yNTYgMjU2LTI1NnoiIGZpbGw9InVybCgjaW5qZWN0ZWQtYSkiPjwvcGF0aD48cGF0aCBkPSJtMTM3LjkwMjM0NCAyNDIuNzYxNzE5LTE1LjgyMDMxMyA1NS45NTcwMzFoLTE2LjY5OTIxOWwtMjIuMzgyODEyLTg0LjU1MDc4MWgxOC4zOTg0MzhsMTMuMTgzNTkzIDU5LjU4OTg0M2guOTM3NWwxNS40MTAxNTctNTkuNTg5ODQzaDE0Ljk0MTQwNmwxNS43MDMxMjUgNTkuNTg5ODQzaC45Mzc1bDEzLjA2NjQwNi01OS41ODk4NDNoMTguMjgxMjVsLTIyLjQ0MTQwNiA4NC41NTA3ODFoLTE2LjU4MjAzMWwtMTUuOTk2MDk0LTU1Ljk1NzAzMXptMTI3LjMyNDIxOCA0MC44Mzk4NDN2MTUuMTE3MTg4aC01Ni4wMTU2MjR2LTg0LjU1MDc4MWg1Ni4wMTU2MjR2MTUuMTE3MTg3aC0zOC4zMjAzMTJ2MTkuNzQ2MDk0aDM2LjE1MjM0NHYxNC4wMDM5MDZoLTM2LjE1MjM0NHYyMC41NjY0MDZ6bTU2LjYwMTU2MyAxNS4xMTcxODhoLTM3Ljk2ODc1di04NC41NTA3ODFoMzYuOTcyNjU2YzE2LjQwNjI1IDAgMjYuMTkxNDA3IDguMDI3MzQzIDI2LjE5MTQwNyAyMS4wOTM3NSAwIDguOTY0ODQzLTYuNjIxMDk0IDE2Ljc1NzgxMi0xNS4yOTI5NjkgMTguMDQ2ODc1djEuMDU0Njg3YzExLjE5MTQwNi44MjAzMTMgMTkuMzM1OTM3IDkuMjU3ODEzIDE5LjMzNTkzNyAyMC4xNTYyNSAwIDE0LjgyNDIxOS0xMS4xOTE0MDYgMjQuMTk5MjE5LTI5LjIzODI4MSAyNC4xOTkyMTl6bS0yMC4yNzM0MzctNzEuMDE1NjI1djIxLjUwMzkwNmgxMy4zMDA3ODFjOS41NTA3ODEgMCAxNC43NjU2MjUtMy45MjU3ODEgMTQuNzY1NjI1LTEwLjcyMjY1NiAwLTYuNzM4MjgxLTQuODYzMjgyLTEwLjc4MTI1LTEzLjMwMDc4Mi0xMC43ODEyNXptMCA1Ny40ODA0NjloMTUuNzYxNzE4YzEwLjE5NTMxMyAwIDE1LjcwMzEyNS00LjI3NzM0NCAxNS43MDMxMjUtMTIuMTg3NSAwLTcuNzM0Mzc1LTUuNjgzNTkzLTExLjgzNTkzOC0xNi4xMTMyODEtMTEuODM1OTM4aC0xNS4zNTE1NjJ6bTg0LjQzMzU5My0yMy4xNDQ1MzJ2LTEzLjE4MzU5M2gxMC4zMTI1YzguMDI3MzQ0IDAgMTMuNDc2NTYzLTQuNjg3NSAxMy40NzY1NjMtMTEuNjAxNTYzIDAtNi43OTY4NzUtNS4yNzM0MzgtMTEuMTMyODEyLTEzLjUzNTE1Ni0xMS4xMzI4MTItOC4yMDMxMjYgMC0xMy42NTIzNDQgNC42Mjg5MDYtMTQuMTIxMDk0IDExLjk1MzEyNWgtMTYuMzQ3NjU2Yy41ODU5MzctMTUuOTk2MDk0IDEyLjQ4MDQ2OC0yNi4wNzQyMTkgMzAuOTM3NS0yNi4wNzQyMTkgMTcuMzQzNzUgMCAyOS44MjQyMTggOS40OTIxODggMjkuODI0MjE4IDIyLjc5Mjk2OSAwIDkuNzg1MTU2LTYuMTUyMzQ0IDE3LjQwMjM0My0xNS41ODU5MzcgMTkuMzM1OTM3djEuMDU0Njg4YzExLjYwMTU2MiAxLjI4OTA2MiAxOC44NjcxODcgOS4wMjM0MzcgMTguODY3MTg3IDIwLjE1NjI1IDAgMTQuODI0MjE4LTEzLjk0NTMxMiAyNS41NDY4NzUtMzMuMjIyNjU2IDI1LjU0Njg3NS0xOC44NjcxODggMC0zMS42NDA2MjUtMTAuNDI5Njg4LTMyLjQwMjM0NC0yNi4zNjcxODhoMTYuOTMzNTk0Yy41MjczNDQgNy4xNDg0MzggNi41NjI1IDExLjY2MDE1NyAxNS42NDQ1MzEgMTEuNjYwMTU3IDguODQ3NjU3IDAgMTUtNC45ODA0NjkgMTUtMTIuMTg3NSAwLTcuMzgyODEzLTUuODAwNzgxLTExLjk1MzEyNi0xNS4yOTI5NjktMTEuOTUzMTI2eiIgZmlsbD0iI2ZmZiI+PC9wYXRoPjwvZz48L3N2Zz4K';\n\nexport const LOGO_BULLFAV48x48 = 'data:image/png;base64,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'\n\nexport const LOGO_BULLFAV_SVG_DATA = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJhIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgNzU4LjczIDczOC45MiI+PGRlZnM+PHJhZGlhbEdyYWRpZW50IGlkPSJiIiBjeD0iMzk5LjMiIGN5PSIzNTkuNDIiIGZ4PSIzOTkuMyIgZnk9IjM1OS40MiIgcj0iMzUxLjY2IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIuMDMiIHN0b3AtY29sb3I9IiNhZTVlYTQiLz48c3RvcCBvZmZzZXQ9Ii4zNCIgc3RvcC1jb2xvcj0iIzhmNGI5YiIvPjxzdG9wIG9mZnNldD0iLjg5IiBzdG9wLWNvbG9yPSIjNWMyZDhjIi8+PHN0b3Agb2Zmc2V0PSIuOTUiIHN0b3AtY29sb3I9IiM1YTJjOGEiLz48c3RvcCBvZmZzZXQ9Ii45OCIgc3RvcC1jb2xvcj0iIzU1MmI4MyIvPjxzdG9wIG9mZnNldD0iLjk5IiBzdG9wLWNvbG9yPSIjNGQyODc3Ii8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjNDgyNzcwIi8+PC9yYWRpYWxHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9ImMiIHgxPSIyMTkuNjMiIHkxPSI0OC4yMSIgeDI9IjU3OC45OCIgeTI9IjY3MC42MyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iI2RlOWQyNiIvPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iI2Y4YzkyNyIvPjxzdG9wIG9mZnNldD0iLjMyIiBzdG9wLWNvbG9yPSIjZTJhZTI0Ii8+PHN0b3Agb2Zmc2V0PSIuNjgiIHN0b3AtY29sb3I9IiNmY2YyOTAiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNmZmQ0M2YiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iZCIgeDE9IjI3MS40MSIgeTE9IjQxMy40OSIgeDI9IjM0MC45MyIgeTI9IjQxMy40OSIgeGxpbms6aHJlZj0iI2MiLz48bGluZWFyR3JhZGllbnQgaWQ9ImUiIHgxPSI0NTcuNjciIHkxPSI0MTMuNDkiIHgyPSI1MjcuMiIgeTI9IjQxMy40OSIgeGxpbms6aHJlZj0iI2MiLz48bGluZWFyR3JhZGllbnQgaWQ9ImYiIHgxPSIxMjAuNjIiIHkxPSI0MTkuMjgiIHgyPSI2NzcuOTkiIHkyPSI0MTkuMjgiIHhsaW5rOmhyZWY9IiNjIi8+PGxpbmVhckdyYWRpZW50IGlkPSJnIiB4MT0iMzU4LjU5IiB5MT0iMjkzLjk3IiB4Mj0iNDQwLjAyIiB5Mj0iMjkzLjk3IiB4bGluazpocmVmPSIjYyIvPjwvZGVmcz48Y2lyY2xlIGN4PSIzOTkuMyIgY3k9IjM1OS40MiIgcj0iMzUxLjY2IiBzdHlsZT0iZmlsbDp1cmwoI2IpOyBzdHJva2Utd2lkdGg6MHB4OyIvPjxwYXRoIGQ9Im0zOTkuMyw3MTguODRjLTE5OC4xOSwwLTM1OS40Mi0xNjEuMjQtMzU5LjQyLTM1OS40MlMyMDEuMTIsMCwzOTkuMywwczM1OS40MiwxNjEuMjQsMzU5LjQyLDM1OS40Mi0xNjEuMjQsMzU5LjQyLTM1OS40MiwzNTkuNDJabTAtNzAzLjMzQzIwOS42NywxNS41Miw1NS40LDE2OS43OSw1NS40LDM1OS40MnMxNTQuMjcsMzQzLjksMzQzLjksMzQzLjksMzQzLjktMTU0LjI3LDM0My45LTM0My45UzU4OC45MywxNS41MiwzOTkuMywxNS41MloiIHN0eWxlPSJmaWxsOnVybCgjYyk7IHN0cm9rZS13aWR0aDowcHg7Ii8+PHBhdGggZD0ibTMwNS4xNywzNjkuODhzLTE5LjM0LTE4LjI5LTMzLjc2LTIxLjF2NTQuODZsNjcuNTMsNzQuNTZzNi4zMy0yMy4yMS0zLjUyLTUzLjQ2YzAsMC0zNC4xMS0xNC40Mi0zMC4yNS01NC44NloiIHN0eWxlPSJmaWxsOnVybCgjZCk7IHN0cm9rZS13aWR0aDowcHg7Ii8+PHBhdGggZD0ibTQ2My4xOSw0MjQuNzRjLTkuODUsMzAuMjUtMy41Miw1My40Ni0zLjUyLDUzLjQ2bDY3LjUzLTc0LjU2di01NC44NmMtMTQuNDIsMi44MS0zMy43NiwyMS4xLTMzLjc2LDIxLjEsMy44Nyw0MC40NC0zMC4yNSw1NC44Ni0zMC4yNSw1NC44NloiIHN0eWxlPSJmaWxsOnVybCgjZSk7IHN0cm9rZS13aWR0aDowcHg7Ii8+PHBhdGggZD0ibTQ2MC40LDI2Mi45M2wtNDkuMzYsODUuNDljLTUuMDgsOC43OS0xOC40MSw4Ljc5LTIzLjQ4LDBsLTQ5LjM2LTg1LjQ5Yy04NS4wOCw0Ny4yNS0yMTcuNTgtMzUuOTgtMjE3LjU4LTM1Ljk4LDM3LjI2LDQ4LjUxLDc5LjcxLDY5LjczLDExNS4zLDc4LjM3LDU2LjczLDEzLjc3LDEwNS43LDQ3LjYxLDEzNS4xNiw5NS41M2wuNjYsMS4wN2MtMS45OCw3Ljk3LTIuOTgsMTYuMTMtMi45OCwyNC4zMnYxMDguODVjMCwyLjQzLS4yNiw0LjgzLS42OSw3LjItMTEuMDQsNy4xNy0xOC4wOSwxOC4wNS0xOC4wOSwzMC4yMywwLDIxLjU4LDIyLjA5LDM5LjA4LDQ5LjMzLDM5LjA4czQ5LjMzLTE3LjUsNDkuMzMtMzkuMDhjMC0xMi4xOS03LjA1LTIzLjA3LTE4LjA5LTMwLjIzLS40My0yLjM3LS42OS00Ljc3LS42OS03LjJ2LTEwOC44NWMwLTguMTktMS0xNi4zNS0yLjk4LTI0LjMybC42Ni0xLjA3YzI5LjQ2LTQ3LjkyLDc4LjQzLTgxLjc3LDEzNS4xNi05NS41MywzNS41OS04LjY0LDc4LjA0LTI5Ljg2LDExNS4zLTc4LjM3LDAsMC0xNjEuMDgsODUuOTYtMjE3LjU4LDM1Ljk4Wm0tNjEuMSwzNDIuNDljLTIyLjksMC00MS41Mi0xNC43Ni00MS41Mi0zMi45LDAtMi41Ni40MS01LjAzLDEuMTEtNy40Mmg4MC44NGMuNywyLjM5LDEuMTEsNC44NywxLjExLDcuNDIsMCwxOC4xNC0xOC42MywzMi45LTQxLjUyLDMyLjlaIiBzdHlsZT0iZmlsbDp1cmwoI2YpOyBzdHJva2Utd2lkdGg6MHB4OyIvPjxwYXRoIGQ9Im00MDcuMTMsMzIxLjA3bDMyLjg5LTYwLjE3cy00Mi41MywxNi45Mi04MS40MywwbDMyLjg5LDYwLjE3czguMzEsMTMuNDMsMTUuNjUsMFoiIHN0eWxlPSJmaWxsOnVybCgjZyk7IHN0cm9rZS13aWR0aDowcHg7Ii8+PHRleHQvPjwvc3ZnPg==\"\n\nexport const PROVIDERS = {\n    YAKKL: 'yakkl',\n    INFURA: 'infura',\n    ALCHEMY: 'alchemy',\n    ETHERSCAN: 'etherscan',\n};\n\nexport const PRICE_PROVIDERS = {\n    ETHERSCAN: 'etherscan',\n    COINBASE: 'coinbase',\n    KRAKEN: 'kraken',\n};\n\nexport const BLOCKCHAINS = {\n    ETHEREUM: 'ethereum',\n    BITCOIN: 'bitcoin',\n    SOLANA: 'solana',\n    CARDANO: 'cardano',\n};\n\nexport const BLOCKCHAINS_NETWORKS = {\n    ETHEREUM: {\n        mainnet: 'mainnet',\n        sepolia: 'sepolia',\n    },\n    BITCOIN: 'bitcoin',\n    SOLANA: 'solana',\n    CARDANO: 'cardano',\n};\n\nexport const ENVIRONMENT_TYPES = {\n    BACKGROUND: 'background',\n    BROWSER: 'browser',\n    NOTIFICATION: 'notification',\n    POPUP: 'index',\n};\n\nexport const PLATFORM_TYPES = {\n    BRAVE: 'Brave',\n    CHROME: 'Chrome',\n    EDGE: 'Edge',\n    FIREFOX: 'Firefox',\n    OPERA: 'Opera',\n    SAFARI: 'Safari',  // We don't support currently\n};\n\nexport const TOKEN_IMAGES = {\n    ETH_URL: './images/eth_logo.svg',\n    BNB_URL: './images/bnb.png',\n    MATIC_URL: './images/matic-token.png',\n};\n\n// Maybe change these to reflect the user_agent value\nexport const OS_TYPES = {\n    OSX: 'OSX', //Mac\n    WINDOWS: 'Windows',\n    LINUX_REDHAT: 'Red Hat',\n    LINUX_UBUNTU: 'Ubuntu',\n    LINUX_OTHER: 'Linux',\n    CHROME: 'Chrome OS',\n    ANDROID: 'Android',\n    IOS: \"iOS\",\n};\n\nexport const SMART_TRANSACTION_STATUSES = {\n    CANCELLED: 'cancelled',\n    PENDING: 'pending',\n    SUCCESS: 'success',\n};\n\n// Wallet security configuration\nimport { SecurityLevel } from '$lib/permissions/types';\n\nexport const WALLET_SECURITY_CONFIG = {\n  DEFAULT_SECURITY_LEVEL: 'medium' as SecurityLevel,\n  DEFAULT_INJECT_IFRAMES: true,\n  TRUSTED_DOMAINS: [\n    'ethereum.org',\n    'uniswap.org',\n    'opensea.io',\n    'metamask.io',\n    // Add other trusted domains as needed\n  ],\n  SECURITY_LEVEL_SETTINGS: {\n    'high': {\n      injectIframes: false,\n      description: 'No iframe injection (highest security)'\n    },\n    'medium': {\n      injectIframes: true,\n      description: 'Inject into trusted domains only (balanced security)'\n    },\n    'standard': {\n      injectIframes: true,\n      description: 'Inject into all non-null origin frames (dApp compatible)'\n    }\n  } as Record<SecurityLevel, { injectIframes: boolean; description: string }>\n} as const;\n\n// Security level types\n// export type SecurityLevel = 0 | 1 | 2;\n\n// Security level descriptions\nexport const SECURITY_LEVEL_DESCRIPTIONS: Record<SecurityLevel, string> = {\n  'high': 'Most restrictive - no iframe injection',\n  'medium': 'Trusted domains only - injects only into known dApp domains',\n  'standard': 'Most permissive - injects into all non-null origin frames'\n} as const;\n\n","import { log } from '$lib/managers/Logger';\n\nexport class YakklError extends Error {\n\tcode?: string;\n\tinfo?: Record<string, unknown>;\n\n\tconstructor(message: string, code?: string, info?: Record<string, unknown>) {\n\t\tsuper(message);\n\t\tthis.name = 'YakklError';\n\t\tthis.code = code;\n\t\tthis.info = info;\n\t}\n}\n\nexport function makeError(\n\tmessage: string,\n\tcode?: string,\n\tinfo?: Record<string, unknown>\n): YakklError {\n\treturn new YakklError(message, code, info);\n}\n\n// Parses error messages from JSON-RPC responses\n// and formats them into a more user-friendly structure.\nexport interface RPCParsedError {\n\tmessage: string;\n\tcode: number;\n\tdetails?: {\n\t\trequestMethod?: string;\n\t\turl?: string;\n\t\tjsonrpc?: string;\n\t\tid?: number;\n\t};\n}\n\nexport function parseJsonRpcError(errorString: string): RPCParsedError {\n\ttry {\n\t\t// First, try to parse the entire string as JSON\n\t\tlet parsed;\n\t\ttry {\n\t\t\t// Handle cases where the error is already a JSON object\n\t\t\tparsed = typeof errorString === 'string' ? JSON.parse(errorString) : errorString;\n\t\t} catch {\n\t\t\t// If direct parsing fails, try to extract JSON portion\n\t\t\tconst jsonMatch = errorString.match(/\\{.*\\}/);\n\t\t\tif (jsonMatch) {\n\t\t\t\tparsed = JSON.parse(jsonMatch[0]);\n\t\t\t}\n\t\t}\n\n\t\tif (parsed) {\n\t\t\t// Handle nested error object\n\t\t\tconst errorObj = parsed.error || parsed;\n\n\t\t\t// Extract relevant information\n\t\t\treturn {\n\t\t\t\tmessage: formatErrorMessage(errorObj.message || 'Unknown error'),\n\t\t\t\tcode: errorObj.code || -1,\n\t\t\t\tdetails: {\n\t\t\t\t\trequestMethod: extractValue(errorString, 'requestMethod'),\n\t\t\t\t\turl: extractValue(errorString, 'url'),\n\t\t\t\t\tjsonrpc: parsed.jsonrpc,\n\t\t\t\t\tid: parsed.id\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Fallback for unparseable errors\n\t\treturn {\n\t\t\tmessage: errorString,\n\t\t\tcode: -1\n\t\t};\n\t} catch (e) {\n\t\tlog.error('Error parsing error message:', false, e);\n\t\treturn {\n\t\t\tmessage: errorString,\n\t\t\tcode: -1\n\t\t};\n\t}\n}\n\n// Helper function to format error messages\n// function formatErrorMessage(message: string): string {\n//   // Remove any JSON syntax\n//   message = message.replace(/[{}\"\\\\]/g, '');\n\n//   // Convert to sentence case and clean up\n//   message = message.charAt(0).toUpperCase() + message.slice(1);\n\n//   // Handle specific error cases\n//   if (message.includes('transaction underpriced')) {\n//     return 'Transaction failed: Gas price too low. Please try again with a higher gas price.';\n//   }\n\n//   // Add more specific error handling as needed\n\n//   return message;\n// }\n\n// NOTE: Add a more comprehensive error handling\n// function to cover more cases and provide better user feedback\n// This function can be expanded with more specific error messages\nexport function formatErrorMessage(message: string): string {\n\t// Common Ethereum errors\n\tconst errorMappings: Record<string, string> = {\n\t\t'transaction underpriced':\n\t\t\t'Transaction failed: Gas price too low. Please try again with a higher gas price. Maybe add a tip as well.',\n\t\t'insufficient funds': 'Transaction failed: Insufficient funds to complete this transaction.',\n\t\t'nonce too low': 'Transaction failed: Please wait for your previous transaction to complete.',\n\t\t'already known': 'This transaction has already been submitted.',\n\t\t'replacement transaction underpriced':\n\t\t\t'Cannot replace existing transaction: New gas price too low.',\n\t\t'gas limit reached':\n\t\t\t'Transaction failed: Network is busy. Please try again later or increase gas limit.'\n\t};\n\n\t// Check for known error patterns\n\tfor (const [pattern, friendlyMessage] of Object.entries(errorMappings)) {\n\t\tif (message.toLowerCase().includes(pattern.toLowerCase())) {\n\t\t\treturn friendlyMessage;\n\t\t}\n\t}\n\n\t// Clean up the message if no specific mapping found\n\tmessage = message.replace(/[{}\"\\\\]/g, '');\n\tmessage = message.charAt(0).toUpperCase() + message.slice(1);\n\n\treturn message;\n}\n\n// Helper function to extract values from error string\nfunction extractValue(errorString: string, key: string): string | undefined {\n\tconst match = new RegExp(`${key}=\"([^\"]*)\"`, 'i').exec(errorString);\n\treturn match ? match[1] : undefined;\n}\n\n// Usage example:\n// try {\n// Your code that might throw an error\n// } catch (error) {\n//   const parsedError = parseJsonRpcError(error.toString());\n\n// You can now use the parsed error to show a user-friendly message\n//   log.info('User friendly error:', parsedError.message);\n//   log.info('Error code:', parsedError.code);\n//   log.info('Additional details:', parsedError.details);\n// }\n\n// Status code\tName\t                  Description\n// 4001\t        User Rejected Request\t  The user rejected the request.\n// 4100\t        Unauthorized\t          The requested method and/or account has not been authorized by the user.\n// 4200\t        Unsupported Method\t    The Provider does not support the requested method.\n// 4900\t        Disconnected\t          The Provider is disconnected from all chains.\n// 4901\t        Chain Disconnected\t    The Provider is not connected to the requested chain.\n\nexport const ErrorCodes = {\n\trpc: {\n\t\tinvalidInput: -32000,\n\t\tresourceNotFound: -32001,\n\t\tresourceUnavailable: -32002,\n\t\ttransactionRejected: -32003,\n\t\tmethodNotSupported: -32004,\n\t\tlimitExceeded: -32005,\n\t\tparse: -32700,\n\t\tinvalidRequest: -32600,\n\t\tmethodNotFound: -32601,\n\t\tinvalidParams: -32602,\n\t\tinternal: -32603\n\t},\n\tprovider: {\n\t\tuserRejectedRequest: 4001,\n\t\tunauthorized: 4100,\n\t\tunsupportedMethod: 4200,\n\t\tdisconnected: 4900,\n\t\tchainDisconnected: 4901\n\t}\n};\n\n// export const errorValues = {\n//   '-32700': {\n//     standard: 'JSON RPC 2.0',\n//     message:\n//       'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',\n//   },\n//   '-32600': {\n//     standard: 'JSON RPC 2.0',\n//     message: 'The JSON sent is not a valid Request object.',\n//   },\n//   '-32601': {\n//     standard: 'JSON RPC 2.0',\n//     message: 'The method does not exist / is not available.',\n//   },\n//   '-32602': {\n//     standard: 'JSON RPC 2.0',\n//     message: 'Invalid method parameter(s).',\n//   },\n//   '-32603': {\n//     standard: 'JSON RPC 2.0',\n//     message: 'Internal JSON-RPC error.',\n//   },\n//   '-32000': {\n//     standard: 'EIP-1474',\n//     message: 'Invalid input.',\n//   },\n//   '-32001': {\n//     standard: 'EIP-1474',\n//     message: 'Resource not found.',\n//   },\n//   '-32002': {\n//     standard: 'EIP-1474',\n//     message: 'Resource unavailable.',\n//   },\n//   '-32003': {\n//     standard: 'EIP-1474',\n//     message: 'Transaction rejected.',\n//   },\n//   '-32004': {\n//     standard: 'EIP-1474',\n//     message: 'Method not supported.',\n//   },\n//   '-32005': {\n//     standard: 'EIP-1474',\n//     message: 'Request limit exceeded.',\n//   },\n//   '4001': {\n//     standard: 'EIP-1193',\n//     message: 'User rejected the request.',\n//   },\n//   '4100': {\n//     standard: 'EIP-1193',\n//     message:\n//       'The requested account and/or method has not been authorized by the user.',\n//   },\n//   '4200': {\n//     standard: 'EIP-1193',\n//     message: 'The requested method is not supported by this Ethereum provider.',\n//   },\n//   '4900': {\n//     standard: 'EIP-1193',\n//     message: 'The provider is disconnected from all chains.',\n//   },\n//   '4901': {\n//     standard: 'EIP-1193',\n//     message: 'The provider is disconnected from the specified chain.',\n//   },\n// };\n\n// Class\nexport class ProviderRpcError extends Error {\n\tconstructor(code: number, message: string, data?: unknown) {\n\t\tsuper(message);\n\t\tthis.name = 'ProviderRpcError';\n\t\tthis.code = code;\n\t\tthis.data = data;\n\t}\n\n\tcode: number;\n\tdata?: unknown;\n}\n","// BigNumber.ts\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n// Define the Numeric type\nexport type Numeric = number | bigint;\n\n// Define the BigNumberish type\nexport type BigNumberish =\n\t| string\n\t| Numeric\n\t| BigNumber\n\t| { _hex: string; _isBigNumber: boolean }\n\t| null;\n\nexport enum CurrencyCode {\n\tUSD = 'USD',\n\tEUR = 'EUR',\n\tGBP = 'GBP'\n\t// Add more as needed\n}\n\nexport interface IBigNumber {\n\tvalue: BigNumberish;\n\ttoNumber(): number | null;\n\ttoBigInt(): bigint | null;\n\tfromValue(value: BigNumberish): void;\n\tmax(other: BigNumberish): BigNumber;\n\tmin(other: BigNumberish): BigNumber;\n\tadd(other: BigNumberish): BigNumber;\n\tsubtract(other: BigNumberish): BigNumber;\n\tsub(other: BigNumberish): BigNumber;\n\tdiv(other: BigNumberish): BigNumber;\n\tmul(other: BigNumberish): BigNumber;\n\tmod(other: BigNumberish): BigNumber;\n\ttoString(): string;\n\ttoHex(): string;\n}\n\n// Implement the BigNumber class with basic static and instance methods\nexport class BigNumber implements IBigNumber {\n\tprotected _value: BigNumberish;\n\n\tconstructor(value: BigNumberish = null) {\n\t\tthis._value = value;\n\t}\n\n\t// Getter for value\n\tget value(): BigNumberish {\n\t\treturn this._value;\n\t}\n\n\t// Setter for value\n\tset value(newValue: BigNumberish) {\n\t\tthis._value = newValue;\n\t}\n\n\tcompare(other: BigNumberish): number {\n\t\tconst a = this.toBigInt();\n\t\tconst b = BigNumber.from(other).toBigInt();\n\t\tif (a === null || b === null) {\n\t\t\tthrow new Error('Cannot compare null values');\n\t\t}\n\t\tif (a < b) return -1;\n\t\tif (a > b) return 1;\n\t\treturn 0;\n\t}\n\n\t// Type guard to check if value is BigNumber\n\tstatic isBigNumber(value: any): value is BigNumber {\n\t\treturn value instanceof BigNumber;\n\t}\n\n\t// Type guard to check if value is an object with hex property\n\tstatic isHexObject(value: any): value is { hex: string; type: string } {\n\t\treturn typeof value === 'object' && value !== null && 'hex' in value && 'type' in value;\n\t}\n\n\t// Method to convert the value to a number\n\ttoNumber(): number | null {\n\t\tif (this._value === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (typeof this._value === 'string' || typeof this._value === 'number') {\n\t\t\treturn Number(this._value);\n\t\t}\n\n\t\tif (typeof this._value === 'bigint') {\n\t\t\treturn Number(this._value);\n\t\t}\n\n\t\tif (BigNumber.isBigNumber(this._value)) {\n\t\t\treturn this._value.toNumber();\n\t\t}\n\n\t\tif (BigNumber.isHexObject(this._value)) {\n\t\t\treturn Number(BigInt(this._value.hex));\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t// Method to convert the value to a bigint\n\ttoBigInt(): bigint | null {\n\t\tif (this._value === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (typeof this._value === 'string') {\n\t\t\treturn BigInt(this._value);\n\t\t}\n\n\t\tif (typeof this._value === 'number') {\n\t\t\treturn BigInt(this._value);\n\t\t}\n\n\t\tif (typeof this._value === 'bigint') {\n\t\t\treturn this._value;\n\t\t}\n\n\t\tif (BigNumber.isBigNumber(this._value)) {\n\t\t\treturn this._value.toBigInt();\n\t\t}\n\n\t\tif (BigNumber.isHexObject(this._value)) {\n\t\t\treturn BigInt(this._value.hex);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t// Method to set the value\n\tfromValue(value: BigNumberish): void {\n\t\tthis._value = value;\n\t}\n\n\t// Instance method to get the maximum of the current value and another BigNumberish value\n\tmax(other: BigNumberish): BigNumber {\n\t\treturn BigNumber.max(this._value, other);\n\t}\n\n\t// Instance method to get the minimum of the current value and another BigNumberish value\n\tmin(other: BigNumberish): BigNumber {\n\t\treturn BigNumber.min(this._value, other);\n\t}\n\n\t// Instance method to add another BigNumberish value to the current value\n\tadd(other: BigNumberish): BigNumber {\n\t\treturn BigNumber.add(this._value, other);\n\t}\n\n\t// Instance method to subtract another BigNumberish value from the current value\n\tsubtract(other: BigNumberish): BigNumber {\n\t\treturn BigNumber.subtract(this._value, other);\n\t}\n\n\t// Instance method to subtract another BigNumberish value from the current value - to be more compatible with other classes\n\tsub(other: BigNumberish): BigNumber {\n\t\treturn this.subtract(other);\n\t}\n\n\t// Instance method to divide the current value by another BigNumberish value\n\tdiv(other: BigNumberish): BigNumber {\n\t\treturn BigNumber.div(this._value, other);\n\t}\n\n\t// Instance method to multiply the current value by another BigNumberish value\n\tmul(other: BigNumberish): BigNumber {\n\t\treturn BigNumber.mul(this._value, other);\n\t}\n\n\t// Instance method to calculate the modulus of the current value by another BigNumberish value\n\tmod(other: BigNumberish): BigNumber {\n\t\treturn BigNumber.mod(this._value, other);\n\t}\n\n\t// Instance method to convert the value to a string\n\ttoString(): string {\n\t\tconst bigintValue = this.toBigInt();\n\t\tif (bigintValue === null) {\n\t\t\treturn '';\n\t\t}\n\t\treturn bigintValue.toString();\n\t}\n\n\t// Instance method to convert the value to a hex string\n\ttoHex(isEthereum: boolean = true): string {\n\t\t// Handle null values\n\t\tif (this._value === null) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Handle string values\n\t\tif (typeof this._value === 'string') {\n\t\t\treturn this._value;\n\t\t}\n\n\t\t// Handle number and bigint values\n\t\tconst bigintValue = this.toBigInt();\n\t\tif (bigintValue === null) {\n\t\t\treturn '';\n\t\t}\n\n\t\tlet hexString = bigintValue.toString(16);\n\n\t\t// Ensure even length for the hex string if Ethereum-compatible\n\t\tif (isEthereum && hexString.length % 2 !== 0) {\n\t\t\thexString = '0' + hexString;\n\t\t}\n\n\t\treturn '0x' + hexString;\n\t}\n\n\t// Static method to create a BigNumber instance\n\tstatic from(value: BigNumberish): BigNumber {\n\t\tif (BigNumber.isHexObject(value)) {\n\t\t\treturn new BigNumber(BigInt(value.hex));\n\t\t}\n\t\treturn new BigNumber(value);\n\t}\n\n\t// Static method to convert a BigNumberish to a number\n\tstatic toNumber(value: BigNumberish): number | null {\n\t\tif (value === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (typeof value === 'string' || typeof value === 'number') {\n\t\t\treturn Number(value);\n\t\t}\n\n\t\tif (typeof value === 'bigint') {\n\t\t\treturn Number(value);\n\t\t}\n\n\t\tif (BigNumber.isBigNumber(value)) {\n\t\t\treturn value.toNumber();\n\t\t}\n\n\t\tif (BigNumber.isHexObject(value)) {\n\t\t\treturn Number(BigInt(value.hex));\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t// Static method to convert a BigNumberish to a bigint\n\tstatic toBigInt(value: BigNumberish, decimals: number = 18): bigint | null {\n\t\tif (value === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (typeof value === 'number') {\n\t\t\tif (!Number.isInteger(value)) {\n\t\t\t\tconst factor = Math.pow(10, decimals);\n\t\t\t\treturn BigInt(Math.round(value * factor));\n\t\t\t} else {\n\t\t\t\treturn BigInt(value);\n\t\t\t}\n\t\t}\n\n\t\tif (typeof value === 'string') {\n\t\t\t// Handle cases where the string value may contain decimals\n\t\t\tif (value.includes('.')) {\n\t\t\t\tconst [integerPart, fractionalPart = ''] = value.split('.');\n\t\t\t\tconst factor = BigInt('1' + '0'.repeat(decimals));\n\t\t\t\tconst scaledValue =\n\t\t\t\t\tBigInt(integerPart) * factor +\n\t\t\t\t\tBigInt((fractionalPart + '0'.repeat(decimals)).slice(0, decimals));\n\t\t\t\treturn scaledValue;\n\t\t\t} else {\n\t\t\t\treturn BigInt(value);\n\t\t\t}\n\t\t}\n\n\t\tif (typeof value === 'bigint') {\n\t\t\treturn value;\n\t\t}\n\n\t\tif (BigNumber.isBigNumber(value)) {\n\t\t\treturn value.toBigInt();\n\t\t}\n\n\t\tif (BigNumber.isHexObject(value)) {\n\t\t\treturn BigInt(value.hex);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t// Static method to get the maximum of two BigNumberish values\n\tstatic max(value1: BigNumberish, value2: BigNumberish): BigNumber {\n\t\tconst bigint1 = BigNumber.toBigInt(value1);\n\t\tconst bigint2 = BigNumber.toBigInt(value2);\n\n\t\tif (bigint1 === null || bigint2 === null) {\n\t\t\tthrow new Error('Invalid BigNumberish value');\n\t\t}\n\n\t\treturn new BigNumber(bigint1 > bigint2 ? bigint1 : bigint2);\n\t}\n\n\t// Static method to get the minimum of two BigNumberish values\n\tstatic min(value1: BigNumberish, value2: BigNumberish): BigNumber {\n\t\tconst bigint1 = BigNumber.toBigInt(value1);\n\t\tconst bigint2 = BigNumber.toBigInt(value2);\n\n\t\tif (bigint1 === null || bigint2 === null) {\n\t\t\tthrow new Error('Invalid BigNumberish value');\n\t\t}\n\n\t\treturn new BigNumber(bigint1 < bigint2 ? bigint1 : bigint2);\n\t}\n\n\t// Static method to add two BigNumberish values\n\tstatic add(value1: BigNumberish, value2: BigNumberish): BigNumber {\n\t\tconst bigint1 = BigNumber.toBigInt(value1);\n\t\tconst bigint2 = BigNumber.toBigInt(value2);\n\n\t\tif (bigint1 === null || bigint2 === null) {\n\t\t\tthrow new Error('Invalid BigNumberish value');\n\t\t}\n\n\t\treturn new BigNumber(bigint1 + bigint2);\n\t}\n\n\t// Static method to subtract one BigNumberish value from another\n\tstatic subtract(value1: BigNumberish, value2: BigNumberish): BigNumber {\n\t\tconst bigint1 = BigNumber.toBigInt(value1);\n\t\tconst bigint2 = BigNumber.toBigInt(value2);\n\n\t\tif (bigint1 === null || bigint2 === null) {\n\t\t\tthrow new Error('Invalid BigNumberish value');\n\t\t}\n\n\t\treturn new BigNumber(bigint1 - bigint2);\n\t}\n\n\tstatic sub(value1: BigNumberish, value2: BigNumberish): BigNumber {\n\t\treturn BigNumber.subtract(value1, value2);\n\t}\n\n\t// Static method to divide one BigNumberish value by another\n\tstatic div(value1: BigNumberish, value2: BigNumberish): BigNumber {\n\t\tconst bigint1 = BigNumber.toBigInt(value1);\n\t\tconst bigint2 = BigNumber.toBigInt(value2);\n\n\t\tif (bigint1 === null || bigint2 === null || bigint2 === BigInt(0)) {\n\t\t\tthrow new Error('Invalid BigNumberish value or division by zero');\n\t\t}\n\n\t\treturn new BigNumber(bigint1 / bigint2);\n\t}\n\n\t// Static method to multiply two BigNumberish values\n\tstatic mul(value1: BigNumberish, value2: BigNumberish): BigNumber {\n\t\tconst bigint1 = BigNumber.toBigInt(value1);\n\t\tconst bigint2 = BigNumber.toBigInt(value2);\n\n\t\tif (bigint1 === null || bigint2 === null) {\n\t\t\tthrow new Error('Invalid BigNumberish value');\n\t\t}\n\n\t\treturn new BigNumber(bigint1 * bigint2);\n\t}\n\n\t// Static method to calculate the modulus of one BigNumberish value by another\n\tstatic mod(value1: BigNumberish, value2: BigNumberish): BigNumber {\n\t\tconst bigint1 = BigNumber.toBigInt(value1);\n\t\tconst bigint2 = BigNumber.toBigInt(value2);\n\n\t\tif (bigint1 === null || bigint2 === null || bigint2 === BigInt(0)) {\n\t\t\tthrow new Error('Invalid BigNumberish value or modulus by zero');\n\t\t}\n\n\t\treturn new BigNumber(bigint1 % bigint2);\n\t}\n\n\t// Static method to convert BigNumberish value to hex string\n\tstatic toHex(value: BigNumberish): string {\n\t\tconst bigintValue = BigNumber.toBigInt(value);\n\t\tif (bigintValue === null) {\n\t\t\tthrow new Error('Invalid BigNumberish value');\n\t\t}\n\t\treturn '0x' + bigintValue.toString(16);\n\t}\n\n\t// Static method to create a BigNumber from a hex string\n\tstatic fromHex(hex: string): BigNumber {\n\t\tif (typeof hex !== 'string' || !/^0x[0-9a-fA-F]+$/.test(hex)) {\n\t\t\tthrow new Error('Invalid hex string');\n\t\t}\n\t\treturn new BigNumber(BigInt(hex));\n\t}\n\n\t// Instance method to convert the current value to fiat\n\ttoFiat(price: number): number {\n\t\tconst numberValue = this.toNumber();\n\t\tif (numberValue === null) {\n\t\t\tthrow new Error('Invalid BigNumberish value');\n\t\t}\n\t\treturn numberValue * price;\n\t}\n\n\t// Instance method to convert the current value to formatted fiat\n\ttoFormattedFiat(price: number, currencyCode: CurrencyCode, locale: string = ''): string {\n\t\tconst fiatValue = this.toFiat(price);\n\t\tconst formatter = new Intl.NumberFormat(locale || undefined, {\n\t\t\tstyle: 'currency',\n\t\t\tcurrency: currencyCode\n\t\t});\n\t\treturn formatter.format(fiatValue);\n\t}\n}\n\n// Examples of use...\n// let ethValue: EthereumBigNumber = new EthereumBigNumber(1);\n// console.log('To Wei:', ethValue.toWei().toBigInt()); // Output: 1000000000000000000n\n// console.log('To Gwei:', ethValue.toGwei().toBigInt()); // Output: 1000000000n\n// console.log('To Ether:', ethValue.toWei().toEther().toBigInt()); // Output: 1n\n\n// let btcValue: BitcoinBigNumber = new BitcoinBigNumber(1);\n// console.log('To Satoshi:', btcValue.toSatoshi().toBigInt()); // Output: 100000000n\n// console.log('To Bitcoin:', btcValue.toSatoshi().toBitcoin().toBigInt()); // Output: 1n\n\n// let solValue: SolanaBigNumber = new SolanaBigNumber(1);\n// console.log('To Lamport:', solValue.toLamport().toBigInt()); // Output: 1000000000n\n// console.log('To SOL:', solValue.toLamport().toSOL().toBigInt()); // Output: 1n\n\n// let optimismValue: OptimismBigNumber = new OptimismBigNumber(1);\n// console.log('To Gwei Optimism:', optimismValue.toGweiOptimism().toBigInt()); // Output: 1000000000n\n// console.log('To Wei Optimism:', optimismValue.toWeiOptimism().toBigInt()); // Output: 1000000000000000000n\n\n// let polygonValue: PolygonBigNumber = new PolygonBigNumber(1);\n// console.log('To Gwei Polygon:', polygonValue.toGweiPolygon().toBigInt()); // Output: 1000000000n\n// console.log('To Wei Polygon:', polygonValue.toWeiPolygon().toBigInt()); // Output: 1000000000000000000n\n\n// let avalancheValue: AvalancheBigNumber = new AvalancheBigNumber(1);\n// console.log('To Gwei Avalanche:', avalancheValue.toGweiAvalanche().toBigInt()); // Output: 1000000000n\n// console.log('To Wei Avalanche:', avalancheValue.toWeiAvalanche().toBigInt()); // Output: 1000000000000000000n\n\n// let baseValue: BaseBigNumber = new BaseBigNumber(1);\n// console.log('To Gwei Base:', baseValue.toGweiBase().toBigInt()); // Output: 1000000000n\n// console.log('To Wei Base:', baseValue.toWeiBase().toBigInt()); // Output: 1000000000000000000n\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n\tPLATFORM_TYPES,\n\tmakeError,\n\ttype BytesLike,\n\ttype CurrentlySelectedData,\n\ttype Deferrable,\n\ttype EncryptedData,\n\ttype MetaData,\n\ttype PrimaryAccountData,\n\ttype ProfileData,\n\ttype Result,\n\ttype YakklAccount,\n\ttype YakklPrimaryAccount\n} from '.';\nimport { BigNumber, type BigNumberish } from '$lib/common/bignumber';\nimport { log } from '$lib/managers/Logger';\n\n// export function toBigInt( value: BigNumberish, decimals: number = 18 ): bigint {\n//   return BigNumber.toBigInt( value, decimals ) ?? 0n;\n// }\n\nexport async function getPrimaryAccountByAddress(\n\taddress: string\n): Promise<YakklPrimaryAccount | null> {\n\tif (!address) return null;\n\t// First, try to find the account in the reactive store\n\tconst accounts: YakklPrimaryAccount[] = []; //await getYakklPrimaryAccounts();\n\n\tif (!accounts) return null;\n\t// Find the account with the matching address\n\tconst primaryAccount = accounts.find(\n\t\t(account: YakklPrimaryAccount) => account.address === address\n\t);\n\n\treturn primaryAccount || null; // Return null if no account is found\n}\n\nexport function encodeJSON<T>(obj: T): string {\n\tconst jsonString = JSON.stringify(obj, (_, value) => {\n\t\tif (typeof value === 'bigint') {\n\t\t\treturn value.toString() + 'n';\n\t\t}\n\t\tif (typeof value === 'object' && value !== null && Object.keys(value).length === 0) {\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\treturn '{}';\n\t\t}\n\t\treturn value;\n\t});\n\treturn jsonString;\n}\n\nexport function decodeJSON<T>(jsonString: string): T {\n\treturn JSON.parse(jsonString, (_key, value) => {\n\t\tif (typeof value === 'string' && /^\\d+n$/.test(value)) {\n\t\t\treturn BigInt(value.slice(0, -1));\n\t\t}\n\t\treturn value;\n\t});\n}\n\nexport function parseWithBigInt(jsonString: string): any {\n\treturn JSON.parse(jsonString, (_, value) =>\n\t\ttypeof value === 'string' && /^\\d+n$/.test(value) ? BigInt(value.slice(0, -1)) : value\n\t);\n}\n\n// This will test to see if encodeJSON or cloneDeep should be called in deepCopy\nexport function isJSONSerializable(value: any): boolean {\n\treturn (\n\t\tvalue === null ||\n\t\ttypeof value === 'boolean' ||\n\t\ttypeof value === 'number' ||\n\t\ttypeof value === 'string' ||\n\t\tArray.isArray(value) ||\n\t\t(typeof value === 'object' &&\n\t\t\tObject.prototype.toString.call(value) === '[object Object]' &&\n\t\t\t(Object.getPrototypeOf(value) === null || Object.getPrototypeOf(value) === Object.prototype))\n\t);\n}\n\nexport function isNull(obj: any): boolean {\n\treturn obj === null;\n}\n\nexport function isUndefined(obj: any): boolean {\n\treturn obj === undefined;\n}\n\nexport function isEmptyObject(obj: any): boolean {\n\treturn (\n\t\tobj && typeof obj === 'object' && Object.keys(obj).length === 0 && obj.constructor === Object\n\t);\n}\n\nexport function isEmptyNullOrUndefined(obj: any): boolean {\n\treturn (\n\t\tobj === null ||\n\t\tobj === undefined ||\n\t\t(typeof obj === 'object' && Object.keys(obj).length === 0 && obj.constructor === Object)\n\t);\n}\n\nexport function isValidJSON(value: string): boolean {\n\ttry {\n\t\tJSON.parse(value);\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport function isEncryptedData(data: any): data is EncryptedData {\n\treturn (\n\t\t!isEmptyNullOrUndefined(data) &&\n\t\ttypeof data.iv === 'string' &&\n\t\ttypeof data.data === 'string' &&\n\t\ttypeof data.salt === 'string'\n\t);\n}\n\nexport function isProfileData(\n\tdata: EncryptedData | ProfileData | Promise<ProfileData>\n): data is ProfileData {\n\treturn (data as ProfileData).pincode !== undefined; // May want to also add '(data as ProfileData).meta !== undefined'\n}\n\nexport function isMetaData(meta: unknown): meta is MetaData {\n\treturn meta !== null && typeof meta === 'object';\n}\n\nexport function isString(value: unknown): value is string {\n\treturn typeof value === 'string';\n}\n\nexport function isCurrentlySelectedData(\n\tdata: EncryptedData | CurrentlySelectedData\n): data is CurrentlySelectedData {\n\treturn (data as CurrentlySelectedData).profile !== undefined;\n}\n\nexport function isPrimaryAccountData(\n\tdata: EncryptedData | PrimaryAccountData\n): data is PrimaryAccountData {\n\treturn (data as PrimaryAccountData).privateKey !== undefined;\n}\n\n// Type guards\nexport function isYakklPrimaryAccount(account: any): account is YakklPrimaryAccount {\n\treturn account && account.subAccounts !== undefined;\n}\n\nexport function isYakklAccount(account: any): account is YakklAccount {\n\treturn account && account.accountType !== undefined;\n}\n\nexport function isJsonObject(value: any): value is Record<string, any> {\n\treturn value !== null && typeof value === 'object' && !Array.isArray(value);\n}\n\nexport async function isPromiseJson(promise: Promise<Record<string, any>>): Promise<boolean> {\n\ttry {\n\t\tconst resolvedValue = await promise;\n\t\treturn isJsonObject(resolvedValue);\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n// Type guard to check if a value is an instance of BigNumber\nexport function isBigNumber(value: any): value is BigNumber {\n\treturn value instanceof BigNumber;\n}\n\n// Utility function to check if a value is BigNumberish\nexport function isBigNumberish(value: any): value is BigNumberish {\n\treturn (\n\t\ttypeof value === 'number' ||\n\t\t(typeof value === 'string' && /^-?\\d+$/.test(value)) || // Only match numeric strings\n\t\ttypeof value === 'bigint' ||\n\t\tisBigNumber(value)\n\t);\n}\n\n// Utility function to convert BigNumberish values to hex string\nexport function toHex(value: BigNumberish): string {\n\tif (isBigNumber(value)) {\n\t\treturn value.toHex();\n\t}\n\tconst hex = BigNumber.from(value).toHex();\n\treturn hex.length % 2 === 0 ? hex : '0x0' + hex.slice(2);\n}\n\n// Function to recursively traverse and convert numeric values to hex strings\nexport function convertToHexStrings<T>(obj: T, skipProperties: string[] = []): T {\n\tconst skipSet = new Set(skipProperties);\n\n\t// Helper function to check if a path should be skipped\n\tfunction shouldSkip(path: string[]): boolean {\n\t\tconst pathString = path.join('.');\n\t\treturn Array.from(skipSet).some((skipPath) => pathString.startsWith(skipPath));\n\t}\n\n\t// Helper function to handle the conversion\n\tfunction convert(value: any, path: string[] = []): any {\n\t\tif (shouldSkip(path)) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif (Array.isArray(value)) {\n\t\t\treturn value.map((v, i) => convert(v, [...path, i.toString()]));\n\t\t} else if (value && typeof value === 'object' && !isBigNumber(value)) {\n\t\t\tconst result: any = {};\n\t\t\tfor (const key in value) {\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(value, key)) {\n\t\t\t\t\tresult[key] = convert(value[key], [...path, key]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t} else if (isBigNumberish(value)) {\n\t\t\treturn toHex(value);\n\t\t}\n\t\treturn value;\n\t}\n\n\treturn convert(obj);\n}\n\nexport function parseJsonOrObject<T>(value: any): T | null {\n\tif (value === null || value === undefined) {\n\t\treturn null;\n\t}\n\n\t// Check if the value is already an object\n\tif (typeof value === 'object') {\n\t\treturn value;\n\t}\n\n\t// Check if the value is a JSON string\n\tif (typeof value === 'string') {\n\t\ttry {\n\t\t\tconst parsed = JSON.parse(value);\n\t\t\t// Ensure the parsed value is an object or an array\n\t\t\tif (typeof parsed === 'object' && parsed !== null) {\n\t\t\t\treturn parsed;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tlog.error('Error parsing JSON string:', false, e);\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn null;\n}\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n\tconst promises: Array<Promise<Result>> = Object.keys(object).map(async (key) => {\n\t\tconst value = object[<keyof Deferrable<T>>key];\n\t\tconst v = await Promise.resolve(value);\n\t\treturn { key: key, value: v };\n\t});\n\n\tconst results = await Promise.all(promises);\n\n\t// log.debug('resolveProperties results', results);\n\n\treturn results.reduce(\n\t\t(accum, result) => {\n\t\t\taccum[<keyof T>result.key] = result.value;\n\t\t\treturn accum;\n\t\t},\n\t\t<T>{}\n\t);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function checkProperties(object: any, properties: { [name: string]: boolean }): void {\n\tif (!object || typeof object !== 'object') {\n\t\tthrow new Error('invalid object', object);\n\t}\n\n\tObject.keys(object).forEach((key) => {\n\t\tif (!properties[key]) {\n\t\t\tthrow new Error('invalid object key - ' + key, object);\n\t\t}\n\t});\n}\n\n// Gets or sets a default value safely.\nexport function getOrDefault<T>(value: T | undefined, defaultValue: T): T {\n\treturn value === undefined ? defaultValue : value;\n}\n\n/**\n * Prefixes a hex string with '0x' or '-0x' and returns it. Idempotent.\n *\n * @param {string} str - The string to prefix.\n * @returns {string} The prefixed string.\n */\nexport const addHexPrefix = (str: string): string => {\n\tif (typeof str !== 'string' || str.match(/^-?0x/u)) {\n\t\treturn str;\n\t}\n\n\tif (str.match(/^-?0X/u)) {\n\t\treturn str.replace('0X', '0x');\n\t}\n\n\tif (str.startsWith('-')) {\n\t\treturn str.replace('-', '-0x');\n\t}\n\n\treturn `0x${str}`;\n};\n\n/**\n * Removes '0x' from a given `String` if present\n * @param str the string value\n * @returns the string without 0x prefix\n */\nexport const stripHexPrefix = (str: string): string => {\n\tif (typeof str !== 'string')\n\t\tthrow new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);\n\n\treturn isHexPrefixed(str) ? str.slice(2) : str;\n};\n\n/**\n * Returns a `Boolean` on whether or not the a `String` starts with '0x'\n * @param str the string input value\n * @return a boolean if it is or is not hex prefixed\n * @throws if the str input is not a string\n */\nexport function isHexPrefixed(str: string): boolean {\n\tif (typeof str !== 'string') {\n\t\tthrow new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);\n\t}\n\n\treturn str[0] === '0' && str[1] === 'x';\n}\n\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isHexString(value: any, length?: number | boolean): value is `0x${string}` {\n\tif (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n\t\treturn false;\n\t}\n\n\tif (typeof length === 'number' && value.length !== 2 + 2 * length) {\n\t\treturn false;\n\t}\n\tif (length === true && value.length % 2 !== 0) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nfunction _getBytes(value: BytesLike, name?: string, copy?: boolean): Uint8Array {\n\ttry {\n\t\tif (value instanceof Uint8Array) {\n\t\t\tif (copy) {\n\t\t\t\treturn new Uint8Array(value);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tif (typeof value === 'string' && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {\n\t\t\tconst result = new Uint8Array((value.length - 2) / 2);\n\t\t\tlet offset = 2;\n\t\t\tfor (let i = 0; i < result.length; i++) {\n\t\t\t\tresult[i] = parseInt(value.substring(offset, offset + 2), 16);\n\t\t\t\toffset += 2;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tthrow new Error('invalid BytesLike value');\n\t} catch (error: unknown) {\n\t\tif (error instanceof Error) {\n\t\t\tthrow makeError(error.message, 'INVALID_ARGUMENT', {\n\t\t\t\targument: name || 'value',\n\t\t\t\tvalue: value\n\t\t\t});\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */\nexport function getBytes(value: BytesLike, name?: string): Uint8Array {\n\treturn _getBytes(value, name, false);\n}\n\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */\nexport function getBytesCopy(value: BytesLike, name?: string): Uint8Array {\n\treturn _getBytes(value, name, true);\n}\n\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isBytesLike(value: any): value is BytesLike {\n\treturn isHexString(value, true) || value instanceof Uint8Array;\n}\n\nconst HexCharacters: string = '0123456789abcdef';\n\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */\nexport function hexlify(data: BytesLike): string {\n\tconst bytes = getBytes(data);\n\n\tlet result = '0x';\n\tfor (let i = 0; i < bytes.length; i++) {\n\t\tconst v = bytes[i];\n\t\tresult += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n\t}\n\treturn result;\n}\n\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */\nexport function concat(datas: ReadonlyArray<BytesLike>): string {\n\treturn '0x' + datas.map((d) => hexlify(d).substring(2)).join('');\n}\n\n/**\n *  Returns the length of %%data%%, in bytes.\n */\nexport function dataLength(data: BytesLike): number {\n\tif (isHexString(data, true)) {\n\t\treturn (data.length - 2) / 2;\n\t}\n\treturn getBytes(data).length;\n}\n\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */\nexport function dataSlice(data: BytesLike, start?: number, end?: number): string {\n\tconst bytes = getBytes(data);\n\tif (end != null && end > bytes.length) {\n\t\t// assert(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n\t\t//     buffer: bytes, length: bytes.length, offset: end\n\t\t// });\n\t}\n\treturn hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));\n}\n\n/**\n * @see {@link getEnvironmentType}\n */\n// export const getEnvironmentTypeMemo = memoize((url: string): string => {\n//   const parsedUrl = new URL(url);\n//   if (parsedUrl.pathname === '/popup.html') {\n//     return ENVIRONMENT_TYPES.POPUP;\n//   } else if (['/index.html'].includes(parsedUrl.pathname)) {\n//     return ENVIRONMENT_TYPES.BROWSER;\n//   } else if (parsedUrl.pathname === '/notification.html') {\n//     return ENVIRONMENT_TYPES.NOTIFICATION;\n//   }\n//   return ENVIRONMENT_TYPES.BACKGROUND;\n// });\n\n/**\n * Returns the window type for the application\n *\n *  - `popup` refers to the extension opened through the browser app icon (in top right corner in chrome and firefox)\n *  - `fullscreen` refers to the main browser window\n *  - `notification` refers to the popup that appears in its own window when taking action outside of metamask\n *  - `background` refers to the background page\n *\n * NOTE: This should only be called on internal URLs.\n *\n * @param {string} [url] - the URL of the window\n * @returns {string} the environment ENUM\n */\n// export const getEnvironmentType = (url: string = window.location.href): string =>\n//   getEnvironmentTypeMemo(url);\n\n/**\n * Returns the platform (browser) where the extension is running.\n *\n * @returns {string} the platform ENUM\n */\nexport const getPlatform = (): string => {\n\tconst { navigator } = window;\n\tconst { userAgent } = navigator;\n\n\t// We do not currently support Safari\n\tif (userAgent.includes('Firefox')) {\n\t\treturn PLATFORM_TYPES.FIREFOX;\n\t} else if ('brave' in navigator) {\n\t\treturn PLATFORM_TYPES.BRAVE;\n\t} else if (userAgent.includes('Edg/')) {\n\t\treturn PLATFORM_TYPES.EDGE;\n\t} else if (userAgent.includes('OPR')) {\n\t\treturn PLATFORM_TYPES.OPERA;\n\t}\n\treturn PLATFORM_TYPES.CHROME;\n};\n\nexport function extractFQDN(url: string): string {\n\ttry {\n\t\tif (!url) return '';\n\t\tconst parsedUrl = new URL(url);\n\t\treturn parsedUrl.hostname;\n\t} catch (e) {\n\t\tlog.error(e);\n\t\treturn '';\n\t}\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// Some math functions are from the following source:\n// ethers.js - under MIT license\n\nimport { makeError } from '$lib/common/errors';\nimport { addHexPrefix, hexlify, isBytesLike, stripHexPrefix } from '$lib/common/misc';\nimport type { BytesLike } from '$lib/common/types';\nimport { BigNumber, type BigNumberish, type Numeric } from '$lib/common/bignumber';\nimport { log } from '$lib/managers/Logger';\n\n// TODO: Some of the things in this file are not used in the project. Remove them if they are not needed or out of date.\n\nconst Nibbles = '0123456789abcdef';\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst maxValue = BigInt(2) ** BigInt(256) - BigInt(1);\n\nexport function convertBasisPointsToDecimal(basisPoints: number): number {\n\ttry {\n\t\tif (basisPoints < 1) {\n\t\t\t// All calculations are done in basis points so we need to check if the value is less than 1 (1 - return of this)\n\t\t\treturn basisPoints;\n\t\t}\n\t\treturn basisPoints / 10000;\n\t} catch (error) {\n\t\tlog.error(`convertBasisPointsToDecimal: ${error}`);\n\t\treturn 0;\n\t}\n}\n\n/**\n * Converts a hex string to a BigInt\n *\n * @param {string} inputHex - A number represented as a hex string\n * @returns {bigint} A BigInt\n */\nfunction hexToBigNumberish(inputHex: string): bigint {\n\treturn BigInt(stripHexPrefix(inputHex));\n}\n\n/**\n * Used to multiply a BigInt by a fraction\n *\n * @param {BigNumberish} targetBN - The number to multiply by a fraction\n * @param {BigNumberish} numerator - The numerator of the fraction multiplier\n * @param {BigNumberish} denominator - The denominator of the fraction multiplier\n * @returns {bigint} The product of the multiplication\n */\nfunction bigNumberishMultiplyByFraction(\n\ttargetBN: BigNumberish,\n\tnumerator: BigNumberish,\n\tdenominator: BigNumberish\n): bigint {\n\ttry {\n\t\tconst tarBN = getBigInt(targetBN);\n\t\tconst numBN = getBigInt(numerator);\n\t\tconst denomBN = getBigInt(denominator);\n\t\treturn (tarBN * numBN) / denomBN;\n\t} catch (error: unknown) {\n\t\tif (error instanceof Error) {\n\t\t\tthrow makeError(error.message, 'NUMERIC_FAULT', {\n\t\t\t\tfault: 'overflow',\n\t\t\t\toperation: 'bigNumberishMultiplyByFraction',\n\t\t\t\tvalue: targetBN\n\t\t\t});\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\n/**\n * Converts a BigInt to a hex string with a '0x' prefix\n *\n * @param {BigNumberish} inputBn - The BigNumberish to convert to a hex string\n * @returns {string} A '0x' prefixed hex string\n */\nfunction bigNumberishToHex(inputBn: BigNumberish): string {\n\tif (inputBn === null) {\n\t\tthrow new Error('value cannot be null');\n\t}\n\treturn addHexPrefix(inputBn.toString(16));\n}\n\n/**\n * Converts a value to a BigInt\n *\n * @param {BigNumberish} value - The value to convert\n * @param {string} [name] - Optional name of the value for error messages\n * @returns {bigint} The converted BigInt\n * @throws {Error} Throws an error if the value is invalid\n */\nexport function getBigInt(value: BigNumberish, name?: string): bigint {\n\ttry {\n\t\tif (value === null) {\n\t\t\tthrow new Error('value cannot be null');\n\t\t}\n\n\t\tswitch (typeof value) {\n\t\t\tcase 'bigint':\n\t\t\t\treturn value;\n\t\t\tcase 'number':\n\t\t\t\tif (!Number.isInteger(value)) {\n\t\t\t\t\tthrow new Error('underflow');\n\t\t\t\t}\n\t\t\t\tif (value < -maxValue || value > maxValue) {\n\t\t\t\t\tthrow new Error('overflow');\n\t\t\t\t}\n\t\t\t\treturn BigInt(value);\n\t\t\tcase 'string':\n\t\t\t\tif (value === '') {\n\t\t\t\t\tthrow new Error('empty string');\n\t\t\t\t}\n\t\t\t\tif (value[0] === '-' && value[1] !== '-') {\n\t\t\t\t\treturn -BigInt(value.substring(1));\n\t\t\t\t}\n\t\t\t\tif (value === '0' || value === '0.0' || value === '0.00') {\n\t\t\t\t\treturn 0n;\n\t\t\t\t}\n\t\t\t\treturn BigInt(value);\n\t\t\tdefault:\n\t\t\t\tthrow new Error('invalid BigNumberish value');\n\t\t}\n\t} catch (error: unknown) {\n\t\tlog.error(`getBigInt: ${error}`);\n\t\tif (error instanceof Error) {\n\t\t\tthrow makeError(error.message, 'INVALID_ARGUMENT', {\n\t\t\t\targument: name || 'value',\n\t\t\t\tvalue: value\n\t\t\t});\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\n/**\n * Converts a value to an unsigned BigInt\n *\n * @param {BigNumberish} value - The value to convert\n * @param {string} [name] - Optional name of the value for error messages\n * @returns {bigint} The converted unsigned BigInt\n * @throws {Error} Throws an error if the value is invalid or negative\n */\nexport function getUint(value: BigNumberish, name?: string): bigint {\n\ttry {\n\t\tconst result = getBigInt(value, name);\n\t\tif (result < BN_0) {\n\t\t\tthrow new Error('unsigned value cannot be negative');\n\t\t}\n\t\treturn result;\n\t} catch (error: unknown) {\n\t\tlog.error(`getUint: ${error}`);\n\t\tif (error instanceof Error) {\n\t\t\tthrow makeError(error.message, 'NUMERIC_FAULT', {\n\t\t\t\tfault: 'overflow',\n\t\t\t\toperation: 'getUint',\n\t\t\t\tvalue: value\n\t\t\t});\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\n/**\n * Converts a BigNumberish or Uint8Array to a BigInt\n *\n * @param {BigNumberish | Uint8Array} value - The value to convert\n * @returns {bigint} The converted BigInt\n */\nexport function toBigInt(value: BigNumberish | Uint8Array, decimals?: number): bigint {\n\tif (value instanceof Uint8Array) {\n\t\tlet result = '0x0';\n\t\tfor (const v of value) {\n\t\t\tresult += Nibbles[v >> 4];\n\t\t\tresult += Nibbles[v & 0x0f];\n\t\t}\n\t\treturn BigInt(result);\n\t}\n\n\tif (typeof value === 'number') {\n\t\tif (decimals !== undefined) return numberToBigInt(value, decimals);\n\t\t// debug_log(\"Decimals must be specified for a number input.\");\n\t}\n\n\tif (typeof value === 'string') {\n\t\tif (decimals !== undefined) return stringToBigInt(value, decimals);\n\t\t//debug_log(\"Decimals must be specified for a string input.\");\n\t}\n\n\treturn getBigInt(value);\n}\n\nexport function stringToBigInt(value: string, decimals: number = 18): bigint {\n\tif (!value || isNaN(Number(value))) {\n\t\t// log.debug(`Invalid input: \"${value}\" is not a valid number string.`);\n\t\treturn 0n;\n\t}\n\n\t// Split into integer and fractional parts\n\tconst [integerPart, fractionalPart = ''] = value.split('.');\n\n\t// Ensure fractional part doesn't exceed the specified decimals\n\tconst paddedFractional = fractionalPart.padEnd(decimals, '0').slice(0, decimals);\n\n\t// Combine integer and fractional parts\n\tconst combined = integerPart + paddedFractional;\n\n\treturn BigInt(combined);\n}\n\nexport function numberToBigInt(value: number, decimals: number = 18): bigint {\n\tif (isNaN(value) || decimals < 0) {\n\t\t// log.debug('Invalid input: amount must be a number, and decimals must be non-negative');\n\t\treturn 0n;\n\t}\n\tconst scale = Math.pow(10, decimals); // Scale factor\n\tconst scaledValue = Math.round(value * scale); // Scale and round\n\treturn BigInt(scaledValue);\n}\n\n// Safe conversion to bigint with comprehensive type handling\nexport function safeConvertToBigInt(value: BigNumberish | null | undefined): bigint | undefined {\n\ttry {\n\t\t// Handle null or undefined\n\t\tif (value === null || value === undefined) return undefined;\n\n\t\t// Check if value is already a bigint\n\t\tif (typeof value === 'bigint') return value;\n\n\t\t// Handle BigNumber type\n\t\tif (value instanceof BigNumber) {\n\t\t\treturn BigInt(value.toString());\n\t\t}\n\n\t\t// Handle object with _hex property (ethers BigNumber-like)\n\t\tif (typeof value === 'object' && value !== null && '_hex' in value) {\n\t\t\treturn BigInt((value as { _hex: string })._hex);\n\t\t}\n\n\t\t// Try to convert using existing toBigInt\n\t\treturn toBigInt(value);\n\t} catch (error: unknown) {\n\t\tlog.error(`safeConvertToBigInt: ${error}`);\n\t\treturn 0n;\n\t}\n}\n\n/**\n * Converts a BigNumberish value to a number\n *\n * @param {BigNumberish} value - The value to convert\n * @param {string} [name] - Optional name of the value for error messages\n * @returns {number} The converted number\n * @throws {Error} Throws an error if the value is invalid\n */\nexport function getNumber(value: BigNumberish, name?: string): number {\n\ttry {\n\t\tswitch (typeof value) {\n\t\t\tcase 'bigint':\n\t\t\t\tif (value < -maxValue || value > maxValue) {\n\t\t\t\t\tthrow new Error('overflow');\n\t\t\t\t}\n\t\t\t\treturn Number(value);\n\t\t\tcase 'number':\n\t\t\t\tif (!Number.isInteger(value)) {\n\t\t\t\t\tthrow new Error('underflow');\n\t\t\t\t}\n\t\t\t\tif (value < -maxValue || value > maxValue) {\n\t\t\t\t\tthrow new Error('overflow');\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\tcase 'string':\n\t\t\t\tif (value === '') {\n\t\t\t\t\tthrow new Error('empty string');\n\t\t\t\t}\n\t\t\t\treturn getNumber(BigInt(value), name);\n\t\t\tdefault:\n\t\t\t\tthrow new Error('invalid numeric value');\n\t\t}\n\t} catch (error: unknown) {\n\t\tlog.error(`getNumber: ${error}`);\n\t\tif (error instanceof Error) {\n\t\t\tthrow makeError(error.message, 'INVALID_ARGUMENT', {\n\t\t\t\targument: name || 'value',\n\t\t\t\tvalue: value\n\t\t\t});\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\n/**\n * Converts a BigNumberish or Uint8Array to a number\n *\n * @param {BigNumberish | Uint8Array} value - The value to convert\n * @returns {number} The converted number\n */\nexport function toNumber(value: BigNumberish | Uint8Array): number {\n\treturn getNumber(toBigInt(value));\n}\n\n/**\n * Converts a BigNumberish value to a Big Endian hex string, optionally padded to a specified width\n *\n * @param {BigNumberish} _value - The value to convert\n * @param {Numeric} [_width] - Optional width to pad the hex string\n * @returns {string} The converted hex string\n * @throws {Error} Throws an error if the value exceeds the specified width\n */\nexport function toBeHex(_value: BigNumberish, _width?: Numeric): string {\n\ttry {\n\t\tconst value = getUint(_value, 'value');\n\n\t\tlet result = value.toString(16);\n\n\t\tif (_width == null) {\n\t\t\t// Ensure the value is of even length\n\t\t\tif (result.length % 2) {\n\t\t\t\tresult = '0' + result;\n\t\t\t}\n\t\t} else {\n\t\t\tconst width = getNumber(_width, 'width');\n\t\t\tif (width * 2 < result.length) {\n\t\t\t\tthrow new Error(`value exceeds width (${width} bytes)`);\n\t\t\t}\n\n\t\t\t// Pad the value to the required width\n\t\t\twhile (result.length < width * 2) {\n\t\t\t\tresult = '0' + result;\n\t\t\t}\n\t\t}\n\n\t\treturn '0x' + result;\n\t} catch (error: unknown) {\n\t\tif (error instanceof Error) {\n\t\t\tlog.error(`toBeHex: ${error}`);\n\t\t\tthrow makeError(error.message, 'NUMERIC_FAULT', {\n\t\t\t\toperation: 'toBeHex',\n\t\t\t\tfault: 'overflow',\n\t\t\t\tvalue: _value\n\t\t\t});\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\n/**\n * Converts a BigNumberish value to a Big Endian Uint8Array\n *\n * @param {BigNumberish} _value - The value to convert\n * @returns {Uint8Array} The converted Uint8Array\n */\nexport function toBeArray(_value: BigNumberish): Uint8Array {\n\tconst value = getUint(_value, 'value');\n\n\tif (value === BN_0) {\n\t\treturn new Uint8Array([]);\n\t}\n\n\tlet hex = value.toString(16);\n\tif (hex.length % 2) {\n\t\thex = '0' + hex;\n\t}\n\n\tconst result = new Uint8Array(hex.length / 2);\n\tfor (let i = 0; i < result.length; i++) {\n\t\tconst offset = i * 2;\n\t\tresult[i] = parseInt(hex.substring(offset, offset + 2), 16);\n\t}\n\n\treturn result;\n}\n\n/**\n * Returns a hex string for a value safe to use as a quantity\n *\n * @param {BytesLike | BigNumberish} value - The value to convert\n * @returns {string} The converted quantity hex string\n */\nexport function toQuantity(value: BytesLike | BigNumberish): string {\n\tlet result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);\n\twhile (result.startsWith('0')) {\n\t\tresult = result.substring(1);\n\t}\n\tif (result === '') {\n\t\tresult = '0';\n\t}\n\treturn '0x' + result;\n}\n\nexport function multiplyNumeric(x: Numeric, y: Numeric): bigint {\n\t// Ensure both value and price are bigint for multiplication\n\tconst valueBigInt = typeof x === 'bigint' ? x : BigInt(x);\n\tconst priceBigInt = typeof y === 'bigint' ? y : BigInt(y);\n\n\t// Perform the multiplication\n\tconst newValue: bigint = valueBigInt * priceBigInt;\n\n\treturn newValue;\n}\n\nexport { hexToBigNumberish, bigNumberishMultiplyByFraction, addHexPrefix, bigNumberishToHex };\n\n// NOTE: Use 'number' for price related calculations. Use 'bigint' for value related to large decimals such as eth wei or smart contract values.\n\n// There is another library that has a similar class but it is not used in this project (BN.js) or (ethers)\n// Implement the BigNumber class with static methods\n// class BigNumber implements IBigNumberHandler {\n//   private _value: BigNumberish;\n\n//   constructor(value: BigNumberish = null) {\n//     this._value = value;\n//   }\n\n// Getter for value\n//   get value(): BigNumberish {\n//     return this._value;\n//   }\n\n// Setter for value\n//   set value(newValue: BigNumberish) {\n//     this._value = newValue;\n//   }\n\n// Method to convert the value to a number\n//   toNumber(): number | null {\n//     if (this._value === null) {\n//       return null;\n//     }\n\n//     if (typeof this._value === 'string' || typeof this._value === 'number') {\n//       return Number(this._value);\n//     }\n\n//     if (typeof this._value === 'bigint') {\n//       return Number(this._value);\n//     }\n\n//     return null;\n//   }\n\n// Method to convert the value to a bigint\n//   toBigInt(): bigint | null {\n//     if (this._value === null) {\n//       return null;\n//     }\n\n//     if (typeof this._value === 'string') {\n//       return BigInt(this._value);\n//     }\n\n//     if (typeof this._value === 'number') {\n//       return BigInt(this._value);\n//     }\n\n//     if (typeof this._value === 'bigint') {\n//       return this._value;\n//     }\n\n//     return null;\n//   }\n\n// Instance method to convert the value to a string\n//   toString(): string {\n//     const bigintValue = this.toBigInt();\n//     if (bigintValue === null) {\n//       return '';\n//     }\n//     return bigintValue.toString();\n//   }\n\n// Instance method to convert the value to a hex string\n//   toHex(): string {\n//     const bigintValue = this.toBigInt();\n//     if (bigintValue === null) {\n//       return '';\n//     }\n//     return '0x' + bigintValue.toString(16);\n//   }\n\n// Instance method to convert the value to Wei (for Ethereum)\n//   toWei(): BigNumber {\n//     return BigNumber.mul(this._value, BigInt(\"1000000000000000000\"));\n//   }\n\n// Instance method to convert the value to Gwei (for Ethereum)\n//   toGwei(): BigNumber {\n//     return BigNumber.mul(this._value, BigInt(\"1000000000\"));\n//   }\n\n// Instance method to convert the value to Ether (from Wei for Ethereum)\n//   toEther(): BigNumber {\n//     return BigNumber.div(this._value, BigInt(\"1000000000000000000\"));\n//   }\n\n// Instance method to convert the value to Satoshi (for Bitcoin)\n//   toSatoshi(): BigNumber {\n//     return BigNumber.mul(this._value, BigInt(\"100000000\"));\n//   }\n\n// Instance method to convert the value to Bitcoin (from Satoshi)\n//   toBitcoin(): BigNumber {\n//     return BigNumber.div(this._value, BigInt(\"100000000\"));\n//   }\n\n// Instance method to convert the value to Lamport (for Solana)\n//    toLamport(): BigNumber {\n//     return BigNumber.mul(this._value, BigInt(\"1000000000\"));\n//   }\n\n// Instance method to convert the value to SOL (from Lamport for Solana)\n//   toSOL(): BigNumber {\n//     return BigNumber.div(this._value, BigInt(\"1000000000\"));\n//   }\n\n// Instance method to convert the value to Gwei (for Optimism)\n//   toGweiOptimism(): BigNumber {\n//     return BigNumber.mul(this._value, BigInt(\"1000000000\"));\n//   }\n\n// Instance method to convert the value to Wei (for Optimism)\n//   toWeiOptimism(): BigNumber {\n//     return BigNumber.mul(this._value, BigInt(\"1000000000000000000\"));\n//   }\n\n// Instance method to convert the value to Gwei (for Polygon)\n//   toGweiPolygon(): BigNumber {\n//     return BigNumber.mul(this._value, BigInt(\"1000000000\"));\n//   }\n\n// Instance method to convert the value to Wei (for Polygon)\n//   toWeiPolygon(): BigNumber {\n//     return BigNumber.mul(this._value, BigInt(\"1000000000000000000\"));\n//   }\n\n// Instance method to convert the value to Gwei (for Avalanche)\n//   toGweiAvalanche(): BigNumber {\n//     return BigNumber.mul(this._value, BigInt(\"1000000000\"));\n//   }\n\n// Instance method to convert the value to Wei (for Avalanche)\n//   toWeiAvalanche(): BigNumber {\n//     return BigNumber.mul(this._value, BigInt(\"1000000000000000000\"));\n//   }\n\n// Instance method to convert the value to Gwei (for Base)\n//   toGweiBase(): BigNumber {\n//     return BigNumber.mul(this._value, BigInt(\"1000000000\"));\n//   }\n\n// Instance method to convert the value to Wei (for Base)\n//   toWeiBase(): BigNumber {\n//     return BigNumber.mul(this._value, BigInt(\"1000000000000000000\"));\n//   }\n\n// Method to set the value\n//   fromValue(value: BigNumberish): void {\n//     this._value = value;\n//   }\n\n// Instance method to get the maximum of the current value and another BigNumberish value\n//   max(other: BigNumberish): BigNumber {\n//     return BigNumber.max(this._value, other);\n//   }\n\n// Instance method to get the minimum of the current value and another BigNumberish value\n//   min(other: BigNumberish): BigNumber {\n//     return BigNumber.min(this._value, other);\n//   }\n\n// Instance method to add another BigNumberish value to the current value\n//   add(other: BigNumberish): BigNumber {\n//     return BigNumber.add(this._value, other);\n//   }\n\n// Instance method to subtract another BigNumberish value from the current value\n//   sub(other: BigNumberish): BigNumber {\n//     return BigNumber.sub(this._value, other);\n//   }\n\n// Instance method to divide the current value by another BigNumberish value\n//   div(other: BigNumberish): BigNumber {\n//     return BigNumber.div(this._value, other);\n//   }\n\n// Instance method to multiply the current value by another BigNumberish value\n//   mul(other: BigNumberish): BigNumber {\n//     return BigNumber.mul(this._value, other);\n//   }\n\n// Instance method to calculate the modulus of the current value by another BigNumberish value\n//   mod(other: BigNumberish): BigNumber {\n//     return BigNumber.mod(this._value, other);\n//   }\n\n// Static method to create a BigNumber instance\n//   static from(value: BigNumberish): BigNumber {\n//     return new BigNumber(value);\n//   }\n\n// Static method to convert a BigNumberish to a number\n//   static toNumber(value: BigNumberish): number | null {\n//     if (value === null) {\n//       return null;\n//     }\n\n//     if (typeof value === 'string' || typeof value === 'number') {\n//       return Number(value);\n//     }\n\n//     if (typeof value === 'bigint') {\n//       return Number(value);\n//     }\n\n//     return null;\n//   }\n\n// Static method to convert a BigNumberish to a bigint\n//   static toBigInt(value: BigNumberish): bigint | null {\n//     if (value === null) {\n//       return null;\n//     }\n\n//     if (typeof value === 'string') {\n//       return BigInt(value);\n//     }\n\n//     if (typeof value === 'number') {\n//       return BigInt(value);\n//     }\n\n//     if (typeof value === 'bigint') {\n//       return value;\n//     }\n\n//     return null;\n//   }\n\n// Static method to get the maximum of two BigNumberish values\n//   static max(value1: BigNumberish, value2: BigNumberish): BigNumber {\n//     const bigint1 = BigNumber.toBigInt(value1);\n//     const bigint2 = BigNumber.toBigInt(value2);\n\n//     if (bigint1 === null || bigint2 === null) {\n//       throw new Error(\"Invalid BigNumberish value\");\n//     }\n\n//     return new BigNumber(bigint1 > bigint2 ? bigint1 : bigint2);\n//   }\n\n// Static method to get the minimum of two BigNumberish values\n//   static min(value1: BigNumberish, value2: BigNumberish): BigNumber {\n//     const bigint1 = BigNumber.toBigInt(value1);\n//     const bigint2 = BigNumber.toBigInt(value2);\n\n//     if (bigint1 === null || bigint2 === null) {\n//       throw new Error(\"Invalid BigNumberish value\");\n//     }\n\n//     return new BigNumber(bigint1 < bigint2 ? bigint1 : bigint2);\n//   }\n\n// Static method to add two BigNumberish values\n//   static add(value1: BigNumberish, value2: BigNumberish): BigNumber {\n//     const bigint1 = BigNumber.toBigInt(value1);\n//     const bigint2 = BigNumber.toBigInt(value2);\n\n//     if (bigint1 === null || bigint2 === null) {\n//       throw new Error(\"Invalid BigNumberish value\");\n//     }\n\n//     return new BigNumber(bigint1 + bigint2);\n//   }\n\n// Static method to subtract one BigNumberish value from another\n//   static sub(value1: BigNumberish, value2: BigNumberish): BigNumber {\n//     const bigint1 = BigNumber.toBigInt(value1);\n//     const bigint2 = BigNumber.toBigInt(value2);\n\n//     if (bigint1 === null || bigint2 === null) {\n//       throw new Error(\"Invalid BigNumberish value\");\n//     }\n\n//     return new BigNumber(bigint1 - bigint2);\n//   }\n\n// Static method to divide one BigNumberish value by another\n//   static div(value1: BigNumberish, value2: BigNumberish): BigNumber {\n//     const bigint1 = BigNumber.toBigInt(value1);\n//     const bigint2 = BigNumber.toBigInt(value2);\n\n//     if (bigint1 === null || bigint2 === null || bigint2 === BigInt(0)) {\n//       throw new Error(\"Invalid BigNumberish value or division by zero\");\n//     }\n\n//     return new BigNumber(bigint1 / bigint2);\n//   }\n\n// Static method to multiply two BigNumberish values\n//   static mul(value1: BigNumberish, value2: BigNumberish): BigNumber {\n//     const bigint1 = BigNumber.toBigInt(value1);\n//     const bigint2 = BigNumber.toBigInt(value2);\n\n//     if (bigint1 === null || bigint2 === null) {\n//       throw new Error(\"Invalid BigNumberish value\");\n//     }\n\n//     return new BigNumber(bigint1 * bigint2);\n//   }\n\n// Static method to calculate the modulus of one BigNumberish value by another\n//   static mod(value1: BigNumberish, value2: BigNumberish): BigNumber {\n//     const bigint1 = BigNumber.toBigInt(value1);\n//     const bigint2 = BigNumber.toBigInt(value2);\n\n//     if (bigint1 === null || bigint2 === null || bigint2 === BigInt(0)) {\n//       throw new Error(\"Invalid BigNumberish value or modulus by zero\");\n//     }\n\n//     return new BigNumber(bigint1 % bigint2);\n//   }\n\n// Static method to convert BigNumberish value to hex string\n//   static toHex(value: BigNumberish): string {\n//     const bigintValue = BigNumber.toBigInt(value);\n//     if (bigintValue === null) {\n//       throw new Error(\"Invalid BigNumberish value\");\n//     }\n//     return \"0x\" + bigintValue.toString(16);\n//   }\n\n// Static method to create a BigNumber from a hex string\n//   static fromHex(hex: string): BigNumber {\n//     if (typeof hex !== \"string\" || !/^0x[0-9a-fA-F]+$/.test(hex)) {\n//       throw new Error(\"Invalid hex string\");\n//     }\n//     return new BigNumber(BigInt(hex));\n//   }\n// }\n\n// Example usage\n// let myValue: BigNumber = BigNumber.from(10n);\n// console.log('Max', myValue.max(9n).toBigInt()); // Output: 10n\n// console.log('Min', myValue.min(9).toBigInt());  // Output: 9n\n// console.log('Max', myValue.max(\"9\").toBigInt()); // Output: 10n\n\n// let myValue2: BigNumber = BigNumber.from(20); // 20 is a number\n// console.log('Value2', myValue2.toBigInt()); // Output: 20n\n\n// let myValue3: number = 5;\n// console.log('Max', BigNumber.max(50n, myValue3).toBigInt()); // Output: 50n\n\n// Division example\n// console.log('Div', myValue.div(\"5\").toBigInt()); // Output: 2n\n// console.log('Div', BigNumber.div(20n, \"4\").toBigInt()); // Output: 5n\n\n// Multiplication example\n// console.log('Mul', myValue.mul(3).toBigInt()); // Output: 30n\n// console.log('Mul', BigNumber.mul(20n, \"2\").toBigInt()); // Output: 40n\n\n// Modulus example\n// console.log('Mod', myValue.mod(3).toBigInt()); // Output: 1n\n// console.log('Mod', BigNumber.mod(20n, \"6\").toBigInt()); // Output: 2n\n\n// Hex conversion example\n// let hexValue: BigNumber = BigNumber.fromHex(\"0x1234\");\n// console.log('Hex to BigInt:', hexValue.toBigInt()); // Output: 4660n\n// console.log('BigInt to Hex:', BigNumber.toHex(4660n)); // Output: \"0x1234\"\n\n// Instance methods toString and toHex\n// console.log('Value toString:', myValue.toString()); // Output: \"10\"\n// console.log('Value toHex:', myValue.toHex()); // Output: \"0xa\"\n\n// Ethereum conversions\n// let etherValue: BigNumber = BigNumber.from(\"1\");\n// console.log('To Wei:', etherValue.toWei().toBigInt()); // Output: 1000000000000000000n\n// console.log('To Gwei:', etherValue.toGwei().toBigInt()); // Output: 1000000000n\n// console.log('To Ether:', etherValue.toWei().toEther().toBigInt()); // Output: 1n\n\n// Bitcoin conversions\n// let bitcoinValue: BigNumber = BigNumber.from(\"1\");\n// console.log('To Satoshi:', bitcoinValue.toSatoshi().toBigInt()); // Output: 100000000n\n// console.log('To Bitcoin:', bitcoinValue.toSatoshi().toBitcoin().toBigInt()); // Output: 1n\n\n// Solana conversions\n// let solValue: BigNumber = BigNumber.from(\"1\");\n// console.log('To Lamport:', solValue.toLamport().toBigInt()); // Output: 1000000000n\n// console.log('To SOL:', solValue.toLamport().toSOL().toBigInt()); // Output: 1n\n\n// Optimism conversions\n// let optimismValue: BigNumber = BigNumber.from(\"1\");\n// console.log('To Gwei Optimism:', optimismValue.toGweiOptimism().toBigInt()); // Output: 1000000000n\n// console.log('To Wei Optimism:', optimismValue.toWeiOptimism().toBigInt()); // Output: 1000000000000000000n\n\n// Polygon conversions\n// let polygonValue: BigNumber = BigNumber.from(\"1\");\n// console.log('To Gwei Polygon:', polygonValue.toGweiPolygon().toBigInt()); // Output: 1000000000n\n// console.log('To Wei Polygon:', polygonValue.toWeiPolygon().toBigInt()); // Output: 1000000000000000000n\n\n// Avalanche conversions\n// let avalancheValue: BigNumber = BigNumber.from(\"1\");\n// console.log('To Gwei Avalanche:', avalancheValue.toGweiAvalanche().toBigInt()); // Output: 1000000000n\n// console.log('To Wei Avalanche:', avalancheValue.toWeiAvalanche().toBigInt()); // Output: 1000000000000000000n\n\n// Base conversions\n// let baseValue: BigNumber = BigNumber.from(\"1\");\n// console.log('To Gwei Base:', baseValue.toGweiBase().toBigInt()); // Output: 1000000000n\n// console.log('To Wei Base:', baseValue.toWeiBase().toBigInt()); // Output: 1000000000000000000n\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { log } from '$lib/managers/Logger';\nimport { browser_ext } from './environment';\n\nexport const clearObjectsFromLocalStorage = async (): Promise<void> => {\n\tif (!browser_ext) return;\n\n\ttry {\n\t\tawait browser_ext.storage.local.clear();\n\t} catch (error) {\n\t\tlog.error('Error clearing local storage', false, error);\n\t\tthrow error;\n\t}\n};\n\n// This had two arguments, but I removed the second one since we only want to return objects\n// export const getObjectFromLocalStorage = async <T>(key: string): Promise<T | null> => {\n//   try {\n//     if (!browser_ext) {\n//       console.log('Browser extension is not available. Returning null.');\n//       return null;\n//     }\n//     const result = await browser_ext.storage.local.get(key);\n//     return result[key] as T;\n//   } catch (error) {\n//     console.log('Error getting object from local storage', false, error);\n//     throw error;\n//   }\n// };\n\nexport const getObjectFromLocalStorage = async <T>(\n\tkey: string,\n\ttimeoutMs = 1000\n): Promise<T | null> => {\n\ttry {\n\t\tif (!browser_ext) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst storagePromise = browser_ext.storage.local.get(key);\n\n\t\t// Set a timeout to prevent infinite hangs\n\t\tconst timeoutPromise = new Promise<null>((resolve) =>\n\t\t\tsetTimeout(() => {\n\t\t\t\tresolve(null);\n\t\t\t}, timeoutMs)\n\t\t);\n\n\t\tconst result = await Promise.race([storagePromise, timeoutPromise]);\n\n\t\tif (!result || !(key in result)) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn result[key] as T;\n\t} catch (error) {\n\t\tlog.error('Error getting object from local storage', false, error);\n\t\treturn null;\n\t}\n};\n\nexport const setObjectInLocalStorage = async <T extends Record<string, any>>(\n\tkey: string,\n\tobj: T | string\n): Promise<void> => {\n\tif (!browser_ext) return;\n\n\ttry {\n\t\tawait browser_ext.storage.local.set({ [key]: obj });\n\t} catch (error) {\n\t\tlog.error('Error setting object in local storage', false, error);\n\t\tthrow error;\n\t}\n};\n\nexport const removeObjectFromLocalStorage = async (keys: string): Promise<void> => {\n\tif (!browser_ext) return;\n\n\ttry {\n\t\tawait browser_ext.storage.local.remove(keys);\n\t} catch (error) {\n\t\tlog.error('Error removing object from local storage', false, error);\n\t\tthrow error;\n\t}\n};\n","import { log } from '$lib/managers/Logger';\n\nexport type Timestamp = string | number | Date | undefined;\n\nexport interface FormatTimestampOptions {\n\tplaceholder?: string;\n\tlocale?: string;\n\toptions?: Intl.DateTimeFormatOptions;\n}\n\nexport function dateString() {\n\treturn new Date().toISOString();\n}\n\nexport function getTime(): number {\n\treturn new Date().getTime();\n}\n\nexport function formatDate(date: Date): string {\n\treturn date.toLocaleString();\n}\n\nexport function formatTimestamp(\n\ttimestamp: Timestamp,\n\t{\n\t\tplaceholder = '------',\n\t\tlocale = 'en-US',\n\t\toptions = { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }\n\t}: FormatTimestampOptions = {}\n): string {\n\ttry {\n\t\tif (timestamp === undefined || (typeof timestamp === 'number' && Number.isNaN(timestamp))) {\n\t\t\treturn placeholder;\n\t\t}\n\n\t\tlet date: Date;\n\n\t\tif (typeof timestamp === 'string' || typeof timestamp === 'number') {\n\t\t\tdate = new Date(timestamp);\n\t\t\tif (isNaN(date.getTime())) {\n\t\t\t\treturn placeholder;\n\t\t\t}\n\t\t} else if (timestamp instanceof Date) {\n\t\t\tdate = timestamp;\n\t\t} else {\n\t\t\treturn placeholder;\n\t\t}\n\n\t\treturn new Intl.DateTimeFormat(locale, options).format(date);\n\t} catch (e) {\n\t\tlog.error(e);\n\t\treturn placeholder;\n\t}\n}\n\n// Example usage\n// console.log(formatTimestamp('2023-07-12T14:30:00Z')); // Default formatting\n// console.log(formatTimestamp(1689160200000)); // Default formatting with timestamp\n// console.log(formatTimestamp(undefined)); // Default placeholder\n// console.log(formatTimestamp('invalid date')); // Default placeholder with invalid date\n// console.log(formatTimestamp(new Date(), { placeholder: '', locale: 'en-GB', options: { year: 'numeric', month: 'long', day: 'numeric' } })); // Custom formatting\n","/* eslint-disable prefer-const */\n\n// dataModels.ts - this is the default data that is used when the user first installs the app. Some of this data will be updated and some may seem out of date. If so, then please file an issue so we can address it. The customer data will override this data.\n\n// yakklSettings\n// `autoLockTimer` is in seconds as integers (e.g., 0 - on idle, 1 - 1 second, ..., 3600 - 1 hour, etc.)\n\n// NOTE: 'id' should be unique value for the given group of data. Crypto uuidv4 can be used so that if we move to a central DB then it will be unique.\n\nexport const prerender = false;\n\nimport { dateString } from '$lib/common/datetime';\nimport type {\n\tPreferences,\n\tYakklWatch,\n\tYakklSecurity,\n\tYakklBlocked,\n\tYakklRegisteredData,\n\tProfile,\n\tYakklChat,\n\tYakklCurrentlySelected,\n\tYakklAccount,\n\tYakklPrimaryAccount,\n\tYakklConnectedDomain,\n\tYakklContact,\n\tYakklNFT,\n\tCurrentlySelectedData,\n\tAccountData,\n\tPrimaryAccountData,\n\tProfileData,\n\tSettings,\n\tConnectedDomainPermissions,\n\tAccountAddress,\n\tConnectedDomainRevoked\n} from '$lib/common/interfaces';\n\nimport {\n\tSystemTheme,\n\tAccountTypeCategory,\n\tRegisteredType,\n\tNetworkType,\n\tAccessSourceType,\n\tPromoClassificationType,\n\tPlanType\n} from '$lib/common/types';\n\nimport {\n\tDEFAULT_POPUP_WIDTH,\n\tDEFAULT_POPUP_HEIGHT,\n\tDEFAULT_EXT_HEIGHT,\n\tDEFAULT_TITLE,\n\tYAKKL_ZERO_ADDRESS,\n\tYAKKL_ZERO_ACCOUNT_NAME,\n\tNUM_OF_SPLASH_IMAGES,\n\tSPLASH_DELAY,\n\tALERT_DELAY,\n\tIDLE_AUTO_LOCK_CYCLE,\n\tVERSION,\n\tDEFAULT_PERSONA\n} from '$lib/common/constants';\n\n// TBD - Need an IR (Incident Response) Plan in the event of security issues of any kind. Future insurance will require this\n// TBD - Same holds true for DR (Disaster Recovery) Plan. We must create a 'chaos monkey' test plan and run on a regular basis\n\n// TBD - Maybe setup a private cryptic domain to use for sending important analytical data\n// TBD - Maybe setup a generic cdn imaging cryptic domain to for rotation of images (if even needed or desired)\n\n// TBD - reset version automatically here...\n\n// Version of data allows for downward compatibility, especially with any messaging systems\n// rotationDate - Automatically set a rotation date for password or passkey change.\n// passkey - // TBD - could be used instad of password with encryption of username + passkey + biometric when using mobile and 2FA with security key\n// status - enabled, disabled, pending. Pending is being worked on and disabled means we're not currently supporting it\n\n// TBD - need to capture OS, version, date of creation, what features are used. Creation date can be associated with personal data\n// All other items would anonymized with no accociate with any given account\n// TBD - May can use $YAK or $YAKKL as a means of credit that can be used for payment of services to get more community envolvement\n// Think of it like earning points back like Amazon on things you normally would do in the crypto space anyway\n// security: {\n// TBD - We may need to have a secret security option that is not open sourced so that we can rotate keys or have multi-signature smart countracts\n// This advanced security could be charged for and we double encrypt and backup on our closed servers via vpn\n// Maybe we have a minimum of $2 USD per month with variable price up to $10 or $20 USD depending on actual usage that covers all costs\n// TBD - Institional version could have an IIoT devices with an embedded TPM chip and certificate that would be able to communicate\n// over VPN with our systems. Would can then work with the institutions security team on protecting all assets\n\n// Default non-ecrypted data which is safe to be in memory (same as currentlySelected data)\n// NOTE: id and userName are unique and part of each storage (stores are only in memory for a given session). All sensitive data is encrypted!\n\n// NOTE: Update these two as needed!!\n// WIP - May need to add a dataModel for providers and the blockchains they support. Review interfaces! This could be used for the wallet provider and blockchain combo for the future.\nexport let yakklWalletBlockchains = ['Ethereum'];\nexport let yakklWalletProviders = ['Alchemy'];\n// WIP - Already have stores and storage defined\n\n// Preferences - User specified and defaults\nexport const yakklPreferences: Preferences = {\n\tid: '',\n\tpersona: DEFAULT_PERSONA,\n\tidleDelayInterval: 60, // System default of 1 minute - this is in seconds\n\tshowTestNetworks: true,\n\tdark: SystemTheme.SYSTEM, // 'dark', 'light', 'system'\n\tchart: 'line',\n\tscreenWidth: 0, // These two change. They are here for temporary but we're already using settings for the popup\n\tscreenHeight: 0,\n\tidleAutoLock: true,\n\tidleAutoLockCycle: IDLE_AUTO_LOCK_CYCLE, // 3 minutes\n\tlocale: 'en_US',\n\tcurrency: { code: 'USD', symbol: '$' },\n\twords: 32, // Default number of words - may not enable in the UI - 24 words= 12 words, 32 words= 24 words\n\twallet: {\n\t\ttitle: DEFAULT_TITLE,\n\t\textensionHeight: DEFAULT_EXT_HEIGHT,\n\t\tpopupHeight: DEFAULT_POPUP_HEIGHT,\n\t\tpopupWidth: DEFAULT_POPUP_WIDTH,\n\t\tenableContextMenu: false,\n\t\tenableResize: false,\n\t\tsplashDelay: SPLASH_DELAY,\n\t\talertDelay: ALERT_DELAY,\n\t\tsplashImages: NUM_OF_SPLASH_IMAGES,\n\t\tautoLockTimer: 0, // In seconds - if 0 then it will autolock on system 'idle'\n\t\tautoLockAsk: false, // If true then it will prompt to ask the user to continue\n\t\tautoLockAskTimer: 10, // If autoLockAsk true then this timer will keep the dialog and app open this many more seconds before locking automatically via timeout\n\t\tanimationLockScreen: false,\n\t\tpinned: true,\n\t\tpinnedLocation: 'M', // May want 'TL' Top Left, 'TR' Top Right, 'BL', 'BR', 'M' Middle, or 'x,y' coordinates\n\t\tdefaultWallet: true // This can be cutoff in preferences/wallet. It allows any reference to 'window.ethereum' or others to only popup Yakkl\n\t},\n\ttheme: 'yakkl',\n\tthemes: [\n\t\t{\n\t\t\tname: 'yakkl',\n\t\t\tanimation: {\n\t\t\t\tlockScreen: ''\n\t\t\t},\n\t\t\tcolors: {\n\t\t\t\tprimary: '',\n\t\t\t\tsecondary: '',\n\t\t\t\tprimaryBackgroundLight: '',\n\t\t\t\tprimaryBackgroundDark: ''\n\t\t\t}\n\t\t}\n\t],\n\tversion: VERSION, // Travels with the data for upgrades\n\tcreateDate: dateString(),\n\tupdateDate: dateString()\n};\n\n// Settings - Mostly items that are automatically updated by the system\nexport let yakklSettings: Settings = {\n\tid: '', // Profile id\n\tpersona: DEFAULT_PERSONA,\n\tversion: VERSION, // Uses semversion format but puts 'default' as a placeholder\n\tpreviousVersion: '',\n\tplan: {\n\t\ttype: PlanType.BASIC_MEMBER,\n\t\tsource: AccessSourceType.STANDARD,\n\t\tpromo: null,\n\t\ttrialEndDate: null,\n\t\tupgradeDate: null\n\t},\n\ttrialCountdownPinned: false,\n\tlegal: {\n\t\ttermsAgreed: false,\n\t\tprivacyViewed: false,\n\t\tupdated: false // If this is set then we show the updated terms and privacy. We could just push the code in top pull up legal again and not have this attribute\n\t},\n\tplatform: {\n\t\tarch: '',\n\t\tnacl_arch: '',\n\t\tos: '',\n\t\tosVersion: '',\n\t\tbrowser: '',\n\t\tbrowserVersion: '',\n\t\tplatform: '' // Something like 'MacIntel'\n\t},\n\tinit: false,\n\tshowHints: true,\n\tisLocked: true,\n\tisLockedHow: '', //'internal' | 'idle_system' | 'idle_timer' | 'user',\n\ttransactions: {\n\t\tretry: {\n\t\t\tenabled: true,\n\t\t\thowManyAttempts: 3,\n\t\t\tseconds: 30, // Retry in 30 seconds\n\t\t\tbaseFeeIncrease: 0.1, // percentages\n\t\t\tpriorityFeeIncrease: 0.1 // percentages\n\t\t},\n\t\tretain: {\n\t\t\tenabled: true, // Log all transactions (attempts, success, fails, etc...)\n\t\t\tdays: -1, // days to retain, if -1 then as long as possible\n\t\t\tincludeRaw: true // This will include the full raw blockchain transaction info\n\t\t\t// Could have obfuscation of data\n\t\t}\n\t},\n\tmeta: {}, // Meta is currently not used\n\tupgradeDate: '',\n\tlastAccessDate: dateString(),\n\tcreateDate: dateString(),\n\tupdateDate: dateString()\n};\n\nexport let yakklWatch: YakklWatch = {\n\tid: '', // Profile id\n\tpersona: DEFAULT_PERSONA,\n\tblockchain: '',\n\tname: '',\n\ttags: [],\n\tquantity: 0n,\n\tincludeInPortfolio: false,\n\texplorer: '',\n\taddress: '',\n\taddressAlias: '',\n\tversion: VERSION, // Travels with the data for upgrades\n\tcreateDate: dateString(),\n\tupdateDate: dateString()\n};\n\n// Need to work on 2FA and zero trust for 'Premium' and/or 'Ultra' and 'Enterprise' (enterprise will need to support SSO or AD)\nexport let yakklSecurity: YakklSecurity = {\n\tid: '',\n\tpersona: DEFAULT_PERSONA,\n\ttype: '',\n\tvalue: '',\n\tenhancedSecurity: {\n\t\tenabled: false, // We have this off so that user makes a decision to enable it\n\t\trotationDays: 0,\n\t\tlastRotationDate: '', // It will not force a pwd change but will keep prompting until they do\n\t\tpassKey: '',\n\t\tpassKeyHints: [],\n\t\tmfaType: '',\n\t\tphone: ''\n\t},\n\tversion: VERSION, // Travels with the data for upgrades\n\tcreateDate: dateString(),\n\tupdateDate: dateString()\n};\n\nexport let yakklBlocked: YakklBlocked = {\n\tid: '',\n\tpersona: DEFAULT_PERSONA,\n\tdomain: ''\n};\n\nexport let yakklRegisteredData: YakklRegisteredData = {\n\tid: '',\n\tpersona: DEFAULT_PERSONA,\n\tkey: '',\n\tplan: {\n\t\ttype: PlanType.BASIC_MEMBER,\n\t\tsource: AccessSourceType.STANDARD,\n\t\tpromo: PromoClassificationType.NONE,\n\t\ttrialEndDate: '',\n\t\tupgradeDate: ''\n\t},\n\tversion: VERSION,\n\tcreateDate: dateString(),\n\tupdateDate: dateString()\n};\n\nexport let profile: Profile = {\n\tid: '', // Must be unique - used where there is an 'id'\n\tpersona: DEFAULT_PERSONA,\n\tuserName: '', // Must be unique - not encrypted\n\tpreferences: yakklPreferences,\n\tdata: {} as ProfileData,\n\tversion: VERSION, // Travels with the data for upgrades\n\tcreateDate: dateString(),\n\tupdateDate: dateString()\n};\n\nexport let yakklChat: YakklChat = {\n\tid: '',\n\tpersona: DEFAULT_PERSONA,\n\ttext: '',\n\tsender: '',\n\ttimestamp: '',\n\tversion: VERSION,\n\tcreateDate: dateString(),\n\tupdateDate: dateString()\n};\n\nexport let yakklCurrentlySelected: YakklCurrentlySelected = {\n\tid: '', // Profile id\n\tpersona: DEFAULT_PERSONA,\n\tshortcuts: {\n\t\tquantity: 0n, // Account value - IF not 0.0 then use formatEther from utilities. If you need to convert to bigint then use parseEther from ethers\n\t\taccountType: AccountTypeCategory.PRIMARY, // primary, imported, sub\n\t\taccountName: YAKKL_ZERO_ACCOUNT_NAME, // shortcut for account.name\n\t\tsmartContract: false,\n\t\taddress: YAKKL_ZERO_ADDRESS, // So we don't have to hit yakklAccount every time\n\t\talias: '', // Address alias like myaddress.eth\n\t\tprimary: null, // Primary account for quick reference\n\t\tinit: false,\n\t\tlegal: false, // from yakklSettings - this version is only a shortcut - use the yakklSettings version for actual logic\n\t\tisLocked: true,\n\t\tshowTestNetworks: false,\n\t\tprofile: {\n\t\t\tuserName: '',\n\t\t\tname: null,\n\t\t\temail: ''\n\t\t},\n\t\tgasLimit: 21000, // 21000 for EOA and 45000 for smart contracts - use decimalToHex to convert to hex\n\t\tnetworks: [\n\t\t\t{\n\t\t\t\tblockchain: 'Ethereum',\n\t\t\t\tname: 'Mainnet',\n\t\t\t\tchainId: 1,\n\t\t\t\tsymbol: 'ETH',\n\t\t\t\ttype: NetworkType.MAINNET,\n\t\t\t\texplorer: 'https://etherscan.io',\n\t\t\t\tdecimals: 18\n\t\t\t},\n\t\t\t{\n\t\t\t\tblockchain: 'Ethereum',\n\t\t\t\tname: 'Sepolia',\n\t\t\t\tchainId: 11155111,\n\t\t\t\tsymbol: 'ETH',\n\t\t\t\ttype: NetworkType.TESTNET,\n\t\t\t\texplorer: 'https://sepolia.etherscan.io',\n\t\t\t\tdecimals: 18\n\t\t\t}\n\t\t], // List of the associated networks for both mainnet and testnets\n\t\tnetwork: {\n\t\t\tblockchain: 'Ethereum',\n\t\t\tname: 'Mainnet',\n\t\t\tchainId: 1,\n\t\t\tsymbol: 'ETH',\n\t\t\ttype: NetworkType.MAINNET,\n\t\t\texplorer: 'https://etherscan.io',\n\t\t\tdecimals: 18\n\t\t}, // The current network for the given account\n\n\t\t// Legacy - May remove\n\t\tblockchain: 'Ethereum', // So we don't have to hit yakklNetwork every time - Also, make sure to name the background card to this blockchain in lowercase\n\t\ttype: 'Mainnet', // whatever type that was selected from the network type collection\n\t\tchainId: 1, // Default to mainnet\n\t\tsymbol: 'ETH',\n\t\texplorer: 'https://etherscan.io'\n\t},\n\t// network: yakklNetwork, // The current network for the given account\n\tpreferences: {\n\t\tlocale: 'en_US',\n\t\tcurrency: { code: 'USD', symbol: '$' }\n\t},\n\tdata: {} as CurrentlySelectedData,\n\tversion: VERSION, // travels with the data and mainly used for upgrades\n\tcreateDate: dateString(),\n\tupdateDate: dateString()\n};\n\n// Pulled from random popular or high-value addresses in etherscan.io\n// If you have a qty > 0 AND includeInPortfolio is true then it will be added to the overall value\n// Why is 'includeInPortfolio' present instead of simply assuming a qty > 0 is for including in the user's portfolio?\n// It forces the user to make a choice and accept responsibility for these values appearing in their portfolio.\n\nexport let yakklPrimaryAccount: YakklPrimaryAccount = {\n\tid: '', // Profile id\n\tpersona: DEFAULT_PERSONA,\n\tname: YAKKL_ZERO_ACCOUNT_NAME, // account name, address, and keys are here for convenience - they are also in the yakklAccount record\n\taddress: YAKKL_ZERO_ADDRESS,\n\tquantity: 0n,\n\tindex: 0, // for primary path account index\n\tdata: {} as PrimaryAccountData, // Encrypted\n\taccount: {} as YakklAccount, // Primary\n\tsubIndex: 0, // for indexing the path for derived - sub accounts\n\tsubAccounts: [], // yakklAccounts\n\tversion: VERSION, // Travels with the data for upgrades\n\tcreateDate: dateString(),\n\tupdateDate: dateString()\n};\n\n// Represents the raw address used for transactions for any asset class\nexport let yakklAccount: YakklAccount = {\n\tid: '', // Profile id\n\tpersona: DEFAULT_PERSONA,\n\tindex: 0,\n\tblockchain: 'Ethereum',\n\tsmartContract: false, // SmartContracts do not have private keys and the price per gas unit is usually 45,000 instead of 21,000\n\taddress: YAKKL_ZERO_ADDRESS, // Must be unique\n\talias: '',\n\taccountType: AccountTypeCategory.PRIMARY, //'imported' | 'sub' | 'primary',  // May need to add 'NFT' or 'RWA' or something else for different types of accounts - ??\n\tname: YAKKL_ZERO_ACCOUNT_NAME,\n\tdescription: '', // Can use this to describe an account associated with an NFT or RWA (Real World Asset) or class\n\tprimaryAccount: yakklPrimaryAccount, // If the account is a primary account then this is empty\n\tdata: {} as AccountData, // Encrypted\n\tquantity: 0n, // big number and supports up to 18 decimals - contains the value here plus the sum of all derived accounts from this primary account\n\tclass: 'Default', // This is only used for enterprise like environments. It can be used for departments like 'Finance', 'Accounting', '<whatever>'\n\tlevel: 'L1',\n\tisSigner: true,\n\tavatar: '', // Default is identityicon but can be changed to user/account avatar\n\ttags: ['Ethereum'],\n\tincludeInPortfolio: true, // This only applys to the value in this primary account and not any of the derived accounts from this primary account\n\tconnectedDomains: [],\n\tversion: VERSION, // Travels with the data for upgrades\n\tcreateDate: dateString(),\n\tupdateDate: dateString()\n};\n\n// Now update the 'primaryAccount' with the 'account' property\nyakklPrimaryAccount.account = yakklAccount;\n\n// Tracks the domain/dApp connected to a given address\nexport let yakklConnectedDomain: YakklConnectedDomain = {\n\tid: '',\n\tpersona: DEFAULT_PERSONA,\n\taddresses: [] as AccountAddress[], // {address: '', blockchain: 'Ethereum', chainId: '0x1'}\n\tname: '', // Name of dApp/site\n\tpermissions: {} as ConnectedDomainPermissions, // What permissions has Yakkl allowed for this connected domain\n\tdomain: '',\n\ticon: '',\n\tversion: VERSION, // Travels with the data for upgrades\n\tstatus: '',\n\trevoked: {} as ConnectedDomainRevoked,\n\tchainId: 1,\n\turl: '',\n\tcreateDate: dateString(),\n\tupdateDate: dateString()\n};\n\n// Holds any contact information of addresses used to send crypto to. Allows the addresses to be more human friendly\nexport let yakklContact: YakklContact = {\n\tid: '',\n\tpersona: DEFAULT_PERSONA,\n\tname: '',\n\taddress: '',\n\taddressType: 'EOA', // EOA or SC\n\tavatar: '',\n\tblockchain: 'Ethereum',\n\talias: '',\n\tnote: '', // Note on the contact for anything you wish to keep\n\tversion: VERSION, // Travels with the data for upgrades\n\tcreateDate: dateString(),\n\tupdateDate: dateString(),\n\tmeta: {}\n};\n\n// TODO: Think through NFT collections, rarity, transfers, etc.\nexport let yakklNFT: YakklNFT = {\n\tid: '',\n\tpersona: DEFAULT_PERSONA,\n\tname: '',\n\tdescription: '',\n\ttoken: '',\n\tthumbnail: '',\n\tblockchain: '',\n\tmedia: [\n\t\t{\n\t\t\ttype: 'image', //\"image\" | \"video\" | \"audio\"\n\t\t\turl: ''\n\t\t}\n\t],\n\tcontract: '',\n\towner: '',\n\tversion: VERSION, // Travels with the data for upgrades\n\ttransferDate: '',\n\tcreateDate: dateString(),\n\tupdateDate: dateString(),\n\tmeta: {}\n};\n\n// Lists...\nexport let yakklAccounts = [yakklAccount];\nexport let yakklPrimaryAccounts = [yakklPrimaryAccount];\nexport let yakklContacts = [yakklContact];\nexport let yakklChats = [yakklChat];\nexport let yakklConnectedDomains = [yakklConnectedDomain];\nexport let yakklBlockedList = [yakklBlocked];\nexport let yakklWatchList = [yakklWatch];\n\n// Sample data...\n// initialAssets.json is in the 'data' directory\nexport let sampleWatch: YakklWatch[] = [\n\t{\n\t\tid: '',\n\t\tpersona: DEFAULT_PERSONA,\n\t\tblockchain: 'Ethereum',\n\t\tname: 'Watcher 1',\n\t\ttags: ['Binance 8', 'Uniswap'],\n\t\tquantity: '.000455',\n\t\tincludeInPortfolio: true,\n\t\texplorer: '',\n\t\taddress: '0xf977814e90da44bfa03b6295a0616a897441acec',\n\t\taddressAlias: '',\n\t\tversion: VERSION,\n\t\tcreateDate: dateString(),\n\t\tupdateDate: dateString()\n\t},\n\t{\n\t\tid: '',\n\t\tpersona: DEFAULT_PERSONA,\n\t\tblockchain: 'Ethereum',\n\t\tname: 'Watcher 2',\n\t\ttags: ['Vb', 'Token holdings'],\n\t\tquantity: '0.0',\n\t\tincludeInPortfolio: false,\n\t\texplorer: 'https://etherscan.io/tokenholdings?a=0xab5801a7d398351b8be11c439e05c5b3259aec9b',\n\t\taddress: '0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B',\n\t\taddressAlias: 'Vb',\n\t\tversion: VERSION,\n\t\tcreateDate: dateString(),\n\t\tupdateDate: dateString()\n\t},\n\t{\n\t\tid: '',\n\t\tpersona: DEFAULT_PERSONA,\n\t\tblockchain: 'Ethereum',\n\t\tname: 'Watcher 3',\n\t\ttags: ['barmstrong.eth', 'coinbase', 'address'],\n\t\tquantity: '0.0',\n\t\tincludeInPortfolio: false,\n\t\texplorer: 'https://etherscan.io/address/0x5b76f5b8fc9d700624f78208132f91ad4e61a1f0',\n\t\taddress: '0x5b76f5B8fc9D700624F78208132f91AD4e61a1f0',\n\t\taddressAlias: 'barmstrong.eth',\n\t\tversion: VERSION,\n\t\tcreateDate: dateString(),\n\t\tupdateDate: dateString()\n\t}\n];\n\n// NOTE: May want to add other default data...\nexport const yakklStoredObjects = [\n\t{ key: 'preferences', value: yakklPreferences },\n\t{ key: 'settings', value: yakklSettings },\n\t{ key: 'yakklCurrentlySelected', value: yakklCurrentlySelected },\n\t{ key: 'yakklSecurity', value: yakklSecurity },\n\t{ key: 'yakklWalletBlockchains', value: yakklWalletBlockchains },\n\t{ key: 'yakklWalletProviders', value: yakklWalletProviders },\n\t{ key: 'profile', value: profile },\n\t{ key: 'yakklBlockedList', value: yakklBlockedList },\n\t{ key: 'yakklWatchList', value: sampleWatch },\n\t{ key: 'yakklConnectedDomains', value: [] }\n];\n\n// Below to be removed at a later date.\n\n// initialAssets.json is in the 'data' directory\n// export let defaultYakklAssets = [\n//   {\n//     name: 'Ethereum', // This should be unique when combined with 'class'\n//     class: 'Token',   // Asset class such as 'Tokens', 'NFTs', 'RWA', ...\n//     subClass: '',  // Mainly applies to RWA such as deeds, titles, ...\n//     description: 'Ethereum crypto',\n//     status: 'enabled',\n//     icon: '/images/ethereum.svg',\n//     symbol: 'ETH',\n//     network: 'Ethereum',  // Primary network\n//     networks: [  // TODO: Verify 'network' and 'name' are handled correctly\n//       {network: \"Ethereum\", type: \"mainnet\", release: \"Production\", name: \"mainnet\", chainId: \"0x1\", symbol: \"ETH\", urlRPC: \"https://mainnet.infura.io/v3/\", explorer: \"https://etherscan.io\"},\n//       {network: \"Ethereum\", type: \"testnet\", release: \"Test\", name: \"Sepolia\", chainId: \"0xaa36a7\", symbol: \"ETH\", urlRPC: \"https://sepolia.infura.io/v3/\", explorer: \"https://etherscan.io\"}\n//     ],\n//     version: '',\n//   },\n//   {\n//     name: 'Bitcoin', // This should be unique when combined with 'class'\n//     class: 'Token',\n//     subClass: '',  // Mainly applies to RWA such as deeds, titles, ...\n//     description: 'Bitcoin crypto',\n//     status: 'pending',\n//     icon: '/images/bitcoin.svg',\n//     symbol: 'BTC',  // May can be different for different asset classes\n//     network: 'Bitcoin',\n//     networks: [],\n//     version: '',\n//   },\n//   {\n//     name: 'Solana', // This should be unique when combined with 'class'\n//     class: 'Token',\n//     subClass: '',  // Mainly applies to RWA such as deeds, titles, ...\n//     description: 'Solana crypto',\n//     status: 'pending',\n//     icon: '/images/solana.svg',\n//     symbol: 'SOL',  // May can be different for different asset classes\n//     network: 'Solana',\n//     networks: [],\n//     version: '',\n//   },\n// ];\n\n// initialNetworks.json is in the 'data' directory\n// export let defaultEthereumNetworks = [\n//   {network: \"Ethereum\", type: \"mainnet\", release: \"Production\", name: \"mainnet\", chainId: \"0x1\", symbol: \"ETH\", urlRPC: \"https://mainnet.infura.io/v3/\", explorer: \"https://etherscan.io\"},\n//   {network: \"Ethereum\", type: \"testnet\", release: \"Test\", name: \"Sepolia\", chainId: \"0xaa36a7\", symbol: \"ETH\", urlRPC: \"https://sepolia.infura.io/v3/\", explorer: \"https://etherscan.io\"}\n// ];\n\n// export let yakklProvider: YakklProvider = {\n//   provider: 'Infura',   // If name is 'yakkl' then yakkl cloud is the provider and we're going direct to the given blockchains\n//   blockchain: 'Ethereum',\n//   name: 'Mainnet',\n//   chainId: '0x1',     // Have to look up the 'name' from yakklNetworks and 'key' from process.env\n//   weight: 5,    // Weight 1-5 with 5 being the provider to use the most - this only applies to mainnets. Testnets all have a weight of 0\n//   data: {       // encrypted\n//     keys: {\n//       key: '',\n//       chainId: '0x1',     // Have to look up the 'name' from yakklNetworks and 'key' from process.env\n//       blockchain: 'Mainnet',\n//     },\n//     protocols: [\n//       {type: 'https', url: '{{blockchain}}.infura.io/v3/{{key}}'},\n//       {type: 'wss', url: '{{blockchain}}.infura.io/ws/v3/{{key}}'}\n//     ],\n//   },\n//   version: '', // Travels with the data for upgrades\n// };\n\n// // Possible example of a provider. Will need to modify and enhance\n// export let yakklProviders: YakklProvider [] = [\n//   {\n//     provider: 'Infura',   // If name is 'yakkl' then yakkl cloud is the provider and we're going direct to the given blockchains\n//     blockchain: 'Ethereum',\n//     name: 'Mainnet',\n//     chainId: '0x1',     // Have to look up the 'name' from yakklNetworks and 'key' from process.env\n//     weight: 5,    // Weight 1-5 with 5 being the provider to use the most - this only applies to mainnets. Testnets all have a weight of 0\n//     data: {\n//       keys: {\n//         key: '',\n//         chainId: '0x1',     // Have to look up the 'name' from yakklNetworks and 'key' from process.env\n//         blockchain: 'Mainnet',\n//       },\n//       protocols: [\n//         {type: 'https', url: '{{blockchain}}.infura.io/v3/{{key}}'},\n//         {type: 'wss', url: '{{blockchain}}.infura.io/ws/v3/{{key}}'}\n//         ]\n//       },\n//     version: '', // Travels with the data for upgrades\n//   },\n//   {provider: \"Infura\", blockchain: \"Ethereum\", name: \"Sepolia\", chainId: \"0xaa36a7\", weight: 0, data: { keys: { key: '', chainId: '0x01', blockchain: 'Mainnet'}, protocols: [{type: \"https\", url: \"{{name}}.infura.io/v3/{{key}}\"}, {type: \"wss\", url: \"{{name}}.infura.io/ws/v3/{{key}}\"}]}, version: ''},\n// ];\n\n// Defaults for Ethereum\n// export let yakklNetwork: YakklNetwork = {\n//   name: 'Ethereum',\n//   symbol: 'ETH',\n//   card: 'ethereum-background.png',\n//   icon: '/images/ethereum.svg',\n//   decimals: 18,\n//   types: [\n//     {type: 'mainnet', release: 'Production', name: 'Mainnet', chainId: 1},\n//     {type: 'testnet', release: 'Test', name: 'Sepolia', chainId: 11155111},\n//   ],\n//   explorer: 'https://etherscan.io',\n//   rpcUrls: [],  // These are the provider urls for the given network\n//   version: '', // Travels with the data for upgrades\n// };\n\n// export let yakklNetworks: Network[] = [\n//   {\n//     name: 'Ethereum',\n//     symbol: 'ETH',\n//     card: 'ethereum-background.png',\n//     icon: '/images/ethereum.svg',\n//     decimals: 18,\n//     types: [\n//       {type: 'mainnet', release: 'Production', name: 'Mainnet', chainId: '0x1'},\n//       {type: 'testnet', release: 'Test', name: 'Sepolia', chainId: '0xaa36a7'},\n//     ],\n//     explorer: 'https://etherscan.io',\n//     rpcUrls: [],  // These are the provider urls for the given network\n//     version: '',\n//   },\n//   {\n//     name: 'Polygon',\n//     symbol: 'MATIC',\n//     card: 'polygon-background.png',\n//     icon: '/images/polygon.svg',\n//     decimals: 6, // Not sure if this is correct\n//     types: [\n//       {type: 'mainnet', release: 'Production', name: 'Mainnet', chainId: '0x89'},\n//       {type: 'testnet', release: 'Test', name: 'Mumbai', chainId: '0x13881'},\n//     ],\n//     explorer: 'https://etherscan.io',\n//     rpcUrls: [],  // These are the provider urls for the given network\n//     version: '',\n//   },\n//   {\n//     name: 'Optimism',\n//     symbol: 'OP',\n//     card: 'optimism-background.png',\n//     icon: '/images/optimism.svg',\n//     decimals: 6, // Not sure if this is correct\n//     types: [\n//       {type: 'mainnet', release: 'Production', name: 'Mainnet', chainId: '0xA'},\n//       {type: 'testnet', release: 'Test', name: 'Kovan', chainId: '0x45'},\n//     ],\n//     explorer: 'https://etherscan.io',\n//     rpcUrls: [],  // These are the provider urls for the given network\n//     version: '',\n//   },\n// ];\n\n// export let yakklAssetKey: YakklAssetKey = {\n//   name: 'Ethereum',  // Default\n//   class: 'Token',    // Default\n//   subClass: '',  // Only applies to RWAs\n//   version: '',\n// };\n\n// export let yakklAssetKeys: YakklAssetKey[] = [\n//   {\n//     name: \"Ethereum\",\n//     class: \"Token\",\n//     subClass: \"\",\n//     version: '',\n//   },\n//   {\n//     name: \"Ethereum\",\n//     class: \"NFT\",\n//     subClass: \"\",\n//     version: '',\n//   },\n//   {\n//     name: \"Ethereum\",\n//     class: \"RWA\",\n//     subClass: \"\",\n//     version: '',\n//   },\n//   {\n//     name: \"Polygon\",\n//     class: \"Token\",\n//     subClass: \"\",\n//     version: '',\n//   },\n//   {\n//     name: \"Polygon\",\n//     class: \"NFT\",\n//     subClass: \"\",\n//     version: '',\n//   },\n//   {\n//     name: \"Polygon\",\n//     class: \"RWA\",\n//     subClass: \"\",\n//     version: '',\n//   },\n//   {\n//     name: \"Bitcoin\",\n//     class: \"Token\",\n//     subClass: \"\",\n//     version: '',\n//   },\n//   {\n//     name: \"Optimism\",\n//     class: \"Token\",\n//     subClass: \"\",\n//     version: '',\n//   },\n//   {\n//     name: \"Optimism\",\n//     class: \"NFT\",\n//     subClass: \"\",\n//     version: '',\n//   },\n//   {\n//     name: \"Optimism\",\n//     class: \"RWA\",\n//     subClass: \"\",\n//     version: '',\n//   }\n// ];\n\n// export let yakklAsset: YakklAsset = {\n//   name: 'Ethereum', // This should be unique when combined with 'class'\n//   class: 'Token',   // Asset class such as 'Tokens', 'NFTs', 'RWA', ...\n//   subClass: '',  // Mainly applies to RWA such as deeds, titles, ...\n//   description: 'Ethereum crypto',\n//   status: 'enabled',\n//   card: 'ethereum-background.png',\n//   icon: '/images/ethereum.svg',\n//   symbol: 'ETH',\n//   decimals: 18,\n//   network:   {\n//     name: 'Ethereum',\n//     symbol: 'ETH',\n//     icon: '/images/ethereum.svg',\n//     rpcUrls: [],  // These are the provider urls for the given network\n//     types: [\n//       {type: 'mainnet', release: 'Production', name: 'Mainnet', chainId: '0x1'},\n//       {type: 'testnet', release: 'Test', name: 'Sepolia', chainId: '0xaa36a7'},\n//     ],\n//     explorer: 'https://etherscan.io'\n//   },\n//   version: '',\n// };\n\n// TODO: Need to refactor these to be more intuitive and easier to use!!\n// Examples of assets\n// export let yakklAssets: YakklAsset[] = [\n//   {\n//     name: \"Ethereum\",\n//     class: \"Token\",\n//     subClass: \"\",\n//     description: \"Ethereum crypto\",\n//     status: \"enabled\",\n//     card: \"ethereum-background.png\",\n//     icon: \"/images/ethereum.svg\",\n//     symbol: \"ETH\",\n//     decimals: 18,\n//     network: {\n//       name: \"Ethereum\",\n//       symbol: \"ETH\",\n//       icon: \"/images/ethereum.svg\",\n//       rpcUrls: [],\n//       types: [\n//         {type: \"mainnet\", release: \"Production\", name: \"Mainnet\", chainId: \"0x1\"},\n//         {type: \"testnet\", release: \"Test\", name: \"Sepolia\", chainId: \"0xaa36a7\"}\n//       ],\n//       explorer: \"https://etherscan.io\",\n//     },\n//     version: '',\n//   },\n//   {\n//     name: \"Ethereum\",\n//     class: \"NFT\",\n//     subClass: \"\",\n//     description: \"Ethereum NFT\",\n//     status: \"enabled\",\n//     card: \"ethereum-background.png\",\n//     icon: \"/images/ethereum.svg\",\n//     symbol: \"ETH\",\n//     decimals: 18,\n//     network: {\n//       name: \"Ethereum\",\n//       symbol: \"ETH\",\n//       icon: \"/images/ethereum.svg\",\n//       rpcUrls: [],\n//       types: [\n//         {type: \"mainnet\", release: \"Production\", name: \"Mainnet\", chainId: \"0x1\"},\n//         {type: \"testnet\", release: \"Test\", name: \"Sepolia\", chainId: \"0xaa36a7\"}\n//       ],\n//       explorer: \"https://etherscan.io\",\n//     },\n//     version: '',\n//   },\n//   {\n//     name: \"Ethereum\",\n//     class: \"RWA\",\n//     subClass: \"\",\n//     description: \"Ethereum RWA (Real World Asset)\",\n//     status: \"enabled\",\n//     icon: \"/images/ethereum.svg\",\n//     card: \"ethereum-background.png\",\n//     symbol: \"ETH\",\n//     decimals: 18,\n//     network: {\n//       name: \"Ethereum\",\n//       symbol: \"ETH\",\n//       icon: \"/images/ethereum.svg\",\n//       rpcUrls: [],\n//       types: [\n//         {type: \"mainnet\", release: \"Production\", name: \"Mainnet\", chainId: \"0x1\"},\n//         {type: \"testnet\", release: \"Test\", name: \"Sepolia\", chainId: \"0xaa36a7\"}\n//       ],\n//       explorer: \"https://etherscan.io\",\n//     },\n//     version: '',\n//   },\n// ];\n\n// Premature for this but appears we're heading in this direction on regulations\n// export let yakklKYC: YakklKYC = {\n//   profileType: \"naturalPerson\", // company...\n//   company: {\n//     name: '',\n//     formedDate: '',\n//     type: '',\n//     registeredCountries: [],\n//     registeredRegions: [],\n//   },\n//   naturalPerson: {\n//     sex: '',\n//     dateOfBirth: '',\n//     idPhoto: false,\n//   },\n//   status: '',\n//   statusReason: '',  // if 'failure' then the reason why the kyc process did not pass\n//   email: '',\n//   createDate: '',\n//   updateDate: '',\n//   expireDate: '', // If annual or every 5 years or undefined if n/a\n//   amlCleared: false,\n//   cipCleared: false,\n//   idConfirmed: false,\n//   idDocsVerified: false,\n//   documents: [],  // {id: 'userId', type: 'passport', fileName: '', created: '', expires: '', updated: '', store: ''}\n//   taxId: '',\n//   taxCountry: '',\n//   proofOfAddress: false,\n//   primaryPhone: {\n//     country: '',\n//     number: '',\n//     type: '',\n//     sms: false  // true/false\n//   },\n//   primaryAddress: {\n//     add1: '',\n//     add2: '',\n//     city: '',\n//     region: '',  // State/prov...\n//     country: '',\n//     postal: ''\n//   },\n//   exceptions: []\n// }\n\n/////////////////////////\n// IMPORTANT: EVERYWHERE there is 'id': in the data. Wait to install initial default data UNTIL AFTER the registration so that\n//  we have a valid unique ID\n/////////////////////////\n\n// Encrypted\n// export let profile: Profile = {  // ALL 'data' properties are encrypted. The others are not\n//   id: 0, // Must be unique - used where there is an 'id'\n//   userName: '',  // Must be unique - not encrypted\n//   preferences: yakklPreferences,\n//   data: {\n//     name: {  // TBD - May want to change for institutional version\n//       first: \"Current\",\n//       middle: '',\n//       last: \"User\",\n//       suffix: ''\n//     }, // currently the only one but it can easily be multi-profile\n//     email: '', // added in 0.33.4\n//     registered: yakklRegisteredData,  // This will unlock certain features - This value can be '' or 'Standard', 'Premium', 'Ultra', 'Enterprise'\n//     kyc: yakklKYC, // KYC (institution) - not currently used\n//     digest: '',\n//     pincode: '', // Encrypted pincode\n//     sig: '',\n//     security: yakklSecurity,\n//     value: 0.0,        // This is a bignumber that represents the grand total of all accounts that are flagged to be included in the overall portforlio\n//     accountIndex: 0,\n//     primaryAccounts: [],\n//     importedAccounts: [],  // Independent accounts - These accounts have no relation to any primary or subaccount.\n//     watchList: [], // If you want to see data from any of your other centralized exchanges or something different\n//     meta: {},\n//   },\n//   version: '', // Travels with the data for upgrades\n//   createDate: '',\n//   updateDate: '',\n// };\n\n// export let yakklActivityLog: YakklActivityLog = {\n//   id: 0,  // Profile id\n//   persona: DEFAULT_PERSONA,\n//   txId: '',\n//   txDate: '',\n//   type: 'System', // 'System' (misc data that does not fit the other types), 'Created' (when system was created), 'Updated' (when system was upgraded/updated), 'Changed' (any datastore changes), 'Error', 'Warning', 'Buy', 'Sell', 'Swap', 'Send', 'Received', 'Payment', 'Token' created\n//   transaction: '', // 'Module name' (if 'type' = 'System') otherwise it's the 'txId' number from 'yakklTransactionDetail'\n//   network: '', // which network like Ethereum\n//   blockchain: '',  // 'mainnet'\n//   from: '',\n//   to: '',\n//   meta: {}, // Can be anything. It's an anonymous key/value property (i.e., meta: {'key': value} or meta: {'key': value...'more': value} where 'more' means any number of key/value pairs) For example, it may be related to a given transaction or set of transactions, etc.\n//   version: '',\n// };\n\n// Begin - May remove these since we now pull from the blockchain\n// export let yakklTransaction: YakklTransaction = {\n//   status: 'pending', // 'error', 'pending', 'dropped', 'replaced' or 'Dropped & Replaced', 'mined' - (success, failure/execution reverted)\n//   message: '',  // Only applies to 'error', 'pending', 'dropped'\n//   type: 'send',  // 'receive'\n//   to: '', // Address sent to\n//   toType: 'eoa', //'sc'\n//   toMulti: [], // Multi-sig ??\n//   from: '', // Address received from\n//   fromType: 'eoa', //'sc'\n//   value: '0.0',\n//   netFee: '0.0', // Will be 0.0 on receives\n//   gasLimit: '0.0', // in gwei\n//   baseFee: '0.0', // on send only - what the baseFee was at the time of sending\n//   maxFeePerGas: '0.0', // at time of send\n//   maxPriorityFeePerGas: '0.0', // tip for validators at time of send\n//   initialTimestamp: '', //This only gets updated if the transaction originates from yakkl\n//   timestamp: '', // date or timestamp of transaction\n//   formattedTimestamp: '',\n//   nonce: 0, // nonce used\n//   hash: '',  // Transaction hash\n//   index: -1, // Index in block\n//   blockchain: 'Ethereum',  // Name of network the transaction occurred on\n//   type: 'Mainnet', // Name of the specific network type\n//   chainId: '0x1',\n//   explorer: 'https://etherscan.io',\n//   blockNumber: '', // Block number the transaction is apart of\n//   blockHash: '',\n//   data: '', // See below\n//   details: [], // Raw details from blockchain of transactions, receipts and block\n//   meta: {},\n// }  // This will get populated after after a send or receive\n\n// // We don't currently store this on the device but we do in memory via the store\n// export let yakklTransactionHistory = {\n//   id: 0,\n//   type: 'etherscan',  // This will change based on the provider of the history data\n//   chainId: '',\n//   blockHash: '',\n//   blockNumber: '',\n//   from: '',\n//   gas: '',\n//   gasUsed: '',\n//   hash: '',\n//   nonce: '',\n//   timestamp: '',\n//   formattedTimestamp: '',\n//   to: '',\n//   index: '',\n//   status: '',\n//   value: '',\n//   explorer: '',\n//   contractAddress: '',\n//   functionName: '',\n//   gasPrice: '',\n//   input: '',\n//   isError: '',\n//   methodId: '',\n//   // meta: {},  // Reference where the data came from... ie meta: yakklEtherscanHistory\n// }\n\n// Etherscan Transaction History - may remove this later\n// export let yakklEtherscanHistory = {\n//   contractAddress: '',\n//   functionName: '',\n//   gasPrice: '',\n//   input: '',\n//   isError: '',\n//   methodId: '',\n// }\n// End - May remove these since we now pull from the blockchain\n\n// TODO: Think through Real World Assets on the blockchains! Currentlt 'yakklAssets' is focused on crypto space for currencies, NFTs, other smart contracts. We may simply have to map to a smart contract!!\n\n// Security...\n// 'authCredentials.type = \"PWD\"' is the default. Type can be the following:\n//      PWD - Password - Default but required. If user selects any option then they still must have a valid password since encryption is based on that as part of the keys\n//      MFA - Multi-Function Authentication\n//      PLess - Passwordless\n//      SSO - Single Sign On - Enterprise only\n//      Google - Provider Google\n//      Facebook - Provider Facebook\n//      Twitter - Provider Twitter\n//      Instagram - Provider Instagram\n// 'rotationDate' - The date of next required password change. IMPORTANT - data will be encrypted off of new password\n// 'passKey' - Additional security code (i.e., pin code or phrase)\n// 'passKeyHints' - Array of objects {question: \"\", answer: \"\"}. The user can create their own questions but must have a minimum of 3\n// 'mfaType' - If MFA is used above then the valid type of communication of the secondary authtentication.\n//      SMS - Text message a code\n//      KEY - Key device such as secure key connected via USB (similar to hardware wallets)\n//      APP - Authentication app such as Google Authenticator or Microsoft Authenticator\n\n// 'version' - Current version the user is using\n// 'previousVerion' - The version the user was using before upgrading\n//// 'featureVersion' - 'open' is default representing opensource version and 'advanced' is for advanced paid features\n// 'installDate' - The original date the user installed YAKKL. If they removed it and installed it again later then the later date\n// 'acceptDate' - Date the user clicked on accept for user data cookie like info\n// 'upgradeDate' - Date the user upgraded\n\n// Default - User related data that must be encrypted\n// Password is used as part of the encryption key. The encrypted version is maintained\n// if the user uses the \"backup\" option this can help BUT we may need to maintain a hashed\n// version\n\n// Singles or lists above... (already exported above)\n// profile\n// yakklSettings\n// yakklPreferences\n// yakklSecurity\n\n// yakklCurrentlySelected\n// yakklRegisteredData\n\n// TODO: Think through maybe adding a collection of totals for each asset class (e.g., 'Ethereum', 'Bitcoin', ...)\n// Includes account values, NFT values and more...\n// export let yakklPortfolio = {\n//   id: '',\n//   persona: DEFAULT_PERSONA,\n//   accounts: yakklAccounts,\n//   version: '', // Travels with the data for upgrades\n// }\n","// EthereumBigNumber.ts\nimport { BigNumber, CurrencyCode, type BigNumberish } from './bignumber';\n\nexport class EthereumBigNumber extends BigNumber {\n\t// Instance methods\n\ttoWei(): EthereumBigNumber {\n\t\tlet ethValue: bigint;\n\n\t\tif (\n\t\t\ttypeof this._value === 'number' ||\n\t\t\t(typeof this._value === 'string' && this._value.includes('.'))\n\t\t) {\n\t\t\tconst valueString = this._value.toString();\n\t\t\tconst [integerPart, fractionalPartRaw = ''] = valueString.split('.');\n\t\t\tconst fractionalPart = fractionalPartRaw.padEnd(18, '0').slice(0, 18); // Wei has 18 decimals\n\t\t\tethValue = BigInt(integerPart + fractionalPart);\n\t\t} else {\n\t\t\tethValue = EthereumBigNumber.toBigInt(this._value) ?? BigInt(0);\n\t\t}\n\n\t\treturn new EthereumBigNumber(ethValue);\n\t}\n\n\ttoGwei(): EthereumBigNumber {\n\t\tlet ethValue: bigint;\n\n\t\tif (\n\t\t\ttypeof this._value === 'number' ||\n\t\t\t(typeof this._value === 'string' && this._value.includes('.'))\n\t\t) {\n\t\t\tconst valueString = this._value.toString();\n\t\t\tconst [integerPart, fractionalPartRaw = ''] = valueString.split('.');\n\t\t\tconst fractionalPart = fractionalPartRaw.padEnd(9, '0').slice(0, 9); // Gwei has 9 decimals\n\t\t\tethValue = BigInt(integerPart + fractionalPart);\n\t\t} else {\n\t\t\tethValue = EthereumBigNumber.toBigInt(this._value) ?? BigInt(0);\n\t\t}\n\n\t\treturn new EthereumBigNumber(ethValue);\n\t}\n\n\ttoEther(): EthereumBigNumber {\n\t\tconst weiValue = EthereumBigNumber.toBigInt(this._value) ?? BigInt(0);\n\t\treturn new EthereumBigNumber(weiValue / BigInt('1000000000000000000'));\n\t}\n\n\ttoEtherString(): string {\n\t\tconst weiValue = EthereumBigNumber.toBigInt(this._value) ?? BigInt(0);\n\t\tconst etherValue = weiValue / BigInt('1000000000000000000');\n\t\tconst remainder = weiValue % BigInt('1000000000000000000');\n\n\t\t// Construct the fractional part as a string\n\t\tconst fractionalPart = remainder.toString().padStart(18, '0').slice(0, 18);\n\n\t\t// Combine the integer part and fractional part\n\t\tconst etherString = `${etherValue}.${fractionalPart}`;\n\t\treturn etherString;\n\t}\n\n\tstatic from(value: BigNumberish): EthereumBigNumber {\n\t\tif (typeof value === 'string' && /^0x[0-9a-fA-F]+$/.test(value)) {\n\t\t\treturn new EthereumBigNumber(BigInt(value));\n\t\t}\n\t\tif (value && typeof value === 'object' && '_hex' in value && '_isBigNumber' in value) {\n\t\t\treturn new EthereumBigNumber(BigInt(value._hex));\n\t\t}\n\t\treturn new EthereumBigNumber(BigNumber.toBigInt(value));\n\t}\n\n\tstatic fromWei(value: BigNumberish): EthereumBigNumber {\n\t\tconst weiValue = EthereumBigNumber.from(value);\n\t\tconst ethValue = weiValue.div(BigInt('1000000000000000000'));\n\t\treturn new EthereumBigNumber(ethValue.toString());\n\t}\n\n\tstatic fromGwei(value: BigNumberish): EthereumBigNumber {\n\t\tconst gweiValue = EthereumBigNumber.from(value);\n\t\tconst ethValue = gweiValue.div(BigInt('1000000000'));\n\t\treturn new EthereumBigNumber(ethValue.toString());\n\t}\n\n\t// Method to convert ether (in decimal, int) to wei\n\tstatic fromEther(value: BigNumberish): EthereumBigNumber {\n\t\tif (value === null || value === undefined) {\n\t\t\tthrow new Error('Value cannot be null or undefined');\n\t\t}\n\n\t\tlet etherString: string;\n\n\t\tif (typeof value === 'number' || typeof value === 'string') {\n\t\t\tetherString = value.toString();\n\t\t} else if (typeof value === 'bigint') {\n\t\t\tetherString = value.toString();\n\t\t} else if (value instanceof BigNumber) {\n\t\t\tetherString = value.toString();\n\t\t} else if (typeof value === 'object' && '_hex' in value && '_isBigNumber' in value) {\n\t\t\tetherString = BigInt(value._hex).toString();\n\t\t} else {\n\t\t\tthrow new Error('Unsupported type for BigNumberish value');\n\t\t}\n\n\t\t// Ensure the string representation has a decimal point\n\t\tif (!etherString.includes('.')) {\n\t\t\tetherString += '.0';\n\t\t}\n\n\t\t// Split the string into the integer and fractional parts\n\t\tconst [integerPart, fractionalPart] = etherString.split('.');\n\t\t// Normalize the fractional part to have exactly 18 digits, representing wei's precision\n\t\tconst fractionalPartPadded = (fractionalPart + '0'.repeat(18)).slice(0, 18);\n\t\t// Combine and convert to BigInt\n\t\tconst weiValue = BigInt(integerPart + fractionalPartPadded);\n\n\t\treturn new EthereumBigNumber(weiValue);\n\t}\n\n\tstatic toWei(value: BigNumberish): EthereumBigNumber {\n\t\tlet ethValue: bigint;\n\n\t\tif (typeof value === 'number' || (typeof value === 'string' && value.includes('.'))) {\n\t\t\tconst valueString = value.toString();\n\t\t\tconst [integerPart, fractionalPartRaw = ''] = valueString.split('.');\n\t\t\tconst fractionalPart = fractionalPartRaw.padEnd(18, '0').slice(0, 18); // Wei has 18 decimals\n\t\t\tethValue = BigInt(integerPart + fractionalPart);\n\t\t} else {\n\t\t\tethValue = EthereumBigNumber.toBigInt(value) ?? BigInt(0);\n\t\t}\n\n\t\treturn new EthereumBigNumber(ethValue);\n\t}\n\n\tstatic toGwei(value: BigNumberish): EthereumBigNumber {\n\t\t// Convert the value to a BigInt\n\t\tlet ethValue: bigint;\n\n\t\t// If the value is a number or a string that represents a float, handle it\n\t\tif (typeof value === 'number' || (typeof value === 'string' && value.includes('.'))) {\n\t\t\t// Convert the value to a string if it is a number\n\t\t\tconst valueString = value.toString();\n\n\t\t\t// Split the value into integer and fractional parts\n\t\t\tconst [integerPart, fractionalPartRaw = ''] = valueString.split('.');\n\n\t\t\t// Truncate or pad the fractional part to 9 digits (to convert Gwei to Wei)\n\t\t\tconst fractionalPart = fractionalPartRaw.padEnd(9, '0').slice(0, 9);\n\n\t\t\t// Combine the parts and convert to BigInt\n\t\t\tethValue = BigInt(integerPart + fractionalPart);\n\t\t} else {\n\t\t\t// Convert directly to BigInt if no fractional part\n\t\t\tethValue = EthereumBigNumber.toBigInt(value) ?? BigInt(0);\n\t\t}\n\n\t\t// Return as a new BigNumber instance\n\t\treturn new EthereumBigNumber(ethValue);\n\t}\n\n\tstatic toEther(value: BigNumberish): EthereumBigNumber {\n\t\tconst weiValue = EthereumBigNumber.from(value).toBigInt() ?? BigInt(0);\n\t\treturn new EthereumBigNumber(weiValue / BigInt('1000000000000000000'));\n\t}\n\n\tstatic toEtherString(value: BigNumberish): string {\n\t\tconst weiValue = EthereumBigNumber.from(value).toBigInt() ?? BigInt(0);\n\t\tconst etherValue = weiValue / BigInt('1000000000000000000');\n\t\tconst remainder = weiValue % BigInt('1000000000000000000');\n\n\t\t// Construct the fractional part as a string\n\t\tconst fractionalPart = remainder.toString().padStart(18, '0').slice(0, 18);\n\n\t\t// Combine the integer part and fractional part\n\t\tconst etherString = `${etherValue}.${fractionalPart}`;\n\t\treturn etherString;\n\t}\n\n\tstatic toFiat(value: BigNumberish, price: number): number {\n\t\tconst etherValue = parseFloat(EthereumBigNumber.toEtherString(value));\n\t\tif (isNaN(etherValue)) {\n\t\t\tthrow new Error('Invalid BigNumberish value');\n\t\t}\n\t\treturn etherValue * price;\n\t}\n\n\tstatic toFormattedFiat(\n\t\tvalue: BigNumberish,\n\t\tprice: number,\n\t\tcurrencyCode: CurrencyCode,\n\t\tlocale: string = ''\n\t): string {\n\t\tconst fiatValue = EthereumBigNumber.toFiat(value, price);\n\t\tconst formatter = new Intl.NumberFormat(locale || undefined, {\n\t\t\tstyle: 'currency',\n\t\t\tcurrency: currencyCode\n\t\t});\n\t\treturn formatter.format(fiatValue);\n\t}\n\n\tstatic toHex(value: BigNumberish): string {\n\t\tconst bigintValue = BigNumber.toBigInt(value);\n\t\tif (bigintValue === null) {\n\t\t\tthrow new Error('Invalid BigNumberish value');\n\t\t}\n\t\tlet hexString = bigintValue.toString(16);\n\t\tif (hexString.length % 2 !== 0) {\n\t\t\thexString = '0' + hexString;\n\t\t}\n\t\treturn '0x' + hexString;\n\t}\n}\n\n// Example usage\n// Using instance methods\n// const ethValueInstance = new EthereumBigNumber(1);\n// console.log('To Wei (Instance):', ethValueInstance.toWei().toBigInt());\n// console.log('To Gwei (Instance):', ethValueInstance.toGwei().toBigInt());\n\n// Using static methods\n// console.log('To Wei (Static):', EthereumBigNumber.toWei(1n).toBigInt());\n// console.log('To Gwei (Static):', EthereumBigNumber.toGwei(1n).toBigInt());\n// console.log('From (Static):', EthereumBigNumber.from(20n).toBigInt());\n\n//----------------------------\n// import { BigNumber, CurrencyCode, type BigNumberish } from \"./bignumber\";\n\n// export class EthereumBigNumber extends BigNumber {\n// Instance method to convert the value to Wei (for Ethereum)\n//   toWei(): BigNumber {\n//     return BigNumber.mul(this._value, BigInt(\"1000000000000000000\"));\n//   }\n\n// Instance method to convert the value to Gwei (for Ethereum)\n//   toGwei(): BigNumber {\n//     return BigNumber.mul(this._value, BigInt(\"1000000000\"));\n//   }\n\n// Instance method to convert the value to Ether (from Wei for Ethereum)\n//   toEther(): BigNumber {\n//     return BigNumber.div(this._value, BigInt(\"1000000000000000000\"));\n//   }\n\n// Instance method to convert from Wei to the current unit (Ethereum)\n//   fromWei(value: BigNumberish): EthereumBigNumber {\n//     const weiValue = BigNumber.from(value);\n//     const ethValue = weiValue.div(BigInt(\"1000000000000000000\"));\n//     return new EthereumBigNumber(ethValue.toString());\n//   }\n\n// Instance method to convert from Gwei to the current unit (Ethereum)\n//   fromGwei(value: BigNumberish): EthereumBigNumber {\n//     const gweiValue = BigNumber.from(value);\n//     const ethValue = gweiValue.div(BigInt(\"1000000000\"));\n//     return new EthereumBigNumber(ethValue.toString());\n//   }\n\n// Instance method to convert from Ether to the current unit (Ethereum)\n//   fromEther(value: BigNumberish): EthereumBigNumber {\n//     return new EthereumBigNumber(value);\n//   }\n\n// Instance method to convert the current value to fiat\n//   toFiat(price: number): number {\n//     const etherValue = this.toEther().toNumber();\n//     if (etherValue === null) {\n//       throw new Error(\"Invalid BigNumberish value\");\n//     }\n//     return etherValue * price;\n//   }\n\n// Instance method to convert the current value to formatted fiat\n//   toFormattedFiat(price: number, currencyCode: CurrencyCode, locale: string = \"\"): string {\n//     const fiatValue = this.toFiat(price);\n//     const formatter = new Intl.NumberFormat(locale || undefined, {\n//       style: 'currency',\n//       currency: currencyCode\n//     });\n//     return formatter.format(fiatValue);\n//   }\n\n// Instance method to convert the value to a hex string (Ethereum specific) of 0x0 for single digit values\n//   toHex(): string {\n//     const bigintValue = this.toBigInt();\n//     if (bigintValue === null) {\n//       return '';\n//     }\n//     let hexString = bigintValue.toString(16);\n//     if (hexString.length % 2 !== 0) {\n//       hexString = '0' + hexString;\n//     }\n//     return '0x' + hexString;\n//   }\n// }\n\n// Examples of use...\n// Create an EthereumBigNumber instance\n// const ethValue = new EthereumBigNumber(1);\n\n// Convert to Wei\n// const weiValue = ethValue.toWei();\n// console.log('To Wei:', weiValue.toBigInt()); // Output: 1000000000000000000n\n\n// Convert to Gwei\n// const gweiValue = ethValue.toGwei();\n// console.log('To Gwei:', gweiValue.toBigInt()); // Output: 1000000000n\n\n// Convert to Ether\n// const etherValue = ethValue.toEther();\n// console.log('To Ether:', etherValue.toBigInt()); // Output: 1n\n\n// Convert from Wei\n// const fromWeiValue = ethValue.fromWei('1000000000000000000');\n// console.log('From Wei:', fromWeiValue.toBigInt()); // Output: 1n\n\n// Convert from Gwei\n// const fromGweiValue = ethValue.fromGwei('1000000000');\n// console.log('From Gwei:', fromGweiValue.toBigInt()); // Output: 1n\n\n// Convert from Ether\n// const fromEtherValue = ethValue.fromEther(1);\n// console.log('From Ether:', fromEtherValue.toBigInt()); // Output: 1n\n\n// Convert to fiat using the EthereumBigNumber class\n// const ethFiatValue = ethValue.toFiat(2000); // Assuming price is 2000 USD per Ether\n// console.log('Ether Fiat Value:', ethFiatValue); // Output: 2000\n\n// Convert to formatted fiat using the EthereumBigNumber class\n// const ethFormattedFiatValue = ethValue.toFormattedFiat(2000, CurrencyCode.USD, 'en-US');\n// console.log('Ether Formatted Fiat Value:', ethFormattedFiatValue); // Output: $2,000.00\n","import { ethers as ethersv6 } from 'ethers-v6';\nimport type {\n\tEVMTransactionRequest,\n\tTransactionResponse,\n\tTransactionReceipt,\n\tLog,\n\tBigNumberish,\n\tTransactionRequest,\n\tAccessList\n} from '$lib/common';\nimport { log } from '../Logger';\n\nexport class EthersConverter {\n\tstatic toEthersHex(value: BigNumberish | null | undefined): string | null | undefined {\n\t\tif (value === null || value === undefined) return null;\n\t\tif (typeof value === 'string' && value.startsWith('0x')) return value;\n\t\treturn '0x' + BigInt(value.toString()).toString(16);\n\t}\n\n\tstatic transactionToEthersTransaction(\n\t\ttransaction: EVMTransactionRequest\n\t): ethersv6.TransactionRequest {\n\t\treturn {\n\t\t\tto: transaction.to ?? undefined,\n\t\t\tfrom: transaction.from ?? undefined,\n\t\t\tnonce: transaction.nonce === -1 ? undefined : transaction.nonce,\n\t\t\tgasLimit: this.toEthersHex(transaction.gasLimit),\n\t\t\tgasPrice: this.toEthersHex(transaction.gasPrice),\n\t\t\tmaxPriorityFeePerGas: this.toEthersHex(transaction.maxPriorityFeePerGas),\n\t\t\tmaxFeePerGas: this.toEthersHex(transaction.maxFeePerGas),\n\t\t\tdata: transaction.data?.toString() ?? undefined,\n\t\t\tvalue: this.toEthersHex(transaction.quantity),\n\t\t\tchainId: this.toEthersHex(transaction.chainId) ?? undefined,\n\t\t\taccessList: transaction.accessList ?? undefined,\n\t\t\tcustomData: transaction.customData,\n\t\t\ttype: transaction.type\n\t\t};\n\t}\n\n\tstatic async ethersTransactionResponseToTransactionResponse(\n\t\ttx: ethersv6.TransactionResponse\n\t): Promise<TransactionResponse> {\n\t\treturn {\n\t\t\thash: tx.hash,\n\t\t\tto: tx.to ?? '',\n\t\t\tfrom: tx.from,\n\t\t\tnonce: tx.nonce,\n\t\t\tgasLimit: tx.gasLimit,\n\t\t\tgasPrice: tx.gasPrice,\n\t\t\tdata: tx.data,\n\t\t\tquantity: tx.value,\n\t\t\tchainId: tx.chainId,\n\t\t\tblockNumber: tx.blockNumber ?? undefined,\n\t\t\tblockHash: tx.blockHash ?? undefined,\n\t\t\ttimestamp: new Date().getTime(),\n\t\t\tconfirmations: await tx.confirmations(),\n\t\t\ttype: tx.type ?? undefined,\n\t\t\taccessList: tx.accessList ?? undefined,\n\t\t\tmaxPriorityFeePerGas: tx.maxPriorityFeePerGas,\n\t\t\tmaxFeePerGas: tx.maxFeePerGas,\n\t\t\twait: async (confirmations?: number): Promise<TransactionReceipt> => {\n\t\t\t\tconst receipt = await tx.wait(confirmations);\n\t\t\t\tif (!receipt) {\n\t\t\t\t\tthrow new Error('Transaction receipt is null');\n\t\t\t\t}\n\t\t\t\treturn this.ethersTransactionReceiptToTransactionReceipt(receipt);\n\t\t\t}\n\t\t};\n\t}\n\n\tstatic async ethersTransactionReceiptToTransactionReceipt(\n\t\treceipt: ethersv6.TransactionReceipt\n\t): Promise<TransactionReceipt> {\n\t\treturn {\n\t\t\tto: receipt.to ?? '',\n\t\t\tfrom: receipt.from,\n\t\t\tcontractAddress: receipt.contractAddress ?? undefined,\n\t\t\ttransactionIndex: receipt.index,\n\t\t\troot: receipt.root ?? undefined,\n\t\t\tgasUsed: receipt.gasUsed,\n\t\t\tlogsBloom: receipt.logsBloom,\n\t\t\tblockHash: receipt.blockHash,\n\t\t\ttransactionHash: receipt.hash,\n\t\t\tlogs: receipt.logs.map(this.ethersLogToLog),\n\t\t\tblockNumber: receipt.blockNumber,\n\t\t\tconfirmations: await receipt.confirmations(),\n\t\t\tcumulativeGasUsed: receipt.cumulativeGasUsed,\n\t\t\teffectiveGasPrice: receipt.gasPrice ?? undefined,\n\t\t\tbyzantium: true,\n\t\t\ttype: receipt.type,\n\t\t\tstatus: receipt.status !== null ? receipt.status : undefined\n\t\t};\n\t}\n\n\tstatic ethersLogToLog(log: ethersv6.Log): Log {\n\t\treturn {\n\t\t\tblockNumber: log.blockNumber,\n\t\t\tblockHash: log.blockHash,\n\t\t\ttransactionIndex: log.transactionIndex,\n\t\t\tremoved: log.removed,\n\t\t\taddress: log.address,\n\t\t\tdata: log.data,\n\t\t\ttopics: [...log.topics],\n\t\t\ttransactionHash: log.transactionHash,\n\t\t\tlogIndex: log.index\n\t\t};\n\t}\n\n\tstatic ethersTransactionRequestToTransactionRequest(\n\t\ttx: ethersv6.TransactionRequest\n\t): TransactionRequest | null {\n\t\ttry {\n\t\t\tif (!tx) return null;\n\t\t\treturn {\n\t\t\t\tto: tx.to as string,\n\t\t\t\tfrom: tx.from as string,\n\t\t\t\tnonce: tx.nonce as number,\n\t\t\t\tgasLimit: tx.gasLimit ? BigInt(tx.gasLimit.toString()) : undefined,\n\t\t\t\tgasPrice: tx.gasPrice ? BigInt(tx.gasPrice.toString()) : undefined,\n\t\t\t\tmaxPriorityFeePerGas: tx.maxPriorityFeePerGas\n\t\t\t\t\t? BigInt(tx.maxPriorityFeePerGas.toString())\n\t\t\t\t\t: undefined,\n\t\t\t\tmaxFeePerGas: tx.maxFeePerGas ? BigInt(tx.maxFeePerGas.toString()) : undefined,\n\t\t\t\tdata: tx.data as string,\n\t\t\t\tquantity: tx.value ? BigInt(tx.value.toString()) : null,\n\t\t\t\tchainId: tx.chainId as number,\n\t\t\t\taccessList: this.convertAccessList(tx.accessList),\n\t\t\t\tcustomData: tx.customData,\n\t\t\t\ttype: tx.type\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlog.error(\n\t\t\t\t'Error converting ethers transaction request to transaction request:',\n\t\t\t\tfalse,\n\t\t\t\terror\n\t\t\t);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate static convertAccessList(\n\t\taccessList: ethersv6.AccessListish | null | undefined\n\t): AccessList | undefined {\n\t\tif (!accessList) return undefined;\n\n\t\tif (Array.isArray(accessList)) {\n\t\t\treturn accessList.map((item) => {\n\t\t\t\tif (Array.isArray(item)) {\n\t\t\t\t\t// Handle [address, storageKeys[]] format\n\t\t\t\t\treturn {\n\t\t\t\t\t\taddress: item[0],\n\t\t\t\t\t\tstorageKeys: item[1]\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\t// Handle { address, storageKeys } format\n\t\t\t\t\treturn {\n\t\t\t\t\t\taddress: item.address,\n\t\t\t\t\t\tstorageKeys: item.storageKeys\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Handle { address: storageKeys[] } format\n\t\treturn Object.entries(accessList).map(([address, storageKeys]) => ({\n\t\t\taddress,\n\t\t\tstorageKeys\n\t\t}));\n\t}\n}\n\n// Example usage:\n// import { EthersConverter } from './EthersConverter';\n\n// // In EthereumSigner class\n// async signTransaction(transaction: EVMTransactionRequest): Promise<string> {\n//   const ethersTx = EthersConverter.transactionToEthersTransaction(transaction);\n//   return await this.wallet.signTransaction(ethersTx);\n// }\n\n// // In EthereumProvider class\n// async sendTransaction(transaction: TransactionRequest): Promise<TransactionResponse> {\n//   const ethersTx = EthersConverter.transactionToEthersTransaction(transaction);\n//   const txResponse = await this.provider.sendTransaction(ethersTx);\n//   return EthersConverter.ethersTransactionResponseToTransactionResponse(txResponse);\n// }\n","// FeeManager.ts\nimport { BigNumber } from '$lib/common/bignumber';\nimport type {\n\tFeeManager,\n\tGasProvider,\n\tGasEstimate,\n\tHistoricalGasData,\n\tGasPrediction,\n\tFeeEstimate\n} from '$lib/common/gas-types';\nimport type { TransactionRequest } from '$lib/common/interfaces';\n\nexport class BaseFeeManager implements FeeManager {\n\tprivate providers: Map<string, GasProvider>;\n\tprivate initializationPromise: Promise<void>;\n\n\tconstructor() {\n\t\tthis.providers = new Map();\n\t\tthis.initializationPromise = Promise.resolve();\n\t}\n\n\tasync addProvider(providerPromise: GasProvider | Promise<GasProvider>): Promise<void> {\n\t\tconst provider = await providerPromise;\n\t\tthis.providers.set(provider.getName(), provider);\n\t}\n\n\tremoveProvider(providerName: string): void {\n\t\tthis.providers.delete(providerName);\n\t}\n\n\tgetProviders(): string[] {\n\t\treturn Array.from(this.providers.keys());\n\t}\n\n\tasync getGasEstimate(transaction: TransactionRequest): Promise<GasEstimate> {\n\t\tawait this.initializationPromise;\n\t\tif (this.providers.size === 0) {\n\t\t\tthrow new Error('No gas providers available');\n\t\t}\n\n\t\tconst estimates: GasEstimate[] = await Promise.all(\n\t\t\tArray.from(this.providers.values()).map(async (provider): Promise<GasEstimate | null> => {\n\t\t\t\treturn provider.getGasEstimate(transaction).catch((error: unknown): GasEstimate | null => {\n\t\t\t\t\tconsole.log(`Failed to get gas estimate from ${provider.getName()}:`, false, error);\n\t\t\t\t\treturn null; // Explicitly return `null` for failed estimates\n\t\t\t\t});\n\t\t\t})\n\t\t).then((estimates: (GasEstimate | null)[]): GasEstimate[] => {\n\t\t\treturn estimates.filter((estimate): estimate is GasEstimate => estimate !== null);\n\t\t});\n\n\t\tconst gasLimits = estimates.map((e) => BigNumber.from(e.gasLimit)).sort((a, b) => a.compare(b));\n\t\tconst baseFees = estimates\n\t\t\t.map((e) => BigNumber.from(e.feeEstimate.baseFee))\n\t\t\t.sort((a, b) => a.compare(b));\n\t\tconst priorityFees = estimates\n\t\t\t.map((e) => BigNumber.from(e.feeEstimate.priorityFee))\n\t\t\t.sort((a, b) => a.compare(b));\n\n\t\tconst medianGasLimit = gasLimits[Math.floor(gasLimits.length / 2)];\n\t\tconst medianBaseFee = baseFees[Math.floor(baseFees.length / 2)];\n\t\tconst medianPriorityFee = priorityFees[Math.floor(priorityFees.length / 2)];\n\n\t\tconst feeEstimate: FeeEstimate = {\n\t\t\tbaseFee: medianBaseFee.toString(),\n\t\t\tpriorityFee: medianPriorityFee.toString(),\n\t\t\ttotalFee: medianBaseFee.add(medianPriorityFee).toString()\n\t\t};\n\n\t\treturn {\n\t\t\tgasLimit: medianGasLimit.toString(),\n\t\t\tfeeEstimate: feeEstimate\n\t\t};\n\t}\n\n\tasync getHistoricalGasData(duration: number): Promise<HistoricalGasData[]> {\n\t\tif (this.providers.size === 0) {\n\t\t\tthrow new Error('No gas providers available');\n\t\t}\n\n\t\tconst allHistoricalData = await Promise.all(\n\t\t\tArray.from(this.providers.values()).map((provider) => provider.getHistoricalGasData(duration))\n\t\t);\n\n\t\tconst aggregatedData: Map<number, HistoricalGasData & { count: number }> = new Map();\n\n\t\tallHistoricalData.flat().forEach((data) => {\n\t\t\tif (!aggregatedData.has(data.timestamp)) {\n\t\t\t\taggregatedData.set(data.timestamp, { ...data, count: 1 });\n\t\t\t} else {\n\t\t\t\tconst existing = aggregatedData.get(data.timestamp)!;\n\t\t\t\texisting.baseFee = BigNumber.from(existing.baseFee)\n\t\t\t\t\t.add(BigNumber.from(data.baseFee))\n\t\t\t\t\t.toString();\n\t\t\t\texisting.priorityFee = BigNumber.from(existing.priorityFee)\n\t\t\t\t\t.add(BigNumber.from(data.priorityFee))\n\t\t\t\t\t.toString();\n\t\t\t\texisting.count++;\n\t\t\t}\n\t\t});\n\n\t\treturn Array.from(aggregatedData.values()).map((data) => ({\n\t\t\ttimestamp: data.timestamp,\n\t\t\tbaseFee: BigNumber.from(data.baseFee).div(BigNumber.from(data.count)).toString(),\n\t\t\tpriorityFee: BigNumber.from(data.priorityFee).div(BigNumber.from(data.count)).toString()\n\t\t}));\n\t}\n\n\tasync predictFutureFees(duration: number): Promise<GasPrediction[]> {\n\t\tif (this.providers.size === 0) {\n\t\t\tthrow new Error('No gas providers available');\n\t\t}\n\n\t\tconst allPredictions = await Promise.all(\n\t\t\tArray.from(this.providers.values()).map((provider) => provider.predictFutureFees(duration))\n\t\t);\n\n\t\tconst aggregatedPredictions: Map<number, GasPrediction & { count: number }> = new Map();\n\n\t\tallPredictions.flat().forEach((prediction) => {\n\t\t\tif (!aggregatedPredictions.has(prediction.timestamp)) {\n\t\t\t\taggregatedPredictions.set(prediction.timestamp, { ...prediction, count: 1 });\n\t\t\t} else {\n\t\t\t\tconst existing = aggregatedPredictions.get(prediction.timestamp)!;\n\t\t\t\texisting.estimatedBaseFee = BigNumber.from(existing.estimatedBaseFee)\n\t\t\t\t\t.add(BigNumber.from(prediction.estimatedBaseFee))\n\t\t\t\t\t.toString();\n\t\t\t\texisting.estimatedPriorityFee = BigNumber.from(existing.estimatedPriorityFee)\n\t\t\t\t\t.add(BigNumber.from(prediction.estimatedPriorityFee))\n\t\t\t\t\t.toString();\n\t\t\t\texisting.count++;\n\t\t\t}\n\t\t});\n\n\t\treturn Array.from(aggregatedPredictions.values()).map((prediction) => ({\n\t\t\ttimestamp: prediction.timestamp,\n\t\t\testimatedBaseFee: BigNumber.from(prediction.estimatedBaseFee)\n\t\t\t\t.div(BigNumber.from(prediction.count))\n\t\t\t\t.toString(),\n\t\t\testimatedPriorityFee: BigNumber.from(prediction.estimatedPriorityFee)\n\t\t\t\t.div(BigNumber.from(prediction.count))\n\t\t\t\t.toString()\n\t\t}));\n\t}\n\n\tsetPriorityOrder(providerNames: string[]): void {\n\t\tconst orderedProviders = new Map<string, GasProvider>();\n\t\tproviderNames.forEach((name) => {\n\t\t\tif (this.providers.has(name)) {\n\t\t\t\torderedProviders.set(name, this.providers.get(name)!);\n\t\t\t}\n\t\t});\n\t\tthis.providers = orderedProviders;\n\t}\n\n\tsetDefaultProvider(providerName: string): void {\n\t\tif (this.providers.has(providerName)) {\n\t\t\tconst defaultProvider = this.providers.get(providerName)!;\n\t\t\tthis.providers.delete(providerName);\n\t\t\tthis.providers = new Map([[providerName, defaultProvider], ...this.providers]);\n\t\t}\n\t}\n}\n","// lib/common/types/gas-types.ts\nimport type { BigNumberish } from './bignumber';\nimport type { TransactionRequest } from './interfaces';\n\nexport enum TransactionSpeed {\n\tSLOW = 'SLOW',\n\tNORMAL = 'NORMAL',\n\tFAST = 'FAST'\n}\n\nexport interface GasFeeOptions {\n\tspeed?: TransactionSpeed;\n\tcustomPriorityFee?: bigint;\n\tcustomMaxFee?: bigint;\n}\n\nexport interface FeeEstimate {\n\tbaseFee: BigNumberish;\n\tpriorityFee: BigNumberish;\n\ttotalFee: BigNumberish;\n\testimatedCostEth?: string;\n\testimatedCostUsd?: string;\n}\n\nexport interface GasEstimate {\n\tgasLimit: BigNumberish;\n\tfeeEstimate: FeeEstimate;\n}\n\nexport interface GasFeeEstimate {\n\tmaxPriorityFeePerGas: bigint;\n\tmaxFeePerGas: bigint;\n\testimatedCostWei: bigint;\n\testimatedCostEth: string;\n\testimatedCostUsd: string;\n}\n\nexport interface HistoricalGasData {\n\ttimestamp: number;\n\tbaseFee: BigNumberish;\n\tpriorityFee: BigNumberish;\n}\n\nexport interface GasPrediction {\n\ttimestamp: number;\n\testimatedBaseFee: BigNumberish;\n\testimatedPriorityFee: BigNumberish;\n}\n\nexport interface GasProvider {\n\tgetName(): string;\n\tgetGasEstimate(transaction: TransactionRequest): Promise<GasEstimate>;\n\tgetHistoricalGasData(duration: number): Promise<HistoricalGasData[]>;\n\tpredictFutureFees(duration: number): Promise<GasPrediction[]>;\n\tgetEOATransferGasEstimate(\n\t\tto: string,\n\t\tvalue: bigint,\n\t\toptions?: GasFeeOptions\n\t): Promise<GasEstimate>;\n}\n\nexport interface FeeManager {\n\tgetGasEstimate(transaction: TransactionRequest): Promise<GasEstimate>;\n\tgetHistoricalGasData(duration: number): Promise<HistoricalGasData[]>;\n\tpredictFutureFees(duration: number): Promise<GasPrediction[]>;\n\taddProvider(provider: GasProvider | Promise<GasProvider>): Promise<void>;\n\tremoveProvider(providerName: string): void;\n\tgetProviders(): string[]; // Add this method\n\tsetPriorityOrder(providerNames: string[]): void;\n\tsetDefaultProvider(providerName: string): void;\n}\n\n// These are fallback values for EOA transactions\nexport const EOA_FALLBACK_GAS = {\n\tLIMITS: {\n\t\tBASE: 21000n // Standard ETH transfer always costs 21000 gas units\n\t},\n\tGWEI: {\n\t\tSLOW: {\n\t\t\tPRIORITY_FEE: 1n, // 1 gwei\n\t\t\tMAX_FEE: 35n // 35 gwei\n\t\t},\n\t\tNORMAL: {\n\t\t\tPRIORITY_FEE: 2n, // 2 gwei\n\t\t\tMAX_FEE: 50n // 50 gwei\n\t\t},\n\t\tFAST: {\n\t\t\tPRIORITY_FEE: 3n, // 3 gwei\n\t\t\tMAX_FEE: 70n // 70 gwei\n\t\t}\n\t}\n};\n","import type { Provider } from './Provider';\n\n// lib/analytics/AnalyticsBase.ts\nexport enum Web3Provider {\n\tALCHEMY = 'alchemy',\n\tINFURA = 'infura',\n\tCLOUDFLARE = 'cloudflare',\n\tQUICKNODE = 'quicknode',\n\tCUSTOM = 'custom'\n}\n\nexport interface BlockchainNetworkInfo {\n\tprovider: Web3Provider;\n\tchainId: number;\n\tnetworkName: string;\n\trpcLatency?: number; // Response time from RPC calls\n\tblockNumber?: number; // Current block number\n\tisSyncing?: boolean; // Network sync status\n\tpeers?: number; // Number of peers (if available)\n\tproviderUrl?: string; // RPC endpoint (masked for security)\n}\n\nexport interface GasAnalytics {\n\ttimestamp: number;\n\testimateType: 'normal' | 'fallback' | 'optimized' | 'historical' | 'prediction';\n\tgasLimit: string;\n\tpriorityFee: string;\n\tmaxFee: string;\n\tbaseFee?: string;\n\tsuccess: boolean;\n\tnetworkInfo: BlockchainNetworkInfo;\n\terrorMessage?: string;\n\tmethodName?: string; // Which method was called\n\tfallbackReason?: string; // Why fallback was used\n}\n\nexport interface SwapAnalytics extends GasAnalytics {\n\ttokenInSymbol: string;\n\ttokenOutSymbol: string;\n\tamount: string;\n\tisMultiHop: boolean;\n\tswapType: 'exactIn' | 'exactOut';\n\tdexUsed: string; // e.g., 'Uniswap V3'\n\trouteHops?: number;\n}\n\nexport abstract class AnalyticsBase {\n\tnetworkInfo: BlockchainNetworkInfo;\n\tprovider: Provider;\n\n\tconstructor(\n\t\tprovider: Provider,\n\t\tweb3Provider: Web3Provider,\n\t\tchainId: number,\n\t\tnetworkName: string\n\t) {\n\t\tthis.provider = provider;\n\t\tthis.networkInfo = {\n\t\t\tprovider: web3Provider,\n\t\t\tchainId,\n\t\t\tnetworkName\n\t\t};\n\t}\n\n\tprotected abstract initializeNetworkInfo(): Promise<void>;\n\tabstract trackGasEstimate(data: GasAnalytics): void;\n\tabstract trackSwapEstimate(data: SwapAnalytics): void;\n\tabstract getAnalyticsSummary(): Promise<any>;\n}\n","// lib/analytics/EthereumAnalytics.ts\nimport {\n\tAnalyticsBase,\n\ttype GasAnalytics,\n\ttype SwapAnalytics,\n\ttype BlockchainNetworkInfo,\n\tWeb3Provider\n} from '$managers/AnalyticsBase';\nimport { log } from '$lib/common/logger-wrapper';\nimport type { Provider } from '$managers/Provider';\nimport { ethers as ethersv6 } from 'ethers-v6';\n\ninterface EstimateStats {\n\ttotal: number;\n\tsuccessful: number;\n\tfallbackUsed: number;\n\taverageGasPrice: bigint;\n\taverageLatency: number;\n\tcommonErrors: Map<string, number>;\n\tmethodUsage: Map<string, number>;\n\tlastBlockNumber: number;\n\ttimeWindow: {\n\t\tstart: number;\n\t\tend: number;\n\t};\n}\n\ninterface ProviderStats {\n\ttotalCalls: number;\n\tfailedCalls: number;\n\taverageLatency: number;\n\tlastError?: string;\n\tlastErrorTime?: number;\n}\n\nexport class EthereumAnalytics extends AnalyticsBase {\n\tprivate gasEstimates: GasAnalytics[] = [];\n\tprivate swapEstimates: SwapAnalytics[] = [];\n\tprivate readonly MAX_STORED_ENTRIES = 1000;\n\tprivate providerStats: Map<string, ProviderStats> = new Map();\n\tprivate lastNetworkCheck: number = 0;\n\tprivate readonly NETWORK_CHECK_INTERVAL = 60000;\n\n\tconstructor(\n\t\tprovider: Provider,\n\t\tweb3Provider: Web3Provider,\n\t\tchainId: number,\n\t\tnetworkName: string\n\t) {\n\t\tsuper(provider, web3Provider, chainId, networkName);\n\t\tthis.initializeProviderStats();\n\t}\n\n\tstatic async create(\n\t\tprovider: Provider,\n\t\tweb3Provider: Web3Provider,\n\t\tchainId: number,\n\t\tnetworkName: string\n\t): Promise<EthereumAnalytics> {\n\t\tconst analytics = new EthereumAnalytics(provider, web3Provider, chainId, networkName);\n\t\tawait analytics.initializeNetworkInfo();\n\t\treturn analytics;\n\t}\n\n\tprivate initializeProviderStats() {\n\t\tthis.providerStats.set(this.networkInfo.provider, {\n\t\t\ttotalCalls: 0,\n\t\t\tfailedCalls: 0,\n\t\t\taverageLatency: 0\n\t\t});\n\t}\n\n\tprotected async initializeNetworkInfo(): Promise<void> {\n\t\ttry {\n\t\t\tconst startTime = Date.now();\n\n\t\t\t// Get network status\n\t\t\tconst blockNumber = await this.provider.getBlockNumber();\n\t\t\tconst latency = Date.now() - startTime;\n\n\t\t\tthis.networkInfo = {\n\t\t\t\t...this.networkInfo,\n\t\t\t\tblockNumber,\n\t\t\t\trpcLatency: latency,\n\t\t\t\tproviderUrl: this.maskProviderUrl(await this.provider.getProviderURL())\n\t\t\t};\n\n\t\t\tthis.updateProviderStats('initializeNetworkInfo', true, latency);\n\t\t} catch (error) {\n\t\t\tlog.error('Failed to initialize network info:', false, false, error);\n\t\t\t// Don't throw here, just log the error\n\t\t}\n\t}\n\n\tprivate maskProviderUrl(url?: string): string {\n\t\tif (!url) return 'unknown';\n\t\ttry {\n\t\t\tconst urlObj = new URL(url);\n\t\t\t// Mask API keys and sensitive info\n\t\t\treturn `${urlObj.protocol}//${urlObj.hostname}/*****`;\n\t\t} catch {\n\t\t\treturn 'invalid-url';\n\t\t}\n\t}\n\n\tprivate updateProviderStats(method: string, success: boolean, latency: number, error?: Error) {\n\t\tconst stats = this.providerStats.get(this.networkInfo.provider) || {\n\t\t\ttotalCalls: 0,\n\t\t\tfailedCalls: 0,\n\t\t\taverageLatency: 0\n\t\t};\n\n\t\tstats.totalCalls++;\n\t\tif (!success) {\n\t\t\tstats.failedCalls++;\n\t\t\tstats.lastError = error?.message;\n\t\t\tstats.lastErrorTime = Date.now();\n\t\t}\n\n\t\t// Update rolling average latency\n\t\tstats.averageLatency =\n\t\t\t(stats.averageLatency * (stats.totalCalls - 1) + latency) / stats.totalCalls;\n\n\t\tthis.providerStats.set(this.networkInfo.provider, stats);\n\t}\n\n\tasync trackGasEstimate(data: GasAnalytics) {\n\t\t// Check if network info needs refresh\n\t\tawait this.checkAndUpdateNetworkInfo();\n\n\t\tconst enrichedData = {\n\t\t\t...data,\n\t\t\ttimestamp: Date.now(),\n\t\t\tnetworkInfo: { ...this.networkInfo }\n\t\t};\n\n\t\tthis.gasEstimates.push(enrichedData);\n\n\t\t// Maintain array size\n\t\tif (this.gasEstimates.length > this.MAX_STORED_ENTRIES) {\n\t\t\tthis.gasEstimates.shift();\n\t\t}\n\n\t\t// Update provider stats\n\t\tthis.updateProviderStats(\n\t\t\tdata.methodName || 'gasEstimate',\n\t\t\tdata.success,\n\t\t\tthis.networkInfo.rpcLatency || 0\n\t\t);\n\n\t\t// Log significant events\n\t\tif (!data.success) {\n\t\t\tlog.warn(`Gas estimation failed for ${data.methodName}:`, false, data.errorMessage);\n\t\t}\n\t\tif (data.estimateType === 'fallback') {\n\t\t\tlog.info(`Using fallback gas estimation for ${data.methodName}:`, false, data.fallbackReason);\n\t\t}\n\t}\n\n\tasync trackSwapEstimate(data: SwapAnalytics) {\n\t\tawait this.checkAndUpdateNetworkInfo();\n\n\t\tconst enrichedData = {\n\t\t\t...data,\n\t\t\ttimestamp: Date.now(),\n\t\t\tnetworkInfo: { ...this.networkInfo }\n\t\t};\n\n\t\tthis.swapEstimates.push(enrichedData);\n\n\t\tif (this.swapEstimates.length > this.MAX_STORED_ENTRIES) {\n\t\t\tthis.swapEstimates.shift();\n\t\t}\n\n\t\t// Track specific swap analytics\n\t\tthis.updateProviderStats(\n\t\t\t`swap_${data.swapType}`,\n\t\t\tdata.success,\n\t\t\tthis.networkInfo.rpcLatency || 0\n\t\t);\n\t}\n\n\tprivate async checkAndUpdateNetworkInfo(): Promise<void> {\n\t\tconst now = Date.now();\n\t\tif (now - this.lastNetworkCheck > this.NETWORK_CHECK_INTERVAL) {\n\t\t\tawait this.initializeNetworkInfo();\n\t\t\tthis.lastNetworkCheck = now;\n\t\t}\n\t}\n\n\tasync getAnalyticsSummary(): Promise<{\n\t\tgasStats: EstimateStats;\n\t\tswapStats: EstimateStats;\n\t\tproviderHealth: Map<string, ProviderStats>;\n\t\tnetworkInfo: BlockchainNetworkInfo;\n\t}> {\n\t\tawait this.checkAndUpdateNetworkInfo();\n\n\t\treturn {\n\t\t\tgasStats: this.calculateGasStats(this.gasEstimates),\n\t\t\tswapStats: this.calculateSwapStats(this.swapEstimates),\n\t\t\tproviderHealth: this.providerStats,\n\t\t\tnetworkInfo: this.networkInfo\n\t\t};\n\t}\n\n\tprivate calculateGasStats(estimates: GasAnalytics[]): EstimateStats {\n\t\tconst timeWindow = {\n\t\t\tstart: estimates[0]?.timestamp || Date.now(),\n\t\t\tend: estimates[estimates.length - 1]?.timestamp || Date.now()\n\t\t};\n\n\t\tconst commonErrors = new Map<string, number>();\n\t\tconst methodUsage = new Map<string, number>();\n\n\t\tlet totalGasPrice = 0n;\n\t\tlet totalLatency = 0;\n\n\t\testimates.forEach((e) => {\n\t\t\tif (e.errorMessage) {\n\t\t\t\tcommonErrors.set(e.errorMessage, (commonErrors.get(e.errorMessage) || 0) + 1);\n\t\t\t}\n\t\t\tif (e.methodName) {\n\t\t\t\tmethodUsage.set(e.methodName, (methodUsage.get(e.methodName) || 0) + 1);\n\t\t\t}\n\t\t\ttotalGasPrice += BigInt(e.maxFee);\n\t\t\ttotalLatency += e.networkInfo.rpcLatency || 0;\n\t\t});\n\n\t\treturn {\n\t\t\ttotal: estimates.length,\n\t\t\tsuccessful: estimates.filter((e) => e.success).length,\n\t\t\tfallbackUsed: estimates.filter((e) => e.estimateType === 'fallback').length,\n\t\t\taverageGasPrice: estimates.length ? totalGasPrice / BigInt(estimates.length) : 0n,\n\t\t\taverageLatency: estimates.length ? totalLatency / estimates.length : 0,\n\t\t\tcommonErrors,\n\t\t\tmethodUsage,\n\t\t\tlastBlockNumber: this.networkInfo.blockNumber || 0,\n\t\t\ttimeWindow\n\t\t};\n\t}\n\n\tprivate calculateSwapStats(estimates: SwapAnalytics[]): EstimateStats & {\n\t\taverageHops: number;\n\t\tpopularPairs: Map<string, number>;\n\t} {\n\t\tconst baseStats = this.calculateGasStats(estimates);\n\t\tconst popularPairs = new Map<string, number>();\n\t\tlet totalHops = 0;\n\n\t\testimates.forEach((e) => {\n\t\t\tconst pair = `${e.tokenInSymbol}/${e.tokenOutSymbol}`;\n\t\t\tpopularPairs.set(pair, (popularPairs.get(pair) || 0) + 1);\n\t\t\ttotalHops += e.routeHops || 1;\n\t\t});\n\n\t\treturn {\n\t\t\t...baseStats,\n\t\t\taverageHops: estimates.length ? totalHops / estimates.length : 0,\n\t\t\tpopularPairs\n\t\t};\n\t}\n\n\tgetProviderHealth(): string {\n\t\tconst stats = this.providerStats.get(this.networkInfo.provider);\n\t\tif (!stats) return 'Unknown';\n\n\t\tconst successRate = (stats.totalCalls - stats.failedCalls) / stats.totalCalls;\n\t\tconst latency = stats.averageLatency;\n\n\t\tif (successRate > 0.99 && latency < 500) return 'Excellent';\n\t\tif (successRate > 0.95 && latency < 1000) return 'Good';\n\t\tif (successRate > 0.9 && latency < 2000) return 'Fair';\n\t\treturn 'Poor';\n\t}\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n// EthereumGasProvider.ts\n\nimport { BigNumber, type BigNumberish } from '$lib/common/bignumber';\nimport { EthereumBigNumber } from '$lib/common/bignumber-ethereum';\nimport {\n\ttype GasProvider,\n\ttype GasEstimate,\n\ttype HistoricalGasData,\n\ttype GasPrediction,\n\ttype GasFeeOptions,\n\ttype GasFeeEstimate,\n\tTransactionSpeed,\n\ttype FeeEstimate,\n\tEOA_FALLBACK_GAS\n} from '$lib/common/gas-types';\nimport type { PriceProvider, SwapToken, TransactionRequest } from '$lib/common/interfaces';\nimport type { Blockchain } from '$lib/managers/Blockchain';\nimport type { Wallet } from '$lib/managers/Wallet';\nimport { Ethereum } from '$lib/managers/blockchains/evm/ethereum/Ethereum';\nimport { log } from '$lib/common/logger-wrapper';\nimport type { UniswapSwapManager } from '$lib/managers/UniswapSwapManager';\nimport type { Provider } from '$lib/managers/Provider';\nimport { ethers as ethersv6 } from 'ethers-v6';\nimport { Web3Provider } from '$lib/managers/AnalyticsBase';\nimport { EthereumAnalytics } from '$lib/managers/blockchains/evm/ethereum/EthereumAnalytics';\n\nconst DEFAULT_GAS_ESTIMATES = {\n\tERC20_APPROVE: 46000n,\n\tSWAP_EXACT_IN: 180000n,\n\tSWAP_EXACT_OUT: 250000n\n};\n\nexport class EthereumGasProvider implements GasProvider {\n\tprivate provider: Provider;\n\tprivate blockchain: Ethereum;\n\tprivate priceProvider: PriceProvider;\n\tprivate analytics: EthereumAnalytics;\n\n\tprivate readonly PRIORITY_FEE_MULTIPLIERS = {\n\t\t[TransactionSpeed.SLOW]: 1n,\n\t\t[TransactionSpeed.NORMAL]: 2n,\n\t\t[TransactionSpeed.FAST]: 3n\n\t};\n\n\tprivate readonly BASE_FEE_MULTIPLIERS = {\n\t\t[TransactionSpeed.SLOW]: 1.2,\n\t\t[TransactionSpeed.NORMAL]: 1.5,\n\t\t[TransactionSpeed.FAST]: 2.0\n\t};\n\n\tprivate readonly FALLBACK_MULTIPLIERS = {\n\t\t[TransactionSpeed.SLOW]: 0.8,\n\t\t[TransactionSpeed.NORMAL]: 1,\n\t\t[TransactionSpeed.FAST]: 1.5\n\t};\n\n\tprivate readonly SAFE_FALLBACK_VALUES = {\n\t\tBASE_PRIORITY_FEE: 1n,\n\t\tMAX_TOTAL_GWEI: 100n,\n\t\tMIN_TOTAL_GWEI: 25n\n\t};\n\n\tprivate readonly MIN_PRIORITY_FEE = 1n;\n\n\tprivate constructor(\n\t\tprovider: Provider,\n\t\tblockchain: Ethereum,\n\t\tpriceProvider: PriceProvider,\n\t\tanalytics: EthereumAnalytics\n\t) {\n\t\tthis.provider = provider;\n\t\tthis.blockchain = blockchain;\n\t\tthis.priceProvider = priceProvider;\n\t\tthis.analytics = analytics;\n\t}\n\n\tstatic async create(\n\t\tprovider: Provider,\n\t\tblockchain: Blockchain,\n\t\tpriceProvider: PriceProvider\n\t): Promise<EthereumGasProvider> {\n\t\tconst web3ProviderType = await this.determineProviderType(provider);\n\t\tconst network = blockchain.getNetwork();\n\n\t\tconst analytics = await EthereumAnalytics.create(\n\t\t\tprovider,\n\t\t\tweb3ProviderType,\n\t\t\tnetwork.chainId,\n\t\t\tnetwork.name\n\t\t);\n\n\t\treturn new EthereumGasProvider(provider, blockchain as Ethereum, priceProvider, analytics);\n\t}\n\n\tprivate static async determineProviderType(provider: Provider): Promise<Web3Provider> {\n\t\tconst providerUrl = (await provider.getProviderURL()) || '';\n\n\t\tif (providerUrl.includes('alchemy')) return Web3Provider.ALCHEMY;\n\t\tif (providerUrl.includes('infura')) return Web3Provider.INFURA;\n\t\tif (providerUrl.includes('cloudflare')) return Web3Provider.CLOUDFLARE;\n\t\tif (providerUrl.includes('quiknode')) return Web3Provider.QUICKNODE;\n\t\treturn Web3Provider.CUSTOM;\n\t}\n\n\tgetName(): string {\n\t\treturn 'EthereumGasProvider';\n\t}\n\n\tasync getFallbackGasPrice(speed: TransactionSpeed = TransactionSpeed.NORMAL): Promise<bigint> {\n\t\ttry {\n\t\t\tconst recentGasPrice = await this.provider.getGasPrice();\n\t\t\tconst multiplier = this.FALLBACK_MULTIPLIERS[speed];\n\t\t\treturn BigInt(Number(recentGasPrice) * multiplier);\n\t\t} catch (error: unknown) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\t\t\tthis.analytics.trackGasEstimate({\n\t\t\t\testimateType: 'fallback',\n\t\t\t\tgasLimit: '0',\n\t\t\t\tpriorityFee: '0',\n\t\t\t\tmaxFee: '0',\n\t\t\t\tsuccess: false,\n\t\t\t\tmethodName: 'getFallbackGasPrice',\n\t\t\t\terrorMessage,\n\t\t\t\tnetworkInfo: this.analytics.networkInfo,\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t\tfallbackReason: 'Gas price fetch failed'\n\t\t\t});\n\t\t\treturn EOA_FALLBACK_GAS.GWEI[speed].MAX_FEE * BigInt(1e9);\n\t\t}\n\t}\n\n\tasync getOptimizedGasFees(\n\t\tgasLimit: bigint,\n\t\toptions: GasFeeOptions = {}\n\t): Promise<GasFeeEstimate> {\n\t\ttry {\n\t\t\tconst speed = options.speed || TransactionSpeed.NORMAL;\n\t\t\tconst feeData = await this.provider.getFeeData();\n\n\t\t\t// Calculate priority fee\n\t\t\tlet priorityFeePerGas: bigint;\n\t\t\tif (options.customPriorityFee) {\n\t\t\t\tpriorityFeePerGas = options.customPriorityFee;\n\t\t\t} else {\n\t\t\t\tconst basePriorityFee = BigInt(\n\t\t\t\t\tMath.max(\n\t\t\t\t\t\tNumber(feeData.maxPriorityFeePerGas || this.MIN_PRIORITY_FEE),\n\t\t\t\t\t\tNumber(this.MIN_PRIORITY_FEE)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\tpriorityFeePerGas = basePriorityFee * this.PRIORITY_FEE_MULTIPLIERS[speed];\n\t\t\t}\n\n\t\t\t// Calculate max fee\n\t\t\tlet maxFeePerGas: bigint;\n\t\t\tif (options.customMaxFee) {\n\t\t\t\tmaxFeePerGas = options.customMaxFee;\n\t\t\t} else {\n\t\t\t\tconst baseFee = feeData.lastBaseFeePerGas || 0n;\n\t\t\t\tconst multiplier = this.BASE_FEE_MULTIPLIERS[speed];\n\t\t\t\tmaxFeePerGas = (baseFee * BigInt(multiplier * 10)) / 10n + priorityFeePerGas;\n\t\t\t}\n\n\t\t\t// Calculate estimated cost\n\t\t\tconst estimatedCostWei = gasLimit * maxFeePerGas;\n\t\t\tconst estimatedCostEth = ethersv6.formatEther(estimatedCostWei);\n\t\t\tconst ethPrice = await this.getEthPrice();\n\t\t\tconst estimatedCostUsd = (Number(estimatedCostEth) * ethPrice).toFixed(2);\n\n\t\t\tconst result = {\n\t\t\t\tmaxPriorityFeePerGas: priorityFeePerGas,\n\t\t\t\tmaxFeePerGas: maxFeePerGas,\n\t\t\t\testimatedCostWei: estimatedCostWei,\n\t\t\t\testimatedCostEth: estimatedCostEth,\n\t\t\t\testimatedCostUsd: `$${estimatedCostUsd}`\n\t\t\t};\n\n\t\t\tthis.analytics.trackGasEstimate({\n\t\t\t\testimateType: 'optimized',\n\t\t\t\tgasLimit: gasLimit.toString(),\n\t\t\t\tpriorityFee: priorityFeePerGas.toString(),\n\t\t\t\tmaxFee: maxFeePerGas.toString(),\n\t\t\t\tsuccess: true,\n\t\t\t\tmethodName: 'getOptimizedGasFees',\n\t\t\t\tnetworkInfo: this.analytics.networkInfo,\n\t\t\t\ttimestamp: Date.now()\n\t\t\t});\n\n\t\t\treturn result;\n\t\t} catch (error: unknown) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\t\t\tthis.analytics.trackGasEstimate({\n\t\t\t\testimateType: 'fallback',\n\t\t\t\tgasLimit: gasLimit.toString(),\n\t\t\t\tpriorityFee: '0',\n\t\t\t\tmaxFee: '0',\n\t\t\t\tsuccess: false,\n\t\t\t\tmethodName: 'getOptimizedGasFees',\n\t\t\t\terrorMessage,\n\t\t\t\tnetworkInfo: this.analytics.networkInfo,\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t\tfallbackReason: 'Optimization failed'\n\t\t\t});\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync getGasEstimate(\n\t\ttransaction: TransactionRequest,\n\t\toptions: GasFeeOptions = {}\n\t): Promise<GasEstimate> {\n\t\ttry {\n\t\t\tconst gasLimit = await this.provider.estimateGas(transaction);\n\t\t\tconst optimizedFees = await this.getOptimizedGasFees(gasLimit, options);\n\n\t\t\tconst result = {\n\t\t\t\tgasLimit: gasLimit.toString(),\n\t\t\t\tfeeEstimate: {\n\t\t\t\t\tbaseFee: (optimizedFees.maxFeePerGas - optimizedFees.maxPriorityFeePerGas).toString(),\n\t\t\t\t\tpriorityFee: optimizedFees.maxPriorityFeePerGas.toString(),\n\t\t\t\t\ttotalFee: optimizedFees.maxFeePerGas.toString(),\n\t\t\t\t\testimatedCostEth: optimizedFees.estimatedCostEth,\n\t\t\t\t\testimatedCostUsd: optimizedFees.estimatedCostUsd\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.analytics.trackGasEstimate({\n\t\t\t\testimateType: 'normal',\n\t\t\t\tgasLimit: gasLimit.toString(),\n\t\t\t\tpriorityFee: optimizedFees.maxPriorityFeePerGas.toString(),\n\t\t\t\tmaxFee: optimizedFees.maxFeePerGas.toString(),\n\t\t\t\tsuccess: true,\n\t\t\t\tmethodName: 'getGasEstimate',\n\t\t\t\tnetworkInfo: this.analytics.networkInfo,\n\t\t\t\ttimestamp: Date.now()\n\t\t\t});\n\n\t\t\treturn result;\n\t\t} catch (error: unknown) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\t\t\tthis.analytics.trackGasEstimate({\n\t\t\t\testimateType: 'fallback',\n\t\t\t\tgasLimit: '0',\n\t\t\t\tpriorityFee: '0',\n\t\t\t\tmaxFee: '0',\n\t\t\t\tsuccess: false,\n\t\t\t\tmethodName: 'getGasEstimate',\n\t\t\t\terrorMessage,\n\t\t\t\tnetworkInfo: this.analytics.networkInfo,\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t\tfallbackReason: 'Estimation failed'\n\t\t\t});\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync getSafeGasEstimate(\n\t\tto: string,\n\t\tvalue: bigint,\n\t\toptions: GasFeeOptions = {}\n\t): Promise<GasEstimate> {\n\t\ttry {\n\t\t\tconst estimate = await this.getEOATransferGasEstimate(to, value, options);\n\n\t\t\tconst totalGwei = EthereumBigNumber.from(estimate.feeEstimate.totalFee).toBigInt();\n\t\t\tif (totalGwei > this.SAFE_FALLBACK_VALUES.MAX_TOTAL_GWEI) {\n\t\t\t\tthrow new Error('Gas estimate too high');\n\t\t\t}\n\t\t\tif (totalGwei < this.SAFE_FALLBACK_VALUES.MIN_TOTAL_GWEI) {\n\t\t\t\tthrow new Error('Gas estimate too low');\n\t\t\t}\n\n\t\t\treturn estimate;\n\t\t} catch (error: unknown) {\n\t\t\tconst baseGasPrice = await this.getFallbackGasPrice(options.speed);\n\t\t\tconst priorityFee = this.SAFE_FALLBACK_VALUES.BASE_PRIORITY_FEE * BigInt(1e9);\n\t\t\tconst maxFee = baseGasPrice + priorityFee;\n\n\t\t\tconst errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\t\t\tthis.analytics.trackGasEstimate({\n\t\t\t\testimateType: 'fallback',\n\t\t\t\tgasLimit: '21000',\n\t\t\t\tpriorityFee: priorityFee.toString(),\n\t\t\t\tmaxFee: maxFee.toString(),\n\t\t\t\tsuccess: false,\n\t\t\t\tmethodName: 'getSafeGasEstimate',\n\t\t\t\terrorMessage,\n\t\t\t\tnetworkInfo: this.analytics.networkInfo,\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t\tfallbackReason: 'Safe estimate bounds exceeded'\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tgasLimit: '21000',\n\t\t\t\tfeeEstimate: {\n\t\t\t\t\tbaseFee: baseGasPrice.toString(),\n\t\t\t\t\tpriorityFee: priorityFee.toString(),\n\t\t\t\t\ttotalFee: maxFee.toString(),\n\t\t\t\t\testimatedCostEth: ethersv6.formatEther(21000n * maxFee),\n\t\t\t\t\testimatedCostUsd: 'Using fallback values'\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\tasync getEOATransferGasEstimate(\n\t\tto: string,\n\t\tvalue: bigint,\n\t\toptions: GasFeeOptions = {}\n\t): Promise<GasEstimate> {\n\t\tconst transaction: TransactionRequest = {\n\t\t\tto,\n\t\t\tquantity: value,\n\t\t\tfrom: '0x0000000000000000000000000000000000000000',\n\t\t\tchainId: this.blockchain.getChainId()\n\t\t};\n\n\t\treturn this.getGasEstimate(transaction, options);\n\t}\n\n\tasync getEOATransferGasEstimateWithFallback(\n\t\tto: string,\n\t\tvalue: bigint,\n\t\toptions: GasFeeOptions = {}\n\t): Promise<GasEstimate> {\n\t\ttry {\n\t\t\treturn await this.getEOATransferGasEstimate(to, value, options);\n\t\t} catch (error: any) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\t\t\tlog.error('Gas estimation failed, using fallback values:', false, errorMessage);\n\n\t\t\tconst speed = options.speed || TransactionSpeed.NORMAL;\n\t\t\tconst fallbackValues = EOA_FALLBACK_GAS.GWEI[speed];\n\n\t\t\tthis.analytics.trackGasEstimate({\n\t\t\t\testimateType: 'fallback',\n\t\t\t\tgasLimit: EOA_FALLBACK_GAS.LIMITS.BASE.toString(),\n\t\t\t\tpriorityFee: fallbackValues.PRIORITY_FEE.toString(),\n\t\t\t\tmaxFee: fallbackValues.MAX_FEE.toString(),\n\t\t\t\tsuccess: false,\n\t\t\t\tmethodName: 'getEOATransferGasEstimateWithFallback',\n\t\t\t\terrorMessage,\n\t\t\t\tnetworkInfo: this.analytics.networkInfo,\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t\tfallbackReason: 'Estimation failed, using fallback'\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tgasLimit: EOA_FALLBACK_GAS.LIMITS.BASE.toString(),\n\t\t\t\tfeeEstimate: {\n\t\t\t\t\tbaseFee: (fallbackValues.MAX_FEE - fallbackValues.PRIORITY_FEE).toString(),\n\t\t\t\t\tpriorityFee: fallbackValues.PRIORITY_FEE.toString(),\n\t\t\t\t\ttotalFee: fallbackValues.MAX_FEE.toString(),\n\t\t\t\t\testimatedCostEth: ethersv6.formatEther(\n\t\t\t\t\t\tEOA_FALLBACK_GAS.LIMITS.BASE * fallbackValues.MAX_FEE * BigInt(1e9)\n\t\t\t\t\t),\n\t\t\t\t\testimatedCostUsd: 'Fallback estimate'\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\tasync getHistoricalGasData(duration: number): Promise<HistoricalGasData[]> {\n\t\ttry {\n\t\t\t// Implement the logic to fetch historical gas data from an external API or indexer\n\t\t\t// For example, you can use a service like Etherscan or Infura to retrieve historical gas data\n\t\t\t// You'll need to make an HTTP request to the API endpoint and parse the response\n\t\t\t// The response should contain the historical gas data for the specified duration\n\t\t\t// Map the response data to the HistoricalGasData interface and return it\n\n\t\t\t// Example using a mock API response\n\t\t\tconst response = await fetch('https://api.example.com/historical-gas-data');\n\t\t\tconst data = await response.json();\n\n\t\t\tconst historicalData = data.map((item: any) => ({\n\t\t\t\ttimestamp: item.timestamp,\n\t\t\t\tbaseFee: item.baseFeePerGas,\n\t\t\t\tpriorityFee: item.priorityFeePerGas\n\t\t\t}));\n\n\t\t\tthis.analytics.trackGasEstimate({\n\t\t\t\testimateType: 'historical',\n\t\t\t\tgasLimit: '0',\n\t\t\t\tpriorityFee: '0',\n\t\t\t\tmaxFee: '0',\n\t\t\t\tsuccess: true,\n\t\t\t\tmethodName: 'getHistoricalGasData',\n\t\t\t\tnetworkInfo: this.analytics.networkInfo,\n\t\t\t\ttimestamp: Date.now()\n\t\t\t});\n\n\t\t\treturn historicalData;\n\t\t} catch (error: unknown) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\t\t\tlog.error('Error fetching historical gas data:', false, errorMessage);\n\n\t\t\tthis.analytics.trackGasEstimate({\n\t\t\t\testimateType: 'historical',\n\t\t\t\tgasLimit: '0',\n\t\t\t\tpriorityFee: '0',\n\t\t\t\tmaxFee: '0',\n\t\t\t\tsuccess: false,\n\t\t\t\tmethodName: 'getHistoricalGasData',\n\t\t\t\terrorMessage,\n\t\t\t\tnetworkInfo: this.analytics.networkInfo,\n\t\t\t\ttimestamp: Date.now()\n\t\t\t});\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync predictFutureFees(duration: number): Promise<GasPrediction[]> {\n\t\ttry {\n\t\t\tconst historicalData = await this.getHistoricalGasData(duration);\n\t\t\tconst predictions = historicalData.map((item) => ({\n\t\t\t\ttimestamp: item.timestamp + duration,\n\t\t\t\testimatedBaseFee: item.baseFee,\n\t\t\t\testimatedPriorityFee: item.priorityFee\n\t\t\t}));\n\n\t\t\tthis.analytics.trackGasEstimate({\n\t\t\t\testimateType: 'prediction',\n\t\t\t\tgasLimit: '0',\n\t\t\t\tpriorityFee: '0',\n\t\t\t\tmaxFee: '0',\n\t\t\t\tsuccess: true,\n\t\t\t\tmethodName: 'predictFutureFees',\n\t\t\t\tnetworkInfo: this.analytics.networkInfo,\n\t\t\t\ttimestamp: Date.now()\n\t\t\t});\n\n\t\t\treturn predictions;\n\t\t} catch (error: unknown) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\t\t\tlog.error('Error predicting future gas fees:', false, errorMessage);\n\n\t\t\tthis.analytics.trackGasEstimate({\n\t\t\t\testimateType: 'prediction',\n\t\t\t\tgasLimit: '0',\n\t\t\t\tpriorityFee: '0',\n\t\t\t\tmaxFee: '0',\n\t\t\t\tsuccess: false,\n\t\t\t\tmethodName: 'predictFutureFees',\n\t\t\t\terrorMessage,\n\t\t\t\tnetworkInfo: this.analytics.networkInfo,\n\t\t\t\ttimestamp: Date.now()\n\t\t\t});\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync estimateSwapGasFee(\n\t\ttokenIn: SwapToken,\n\t\ttokenOut: SwapToken,\n\t\tfromAmount: BigNumberish,\n\t\tslippageTolerance: number,\n\t\tdeadline: number,\n\t\tswapManager: UniswapSwapManager,\n\t\tfee: number = 3000\n\t): Promise<string> {\n\t\ttry {\n\t\t\t// Base gas units for different operations\n\t\t\tconst BASE_SWAP_GAS = 150000n;\n\t\t\tconst APPROVAL_GAS = 46000n;\n\n\t\t\t// Calculate total gas units needed\n\t\t\tlet totalGasUnits = BASE_SWAP_GAS;\n\t\t\tif (!tokenIn.isNative) {\n\t\t\t\ttotalGasUnits += APPROVAL_GAS;\n\t\t\t}\n\n\t\t\t// Get current gas prices\n\t\t\tconst feeData = await this.provider.getFeeData();\n\t\t\tconst maxFeePerGas = feeData.maxFeePerGas || feeData.gasPrice;\n\t\t\tif (!maxFeePerGas) throw new Error('Could not get gas price');\n\n\t\t\t// Calculate total gas cost in wei\n\t\t\tconst gasCostWei = totalGasUnits * BigInt(maxFeePerGas.toString());\n\n\t\t\t// Convert to ETH\n\t\t\tconst gasCostEth = EthereumBigNumber.fromWei(gasCostWei.toString()).toEtherString();\n\n\t\t\t// Get ETH price\n\t\t\tconst ethPrice = await this.getEthPrice();\n\n\t\t\t// Calculate USD cost\n\t\t\tconst gasCostUsd = parseFloat(gasCostEth) * ethPrice;\n\n\t\t\tthis.analytics.trackSwapEstimate({\n\t\t\t\testimateType: 'normal',\n\t\t\t\tgasLimit: totalGasUnits.toString(),\n\t\t\t\tpriorityFee: feeData.maxPriorityFeePerGas?.toString() || '0',\n\t\t\t\tmaxFee: maxFeePerGas.toString(),\n\t\t\t\tsuccess: true,\n\t\t\t\tmethodName: 'estimateSwapGasFee',\n\t\t\t\tnetworkInfo: this.analytics.networkInfo,\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t\ttokenInSymbol: tokenIn.symbol,\n\t\t\t\ttokenOutSymbol: tokenOut.symbol,\n\t\t\t\tamount: fromAmount.toString(),\n\t\t\t\tisMultiHop: false,\n\t\t\t\tswapType: 'exactIn',\n\t\t\t\tdexUsed: 'Uniswap V3'\n\t\t\t});\n\n\t\t\treturn `$${gasCostUsd.toFixed(2)} (${gasCostEth} ETH)`;\n\t\t} catch (error: unknown) {\n\t\t\tconst errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\t\t\tlog.error('Gas estimation error:', false, errorMessage);\n\n\t\t\tthis.analytics.trackSwapEstimate({\n\t\t\t\testimateType: 'fallback',\n\t\t\t\tgasLimit: '0',\n\t\t\t\tpriorityFee: '0',\n\t\t\t\tmaxFee: '0',\n\t\t\t\tsuccess: false,\n\t\t\t\tmethodName: 'estimateSwapGasFee',\n\t\t\t\terrorMessage,\n\t\t\t\tnetworkInfo: this.analytics.networkInfo,\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t\ttokenInSymbol: tokenIn.symbol,\n\t\t\t\ttokenOutSymbol: tokenOut.symbol,\n\t\t\t\tamount: fromAmount.toString(),\n\t\t\t\tisMultiHop: false,\n\t\t\t\tswapType: 'exactIn',\n\t\t\t\tdexUsed: 'Uniswap V3'\n\t\t\t});\n\n\t\t\treturn 'Unable to estimate gas';\n\t\t}\n\t}\n\n\t// First one was tested after bottom one\n\t// async estimateSwapGasFee(\n\t//   tokenIn: SwapToken,\n\t//   tokenOut: SwapToken,\n\t//   fromAmount: BigNumberish,\n\t//   slippageTolerance: number,\n\t//   deadline: number,\n\t//   swapManager: UniswapSwapManager,\n\t//   fee: number = 3000,\n\t//   dummyFromAddress: string = '0x0000000000000000000000000000000000000000'\n\t// ): Promise<string> {\n\t//   try {\n\t//     // Convert input values\n\t//     const fromAmountBN = EthereumBigNumber.from(fromAmount);\n\t//     const slippageBN = fromAmountBN.mul(Math.floor(slippageTolerance * 10)).div(1000);\n\t//     const minAmountOut = fromAmountBN.sub(slippageBN);\n\t//     const deadlineTimestamp = Math.floor(Date.now() / 1000) + deadline * 60;\n\t//     let totalGasEstimate: bigint;\n\n\t//     try {\n\t//       // Attempt to get the exact gas estimate\n\t//       const swapGasEstimate = await swapManager.populateSwapTransaction(\n\t//         Token.fromSwapToken(tokenIn, this.blockchain, this.provider),\n\t//         Token.fromSwapToken(tokenOut, this.blockchain, this.provider),\n\t//         fromAmountBN.toString(),\n\t//         minAmountOut.toString(),\n\t//         dummyFromAddress,\n\t//         deadlineTimestamp,\n\t//         fee,\n\t//         true\n\t//       );\n\n\t//       // Check if the result is a bigint (gas estimate) or a TransactionRequest\n\t//       if (typeof swapGasEstimate === 'bigint') {\n\t//         totalGasEstimate = swapGasEstimate;\n\t//       } else {\n\t//         // Use default estimates based on transaction type\n\t//         const isMultiHop = false; // Optional: Set this dynamically based on external logic if available\n\t//         totalGasEstimate = isMultiHop ? 200000n : 150000n;\n\t//       }\n\n\t//       // Add approval gas if not native\n\t//       if (!tokenIn.isNative) {\n\t//         totalGasEstimate += 46000n;\n\t//       }\n\t//     } catch {\n\t//       log.error('Gas estimation failed, using default.');\n\t//       totalGasEstimate = (tokenIn.isNative ? 150000n : 196000n);\n\t//     }\n\n\t//     // Calculate fee in ETH and USD\n\t//     const feeData = await this.provider.getFeeData();\n\t//     const gasPriceGwei = EthereumBigNumber.from(feeData.maxFeePerGas || feeData.gasPrice || 0);\n\t//     const gasFeeGwei = EthereumBigNumber.from(totalGasEstimate).mul(gasPriceGwei);\n\t//     const gasFeeEth = EthereumBigNumber.fromGwei(gasFeeGwei.toString()).toEtherString();\n\t//     const ethPrice = await this.getEthPrice();\n\t//     const gasFeeUsd = parseFloat(gasFeeEth) * ethPrice;\n\n\t//     return `$${gasFeeUsd.toFixed(2)} (${gasFeeEth} ETH)`;\n\t//   } catch (error) {\n\t//     log.error('Error estimating swap gas fee:', false, error);\n\t//     return 'N/A';\n\t//   }\n\t// }\n\n\t// async estimateSwapGasFee(\n\t//   tokenIn: SwapToken,\n\t//   tokenOut: SwapToken,\n\t//   fromAmount: BigNumberish,\n\t//   slippageTolerance: number,\n\t//   deadline: number,\n\t//   swapManager: UniswapSwapManager,\n\t//   fee: number = 3000,\n\t//   dummyFromAddress: string = '0x0000000000000000000000000000000000000000' // Dummy from address for ETH swaps estimates\n\t// ): Promise<string> {\n\t//   try {\n\t//     if (!tokenIn || !tokenOut || !fromAmount || !slippageTolerance || !deadline || !swapManager) {\n\t//       return 'N/A'; //'Invalid parameters'; // Return an error message if any required parameters are missing\n\t//     }\n\n\t//     const fromAmountBN = EthereumBigNumber.from(fromAmount);\n\t//     const slippageBN = fromAmountBN.mul(Math.floor(slippageTolerance * 10)).div(1000);\n\t//     const minAmountOut = fromAmountBN.sub(slippageBN);\n\t//     const deadlineTimestamp = Math.floor(Date.now() / 1000) + (deadline * 60);\n\n\t//     let totalGasEstimate: bigint;\n\n\t//     try {\n\t//       const swapGasEstimate = await swapManager.populateSwapTransaction(\n\t//         Token.fromSwapToken(tokenIn, this.blockchain, this.provider),\n\t//         Token.fromSwapToken(tokenOut, this.blockchain, this.provider),\n\t//         fromAmountBN.toString(),\n\t//         minAmountOut.toString(),\n\t//         dummyFromAddress,\n\t//         deadlineTimestamp,\n\t//         fee,\n\t//         true\n\t//       );\n\n\t//       if (typeof swapGasEstimate === 'bigint') {\n\t//         totalGasEstimate = swapGasEstimate;\n\t//       } else {\n\t//         // If we couldn't get an exact estimate, use defaults\n\t//         totalGasEstimate = DEFAULT_GAS_ESTIMATES.SWAP_EXACT_IN;\n\n\t//         // Add approval gas if it's not a native token\n\t//         if (!tokenIn.isNative) {\n\t//           totalGasEstimate += DEFAULT_GAS_ESTIMATES.ERC20_APPROVE;\n\t//         }\n\t//       }\n\t//     } catch (error) {\n\t//       log.error('Gas estimation failed, using defaults...');\n\n\t//       // Use default estimates\n\t//       totalGasEstimate = DEFAULT_GAS_ESTIMATES.SWAP_EXACT_IN;\n\n\t//       // Add approval gas if it's not a native token\n\t//       if (!tokenIn.isNative) {\n\t//         totalGasEstimate += DEFAULT_GAS_ESTIMATES.ERC20_APPROVE;\n\t//       }\n\t//     }\n\n\t//     // Calculate fee in ETH\n\t//     const feeData = await this.provider.getFeeData();\n\t//     const gasPriceGwei = EthereumBigNumber.from(feeData.maxFeePerGas || feeData.gasPrice || 0);\n\t//     const gasFeeGwei = EthereumBigNumber.from(totalGasEstimate).mul(gasPriceGwei);\n\t//     const gasFeeEth = EthereumBigNumber.fromGwei(gasFeeGwei.toString()).toEtherString();\n\n\t//     // Get ETH price and calculate USD value\n\t//     const ethPrice = await this.getEthPrice();\n\t//     const gasFeeUsd = parseFloat(gasFeeEth) * ethPrice;\n\n\t//     return `$${gasFeeUsd.toFixed(2)} (${gasFeeEth} ETH)`;\n\t//   } catch (error) {\n\t//     log.error('Error estimating swap gas fee:', false, error);\n\t//     // Even if everything fails, return a conservative estimate\n\t//     const conservativeGasEstimate = DEFAULT_GAS_ESTIMATES.SWAP_EXACT_IN +\n\t//       (!tokenIn.isNative ? DEFAULT_GAS_ESTIMATES.ERC20_APPROVE : 0n);\n\n\t//     try {\n\t//       const feeData = await this.provider.getFeeData();\n\t//       const gasPriceGwei = EthereumBigNumber.from(feeData.maxFeePerGas || feeData.gasPrice || 0);\n\t//       const gasFeeGwei = EthereumBigNumber.from(conservativeGasEstimate).mul(gasPriceGwei);\n\t//       const gasFeeEth = EthereumBigNumber.fromGwei(gasFeeGwei.toString()).toEtherString();\n\t//       const ethPrice = await this.getEthPrice();\n\t//       const gasFeeUsd = parseFloat(gasFeeEth) * ethPrice;\n\n\t//       return `≈ $${gasFeeUsd.toFixed(2)} (${gasFeeEth} ETH)`;\n\t//     } catch {\n\t//       return 'N/A';\n\t//     }\n\t//   }\n\t// }\n\n\tasync getEthPrice(): Promise<number> {\n\t\ttry {\n\t\t\tlog.debug('getEthPrice - priceProvider', false, this.priceProvider);\n\n\t\t\tconst marketPrice = this.priceProvider.getMarketPrice('ETH-USD');\n\t\t\treturn (await marketPrice).price;\n\t\t} catch (error) {\n\t\t\tlog.error('Error fetching ETH price:', false, false, error);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tasync getCurrentGasPriceInGwei(factor: number = 1): Promise<number> {\n\t\tconst gasPrice = await this.provider.getGasPrice();\n\t\treturn Number(ethersv6.formatUnits(gasPrice, 'gwei')) * factor;\n\t}\n\n\tasync getGasPriceFromEtherscan(apiKey: string): Promise<number> {\n\t\tconst response = await fetch(\n\t\t\t`https://api.etherscan.io/api?module=gastracker&action=gasoracle&apikey=${apiKey}`\n\t\t);\n\t\tconst data = await response.json();\n\t\treturn Number(data.result.ProposeGasPrice);\n\t}\n\n\tasync getFormattedGasEstimates(\n\t\tgasEstimate: BigNumberish,\n\t\tfactor: number = 1.5,\n\t\tgasPriceInGwei: number = 0,\n\t\tethPriceInUsd: number = 0\n\t) {\n\t\tif (!gasEstimate) {\n\t\t\tthrow new Error('Gas estimate must be provided');\n\t\t}\n\n\t\tconst gasEstimateBigInt = BigNumber.from(gasEstimate).toBigInt();\n\n\t\tif (gasEstimateBigInt! <= 0n) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (factor <= 0) {\n\t\t\tfactor = 1;\n\t\t\tlog.warn('Factor must be greater than 0 - set to 1');\n\t\t}\n\n\t\tif (gasPriceInGwei < 0) {\n\t\t\tgasPriceInGwei = 0;\n\t\t\tlog.warn('Gas price must be greater than or equal to 0 - set to 0');\n\t\t}\n\n\t\tif (ethPriceInUsd <= 0) {\n\t\t\tethPriceInUsd = 0;\n\t\t\tlog.warn('ETH price must be greater than 0 - set to 0');\n\t\t}\n\n\t\tif (gasPriceInGwei === 0) {\n\t\t\tgasPriceInGwei = await this.getCurrentGasPriceInGwei(factor);\n\t\t}\n\n\t\tif (ethPriceInUsd === 0) {\n\t\t\tethPriceInUsd = await this.getEthPrice();\n\t\t}\n\n\t\tconst gasPriceInEth = gasPriceInGwei * 1e-9;\n\t\tconst gasEstimateInEth = Number(gasEstimate) * gasPriceInEth;\n\t\tconst gasEstimateInUsd = gasEstimateInEth * ethPriceInUsd;\n\n\t\treturn gasEstimateInUsd;\n\t}\n\n\tsetPriceProvider(priceProvider: PriceProvider): void {\n\t\tthis.priceProvider = priceProvider;\n\t}\n}\n\n// /* eslint-disable @typescript-eslint/no-unused-vars */\n// /* eslint-disable @typescript-eslint/no-explicit-any */\n// // EthereumGasProvider.ts\n\n// import { BigNumber, type BigNumberish } from '$lib/common/bignumber';\n// import { EthereumBigNumber } from '$lib/common/bignumber-ethereum';\n// import { log.debug } from '$lib/common/debug-error';\n// // import { ETH_BASE_UNISWAP_GAS_UNITS } from '$lib/common/constants';\n// import type {\n//   GasProvider,\n//   GasEstimate,\n//   HistoricalGasData,\n//   GasPrediction,\n//   FeeEstimate\n// } from '$lib/common/gas-types';\n// import type { PriceProvider, SwapToken, TransactionRequest } from '$lib/common/interfaces';\n// import type { Blockchain, Wallet } from '$lib/managers';\n// import { Ethereum } from '$lib/managers/blockchains/evm/ethereum/Ethereum';\n// import { log } from '$lib/managers/Logger';\n// import type { UniswapSwapManager } from '$lib/managers/UniswapSwapManager';\n// import type { Provider } from '$lib/managers/Provider';\n// import { ethers as ethersv6 } from 'ethers-v6';\n\n// const DEFAULT_GAS_ESTIMATES = {\n//   ERC20_APPROVE: 46000n,\n//   SWAP_EXACT_IN: 180000n,\n//   SWAP_EXACT_OUT: 250000n\n// };\n\n// export class EthereumGasProvider implements GasProvider {\n//   private provider: Provider;\n//   private blockchain: Ethereum;\n//   private priceProvider: PriceProvider;\n\n//   constructor ( provider: Provider, blockchain: Blockchain, priceProvider: PriceProvider ) {\n//     this.provider = provider;\n//     this.blockchain = blockchain as Ethereum;\n//     this.priceProvider = priceProvider;\n//   }\n\n//   getName(): string {\n//     return \"EthereumGasProvider\";\n//   }\n\n//   async getGasEstimate( transaction: TransactionRequest ): Promise<GasEstimate> {\n//     let gasLimit: bigint = 0n;\n//     let feeEstimate: FeeEstimate | null = null;\n//     let feeData: any;\n//     try {\n//       gasLimit = await this.provider.estimateGas( transaction );\n//       feeData = await this.provider.getFeeData();\n\n//       feeEstimate = {\n//         baseFee: feeData.lastBaseFeePerGas.toString(),\n//         priorityFee: feeData.maxPriorityFeePerGas.toString(),\n//         totalFee: BigNumber.from( feeData.lastBaseFeePerGas ).add( feeData.maxPriorityFeePerGas ).toString()\n//       };\n\n//       return {\n//         gasLimit: gasLimit.toString(),\n//         feeEstimate: feeEstimate\n//       };\n//     } catch ( error ) {\n//       log.error('Error estimating gas gasLimit, feeEstimate, feeData :==>>', { gasLimit, feeEstimate, feeData });\n//       log.error('Error estimating gas:', false, error );\n//       throw error;\n//     }\n//   }\n\n//   async getHistoricalGasData( duration: number ): Promise<HistoricalGasData[]> {\n//     try {\n//       // Implement the logic to fetch historical gas data from an external API or indexer\n//       // For example, you can use a service like Etherscan or Infura to retrieve historical gas data\n//       // You'll need to make an HTTP request to the API endpoint and parse the response\n//       // The response should contain the historical gas data for the specified duration\n//       // Map the response data to the HistoricalGasData interface and return it\n\n//       // Example using a mock API response\n//       const response = await fetch( 'https://api.example.com/historical-gas-data' );\n//       const data = await response.json();\n\n//       return data.map( ( item: any ) => ( {\n//         timestamp: item.timestamp,\n//         baseFee: item.baseFeePerGas,\n//         priorityFee: item.priorityFeePerGas\n//       } ) );\n//     } catch ( error ) {\n//       log.error( 'Error fetching historical gas data:', false, error );\n//       throw error;\n//     }\n//   }\n\n//   async predictFutureFees( duration: number ): Promise<GasPrediction[]> {\n//     try {\n//       // Implement the logic to predict future gas fees using a predictive model\n//       // You can use historical gas data and machine learning techniques to build a predictive model\n//       // The model should take into account factors like network congestion, transaction volume, etc.\n//       // Train the model using historical data and use it to predict future gas fees for the specified duration\n//       // Map the predicted data to the GasPrediction interface and return it\n\n//       // Example using a mock prediction model\n//       const historicalData = await this.getHistoricalGasData( duration );\n//       const predictions = historicalData.map( ( item ) => ( {\n//         timestamp: item.timestamp + duration,\n//         estimatedBaseFee: item.baseFee,\n//         estimatedPriorityFee: item.priorityFee\n//       } ) );\n\n//       return predictions;\n//     } catch ( error ) {\n//       log.error( 'Error predicting future gas fees:', false, error );\n//       throw error;\n//     }\n//   }\n\n//   async estimateSwapGasFee(\n//     tokenIn: SwapToken,\n//     tokenOut: SwapToken,\n//     fromAmount: BigNumberish,\n//     slippageTolerance: number,\n//     deadline: number,\n//     swapManager: UniswapSwapManager,\n//     fee: number = 3000\n//   ): Promise<string> {\n//     try {\n//       // Base gas units for different operations\n//       const BASE_SWAP_GAS = 150000n;\n//       const APPROVAL_GAS = 46000n;\n\n//       // Calculate total gas units needed\n//       let totalGasUnits = BASE_SWAP_GAS;\n//       if ( !tokenIn.isNative ) {\n//         totalGasUnits += APPROVAL_GAS;\n//       }\n\n//       // Get current gas prices\n//       const feeData = await this.provider.getFeeData();\n//       const maxFeePerGas = feeData.maxFeePerGas || feeData.gasPrice;\n//       if ( !maxFeePerGas ) throw new Error( 'Could not get gas price' );\n\n//       // Calculate total gas cost in wei\n//       const gasCostWei = totalGasUnits * BigInt( maxFeePerGas.toString() );\n\n//       // Convert to ETH\n//       const gasCostEth = EthereumBigNumber.fromWei( gasCostWei.toString() ).toEtherString();\n\n//       // Get ETH price\n//       const ethPrice = await this.getEthPrice();\n\n//       // Calculate USD cost\n//       const gasCostUsd = parseFloat( gasCostEth ) * ethPrice;\n\n//       return `$${ gasCostUsd.toFixed( 2 ) } (${ gasCostEth } ETH)`;\n//     } catch ( error ) {\n//       log.error( 'Gas estimation error:', false, error );\n//       return 'Unable to estimate gas';\n//     }\n//   }\n\n//   // First one was tested after bottom one\n//   // async estimateSwapGasFee(\n//   //   tokenIn: SwapToken,\n//   //   tokenOut: SwapToken,\n//   //   fromAmount: BigNumberish,\n//   //   slippageTolerance: number,\n//   //   deadline: number,\n//   //   swapManager: UniswapSwapManager,\n//   //   fee: number = 3000,\n//   //   dummyFromAddress: string = '0x0000000000000000000000000000000000000000'\n//   // ): Promise<string> {\n//   //   try {\n//   //     // Convert input values\n//   //     const fromAmountBN = EthereumBigNumber.from( fromAmount );\n//   //     const slippageBN = fromAmountBN.mul( Math.floor( slippageTolerance * 10 ) ).div( 1000 );\n//   //     const minAmountOut = fromAmountBN.sub( slippageBN );\n//   //     const deadlineTimestamp = Math.floor( Date.now() / 1000 ) + deadline * 60;\n//   //     let totalGasEstimate: bigint;\n\n//   //     try {\n//   //       // Attempt to get the exact gas estimate\n//   //       const swapGasEstimate = await swapManager.populateSwapTransaction(\n//   //         Token.fromSwapToken( tokenIn, this.blockchain, this.provider ),\n//   //         Token.fromSwapToken( tokenOut, this.blockchain, this.provider ),\n//   //         fromAmountBN.toString(),\n//   //         minAmountOut.toString(),\n//   //         dummyFromAddress,\n//   //         deadlineTimestamp,\n//   //         fee,\n//   //         true\n//   //       );\n\n//   //       // Check if the result is a bigint (gas estimate) or a TransactionRequest\n//   //       if ( typeof swapGasEstimate === 'bigint' ) {\n//   //         totalGasEstimate = swapGasEstimate;\n//   //       } else {\n//   //         // Use default estimates based on transaction type\n//   //         const isMultiHop = false; // Optional: Set this dynamically based on external logic if available\n//   //         totalGasEstimate = isMultiHop ? 200000n : 150000n;\n//   //       }\n\n//   //       // Add approval gas if not native\n//   //       if ( !tokenIn.isNative ) {\n//   //         totalGasEstimate += 46000n;\n//   //       }\n//   //     } catch {\n//   //       log.error( 'Gas estimation failed, using default.' );\n//   //       totalGasEstimate = ( tokenIn.isNative ? 150000n : 196000n );\n//   //     }\n\n//   //     // Calculate fee in ETH and USD\n//   //     const feeData = await this.provider.getFeeData();\n//   //     const gasPriceGwei = EthereumBigNumber.from( feeData.maxFeePerGas || feeData.gasPrice || 0 );\n//   //     const gasFeeGwei = EthereumBigNumber.from( totalGasEstimate ).mul( gasPriceGwei );\n//   //     const gasFeeEth = EthereumBigNumber.fromGwei( gasFeeGwei.toString() ).toEtherString();\n//   //     const ethPrice = await this.getEthPrice();\n//   //     const gasFeeUsd = parseFloat( gasFeeEth ) * ethPrice;\n\n//   //     return `$${ gasFeeUsd.toFixed( 2 ) } (${ gasFeeEth } ETH)`;\n//   //   } catch ( error ) {\n//   //     log.error( 'Error estimating swap gas fee:', false, error );\n//   //     return 'N/A';\n//   //   }\n//   // }\n\n//   // async estimateSwapGasFee(\n//   //   tokenIn: SwapToken,\n//   //   tokenOut: SwapToken,\n//   //   fromAmount: BigNumberish,\n//   //   slippageTolerance: number,\n//   //   deadline: number,\n//   //   swapManager: UniswapSwapManager,\n//   //   fee: number = 3000,\n//   //   dummyFromAddress: string = '0x0000000000000000000000000000000000000000' // Dummy from address for ETH swaps estimates\n//   // ): Promise<string> {\n//   //   try {\n//   //     if ( !tokenIn || !tokenOut || !fromAmount || !slippageTolerance || !deadline || !swapManager ) {\n//   //       return 'N/A'; //'Invalid parameters'; // Return an error message if any required parameters are missing\n//   //     }\n\n//   //     const fromAmountBN = EthereumBigNumber.from( fromAmount );\n//   //     const slippageBN = fromAmountBN.mul( Math.floor( slippageTolerance * 10 ) ).div( 1000 );\n//   //     const minAmountOut = fromAmountBN.sub( slippageBN );\n//   //     const deadlineTimestamp = Math.floor( Date.now() / 1000 ) + ( deadline * 60 );\n\n//   //     let totalGasEstimate: bigint;\n\n//   //     try {\n//   //       const swapGasEstimate = await swapManager.populateSwapTransaction(\n//   //         Token.fromSwapToken( tokenIn, this.blockchain, this.provider ),\n//   //         Token.fromSwapToken( tokenOut, this.blockchain, this.provider ),\n//   //         fromAmountBN.toString(),\n//   //         minAmountOut.toString(),\n//   //         dummyFromAddress,\n//   //         deadlineTimestamp,\n//   //         fee,\n//   //         true\n//   //       );\n\n//   //       if ( typeof swapGasEstimate === 'bigint' ) {\n//   //         totalGasEstimate = swapGasEstimate;\n//   //       } else {\n//   //         // If we couldn't get an exact estimate, use defaults\n//   //         totalGasEstimate = DEFAULT_GAS_ESTIMATES.SWAP_EXACT_IN;\n\n//   //         // Add approval gas if it's not a native token\n//   //         if ( !tokenIn.isNative ) {\n//   //           totalGasEstimate += DEFAULT_GAS_ESTIMATES.ERC20_APPROVE;\n//   //         }\n//   //       }\n//   //     } catch ( error ) {\n//   //       // log.error( 'Gas estimation failed, using default:', false, error );\n//   //       log.error( 'Gas estimation failed, using defaults...');\n\n//   //       // Use default estimates\n//   //       totalGasEstimate = DEFAULT_GAS_ESTIMATES.SWAP_EXACT_IN;\n\n//   //       // Add approval gas if it's not a native token\n//   //       if ( !tokenIn.isNative ) {\n//   //         totalGasEstimate += DEFAULT_GAS_ESTIMATES.ERC20_APPROVE;\n//   //       }\n//   //     }\n\n//   //     // Calculate fee in ETH\n//   //     const feeData = await this.provider.getFeeData();\n//   //     const gasPriceGwei = EthereumBigNumber.from( feeData.maxFeePerGas || feeData.gasPrice || 0 );\n//   //     const gasFeeGwei = EthereumBigNumber.from( totalGasEstimate ).mul( gasPriceGwei );\n//   //     const gasFeeEth = EthereumBigNumber.fromGwei( gasFeeGwei.toString() ).toEtherString();\n\n//   //     // Get ETH price and calculate USD value\n//   //     const ethPrice = await this.getEthPrice();\n//   //     const gasFeeUsd = parseFloat( gasFeeEth ) * ethPrice;\n\n//   //     return `$${ gasFeeUsd.toFixed( 2 ) } (${ gasFeeEth } ETH)`;\n//   //   } catch ( error ) {\n//   //     log.error( 'Error estimating swap gas fee:', false, error );\n//   //     // Even if everything fails, return a conservative estimate\n//   //     const conservativeGasEstimate = DEFAULT_GAS_ESTIMATES.SWAP_EXACT_IN +\n//   //       ( !tokenIn.isNative ? DEFAULT_GAS_ESTIMATES.ERC20_APPROVE : 0n );\n\n//   //     try {\n//   //       const feeData = await this.provider.getFeeData();\n//   //       const gasPriceGwei = EthereumBigNumber.from( feeData.maxFeePerGas || feeData.gasPrice || 0 );\n//   //       const gasFeeGwei = EthereumBigNumber.from( conservativeGasEstimate ).mul( gasPriceGwei );\n//   //       const gasFeeEth = EthereumBigNumber.fromGwei( gasFeeGwei.toString() ).toEtherString();\n//   //       const ethPrice = await this.getEthPrice();\n//   //       const gasFeeUsd = parseFloat( gasFeeEth ) * ethPrice;\n\n//   //       return `≈ $${ gasFeeUsd.toFixed( 2 ) } (${ gasFeeEth } ETH)`;\n//   //     } catch {\n//   //       return 'N/A';\n//   //     }\n//   //   }\n//   // }\n\n//   async getEthPrice(): Promise<number> {\n//     try {\n//       log.debug('getEthPrice - priceProvider', this.priceProvider);\n\n//       const marketPrice = this.priceProvider.getMarketPrice( 'ETH-USD' );\n//       return ( await marketPrice ).price;\n//     } catch ( error ) {\n//       log.error( 'Error fetching ETH price:', false, error );\n//       // throw error;\n//       return 0;\n//     }\n//   }\n\n//   // factor is a multiplier to adjust the gas price. Default of 1 will return the current gas price\n//   async getCurrentGasPriceInGwei(factor: number = 1): Promise<number> {\n//     const gasPrice = await this.provider.getGasPrice();\n//     // Convert from wei to gwei (1 gwei = 10^9 wei)\n//     return Number( ethersv6.formatUnits( gasPrice, \"gwei\" ) ) * factor;\n//   }\n\n//   async getGasPriceFromEtherscan( apiKey: string ): Promise<number> {\n//     const response = await fetch( `https://api.etherscan.io/api?module=gastracker&action=gasoracle&apikey=${ apiKey }` );\n//     const data = await response.json();\n//     return Number( data.result.ProposeGasPrice ); // returns a standard gas price in gwei\n//   }\n\n//   async getFormattedGasEstimates( gasEstimate: BigNumberish, factor: number = 1.5, gasPriceInGwei: number = 0, ethPriceInUsd: number = 0 ) {\n//     if ( !gasEstimate ) {\n//       throw new Error(\"Gas estimate must be provided\");\n//     }\n\n//     const gasEstimateBigInt = BigNumber.from( gasEstimate ).toBigInt();\n\n//     if ( gasEstimateBigInt! <= 0n ) {\n//       return 0;\n//     }\n\n//     if ( factor <= 0 ) {\n//       factor = 1;\n//       log.warn( 'Factor must be greater than 0 - set to 1' );\n//     }\n\n//     if ( gasPriceInGwei < 0 ) {\n//       gasPriceInGwei = 0;\n//       log.warn( 'Gas price must be greater than or equal to 0 - set to 0' );\n//     }\n\n//     if ( ethPriceInUsd <= 0 ) {\n//       ethPriceInUsd = 0;\n//       log.warn( 'ETH price must be greater than 0 - set to 0' );\n//     }\n\n//     if ( gasPriceInGwei === 0 ) {\n//       // Get the current gas price in gwei\n//       gasPriceInGwei = await this.getCurrentGasPriceInGwei(factor);\n//     }\n\n//     if ( ethPriceInUsd === 0 ) {\n//       // Get the current ETH price in USD\n//       ethPriceInUsd = await this.getEthPrice();\n//     }\n\n//     // Convert gas price from gwei to ETH (1 gwei = 10^-9 ETH)\n//     const gasPriceInEth = gasPriceInGwei * 1e-9;\n//     // Calculate the gas cost in ETH\n//     const gasEstimateInEth = Number(gasEstimate) * gasPriceInEth;  // May want to stay as bigint\n//     // Calculate the gas cost in USD\n//     const gasEstimateInUsd = gasEstimateInEth * ethPriceInUsd;\n\n//     return gasEstimateInUsd;\n//   }\n\n//   setPriceProvider( priceProvider: PriceProvider ): void {\n//     this.priceProvider = priceProvider;\n//   }\n// }\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { fetchJson } from '@ethersproject/web';\nimport type { MarketPriceData, PriceProvider } from '$lib/common/interfaces';\nimport { log } from '$lib/managers/Logger';\n\nexport class CoinbasePriceProvider implements PriceProvider {\n\tgetAPIKey(): string {\n\t\treturn import.meta.env.VITE_COINBASE_API_KEY;\n\t}\n\n\tgetName() {\n\t\treturn 'Coinbase';\n\t}\n\n\tasync getMarketPrice(pair: string): Promise<MarketPriceData> {\n\t\ttry {\n\t\t\tif (!pair) {\n\t\t\t\treturn {\n\t\t\t\t\tprovider: this.getName(),\n\t\t\t\t\tprice: 0,\n\t\t\t\t\tlastUpdated: new Date(),\n\t\t\t\t\tstatus: 404,\n\t\t\t\t\tmessage: `Invalid pair - ${pair}`\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tpair = await this.getProviderPairFormat(pair);\n\n\t\t\tconst [tokenIn, tokenOut] = pair.split('-');\n\t\t\tif (!tokenIn || !tokenOut) {\n\t\t\t\treturn {\n\t\t\t\t\tprovider: this.getName(),\n\t\t\t\t\tprice: 0,\n\t\t\t\t\tlastUpdated: new Date(),\n\t\t\t\t\tstatus: 404,\n\t\t\t\t\tmessage: `Invalid pair - ${pair}`\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (tokenIn === 'USDC') {\n\t\t\t\t// Coinbase has declared USD:USDC as an alias to each other and always $1 in value\n\t\t\t\treturn {\n\t\t\t\t\tprovider: this.getName(),\n\t\t\t\t\tprice: parseFloat('1.00'),\n\t\t\t\t\tlastUpdated: new Date(),\n\t\t\t\t\tcurrency: tokenOut,\n\t\t\t\t\tstatus: 0,\n\t\t\t\t\tmessage: ''\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (tokenIn === 'WETH') {\n\t\t\t\tpair = `ETH-${tokenOut}`;\n\t\t\t}\n\t\t\tif (tokenIn === 'WBTC') {\n\t\t\t\tpair = `BTC-${tokenOut}`;\n\t\t\t}\n\n\t\t\tconst json = await fetchJson(\n\t\t\t\t`https://api.coinbase.com/api/v3/brokerage/market/products?limit=1&product_ids=${pair}`\n\t\t\t); // WETH is not supported by Coinbase\n\n\t\t\tif (json.num_products <= 0) {\n\t\t\t\treturn {\n\t\t\t\t\tprovider: this.getName(),\n\t\t\t\t\tprice: 0,\n\t\t\t\t\tlastUpdated: new Date(),\n\t\t\t\t\tstatus: 404,\n\t\t\t\t\tmessage: `No data found for - ${pair}`\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tprovider: this.getName(),\n\t\t\t\tprice: parseFloat(json.products[0].price),\n\t\t\t\tlastUpdated: new Date(),\n\t\t\t\tcurrency: tokenOut,\n\t\t\t\tstatus: 0,\n\t\t\t\tmessage: ''\n\t\t\t};\n\t\t} catch (e: any) {\n\t\t\tlog.error('CoinbasePriceProvider - getPrice - error', e);\n\n\t\t\tlet status = 404; // Default status\n\t\t\tlet message = `Error - ${e}`;\n\n\t\t\tif (e.response && e.response.status === 429) {\n\t\t\t\t// Handle 429 Too Many Requests error\n\t\t\t\tstatus = 429;\n\t\t\t\tmessage = 'Too Many Requests - Rate limit exceeded';\n\t\t\t}\n\n\t\t\t// log.debug( 'CoinbasePriceProvider - getPrice - error', status, message );\n\n\t\t\treturn {\n\t\t\t\tprovider: this.getName(),\n\t\t\t\tprice: 0,\n\t\t\t\tlastUpdated: new Date(),\n\t\t\t\tstatus,\n\t\t\t\tmessage\n\t\t\t};\n\t\t}\n\t}\n\n\tasync getProviderPairFormat(pair: string) {\n\t\treturn pair;\n\t}\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { BaseFeeManager } from './FeeManager';\nimport { EthereumGasProvider } from '$managers/providers/fees/ethereum/EthereumGasProvider';\nimport type {\n\tFeeManager,\n\tGasEstimate,\n\tGasPrediction,\n\tHistoricalGasData\n} from '$lib/common/gas-types';\nimport {\n\ttype AccountInfo,\n\ttype BaseTransaction,\n\ttype BigNumberish,\n\ttype Block,\n\ttype BlockTag,\n\ttype BlockWithTransactions,\n\ttype Deferrable,\n\ttype Filter,\n\ttype Log,\n\ttype MetaData,\n\ttype Transaction,\n\ttype TransactionReceipt,\n\ttype TransactionRequest,\n\ttype TransactionResponse,\n\ttype YakklPrimaryAccount,\n\ttype Network,\n\ttype IMAGEPATH\n} from '$lib/common';\nimport type { Signer } from '$managers/Signer';\nimport type { Provider } from '$managers/Provider';\nimport type { AbstractContract } from './Contract';\nimport { CoinbasePriceProvider } from './providers/price/coinbase/CoinbasePriceProvider';\nimport type { ethers as ethersv6 } from 'ethers-v6';\nimport { log } from './Logger';\nimport { GasProviderFactory } from './GasProviderFactory';\n\nexport interface ContractInterface {\n\taddress: string;\n\tabi: readonly any[]; // Change this line\n\tfunctions: Record<string, (...args: any[]) => Promise<any>>;\n\tcall(functionName: string, ...args: any[]): Promise<any>;\n}\n\n/**\n * Interface for blockchain interactions.\n */\nexport interface Blockchain {\n\tprovider: Provider;\n\tname: string; // Name of the blockchain\n\tnetworks: Network[]; // List of networks supported by this blockchain (e.g. Mainnet, Testnet) - The specific blockchain should set the networks it supports\n\tnetwork: Network; // Current network\n\tchainId: number; // Current chainId\n\tsymbol: string; // Symbol of the blockchain, e.g. 'ETH'\n\ticon: IMAGEPATH; // Icon of the blockchain (could be a URL, path or base64 encoded string)\n\tproviders: Provider[]; // List of providers supported by this blockchain\n\toptions: { [key: string]: MetaData }; // Additional options for the blockchain (optional)\n\n\t// Contract: new (address: string, abi: any[], signerOrProvider: Provider | Signer) => ContractInterface;\n\tcreateContract(\n\t\taddress: string,\n\t\tabi: any[],\n\t\tproviderNative?: ethersv6.JsonRpcProvider | null | undefined\n\t): AbstractContract | null;\n\n\t// getContract(address: string, abi: any): Promise<any>; // Replace 'any' with appropriate types\n\n\t/**\n\t * Gets a gas estimate for a transaction.\n\t * @param transaction - The transaction request to estimate gas for.\n\t * @returns A promise that resolves to a gas estimate.\n\t */\n\tgetGasEstimate(transaction: TransactionRequest): Promise<GasEstimate>;\n\n\t/**\n\t * Gets historical gas data.\n\t * @param duration - The duration for which to fetch historical data.\n\t * @returns A promise that resolves to an array of historical gas data.\n\t */\n\tgetHistoricalGasData(duration: number): Promise<HistoricalGasData[]>;\n\n\t/**\n\t * Predicts future gas fees.\n\t * @param duration - The duration for which to predict future fees.\n\t * @returns A promise that resolves to an array of gas predictions.\n\t */\n\tpredictFutureFees(duration: number): Promise<GasPrediction[]>;\n\n\t/**\n\t * Calls a transaction.\n\t * @param transaction - The transaction request to call.\n\t * @param blockTag - Optional block tag.\n\t * @returns The result of the call.\n\t */\n\tcall(\n\t\ttransaction: Deferrable<TransactionRequest>,\n\t\tblockTag?: BlockTag | Promise<BlockTag>\n\t): Promise<string>;\n\n\t/**\n\t * Connects the blockchain to a provider with a specific chain ID.\n\t * @param provider - The provider to connect.\n\t * @param chainId - The chain ID to connect.\n\t */\n\tconnect(provider: Provider, chainId: number): void;\n\n\t/**\n\t * Creates a new account.\n\t * @param accountToDeriveFrom - The primary account to derive from, if any.\n\t * @param accountInfo - Information about the account.\n\t * @returns The created account.\n\t */\n\tcreateAccount<T>(\n\t\taccountToDeriveFrom: YakklPrimaryAccount | null,\n\t\taccountInfo: AccountInfo\n\t): Promise<T>;\n\n\testimateGas(transaction: Deferrable<TransactionRequest>): Promise<bigint>;\n\n\t// Getters for blockchain information\n\tgetBlockchainName(): string;\n\tgetChainId(): number;\n\tgetNetwork(): Network;\n\tgetNetworkByChainId(chainId: number): Network;\n\tgetIcon(): IMAGEPATH;\n\tgetNetworks(): Network[];\n\tgetSymbol(): string;\n\tsetChainId(chainId: number): void;\n\tsetNetwork(network: Network): Network; // Sets the current network and returns the old network or null if not found\n\tsetNetworkByChainId(chainId: number): Network; // Sets the current network by chain ID and returns the old network or null if not found\n\n\t// Queries\n\tgetBalance(\n\t\taddressOrName: string | Promise<string>,\n\t\tblockTag?: BlockTag | Promise<BlockTag>\n\t): Promise<bigint>;\n\tgetBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block>;\n\tgetBlockNumber(): Promise<number>;\n\tgetBlockWithTransactions(\n\t\tblockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>\n\t): Promise<BlockWithTransactions>;\n\tgetCode(\n\t\taddressOrName: string | Promise<string>,\n\t\tblockTag?: BlockTag | Promise<BlockTag>\n\t): Promise<string>;\n\tgetFeeData(): Promise<any>;\n\tgetGasPrice(): Promise<bigint>;\n\tgetLogs(filter: Filter): Promise<Array<Log>>;\n\tgetOptions(blockchain: string): MetaData | undefined;\n\tgetProvider(): Provider;\n\tgetProviders(): Provider[];\n\tgetProviderList(): string[];\n\tgetSigner(): Signer | null;\n\tgetSignerNative(): any | null;\n\tgetStorageAt(\n\t\taddressOrName: string | Promise<string>,\n\t\tposition: BigNumberish | Promise<BigNumberish>,\n\t\tblockTag?: BlockTag | Promise<BlockTag>\n\t): Promise<string>;\n\tgetTransaction(transactionHash: string): Promise<any>;\n\tgetTransactionCount(\n\t\taddressOrName: string | Promise<string>,\n\t\tblockTag?: BlockTag | Promise<BlockTag>\n\t): Promise<number>;\n\tgetTransactionReceipt(transactionHash: string): Promise<TransactionReceipt>;\n\tgetTransactionHistory(address: string): Promise<any>;\n\n\tisNetworkAndChainIdValid(chainId: number): boolean;\n\n\t/**\n\t * Checks if an address is valid.\n\t * @param address - The address to check.\n\t * @returns Whether the address is valid.\n\t */\n\tisAddress(address: string): boolean;\n\n\t/**\n\t * Checks if an address is a smart contract.\n\t * @param address - The address to check.\n\t * @returns Whether the address is a smart contract.\n\t */\n\tisSmartContract(address: string): Promise<boolean>;\n\n\t/**\n\t * Checks if a given blockchain supports smart contracts.\n\t * @returns Whether the supports a smart contract.\n\t */\n\tisSmartContractSupported(): boolean;\n\n\t/**\n\t * Calls a specific blockchain method.\n\t * @param method - The method to call.\n\t * @param params - The parameters for the method.\n\t * @returns The result of the request.\n\t */\n\trequest(method: string, params: any[]): Promise<any>;\n\n\t// Execution\n\tsendRawTransaction(signedTransaction: string): Promise<TransactionResponse>;\n\tsendTransaction(transaction: TransactionRequest): Promise<TransactionResponse>;\n\tsetProvider(provider: Provider, chainId: number): void;\n\tsignMessage(message: string): Promise<string>;\n\tsignTransaction(transaction: Transaction): Promise<string>;\n\tsignTypedData(transaction: Transaction): Promise<string>;\n}\n\n/**\n * Abstract class representing a blockchain.\n */\nexport abstract class AbstractBlockchain<T extends BaseTransaction> implements Blockchain {\n\tprovider: Provider;\n\tproviders: Provider[] = [];\n\tchainId: number;\n\tnetworks: Network[] = [];\n\tnetwork: Network;\n\tsymbol: string;\n\ticon: IMAGEPATH;\n\tname: string;\n\toptions: { [key: string]: MetaData };\n\tprotected feeManager!: FeeManager;\n\n\t/**\n\t * Creates an instance of AbstractBlockchain. This class should be extended by specific blockchain implementations.\n\t * @param name - The name of the blockchain.\n\t * @param chainId - The chain ID of the blockchain to be set as current.\n\t * @param providers - The providers supported by this blockchain.\n\t * @param options - Additional options for the blockchain.\n\t */\n\tconstructor(\n\t\tname: string,\n\t\tchainId: number,\n\t\tproviders: Provider[],\n\t\tnetworks: Network[],\n\t\tsymbol: string,\n\t\ticon: IMAGEPATH,\n\t\toptions: { [key: string]: MetaData } = {}\n\t) {\n\t\tthis.name = name;\n\t\tthis.providers = providers;\n\t\tif (providers.length === 0) throw new Error('Providers list cannot be empty');\n\t\tthis.chainId = chainId;\n\t\tthis.networks = networks; // providers, networks and chainId are critical\n\t\tthis.options = options;\n\t\tthis.symbol = symbol;\n\t\tthis.icon = icon;\n\t\tthis.network = this.getNetwork();\n\n\t\tif (!this.isNetworkAndChainIdValid(chainId))\n\t\t\tthrow new Error('Unsupported network and chain. Please check the chain ID and/or networks');\n\t\tif (!this.providers || this.providers.length === 0)\n\t\t\tthrow new Error('Providers list cannot be empty');\n\n\t\tthis.provider = providers[0]; // Default to the first provider\n\t\t// this.feeManager = new BaseFeeManager( [ new EthereumGasProvider( this.provider, this, new CoinbasePriceProvider() ) ] );\n\t\tthis.feeManager = new BaseFeeManager();\n\t\tthis.initializeBlockchain().catch((error) => {\n\t\t\tlog.error('Failed to initialize blockchain:', false, error);\n\t\t});\n\t}\n\n\tprivate async initializeBlockchain(): Promise<void> {\n\t\ttry {\n\t\t\tif (!this.provider) {\n\t\t\t\tthrow new Error('Provider not initialized');\n\t\t\t}\n\n\t\t\tconst gasProvider = await EthereumGasProvider.create(\n\t\t\t\tthis.provider,\n\t\t\t\tthis,\n\t\t\t\tnew CoinbasePriceProvider()\n\t\t\t);\n\n\t\t\tawait this.feeManager.addProvider(gasProvider);\n\t\t} catch (error) {\n\t\t\tlog.error('Failed to initialize blockchain:', false, false, error);\n\t\t\t// Don't throw, just log the error\n\t\t}\n\t}\n\n\t// Add a method to check initialization status\n\tprivate async isInitialized(): Promise<boolean> {\n\t\ttry {\n\t\t\tconst providers = this.feeManager.getProviders();\n\t\t\treturn providers.length > 0;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Add method to check if initialization is complete\n\tprivate async ensureInitialized(): Promise<void> {\n\t\tconst providers = this.feeManager.getProviders();\n\t\tif (!this.feeManager || providers.length === 0) {\n\t\t\tthrow new Error('Blockchain not properly initialized');\n\t\t}\n\t}\n\n\t// abstract Contract: new (address: string, abi: any[], signerOrProvider: Provider | Signer) => ContractInterface;\n\t// abstract getContract(address: string, abi: any[]): Promise<ContractInterface>;\n\tabstract createContract(address: string, abi: any[]): AbstractContract | null;\n\n\t// async estimateGas(transaction: TransactionRequest): Promise<bigint> {\n\t//   const estimate = await this.feeManager.getGasEstimate(transaction);\n\t//   return BigNumber.from(estimate.gasLimit).toBigInt() ?? BigInt(0);\n\t// }\n\n\tasync getGasEstimate(transaction: TransactionRequest): Promise<GasEstimate> {\n\t\tif (!(await this.isInitialized())) {\n\t\t\tthrow new Error('Gas provider not initialized');\n\t\t}\n\t\treturn this.feeManager.getGasEstimate(transaction);\n\t}\n\n\tasync getHistoricalGasData(duration: number): Promise<HistoricalGasData[]> {\n\t\tif (!this.feeManager || !duration) throw new Error('Fee manager or duration not set');\n\t\treturn await this.feeManager.getHistoricalGasData(duration);\n\t}\n\n\tasync predictFutureFees(duration: number): Promise<GasPrediction[]> {\n\t\tif (!this.feeManager || !duration) throw new Error('Fee manager or duration not set');\n\t\treturn await this.feeManager.predictFutureFees(duration);\n\t}\n\n\t/**\n\t * Calls a transaction.\n\t * @param transaction - The transaction request to call.\n\t * @param blockTag - Optional block tag.\n\t * @returns The result of the call.\n\t */\n\tasync call(transaction: Deferrable<TransactionRequest>, blockTag: any): Promise<string> {\n\t\tif (!transaction) throw new Error('Transaction not set');\n\t\ttry {\n\t\t\treturn await this.provider.call(transaction, blockTag);\n\t\t} catch (e) {\n\t\t\tthrow new Error(`Error calling - call: ${e}`);\n\t\t}\n\t}\n\n\t/**\n\t * Connects the blockchain to a provider with a specific chain ID.\n\t * @param provider - The provider to connect.\n\t * @param chainId - The chain ID to connect.\n\t */\n\tconnect(provider: Provider, chainId: number): void {\n\t\tif (!this.providers || !this.providers.includes(provider))\n\t\t\tthrow new Error('Provider(s) not supported');\n\t\tif (!this.isNetworkAndChainIdValid(chainId)) throw new Error('Unsupported network and chain');\n\n\t\tthis.provider = provider;\n\t\tthis.chainId = chainId;\n\t}\n\n\tabstract createAccount<T>(\n\t\taccountToDeriveFrom: YakklPrimaryAccount | null,\n\t\taccountInfo: AccountInfo\n\t): Promise<T>;\n\tabstract estimateGas(transaction: Deferrable<TransactionRequest>): Promise<bigint>;\n\n\tgetBlockchainName(): string {\n\t\treturn this.name;\n\t}\n\n\tgetChainId(): number {\n\t\treturn this.chainId;\n\t}\n\n\tgetNetwork(): Network {\n\t\tthis.network =\n\t\t\tthis.networks.find((network) => network.chainId === this.chainId) || this.networks[0];\n\t\treturn this.network;\n\t}\n\n\tgetNetworkByChainId(chainId: number): Network {\n\t\tif (!chainId) throw new Error('Chain ID not set');\n\t\tif (!this.isNetworkAndChainIdValid(chainId)) throw new Error('Unsupported network and chain');\n\t\treturn this.networks.find((network) => network.chainId === chainId) || this.networks[0];\n\t}\n\n\tgetIcon(): IMAGEPATH {\n\t\treturn this.icon;\n\t}\n\n\tgetNetworks(): Network[] {\n\t\tlog.info('Blockchain networks', false, this.networks);\n\t\treturn this.networks;\n\t}\n\n\tgetSymbol(): string {\n\t\treturn this.symbol;\n\t}\n\n\t// May need to check if there is a current provider and if that provider supports the chainId\n\t// If not, throw an error or switch to a provider that supports the chainId\n\t// May also need to check if the chainId is supported by the blockchain itself (e.g. Ethereum)\n\t// If not, throw an error or switch to a chainId that is supported\n\t// May also need to make sure that the chainId is valid (e.g. not 0) - if not, throw an error. We don't want to change to chainId on a different blockchain! The blockchain should be able to handle this.\n\tasync setChainId(chainId: number): Promise<void> {\n\t\tif (!chainId) throw new Error('Chain ID not set');\n\t\tif (!this.isNetworkAndChainIdValid(chainId)) throw new Error('Unsupported network and chain');\n\n\t\tif (this.chainId === chainId) {\n\t\t\treturn;\n\t\t}\n\t\tif (chainId <= 0) {\n\t\t\tthrow new Error('Invalid chain ID');\n\t\t}\n\t\t// Check if the provider supports the chainId\n\t\tif (this.provider.getChainIds() && !this.provider.getChainIds().includes(chainId)) {\n\t\t\tthrow new Error('Provider does not support chain ID');\n\t\t}\n\t\t// Check if the blockchain supports the chainId\n\t\tif (this.networks.find((network) => network.chainId === chainId) === undefined) {\n\t\t\tthrow new Error('Blockchain does not support chain ID');\n\t\t}\n\t\tthis.network = this.getNetworkByChainId(chainId);\n\t\tthis.chainId = chainId;\n\t}\n\n\t// Everything pulls from the current network object\n\tsetNetwork(network: Network): Network {\n\t\tif (!network) throw new Error('Network not set');\n\t\ttry {\n\t\t\tif (!this.networks.includes(network)) {\n\t\t\t\treturn this.network; // Return the current network if not found\n\t\t\t}\n\t\t\tconst oldNetwork = this.network;\n\t\t\tthis.network = network;\n\t\t\treturn oldNetwork;\n\t\t} catch (e) {\n\t\t\tthrow new Error(`Error calling - switchNetwork: ${e}`);\n\t\t}\n\t}\n\n\tsetNetworkByChainId(chainId: number): Network {\n\t\tif (!chainId) throw new Error('Chain ID not set');\n\t\ttry {\n\t\t\tconst network = this.getNetworkByChainId(chainId);\n\t\t\treturn this.setNetwork(network);\n\t\t} catch (e) {\n\t\t\tthrow new Error(`Error calling - switchNetwork: ${e}`);\n\t\t}\n\t}\n\n\t/**\n\t * Gets the balance of an address.\n\t * @param address - The address to get the balance for.\n\t * @returns The balance of the address.\n\t */\n\tasync getBalance(address: string): Promise<bigint> {\n\t\ttry {\n\t\t\tif (!address) return 0n;\n\t\t\treturn await this.provider.getBalance(address);\n\t\t} catch (e) {\n\t\t\tthrow new Error(`Error calling - getBalance: ${e}`);\n\t\t}\n\t}\n\n\tabstract getBlock(blockHashOrBlockTag: BlockTag | Promise<BlockTag>): Promise<Block>;\n\tabstract getBlockNumber(): Promise<number>;\n\tabstract getBlockWithTransactions(\n\t\tblockHashOrBlockTag: BlockTag | Promise<BlockTag>\n\t): Promise<BlockWithTransactions>;\n\tabstract getCode(\n\t\taddressOrName: string | Promise<string>,\n\t\tblockTag?: BlockTag | Promise<BlockTag>\n\t): Promise<string>;\n\tabstract getFeeData(): Promise<any>;\n\tabstract getGasPrice(): Promise<bigint>;\n\tabstract getLogs(filter: Filter): Promise<Log[]>;\n\n\t/**\n\t * Gets the options for a blockchain.\n\t * @param blockchain - The blockchain to get options for.\n\t * @returns The options for the blockchain.\n\t */\n\tgetOptions(blockchain: string): MetaData | undefined {\n\t\tif (!blockchain) throw new Error('Blockchain not set');\n\t\treturn this.options[blockchain];\n\t}\n\n\t/**\n\t * Gets the current provider.\n\t * @returns The current provider.\n\t */\n\tgetProvider(): Provider {\n\t\treturn this.provider;\n\t}\n\n\tgetSigner(): Signer | null {\n\t\treturn this.provider.getSigner();\n\t}\n\n\tgetSignerNative(): any | null {\n\t\treturn this.provider.getSignerNative();\n\t}\n\n\t/**\n\t * Gets the list of providers supported by this blockchain.\n\t * @returns The list of providers.\n\t */\n\tgetProviders(): Provider[] {\n\t\treturn this.providers;\n\t}\n\n\t/**\n\t * Gets the list of provider names supported by this blockchain.\n\t * @returns The list of provider names.\n\t */\n\tgetProviderList(): string[] {\n\t\treturn this.providers.map((provider) => provider.name);\n\t}\n\n\tisNetworkAndChainIdValid(chainId: number): boolean {\n\t\tif (!chainId) throw new Error('Chain ID not set');\n\t\treturn this.networks.find((network) => network.chainId === chainId) !== undefined;\n\t}\n\n\tabstract getStorageAt(\n\t\taddressOrName: string | Promise<string>,\n\t\tposition: BigNumberish | Promise<BigNumberish>,\n\t\tblockTag?: BlockTag | Promise<BlockTag>\n\t): Promise<string>;\n\n\tabstract getTransaction(transactionHash: string): Promise<any>;\n\tabstract getTransactionCount(\n\t\taddressOrName: string | Promise<string>,\n\t\tblockTag?: BlockTag | Promise<BlockTag>\n\t): Promise<number>;\n\tabstract getTransactionHistory(address: string): Promise<any>;\n\tabstract getTransactionReceipt(transactionHash: string): Promise<TransactionReceipt>;\n\n\tabstract isAddress(address: string): boolean;\n\tabstract isSmartContract(address: string): Promise<boolean>;\n\tabstract resolveName(name: string | Promise<string>): Promise<null | string>;\n\tabstract lookupAddress(address: string | Promise<string>): Promise<null | string>;\n\n\tabstract sendTransaction(transaction: TransactionRequest): Promise<TransactionResponse>;\n\n\tisSmartContractSupported(): boolean {\n\t\treturn false; // Default to false - override in subclasses\n\t}\n\n\t/**\n\t * Calls a specific blockchain method.\n\t * @param method - The method to call.\n\t * @param params - The parameters for the method.\n\t * @returns The result of the request.\n\t */\n\tasync request(method: string, params: any[]): Promise<any> {\n\t\ttry {\n\t\t\treturn await this.provider.request(method, params);\n\t\t} catch (e) {\n\t\t\tthrow new Error(`Error calling - request - ${method}: ${e}`);\n\t\t}\n\t}\n\n\t/**\n\t * Sends a raw transaction.\n\t * @param signedTransaction - The signed transaction to send.\n\t * @returns The transaction response.\n\t */\n\tasync sendRawTransaction(signedTransaction: string): Promise<TransactionResponse> {\n\t\ttry {\n\t\t\treturn await this.provider.sendRawTransaction(signedTransaction);\n\t\t} catch (e) {\n\t\t\tthrow new Error(`Error calling - sendTransaction: ${e}`);\n\t\t}\n\t}\n\n\t/**\n\t * Sets the provider for the blockchain.\n\t * @param provider - The provider to set.\n\t * @param chainId - The chain ID to set.\n\t */\n\tsetProvider(provider: Provider, chainId: number): void {\n\t\tif (!this.providers.includes(provider)) {\n\t\t\tthrow new Error('Provider not supported');\n\t\t}\n\t\tthis.provider = provider;\n\t\tthis.chainId = chainId;\n\t}\n\n\tabstract signTransaction(transaction: TransactionRequest): Promise<string>;\n\tabstract signMessage(message: string): Promise<string>;\n\tabstract signTypedData(transction: TransactionRequest): Promise<string>;\n\n\t/**\n\t * Protected method to add or override metadata.\n\t * @param newOptions - The new options to add or override.\n\t * @param overrideAll - Whether to override all existing options.\n\t */\n\tprotected _updateOptions(\n\t\tnewOptions: { [key: string]: MetaData },\n\t\toverrideAll: boolean = false\n\t): void {\n\t\tif (overrideAll) {\n\t\t\tthis.options = newOptions;\n\t\t} else {\n\t\t\tthis.options = { ...this.options, ...newOptions };\n\t\t}\n\t}\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { type BigNumberish, type TransactionRequest, type TransactionResponse } from '$lib/common';\nimport type { Provider } from '$managers/Provider';\nimport { Signer } from './Signer';\n// import type { Signer } from '$plugins/Signer';\n// import { ethers as ethersv6 } from 'ethers-v6';\n\nexport abstract class AbstractContract {\n\tprotected address: string;\n\tprotected abi: readonly any[];\n\tprotected provider: Provider | null;\n\tabstract interface: any; // Add this to support interface operations\n\n\t// Added providerNative to the constructor - may need to be removed\n\tconstructor(address: string, abi: any[], provider: Provider) {\n\t\tif (!address || !abi || !provider) throw new Error('Invalid parameters');\n\n\t\tthis.address = address;\n\t\tthis.abi = abi;\n\n\t\t// if (this.isSigner(provider)) {\n\t\t//   this.signer = provider;\n\t\t//   this.provider = provider.provider;\n\t\t// } else {\n\t\tthis.provider = provider;\n\t\t// Note: We're not setting this.signer here as it's not available from a Provider\n\t\t// }\n\t}\n\n\tprivate isSigner(value: Provider | Signer): value is Signer {\n\t\tif (!value) return false;\n\t\treturn 'signMessage' in value && typeof value.signMessage === 'function';\n\t}\n\n\tabstract call(functionName: string, ...args: any[]): Promise<any>;\n\tabstract estimateGas(functionName: string, ...args: any[]): Promise<BigNumberish>;\n\tabstract populateTransaction(\n\t\tfunctionName: string,\n\t\t...args: any[]\n\t): Promise<TransactionRequest | null>;\n\tabstract sendTransaction(functionName: string, ...args: any[]): Promise<TransactionResponse>;\n\tabstract encodeFunctionData(functionName: string, args?: any[]): string;\n\tabstract on(eventName: string, listener: (...args: any[]) => void): void;\n\tabstract off(eventName: string, listener: (...args: any[]) => void): void;\n\tabstract once(eventName: string, listener: (...args: any[]) => void): void;\n\tabstract getFunctions(): Record<string, (...args: any[]) => Promise<any>>;\n\tabstract getEvents(): string[];\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { AbstractContract } from '$managers/Contract';\nimport { type BigNumberish, type TransactionRequest, type TransactionResponse } from '$lib/common';\nimport type { Provider } from '$managers/Provider';\n// import type { Signer } from '$plugins/Signer';\nimport { ethers as ethersv6 } from 'ethers-v6';\nimport { EthersConverter } from '$managers/utilities/EthersConverter';\nimport type { FunctionFragment, EventFragment } from 'ethers-v6';\nimport { log } from '$lib/managers/Logger';\n\nexport class EthereumContract extends AbstractContract {\n\tprivate contract: ethersv6.Contract;\n\tinterface: ethersv6.Interface;\n\n\t// Added providerNative to the constructor - may need to be removed\n\tconstructor(address: string, abi: any[], provider: Provider) {\n\t\tsuper(address, abi, provider);\n\n\t\t// Create contract instance with the given provider or fallback to default provider\n\t\tthis.contract = new ethersv6.Contract(address, abi, provider.getSignerNative());\n\n\t\tif (!this.contract) {\n\t\t\tthrow new Error('Invalid contract');\n\t\t}\n\n\t\tthis.interface = new ethersv6.Interface(abi);\n\t\tif (!this.interface) {\n\t\t\tthrow new Error('Invalid interface');\n\t\t}\n\t}\n\n\tasync call(functionName: string, ...args: any[]): Promise<any> {\n\t\ttry {\n\t\t\tif (!functionName || !this.interface)\n\t\t\t\tthrow new Error('Invalid function name or invalid interface');\n\t\t\tif (!this.interface.getFunction(functionName))\n\t\t\t\tthrow new Error(`Function ${functionName} does not exist on contract`);\n\n\t\t\treturn await this.contract[functionName](...args);\n\t\t} catch (error) {\n\t\t\tlog.error(`Error calling ${functionName}:`, false, error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync estimateGas(functionName: string, ...args: any[]): Promise<BigNumberish> {\n\t\ttry {\n\t\t\tif (!functionName || !this.interface)\n\t\t\t\tthrow new Error('Invalid function name or invalid interface');\n\t\t\tif (!this.interface.getFunction(functionName))\n\t\t\t\tthrow new Error(`Function ${functionName} does not exist on contract`);\n\n\t\t\t// Get the function from the contract\n\t\t\tconst contractFunction = (this.contract as any)[functionName];\n\t\t\tif (typeof contractFunction !== 'function') {\n\t\t\t\tthrow new Error(`${functionName} is not a function`);\n\t\t\t}\n\n\t\t\t// Estimate gas using the bound estimateGas function\n\t\t\tconst estimation = await contractFunction.estimateGas(...args);\n\t\t\treturn BigInt(estimation.toString());\n\t\t} catch (error) {\n\t\t\tlog.error(`Error estimating gas for ${functionName}:`, false, error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync populateTransaction(\n\t\tfunctionName: string,\n\t\t...args: any[]\n\t): Promise<TransactionRequest | null> {\n\t\ttry {\n\t\t\tif (!functionName || !this.interface)\n\t\t\t\tthrow new Error('Invalid function name or invalid interface');\n\t\t\tif (!this.interface.getFunction(functionName))\n\t\t\t\tthrow new Error(`Function ${functionName} does not exist on contract`);\n\n\t\t\t// Get the function from the contract\n\t\t\tconst contractFunction = (this.contract as any)[functionName];\n\t\t\tif (typeof contractFunction !== 'function') {\n\t\t\t\tthrow new Error(`${functionName} is not a function`);\n\t\t\t}\n\n\t\t\t// Populate the transaction using the bound populateTransaction function\n\t\t\tconst tx = await contractFunction.populateTransaction(...args);\n\t\t\tif (!tx) throw new Error('Invalid transaction from populate transaction');\n\t\t\treturn EthersConverter.ethersTransactionRequestToTransactionRequest(tx);\n\t\t} catch (error) {\n\t\t\tlog.error(`Error populating transaction for ${functionName}:`, false, error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync sendTransaction(functionName: string, ...args: any[]): Promise<TransactionResponse> {\n\t\ttry {\n\t\t\tif (!this.interface.getFunction(functionName)) {\n\t\t\t\tthrow new Error(`Function ${functionName} does not exist on contract`);\n\t\t\t}\n\n\t\t\tconst tx = await this.contract[functionName](...args);\n\t\t\tif (!tx) throw new Error('Invalid transaction from send transaction');\n\n\t\t\treturn EthersConverter.ethersTransactionResponseToTransactionResponse(tx);\n\t\t} catch (error) {\n\t\t\tlog.error(`Error sending transaction for ${functionName}:`, false, error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tencodeFunctionData(functionName: string, args: any[] = []): string {\n\t\tif (!this.interface.getFunction(functionName)) {\n\t\t\tthrow new Error(`Function ${functionName} does not exist on contract`);\n\t\t}\n\t\treturn this.interface.encodeFunctionData(functionName, args);\n\t}\n\n\ton(eventName: string, listener: (...args: any[]) => void): void {\n\t\tthis.contract.on(eventName, listener);\n\t}\n\n\toff(eventName: string, listener: (...args: any[]) => void): void {\n\t\tthis.contract.off(eventName, listener);\n\t}\n\n\tonce(eventName: string, listener: (...args: any[]) => void): void {\n\t\tthis.contract.once(eventName, listener);\n\t}\n\n\tgetFunctions(): Record<string, (...args: any[]) => Promise<any>> {\n\t\tconst functions: Record<string, (...args: any[]) => Promise<any>> = {};\n\n\t\t// Get all function fragments from the interface\n\t\tconst functionFragments = Object.values(\n\t\t\tObject.fromEntries(\n\t\t\t\tObject.entries(this.interface.fragments).filter(\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\t\t([_, fragment]) => fragment.type === 'function'\n\t\t\t\t)\n\t\t\t)\n\t\t) as FunctionFragment[];\n\n\t\t// Create function entries\n\t\tfunctionFragments.forEach((fragment) => {\n\t\t\tfunctions[fragment.name] = (...args: any[]) => this.call(fragment.name, ...args);\n\t\t});\n\n\t\treturn functions;\n\t}\n\n\tgetEvents(): string[] {\n\t\t// Get all event fragments from the interface\n\t\tconst eventFragments = Object.values(\n\t\t\tObject.fromEntries(\n\t\t\t\tObject.entries(this.interface.fragments).filter(\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\t\t([_, fragment]) => fragment.type === 'event'\n\t\t\t\t)\n\t\t\t)\n\t\t) as EventFragment[];\n\n\t\treturn eventFragments.map((event) => event.name);\n\t}\n\n\t// WIP\n\t//   async supportsPermit( tokenAddress: string ) {\n\t//   try {\n\t//     const token = new ethersv6.Contract( tokenAddress, [\n\t//       \"function permit(address,address,uint256,uint256,uint8,bytes32,bytes32)\"\n\t//     ], this.provider?.getProvider() );\n\t//     return !!( await token.estimateGas.permit() ); // If estimation does not revert, permit is likely supported\n\t//   } catch ( error ) {\n\t//     return false;\n\t//   }\n\t// }\n\n\t// WIP\n\t//   async permitAndApprove( token, owner, spender, value, nonce, deadline, v, r, s, signer ) {\n\t//   const tokenContract = new ethersv6.Contract( token, [\n\t//     \"function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\"\n\t//   ], signer );\n\n\t//   await tokenContract.permit( owner, spender, value, deadline, v, r, s );\n\t// }\n\n\t// WIP Usage:\n\t//   if( await supportsPermit( tokenAddress, provider )) {\n\t//   try {\n\t//     await permitAndApprove( tokenAddress, owner, spender, value, nonce, deadline, v, r, s, signer );\n\t//   } catch ( error ) {\n\t//     log.error( 'Permit failed, falling back to approve:', false, error );\n\t//     await tokenContract.approve( spender, value );\n\t//   }\n\t// } else {\n\t//   await tokenContract.approve( spender, value );\n\t// }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport {\n\ttype AccountData,\n\ttype AccountInfo,\n\ttype Deferrable,\n\ttype EthereumTransaction,\n\ttype MetaData,\n\ttype TransactionReceipt,\n\ttype TransactionRequest,\n\ttype TransactionResponse,\n\ttype YakklAccount,\n\ttype YakklPrimaryAccount,\n\ttype Block,\n\ttype BlockTag,\n\ttype BlockWithTransactions,\n\ttype Filter,\n\ttype Log,\n\ttype PrimaryAccountData,\n\tAccountTypeCategory,\n\tVERSION,\n\ttype Network,\n\tNetworkType,\n\ttype BigNumberish\n} from '$lib/common';\nimport { dateString } from '$lib/common/datetime';\nimport { AbstractBlockchain } from '$managers/Blockchain';\nimport type { Provider } from '$managers/Provider';\nimport { ethers as ethersv6 } from 'ethers-v6';\nimport { EthereumContract } from './EthereumContract';\nimport type { AbstractContract } from '$lib/managers/Contract';\n\nconst networks: Network[] = [\n\t{\n\t\tblockchain: 'Ethereum',\n\t\tname: 'Mainnet',\n\t\tchainId: 1,\n\t\tsymbol: 'ETH',\n\t\ttype: NetworkType.MAINNET,\n\t\texplorer: 'https://etherscan.io',\n\t\tdecimals: 18\n\t},\n\t{\n\t\tblockchain: 'Ethereum',\n\t\tname: 'Sepolia',\n\t\tchainId: 11155111,\n\t\tsymbol: 'ETH',\n\t\ttype: NetworkType.TESTNET,\n\t\texplorer: 'https://sepolia.etherscan.io',\n\t\tdecimals: 18\n\t},\n\t{\n\t\tblockchain: 'Unichain',\n\t\tname: 'Sepolia',\n\t\tchainId: 1301,\n\t\tsymbol: 'ETH',\n\t\ttype: NetworkType.TESTNET,\n\t\texplorer: 'https://sepolia.uniscan.xyz/',\n\t\tdecimals: 18\n\t}\n];\n\n// Unichain Sepolia Testnet RPC: https://sepolia.unichain.org/\n\nexport class Ethereum extends AbstractBlockchain<EthereumTransaction> {\n\t_options: MetaData | undefined;\n\n\tconstructor(\n\t\tproviders: Provider[],\n\t\tchainId: number = 1,\n\t\toptions: { [key: string]: MetaData } = {},\n\t\toverrideAll: boolean = false\n\t) {\n\t\tsuper('Ethereum', chainId, providers, networks, 'ETH', '/images/ethereum_icon_purple.svg');\n\t\tthis.chainId = chainId;\n\t\tthis.options = options;\n\t\tthis._updateOptions(options, overrideAll);\n\t\tthis._options = this.getOptions('ethereum');\n\t}\n\n\tasync createAccount<T>(\n\t\taccountToDeriveFrom: YakklPrimaryAccount | null = null,\n\t\taccountInfo: AccountInfo\n\t): Promise<T> {\n\t\tif (!accountInfo) throw new Error('Account info is missing');\n\t\tif (accountToDeriveFrom === null) {\n\t\t\treturn this.createPrimaryAccount(accountInfo) as unknown as T;\n\t\t} else {\n\t\t\tif (!accountInfo.path) throw new Error('Derive Path is missing from the account info');\n\t\t\treturn this.createSubAccount(accountToDeriveFrom, accountInfo.path) as unknown as T;\n\t\t}\n\t}\n\n\tasync estimateGas(transaction: Deferrable<TransactionRequest>): Promise<bigint> {\n\t\tif (!transaction) throw new Error('Transaction is missing');\n\t\treturn await this.provider.estimateGas(transaction);\n\t}\n\n\tasync getBalance(\n\t\taddressOrName: string | Promise<string>,\n\t\tblockTag?: BlockTag | Promise<BlockTag>\n\t): Promise<bigint> {\n\t\tif (!addressOrName) throw new Error('Address is missing');\n\t\treturn await this.provider.getBalance(\n\t\t\taddressOrName,\n\t\t\tblockTag !== undefined ? blockTag : 'latest'\n\t\t);\n\t}\n\n\tasync getBlock(blockHashOrBlockTag: BlockTag | Promise<BlockTag>): Promise<Block> {\n\t\tif (!blockHashOrBlockTag) throw new Error('Block hash or tag is missing');\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tasync getBlockNumber(): Promise<number> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tasync getBlockWithTransactions(\n\t\tblockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>\n\t): Promise<BlockWithTransactions> {\n\t\tif (!blockHashOrBlockTag) throw new Error('Block hash or tag is missing');\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tasync getCode(\n\t\taddressOrName: string | Promise<string>,\n\t\tblockTag?: BlockTag | Promise<BlockTag>\n\t): Promise<string> {\n\t\tif (!addressOrName) throw new Error('Address is missing');\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tasync getFeeData(): Promise<any> {\n\t\treturn await this.provider.getFeeData();\n\t}\n\n\tasync getGasPrice(): Promise<bigint> {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tasync getLogs(filter: Filter): Promise<Array<Log>> {\n\t\tif (!filter) throw new Error('Filter is missing');\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tasync getStorageAt(\n\t\taddressOrName: string | Promise<string>,\n\t\tposition: BigNumberish | Promise<BigNumberish>,\n\t\tblockTag?: BlockTag | Promise<BlockTag>\n\t): Promise<string> {\n\t\tif (!addressOrName) throw new Error('Address is missing');\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tasync signTypedData(transction: TransactionRequest): Promise<string> {\n\t\tif (!transction) throw new Error('Transaction is missing');\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\tasync getTransaction(transactionHash: string): Promise<EthereumTransaction> {\n\t\tif (!transactionHash) throw new Error('Transaction hash is missing');\n\t\treturn await this.provider.getTransaction(transactionHash);\n\t}\n\n\tasync getTransactionCount(\n\t\taddressOrName: string | Promise<string>,\n\t\tblockTag?: BlockTag | Promise<BlockTag>\n\t): Promise<number> {\n\t\tif (!addressOrName) throw new Error('Address is missing');\n\t\treturn await this.provider.getTransactionCount(addressOrName, blockTag);\n\t}\n\n\tasync getTransactionHistory(address: string): Promise<any> {\n\t\tif (!address) throw new Error('Address is missing');\n\t\treturn await this.provider.getTransactionHistory(address);\n\t}\n\n\tasync getTransactionReceipt(transactionHash: string): Promise<TransactionReceipt> {\n\t\tif (!transactionHash) throw new Error('Transaction hash is missing');\n\t\treturn await this.provider.getTransactionReceipt(transactionHash);\n\t}\n\n\tisAddress(address: string): boolean {\n\t\tconst returnValue = ethersv6.isAddress(address);\n\t\treturn returnValue;\n\t}\n\n\tasync isSmartContract(address: string): Promise<boolean> {\n\t\tif (!this.isAddress(address)) return false;\n\t\tlet contractCode: string | null;\n\t\ttry {\n\t\t\tcontractCode = await this.provider.getCode(address);\n\t\t} catch (e) {\n\t\t\tcontractCode = null;\n\t\t}\n\t\treturn (contractCode && contractCode !== '0x' && contractCode !== '0x0') as boolean;\n\t}\n\n\tisSmartContractSupported(): boolean {\n\t\treturn true; // Ethereum supports smart contracts\n\t}\n\n\tasync request(method: string, params: any[]): Promise<any> {\n\t\treturn await this.provider.request(method, params);\n\t}\n\n\tasync sendTransaction(transaction: TransactionRequest): Promise<TransactionResponse> {\n\t\treturn await this.provider.sendTransaction(transaction);\n\t}\n\n\tasync sendRawTransaction(signedTransaction: string): Promise<TransactionResponse> {\n\t\treturn await this.provider.sendRawTransaction(signedTransaction);\n\t}\n\n\tasync signTransaction(transaction: TransactionRequest): Promise<string> {\n\t\treturn await this.provider.signTransaction(transaction);\n\t}\n\n\tasync signMessage(message: string): Promise<string> {\n\t\treturn await this.provider.signMessage(message);\n\t}\n\n\tprivate async createPrimaryAccount(accountInfo: AccountInfo): Promise<YakklPrimaryAccount> {\n\t\tconst entropy = ethersv6.randomBytes(32);\n\t\tif (!entropy) throw new Error('Error generating entropy for the mnemonic');\n\n\t\tconst randomMnemonic = ethersv6.Mnemonic.fromEntropy(entropy);\n\t\tif (!randomMnemonic) throw new Error('Error generating mnemonic from entropy');\n\n\t\tconst ethWallet = ethersv6.HDNodeWallet.fromMnemonic(randomMnemonic, accountInfo.path);\n\t\tif (!ethWallet) throw new Error('Error creating wallet from mnemonic');\n\n\t\tconst accountData: AccountData = {\n\t\t\textendedKey: ethWallet.extendedKey,\n\t\t\tprivateKey: ethWallet.privateKey,\n\t\t\tpublicKey: ethWallet.publicKey,\n\t\t\tpublicKeyUncompressed: ethWallet.publicKey, //ethWallet.signingKey.publicKey,\n\t\t\tpath: ethWallet.path ? ethWallet.path : accountInfo.path,\n\t\t\tpathIndex: accountInfo.index,\n\t\t\tfingerPrint: ethWallet.fingerprint,\n\t\t\tparentFingerPrint: ethWallet.parentFingerprint,\n\t\t\tchainCode: ethWallet.chainCode,\n\t\t\tassignedTo: [] // Who are the parties that have responsibility for this account\n\t\t};\n\n\t\tconst yakklAccount: YakklAccount = {\n\t\t\tid: accountInfo.id,\n\t\t\tindex: accountInfo.index,\n\t\t\tblockchain: 'Ethereum',\n\t\t\tsmartContract: false,\n\t\t\taddress: ethWallet.address,\n\t\t\talias: '',\n\t\t\taccountType: AccountTypeCategory.PRIMARY,\n\t\t\tname: !accountInfo.accountName\n\t\t\t\t? `Portfolio Level Account ${accountInfo.index + 1}`\n\t\t\t\t: accountInfo.accountName,\n\t\t\tdescription: '',\n\t\t\tprimaryAccount: null, // If subaccount then it must be a valid primaryaccount else undefined\n\t\t\tdata: accountData,\n\t\t\tquantity: 0n,\n\t\t\tclass: 'Default', // This is only used for enterprise like environments. It can be used for departments like 'Finance', 'Accounting', '<whatever>'\n\t\t\tlevel: 'L1',\n\t\t\tisSigner: true,\n\t\t\tavatar: '', // Default is identityicon but can be changed to user/account avatar\n\t\t\ttags: ['Ethereum', 'primary'],\n\t\t\tincludeInPortfolio: true, // This only applys to the value in this primary account and not any of the derived accounts from this primary account\n\t\t\tconnectedDomains: [],\n\t\t\tversion: VERSION,\n\t\t\tcreateDate: dateString(),\n\t\t\tupdateDate: dateString()\n\t\t};\n\n\t\tconst primaryAccountData: PrimaryAccountData = {\n\t\t\textendedKey: ethWallet.extendedKey,\n\t\t\tprivateKey: ethWallet.privateKey,\n\t\t\tpublicKey: ethWallet.publicKey,\n\t\t\tpublicKeyUncompressed: ethWallet.publicKey,\n\t\t\tpath: ethWallet.path ? ethWallet.path : accountInfo.path,\n\t\t\tpathIndex: accountInfo.index,\n\t\t\tfingerPrint: ethWallet.fingerprint,\n\t\t\tparentFingerPrint: ethWallet.parentFingerprint,\n\t\t\tchainCode: ethWallet.chainCode,\n\t\t\tmnemonic: randomMnemonic.phrase,\n\t\t\tentropy: entropy,\n\t\t\tpassword: ethWallet.mnemonic?.password,\n\t\t\twordCount: ethWallet.mnemonic?.phrase.split(' ').length || 24,\n\t\t\twordListLocale: ethWallet.mnemonic?.wordlist.locale || 'en'\n\t\t};\n\n\t\tconst primaryAccount: YakklPrimaryAccount = {\n\t\t\tid: accountInfo.id,\n\t\t\tname: 'Primary Account',\n\t\t\taddress: ethWallet.address,\n\t\t\tquantity: 0n,\n\t\t\tindex: 0,\n\t\t\tdata: primaryAccountData,\n\t\t\taccount: {} as YakklAccount,\n\t\t\tsubIndex: 0,\n\t\t\tsubAccounts: [] as YakklAccount[],\n\t\t\tversion: VERSION,\n\t\t\tcreateDate: dateString(),\n\t\t\tupdateDate: dateString()\n\t\t};\n\n\t\treturn primaryAccount;\n\t}\n\n\tprivate async createSubAccount(\n\t\tprimaryAccount: YakklPrimaryAccount,\n\t\tderivedPath: string\n\t): Promise<YakklAccount> {\n\t\tconst mnemonic = (primaryAccount.data as PrimaryAccountData).mnemonic;\n\t\tif (!mnemonic) throw new Error('Mnemonic is missing from the primary account data');\n\n\t\tconst ethWallet = ethersv6.HDNodeWallet.fromPhrase(mnemonic, undefined, derivedPath);\n\t\tif (!ethWallet) throw new Error('Error deriving sub account from primary account');\n\n\t\tconst accountData: AccountData = {\n\t\t\textendedKey: ethWallet.extendedKey,\n\t\t\tprivateKey: ethWallet.privateKey,\n\t\t\tpublicKey: ethWallet.publicKey,\n\t\t\tpublicKeyUncompressed: ethWallet.publicKey,\n\t\t\tpath: ethWallet.path as string,\n\t\t\tpathIndex: primaryAccount.subIndex + 1,\n\t\t\tfingerPrint: ethWallet.fingerprint,\n\t\t\tparentFingerPrint: (primaryAccount.data as PrimaryAccountData).fingerPrint,\n\t\t\tchainCode: '',\n\t\t\tassignedTo: []\n\t\t};\n\n\t\tconst subAccount: YakklAccount = {\n\t\t\tid: '1', // TODO: Generate a unique ID\n\t\t\tindex: primaryAccount.subIndex + 1,\n\t\t\tblockchain: 'Ethereum',\n\t\t\tsmartContract: false,\n\t\t\taddress: ethWallet.address,\n\t\t\talias: 'New Sub Account',\n\t\t\taccountType: AccountTypeCategory.SUB,\n\t\t\tname: 'Sub Account Name',\n\t\t\tdescription: 'Description of the sub account',\n\t\t\tprimaryAccount: primaryAccount,\n\t\t\tdata: accountData,\n\t\t\tquantity: 0n,\n\t\t\tclass: 'standard',\n\t\t\tlevel: 'L1',\n\t\t\tisSigner: true,\n\t\t\tavatar: 'default-avatar.png',\n\t\t\ttags: [],\n\t\t\tincludeInPortfolio: true,\n\t\t\tconnectedDomains: [],\n\t\t\tversion: '1.0',\n\t\t\tcreateDate: new Date().toISOString(),\n\t\t\tupdateDate: new Date().toISOString()\n\t\t};\n\n\t\treturn subAccount;\n\t}\n\n\tasync resolveName(name: string | Promise<string>): Promise<null | string> {\n\t\tif (!name) return null;\n\t\treturn await this.provider.resolveName(name);\n\t}\n\n\tasync lookupAddress(address: string | Promise<string>): Promise<null | string> {\n\t\tif (!address) return null;\n\t\treturn await this.provider.lookupAddress(address);\n\t}\n\n\tcreateContract(address: string, abi: any[]): AbstractContract | null {\n\t\tif (!address || !abi) return null;\n\t\treturn new EthereumContract(address, abi, this.provider); // this.provider could be null - if so, it will thrown an error\n\t}\n}\n","// constants-evm.ts\nimport ERC20_ABI from './abis/erc20.json';\n// import UNISWAP_V3_FACTORY_ABI from './abis/uniswap-v3-factory.json';  // Instead, use from uniswap-v3-sdk\n// import UNISWAP_V3_ROUTER_ABI from './abis/uniswap-v3-router.json';\n// import UNISWAP_V3_QUOTER_ABI from './abis/uniswap-v3-quoter.json';\n// import UNISWAP_V3_POOL_ABI from './abis/uniswap-v3-pool.json';\n\nexport const ABIs = {\n\tERC20: ERC20_ABI\n\t//   UNISWAP_V3_FACTORY: UNISWAP_V3_FACTORY_ABI,\n\t//   UNISWAP_V3_ROUTER: UNISWAP_V3_ROUTER_ABI,\n\t//   // UNISWAP_V3_QUOTER: UNISWAP_V3_QUOTER_ABI,\n\t//   UNISWAP_V3_POOL: UNISWAP_V3_POOL_ABI,\n\t//   // Add more ABIs as needed\n};\n\n// Contract addresses on mainnet\nexport const ADDRESSES = {\n\tYAKKL: '0x2B64822cf4bbDd77d386F51AA2B40c5cdbeb80b5', // YAKKL token address - replace with actual address when ready!\n\tUNISWAP_FACTORY: '0x1F98431c8aD98523631AE4a59f267346ea31F984',\n\tUNISWAP_FACTORY_SEPOLIA: '0x0227628f3F023bb0B980b67D528571c95c6DaC1c',\n\tUNISWAP_V3_ROUTER: '0xE592427A0AEce92De3Edee1F18E0157C05861564', //0x84E44095eeBfEC7793Cd7d5b57B7e401D7f1cA2E\n\tUNISWAP_V3_ROUTER_SEPOLIA: '0x3bFA4769FB09eefC5a80d6E87c3B9C650f7Ae48E',\n\tUNISWAP_V3_QUOTER: '0x61fFE014bA17989E743c5F6cB21bF9697530B21e', //\"0x61fFE014bA17989E743c5F6cB21bF9697530B21e\", // 0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6 - V1 address\n\tUNISWAP_V3_QUOTER_SEPOLIA: '0xEd1f6473345F45b75F8179591dd5bA1888cf2FB3',\n\tUNISWAP_UNIVERSAL_ROUTER: '0xEf1c6E67703c7BD7107eed8303Fbe6EC2554BF6B',\n\tUNISWAP_UNIVERSAL_ROUTER_SEPOLIA: '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD',\n\tSUSHISWAP_FACTORY: '0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac', // Mainnet\n\tSUSHISWAP_FACTORY_SEPOLIA: '0x...',\n\tWETH: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', // WETH9 - most common WETH contract address\n\tWETH_SEPOLIA: '0xfFf9976782d46cc05630D1f6EbAB18B2324d6B14',\n\tWBTC: '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599',\n\tUSDC: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\n\tUSDT: '0xdAC17F958D2ee523a2206206994597C13D831ec7',\n\tDAI: '0x6B175474E89094C44Da98b954EedeAC495271d0F'\n\t// Add more addresses as needed\n};\n\n// NOTE: May want to update the ADDRESSES values to support dynamic data from our servers.\n\n// ! Danger Zone: DO NOT USE ON MAINNET NOR ANY TESTNET! Only for LOCAL testing purposes on Anvil Fork of LOCAL Mainnet Ethereum.\n\n// Foundry test accounts to be used for testing only - DO NOT USE ON MAINNET! These are meant for Foundry's Anvil Fork of LOCAL Mainnet Ethereum.\nexport const EOA_TEST_ACCOUNTS = [\n\t'0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n\t'0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n\t'0x3c44cdddb6a900fa2b585dd299e03d12fa4293bc',\n\t'0x90f79bf6eb2c4f870365e785982e1f101e93b906',\n\t'0x15d34aaf54267db7d7c367839aaf71a00a2c6a65',\n\t'0x9965507d1a55bcc2695c58ba16fb37d819b0a4dc',\n\t'0x976ea74026e726554db657fa54763abd0c3a0aa9',\n\t'0x14dc79964da2c08b23698b3d3cc7ca32193d9955',\n\t'0x23618e81e3f5cdf7f54c3d65f7fbc0abf5b21e8f',\n\t'0xa0ee7a142d267c1f36714e4a8f75612f20a79720'\n\t// Add more test accounts if needed\n];\n\n// Foundry test account private keys - DO NOT USE ON MAINNET! These are meant for Foundry's Anvil Fork of LOCAL Mainnet Ethereum.\nexport const EOA_TEST_ACCOUNTS_PRIVATE_KEYS = [\n\t'0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80',\n\t'0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d',\n\t'0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a',\n\t'0x7c852118294e51e653712a81e05800f419141751be58f605c371e15141b007a6',\n\t'0x47e179ec197488593b187f80a00eb0da91f1b9d0b13f8733639f19c30a34926a',\n\t'0x8b3a350cf5c34c9194ca85829a2df0ec3153be0318b5e2d3348e872092edffba',\n\t'0x92db14e403b83dfe3df233f83dfa3a0d7096f21ca9b0d6d6b8d88b2b4ec1564e',\n\t'0x4bbbf85ce3377467afe5d46f804f221813b2bb87f24d81f60f1fcdbf7cbf4356',\n\t'0xdbda1821b80551c9d65939329250298aa3472ba22feea921c0cf5d620ea67b97',\n\t'0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6'\n\t// Add more test account private keys if needed\n];\n","/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { Provider } from '$managers/Provider';\nimport type { Blockchain } from '$managers/Blockchain';\nimport {\n\tisYakklPrimaryAccount,\n\ttype AccountInfo,\n\ttype Transaction,\n\ttype TransactionRequest,\n\ttype TransactionResponse,\n\ttype TypedDataDomain,\n\ttype TypedDataField,\n\ttype YakklAccount,\n\ttype YakklPrimaryAccount\n} from '$lib/common';\nimport eventManager from '$managers/EventManager';\nimport ProviderFactory from '$managers/ProviderFactory';\nimport BlockchainFactory from '$managers/BlockchainFactory';\nimport { Signer } from '$managers/Signer';\nimport { Ethereum, EthereumSigner } from '$managers/blockchains';\nimport { writable } from 'svelte/store';\nimport type { GasEstimate, HistoricalGasData, GasPrediction } from '$lib/common/gas-types';\nimport type { Token } from '$managers/Token';\nimport { TokenService } from './blockchains/evm/TokenService';\nimport { log } from '$lib/common/logger-wrapper';\nimport { browserSvelte, browser_ext } from '$lib/common/environment';\n\nexport const walletStore = writable<Wallet | null>(null);\n\n/**\n * Wallet class to manage blockchain interactions, switching providers, and handling accounts and tokens.\n */\nexport class Wallet {\n\tprivate provider: Provider | null = null;\n\tprivate blockchain: Blockchain | null = null;\n\tprivate signer: Signer | null = null;\n\tprivate portfolio: Token[] = [];\n\tprivate currentToken: Token | null = null;\n\tprivate accounts: YakklAccount[] = [];\n\t// private currentAccount: YakklAccount | null = null;\n\tprivate apiKey: string | null = null;\n\tprivate chainId: number;\n\tprivate privateKey: string | null = null; // This is the user's private key\n\tprivate tokenService: TokenService<any> | null = null;\n\n\t/**\n\t * Creates an instance of Wallet.\n\t * @param providerNames - List of provider names.\n\t * @param blockchainNames - List of blockchain names.\n\t * @param privateKey - Optional private key for the wallet.\n\t */\n\tconstructor(\n\t\tprivate providerNames: string[] = ['Alchemy'],\n\t\tprivate blockchainNames: string[] = ['Ethereum'],\n\t\tchainId: number = 1,\n\t\tapiKey: string | null = null,\n\t\tprivateKey: string | null = null\n\t) {\n\t\tthis.apiKey = apiKey; // Set the private key if provided else use setPrivateKey method before attempting to send transactions - This is the provider API Key and not the user's private key\n\t\tthis.chainId = chainId; // Have to do this before initializing the wallet\n\t\tthis.setChainId(chainId);\n\t\tthis.privateKey = privateKey; // This is the user's private key\n\t\tthis.initialize();\n\t\tWallet.setInstance(this); // Any change to the wallet instance should update the store\n\n\t\t// Send initial state change message\n\t\tif (browserSvelte) {\n\t\t\tbrowser_ext.runtime\n\t\t\t\t.sendMessage({\n\t\t\t\t\ttype: 'YAKKL_STATE_CHANGE',\n\t\t\t\t\tdata: { chainId }\n\t\t\t\t})\n\t\t\t\t.catch((error: Error) => {\n\t\t\t\t\tlog.error('Error sending initial chain change message', true, error);\n\t\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Initializes the wallet by setting up providers and blockchains.\n\t */\n\tprivate initialize(): void {\n\t\tif (this.providerNames.length > 0) {\n\t\t\t// Initialize all providers\n\t\t\tconst providers = this.providerNames.map((name) =>\n\t\t\t\tProviderFactory.createProvider({ name, apiKey: this.apiKey, chainId: this.chainId })\n\t\t\t);\n\t\t\t// Set the first provider as the primary provider\n\t\t\tthis.provider = providers[0];\n\t\t\t// Initialize the blockchain with all providers\n\t\t\tconst blockchainName = this.getBlockchainFromChainId(this.chainId);\n\t\t\tthis.blockchain = BlockchainFactory.createBlockchain(blockchainName, providers);\n\t\t\tthis.tokenService = new TokenService<any>(this.blockchain as Ethereum);\n\t\t}\n\n\t\tthis.setupEventListeners();\n\t\tif (this.privateKey) {\n\t\t\tthis.setSigner(this.privateKey);\n\t\t}\n\t\tWallet.setInstance(this);\n\t}\n\n\tprivate static setInstance(instance: Wallet): void {\n\t\twalletStore.set(instance);\n\t}\n\n\t/**\n\t * Adds a token to the wallet's portfolio.\n\t * @param token - The token to add to the portfolio.\n\t */\n\tpublic addTokenToPortfolio(token: Token): void {\n\t\tthis.portfolio.push(token);\n\t\tWallet.setInstance(this);\n\t}\n\n\t/**\n\t * Creates a new account.\n\t * @param accountToDeriveFrom - The primary account to derive from, if any.\n\t * @param accountInfo - Information about the account.\n\t * @returns The created account.\n\t */\n\tpublic async createAccount<T>(\n\t\taccountToDeriveFrom: YakklPrimaryAccount | null = null,\n\t\taccountInfo: AccountInfo\n\t): Promise<T> {\n\t\tif (!this.blockchain) {\n\t\t\tthrow new Error('Blockchain not initialized');\n\t\t}\n\t\tconst newAccount = await this.blockchain.createAccount<T>(accountToDeriveFrom, accountInfo);\n\t\tif (isYakklPrimaryAccount(newAccount)) {\n\t\t\tthis.addAccount(newAccount as unknown as YakklPrimaryAccount);\n\t\t} else {\n\t\t\tthis.addAccount(newAccount as unknown as YakklAccount);\n\t\t}\n\t\tWallet.setInstance(this);\n\t\treturn newAccount;\n\t}\n\n\t/**\n\t * Estimates the gas required for a transaction.\n\t * @param transaction - The transaction to estimate gas for.\n\t * @returns The estimated gas.\n\t */\n\tpublic async estimateGas(transaction: Transaction): Promise<bigint> {\n\t\tif (!this.blockchain) {\n\t\t\tthrow new Error('Blockchain not initialized');\n\t\t}\n\t\treturn await this.blockchain.estimateGas(transaction);\n\t}\n\n\t/**\n\t * Gets the balance of an address.\n\t * @param address - The address to get the balance for.\n\t * @returns The balance of the address.\n\t */\n\tasync getBalance(address: string): Promise<bigint> {\n\t\tif (!this.blockchain) {\n\t\t\tthrow new Error('Blockchain not initialized');\n\t\t}\n\t\treturn await this.blockchain.getBalance(address);\n\t}\n\n\t/**\n\t * Gets the current blockchain.\n\t * @returns The current blockchain.\n\t */\n\tpublic getBlockchain(): Blockchain | Ethereum {\n\t\tswitch (this.chainId) {\n\t\t\t// Add other casts here\n\t\t\tcase 1: // Mainnet\n\t\t\tcase 11155111: // Testnet - Sepolia\n\t\t\tdefault:\n\t\t\t\treturn this.blockchain as Ethereum;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the current blockchain name.\n\t * @returns The current blockchain name.\n\t */\n\tpublic getBlockchainFromChainId(chainId: number): string {\n\t\tswitch (chainId) {\n\t\t\tcase 137:\n\t\t\t\treturn 'Polygon';\n\t\t\tcase 43114:\n\t\t\t\treturn 'Avalanche';\n\t\t\tcase 42161:\n\t\t\t\treturn 'Arbitrum';\n\t\t\tcase 250:\n\t\t\t\treturn 'Optimism';\n\t\t\tcase 1:\n\t\t\tcase 11155111:\n\t\t\tdefault:\n\t\t\t\treturn 'Ethereum';\n\t\t}\n\t}\n\n\tpublic getTokenService(): TokenService<any> | null {\n\t\treturn this.tokenService;\n\t}\n\n\tpublic getChainId(): number {\n\t\treturn this.chainId;\n\t}\n\n\t/**\n\t * Gets the current token.\n\t * @returns The current token.\n\t */\n\tpublic getCurrentToken(): Token | null {\n\t\treturn this.currentToken;\n\t}\n\n\t/**\n\t * Gets the portfolio of tokens.\n\t * @returns The portfolio of tokens.\n\t */\n\tpublic getPortfolio(): Token[] {\n\t\treturn this.portfolio;\n\t}\n\n\t/**\n\t * Gets the current provider.\n\t * @returns The current provider.\n\t */\n\tpublic getProvider(): Provider | null {\n\t\treturn this.provider;\n\t}\n\n\t/**\n\t * Gets the transaction history for an address.\n\t * @param address - The address to get the transaction history for.\n\t * @returns The transaction history.\n\t */\n\tpublic async getTransactionHistory(address: string): Promise<Transaction[]> {\n\t\tif (!this.blockchain) {\n\t\t\tthrow new Error('Blockchain not initialized');\n\t\t}\n\t\treturn await this.blockchain.getTransactionHistory(address);\n\t}\n\n\t/**\n\t * Handles provider connected event.\n\t * @param data - Data containing provider, blockchain, and chainId.\n\t */\n\tprivate onProviderConnected(data: {\n\t\tprovider: string;\n\t\tblockchain: string;\n\t\tchainId: number;\n\t}): void {\n\t\t// console.log(`onConnected to ${data.provider} on ${data.blockchain} with chainId ${data.chainId}`);\n\t\tWallet.setInstance(this);\n\t}\n\n\t/**\n\t * Handles balance fetched event.\n\t * @param data - Data containing address and balance.\n\t */\n\tprivate onBalanceFetched(data: { address: string; balance: bigint }): void {\n\t\t// console.log(`onBalance event for fetched ${data.address}: XXXXXXXX`, this.chainId);\n\t\tWallet.setInstance(this);\n\t}\n\n\t/**\n\t * Handles provider switched event.\n\t * @param data - Data containing old provider and new provider.\n\t */\n\tprivate onProviderSwitched(data: { oldProvider: string; newProvider: string }): void {\n\t\t// console.log(`onProvider switched from ${data.oldProvider} to ${data.newProvider}`);\n\t\tWallet.setInstance(this);\n\t}\n\n\t/**\n\t * Handles error event.\n\t * @param data - Data containing provider, method, and error.\n\t */\n\tprivate onError(data: { provider: string; method: string; error: any }): void {\n\t\t// console.log(`onError in provider ${data.provider}, method ${data.method}:`, data.error);\n\t\tWallet.setInstance(this);\n\t}\n\n\t/**\n\t * Handles request made event.\n\t * @param data - Data containing provider, method, params, and result.\n\t */\n\tprivate onRequestMade(data: {\n\t\tprovider: string;\n\t\tmethod: string;\n\t\tparams: any[];\n\t\tresult: any;\n\t}): void {\n\t\t// console.log(`onRequest made to ${data.provider} with method ${data.method}:`, data.result);\n\t\tWallet.setInstance(this);\n\t}\n\n\tasync setChainId(chainId: number): Promise<void> {\n\t\tthis.chainId = chainId;\n\t\tthis.blockchain?.setChainId(chainId);\n\t\tthis.provider?.setChainId(chainId);\n\t\tWallet.setInstance(this);\n\n\t\t// Send state change message for chain ID update\n\t\tif (browserSvelte) {\n\t\t\tbrowser_ext.runtime\n\t\t\t\t.sendMessage({\n\t\t\t\t\ttype: 'YAKKL_STATE_CHANGE',\n\t\t\t\t\tdata: { chainId }\n\t\t\t\t})\n\t\t\t\t.catch((error: Error) => {\n\t\t\t\t\tlog.error('Error sending chain change message', true, error);\n\t\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Sets the API key for the wallet provider.\n\t * @param apiKey - The API key to set.\n\t */\n\tsetAPIKey(apiKey: string): void {\n\t\tthis.apiKey = apiKey;\n\t\tWallet.setInstance(this);\n\t}\n\n\t/**\n\t * Sets the current token by its address.\n\t * @param tokenAddress - The address of the token to set as current.\n\t */\n\tpublic setCurrentToken(tokenAddress: string): void {\n\t\tconst token = this.portfolio.find((t) => t.address === tokenAddress);\n\t\tif (!token) {\n\t\t\tthrow new Error(`Token with address ${tokenAddress} not found in portfolio`);\n\t\t}\n\t\tthis.currentToken = token;\n\t\tthis.provider = token.provider;\n\t\tthis.blockchain = token.blockchain;\n\t\tWallet.setInstance(this);\n\t}\n\n\t/**\n\t * Sets up event listeners for the wallet.\n\t */\n\tprivate setupEventListeners(): void {\n\t\teventManager.on('balanceFetched', this.onBalanceFetched.bind(this));\n\t\teventManager.on('error', this.onError.bind(this));\n\t\teventManager.on('providerConnected', this.onProviderConnected.bind(this));\n\t\teventManager.on('providerSwitched', this.onProviderSwitched.bind(this));\n\t\teventManager.on('requestMade', this.onRequestMade.bind(this));\n\t\tWallet.setInstance(this);\n\t}\n\n\t/**\n\t * Sets the signer for the wallet based on the current token and private key.\n\t */\n\tpublic setSigner(privateKey: string | null): Promise<Signer> | null {\n\t\ttry {\n\t\t\tif (!this.blockchain) {\n\t\t\t\tlog.warn('Blockchain is not initialized yet');\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (!this.provider) {\n\t\t\t\tlog.warn('Provider is not initialized yet');\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// privateKey can be null if the system is initializing so we simply log and return\n\t\t\tif (!privateKey && !this.privateKey) {\n\t\t\t\tlog.warn('No private key provided yet');\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tswitch (\n\t\t\t\tthis.blockchain.name //this.currentToken.blockchain.name) {\n\t\t\t) {\n\t\t\t\tcase 'Ethereum':\n\t\t\t\t\tthis.signer = new EthereumSigner(privateKey, this.provider);\n\t\t\t\t\tbreak;\n\t\t\t\t// case 'Polygon':\n\t\t\t\t//   this.signer = new PolygonSigner(this.privateKey);\n\t\t\t\t//   break;\n\t\t\t\t// case 'Optimism':\n\t\t\t\t//   this.signer = new OptimismSigner(this.privateKey);\n\t\t\t\t//   break;\n\t\t\t\t// case 'Arbitrum':\n\t\t\t\t//   this.signer = new ArbitrumSigner(this.privateKey);\n\t\t\t\t//   break;\n\t\t\t\t// case 'Avalanche':\n\t\t\t\t//   this.signer = new AvalancheSigner(this.privateKey);\n\t\t\t\t//   break;\n\t\t\t\t// case 'Base':\n\t\t\t\t//   this.signer = new BaseSigner(this.privateKey);\n\t\t\t\t//   break;\n\t\t\t\t// case 'Celo':\n\t\t\t\t//   this.signer = new CeloSigner(this.privateKey);\n\t\t\t\t//   break;\n\t\t\t\t// case 'Bitcoin':\n\t\t\t\t//   this.signer = new BitcoinSigner(this.privateKey);\n\t\t\t\t//   break;\n\t\t\t\t// case 'Solana':\n\t\t\t\t//   this.signer = new SolanaSigner(Uint8Array.from(Buffer.from(this.privateKey, 'base64')));\n\t\t\t\t//   break;\n\t\t\t\t// case 'Aptos':\n\t\t\t\t//   this.signer = new AptosSigner(this.privateKey);\n\t\t\t\t//   break;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unsupported blockchain: ${this.blockchain.name}`); //${this.currentToken.blockchain.name}`);\n\t\t\t}\n\t\t\tif (this.signer) {\n\t\t\t\tthis.privateKey = privateKey; // Set the private key for the user for signing transactions of the current token.\n\t\t\t\tWallet.setInstance(this);\n\t\t\t\tthis.provider.setSigner(this.signer);\n\t\t\t\treturn Promise.resolve(this.signer);\n\t\t\t} else {\n\t\t\t\tthrow new Error('Signer could not be created');\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlog.error('Error setting signer:', false, error);\n\t\t\treturn Promise.reject(error);\n\t\t}\n\t}\n\n\tpublic getSigner(): Signer | null {\n\t\treturn this.signer;\n\t}\n\n\t// SwitchNetwork is implemented with setChainId since the provider and blockchain remain the same.\n\n\t/**\n\t * Switches to a different provider.\n\t */\n\tpublic switchProvider(): void {\n\t\tif (!this.blockchain || !this.provider) {\n\t\t\tthrow new Error('Blockchain or Provider not initialized');\n\t\t}\n\n\t\tconst availableProviders = this.providerNames\n\t\t\t.map((name) =>\n\t\t\t\tProviderFactory.createProvider({ name, apiKey: this.privateKey, chainId: this.chainId })\n\t\t\t) // Create instances of all available providers using defaults\n\t\t\t.filter((provider) => provider.blockchains.includes(this.blockchain!.name));\n\n\t\tconst newProvider = availableProviders.find((provider) => provider !== this.provider);\n\t\tif (newProvider) {\n\t\t\tconst chainId: number = this.provider.chainId;\n\t\t\tconst oldProviderName: string = this.provider.name;\n\n\t\t\tthis.provider = newProvider;\n\t\t\tthis.blockchain.connect(newProvider, chainId);\n\t\t\teventManager.emit('providerSwitched', {\n\t\t\t\toldProvider: oldProviderName,\n\t\t\t\tnewProvider: newProvider.name\n\t\t\t});\n\t\t\tWallet.setInstance(this);\n\t\t}\n\t}\n\n\t/**\n\t * Switches to a specific provider by name or instance.\n\t * @param providerOrName - The provider name or instance to switch to.\n\t */\n\tpublic switchToProvider(providerOrName: string | Provider): void {\n\t\tif (!this.blockchain) {\n\t\t\tthrow new Error('Blockchain not initialized');\n\t\t}\n\n\t\tlet newProvider: Provider | null | undefined = null;\n\n\t\tif (typeof providerOrName === 'string') {\n\t\t\tconst availableProviders = this.providerNames\n\t\t\t\t.map((name) =>\n\t\t\t\t\tProviderFactory.createProvider({ name, apiKey: this.privateKey, chainId: this.chainId })\n\t\t\t\t) // Create instances of all available providers using defaults\n\t\t\t\t.filter((provider) => provider.blockchains.includes(this.blockchain!.name));\n\t\t\tif (!availableProviders.length) {\n\t\t\t\tthrow new Error('No available providers for this blockchain');\n\t\t\t}\n\t\t\tnewProvider = availableProviders.find((provider) => provider !== this.provider);\n\t\t\tif (!newProvider) {\n\t\t\t\tnewProvider = ProviderFactory.createProvider({ name: providerOrName });\n\t\t\t}\n\t\t} else {\n\t\t\tnewProvider = providerOrName;\n\t\t}\n\n\t\tif (!newProvider) {\n\t\t\tthrow new Error(\n\t\t\t\t`Provider ${typeof providerOrName === 'string' ? providerOrName : 'unknown'} could not be created or is invalid.`\n\t\t\t);\n\t\t}\n\n\t\tif (!newProvider.blockchains.includes(this.blockchain.name)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Provider ${newProvider.name} does not support blockchain ${this.blockchain.name}`\n\t\t\t);\n\t\t}\n\n\t\tif (newProvider !== this.provider) {\n\t\t\tconst chainId: number = this.provider?.chainId || this.blockchain.chainId;\n\t\t\tconst oldProvider = this.provider;\n\t\t\tthis.provider = newProvider;\n\t\t\tthis.blockchain.connect(newProvider, chainId);\n\t\t\teventManager.emit('providerSwitched', {\n\t\t\t\toldProvider: oldProvider?.name,\n\t\t\t\tnewProvider: newProvider.name\n\t\t\t});\n\t\t\tWallet.setInstance(this);\n\t\t}\n\t}\n\n\t/**\n\t * Sends a transaction.\n\t * @param transaction - The transaction request to send.\n\t * @returns The transaction response.\n\t */\n\tasync sendTransaction(transaction: TransactionRequest): Promise<TransactionResponse> {\n\t\tif (!this.signer) {\n\t\t\tif (!this.privateKey) {\n\t\t\t\tthrow new Error('Private key not set');\n\t\t\t} else {\n\t\t\t\tawait this.setSigner(this.privateKey); // Since it is showing as not set\n\t\t\t}\n\t\t}\n\n\t\tif (!this.blockchain || !this.provider || !this.signer) {\n\t\t\t// console.log('Blockchain, Provider, Signer:', this.blockchain, this.provider, this.signer);\n\t\t\tthrow new Error('Blockchain or Provider or Signer not initialized');\n\t\t}\n\n\t\t// Implement gas estimation - Found an issue the FeeProvider model (not complete).\n\t\t// const gasEstimate = await this.blockchain.getGasEstimate(transaction);\n\n\t\t// Apply the gas estimate to the transaction\n\t\t// transaction.gasLimit = gasEstimate.gasLimit;\n\t\t// transaction.maxFeePerGas = gasEstimate.feeEstimate.totalFee;\n\t\t// transaction.maxPriorityFeePerGas = gasEstimate.feeEstimate.priorityFee;\n\n\t\t// debug_log('Sending transaction to provider:', transaction);\n\n\t\treturn await this.blockchain.sendTransaction(transaction);\n\t}\n\n\t/**\n\t * Signs typed data.\n\t * @param domain - The domain for the typed data.\n\t * @param types - The types for the typed data.\n\t * @param value - The value of the typed data.\n\t * @returns The signed data.\n\t */\n\tpublic async signTypedData(\n\t\tdomain: TypedDataDomain,\n\t\ttypes: Record<string, TypedDataField[]>,\n\t\tvalue: Record<string, any>\n\t): Promise<string> {\n\t\tif (!this.signer) {\n\t\t\tthrow new Error('Signer not initialized');\n\t\t}\n\n\t\tif (typeof (this.signer as any).signTypedData === 'function') {\n\t\t\treturn await (this.signer as EthereumSigner).signTypedData(domain, types, value);\n\t\t} else {\n\t\t\tthrow new Error('signTypedData is not supported for the current blockchain signer');\n\t\t}\n\t}\n\n\t/**\n\t * Adds an account to the wallet.\n\t * @param account - The account to add.\n\t */\n\tpublic addAccount(account: YakklAccount | YakklPrimaryAccount): void {\n\t\tif (isYakklPrimaryAccount(account)) {\n\t\t\t// If it's a primary account, add its main account part\n\t\t\tthis.accounts.push(account.account);\n\t\t\t// account.subAccounts.forEach(subAccount => this.accounts.push(subAccount));\n\t\t} else {\n\t\t\t// If it's a regular account\n\t\t\tthis.accounts.push(account);\n\t\t}\n\t\tWallet.setInstance(this);\n\t}\n\n\t/**\n\t * Gets an account by its address.\n\t * @param address - The address of the account to get.\n\t * @returns The account, if found.\n\t */\n\tpublic getAccount(address: string): YakklAccount | undefined {\n\t\treturn this.accounts.find((account) => account.address === address);\n\t}\n\n\t/**\n\t * Removes an account by its address.\n\t * @param address - The address of the account to remove.\n\t */\n\tpublic removeAccount(address: string): void {\n\t\tthis.accounts = this.accounts.filter((account) => account.address !== address);\n\t\tWallet.setInstance(this);\n\t}\n\n\tasync getGasEstimate(transaction: TransactionRequest): Promise<GasEstimate> {\n\t\tif (!this.blockchain) {\n\t\t\tthrow new Error('Blockchain not initialized');\n\t\t}\n\t\treturn await this.blockchain.getGasEstimate(transaction);\n\t}\n\n\tasync getHistoricalGasData(duration: number): Promise<HistoricalGasData[]> {\n\t\tif (!this.blockchain) {\n\t\t\tthrow new Error('Blockchain not initialized');\n\t\t}\n\t\treturn await this.blockchain.getHistoricalGasData(duration);\n\t}\n\n\tasync predictFutureFees(duration: number): Promise<GasPrediction[]> {\n\t\tif (!this.blockchain) {\n\t\t\tthrow new Error('Blockchain not initialized');\n\t\t}\n\t\treturn await this.blockchain.predictFutureFees(duration);\n\t}\n}\n","import { writable, derived } from 'svelte/store';\nimport type { SwapToken } from '$lib/common/interfaces';\nimport { ADDRESSES } from '$lib/managers/contracts/evm/constants-evm';\nimport { log } from '$lib/managers/Logger';\n\n// Writable store to hold all tokens\nexport const tokens = writable<SwapToken[]>([]);\n\n// Writable store to hold preferred token symbols\nexport const preferredTokenSymbols = writable<string[]>(['ETH', 'WETH', 'USDC', 'USDT', 'WBTC']);\n\n// Derived store for tokens with preferred tokens listed first\nexport const sortedTokens = derived(\n\t[tokens, preferredTokenSymbols],\n\t([$tokens, $preferredTokenSymbols]) => {\n\t\t// Filter out the preferred tokens from the main list\n\t\tconst preferredTokens = $tokens.filter((token) =>\n\t\t\t$preferredTokenSymbols.includes(token.symbol)\n\t\t);\n\n\t\tconst nonPreferredTokens = $tokens.filter(\n\t\t\t(token) => !$preferredTokenSymbols.includes(token.symbol) && token.chainId === 1\n\t\t);\n\n\t\tlet eth: SwapToken = {\n\t\t\tchainId: 1,\n\t\t\taddress: ADDRESSES.WETH,\n\t\t\tname: 'Ethereum',\n\t\t\tsymbol: 'ETH',\n\t\t\tdecimals: 18,\n\t\t\tisNative: true,\n\t\t\tisStablecoin: false,\n\t\t\tlogoURI: '/images/ethereum.svg'\n\t\t};\n\n\t\tpreferredTokens.unshift(eth);\n\n\t\t// Combine preferred tokens at the top, followed by the rest\n\t\treturn [...preferredTokens, ...nonPreferredTokens];\n\t}\n);\n\n// Function to load tokens from static JSON file\nexport async function loadTokens() {\n\ttry {\n\t\tconst response = await fetch('/data/uniswap.json');\n\t\tconst data = await response.json();\n\n\t\t// CoinGecko has a format similar to data.tokens while Uniswap has a format similar to data (just an array of tokens)\n\t\t// Determine the correct tokens array\n\t\tconst tokensData = data.tokens || data?.data?.tokens || data;\n\n\t\tconst loadedTokens: SwapToken[] = tokensData.map((token: SwapToken) => ({\n\t\t\t...token,\n\t\t\tisStablecoin: ['USDC', 'USDT', 'DAI', 'BUSD'].includes(token.symbol) // Mark stablecoins\n\t\t}));\n\n\t\t// Update the tokens store\n\t\ttokens.set(loadedTokens);\n\t} catch (error) {\n\t\tlog.error('Error loading tokens:', false, error);\n\t}\n}\n","/* eslint-disable no-useless-catch */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-ts-comment */\n\nexport const prerender = false;\n\nimport { getObjectFromLocalStorage, setObjectInLocalStorage } from '$lib/common/storage';\nimport { writable, get } from 'svelte/store';\nimport {\n\tyakklSettings,\n\tprofile,\n\tyakklPrimaryAccounts,\n\tyakklCurrentlySelected,\n\tyakklWatchList,\n\tyakklContacts,\n\tyakklAccounts,\n\tyakklPreferences,\n\tyakklChats,\n\tyakklBlockedList\n} from '$lib/models/dataModels';\nimport {\n\tSTORAGE_YAKKL_REGISTERED_DATA,\n\tSTORAGE_YAKKL_ACCOUNTS,\n\tSTORAGE_YAKKL_PRIMARY_ACCOUNTS,\n\tSTORAGE_YAKKL_CURRENTLY_SELECTED,\n\tSTORAGE_YAKKL_PROFILE,\n\tSTORAGE_YAKKL_PREFERENCES,\n\tSTORAGE_YAKKL_SETTINGS,\n\tSTORAGE_YAKKL_CONTACTS,\n\tSTORAGE_YAKKL_WATCHLIST,\n\tSTORAGE_YAKKL_BLOCKEDLIST,\n\tSTORAGE_YAKKL_CONNECTED_DOMAINS,\n\tSTORAGE_YAKKL_CHATS,\n\tSTORAGE_YAKKL_WALLET_BLOCKCHAINS,\n\tSTORAGE_YAKKL_WALLET_PROVIDERS,\n\tSTORAGE_YAKKL_TOKENDATA,\n\tSTORAGE_YAKKL_TOKENDATA_CUSTOM,\n\tSTORAGE_YAKKL_COMBINED_TOKENS\n} from '$lib/common/constants';\n\nimport { encryptData, decryptData } from '$lib/common/encryption';\nimport { isEncryptedData } from '$lib/common/misc';\nimport { type PricingStore } from '$lib/common/types';\nimport { isEqual } from 'lodash-es';\n\nimport type {\n\tCurrentlySelectedData,\n\tPreferences,\n\tProfile,\n\tSettings,\n\tYakklCurrentlySelected,\n\tYakklBlocked,\n\tYakklWatch,\n\tYakklAccount,\n\tYakklContact,\n\tYakklRegisteredData,\n\tYakklPrimaryAccount,\n\tHasData,\n\tYakklConnectedDomain,\n\tYakklChat,\n\tGasTransStore,\n\tContractData,\n\tTokenData,\n\tMarketPriceData,\n\tActiveTab\n} from '$lib/common/interfaces';\n\nimport { walletStore, type Wallet } from '$lib/managers/Wallet';\nimport type { Blockchain } from '$lib/managers/Blockchain';\nimport type { Provider } from '$lib/managers/Provider';\nimport type { TokenService } from '$lib/managers/blockchains/evm/TokenService';\nimport { tokens } from './stores/tokens';\n// import { timerManagerStore } from '$lib/managers/TimerManager';\nimport { log } from '$lib/managers/Logger';\nimport { AccountTypeCategory, NetworkType } from '$lib/common/types';\nimport { browser_ext } from '$lib/common/environment';\nimport type { RSSItem } from '$lib/managers/ExtensionRSSFeedService';\n\n// Svelte writeable stores\nexport const alert = writable({\n\tmsg: 'Welcome to the YAKKL® Smart Wallet!',\n\ticon: 1,\n\tcolor: {\n\t\tbackground: 'bg-indigo-400',\n\t\ttext: 'text-indigo-800'\n\t},\n\topacity: 0.5,\n\tms: 3000\n});\n\n// default ms = 3 seconds. To make the Alert stay until user clicks close then set ms = 0\n\n// loadCheckCurrentlySelectedStore - Checks the $yakklCurrentlySelectedStore to see if 'data' is encrypted and it does not decrpt any contained objects attached to the 'data' object until needed\nexport async function loadCheckCurrentlySelectedStore(): Promise<YakklCurrentlySelected | null> {\n\ttry {\n\t\tconst currentlySelected = getYakklCurrentlySelectedStore();\n\t\tconst miscStore = getMiscStore();\n\n\t\tif (miscStore && currentlySelected !== null) {\n\t\t\tif (isEncryptedData(currentlySelected.data)) {\n\t\t\t\tdecryptData(currentlySelected.data, miscStore).then((result) => {\n\t\t\t\t\tcurrentlySelected.data = result as CurrentlySelectedData;\n\t\t\t\t\t// setYakklCurrentlySelectedStore(currentlySelected);\n\t\t\t\t\treturn currentlySelected; //true;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn currentlySelected; //true;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t} catch (error) {\n\t\tlog.error('Error in loadCheckCurrentlySelectedStore:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function verifyEncryption<T extends HasData<any>>(value: T | T[]): Promise<T | T[]> {\n\ttry {\n\t\tconst miscStore = getMiscStore();\n\n\t\tif (miscStore) {\n\t\t\t// Helper function to process each item\n\t\t\tconst processItem = async (item: T) => {\n\t\t\t\tif (!isEncryptedData(item.data)) {\n\t\t\t\t\tconst result = await encryptData(item.data, miscStore);\n\t\t\t\t\titem.data = result as any;\n\t\t\t\t}\n\t\t\t\treturn item;\n\t\t\t};\n\n\t\t\t// If the input value is an array, process each item in the array\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\treturn Promise.all(value.map(processItem));\n\t\t\t} else {\n\t\t\t\t// If the input value is a single item, process it directly\n\t\t\t\treturn processItem(value);\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t} catch (error) {\n\t\tlog.error('Error in verifyEncryption:', false, error);\n\t\tthrow error;\n\t}\n}\n\n//\n// NOTE: getYakkl... or setYakkl... represents both a storage and store. If there is no Yakkl prefix like 'getMiscStore' then it is only in memory and not stored\n//\n\n// ---------------------------------\n// Svelte memory stores\n\nexport const yakklPreferencesStore = writable<Preferences>(yakklPreferences);\nexport const yakklSettingsStore = writable(yakklSettings);\nexport const profileStore = writable(profile);\nexport const yakklCurrentlySelectedStore = writable<YakklCurrentlySelected | null>(\n\tyakklCurrentlySelected\n);\nexport const yakklContactsStore = writable<YakklContact[]>(yakklContacts);\nexport const yakklChatsStore = writable<YakklChat[]>(yakklChats);\nexport const yakklAccountsStore = writable<YakklAccount[]>(yakklAccounts);\nexport const yakklPrimaryAccountsStore = writable<YakklPrimaryAccount[]>(yakklPrimaryAccounts);\nexport const yakklWatchListStore = writable<YakklWatch[]>(yakklWatchList);\nexport const yakklBlockedListStore = writable<YakklBlocked[]>(yakklBlockedList);\nexport const yakklConnectedDomainsStore = writable<YakklConnectedDomain[]>(undefined); // Move to null since these do not need to be pre-seeded\nexport const yakklMiscStore = writable<string>(undefined); // Misc items so formats will change\nexport const yakklVeryStore = writable<any>(undefined); // Misc items so formats will change\nexport const yakklVersionStore = writable<string>(undefined);\nexport const yakklUserNameStore = writable<string>(undefined);\nexport const yakklPricingStore = writable<PricingStore>(undefined); // {provider: '', pair: '', price: 1 }  - This is for the trading pairs that change every so often\nexport const yakklGasTransStore = writable<GasTransStore | undefined>(undefined); // Currently this is only used as a reactive store for the gas or transaction fees\nexport const yakklContactStore = writable<YakklContact | null>(undefined); // The single selcted contact from the yakklContactsStore list\nexport const yakklAccountStore = writable<YakklAccount>(undefined); // The single selcted account from the yakklAccountsStore list\nexport const yakklWalletProvidersStore = writable<string[]>([]);\nexport const yakklWalletBlockchainsStore = writable<string[]>([]);\nexport const yakklTokenDataStore = writable<TokenData[]>([]); // This is the official list of default tokens that we check to see if the user has any positions in\nexport const yakklTokenDataCustomStore = writable<TokenData[]>([]); // This is the official list of user added tokens that we check to see if the user has any positions in\nexport const yakklCombinedTokenStore = writable<TokenData[]>([]); // This is the combined list of default and custom tokens. We use this instead of derived so we can control the reactiveness better\nexport const yakklInstancesStore = writable<\n\t[Wallet | null, Provider | null, Blockchain | null, TokenService<any> | null]\n>([null, null, null, null]);\n\n// yakklGPTRunningStore and yakklGPTKeyStore are used for the GPT API\nexport const yakklGPTRunningStore = writable(false); // Single indicator for GPT running or not\nexport const yakklGPTKeyStore = writable<string>(undefined); // Single indicator for GPT Key\n\nexport const yakklConnectionStore = writable<boolean>(true); // All fetch or api calls need to validate that the yakklConnectionStore is true before accessing the internet\nexport const yakklDappConnectRequestStore = writable<string | null>(null);\n\nexport const priceStore = writable<MarketPriceData | null>(null); // This is for the trading pairs that change every so often\nexport const sessionInitialized = writable(false);\n\nexport const activeTabBackgroundStore = writable<ActiveTab | null>(null);\nexport const activeTabUIStore = writable<ActiveTab | null>(null);\nexport const backgroundUIConnectedStore = writable(false);\n\nexport const wallet = writable<Wallet | null>(null);\nexport const yakklContractStore = writable<ContractData>({\n\taddress: '',\n\tabi: '',\n\tfunctions: []\n});\nexport const yakklContextTypeStore = writable<string>(undefined);\n\n// Bookmarked Articles Store\nexport const yakklBookmarkedArticlesStore = writable<RSSItem[]>([]);\n\n// --------------------------------\n\nexport function resetStores() {\n\ttry {\n\t\tsetPreferencesStore(yakklPreferences);\n\t\tsetSettingsStore(yakklSettings);\n\t\tsetProfileStore(profile);\n\t\tsetYakklCurrentlySelectedStore(yakklCurrentlySelected);\n\t\tsetYakklWatchListStore(yakklWatchList);\n\t\tsetYakklBlockedListStore(yakklBlockedList);\n\t\tsetYakklContactsStore(yakklContacts);\n\t\tsetYakklChatsStore(yakklChats);\n\t\tsetYakklAccountsStore(yakklAccounts);\n\t\tsetYakklPrimaryAccountsStore(yakklPrimaryAccounts);\n\n\t\tsetYakklTokenDataStore([]);\n\t\tsetYakklTokenDataCustomStore([]);\n\t\tsetYakklCombinedTokenStore([]);\n\t\tsetYakklWalletBlockchainsStore([]);\n\t\tsetYakklWalletProvidersStore([]);\n\t\tsetYakklConnectedDomainsStore([]);\n\t\tyakklMiscStore.set(undefined);\n\t\tyakklContextTypeStore.set(undefined);\n\t\tyakklVeryStore.set(undefined);\n\t\tyakklVersionStore.set(undefined);\n\t\tyakklUserNameStore.set(undefined);\n\t\tyakklPricingStore.set(undefined);\n\t\tyakklGasTransStore.set(undefined);\n\t\tyakklContactStore.set(undefined);\n\t\tyakklAccountStore.set(undefined);\n\t\tyakklWalletProvidersStore.set([]);\n\t\tyakklWalletBlockchainsStore.set([]);\n\t\tyakklTokenDataStore.set([]);\n\t\tyakklTokenDataCustomStore.set([]);\n\t\tyakklCombinedTokenStore.set([]);\n\t\tyakklInstancesStore.set([null, null, null, null]);\n\t\tyakklGPTRunningStore.set(false);\n\t\tyakklGPTKeyStore.set(undefined);\n\t\tyakklConnectionStore.set(true);\n\t\tyakklDappConnectRequestStore.set(null);\n\t\twallet.set(null);\n\t\tyakklContractStore.set({\n\t\t\taddress: '',\n\t\t\tabi: '',\n\t\t\tfunctions: []\n\t\t});\n\n\t\ttokens.set([]);\n\t\twalletStore.set(null);\n\t\t// timerManagerStore.set(null);\n\n\t\tpriceStore.set(null);\n\t} catch (error) {\n\t\tlog.error(error);\n\t\tthrow error;\n\t}\n}\n\n// Generic error logger\nexport function onError(e: any) {\n\tlog.error(e);\n}\n\n// Anytime any local storage changes then we set the Svelte memory stores to keep things in sync\nexport function storageChange(changes: any) {\n\ttry {\n\t\tif (changes.yakklPreferences) {\n\t\t\tsetPreferencesStore(changes.yakklPreferences.newValue);\n\t\t}\n\t\tif (changes.yakklSettings) {\n\t\t\tsetSettingsStore(changes.yakklSettings.newValue);\n\t\t}\n\t\tif (changes.profile) {\n\t\t\tsetProfileStore(changes.profile.newValue);\n\t\t}\n\t\tif (changes.yakklCurrentlySelected) {\n\t\t\tsetYakklCurrentlySelectedStore(changes.yakklCurrentlySelected.newValue);\n\t\t}\n\t\tif (changes.yakklWatchList) {\n\t\t\tsetYakklWatchListStore(changes.yakklWatchList.newValue);\n\t\t}\n\t\tif (changes.yakklAccounts) {\n\t\t\tsetYakklAccountsStore(changes.yakklAccounts.newValue);\n\t\t}\n\t\tif (changes.yakklPrimaryAccounts) {\n\t\t\tsetYakklPrimaryAccountsStore(changes.yakklPrimaryAccounts.newValue);\n\t\t}\n\t\tif (changes.yakklContacts) {\n\t\t\tsetYakklContactsStore(changes.yakklContacts.newValue);\n\t\t}\n\t\tif (changes.yakklChats) {\n\t\t\tsetYakklChatsStore(changes.yakklChats.newValue);\n\t\t}\n\t\tif (changes.yakklConnectedDomains) {\n\t\t\tsetYakklConnectedDomainsStore(changes.yakklConnectedDomains.newValue);\n\t\t}\n\t\tif (changes.yakklBlockedList) {\n\t\t\tsetYakklBlockedListStore(changes.yakklBlockedList.newValue);\n\t\t}\n\t} catch (error) {\n\t\tlog.error(error);\n\t\tthrow error;\n\t}\n}\n\nexport async function syncStorageToStore() {\n\ttry {\n\t\tconst [\n\t\t\tpreferences,\n\t\t\tsettings,\n\t\t\tprofileLocal,\n\t\t\tyakklCurrentlySelectedLocal,\n\t\t\tyakklWatchList,\n\t\t\tyakklBlockedList,\n\t\t\tyakklAccounts,\n\t\t\tyakklPrimaryAccounts,\n\t\t\tyakklContacts,\n\t\t\tyakklChats,\n\t\t\tyakklTokenData,\n\t\t\tyakklTokenDataCustom,\n\t\t\tyakklConnectedDomains\n\t\t] = await Promise.all([\n\t\t\tgetPreferences(),\n\t\t\tgetSettings(),\n\t\t\tgetProfile(),\n\t\t\tgetYakklCurrentlySelected(),\n\t\t\tgetYakklWatchList(),\n\t\t\tgetYakklBlockedList(),\n\t\t\tgetYakklAccounts(),\n\t\t\tgetYakklPrimaryAccounts(),\n\t\t\tgetYakklContacts(),\n\t\t\tgetYakklChats(),\n\t\t\tgetYakklTokenData(),\n\t\t\tgetYakklTokenDataCustom(),\n\t\t\tgetYakklConnectedDomains()\n\t\t]);\n\n\t\tsetPreferencesStore(preferences ?? yakklPreferences);\n\t\tsetSettingsStore(settings ?? yakklSettings);\n\t\tsetProfileStore(profileLocal ?? profile);\n\t\tsetYakklCurrentlySelectedStore(yakklCurrentlySelectedLocal ?? yakklCurrentlySelected);\n\t\tsetYakklWatchListStore(yakklWatchList);\n\t\tsetYakklBlockedListStore(yakklBlockedList);\n\t\tsetYakklAccountsStore(yakklAccounts);\n\t\tsetYakklPrimaryAccountsStore(yakklPrimaryAccounts);\n\t\tsetYakklContactsStore(yakklContacts);\n\t\tsetYakklChatsStore(yakklChats);\n\t\tsetYakklTokenDataStore(yakklTokenData);\n\t\tsetYakklTokenDataCustomStore(yakklTokenDataCustom);\n\t\tsetYakklConnectedDomainsStore(yakklConnectedDomains);\n\t} catch (error) {\n\t\tlog.error('Error syncing stores:', false, error);\n\t\tthrow error; // Rethrow so that load() can catch it\n\t}\n}\n\n// NOTE: We need to think through the id and persona for each store and any wrappers and how best to handle them.\n// We can filter on get and on set we will need to get all, find the item we need to update and then update it.\n\n// Browser Extension local storage\n// Returns old settings\nexport async function setSettings(settings: Settings) {\n\treturn await setSettingsStorage(settings);\n}\n\n// --------------------------------\n// Call these for getting memory data store only\nexport function getYakklPreferenceStore() {\n\tconst store = get(yakklPreferencesStore);\n\treturn store;\n}\n\nexport function getSettingsStore() {\n\tconst store = get(yakklSettingsStore);\n\treturn store;\n}\n\nexport function getProfileStore(values: Profile) {\n\tconst store = get(profileStore);\n\tprofileStore.set(values);\n\treturn store;\n}\n\nexport function getYakklCurrentlySelectedStore() {\n\tconst store = get(yakklCurrentlySelectedStore);\n\treturn store;\n}\n\nexport function getYakklWatchListStore() {\n\tconst store = get(yakklWatchListStore);\n\treturn store;\n}\n\nexport function getYakklBlockedListStore() {\n\tconst store = get(yakklBlockedListStore);\n\treturn store;\n}\n\nexport function getYakklAccountsStore() {\n\tconst store = get(yakklAccountsStore);\n\treturn store;\n}\n\nexport function getYakklPrimaryAccountsStore() {\n\tconst store = get(yakklPrimaryAccountsStore);\n\treturn store;\n}\n\nexport function getYakklContactsStore() {\n\tconst store = get(yakklContactsStore);\n\treturn store;\n}\n\nexport function getYakklTokenDataStore() {\n\tconst store = get(yakklTokenDataStore);\n\treturn store;\n}\n\nexport function getYakklTokenDataCustomStore() {\n\tconst store = get(yakklTokenDataCustomStore);\n\treturn store;\n}\n\nexport function getYakklCombinedTokenStore() {\n\tconst store = get(yakklCombinedTokenStore);\n\treturn store;\n}\n\nexport function getYakklChatsStore() {\n\tconst store = get(yakklChatsStore);\n\treturn store;\n}\n\nexport function getYakklWalletBlockchainsStore() {\n\tconst store = get(yakklWalletBlockchainsStore);\n\treturn store;\n}\n\nexport function getYakklWalletProvidersStore() {\n\tconst store = get(yakklWalletProvidersStore);\n\treturn store;\n}\n\nexport function getYakklConnectedDomainsStore() {\n\tconst store = get(yakklConnectedDomainsStore);\n\treturn store;\n}\n\nexport function getYakklContractStore() {\n\treturn get(yakklContractStore);\n}\n\n// Memory only\nexport function getMiscStore() {\n\tconst store = get(yakklMiscStore);\n\treturn store;\n}\n\nexport function getContextTypeStore() {\n\tconst store = get(yakklContextTypeStore);\n\treturn store;\n}\n\n// Memory only\nexport function getVeryStore() {\n\tconst store = get(yakklVeryStore);\n\treturn store;\n}\n\nexport function getDappConnectRequestStore() {\n\tconst store = get(yakklDappConnectRequestStore);\n\treturn store;\n}\n\nexport function getContactStore() {\n\tconst store = get(yakklContactStore);\n\treturn store;\n}\n\nexport function getAccountStore() {\n\tconst store = get(yakklAccountStore);\n\treturn store;\n}\n\nexport function getVersionStore() {\n\tconst store = get(yakklVersionStore);\n\treturn store;\n}\n\nexport function getUserNameStore() {\n\tconst store = get(yakklUserNameStore);\n\treturn store;\n}\n\nexport function getYakklGPTKeyStore() {\n\tconst store = get(yakklGPTKeyStore);\n\treturn store;\n}\n\nexport function getYakklConnectionStore() {\n\tconst store = get(yakklConnectionStore);\n\treturn store;\n}\n\nexport function getYakklInstancesStore() {\n\tconst store = get(yakklInstancesStore);\n\treturn store;\n}\n\n// export function getYakklPriceStore() {\n// \tconst store = get(yakklPriceStore);\n// \treturn store;\n// }\n\n// --------------------------------\n// Call these for setting memory data store only\n// Return previous values\nexport function setPreferencesStore(values: Preferences | null) {\n\tconst store = get(yakklPreferencesStore);\n\tyakklPreferencesStore.set(values === null ? yakklPreferences : values);\n\treturn store;\n}\n\nexport function setSettingsStore(values: Settings | null) {\n\tconst store = get(yakklSettingsStore);\n\tyakklSettingsStore.set(values === null ? yakklSettings : values);\n\treturn store;\n}\n\n// Return previous values\nexport function setProfileStore(values: Profile | null) {\n\tconst store = get(profileStore);\n\tprofileStore.set(values === null ? profile : values);\n\treturn store;\n}\n\n// Return previous values\n// Making sure the value set for currently selected is not encrypted\nexport function setYakklCurrentlySelectedStore(values: YakklCurrentlySelected | null) {\n\tconst store = get(yakklCurrentlySelectedStore);\n\tyakklCurrentlySelectedStore.set(values !== null ? values : null); // Set here even if some items are empty. Validate items in save to storage\n\treturn store;\n}\n\n// Return previous values\nexport function setYakklWatchListStore(values: YakklWatch[]) {\n\tconst store = get(yakklWatchListStore);\n\tyakklWatchListStore.set(values);\n\treturn store;\n}\n\n// Return previous values\nexport function setYakklBlockedListStore(values: YakklBlocked[]) {\n\tconst store = get(yakklBlockedListStore);\n\tyakklBlockedListStore.set(values);\n\treturn store;\n}\n\n// Return previous values\nexport function setYakklContactsStore(values: YakklContact[]) {\n\tconst store = get(yakklContactsStore);\n\tyakklContactsStore.set(values);\n\treturn store;\n}\n\nexport function setYakklTokenDataStore(values: TokenData[]) {\n\tconst store = get(yakklTokenDataStore);\n\tyakklTokenDataStore.set(values);\n\treturn store;\n}\n\nexport function setYakklTokenDataCustomStore(values: TokenData[]) {\n\tconst store = get(yakklTokenDataCustomStore);\n\tyakklTokenDataCustomStore.set(values);\n\treturn store;\n}\n\nexport function setYakklCombinedTokenStore(values: TokenData[]) {\n\tconst store = get(yakklCombinedTokenStore);\n\tyakklCombinedTokenStore.set(values);\n\treturn store;\n}\n\n// Return previous values\nexport function setYakklChatsStore(values: YakklChat[]) {\n\tconst store = get(yakklChatsStore);\n\tyakklChatsStore.set(values);\n\treturn store;\n}\n\n// Return previous values\nexport function setYakklWalletBlockchainsStore(values: string[]) {\n\tconst store = get(yakklWalletBlockchainsStore);\n\tyakklWalletBlockchainsStore.set(values);\n\treturn store;\n}\n\n// Return previous values\nexport function setYakklWalletProvidersStore(values: string[]) {\n\tconst store = get(yakklWalletProvidersStore);\n\tyakklWalletProvidersStore.set(values);\n\treturn store;\n}\n\n// Return previous values\nexport function setYakklConnectedDomainsStore(values: YakklConnectedDomain[]) {\n\tconst store = get(yakklConnectedDomainsStore);\n\tyakklConnectedDomainsStore.set(values);\n\treturn store;\n}\n\n// Return previous values\nexport function setYakklAccountsStore(values: YakklAccount[]) {\n\tconst store = get(yakklAccountsStore);\n\tyakklAccountsStore.set(values);\n\treturn store;\n}\n\n// Return previous values\nexport function setYakklPrimaryAccountsStore(values: YakklPrimaryAccount[]) {\n\tconst store = get(yakklPrimaryAccountsStore);\n\tyakklPrimaryAccountsStore.set(values);\n\treturn store;\n}\n\n// Return previous values\nexport function setMiscStore(values: string) {\n\tconst store = get(yakklMiscStore);\n\tyakklMiscStore.set(values);\n\treturn store;\n}\n\nexport function setContextTypeStore(values: string) {\n\tconst store = get(yakklContextTypeStore);\n\tyakklContextTypeStore.set(values);\n\treturn store;\n}\n\n// Return previous values\nexport function setVeryStore(values: any) {\n\tconst store = get(yakklVeryStore);\n\tyakklVeryStore.set(values);\n\treturn store;\n}\n\nexport function setDappConnectRequestStore(values: string | null) {\n\tconst store = get(yakklDappConnectRequestStore);\n\tyakklDappConnectRequestStore.set(values);\n\treturn store;\n}\n\n// Return previous values\nexport function setContactStore(values: YakklContact | null) {\n\tconst store = get(yakklContactStore);\n\tyakklContactStore.set(values);\n\treturn store;\n}\n\n// Return previous values\nexport function setAccountStore(values: YakklAccount) {\n\tconst store = get(yakklAccountStore);\n\tyakklAccountStore.set(values);\n\treturn store;\n}\n\n// Return previous values\nexport function setVersionStore(values: string) {\n\tconst store = get(yakklVersionStore);\n\tyakklVersionStore.set(values);\n\treturn store;\n}\n\n// Return previous values\nexport function setUserNameStore(values: string) {\n\tconst store = get(yakklUserNameStore);\n\tyakklUserNameStore.set(values);\n\treturn store;\n}\n\nexport function setYakklGPTKeyStore(values: string) {\n\tconst store = get(yakklGPTKeyStore);\n\tyakklGPTKeyStore.set(values);\n\treturn store;\n}\n\n// Return previous values\nexport function setYakklConnectionStore(values: boolean) {\n\tconst store = get(yakklConnectionStore);\n\tyakklConnectionStore.set(values);\n\treturn store;\n}\n\nexport function setYakklContractStore(values: ContractData) {\n\tconst store = get(yakklContractStore);\n\tyakklContractStore.set(values);\n\treturn store;\n}\n\nexport function setYakklInstancesStore(\n\tvalues: [Wallet | null, Provider | null, Blockchain | null, TokenService<any> | null]\n) {\n\tconst store = get(yakklInstancesStore);\n\tyakklInstancesStore.set(values);\n\treturn store;\n}\n\n// --------------------------------\n\nexport async function getYakklRegisteredData(\n\tid?: string,\n\tpersona?: string\n): Promise<YakklRegisteredData | null> {\n\ttry {\n\t\tconst value = await getObjectFromLocalStorage<YakklRegisteredData>(\n\t\t\tSTORAGE_YAKKL_REGISTERED_DATA\n\t\t);\n\t\tif (typeof value === 'string') {\n\t\t\t// Handle the case where value is a string, which shouldn't happen in this context\n\t\t\tthrow new Error('Unexpected string value received from local storage');\n\t\t}\n\n\t\tif (id && persona) {\n\t\t\t// TODO: Implement this later - think through the license key and persona\n\t\t}\n\n\t\treturn value || null; // Return an empty object or provide a default value if necessary\n\t} catch (error) {\n\t\tlog.error('Error in getYakklRegisteredData:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function getYakklContacts(id?: string, persona?: string): Promise<YakklContact[]> {\n\ttry {\n\t\tconst value = await getObjectFromLocalStorage<YakklContact[]>(STORAGE_YAKKL_CONTACTS);\n\t\tif (typeof value === 'string') {\n\t\t\t// Handle the case where value is a string, which shouldn't happen in this context\n\t\t\tthrow new Error('Unexpected string value received from local storage');\n\t\t}\n\n\t\tif (id && persona) {\n\t\t\t// TODO: Implement this later\n\t\t}\n\n\t\treturn value || []; // Return an empty array or provide a default value if necessary\n\t} catch (error) {\n\t\tlog.error('Error in getYakklContacts:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function getYakklTokenData(id?: string, persona?: string): Promise<TokenData[]> {\n\ttry {\n\t\tconst value = await getObjectFromLocalStorage<TokenData[]>(STORAGE_YAKKL_TOKENDATA);\n\t\tif (typeof value === 'string') {\n\t\t\t// Handle the case where value is a string, which shouldn't happen in this context\n\t\t\tthrow new Error('Unexpected string value received from local storage');\n\t\t}\n\n\t\tif (id && persona) {\n\t\t\t// TODO: Implement this later\n\t\t}\n\n\t\tif (value) setYakklTokenDataStore(value);\n\t\treturn value || []; // Return an empty array or provide a default value if necessary\n\t} catch (error) {\n\t\tlog.error('Error in getYakklTokenData:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function getYakklTokenDataCustom(id?: string, persona?: string): Promise<TokenData[]> {\n\ttry {\n\t\tconst value = await getObjectFromLocalStorage<TokenData[]>(STORAGE_YAKKL_TOKENDATA_CUSTOM);\n\t\tif (typeof value === 'string') {\n\t\t\t// Handle the case where value is a string, which shouldn't happen in this context\n\t\t\tthrow new Error('Unexpected string value received from local storage');\n\t\t}\n\n\t\tif (id && persona) {\n\t\t\t// TODO: Implement this later\n\t\t}\n\n\t\tif (value) setYakklTokenDataCustomStore(value);\n\t\treturn value || []; // Return an empty array or provide a default value if necessary\n\t} catch (error) {\n\t\tlog.error('Error in getYakklTokenDataCustom:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function getYakklCombinedToken(id?: string, persona?: string): Promise<TokenData[]> {\n\ttry {\n\t\tconst value = await getObjectFromLocalStorage<TokenData[]>(STORAGE_YAKKL_COMBINED_TOKENS);\n\t\tif (typeof value === 'string') {\n\t\t\t// Handle the case where value is a string, which shouldn't happen in this context\n\t\t\tthrow new Error('Unexpected string value received from local storage');\n\t\t}\n\n\t\tif (id && persona) {\n\t\t\t// TODO: Implement this later\n\t\t}\n\n\t\tif (value) setYakklCombinedTokenStore(value);\n\t\treturn value || []; // Return an empty array or provide a default value if necessary\n\t} catch (error) {\n\t\tlog.error('Error in getYakklCombinedToken:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function getYakklChats(id?: string, persona?: string): Promise<YakklChat[]> {\n\ttry {\n\t\tlet value = await getObjectFromLocalStorage<YakklChat[]>(STORAGE_YAKKL_CHATS);\n\t\tif (typeof value === 'string') {\n\t\t\tvalue = [];\n\t\t\tsetYakklChatsStorage(value);\n\t\t}\n\n\t\tif (id && persona) {\n\t\t\t// TODO: Implement this later\n\t\t}\n\n\t\t// Convert object to array if necessary\n\t\tif (value && typeof value === 'object' && !Array.isArray(value)) {\n\t\t\tvalue = Object.values(value);\n\t\t}\n\t\treturn value || [];\n\t} catch (error) {\n\t\tlog.error('Error in getYakklChats:', false, error);\n\t\treturn [];\n\t}\n}\n\nexport async function getYakklWalletBlockchains(): Promise<string[]> {\n\ttry {\n\t\tlet value = await getObjectFromLocalStorage<string[]>(STORAGE_YAKKL_WALLET_BLOCKCHAINS);\n\t\tif (typeof value === 'string') {\n\t\t\t// Handle the case where value is a string, which shouldn't happen in this context\n\t\t\tvalue = [];\n\t\t\tsetYakklWalletBlockchainsStorage(value);\n\t\t}\n\t\treturn value || []; // Return an empty array or provide a default value if necessary\n\t} catch (error) {\n\t\tlog.error('Error in getYakklWalletBlockchains:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function getYakklWalletProviders(): Promise<string[]> {\n\ttry {\n\t\tlet value = await getObjectFromLocalStorage<string[]>(STORAGE_YAKKL_WALLET_PROVIDERS);\n\t\tif (typeof value === 'string') {\n\t\t\t// Handle the case where value is a string, which shouldn't happen in this context\n\t\t\tvalue = [];\n\t\t\tsetYakklWalletProvidersStorage(value);\n\t\t}\n\t\treturn value || []; // Return an empty array or provide a default value if necessary\n\t} catch (error) {\n\t\tlog.error('Error in getYakklWalletProviders:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function getYakklConnectedDomains(\n\tid?: string,\n\tpersona?: string\n): Promise<YakklConnectedDomain[]> {\n\ttry {\n\t\tconst value = await getObjectFromLocalStorage<YakklConnectedDomain[]>(\n\t\t\tSTORAGE_YAKKL_CONNECTED_DOMAINS\n\t\t);\n\n\t\tlog.info('getYakklConnectedDomains - value:', false, value);\n\n\t\tif (typeof value === 'string') {\n\t\t\t// Handle the case where value is a string, which shouldn't happen in this context\n\t\t\tthrow new Error('Unexpected string value received from local storage');\n\t\t}\n\n\t\tif (id && persona) {\n\t\t\treturn value.filter((d) => d.id === id && d.persona === persona) || [];\n\t\t}\n\n\t\treturn value || []; // Return an empty array or provide a default value if necessary\n\t} catch (error) {\n\t\tlog.error('Error in getYakklConnectedDomains:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function getPreferences(id?: string, persona?: string): Promise<Preferences | null> {\n\ttry {\n\t\tconst value = await getObjectFromLocalStorage<Preferences>(STORAGE_YAKKL_PREFERENCES);\n\t\tif (typeof value === 'string') {\n\t\t\t// Handle the case where value is a string, which shouldn't happen in this context\n\t\t\tthrow new Error('Unexpected string value received from local storage');\n\t\t}\n\n\t\tif (id && persona) {\n\t\t\t// TODO: Implement this later\n\t\t}\n\n\t\treturn value; // Return an empty object or provide a default value if necessary\n\t} catch (error) {\n\t\tlog.error('Error in getPreferences:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function getSettings(id?: string, persona?: string): Promise<Settings | null> {\n\ttry {\n\t\tconst value = await getObjectFromLocalStorage<Settings>(STORAGE_YAKKL_SETTINGS);\n\t\tif (typeof value === 'string') {\n\t\t\t// Handle the case where value is a string, which shouldn't happen in this context\n\t\t\tthrow new Error('Unexpected string value received from local storage');\n\t\t}\n\n\t\tif (id && persona) {\n\t\t\t// TODO: Implement this later\n\t\t}\n\n\t\treturn value; // Return an empty object or provide a default value if necessary\n\t} catch (error) {\n\t\tlog.error('Error in getSettings:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function getProfile(id?: string, persona?: string): Promise<Profile | null> {\n\ttry {\n\t\tconst value = await getObjectFromLocalStorage<Profile>(STORAGE_YAKKL_PROFILE);\n\t\tif (typeof value === 'string') {\n\t\t\t// Handle the case where value is a string, which shouldn't happen in this context\n\t\t\tthrow new Error('Unexpected string value received from local storage');\n\t\t}\n\n\t\tif (id && persona) {\n\t\t\t// TODO: Implement this later\n\t\t}\n\n\t\treturn value; // Return an empty object or provide a default value if necessary\n\t} catch (error) {\n\t\tlog.error('Error in getProfile:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function getYakklCurrentlySelected(\n\tid?: string,\n\tpersona?: string\n): Promise<YakklCurrentlySelected> {\n\ttry {\n\t\tconst value = await getObjectFromLocalStorage<YakklCurrentlySelected>(\n\t\t\tSTORAGE_YAKKL_CURRENTLY_SELECTED\n\t\t);\n\n\t\tif (id && persona) {\n\t\t\t// TODO: Implement this later\n\t\t}\n\n\t\t// If no value or value is a string, return default values\n\t\tif (!value || typeof value === 'string') {\n\t\t\tlog.warn('No currently selected Yakkl found, using defaults', false, value);\n\t\t\treturn {\n\t\t\t\tid: '',\n\t\t\t\tshortcuts: {\n\t\t\t\t\tquantity: 0n,\n\t\t\t\t\taccountType: AccountTypeCategory.PRIMARY,\n\t\t\t\t\taccountName: 'YAKKL_ZERO_ACCOUNT',\n\t\t\t\t\tsmartContract: false,\n\t\t\t\t\taddress: '',\n\t\t\t\t\talias: '',\n\t\t\t\t\tprimary: null,\n\t\t\t\t\tinit: false,\n\t\t\t\t\tlegal: false,\n\t\t\t\t\tisLocked: true,\n\t\t\t\t\tshowTestNetworks: false,\n\t\t\t\t\tprofile: {\n\t\t\t\t\t\tuserName: '',\n\t\t\t\t\t\tname: null,\n\t\t\t\t\t\temail: ''\n\t\t\t\t\t},\n\t\t\t\t\tgasLimit: 21000,\n\t\t\t\t\tnetworks: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tblockchain: 'Ethereum',\n\t\t\t\t\t\t\tname: 'Mainnet',\n\t\t\t\t\t\t\tchainId: 1,\n\t\t\t\t\t\t\tsymbol: 'ETH',\n\t\t\t\t\t\t\ttype: NetworkType.MAINNET,\n\t\t\t\t\t\t\texplorer: 'https://etherscan.io',\n\t\t\t\t\t\t\tdecimals: 18\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\tnetwork: {\n\t\t\t\t\t\tblockchain: 'Ethereum',\n\t\t\t\t\t\tname: 'Mainnet',\n\t\t\t\t\t\tchainId: 1,\n\t\t\t\t\t\tsymbol: 'ETH',\n\t\t\t\t\t\ttype: NetworkType.MAINNET,\n\t\t\t\t\t\texplorer: 'https://etherscan.io',\n\t\t\t\t\t\tdecimals: 18\n\t\t\t\t\t},\n\t\t\t\t\tblockchain: 'Ethereum',\n\t\t\t\t\ttype: NetworkType.MAINNET,\n\t\t\t\t\tchainId: 1,\n\t\t\t\t\tsymbol: 'ETH',\n\t\t\t\t\texplorer: 'https://etherscan.io'\n\t\t\t\t},\n\t\t\t\tpreferences: {\n\t\t\t\t\tlocale: 'en_US',\n\t\t\t\t\tcurrency: { code: 'USD', symbol: '$' }\n\t\t\t\t},\n\t\t\t\tdata: {},\n\t\t\t\tversion: '1.0.0',\n\t\t\t\tcreateDate: new Date().toISOString(),\n\t\t\t\tupdateDate: new Date().toISOString()\n\t\t\t};\n\t\t}\n\t\treturn value;\n\t} catch (error) {\n\t\tlog.error('Error in getYakklCurrentlySelected:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function getYakklWatchList(id?: string, persona?: string): Promise<YakklWatch[]> {\n\t// eslint-disable-next-line no-useless-catch\n\ttry {\n\t\tconst value = await getObjectFromLocalStorage<YakklWatch[]>(STORAGE_YAKKL_WATCHLIST);\n\t\tif (typeof value === 'string') {\n\t\t\t// Handle the case where value is a string, which shouldn't happen in this context\n\t\t\tthrow new Error('Unexpected string value received from local storage');\n\t\t}\n\n\t\tif (id && persona) {\n\t\t\t// TODO: Implement this later\n\t\t}\n\n\t\treturn value || [];\n\t} catch (error) {\n\t\tlog.error('Error in getYakklWatchList:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function getYakklBlockedList(id?: string, persona?: string): Promise<YakklBlocked[]> {\n\t// eslint-disable-next-line no-useless-catch\n\ttry {\n\t\tconst value = await getObjectFromLocalStorage<YakklBlocked[]>(STORAGE_YAKKL_BLOCKEDLIST);\n\t\tif (typeof value === 'string') {\n\t\t\t// Handle the case where value is a string, which shouldn't happen in this context\n\t\t\tthrow new Error('Unexpected string value received from local storage');\n\t\t}\n\n\t\tif (id && persona) {\n\t\t\t// TODO: Implement this later\n\t\t}\n\n\t\treturn value || [];\n\t} catch (error) {\n\t\tlog.error('Error in getYakklBlockedList:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function getYakklAccounts(id?: string, persona?: string): Promise<YakklAccount[]> {\n\t// eslint-disable-next-line no-useless-catch\n\ttry {\n\t\tconst value = await getObjectFromLocalStorage<YakklAccount[]>(STORAGE_YAKKL_ACCOUNTS);\n\t\tif (typeof value === 'string') {\n\t\t\t// Handle the case where value is a string, which shouldn't happen in this context\n\t\t\tthrow new Error('Unexpected string value received from local storage');\n\t\t}\n\n\t\tif (id && persona) {\n\t\t\t// TODO: Implement this later\n\t\t}\n\n\t\treturn value || [];\n\t} catch (error) {\n\t\tlog.error('Error in getYakklAccounts:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function getYakklPrimaryAccounts(\n\tid?: string,\n\tpersona?: string\n): Promise<YakklPrimaryAccount[]> {\n\t// eslint-disable-next-line no-useless-catch\n\ttry {\n\t\tconst value = await getObjectFromLocalStorage<YakklPrimaryAccount[]>(\n\t\t\tSTORAGE_YAKKL_PRIMARY_ACCOUNTS\n\t\t);\n\t\tif (typeof value === 'string') {\n\t\t\t// Handle the case where value is a string, which shouldn't happen in this context\n\t\t\tthrow new Error('Unexpected string value received from local storage');\n\t\t}\n\n\t\tif (id && persona) {\n\t\t\t// TODO: Implement this later\n\t\t}\n\n\t\treturn value || [];\n\t} catch (error) {\n\t\tlog.error('Error in getYakklPrimaryAccounts:', false, error);\n\t\tthrow error;\n\t}\n}\n\n// --------------------------------\n// Call these storage functions when you need to update both persistent and memory stores\nexport async function setYakklContactsStorage(values: YakklContact[]) {\n\ttry {\n\t\tyakklContactsStore.set(values);\n\t\tawait setObjectInLocalStorage('yakklContacts', values);\n\t} catch (error) {\n\t\tlog.error('Error in setYakklContactsStorage:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function setYakklTokenDataStorage(values: TokenData[]) {\n\ttry {\n\t\t// const current = get(yakklTokenDataStore);\n\n\t\t// Only update if the values are different\n\t\t// if (!isEqual(current, values)) {\n\t\tyakklTokenDataStore.set(values);\n\t\tawait setObjectInLocalStorage('yakklTokenData', values);\n\t\t// }\n\t} catch (error) {\n\t\tlog.error('Error in setYakklTokenDataStorage:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function setYakklTokenDataCustomStorage(values: TokenData[]) {\n\ttry {\n\t\t// const current = get(yakklTokenDataCustomStore);\n\n\t\t// Only update if the values are different\n\t\t// if (!isEqual(current, values)) {\n\t\tyakklTokenDataCustomStore.set(values);\n\t\tawait setObjectInLocalStorage('yakklTokenDataCustom', values);\n\t\t// }\n\t} catch (error) {\n\t\tlog.error('Error in setYakklTokenDataCustomStorage:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function setYakklCombinedTokenStorage(values: TokenData[]) {\n\ttry {\n\t\t// const current = get(yakklCombinedTokenStore);\n\n\t\t// Only update if the values are different\n\t\t// if (!isEqual(current, values)) {\n\t\tyakklCombinedTokenStore.set(values);\n\t\tawait setObjectInLocalStorage('yakklCombinedTokens', values);\n\t\t// }\n\t} catch (error) {\n\t\tlog.error('Error in setYakklCombinedTokenStorage:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function setYakklChatsStorage(values: YakklChat[]) {\n\ttry {\n\t\t// const current = get(yakklChatsStore);\n\t\t// if (!isEqual(current, values)) {\n\t\tyakklChatsStore.set(values);\n\t\tawait setObjectInLocalStorage('yakklChats', values);\n\t\t// }\n\t} catch (error) {\n\t\tlog.error('Error in setYakklChatsStorage:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function setYakklWalletBlockchainsStorage(values: string[]) {\n\ttry {\n\t\t// const current = get(yakklWalletBlockchainsStore);\n\t\t// if (!isEqual(current, values)) {\n\t\tyakklWalletBlockchainsStore.set(values);\n\t\tawait setObjectInLocalStorage('yakklWalletBlockchains', values);\n\t\t// }\n\t} catch (error) {\n\t\tlog.error('Error in setYakklWalletBlockchainsStorage:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function setYakklWalletProvidersStorage(values: string[]) {\n\ttry {\n\t\t// const current = get(yakklWalletProvidersStore);\n\t\t// if (!isEqual(current, values)) {\n\t\tyakklWalletProvidersStore.set(values);\n\t\tawait setObjectInLocalStorage('yakklWalletProviders', values);\n\t\t// }\n\t} catch (error) {\n\t\tlog.error('Error in setYakklWalletProvidersStorage:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function setYakklConnectedDomainsStorage(values: YakklConnectedDomain[]) {\n\ttry {\n\t\tconst current = get(yakklConnectedDomainsStore);\n\t\tif (!isEqual(current, values)) {\n\t\t\tyakklConnectedDomainsStore.set(values);\n\t\t\tawait setObjectInLocalStorage('yakklConnectedDomains', values);\n\t\t}\n\t} catch (error) {\n\t\tlog.error('Error in setYakklConnectedDomainsStorage:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function setSettingsStorage(values: Settings) {\n\ttry {\n\t\t// const current = get(yakklSettingsStore);\n\t\t// if (!isEqual(current, values)) {\n\t\tyakklSettingsStore.set(values);\n\t\tawait setObjectInLocalStorage('settings', values);\n\t\t// }\n\t} catch (error) {\n\t\tlog.error('Error in setSettingsStorage:', false, error);\n\t\tthrow new Error('Error in setSettingsStorage: ' + false, error);\n\t}\n}\n\nexport async function setPreferencesStorage(values: Preferences) {\n\ttry {\n\t\t// const current = get(yakklPreferencesStore);\n\t\t// if (!isEqual(current, values)) {\n\t\tyakklPreferencesStore.set(values);\n\t\tawait setObjectInLocalStorage('preferences', values);\n\t\t// }\n\t} catch (error) {\n\t\tlog.error('Error in setPreferencesStorage:', false, error);\n\t\tthrow new Error('Error in setPreferencesStorage: ' + false, error);\n\t}\n}\n\nexport async function setProfileStorage(values: Profile) {\n\ttry {\n\t\t// const current = get(profileStore);\n\t\t// const newValues = (await verifyEncryption(values)) as Profile;\n\n\t\t// if (!isEqual(current, newValues)) {\n\t\tprofileStore.set(values);\n\t\tawait setObjectInLocalStorage('profile', values);\n\t\t// }\n\t} catch (error) {\n\t\tlog.error('Error in setProfileStorage:', false, error);\n\t\tthrow new Error('Error in setProfileStorage: ' + false, error);\n\t}\n}\n\nexport async function setYakklCurrentlySelectedStorage(values: YakklCurrentlySelected) {\n\ttry {\n\t\tif (\n\t\t\tvalues.shortcuts.address.trim().length === 0 ||\n\t\t\tvalues.shortcuts.accountName.trim().length === 0\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t'Attempting to save yakklCurrentlySelected with no address or no account name. Select a default account and retry.'\n\t\t\t);\n\t\t}\n\n\t\t// Get current store value\n\t\t// const current = get(yakklCurrentlySelectedStore);\n\n\t\t// Avoid unnecessary updates by checking for equality\n\t\t// if (!isEqual(current, values)) {\n\t\t// Update the store with the new value\n\n\t\t// Verify encryption (ensures the value is encrypted correctly before storing)\n\t\tconst newValues = await verifyEncryption(values);\n\t\tsetYakklCurrentlySelectedStore(newValues as YakklCurrentlySelected);\n\n\t\t// Update localStorage only if the encrypted data differs\n\t\t// const currentEncrypted = await verifyEncryption(current); // Encrypt current for comparison\n\t\t// if (!isEqual(currentEncrypted, newValues)) {\n\t\tawait setObjectInLocalStorage('yakklCurrentlySelected', newValues);\n\t\t// }\n\t\t// }\n\t\t// setYakklCurrentlySelectedStore(values);\n\t\t// const newValues = await verifyEncryption(values); // We put this after the store since data.<whatever> holds already encrypted data\n\t\t// await setObjectInLocalStorage('yakklCurrentlySelected', newValues);\n\t} catch (error) {\n\t\tlog.error('Error in setYakklCurrentlySelectedStorage:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function setYakklWatchListStorage(values: YakklWatch[]) {\n\ttry {\n\t\tyakklWatchListStore.set(values);\n\t\tawait setObjectInLocalStorage('yakklWatchList', values);\n\t} catch (error) {\n\t\tlog.error('Error in setYakklWatchListStorage:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function setYakklBlockedListStorage(values: YakklBlocked[]) {\n\ttry {\n\t\tyakklBlockedListStore.set(values);\n\t\tawait setObjectInLocalStorage('yakklBlockedList', values);\n\t} catch (error) {\n\t\tlog.error('Error in setYakklBlockedListStorage:', false, error);\n\t\tthrow error;\n\t}\n}\n\n// No need for memory store since only being held in persistent storage\nexport async function setYakklAccountsStorage(values: YakklAccount[]) {\n\ttry {\n\t\tconst newValues = (await verifyEncryption(values)) as unknown as YakklAccount[];\n\t\tyakklAccountsStore.set(newValues);\n\t\tawait setObjectInLocalStorage<YakklAccount[]>('yakklAccounts', newValues);\n\t} catch (error) {\n\t\tlog.error('Error in setYakklAccountsStorage:', false, error);\n\t\tthrow error;\n\t}\n}\n\n// No need for memory store since only being held in persistent storage\nexport async function setYakklPrimaryAccountsStorage(values: YakklPrimaryAccount[]) {\n\ttry {\n\t\tconst newValues = (await verifyEncryption(values)) as unknown as YakklPrimaryAccount[];\n\t\tyakklPrimaryAccountsStore.set(newValues);\n\t\tawait setObjectInLocalStorage('yakklPrimaryAccounts', newValues);\n\t} catch (error) {\n\t\tlog.error('Error in setYakklPrimaryAccountsStorage:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function updateYakklTokenData(updater: (token: TokenData) => TokenData) {\n\ttry {\n\t\t// Get the current token data from the store\n\t\tconst currentData = get(yakklTokenDataStore);\n\t\t// Update the token data using the updater function\n\t\tconst updatedData = currentData.map((token) => updater(token));\n\t\t// Update the store\n\t\tyakklTokenDataStore.set(updatedData);\n\t\t// Persist the updated data in local storage\n\t\tawait setObjectInLocalStorage('yakklTokenData', updatedData);\n\t} catch (error) {\n\t\tlog.error('Error updating token data:', false, error);\n\t\tthrow error;\n\t}\n}\n\nexport async function updateYakklTokenDataCustom(updater: (token: TokenData) => TokenData) {\n\ttry {\n\t\t// Get the current token data from the store\n\t\tconst currentData = get(yakklTokenDataCustomStore);\n\t\t// Update the token data using the updater function\n\t\tconst updatedData = currentData.map((token) => updater(token));\n\t\t// Update the store\n\t\tyakklTokenDataCustomStore.set(updatedData);\n\t\t// Persist the updated data in local storage\n\t\tawait setObjectInLocalStorage('yakklTokenDataCustom', updatedData);\n\t} catch (error) {\n\t\tlog.error('Error updating custom token data:', false, error);\n\t\tthrow error;\n\t}\n}\n\n// Function to update the combined store\nexport function updateCombinedTokenStore() {\n\tconst combinedTokens = [...get(yakklTokenDataStore), ...get(yakklTokenDataCustomStore)];\n\tyakklCombinedTokenStore.set(combinedTokens); // Single reactive update for the combined tokens\n}\n\n// Bookmarked Articles Storage\nexport async function getYakklBookmarkedArticles(): Promise<RSSItem[]> {\n\ttry {\n\t\tconst result = await getObjectFromLocalStorage<RSSItem[]>('yakklBookmarkedArticles');\n\t\tconst articles = result || [];\n\t\tyakklBookmarkedArticlesStore.set(articles); // Ensure store is in sync\n\t\treturn articles;\n\t} catch (error) {\n\t\tconsole.error('Error getting bookmarked articles:', error);\n\t\treturn [];\n\t}\n}\n\nexport async function setYakklBookmarkedArticles(articles: RSSItem[]): Promise<void> {\n\ttry {\n\t\tawait setObjectInLocalStorage('yakklBookmarkedArticles', articles);\n\t\tyakklBookmarkedArticlesStore.set(articles); // Update store after storage\n\t} catch (error) {\n\t\tconsole.error('Error setting bookmarked articles:', error);\n\t}\n}\n\n// Initialize bookmarked articles from storage\ngetYakklBookmarkedArticles().then((articles) => {\n\tyakklBookmarkedArticlesStore.set(articles);\n});\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nexport const prerender = false;\n\nimport { type SaltedKey } from '$lib/common';\nimport type { EncryptedData } from '$lib/common';\nimport { log } from '$lib/managers/Logger';\n// import { encodeJSON } from '$lib/utilities/utilities';\nimport { Buffer } from 'buffer';\n\nlet crypto: Crypto;\nif (typeof window !== 'undefined' && window.crypto) {\n\tcrypto = window.crypto;\n} else if (typeof global !== 'undefined' && global?.crypto) {\n\tcrypto = global.crypto;\n} else if (typeof require !== 'undefined') {\n\t// Node.js environment\n\t// eslint-disable-next-line @typescript-eslint/no-var-requires\n\tcrypto = require('crypto').webcrypto;\n} else {\n\tthrow new Error('No crypto support found');\n}\n\nfunction bufferToBase64(array: Uint8Array): string {\n\treturn Buffer.from(array).toString('base64');\n}\n\n// function base64ToBuffer(s: string): Uint8Array {\n//   return Buffer.from(s, \"base64\");\n// }\n\nfunction base64ToBuffer(base64: string): Uint8Array {\n\tconst binaryString = atob(base64);\n\tconst length = binaryString.length;\n\n\t// Explicitly type the buffer as ArrayBuffer (not ArrayBufferLike)\n\tconst buffer: ArrayBuffer = new ArrayBuffer(length);\n\tconst view = new Uint8Array(buffer);\n\n\tfor (let i = 0; i < length; i++) {\n\t\tview[i] = binaryString.charCodeAt(i);\n\t}\n\n\t// Create a new Uint8Array from the buffer to ensure correct typing\n\treturn new Uint8Array(view.buffer.slice(0));\n}\n\nfunction bufferForCrypto(base64: string): ArrayBuffer {\n\tconst binaryString = atob(base64);\n\tconst bytes = new Uint8Array(binaryString.length);\n\n\tfor (let i = 0; i < binaryString.length; i++) {\n\t\tbytes[i] = binaryString.charCodeAt(i);\n\t}\n\n\treturn bytes.buffer;\n}\n\nasync function generateSalt(): Promise<string> {\n\tconst saltBuffer = crypto.getRandomValues(new Uint8Array(64));\n\treturn bufferToBase64(saltBuffer);\n}\n\nexport async function digestMessage(message: string) {\n\tconst encoder = new TextEncoder();\n\tconst data = encoder.encode(message);\n\tconst hashBuffer = await crypto.subtle.digest('SHA-256', data);\n\tconst hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array\n\tconst hashHex = hashArray.map((b) => b.toString(16).padStart(2, '0')).join(''); // convert bytes to hex string\n\treturn hashHex;\n}\n\nexport async function deriveKeyFromPassword(\n\tpassword: string,\n\texistingSalt?: string\n): Promise<SaltedKey> {\n\tconst salt = existingSalt || (await generateSalt());\n\tconst encoder = new TextEncoder();\n\n\tconst derivationKey = await crypto.subtle.importKey(\n\t\t'raw',\n\t\tencoder.encode(password),\n\t\t{ name: 'PBKDF2' },\n\t\tfalse,\n\t\t['deriveKey']\n\t);\n\n\tconst key = await crypto.subtle.deriveKey(\n\t\t{\n\t\t\tname: 'PBKDF2',\n\t\t\tsalt: encoder.encode(salt),\n\t\t\titerations: 1000000,\n\t\t\thash: 'SHA-256'\n\t\t},\n\t\tderivationKey,\n\t\t{ name: 'AES-GCM', length: 256 },\n\t\tfalse,\n\t\t['encrypt', 'decrypt']\n\t);\n\n\treturn {\n\t\tkey,\n\t\tsalt\n\t};\n}\n\n// Made a copy of this function from utilities.ts due to some of the dependencies were svelte specific. Need to have another file that contains non-svelte specific functions\nfunction encodeJSON<T>(obj: T) {\n\treturn JSON.stringify(obj, (_, value) => {\n\t\tif (typeof value === 'bigint') {\n\t\t\treturn value.toString();\n\t\t}\n\t\treturn value;\n\t});\n}\n\nexport async function encryptData(\n\tdata: any,\n\tpasswordOrSaltedKey: string | SaltedKey\n): Promise<EncryptedData> {\n\ttry {\n\t\tif (!data) {\n\t\t\tthrow new Error('Missing data to encrypt');\n\t\t}\n\t\tif (!passwordOrSaltedKey) {\n\t\t\tthrow new Error('Missing password or key to encrypt data');\n\t\t}\n\n\t\tconst { key, salt } =\n\t\t\ttypeof passwordOrSaltedKey === 'string'\n\t\t\t\t? await deriveKeyFromPassword(passwordOrSaltedKey)\n\t\t\t\t: passwordOrSaltedKey;\n\n\t\tconst encoder = new TextEncoder();\n\t\tconst iv = crypto.getRandomValues(new Uint8Array(16));\n\t\tconst encodedData = encoder.encode(encodeJSON(data));\n\t\tconst cipherData = await crypto.subtle.encrypt(\n\t\t\t// note we use GCM mode to get authentication guarantees / tamper resistance\n\t\t\t{ name: 'AES-GCM', iv: iv },\n\t\t\tkey,\n\t\t\tencodedData\n\t\t);\n\n\t\treturn {\n\t\t\tdata: bufferToBase64(new Uint8Array(cipherData)),\n\t\t\tiv: bufferToBase64(iv),\n\t\t\tsalt\n\t\t} as EncryptedData;\n\t} catch (error) {\n\t\tlog.error('Error encrypting data:', false, error);\n\t\tthrow error;\n\t}\n}\n\n// Return json\nexport async function decryptData<T>(\n\tencryptedData: EncryptedData,\n\tpasswordOrSaltedKey: string | SaltedKey\n): Promise<T> {\n\ttry {\n\t\tif (!passwordOrSaltedKey) {\n\t\t\tthrow new Error('Missing password or key to decrypt data');\n\t\t}\n\t\tconst { data, iv, salt } = encryptedData;\n\t\tconst { key } =\n\t\t\ttypeof passwordOrSaltedKey === 'string'\n\t\t\t\t? await deriveKeyFromPassword(passwordOrSaltedKey, salt)\n\t\t\t\t: passwordOrSaltedKey;\n\n\t\tconst plaintext = await crypto.subtle.decrypt(\n\t\t\t{ name: 'AES-GCM', iv: bufferForCrypto(iv) },\n\t\t\tkey,\n\t\t\tbufferForCrypto(data)\n\t\t);\n\n\t\tconst txtDecoder = new TextDecoder().decode(plaintext);\n\t\treturn JSON.parse(txtDecoder) as T;\n\t} catch (error) {\n\t\tlog.error('Error decrypting data:', false, error);\n\t\tthrow error;\n\t}\n}\n\n// Create a helper function that ensures ArrayBuffer compatibility\nfunction ensureArrayBuffer(data: Uint8Array): Uint8Array {\n\t// If the underlying buffer is a SharedArrayBuffer, we need to copy it\n\tif (data.buffer instanceof SharedArrayBuffer) {\n\t\tconst newBuffer = new ArrayBuffer(data.byteLength);\n\t\tconst newArray = new Uint8Array(newBuffer);\n\t\tnewArray.set(data);\n\t\treturn newArray;\n\t}\n\treturn data;\n}\n"],"names":["log","debug","debugStack","warn","errorStack","info","infoStack","trace","error","LoggerInstance","bind","setLevel","setLogFilterEnabled","setLogFilterRegex","setStackIndex","setBackend","clearPersistedLogs","getPersistedLogs","SystemTheme","AccountTypeCategory","PlanType","AccessSourceType","PromoClassificationType","NetworkType","MessageType","VERSION","YEAR","PRO_ELIGIBLE_PROMO_TYPES","FOUNDING_MEMBER_DEADLINE","EARLY_ADOPTER_DEADLINES","date","price","DEFAULT_PERSONA","TIMELINES","NUM_OF_SPLASH_IMAGES","SPLASH_DELAY","ALERT_DELAY","IDLE_AUTO_LOCK_CYCLE","TIMER_PRICE_INTERVAL_TIME","TIMER_TOKEN_PRICE_CYCLE_TIME","TIMER_GAS_PRICE_CHECK","ETH_BASE_SWAP_GAS_UNITS","YAKKL_FEE_BASIS_POINTS","YAKKL_FEE_BASIS_POINTS_DIVISOR","YAKKL_ZERO_ADDRESS","YAKKL_ZERO_ACCOUNT_NAME","YAKKL_INTERNAL","YAKKL_DAPP","DEFAULT_POPUP_WIDTH","DEFAULT_POPUP_HEIGHT","DEFAULT_EXT_HEIGHT","DEFAULT_TITLE","DEFAULT_DERIVED_PATH_ETH","STORAGE_YAKKL_PREFERENCES","STORAGE_YAKKL_SETTINGS","STORAGE_YAKKL_CURRENTLY_SELECTED","STORAGE_YAKKL_REGISTERED_DATA","STORAGE_YAKKL_PROFILE","STORAGE_YAKKL_ACCOUNTS","STORAGE_YAKKL_PRIMARY_ACCOUNTS","STORAGE_YAKKL_CONTACTS","STORAGE_YAKKL_TOKENDATA","STORAGE_YAKKL_TOKENDATA_CUSTOM","STORAGE_YAKKL_COMBINED_TOKENS","STORAGE_YAKKL_CHATS","STORAGE_YAKKL_WATCHLIST","STORAGE_YAKKL_BLOCKEDLIST","STORAGE_YAKKL_CONNECTED_DOMAINS","STORAGE_YAKKL_WALLET_PROVIDERS","STORAGE_YAKKL_WALLET_BLOCKCHAINS","PATH_WELCOME","PATH_LOGOUT","PATH_ACCOUNTS","PATH_SECURITY","YakklError","Error","code","constructor","message","super","this","name","makeError","parseJsonRpcError","errorString","parsed","JSON","parse","jsonMatch","match","errorObj","formatErrorMessage","details","requestMethod","extractValue","url","jsonrpc","id","e","log$1","errorMappings","pattern","friendlyMessage","Object","entries","toLowerCase","includes","replace","charAt","toUpperCase","slice","key","RegExp","exec","BigNumber","_value","value","newValue","compare","other","a","toBigInt","b","from","isBigNumber","isHexObject","toNumber","Number","BigInt","hex","fromValue","max","min","add","subtract","sub","div","mul","mod","toString","bigintValue","toHex","isEthereum","hexString","length","decimals","isInteger","factor","Math","pow","round","integerPart","fractionalPart","split","repeat","scaledValue","value1","value2","bigint1","bigint2","fromHex","test","toFiat","numberValue","toFormattedFiat","currencyCode","locale","fiatValue","formatter","Intl","NumberFormat","style","currency","format","encodeJSON","obj","jsonString","stringify","_","keys","Array","isArray","isEmptyNullOrUndefined","isEncryptedData","data","iv","salt","isProfileData","pincode","isMetaData","meta","isString","Nibbles","maxValue","getBigInt","substring","argument","Uint8Array","result","v","safeConvertToBigInt","_hex","getObjectFromLocalStorage","async","timeoutMs","browser_ext","storagePromise","storage","local","get","timeoutPromise","Promise","resolve","setTimeout","race","setObjectInLocalStorage","set","dateString","Date","toISOString","formatDate","toLocaleString","formatTimestamp","timestamp","placeholder","options","month","day","hour","minute","isNaN","getTime","DateTimeFormat","yakklPreferences","persona","idleDelayInterval","showTestNetworks","dark","SYSTEM","chart","screenWidth","screenHeight","idleAutoLock","idleAutoLockCycle","symbol","words","wallet","title","extensionHeight","popupHeight","popupWidth","enableContextMenu","enableResize","splashDelay","alertDelay","splashImages","autoLockTimer","autoLockAsk","autoLockAskTimer","animationLockScreen","pinned","pinnedLocation","defaultWallet","theme","themes","animation","lockScreen","colors","primary","secondary","primaryBackgroundLight","primaryBackgroundDark","version","createDate","updateDate","yakklSettings","previousVersion","plan","type","BASIC_MEMBER","source","STANDARD","promo","trialEndDate","upgradeDate","trialCountdownPinned","legal","termsAgreed","privacyViewed","updated","platform","arch","nacl_arch","os","osVersion","browser","browserVersion","init","showHints","isLocked","isLockedHow","transactions","retry","enabled","howManyAttempts","seconds","baseFeeIncrease","priorityFeeIncrease","retain","days","includeRaw","lastAccessDate","yakklWatch","blockchain","tags","quantity","includeInPortfolio","explorer","address","addressAlias","yakklBlocked","domain","yakklRegisteredData","NONE","profile","userName","preferences","yakklChat","text","sender","yakklCurrentlySelected","shortcuts","accountType","PRIMARY","accountName","smartContract","alias","email","gasLimit","networks","chainId","MAINNET","TESTNET","network","yakklPrimaryAccount","index","account","subIndex","subAccounts","yakklAccount","description","primaryAccount","class","level","isSigner","avatar","connectedDomains","yakklContact","addressType","note","yakklAccounts","yakklPrimaryAccounts","yakklContacts","yakklChats","yakklBlockedList","yakklWatchList","EthereumBigNumber","toWei","ethValue","valueString","fractionalPartRaw","padEnd","toGwei","toEther","weiValue","toEtherString","etherValue","remainder","padStart","etherString","fromWei","fromGwei","gweiValue","fromEther","fractionalPartPadded","parseFloat","EthersConverter","toEthersHex","startsWith","transactionToEthersTransaction","transaction","to","nonce","gasPrice","maxPriorityFeePerGas","maxFeePerGas","accessList","customData","ethersTransactionResponseToTransactionResponse","tx","hash","blockNumber","blockHash","confirmations","wait","receipt","ethersTransactionReceiptToTransactionReceipt","contractAddress","transactionIndex","root","gasUsed","logsBloom","transactionHash","logs","map","ethersLogToLog","cumulativeGasUsed","effectiveGasPrice","byzantium","status","removed","topics","logIndex","ethersTransactionRequestToTransactionRequest","convertAccessList","item","storageKeys","BaseFeeManager","providers","initializationPromise","Map","addProvider","providerPromise","provider","getName","removeProvider","providerName","delete","getProviders","getGasEstimate","size","estimates","all","values","catch","console","then","filter","estimate","gasLimits","sort","baseFees","feeEstimate","baseFee","priorityFees","priorityFee","medianGasLimit","floor","medianBaseFee","medianPriorityFee","totalFee","getHistoricalGasData","duration","allHistoricalData","aggregatedData","flat","forEach","has","count","existing","predictFutureFees","allPredictions","aggregatedPredictions","prediction","estimatedBaseFee","estimatedPriorityFee","setPriorityOrder","providerNames","orderedProviders","setDefaultProvider","defaultProvider","TransactionSpeed","EOA_FALLBACK_GAS","LIMITS","BASE","GWEI","SLOW","PRIORITY_FEE","MAX_FEE","NORMAL","FAST","Web3Provider","AnalyticsBase","networkInfo","web3Provider","networkName","EthereumAnalytics","gasEstimates","swapEstimates","MAX_STORED_ENTRIES","providerStats","lastNetworkCheck","NETWORK_CHECK_INTERVAL","initializeProviderStats","create","analytics","initializeNetworkInfo","totalCalls","failedCalls","averageLatency","startTime","now","getBlockNumber","latency","rpcLatency","providerUrl","maskProviderUrl","getProviderURL","updateProviderStats","urlObj","URL","protocol","hostname","method","success","stats","lastError","lastErrorTime","trackGasEstimate","checkAndUpdateNetworkInfo","enrichedData","push","shift","methodName","errorMessage","estimateType","fallbackReason","trackSwapEstimate","swapType","getAnalyticsSummary","gasStats","calculateGasStats","swapStats","calculateSwapStats","providerHealth","timeWindow","start","end","commonErrors","methodUsage","totalGasPrice","totalLatency","maxFee","total","successful","fallbackUsed","averageGasPrice","lastBlockNumber","baseStats","popularPairs","totalHops","pair","tokenInSymbol","tokenOutSymbol","routeHops","averageHops","getProviderHealth","successRate","EthereumGasProvider","priceProvider","PRIORITY_FEE_MULTIPLIERS","BASE_FEE_MULTIPLIERS","FALLBACK_MULTIPLIERS","SAFE_FALLBACK_VALUES","BASE_PRIORITY_FEE","MAX_TOTAL_GWEI","MIN_TOTAL_GWEI","MIN_PRIORITY_FEE","web3ProviderType","determineProviderType","getNetwork","ALCHEMY","INFURA","CLOUDFLARE","QUICKNODE","CUSTOM","getFallbackGasPrice","speed","recentGasPrice","getGasPrice","multiplier","getOptimizedGasFees","feeData","getFeeData","priorityFeePerGas","customPriorityFee","basePriorityFee","customMaxFee","lastBaseFeePerGas","estimatedCostWei","estimatedCostEth","ethersv6","formatEther","ethPrice","getEthPrice","estimatedCostUsd","toFixed","estimateGas","optimizedFees","getSafeGasEstimate","getEOATransferGasEstimate","totalGwei","baseGasPrice","getChainId","getEOATransferGasEstimateWithFallback","fallbackValues","response","fetch","json","historicalData","baseFeePerGas","predictions","estimateSwapGasFee","tokenIn","tokenOut","fromAmount","slippageTolerance","deadline","swapManager","fee","BASE_SWAP_GAS","APPROVAL_GAS","totalGasUnits","isNative","gasCostWei","gasCostEth","gasCostUsd","amount","isMultiHop","dexUsed","marketPrice","getMarketPrice","getCurrentGasPriceInGwei","formatUnits","getGasPriceFromEtherscan","apiKey","ProposeGasPrice","getFormattedGasEstimates","gasEstimate","gasPriceInGwei","ethPriceInUsd","gasEstimateBigInt","gasPriceInEth","gasEstimateInEth","gasEstimateInUsd","setPriceProvider","CoinbasePriceProvider","getAPIKey","lastUpdated","getProviderPairFormat","fetchJson","num_products","products","AbstractBlockchain","icon","feeManager","isNetworkAndChainIdValid","initializeBlockchain","gasProvider","isInitialized","ensureInitialized","call","blockTag","connect","getBlockchainName","find","getNetworkByChainId","getIcon","getNetworks","getSymbol","setChainId","getChainIds","setNetwork","oldNetwork","setNetworkByChainId","getBalance","getOptions","getProvider","getSigner","getSignerNative","getProviderList","isSmartContractSupported","request","params","sendRawTransaction","signedTransaction","setProvider","_updateOptions","newOptions","overrideAll","AbstractContract","abi","signMessage","EthereumContract","contract","interface","Contract","Interface","functionName","args","getFunction","contractFunction","estimation","populateTransaction","sendTransaction","encodeFunctionData","on","eventName","listener","off","once","getFunctions","functions","functionFragments","fromEntries","fragments","fragment","getEvents","eventFragments","event","Ethereum","_options","createAccount","accountToDeriveFrom","accountInfo","createPrimaryAccount","path","createSubAccount","addressOrName","getBlock","blockHashOrBlockTag","getBlockWithTransactions","getCode","getLogs","getStorageAt","position","signTypedData","transction","getTransaction","getTransactionCount","getTransactionHistory","getTransactionReceipt","isAddress","returnValue","isSmartContract","contractCode","signTransaction","entropy","randomBytes","randomMnemonic","Mnemonic","fromEntropy","ethWallet","HDNodeWallet","fromMnemonic","extendedKey","privateKey","publicKey","publicKeyUncompressed","pathIndex","fingerPrint","fingerprint","parentFingerPrint","parentFingerprint","chainCode","primaryAccountData","mnemonic","phrase","password","wordCount","wordListLocale","wordlist","derivedPath","fromPhrase","accountData","assignedTo","subAccount","SUB","resolveName","lookupAddress","createContract","ADDRESSES","WETH","walletStore","writable","tokens","preferredTokenSymbols","sortedTokens","derived","$tokens","$preferredTokenSymbols","preferredTokens","token","nonPreferredTokens","eth","isStablecoin","logoURI","unshift","prerender","alert","msg","color","background","opacity","ms","loadCheckCurrentlySelectedStore","currentlySelected","getYakklCurrentlySelectedStore","miscStore","getMiscStore","decryptData","verifyEncryption","processItem","encryptData","yakklPreferencesStore","yakklSettingsStore","profileStore","yakklCurrentlySelectedStore","yakklContactsStore","yakklChatsStore","yakklAccountsStore","yakklPrimaryAccountsStore","yakklWatchListStore","yakklBlockedListStore","yakklConnectedDomainsStore","yakklMiscStore","yakklVeryStore","yakklVersionStore","yakklUserNameStore","yakklPricingStore","yakklGasTransStore","yakklContactStore","yakklAccountStore","yakklWalletProvidersStore","yakklWalletBlockchainsStore","yakklTokenDataStore","yakklTokenDataCustomStore","yakklCombinedTokenStore","yakklInstancesStore","yakklGPTRunningStore","yakklGPTKeyStore","yakklConnectionStore","yakklDappConnectRequestStore","priceStore","sessionInitialized","activeTabBackgroundStore","activeTabUIStore","backgroundUIConnectedStore","yakklContractStore","yakklContextTypeStore","yakklBookmarkedArticlesStore","resetStores","setPreferencesStore","setSettingsStore","setProfileStore","setYakklCurrentlySelectedStore","setYakklWatchListStore","setYakklBlockedListStore","setYakklContactsStore","setYakklChatsStore","setYakklAccountsStore","setYakklPrimaryAccountsStore","setYakklTokenDataStore","setYakklTokenDataCustomStore","setYakklCombinedTokenStore","setYakklWalletBlockchainsStore","setYakklWalletProvidersStore","setYakklConnectedDomainsStore","onError","storageChange","changes","yakklConnectedDomains","syncStorageToStore","settings","profileLocal","yakklCurrentlySelectedLocal","yakklTokenData","yakklTokenDataCustom","getPreferences","getSettings","getProfile","getYakklCurrentlySelected","getYakklWatchList","getYakklBlockedList","getYakklAccounts","getYakklPrimaryAccounts","getYakklContacts","getYakklChats","getYakklTokenData","getYakklTokenDataCustom","getYakklConnectedDomains","setSettings","setSettingsStorage","getYakklPreferenceStore","store","getSettingsStore","getProfileStore","getYakklWatchListStore","getYakklBlockedListStore","getYakklAccountsStore","getYakklPrimaryAccountsStore","getYakklContactsStore","getYakklTokenDataStore","getYakklTokenDataCustomStore","getYakklCombinedTokenStore","getYakklChatsStore","getYakklWalletBlockchainsStore","getYakklWalletProvidersStore","getYakklConnectedDomainsStore","getYakklContractStore","getContextTypeStore","getVeryStore","getDappConnectRequestStore","getContactStore","getAccountStore","getVersionStore","getUserNameStore","getYakklGPTKeyStore","getYakklConnectionStore","getYakklInstancesStore","setMiscStore","setContextTypeStore","setVeryStore","setDappConnectRequestStore","setContactStore","setAccountStore","setVersionStore","setUserNameStore","setYakklGPTKeyStore","setYakklConnectionStore","setYakklContractStore","setYakklInstancesStore","getYakklRegisteredData","getYakklCombinedToken","setYakklChatsStorage","getYakklWalletBlockchains","setYakklWalletBlockchainsStorage","getYakklWalletProviders","setYakklWalletProvidersStorage","d","setYakklContactsStorage","setYakklTokenDataStorage","setYakklTokenDataCustomStorage","setYakklCombinedTokenStorage","setYakklConnectedDomainsStorage","current","isEqual","setPreferencesStorage","setProfileStorage","setYakklCurrentlySelectedStorage","trim","newValues","setYakklWatchListStorage","setYakklBlockedListStorage","setYakklAccountsStorage","setYakklPrimaryAccountsStorage","updateYakklTokenData","updater","currentData","updatedData","updateYakklTokenDataCustom","updateCombinedTokenStore","combinedTokens","getYakklBookmarkedArticles","articles","setYakklBookmarkedArticles","crypto","window","global","require","webcrypto","bufferToBase64","array","Buffer","bufferForCrypto","base64","binaryString","atob","bytes","i","charCodeAt","buffer","generateSalt","saltBuffer","getRandomValues","digestMessage","encoder","TextEncoder","encode","hashBuffer","subtle","digest","hashArray","hashHex","join","deriveKeyFromPassword","existingSalt","derivationKey","importKey","deriveKey","iterations","passwordOrSaltedKey","encodedData","cipherData","encrypt","encryptedData","plaintext","decrypt","txtDecoder","TextDecoder","decode"],"mappings":"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"}