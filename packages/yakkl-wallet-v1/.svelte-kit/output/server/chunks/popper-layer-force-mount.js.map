{"version":3,"file":"popper-layer-force-mount.js","sources":["../../../../../../node_modules/.pnpm/svelte-toolbelt@0.4.6_svelte@5.34.3/node_modules/svelte-toolbelt/dist/utils/after-tick.js","../../../../../../node_modules/.pnpm/runed@0.15.4_svelte@5.34.3/node_modules/runed/dist/utilities/ElementSize/ElementSize.svelte.js","../../../../../../node_modules/.pnpm/runed@0.15.4_svelte@5.34.3/node_modules/runed/dist/utilities/watch/watch.svelte.js","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/internal/is.js","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/internal/use-state-machine.svelte.js","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/bits/utilities/presence-layer/usePresence.svelte.js","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/bits/utilities/presence-layer/presence-layer.svelte","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/internal/events.js","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/internal/debounce.js","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/internal/elements.js","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/bits/utilities/dismissible-layer/useDismissibleLayer.svelte.js","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/bits/utilities/dismissible-layer/dismissible-layer.svelte","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/bits/utilities/escape-layer/useEscapeLayer.svelte.js","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/bits/utilities/escape-layer/escape-layer.svelte","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/bits/utilities/focus-scope/focus-scope-stack.svelte.js","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/internal/focus.js","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/bits/utilities/focus-scope/useFocusScope.svelte.js","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/bits/utilities/focus-scope/focus-scope.svelte","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/bits/utilities/text-selection-layer/useTextSelectionLayer.svelte.js","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/bits/utilities/text-selection-layer/text-selection-layer.svelte","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/internal/create-shared-hook.svelte.js","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/internal/use-body-scroll-lock.svelte.js","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/bits/utilities/scroll-lock/scroll-lock.svelte","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/internal/floating-svelte/floating-utils.svelte.js","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/internal/floating-svelte/use-floating.svelte.js","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/bits/utilities/floating-layer/useFloatingLayer.svelte.js","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer.svelte","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-anchor.svelte","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-content.svelte","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-content-static.svelte","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-content.svelte","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer-inner.svelte","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer.svelte","../../../../../../node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.34.3/node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer-force-mount.svelte"],"sourcesContent":["import { tick } from \"svelte\";\nexport function afterTick(fn) {\n    tick().then(fn);\n}\n","import { get } from \"../../internal/utils/get.js\";\n/**\n * Returns a reactive value holding the size of `node`.\n *\n * Accepts an `options` object with the following properties:\n * - `initialSize`: The initial size of the element. Defaults to `{ width: 0, height: 0 }`.\n * - `box`: The box model to use. Can be either `\"content-box\"` or `\"border-box\"`. Defaults to `\"border-box\"`.\n *\n * @returns an object with `width` and `height` properties.\n *\n * @see {@link https://runed.dev/docs/utilities/element-size}\n */\nexport class ElementSize {\n    #size = $state({\n        width: 0,\n        height: 0,\n    });\n    constructor(node, options = { box: \"border-box\" }) {\n        this.#size = {\n            width: options.initialSize?.width ?? 0,\n            height: options.initialSize?.height ?? 0,\n        };\n        $effect(() => {\n            const node$ = get(node);\n            if (!node$)\n                return;\n            const observer = new ResizeObserver((entries) => {\n                for (const entry of entries) {\n                    const boxSize = options.box === \"content-box\" ? entry.contentBoxSize : entry.borderBoxSize;\n                    const boxSizeArr = Array.isArray(boxSize) ? boxSize : [boxSize];\n                    this.#size.width = boxSizeArr.reduce((acc, size) => Math.max(acc, size.inlineSize), 0);\n                    this.#size.height = boxSizeArr.reduce((acc, size) => Math.max(acc, size.blockSize), 0);\n                }\n            });\n            observer.observe(node$);\n            return () => {\n                observer.disconnect();\n            };\n        });\n    }\n    get width() {\n        return this.#size.width;\n    }\n    get height() {\n        return this.#size.height;\n    }\n}\n","import { untrack } from \"svelte\";\nfunction runEffect(flush, effect) {\n    switch (flush) {\n        case \"post\":\n            $effect(effect);\n            break;\n        case \"pre\":\n            $effect.pre(effect);\n            break;\n    }\n}\nfunction runWatcher(sources, flush, effect, options = {}) {\n    const { lazy = false } = options;\n    // Run the effect immediately if `lazy` is `false`.\n    let active = !lazy;\n    // On the first run, if the dependencies are an array, pass an empty array\n    // to the previous value instead of `undefined` to allow destructuring.\n    //\n    // watch(() => [a, b], ([a, b], [prevA, prevB]) => { ... });\n    let previousValues = Array.isArray(sources)\n        ? []\n        : undefined;\n    runEffect(flush, () => {\n        const values = Array.isArray(sources) ? sources.map((source) => source()) : sources();\n        if (!active) {\n            active = true;\n            previousValues = values;\n            return;\n        }\n        const cleanup = untrack(() => effect(values, previousValues));\n        previousValues = values;\n        return cleanup;\n    });\n}\nfunction runWatcherOnce(sources, flush, effect) {\n    const cleanupRoot = $effect.root(() => {\n        let stop = false;\n        runWatcher(sources, flush, (values, previousValues) => {\n            if (stop) {\n                cleanupRoot();\n                return;\n            }\n            // Since `lazy` is `true`, `previousValues` is always defined.\n            const cleanup = effect(values, previousValues);\n            stop = true;\n            return cleanup;\n        }, \n        // Running the effect immediately just once makes no sense at all.\n        // That's just `onMount` with extra steps.\n        { lazy: true });\n    });\n    $effect(() => {\n        return cleanupRoot;\n    });\n}\nexport function watch(sources, effect, options) {\n    runWatcher(sources, \"post\", effect, options);\n}\nfunction watchPre(sources, effect, options) {\n    runWatcher(sources, \"pre\", effect, options);\n}\nwatch.pre = watchPre;\nexport function watchOnce(source, effect) {\n    runWatcherOnce(source, \"post\", effect);\n}\nfunction watchOncePre(source, effect) {\n    runWatcherOnce(source, \"pre\", effect);\n}\nwatchOnce.pre = watchOncePre;\n","export const isBrowser = typeof document !== \"undefined\";\nexport const isIOS = getIsIOS();\nfunction getIsIOS() {\n    return (isBrowser &&\n        window?.navigator?.userAgent &&\n        // eslint-disable-next-line regexp/no-unused-capturing-group\n        (/iP(ad|hone|od)/.test(window.navigator.userAgent) ||\n            // The new iPad Pro Gen3 does not identify itself as iPad, but as Macintosh.\n            (window?.navigator?.maxTouchPoints > 2 &&\n                /iPad|Macintosh/.test(window?.navigator.userAgent))));\n}\nexport function isFunction(value) {\n    return typeof value === \"function\";\n}\nexport function isHTMLElement(element) {\n    return element instanceof HTMLElement;\n}\nexport function isElement(element) {\n    return element instanceof Element;\n}\nexport function isElementOrSVGElement(element) {\n    return element instanceof Element || element instanceof SVGElement;\n}\nexport function isNumberString(value) {\n    return !Number.isNaN(Number(value)) && !Number.isNaN(Number.parseFloat(value));\n}\nexport function isNull(value) {\n    return value === null;\n}\nexport function isTouch(e) {\n    return e.pointerType === \"touch\";\n}\nexport function isFocusVisible(element) {\n    return element.matches(\":focus-visible\");\n}\nexport function isNotNull(value) {\n    return value !== null;\n}\n/**\n * Determines if the provided object is a valid `HTMLInputElement` with\n * a `select` method available.\n */\nexport function isSelectableInput(element) {\n    return element instanceof HTMLInputElement && \"select\" in element;\n}\n/**\n * Given a node, determine if it is hidden by walking up the\n * DOM tree until we hit the `stopAt` node (exclusive), if provided)\n * otherwise we stop at the document root.\n */\nexport function isElementHidden(node, stopAt) {\n    if (getComputedStyle(node).visibility === \"hidden\")\n        return true;\n    while (node) {\n        // we stop at `upTo` (excluding it)\n        if (stopAt !== undefined && node === stopAt)\n            return false;\n        if (getComputedStyle(node).display === \"none\")\n            return true;\n        node = node.parentElement;\n    }\n    return false;\n}\n","import { box } from \"svelte-toolbelt\";\n/**\n * The `useStateMachine` function is a TypeScript function that creates a state machine and returns the\n * current state and a dispatch function to update the state based on events.\n * @param initialState - The `initialState` parameter is the initial state of the state machine. It\n * represents the starting point of the state machine's state.\n * @param machine - The `machine` parameter is an object that represents a state machine. It should\n * have keys that correspond to the possible states of the machine, and the values should be objects\n * that represent the possible events and their corresponding next states.\n * @returns The `useStateMachine` function returns an object with two properties: `state` and\n * `dispatch`.\n */\nexport function useStateMachine(initialState, machine) {\n    const state = box(initialState);\n    function reducer(event) {\n        // @ts-expect-error  state.value is keyof M\n        const nextState = machine[state.current][event];\n        return nextState ?? state.current;\n    }\n    const dispatch = (event) => {\n        state.current = reducer(event);\n    };\n    return {\n        state,\n        dispatch,\n    };\n}\n","import { afterTick } from \"svelte-toolbelt\";\nimport { Previous } from \"runed\";\nimport { untrack } from \"svelte\";\nimport { useStateMachine } from \"../../../internal/use-state-machine.svelte.js\";\nexport function usePresence(present, id) {\n    let styles = $state({});\n    let prevAnimationNameState = $state(\"none\");\n    const initialState = present.current ? \"mounted\" : \"unmounted\";\n    let node = $state(null);\n    const prevPresent = new Previous(() => present.current);\n    $effect(() => {\n        if (!id.current)\n            return;\n        if (!present.current)\n            return;\n        afterTick(() => {\n            node = document.getElementById(id.current);\n        });\n    });\n    const { state, dispatch } = useStateMachine(initialState, {\n        mounted: {\n            UNMOUNT: \"unmounted\",\n            ANIMATION_OUT: \"unmountSuspended\",\n        },\n        unmountSuspended: {\n            MOUNT: \"mounted\",\n            ANIMATION_END: \"unmounted\",\n        },\n        unmounted: {\n            MOUNT: \"mounted\",\n        },\n    });\n    $effect(() => {\n        const currPresent = present.current;\n        untrack(() => {\n            if (!node) {\n                node = document.getElementById(id.current);\n            }\n            if (!node)\n                return;\n            const hasPresentChanged = currPresent !== prevPresent.current;\n            if (!hasPresentChanged)\n                return;\n            const prevAnimationName = prevAnimationNameState;\n            const currAnimationName = getAnimationName(node);\n            if (currPresent) {\n                dispatch(\"MOUNT\");\n            }\n            else if (currAnimationName === \"none\" || styles.display === \"none\") {\n                // If there is no exit animation or the element is hidden, animations won't run\n                // so we unmount instantly\n                dispatch(\"UNMOUNT\");\n            }\n            else {\n                /**\n                 * When `present` changes to `false`, we check changes to animation-name to\n                 * determine whether an animation has started. We chose this approach (reading\n                 * computed styles) because there is no `animationrun` event and `animationstart`\n                 * fires after `animation-delay` has expired which would be too late.\n                 */\n                const isAnimating = prevAnimationName !== currAnimationName;\n                if (prevPresent && isAnimating) {\n                    dispatch(\"ANIMATION_OUT\");\n                }\n                else {\n                    dispatch(\"UNMOUNT\");\n                }\n            }\n        });\n    });\n    /**\n     * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`\n     * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we\n     * make sure we only trigger ANIMATION_END for the currently active animation.\n     */\n    function handleAnimationEnd(event) {\n        if (!node) {\n            node = document.getElementById(id.current);\n        }\n        if (!node)\n            return;\n        const currAnimationName = getAnimationName(node);\n        const isCurrentAnimation = currAnimationName.includes(event.animationName) || currAnimationName === \"none\";\n        if (event.target === node && isCurrentAnimation) {\n            dispatch(\"ANIMATION_END\");\n        }\n    }\n    function handleAnimationStart(event) {\n        if (!node) {\n            node = document.getElementById(id.current);\n        }\n        if (!node)\n            return;\n        if (event.target === node) {\n            prevAnimationNameState = getAnimationName(node);\n        }\n    }\n    $effect(() => {\n        state.current;\n        untrack(() => {\n            if (!node) {\n                node = document.getElementById(id.current);\n            }\n            if (!node)\n                return;\n            const currAnimationName = getAnimationName(node);\n            prevAnimationNameState = state.current === \"mounted\" ? currAnimationName : \"none\";\n        });\n    });\n    $effect(() => {\n        if (!node)\n            return;\n        styles = getComputedStyle(node);\n        node.addEventListener(\"animationstart\", handleAnimationStart);\n        node.addEventListener(\"animationcancel\", handleAnimationEnd);\n        node.addEventListener(\"animationend\", handleAnimationEnd);\n        return () => {\n            node?.removeEventListener(\"animationstart\", handleAnimationStart);\n            node?.removeEventListener(\"animationcancel\", handleAnimationEnd);\n            node?.removeEventListener(\"animationend\", handleAnimationEnd);\n        };\n    });\n    const isPresentDerived = $derived([\"mounted\", \"unmountSuspended\"].includes(state.current));\n    return {\n        get current() {\n            return isPresentDerived;\n        },\n    };\n}\nfunction getAnimationName(node) {\n    return node ? getComputedStyle(node).animationName || \"none\" : \"none\";\n}\n","<script lang=\"ts\">\n\timport { box } from \"svelte-toolbelt\";\n\timport type { PresenceLayerImplProps } from \"./types.js\";\n\timport { usePresence } from \"./usePresence.svelte.js\";\n\n\tlet { present, forceMount, presence, id }: PresenceLayerImplProps = $props();\n\n\tconst isPresent = usePresence(\n\t\tbox.with(() => present),\n\t\tbox.with(() => id)\n\t);\n</script>\n\n{#if forceMount || present || isPresent.current}\n\t{@render presence?.({ present: isPresent })}\n{/if}\n","/**\n * Adds an event listener to the specified target element(s) for the given event(s), and returns a function to remove it.\n * @param target The target element(s) to add the event listener to.\n * @param event The event(s) to listen for.\n * @param handler The function to be called when the event is triggered.\n * @param options An optional object that specifies characteristics about the event listener.\n * @returns A function that removes the event listener from the target element(s).\n */\nexport function addEventListener(target, event, handler, options) {\n    const events = Array.isArray(event) ? event : [event];\n    // Add the event listener to each specified event for the target element(s).\n    events.forEach((_event) => target.addEventListener(_event, handler, options));\n    // Return a function that removes the event listener from the target element(s).\n    return () => {\n        events.forEach((_event) => target.removeEventListener(_event, handler, options));\n    };\n}\n/**\n * Creates a typed event dispatcher and listener pair for custom events\n * @template T - The type of data that will be passed in the event detail\n * @param eventName - The name of the custom event\n * @param options - CustomEvent options (bubbles, cancelable, etc.)\n * @returns A tuple containing dispatch and listen functions\n */\nexport function createCustomEvent(eventName, options = { bubbles: true, cancelable: true }) {\n    function dispatch(element, detail) {\n        const event = new CustomEvent(eventName, {\n            ...options,\n            detail,\n        });\n        element.dispatchEvent(event);\n    }\n    function listen(element, callback) {\n        const handler = (event) => {\n            callback(event);\n        };\n        // @ts-expect-error shh\n        return addEventListener(element, eventName, handler);\n    }\n    return [dispatch, listen];\n}\n","// eslint-disable-next-line ts/no-explicit-any\nexport function debounce(fn, wait = 500) {\n    let timeout = null;\n    const debounced = (...args) => {\n        if (timeout !== null) {\n            clearTimeout(timeout);\n        }\n        timeout = setTimeout(() => {\n            fn(...args);\n        }, wait);\n    };\n    debounced.destroy = () => {\n        if (timeout !== null) {\n            clearTimeout(timeout);\n            timeout = null;\n        }\n    };\n    return debounced;\n}\n","export function isOrContainsTarget(node, target) {\n    return node === target || node.contains(target);\n}\nexport function getOwnerDocument(el) {\n    return el?.ownerDocument ?? document;\n}\n","import { untrack } from \"svelte\";\nimport { afterSleep, afterTick, box, executeCallbacks, onDestroyEffect, useRefById, } from \"svelte-toolbelt\";\nimport { addEventListener } from \"../../../internal/events.js\";\nimport { debounce } from \"../../../internal/debounce.js\";\nimport { noop } from \"../../../internal/noop.js\";\nimport { getOwnerDocument, isOrContainsTarget } from \"../../../internal/elements.js\";\nimport { isElement } from \"../../../internal/is.js\";\nglobalThis.bitsDismissableLayers ??= new Map();\nexport class DismissibleLayerState {\n    #interactOutsideProp;\n    #behaviorType;\n    #interceptedEvents = {\n        pointerdown: false,\n    };\n    #isResponsibleLayer = false;\n    node = box(null);\n    #documentObj = undefined;\n    #enabled;\n    #isFocusInsideDOMTree = $state(false);\n    #onFocusOutside;\n    currNode = $state(null);\n    #isValidEventProp;\n    #unsubClickListener = noop;\n    constructor(props) {\n        this.#enabled = props.enabled;\n        this.#isValidEventProp = props.isValidEvent;\n        useRefById({\n            id: props.id,\n            ref: this.node,\n            deps: () => this.#enabled.current,\n            onRefChange: (node) => {\n                this.currNode = node;\n            },\n        });\n        this.#behaviorType = props.interactOutsideBehavior;\n        this.#interactOutsideProp = props.onInteractOutside;\n        this.#onFocusOutside = props.onFocusOutside;\n        $effect(() => {\n            this.#documentObj = getOwnerDocument(this.currNode);\n        });\n        let unsubEvents = noop;\n        const cleanup = () => {\n            this.#resetState();\n            globalThis.bitsDismissableLayers.delete(this);\n            this.#handleInteractOutside.destroy();\n            unsubEvents();\n        };\n        $effect(() => {\n            if (this.#enabled.current && this.currNode) {\n                afterSleep(1, () => {\n                    if (!this.currNode)\n                        return;\n                    globalThis.bitsDismissableLayers.set(this, untrack(() => this.#behaviorType));\n                    unsubEvents();\n                    unsubEvents = this.#addEventListeners();\n                });\n            }\n            return () => {\n                cleanup();\n            };\n        });\n        onDestroyEffect(() => {\n            this.#resetState.destroy();\n            globalThis.bitsDismissableLayers.delete(this);\n            this.#handleInteractOutside.destroy();\n            this.#unsubClickListener();\n            unsubEvents();\n        });\n    }\n    #handleFocus = (event) => {\n        if (event.defaultPrevented)\n            return;\n        if (!this.currNode)\n            return;\n        afterTick(() => {\n            if (!this.currNode || this.#isTargetWithinLayer(event.target))\n                return;\n            if (event.target && !this.#isFocusInsideDOMTree) {\n                this.#onFocusOutside.current?.(event);\n            }\n        });\n    };\n    #addEventListeners() {\n        return executeCallbacks(\n        /**\n         * CAPTURE INTERACTION START\n         * mark interaction-start event as intercepted.\n         * mark responsible layer during interaction start\n         * to avoid checking if is responsible layer during interaction end\n         * when a new floating element may have been opened.\n         */\n        addEventListener(this.#documentObj, \"pointerdown\", executeCallbacks(this.#markInterceptedEvent, this.#markResponsibleLayer), true), \n        /**\n         * BUBBLE INTERACTION START\n         * Mark interaction-start event as non-intercepted. Debounce `onInteractOutsideStart`\n         * to avoid prematurely checking if other events were intercepted.\n         */\n        addEventListener(this.#documentObj, \"pointerdown\", executeCallbacks(this.#markNonInterceptedEvent, this.#handleInteractOutside)), \n        /**\n         * HANDLE FOCUS OUTSIDE\n         */\n        addEventListener(this.#documentObj, \"focusin\", this.#handleFocus));\n    }\n    #handleDismiss = (e) => {\n        let event = e;\n        if (event.defaultPrevented) {\n            event = createWrappedEvent(e);\n        }\n        this.#interactOutsideProp.current(e);\n    };\n    #handleInteractOutside = debounce((e) => {\n        if (!this.currNode) {\n            this.#unsubClickListener();\n            return;\n        }\n        const isEventValid = this.#isValidEventProp.current(e, this.currNode) || isValidEvent(e, this.currNode);\n        if (!this.#isResponsibleLayer || this.#isAnyEventIntercepted() || !isEventValid) {\n            this.#unsubClickListener();\n            return;\n        }\n        let event = e;\n        if (event.defaultPrevented) {\n            event = createWrappedEvent(event);\n        }\n        if (this.#behaviorType.current !== \"close\" &&\n            this.#behaviorType.current !== \"defer-otherwise-close\") {\n            this.#unsubClickListener();\n            return;\n        }\n        if (e.pointerType === \"touch\") {\n            this.#unsubClickListener();\n            // @ts-expect-error - later\n            this.#unsubClickListener = addEventListener(this.#documentObj, \"click\", this.#handleDismiss, { once: true });\n        }\n        else {\n            this.#interactOutsideProp.current(event);\n        }\n    }, 10);\n    #markInterceptedEvent = (e) => {\n        this.#interceptedEvents[e.type] = true;\n    };\n    #markNonInterceptedEvent = (e) => {\n        this.#interceptedEvents[e.type] = false;\n    };\n    #markResponsibleLayer = () => {\n        if (!this.node.current)\n            return;\n        this.#isResponsibleLayer = isResponsibleLayer(this.node.current);\n    };\n    #isTargetWithinLayer = (target) => {\n        if (!this.node.current)\n            return false;\n        return isOrContainsTarget(this.node.current, target);\n    };\n    #resetState = debounce(() => {\n        for (const eventType in this.#interceptedEvents) {\n            this.#interceptedEvents[eventType] = false;\n        }\n        this.#isResponsibleLayer = false;\n    }, 20);\n    #isAnyEventIntercepted() {\n        const i = Object.values(this.#interceptedEvents).some(Boolean);\n        return i;\n    }\n    #onfocuscapture = () => {\n        this.#isFocusInsideDOMTree = true;\n    };\n    #onblurcapture = () => {\n        this.#isFocusInsideDOMTree = false;\n    };\n    props = {\n        onfocuscapture: this.#onfocuscapture,\n        onblurcapture: this.#onblurcapture,\n    };\n}\nexport function useDismissibleLayer(props) {\n    return new DismissibleLayerState(props);\n}\nfunction getTopMostLayer(layersArr) {\n    return layersArr.findLast(([_, { current: behaviorType }]) => behaviorType === \"close\" || behaviorType === \"ignore\");\n}\nfunction isResponsibleLayer(node) {\n    const layersArr = [...globalThis.bitsDismissableLayers];\n    /**\n     * We first check if we can find a top layer with `close` or `ignore`.\n     * If that top layer was found and matches the provided node, then the node is\n     * responsible for the outside interaction. Otherwise, we know that all layers defer so\n     * the first layer is the responsible one.\n     */\n    const topMostLayer = getTopMostLayer(layersArr);\n    if (topMostLayer)\n        return topMostLayer[0].node.current === node;\n    const [firstLayerNode] = layersArr[0];\n    return firstLayerNode.node.current === node;\n}\nfunction isValidEvent(e, node) {\n    if (\"button\" in e && e.button > 0)\n        return false;\n    const target = e.target;\n    if (!isElement(target))\n        return false;\n    const ownerDocument = getOwnerDocument(target);\n    const isValid = ownerDocument.documentElement.contains(target) && !isOrContainsTarget(node, target);\n    return isValid;\n}\nfunction createWrappedEvent(e) {\n    const capturedCurrentTarget = e.currentTarget;\n    const capturedTarget = e.target;\n    let newEvent;\n    if (e instanceof PointerEvent) {\n        newEvent = new PointerEvent(e.type, e);\n    }\n    else {\n        newEvent = new PointerEvent(\"pointerdown\", e);\n    }\n    // track the prevented state separately\n    let isPrevented = false;\n    // Create a proxy to intercept property access and method calls\n    const wrappedEvent = new Proxy(newEvent, {\n        get: (target, prop) => {\n            if (prop === \"currentTarget\") {\n                return capturedCurrentTarget;\n            }\n            if (prop === \"target\") {\n                return capturedTarget;\n            }\n            if (prop === \"preventDefault\") {\n                return () => {\n                    isPrevented = true;\n                    if (typeof target.preventDefault === \"function\") {\n                        target.preventDefault();\n                    }\n                };\n            }\n            if (prop === \"defaultPrevented\") {\n                return isPrevented;\n            }\n            if (prop in target) {\n                // eslint-disable-next-line ts/no-explicit-any\n                return target[prop];\n            }\n            // eslint-disable-next-line ts/no-explicit-any\n            return e[prop];\n        },\n    });\n    return wrappedEvent;\n}\n","<script lang=\"ts\">\n\timport { box } from \"svelte-toolbelt\";\n\timport type { DismissibleLayerImplProps } from \"./types.js\";\n\timport { useDismissibleLayer } from \"./useDismissibleLayer.svelte.js\";\n\timport { noop } from \"../../../internal/noop.js\";\n\n\tlet {\n\t\tinteractOutsideBehavior = \"close\",\n\t\tonInteractOutside = noop,\n\t\tonFocusOutside = noop,\n\t\tid,\n\t\tchildren,\n\t\tenabled,\n\t\tisValidEvent = () => false,\n\t}: DismissibleLayerImplProps = $props();\n\n\tconst dismissibleLayerState = useDismissibleLayer({\n\t\tid: box.with(() => id),\n\t\tinteractOutsideBehavior: box.with(() => interactOutsideBehavior),\n\t\tonInteractOutside: box.with(() => onInteractOutside),\n\t\tenabled: box.with(() => enabled),\n\t\tonFocusOutside: box.with(() => onFocusOutside),\n\t\tisValidEvent: box.with(() => isValidEvent),\n\t});\n</script>\n\n{@render children?.({ props: dismissibleLayerState.props })}\n","import { untrack } from \"svelte\";\nimport { addEventListener } from \"../../../internal/events.js\";\nimport { kbd } from \"../../../internal/kbd.js\";\nimport { noop } from \"../../../internal/noop.js\";\nglobalThis.bitsEscapeLayers ??= new Map();\nexport class EscapeLayerState {\n    #onEscapeProp;\n    #behaviorType;\n    #enabled;\n    constructor(props) {\n        this.#behaviorType = props.escapeKeydownBehavior;\n        this.#onEscapeProp = props.onEscapeKeydown;\n        this.#enabled = props.enabled;\n        let unsubEvents = noop;\n        $effect(() => {\n            if (this.#enabled.current) {\n                globalThis.bitsEscapeLayers.set(this, untrack(() => this.#behaviorType));\n                unsubEvents = this.#addEventListener();\n            }\n            return () => {\n                unsubEvents();\n                globalThis.bitsEscapeLayers.delete(this);\n            };\n        });\n    }\n    #addEventListener = () => {\n        return addEventListener(document, \"keydown\", this.#onkeydown, { passive: false });\n    };\n    #onkeydown = (e) => {\n        if (e.key !== kbd.ESCAPE || !isResponsibleEscapeLayer(this))\n            return;\n        const clonedEvent = new KeyboardEvent(e.type, e);\n        e.preventDefault();\n        const behaviorType = this.#behaviorType.current;\n        if (behaviorType !== \"close\" && behaviorType !== \"defer-otherwise-close\")\n            return;\n        this.#onEscapeProp.current(clonedEvent);\n    };\n}\nexport function useEscapeLayer(props) {\n    return new EscapeLayerState(props);\n}\nfunction isResponsibleEscapeLayer(instance) {\n    const layersArr = [...globalThis.bitsEscapeLayers];\n    /**\n     * We first check if we can find a top layer with `close` or `ignore`.\n     * If that top layer was found and matches the provided node, then the node is\n     * responsible for the escape. Otherwise, we know that all layers defer so\n     * the first layer is the responsible one.\n     */\n    const topMostLayer = layersArr.findLast(([_, { current: behaviorType }]) => behaviorType === \"close\" || behaviorType === \"ignore\");\n    if (topMostLayer)\n        return topMostLayer[0] === instance;\n    const [firstLayerNode] = layersArr[0];\n    return firstLayerNode === instance;\n}\n","<script lang=\"ts\">\n\timport { box } from \"svelte-toolbelt\";\n\timport type { EscapeLayerImplProps } from \"./types.js\";\n\timport { useEscapeLayer } from \"./useEscapeLayer.svelte.js\";\n\timport { noop } from \"../../../internal/noop.js\";\n\n\tlet {\n\t\tescapeKeydownBehavior = \"close\",\n\t\tonEscapeKeydown = noop,\n\t\tchildren,\n\t\tenabled,\n\t}: EscapeLayerImplProps = $props();\n\n\tuseEscapeLayer({\n\t\tescapeKeydownBehavior: box.with(() => escapeKeydownBehavior),\n\t\tonEscapeKeydown: box.with(() => onEscapeKeydown),\n\t\tenabled: box.with(() => enabled),\n\t});\n</script>\n\n{@render children?.()}\n","import { box } from \"svelte-toolbelt\";\nimport { useId } from \"../../../internal/use-id.js\";\nconst focusStack = box([]);\nexport function createFocusScopeStack() {\n    const stack = focusStack;\n    return {\n        add(focusScope) {\n            // pause the currently active focus scope (top of the stack)\n            const activeFocusScope = stack.current[0];\n            if (focusScope.id !== activeFocusScope?.id) {\n                activeFocusScope?.pause();\n            }\n            // remove in case it already exists because it'll be added to the top\n            stack.current = removeFromFocusScopeArray(stack.current, focusScope);\n            stack.current.unshift(focusScope);\n        },\n        remove(focusScope) {\n            stack.current = removeFromFocusScopeArray(stack.current, focusScope);\n            stack.current[0]?.resume();\n        },\n    };\n}\nexport function createFocusScopeAPI() {\n    let paused = $state(false);\n    return {\n        id: useId(),\n        get paused() {\n            return paused;\n        },\n        pause() {\n            paused = true;\n        },\n        resume() {\n            paused = false;\n        },\n    };\n}\nfunction removeFromFocusScopeArray(arr, item) {\n    return [...arr].filter((i) => i.id !== item.id);\n}\nexport function removeLinks(items) {\n    return items.filter((item) => item.tagName !== \"A\");\n}\n","import { isBrowser, isElementHidden, isSelectableInput } from \"./is.js\";\n/**\n * Handles `initialFocus` prop behavior for the\n * Calendar & RangeCalendar components.\n */\nexport function handleCalendarInitialFocus(calendar) {\n    if (!isBrowser)\n        return;\n    const selectedDay = calendar.querySelector(\"[data-selected]\");\n    if (selectedDay)\n        return focusWithoutScroll(selectedDay);\n    const today = calendar.querySelector(\"[data-today]\");\n    if (today)\n        return focusWithoutScroll(today);\n    const firstDay = calendar.querySelector(\"[data-calendar-date]\");\n    if (firstDay)\n        return focusWithoutScroll(firstDay);\n}\n/**\n * A utility function that focuses an element without scrolling.\n */\nexport function focusWithoutScroll(element) {\n    const scrollPosition = {\n        x: window.pageXOffset || document.documentElement.scrollLeft,\n        y: window.pageYOffset || document.documentElement.scrollTop,\n    };\n    element.focus();\n    window.scrollTo(scrollPosition.x, scrollPosition.y);\n}\n/**\n * A utility function that focuses an element.\n */\nexport function focus(element, { select = false } = {}) {\n    if (!(element && element.focus))\n        return;\n    const previouslyFocusedElement = document.activeElement;\n    // prevent scroll on focus\n    element.focus({ preventScroll: true });\n    // only elect if its not the same element, it supports selection, and we need to select it\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select) {\n        element.select();\n    }\n}\n/**\n * Attempts to focus the first element in a list of candidates.\n * Stops when focus is successful.\n */\nexport function focusFirst(candidates, { select = false } = {}) {\n    const previouslyFocusedElement = document.activeElement;\n    for (const candidate of candidates) {\n        focus(candidate, { select });\n        if (document.activeElement !== previouslyFocusedElement) {\n            return true;\n        }\n    }\n}\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nexport function findVisible(elements, container) {\n    for (const element of elements) {\n        // we stop checking if it's hidden at the `container` level (excluding)\n        if (!isElementHidden(element, container))\n            return element;\n    }\n}\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nexport function getTabbableCandidates(container) {\n    const nodes = [];\n    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n        // eslint-disable-next-line ts/no-explicit-any\n        acceptNode: (node) => {\n            const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n            if (node.disabled || node.hidden || isHiddenInput)\n                return NodeFilter.FILTER_SKIP;\n            // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n            // runtime's understanding of tabbability, so this automatically accounts\n            // for any kind of element that could be tabbed to.\n            return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n        },\n    });\n    while (walker.nextNode())\n        nodes.push(walker.currentNode);\n    // we do not take into account the order of nodes with positive `tabIndex` as it\n    // hinders accessibility to have tab order different from visual order.\n    return nodes;\n}\n/**\n * A utility function that returns the first and last elements within a container that are\n * visible and focusable.\n */\nexport function getTabbableEdges(container) {\n    const candidates = getTabbableCandidates(container);\n    const first = findVisible(candidates, container);\n    const last = findVisible(candidates.reverse(), container);\n    return [first, last];\n}\n","import { untrack } from \"svelte\";\nimport { afterTick, box, executeCallbacks, useRefById } from \"svelte-toolbelt\";\nimport { createFocusScopeAPI, createFocusScopeStack, removeLinks, } from \"./focus-scope-stack.svelte.js\";\nimport { focus, focusFirst, getTabbableCandidates, getTabbableEdges } from \"../../../internal/focus.js\";\nimport { addEventListener } from \"../../../internal/events.js\";\nimport { isHTMLElement } from \"../../../internal/is.js\";\nimport { kbd } from \"../../../internal/kbd.js\";\nconst AUTOFOCUS_ON_MOUNT = \"focusScope.autoFocusOnMount\";\nconst AUTOFOCUS_ON_DESTROY = \"focusScope.autoFocusOnDestroy\";\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\nexport function useFocusScope({ id, loop, enabled, onOpenAutoFocus, onCloseAutoFocus, forceMount, }) {\n    const focusScopeStack = createFocusScopeStack();\n    const focusScope = createFocusScopeAPI();\n    const ref = box(null);\n    useRefById({\n        id,\n        ref,\n        deps: () => enabled.current,\n    });\n    let lastFocusedElement = $state(null);\n    $effect(() => {\n        const container = ref.current;\n        if (!container)\n            return;\n        if (!enabled.current)\n            return;\n        function handleFocusIn(event) {\n            if (focusScope.paused || !container)\n                return;\n            const target = event.target;\n            if (!isHTMLElement(target))\n                return;\n            if (container.contains(target)) {\n                lastFocusedElement = target;\n            }\n            else {\n                focus(lastFocusedElement, { select: true });\n            }\n        }\n        function handleFocusOut(event) {\n            if (focusScope.paused || !container)\n                return;\n            const relatedTarget = event.relatedTarget;\n            if (!isHTMLElement(relatedTarget))\n                return;\n            // A `focusout` event with a `null` `relatedTarget` will happen in at least two cases:\n            //\n            // 1. When the user switches app/tabs/windows/the browser itself loses focus.\n            // 2. In Google Chrome, when the focused element is removed from the DOM.\n            //\n            // We let the browser do its thing here because:\n            //\n            // 1. The browser already keeps a memory of what's focused for when the\n            // page gets refocused.\n            // 2. In Google Chrome, if we try to focus the deleted focused element it throws\n            // the CPU to 100%, so we avoid doing anything for this reason here too.\n            if (relatedTarget === null)\n                return;\n            // If the focus has moved to an actual legitimate element (`relatedTarget !== null`)\n            // that is outside the container, we move focus to the last valid focused element inside.\n            if (!container.contains(relatedTarget))\n                focus(lastFocusedElement, { select: true });\n        }\n        // When the focused element gets removed from the DOM, browsers move focus\n        // back to the document.body. In this case, we move focus to the container\n        // to keep focus trapped correctly.\n        // instead of leaning on document.activeElement, we use lastFocusedElement to check\n        // if the element still exists inside the container,\n        // if not then we focus to the container\n        function handleMutations(_) {\n            const lastFocusedElementExists = container?.contains(lastFocusedElement);\n            if (!lastFocusedElementExists) {\n                focus(container);\n            }\n        }\n        return untrack(() => {\n            const unsubEvents = executeCallbacks(addEventListener(document, \"focusin\", handleFocusIn), addEventListener(document, \"focusout\", handleFocusOut));\n            const mutationObserver = new MutationObserver(handleMutations);\n            mutationObserver.observe(container, { childList: true, subtree: true });\n            return () => {\n                unsubEvents();\n                mutationObserver.disconnect();\n            };\n        });\n    });\n    $effect(() => {\n        if (forceMount.current)\n            return;\n        let container = ref.current;\n        const previouslyFocusedElement = document.activeElement;\n        untrack(() => {\n            handleMount(container, previouslyFocusedElement);\n        });\n        return () => {\n            if (!container)\n                return;\n            handleDestroy(previouslyFocusedElement);\n        };\n    });\n    $effect(() => {\n        if (!forceMount.current)\n            return;\n        enabled.current;\n        const container = ref.current;\n        const previouslyFocusedElement = document.activeElement;\n        untrack(() => {\n            handleMount(container, previouslyFocusedElement);\n        });\n        return () => {\n            if (!container)\n                return;\n            handleDestroy(previouslyFocusedElement);\n        };\n    });\n    function handleMount(container, prevFocusedElement) {\n        if (!container)\n            container = document.getElementById(id.current);\n        if (!container)\n            return;\n        focusScopeStack.add(focusScope);\n        const hasFocusedCandidate = container.contains(prevFocusedElement);\n        if (!hasFocusedCandidate) {\n            const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n            onOpenAutoFocus.current(mountEvent);\n            if (!mountEvent.defaultPrevented) {\n                afterTick(() => {\n                    if (!container)\n                        return;\n                    focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });\n                    if (document.activeElement === prevFocusedElement) {\n                        focus(container);\n                    }\n                });\n            }\n        }\n    }\n    function handleDestroy(prevFocusedElement) {\n        const destroyEvent = new CustomEvent(AUTOFOCUS_ON_DESTROY, EVENT_OPTIONS);\n        onCloseAutoFocus.current(destroyEvent);\n        setTimeout(() => {\n            if (!destroyEvent.defaultPrevented && prevFocusedElement) {\n                focus(prevFocusedElement ?? document.body, { select: true });\n            }\n            focusScopeStack.remove(focusScope);\n        }, 0);\n    }\n    function handleKeydown(e) {\n        if (!enabled.current)\n            return;\n        if (!loop.current && !enabled.current)\n            return;\n        if (focusScope.paused)\n            return;\n        const isTabKey = e.key === kbd.TAB && !e.ctrlKey && !e.altKey && !e.metaKey;\n        const focusedElement = document.activeElement;\n        if (!(isTabKey && focusedElement))\n            return;\n        const container = ref.current;\n        if (!container)\n            return;\n        const [first, last] = getTabbableEdges(container);\n        const hasTabbableElementsInside = first && last;\n        if (!hasTabbableElementsInside) {\n            if (focusedElement === container) {\n                e.preventDefault();\n            }\n        }\n        else {\n            if (!e.shiftKey && focusedElement === last) {\n                e.preventDefault();\n                if (loop.current)\n                    focus(first, { select: true });\n            }\n            else if (e.shiftKey && focusedElement === first) {\n                e.preventDefault();\n                if (loop.current)\n                    focus(last, { select: true });\n            }\n        }\n    }\n    const props = $derived.by(() => ({\n        id: id.current,\n        tabindex: -1,\n        onkeydown: handleKeydown,\n    }));\n    return {\n        get props() {\n            return props;\n        },\n    };\n}\n","<script lang=\"ts\">\n\timport { box } from \"svelte-toolbelt\";\n\timport type { FocusScopeImplProps } from \"./types.js\";\n\timport { useFocusScope } from \"./useFocusScope.svelte.js\";\n\timport { noop } from \"../../../internal/noop.js\";\n\n\tlet {\n\t\tid,\n\t\ttrapFocus = false,\n\t\tloop = false,\n\t\tonCloseAutoFocus = noop,\n\t\tonOpenAutoFocus = noop,\n\t\tfocusScope,\n\t\tforceMount = false,\n\t}: FocusScopeImplProps = $props();\n\n\tconst focusScopeState = useFocusScope({\n\t\tenabled: box.with(() => trapFocus),\n\t\tloop: box.with(() => loop),\n\t\tonCloseAutoFocus: box.with(() => onCloseAutoFocus),\n\t\tonOpenAutoFocus: box.with(() => onOpenAutoFocus),\n\t\tid: box.with(() => id),\n\t\tforceMount: box.with(() => forceMount),\n\t});\n</script>\n\n{@render focusScope?.({ props: focusScopeState.props })}\n","import { untrack } from \"svelte\";\nimport { box, composeHandlers, executeCallbacks, useRefById, } from \"svelte-toolbelt\";\nimport { addEventListener } from \"../../../internal/events.js\";\nimport { noop } from \"../../../internal/noop.js\";\nimport { isHTMLElement } from \"../../../internal/is.js\";\nimport { isOrContainsTarget } from \"../../../internal/elements.js\";\nglobalThis.bitsTextSelectionLayers ??= new Map();\nexport class TextSelectionLayerState {\n    #id;\n    #onPointerDownProp;\n    #onPointerUpProp;\n    #enabled;\n    #unsubSelectionLock = noop;\n    #ref = box(null);\n    constructor(props) {\n        this.#id = props.id;\n        this.#enabled = props.preventOverflowTextSelection;\n        this.#onPointerDownProp = props.onPointerDown;\n        this.#onPointerUpProp = props.onPointerUp;\n        useRefById({\n            id: this.#id,\n            ref: this.#ref,\n            deps: () => this.#enabled.current,\n        });\n        let unsubEvents = noop;\n        $effect(() => {\n            if (this.#enabled.current) {\n                globalThis.bitsTextSelectionLayers.set(this, untrack(() => this.#enabled));\n                unsubEvents = this.#addEventListeners();\n            }\n            return () => {\n                unsubEvents();\n                this.#resetSelectionLock();\n                globalThis.bitsTextSelectionLayers.delete(this);\n            };\n        });\n    }\n    #addEventListeners() {\n        return executeCallbacks(addEventListener(document, \"pointerdown\", this.#pointerdown), addEventListener(document, \"pointerup\", composeHandlers(this.#resetSelectionLock, this.#onPointerUpProp)));\n    }\n    #pointerdown = (e) => {\n        const node = this.#ref.current;\n        const target = e.target;\n        if (!isHTMLElement(node) || !isHTMLElement(target) || !this.#enabled.current)\n            return;\n        /**\n         * We only lock user-selection overflow if layer is the top most layer and\n         * pointerdown occurred inside the node. You are still allowed to select text\n         * outside the node provided pointerdown occurs outside the node.\n         */\n        if (!isHighestLayer(this) || !isOrContainsTarget(node, target))\n            return;\n        this.#onPointerDownProp.current(e);\n        if (e.defaultPrevented)\n            return;\n        this.#unsubSelectionLock = preventTextSelectionOverflow(node);\n    };\n    #resetSelectionLock = () => {\n        this.#unsubSelectionLock();\n        this.#unsubSelectionLock = noop;\n    };\n}\nexport function useTextSelectionLayer(props) {\n    return new TextSelectionLayerState(props);\n}\nconst getUserSelect = (node) => node.style.userSelect || node.style.webkitUserSelect;\nfunction preventTextSelectionOverflow(node) {\n    const body = document.body;\n    const originalBodyUserSelect = getUserSelect(body);\n    const originalNodeUserSelect = getUserSelect(node);\n    setUserSelect(body, \"none\");\n    setUserSelect(node, \"text\");\n    return () => {\n        setUserSelect(body, originalBodyUserSelect);\n        setUserSelect(node, originalNodeUserSelect);\n    };\n}\nfunction setUserSelect(node, value) {\n    node.style.userSelect = value;\n    node.style.webkitUserSelect = value;\n}\nfunction isHighestLayer(instance) {\n    const layersArr = [...globalThis.bitsTextSelectionLayers];\n    if (!layersArr.length)\n        return false;\n    const highestLayer = layersArr.at(-1);\n    if (!highestLayer)\n        return false;\n    return highestLayer[0] === instance;\n}\n","<script lang=\"ts\">\n\timport { box } from \"svelte-toolbelt\";\n\timport type { TextSelectionLayerImplProps } from \"./types.js\";\n\timport { useTextSelectionLayer } from \"./useTextSelectionLayer.svelte.js\";\n\timport { noop } from \"../../../internal/noop.js\";\n\n\tlet {\n\t\tpreventOverflowTextSelection = true,\n\t\tonPointerDown = noop,\n\t\tonPointerUp = noop,\n\t\tid,\n\t\tchildren,\n\t\tenabled,\n\t}: TextSelectionLayerImplProps = $props();\n\n\tuseTextSelectionLayer({\n\t\tid: box.with(() => id),\n\t\tpreventOverflowTextSelection: box.with(() => preventOverflowTextSelection),\n\t\tonPointerDown: box.with(() => onPointerDown),\n\t\tonPointerUp: box.with(() => onPointerUp),\n\t\tenabled: box.with(() => enabled),\n\t});\n</script>\n\n{@render children?.()}\n","export function createSharedHook(factory) {\n    let subscribers = 0;\n    let state = $state();\n    let scope;\n    function dispose() {\n        subscribers -= 1;\n        if (scope && subscribers <= 0) {\n            scope();\n            state = undefined;\n            scope = undefined;\n        }\n    }\n    return ((...args) => {\n        subscribers += 1;\n        if (state === undefined) {\n            scope = $effect.root(() => {\n                state = factory(...args);\n            });\n        }\n        $effect(() => {\n            return () => {\n                dispose();\n            };\n        });\n        return state;\n    });\n}\n","import { SvelteMap } from \"svelte/reactivity\";\nimport { afterSleep, afterTick, box } from \"svelte-toolbelt\";\nimport { untrack } from \"svelte\";\nimport { isBrowser, isIOS } from \"./is.js\";\nimport { addEventListener } from \"./events.js\";\nimport { useId } from \"./use-id.js\";\nimport { createSharedHook } from \"./create-shared-hook.svelte.js\";\nconst useBodyLockStackCount = createSharedHook(() => {\n    const map = new SvelteMap();\n    const locked = $derived.by(() => {\n        for (const value of map.values()) {\n            if (value) {\n                return true;\n            }\n        }\n        return false;\n    });\n    let initialBodyStyle = $state({});\n    let stopTouchMoveListener = null;\n    function resetBodyStyle() {\n        if (!isBrowser)\n            return;\n        document.body.style.paddingRight = initialBodyStyle.paddingRight ?? \"\";\n        document.body.style.marginRight = initialBodyStyle.marginRight ?? \"\";\n        document.body.style.pointerEvents = initialBodyStyle.pointerEvents ?? \"\";\n        document.body.style.removeProperty(\"--scrollbar-width\");\n        document.body.style.overflow = initialBodyStyle.overflow ?? \"\";\n        isIOS && stopTouchMoveListener?.();\n    }\n    $effect(() => {\n        const curr = locked;\n        return untrack(() => {\n            if (!curr) {\n                return;\n            }\n            const bodyStyle = getComputedStyle(document.body);\n            initialBodyStyle.overflow = bodyStyle.overflow;\n            initialBodyStyle.paddingRight = bodyStyle.paddingRight;\n            initialBodyStyle.marginRight = bodyStyle.marginRight;\n            initialBodyStyle.pointerEvents = bodyStyle.pointerEvents;\n            // TODO: account for RTL direction, etc.\n            const verticalScrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n            const paddingRight = Number.parseInt(initialBodyStyle.paddingRight ?? \"0\", 10);\n            const config = {\n                padding: paddingRight + verticalScrollbarWidth,\n                margin: Number.parseInt(initialBodyStyle.marginRight ?? \"0\", 10),\n            };\n            if (verticalScrollbarWidth > 0) {\n                document.body.style.paddingRight = `${config.padding}px`;\n                document.body.style.marginRight = `${config.margin}px`;\n                document.body.style.setProperty(\"--scrollbar-width\", `${verticalScrollbarWidth}px`);\n                document.body.style.overflow = \"hidden\";\n            }\n            if (isIOS) {\n                stopTouchMoveListener = addEventListener(document, \"touchmove\", (e) => {\n                    if (e.target !== document.documentElement)\n                        return;\n                    if (e.touches.length > 1)\n                        return;\n                    e.preventDefault();\n                }, { passive: false });\n            }\n            afterTick(() => {\n                document.body.style.pointerEvents = \"none\";\n                document.body.style.overflow = \"hidden\";\n            });\n        });\n    });\n    $effect(() => {\n        return () => {\n            stopTouchMoveListener?.();\n        };\n    });\n    return {\n        get map() {\n            return map;\n        },\n        resetBodyStyle,\n    };\n});\nexport function useBodyScrollLock(initialState, restoreScrollDelay = () => null) {\n    const id = useId();\n    const countState = useBodyLockStackCount();\n    const _restoreScrollDelay = $derived(restoreScrollDelay());\n    countState.map.set(id, initialState ?? false);\n    const locked = box.with(() => countState.map.get(id) ?? false, (v) => countState.map.set(id, v));\n    $effect(() => {\n        return () => {\n            countState.map.delete(id);\n            // if any locks are still active, we don't reset the body style\n            if (isAnyLocked(countState.map))\n                return;\n            // if no locks are active (meaning this was the last lock), we reset the body style\n            if (_restoreScrollDelay === null) {\n                requestAnimationFrame(() => countState.resetBodyStyle());\n            }\n            else {\n                afterSleep(_restoreScrollDelay, () => countState.resetBodyStyle());\n            }\n        };\n    });\n    return locked;\n}\nfunction isAnyLocked(map) {\n    for (const [_, value] of map) {\n        if (value)\n            return true;\n    }\n    return false;\n}\n","<script lang=\"ts\">\n\timport type { ScrollLockProps } from \"./index.js\";\n\timport { useBodyScrollLock } from \"../../../internal/use-body-scroll-lock.svelte.js\";\n\n\tlet { preventScroll = true, restoreScrollDelay = null }: ScrollLockProps = $props();\n\n\tuseBodyScrollLock(preventScroll, () => restoreScrollDelay);\n</script>\n","export function get(valueOrGetValue) {\n    return typeof valueOrGetValue === \"function\"\n        ? valueOrGetValue()\n        : valueOrGetValue;\n}\nexport function getDPR(element) {\n    if (typeof window === \"undefined\")\n        return 1;\n    const win = element.ownerDocument.defaultView || window;\n    return win.devicePixelRatio || 1;\n}\nexport function roundByDPR(element, value) {\n    const dpr = getDPR(element);\n    return Math.round(value * dpr) / dpr;\n}\nexport function getFloatingContentCSSVars(name) {\n    return {\n        [`--bits-${name}-content-transform-origin`]: `var(--bits-floating-transform-origin)`,\n        [`--bits-${name}-content-available-width`]: `var(--bits-floating-available-width)`,\n        [`--bits-${name}-content-available-height`]: `var(--bits-floating-available-height)`,\n        [`--bits-${name}-anchor-width`]: `var(--bits-floating-anchor-width)`,\n        [`--bits-${name}-anchor-height`]: `var(--bits-floating-anchor-height)`,\n    };\n}\n","import { computePosition } from \"@floating-ui/dom\";\nimport { box } from \"svelte-toolbelt\";\nimport { get, getDPR, roundByDPR } from \"./floating-utils.svelte.js\";\nexport function useFloating(options) {\n    /** Options */\n    const whileElementsMountedOption = options.whileElementsMounted;\n    const openOption = $derived(get(options.open) ?? true);\n    const middlewareOption = $derived(get(options.middleware));\n    const transformOption = $derived(get(options.transform) ?? true);\n    const placementOption = $derived(get(options.placement) ?? \"bottom\");\n    const strategyOption = $derived(get(options.strategy) ?? \"absolute\");\n    const reference = options.reference;\n    /** State */\n    let x = $state(0);\n    let y = $state(0);\n    const floating = box(null);\n    let strategy = $state(strategyOption);\n    let placement = $state(placementOption);\n    let middlewareData = $state({});\n    let isPositioned = $state(false);\n    const floatingStyles = $derived.by(() => {\n        const initialStyles = {\n            position: strategy,\n            left: \"0\",\n            top: \"0\",\n        };\n        if (!floating.current) {\n            return initialStyles;\n        }\n        const xVal = roundByDPR(floating.current, x);\n        const yVal = roundByDPR(floating.current, y);\n        if (transformOption) {\n            return {\n                ...initialStyles,\n                transform: `translate(${xVal}px, ${yVal}px)`,\n                ...(getDPR(floating.current) >= 1.5 && {\n                    willChange: \"transform\",\n                }),\n            };\n        }\n        return {\n            position: strategy,\n            left: `${xVal}px`,\n            top: `${yVal}px`,\n        };\n    });\n    /** Effects */\n    let whileElementsMountedCleanup;\n    function update() {\n        if (reference.current === null || floating.current === null)\n            return;\n        computePosition(reference.current, floating.current, {\n            middleware: middlewareOption,\n            placement: placementOption,\n            strategy: strategyOption,\n        }).then((position) => {\n            x = position.x;\n            y = position.y;\n            strategy = position.strategy;\n            placement = position.placement;\n            middlewareData = position.middlewareData;\n            isPositioned = true;\n        });\n    }\n    function cleanup() {\n        if (typeof whileElementsMountedCleanup === \"function\") {\n            whileElementsMountedCleanup();\n            whileElementsMountedCleanup = undefined;\n        }\n    }\n    function attach() {\n        cleanup();\n        if (whileElementsMountedOption === undefined) {\n            update();\n            return;\n        }\n        if (reference.current === null || floating.current === null)\n            return;\n        whileElementsMountedCleanup = whileElementsMountedOption(reference.current, floating.current, update);\n    }\n    function reset() {\n        if (!openOption) {\n            isPositioned = false;\n        }\n    }\n    $effect(update);\n    $effect(attach);\n    $effect(reset);\n    $effect(() => cleanup);\n    return {\n        floating,\n        reference,\n        get strategy() {\n            return strategy;\n        },\n        get placement() {\n            return placement;\n        },\n        get middlewareData() {\n            return middlewareData;\n        },\n        get isPositioned() {\n            return isPositioned;\n        },\n        get floatingStyles() {\n            return floatingStyles;\n        },\n        get update() {\n            return update;\n        },\n    };\n}\n","import { untrack } from \"svelte\";\nimport { arrow, autoUpdate, flip, hide, limitShift, offset, shift, size, } from \"@floating-ui/dom\";\nimport { box, cssToStyleObj, styleToString, useRefById } from \"svelte-toolbelt\";\nimport { ElementSize } from \"runed\";\nimport { isNotNull } from \"../../../internal/is.js\";\nimport { useId } from \"../../../internal/use-id.js\";\nimport { useFloating } from \"../../../internal/floating-svelte/use-floating.svelte.js\";\nimport { createContext } from \"../../../internal/create-context.js\";\nexport const SIDE_OPTIONS = [\"top\", \"right\", \"bottom\", \"left\"];\nexport const ALIGN_OPTIONS = [\"start\", \"center\", \"end\"];\nconst OPPOSITE_SIDE = {\n    top: \"bottom\",\n    right: \"left\",\n    bottom: \"top\",\n    left: \"right\",\n};\nclass FloatingRootState {\n    anchorNode = box(null);\n    customAnchorNode = box(null);\n    triggerNode = box(null);\n    constructor() {\n        $effect(() => {\n            if (this.customAnchorNode.current) {\n                if (typeof this.customAnchorNode.current === \"string\") {\n                    this.anchorNode.current = document.querySelector(this.customAnchorNode.current);\n                }\n                else {\n                    this.anchorNode.current = this.customAnchorNode.current;\n                }\n            }\n            else {\n                this.anchorNode.current = this.triggerNode.current;\n            }\n        });\n    }\n}\nclass FloatingContentState {\n    // state\n    root;\n    // nodes\n    contentRef = box(null);\n    wrapperRef = box(null);\n    arrowRef = box(null);\n    // ids\n    arrowId = box(useId());\n    id;\n    wrapperId;\n    style;\n    #transformedStyle = $derived.by(() => {\n        if (typeof this.style === \"string\")\n            return cssToStyleObj(this.style);\n        if (!this.style)\n            return {};\n    });\n    #dir;\n    #side;\n    #sideOffset;\n    #align;\n    #alignOffset;\n    #arrowPadding;\n    #avoidCollisions;\n    #collisionBoundary;\n    #collisionPadding;\n    #sticky;\n    #hideWhenDetached;\n    #strategy;\n    #updatePositionStrategy = undefined;\n    onPlaced;\n    enabled;\n    #arrowSize = new ElementSize(() => this.arrowRef.current ?? undefined);\n    #arrowWidth = $derived(this.#arrowSize?.width ?? 0);\n    #arrowHeight = $derived(this.#arrowSize?.height ?? 0);\n    #desiredPlacement = $derived.by(() => (this.#side?.current +\n        (this.#align.current !== \"center\" ? `-${this.#align.current}` : \"\")));\n    #boundary = $derived.by(() => Array.isArray(this.#collisionBoundary.current)\n        ? this.#collisionBoundary.current\n        : [this.#collisionBoundary.current]);\n    hasExplicitBoundaries = $derived(this.#boundary.length > 0);\n    detectOverflowOptions = $derived.by(() => ({\n        padding: this.#collisionPadding.current,\n        boundary: this.#boundary.filter(isNotNull),\n        altBoundary: this.hasExplicitBoundaries,\n    }));\n    #availableWidth = $state(undefined);\n    #availableHeight = $state(undefined);\n    #anchorWidth = $state(undefined);\n    #anchorHeight = $state(undefined);\n    middleware = $derived.by(() => [\n        offset({\n            mainAxis: this.#sideOffset.current + this.#arrowHeight,\n            alignmentAxis: this.#alignOffset.current,\n        }),\n        this.#avoidCollisions.current &&\n            shift({\n                mainAxis: true,\n                crossAxis: false,\n                limiter: this.#sticky.current === \"partial\" ? limitShift() : undefined,\n                ...this.detectOverflowOptions,\n            }),\n        this.#avoidCollisions.current && flip({ ...this.detectOverflowOptions }),\n        size({\n            ...this.detectOverflowOptions,\n            apply: ({ rects, availableWidth, availableHeight }) => {\n                const { width: anchorWidth, height: anchorHeight } = rects.reference;\n                this.#availableWidth = availableWidth;\n                this.#availableHeight = availableHeight;\n                this.#anchorWidth = anchorWidth;\n                this.#anchorHeight = anchorHeight;\n            },\n        }),\n        this.arrowRef.current &&\n            arrow({ element: this.arrowRef.current, padding: this.#arrowPadding.current }),\n        transformOrigin({ arrowWidth: this.#arrowWidth, arrowHeight: this.#arrowHeight }),\n        this.#hideWhenDetached.current &&\n            hide({ strategy: \"referenceHidden\", ...this.detectOverflowOptions }),\n    ].filter(Boolean));\n    floating;\n    placedSide = $derived.by(() => getSideFromPlacement(this.floating.placement));\n    placedAlign = $derived.by(() => getAlignFromPlacement(this.floating.placement));\n    arrowX = $derived.by(() => this.floating.middlewareData.arrow?.x ?? 0);\n    arrowY = $derived.by(() => this.floating.middlewareData.arrow?.y ?? 0);\n    cannotCenterArrow = $derived.by(() => this.floating.middlewareData.arrow?.centerOffset !== 0);\n    contentZIndex = $state();\n    arrowBaseSide = $derived(OPPOSITE_SIDE[this.placedSide]);\n    wrapperProps = $derived.by(() => ({\n        id: this.wrapperId.current,\n        \"data-bits-floating-content-wrapper\": \"\",\n        style: {\n            ...this.floating.floatingStyles,\n            // keep off page when measuring\n            transform: this.floating.isPositioned\n                ? this.floating.floatingStyles.transform\n                : \"translate(0, -200%)\",\n            minWidth: \"max-content\",\n            zIndex: this.contentZIndex,\n            \"--bits-floating-transform-origin\": `${this.floating.middlewareData.transformOrigin?.x} ${this.floating.middlewareData.transformOrigin?.y}`,\n            \"--bits-floating-available-width\": `${this.#availableWidth}px`,\n            \"--bits-floating-available-height\": `${this.#availableHeight}px`,\n            \"--bits-floating-anchor-width\": `${this.#anchorWidth}px`,\n            \"--bits-floating-anchor-height\": `${this.#anchorHeight}px`,\n            // hide the content if using the hide middleware and should be hidden\n            ...(this.floating.middlewareData.hide?.referenceHidden && {\n                visibility: \"hidden\",\n                \"pointer-events\": \"none\",\n            }),\n            ...this.#transformedStyle,\n        },\n        // Floating UI calculates logical alignment based the `dir` attribute\n        dir: this.#dir.current,\n    }));\n    props = $derived.by(() => ({\n        \"data-side\": this.placedSide,\n        \"data-align\": this.placedAlign,\n        style: styleToString({\n            ...this.#transformedStyle,\n            // if the FloatingContent hasn't been placed yet (not all measurements done)\n            // we prevent animations so that users's animation don't kick in too early referring wrong sides\n            // animation: !this.floating.isPositioned ? \"none\" : undefined,\n        }),\n    }));\n    arrowStyle = $derived({\n        position: \"absolute\",\n        left: this.arrowX ? `${this.arrowX}px` : undefined,\n        top: this.arrowY ? `${this.arrowY}px` : undefined,\n        [this.arrowBaseSide]: 0,\n        \"transform-origin\": {\n            top: \"\",\n            right: \"0 0\",\n            bottom: \"center 0\",\n            left: \"100% 0\",\n        }[this.placedSide],\n        transform: {\n            top: \"translateY(100%)\",\n            right: \"translateY(50%) rotate(90deg) translateX(-50%)\",\n            bottom: \"rotate(180deg)\",\n            left: \"translateY(50%) rotate(-90deg) translateX(50%)\",\n        }[this.placedSide],\n        visibility: this.cannotCenterArrow ? \"hidden\" : undefined,\n    });\n    constructor(props, root) {\n        this.id = props.id;\n        this.#side = props.side;\n        this.#sideOffset = props.sideOffset;\n        this.#align = props.align;\n        this.#alignOffset = props.alignOffset;\n        this.#arrowPadding = props.arrowPadding;\n        this.#avoidCollisions = props.avoidCollisions;\n        this.#collisionBoundary = props.collisionBoundary;\n        this.#collisionPadding = props.collisionPadding;\n        this.#sticky = props.sticky;\n        this.#hideWhenDetached = props.hideWhenDetached;\n        this.#updatePositionStrategy = props.updatePositionStrategy;\n        this.onPlaced = props.onPlaced;\n        this.#strategy = props.strategy;\n        this.#dir = props.dir;\n        this.style = props.style;\n        this.root = root;\n        this.enabled = props.enabled;\n        this.wrapperId = props.wrapperId;\n        if (props.customAnchor) {\n            this.root.customAnchorNode.current = props.customAnchor.current;\n        }\n        $effect(() => {\n            props.customAnchor.current;\n            untrack(() => {\n                this.root.customAnchorNode.current = props.customAnchor.current;\n            });\n        });\n        useRefById({\n            id: this.wrapperId,\n            ref: this.wrapperRef,\n            deps: () => this.enabled.current,\n        });\n        useRefById({\n            id: this.id,\n            ref: this.contentRef,\n            deps: () => this.enabled.current,\n        });\n        this.floating = useFloating({\n            strategy: () => this.#strategy.current,\n            placement: () => this.#desiredPlacement,\n            middleware: () => this.middleware,\n            reference: this.root.anchorNode,\n            whileElementsMounted: (...args) => {\n                const cleanup = autoUpdate(...args, {\n                    animationFrame: this.#updatePositionStrategy?.current === \"always\",\n                });\n                return cleanup;\n            },\n            open: () => this.enabled.current,\n        });\n        $effect(() => {\n            if (!this.floating.isPositioned)\n                return;\n            this.onPlaced?.current();\n        });\n        $effect(() => {\n            const contentNode = this.contentRef.current;\n            if (!contentNode)\n                return;\n            untrack(() => {\n                this.contentZIndex = window.getComputedStyle(contentNode).zIndex;\n            });\n        });\n        $effect(() => {\n            this.floating.floating.current = this.wrapperRef.current;\n        });\n    }\n}\nclass FloatingArrowState {\n    #id;\n    #ref;\n    #content;\n    constructor(props, content) {\n        this.#content = content;\n        this.#id = props.id;\n        this.#ref = props.ref;\n        useRefById({\n            id: this.#id,\n            ref: this.#ref,\n            onRefChange: (node) => {\n                this.#content.arrowRef.current = node;\n            },\n            deps: () => this.#content.enabled.current,\n        });\n    }\n    props = $derived.by(() => ({\n        id: this.#id.current,\n        style: this.#content.arrowStyle,\n        \"data-side\": this.#content.placedSide,\n    }));\n}\nclass FloatingAnchorState {\n    ref = box(null);\n    constructor(props, root) {\n        if (props.virtualEl && props.virtualEl.current) {\n            root.triggerNode = box.from(props.virtualEl.current);\n        }\n        else {\n            useRefById({\n                id: props.id,\n                ref: this.ref,\n                onRefChange: (node) => {\n                    root.triggerNode.current = node;\n                },\n            });\n        }\n    }\n}\n//\n// CONTEXT METHODS\n//\nconst [setFloatingRootContext, getFloatingRootContext] = createContext(\"Floating.Root\");\nconst [setFloatingContentContext, getFloatingContentContext] = createContext(\"Floating.Content\");\nexport function useFloatingRootState() {\n    return setFloatingRootContext(new FloatingRootState());\n}\nexport function useFloatingContentState(props) {\n    return setFloatingContentContext(new FloatingContentState(props, getFloatingRootContext()));\n}\nexport function useFloatingArrowState(props) {\n    return new FloatingArrowState(props, getFloatingContentContext());\n}\nexport function useFloatingAnchorState(props) {\n    return new FloatingAnchorState(props, getFloatingRootContext());\n}\n//\n// HELPERS\n//\nfunction transformOrigin(options) {\n    return {\n        name: \"transformOrigin\",\n        options,\n        fn(data) {\n            const { placement, rects, middlewareData } = data;\n            const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n            const isArrowHidden = cannotCenterArrow;\n            const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;\n            const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;\n            const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n            const noArrowAlign = { start: \"0%\", center: \"50%\", end: \"100%\" }[placedAlign];\n            const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;\n            const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;\n            let x = \"\";\n            let y = \"\";\n            if (placedSide === \"bottom\") {\n                x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n                y = `${-arrowHeight}px`;\n            }\n            else if (placedSide === \"top\") {\n                x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n                y = `${rects.floating.height + arrowHeight}px`;\n            }\n            else if (placedSide === \"right\") {\n                x = `${-arrowHeight}px`;\n                y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n            }\n            else if (placedSide === \"left\") {\n                x = `${rects.floating.width + arrowHeight}px`;\n                y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n            }\n            return { data: { x, y } };\n        },\n    };\n}\nfunction getSideAndAlignFromPlacement(placement) {\n    const [side, align = \"center\"] = placement.split(\"-\");\n    return [side, align];\n}\nexport function getSideFromPlacement(placement) {\n    return getSideAndAlignFromPlacement(placement)[0];\n}\nexport function getAlignFromPlacement(placement) {\n    return getSideAndAlignFromPlacement(placement)[1];\n}\n","<script lang=\"ts\">\n\timport type { Snippet } from \"svelte\";\n\timport { useFloatingRootState } from \"../useFloatingLayer.svelte.js\";\n\n\tlet { children }: { children?: Snippet } = $props();\n\n\tuseFloatingRootState();\n</script>\n\n{@render children?.()}\n","<script lang=\"ts\">\n\timport { box } from \"svelte-toolbelt\";\n\timport { useFloatingAnchorState } from \"../useFloatingLayer.svelte.js\";\n\timport type { AnchorProps } from \"./index.js\";\n\timport type { Measurable } from \"../../../../internal/floating-svelte/types.js\";\n\n\tlet { id, children, virtualEl }: AnchorProps = $props();\n\n\tuseFloatingAnchorState({\n\t\tid: box.with(() => id),\n\t\tvirtualEl: box.with(() => virtualEl as unknown as Measurable | null),\n\t});\n</script>\n\n{@render children?.()}\n","<script lang=\"ts\">\n\timport { box, mergeProps } from \"svelte-toolbelt\";\n\timport { useFloatingContentState } from \"../useFloatingLayer.svelte.js\";\n\timport type { ContentImplProps } from \"./index.js\";\n\timport { useId } from \"../../../../internal/use-id.js\";\n\n\tlet {\n\t\tcontent,\n\t\tside = \"bottom\",\n\t\tsideOffset = 0,\n\t\talign = \"center\",\n\t\talignOffset = 0,\n\t\tid,\n\t\tarrowPadding = 0,\n\t\tavoidCollisions = true,\n\t\tcollisionBoundary = [],\n\t\tcollisionPadding = 0,\n\t\thideWhenDetached = false,\n\t\tonPlaced = () => {},\n\t\tsticky = \"partial\",\n\t\tupdatePositionStrategy = \"optimized\",\n\t\tstrategy = \"fixed\",\n\t\tdir = \"ltr\",\n\t\tstyle = {},\n\t\twrapperId = useId(),\n\t\tcustomAnchor = null,\n\t}: ContentImplProps = $props();\n\n\tconst contentState = useFloatingContentState({\n\t\tside: box.with(() => side),\n\t\tsideOffset: box.with(() => sideOffset),\n\t\talign: box.with(() => align),\n\t\talignOffset: box.with(() => alignOffset),\n\t\tid: box.with(() => id),\n\t\tarrowPadding: box.with(() => arrowPadding),\n\t\tavoidCollisions: box.with(() => avoidCollisions),\n\t\tcollisionBoundary: box.with(() => collisionBoundary),\n\t\tcollisionPadding: box.with(() => collisionPadding),\n\t\thideWhenDetached: box.with(() => hideWhenDetached),\n\t\tonPlaced: box.with(() => onPlaced),\n\t\tsticky: box.with(() => sticky),\n\t\tupdatePositionStrategy: box.with(() => updatePositionStrategy),\n\t\tstrategy: box.with(() => strategy),\n\t\tdir: box.with(() => dir),\n\t\tstyle: box.with(() => style),\n\t\tenabled: box.with(() => false),\n\t\twrapperId: box.with(() => wrapperId),\n\t\tcustomAnchor: box.with(() => customAnchor),\n\t});\n\n\tconst mergedProps = $derived(\n\t\tmergeProps(contentState.wrapperProps, {\n\t\t\tstyle: {\n\t\t\t\tpointerEvents: \"auto\",\n\t\t\t},\n\t\t})\n\t);\n</script>\n\n{@render content?.({ props: contentState.props, wrapperProps: mergedProps })}\n","<script lang=\"ts\">\n\timport { type Snippet, onMount } from \"svelte\";\n\n\tlet {\n\t\tcontent,\n\t\tonPlaced,\n\t}: {\n\t\tcontent?: Snippet<\n\t\t\t[{ props: Record<string, unknown>; wrapperProps: Record<string, unknown> }]\n\t\t>;\n\t\tonPlaced?: () => void;\n\t} = $props();\n\n\tonMount(() => {\n\t\tonPlaced?.();\n\t});\n</script>\n\n{@render content?.({ props: {}, wrapperProps: {} })}\n","<script lang=\"ts\">\n\timport FloatingLayerContentStatic from \"../floating-layer/components/floating-layer-content-static.svelte\";\n\timport FloatingLayerContent from \"../floating-layer/components/floating-layer-content.svelte\";\n\timport type { FloatingLayerContentImplProps } from \"../floating-layer/types.js\";\n\n\tlet {\n\t\tcontent,\n\t\tisStatic = false,\n\t\tonPlaced,\n\t\t...restProps\n\t}: FloatingLayerContentImplProps & { isStatic: boolean } = $props();\n</script>\n\n{#if isStatic}\n\t<FloatingLayerContentStatic {content} {onPlaced} />\n{:else}\n\t<FloatingLayerContent {content} {onPlaced} {...restProps} />\n{/if}\n","<script lang=\"ts\">\n\timport { mergeProps } from \"svelte-toolbelt\";\n\timport ScrollLock from \"../scroll-lock/scroll-lock.svelte\";\n\timport type { PopperLayerImplProps } from \"./types.js\";\n\timport PopperContent from \"./popper-content.svelte\";\n\timport EscapeLayer from \"../escape-layer/escape-layer.svelte\";\n\timport DismissibleLayer from \"../dismissible-layer/dismissible-layer.svelte\";\n\timport TextSelectionLayer from \"../text-selection-layer/text-selection-layer.svelte\";\n\timport FocusScope from \"../focus-scope/focus-scope.svelte\";\n\n\tlet {\n\t\tpopper,\n\t\tonEscapeKeydown,\n\t\tescapeKeydownBehavior,\n\t\tpreventOverflowTextSelection,\n\t\tid,\n\t\tonPointerDown,\n\t\tonPointerUp,\n\t\tside,\n\t\tsideOffset,\n\t\talign,\n\t\talignOffset,\n\t\tarrowPadding,\n\t\tavoidCollisions,\n\t\tcollisionBoundary,\n\t\tcollisionPadding,\n\t\tsticky,\n\t\thideWhenDetached,\n\t\tupdatePositionStrategy,\n\t\tstrategy,\n\t\tdir,\n\t\tpreventScroll,\n\t\twrapperId,\n\t\tstyle,\n\t\tonPlaced,\n\t\tonInteractOutside,\n\t\tonCloseAutoFocus,\n\t\tonOpenAutoFocus,\n\t\tonFocusOutside,\n\t\tinteractOutsideBehavior = \"close\",\n\t\tloop,\n\t\ttrapFocus = true,\n\t\tisValidEvent = () => false,\n\t\tcustomAnchor = null,\n\t\tisStatic = false,\n\t\tenabled,\n\t\t...restProps\n\t}: Omit<PopperLayerImplProps, \"present\" | \"children\"> & {\n\t\tenabled: boolean;\n\t} = $props();\n</script>\n\n<PopperContent\n\t{isStatic}\n\t{id}\n\t{side}\n\t{sideOffset}\n\t{align}\n\t{alignOffset}\n\t{arrowPadding}\n\t{avoidCollisions}\n\t{collisionBoundary}\n\t{collisionPadding}\n\t{sticky}\n\t{hideWhenDetached}\n\t{updatePositionStrategy}\n\t{strategy}\n\t{dir}\n\t{wrapperId}\n\t{style}\n\t{onPlaced}\n\t{customAnchor}\n>\n\t{#snippet content({ props: floatingProps, wrapperProps })}\n\t\t{#if restProps.forceMount && enabled}\n\t\t\t<ScrollLock {preventScroll} />\n\t\t{:else if !restProps.forceMount}\n\t\t\t<ScrollLock {preventScroll} />\n\t\t{/if}\n\t\t<FocusScope\n\t\t\t{id}\n\t\t\t{onOpenAutoFocus}\n\t\t\t{onCloseAutoFocus}\n\t\t\t{loop}\n\t\t\ttrapFocus={enabled && trapFocus}\n\t\t\tforceMount={restProps.forceMount}\n\t\t>\n\t\t\t{#snippet focusScope({ props: focusScopeProps })}\n\t\t\t\t<EscapeLayer {onEscapeKeydown} {escapeKeydownBehavior} {enabled}>\n\t\t\t\t\t<DismissibleLayer\n\t\t\t\t\t\t{id}\n\t\t\t\t\t\t{onInteractOutside}\n\t\t\t\t\t\t{onFocusOutside}\n\t\t\t\t\t\t{interactOutsideBehavior}\n\t\t\t\t\t\t{isValidEvent}\n\t\t\t\t\t\t{enabled}\n\t\t\t\t\t>\n\t\t\t\t\t\t{#snippet children({ props: dismissibleProps })}\n\t\t\t\t\t\t\t<TextSelectionLayer\n\t\t\t\t\t\t\t\t{id}\n\t\t\t\t\t\t\t\t{preventOverflowTextSelection}\n\t\t\t\t\t\t\t\t{onPointerDown}\n\t\t\t\t\t\t\t\t{onPointerUp}\n\t\t\t\t\t\t\t\t{enabled}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{@render popper?.({\n\t\t\t\t\t\t\t\t\tprops: mergeProps(\n\t\t\t\t\t\t\t\t\t\trestProps,\n\t\t\t\t\t\t\t\t\t\tfloatingProps,\n\t\t\t\t\t\t\t\t\t\tdismissibleProps,\n\t\t\t\t\t\t\t\t\t\tfocusScopeProps,\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tstyle: {\n\t\t\t\t\t\t\t\t\t\t\t\tpointerEvents: \"auto\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\twrapperProps,\n\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t</TextSelectionLayer>\n\t\t\t\t\t\t{/snippet}\n\t\t\t\t\t</DismissibleLayer>\n\t\t\t\t</EscapeLayer>\n\t\t\t{/snippet}\n\t\t</FocusScope>\n\t{/snippet}\n</PopperContent>\n","<script lang=\"ts\">\n\timport type { PopperLayerImplProps } from \"./types.js\";\n\timport PopperLayerInner from \"./popper-layer-inner.svelte\";\n\timport PresenceLayer from \"../presence-layer/presence-layer.svelte\";\n\n\tlet {\n\t\tpopper,\n\t\tpresent,\n\t\tonEscapeKeydown,\n\t\tescapeKeydownBehavior,\n\t\tpreventOverflowTextSelection,\n\t\tid,\n\t\tonPointerDown,\n\t\tonPointerUp,\n\t\tside,\n\t\tsideOffset,\n\t\talign,\n\t\talignOffset,\n\t\tarrowPadding,\n\t\tavoidCollisions,\n\t\tcollisionBoundary,\n\t\tcollisionPadding,\n\t\tsticky,\n\t\thideWhenDetached,\n\t\tupdatePositionStrategy,\n\t\tstrategy,\n\t\tdir,\n\t\tpreventScroll,\n\t\twrapperId,\n\t\tstyle,\n\t\tonPlaced,\n\t\tonInteractOutside,\n\t\tonCloseAutoFocus,\n\t\tonOpenAutoFocus,\n\t\tonFocusOutside,\n\t\tinteractOutsideBehavior = \"close\",\n\t\tloop,\n\t\ttrapFocus = true,\n\t\tisValidEvent = () => false,\n\t\tcustomAnchor = null,\n\t\tisStatic = false,\n\t\t...restProps\n\t}: PopperLayerImplProps = $props();\n</script>\n\n<PresenceLayer {id} {present} {...restProps}>\n\t{#snippet presence({ present })}\n\t\t<PopperLayerInner\n\t\t\t{popper}\n\t\t\t{onEscapeKeydown}\n\t\t\t{escapeKeydownBehavior}\n\t\t\t{preventOverflowTextSelection}\n\t\t\t{id}\n\t\t\t{onPointerDown}\n\t\t\t{onPointerUp}\n\t\t\t{side}\n\t\t\t{sideOffset}\n\t\t\t{align}\n\t\t\t{alignOffset}\n\t\t\t{arrowPadding}\n\t\t\t{avoidCollisions}\n\t\t\t{collisionBoundary}\n\t\t\t{collisionPadding}\n\t\t\t{sticky}\n\t\t\t{hideWhenDetached}\n\t\t\t{updatePositionStrategy}\n\t\t\t{strategy}\n\t\t\t{dir}\n\t\t\t{preventScroll}\n\t\t\t{wrapperId}\n\t\t\t{style}\n\t\t\t{onPlaced}\n\t\t\t{customAnchor}\n\t\t\t{isStatic}\n\t\t\tenabled={present.current}\n\t\t\t{onInteractOutside}\n\t\t\t{onCloseAutoFocus}\n\t\t\t{onOpenAutoFocus}\n\t\t\t{interactOutsideBehavior}\n\t\t\t{loop}\n\t\t\t{trapFocus}\n\t\t\t{isValidEvent}\n\t\t\t{onFocusOutside}\n\t\t\tforceMount={false}\n\t\t\t{...restProps}\n\t\t/>\n\t{/snippet}\n</PresenceLayer>\n","<script lang=\"ts\">\n\timport type { PopperLayerImplProps } from \"./types.js\";\n\timport PopperLayerInner from \"./popper-layer-inner.svelte\";\n\n\tlet {\n\t\tpopper,\n\t\tonEscapeKeydown,\n\t\tescapeKeydownBehavior,\n\t\tpreventOverflowTextSelection,\n\t\tid,\n\t\tonPointerDown,\n\t\tonPointerUp,\n\t\tside,\n\t\tsideOffset,\n\t\talign,\n\t\talignOffset,\n\t\tarrowPadding,\n\t\tavoidCollisions,\n\t\tcollisionBoundary,\n\t\tcollisionPadding,\n\t\tsticky,\n\t\thideWhenDetached,\n\t\tupdatePositionStrategy,\n\t\tstrategy,\n\t\tdir,\n\t\tpreventScroll,\n\t\twrapperId,\n\t\tstyle,\n\t\tonPlaced,\n\t\tonInteractOutside,\n\t\tonCloseAutoFocus,\n\t\tonOpenAutoFocus,\n\t\tonFocusOutside,\n\t\tinteractOutsideBehavior = \"close\",\n\t\tloop,\n\t\ttrapFocus = true,\n\t\tisValidEvent = () => false,\n\t\tcustomAnchor = null,\n\t\tisStatic = false,\n\t\tenabled,\n\t\t...restProps\n\t}: Omit<PopperLayerImplProps, \"present\"> & {\n\t\tenabled: boolean;\n\t} = $props();\n</script>\n\n<PopperLayerInner\n\t{popper}\n\t{onEscapeKeydown}\n\t{escapeKeydownBehavior}\n\t{preventOverflowTextSelection}\n\t{id}\n\t{onPointerDown}\n\t{onPointerUp}\n\t{side}\n\t{sideOffset}\n\t{align}\n\t{alignOffset}\n\t{arrowPadding}\n\t{avoidCollisions}\n\t{collisionBoundary}\n\t{collisionPadding}\n\t{sticky}\n\t{hideWhenDetached}\n\t{updatePositionStrategy}\n\t{strategy}\n\t{dir}\n\t{preventScroll}\n\t{wrapperId}\n\t{style}\n\t{onPlaced}\n\t{customAnchor}\n\t{isStatic}\n\t{enabled}\n\t{onInteractOutside}\n\t{onCloseAutoFocus}\n\t{onOpenAutoFocus}\n\t{interactOutsideBehavior}\n\t{loop}\n\t{trapFocus}\n\t{isValidEvent}\n\t{onFocusOutside}\n\t{...restProps}\n\tforceMount={true}\n/>\n"],"names":["afterTick","fn","tick","then","ElementSize","size","width","height","constructor","node","options","box","this","initialSize","runWatcher","sources","flush","effect","lazy","watch","watchPre","pre","isBrowser","document","isHTMLElement","element","HTMLElement","isElement","Element","isElementOrSVGElement","SVGElement","isTouch","e","pointerType","isFocusVisible","matches","isNotNull","value","isSelectableInput","HTMLInputElement","isElementHidden","stopAt","getComputedStyle","visibility","display","parentElement","useStateMachine","initialState","machine","state","reducer","event","nextState","current","dispatch","usePresence","present","id","mounted","UNMOUNT","ANIMATION_OUT","unmountSuspended","MOUNT","ANIMATION_END","unmounted","isPresentDerived","includes","forceMount","presence","$$props","isPresent","with","$$payload","addEventListener","target","handler","events","Array","isArray","forEach","_event","removeEventListener","debounce","wait","timeout","debounced","args","clearTimeout","setTimeout","destroy","isOrContainsTarget","contains","getOwnerDocument","el","ownerDocument","globalThis","bitsDismissableLayers","Map","DismissibleLayerState","pointerdown","isResponsibleLayer","documentObj","isFocusInsideDOMTree","currNode","unsubClickListener","noop","props","enabled","isValidEventProp","isValidEvent","useRefById","ref","deps","onRefChange","behaviorType","interactOutsideBehavior","interactOutsideProp","onInteractOutside","onFocusOutside","defaultPrevented","addEventListeners","executeCallbacks","markResponsibleLayer","markNonInterceptedEvent","handleFocus","createWrappedEvent","handleInteractOutside","isEventValid","handleDismiss","once","type","resetState","eventType","interceptedEvents","isAnyEventIntercepted","i","Object","values","some","Boolean","onfocuscapture","onblurcapture","useDismissibleLayer","getTopMostLayer","layersArr","findLast","_","topMostLayer","firstLayerNode","button","isValid","documentElement","capturedCurrentTarget","currentTarget","capturedTarget","newEvent","PointerEvent","isPrevented","wrappedEvent","Proxy","get","prop","preventDefault","children","dismissibleLayerState","bitsEscapeLayers","EscapeLayerState","escapeKeydownBehavior","onEscapeProp","onEscapeKeydown","onkeydown","passive","key","kbd.ESCAPE","isResponsibleEscapeLayer","clonedEvent","KeyboardEvent","useEscapeLayer","instance","createFocusScopeAPI","paused","useId","pause","resume","focus","select","previouslyFocusedElement","activeElement","preventScroll","focusFirst","candidates","candidate","findVisible","elements","container","getTabbableCandidates","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","tagName","disabled","hidden","FILTER_SKIP","tabIndex","FILTER_ACCEPT","nextNode","push","currentNode","getTabbableEdges","first","last","reverse","useFocusScope","loop","onOpenAutoFocus","onCloseAutoFocus","focusScope","handleKeydown","isTabKey","kbd.TAB","ctrlKey","altKey","metaKey","focusedElement","hasTabbableElementsInside","shiftKey","tabindex","trapFocus","focusScopeState","bitsTextSelectionLayers","TextSelectionLayerState","unsubSelectionLock","preventOverflowTextSelection","onPointerDownProp","onPointerDown","onPointerUpProp","onPointerUp","composeHandlers","resetSelectionLock","isHighestLayer","preventTextSelectionOverflow","useTextSelectionLayer","getUserSelect","style","userSelect","webkitUserSelect","body","originalBodyUserSelect","originalNodeUserSelect","setUserSelect","length","highestLayer","at","createSharedHook","factory","useBodyLockStackCount","useBodyScrollLock","restoreScrollDelay","countState","map","set","locked","v","valueOrGetValue","getDPR","window","win","defaultView","devicePixelRatio","roundByDPR","dpr","Math","round","getFloatingContentCSSVars","name","useFloating","open","middlewareOption","middleware","transformOption","transform","placementOption","placement","strategyOption","strategy","reference","x","y","floating","middlewareData","isPositioned","floatingStyles","initialStyles","position","left","top","xVal","yVal","willChange","update","computePosition","OPPOSITE_SIDE","right","bottom","FloatingRootState","anchorNode","customAnchorNode","triggerNode","FloatingContentState","root","contentRef","wrapperRef","arrowRef","arrowId","wrapperId","transformedStyle","cssToStyleObj","updatePositionStrategy","onPlaced","arrowWidth","arrowSize","arrowHeight","$.derived","side","align","collisionBoundary","hasExplicitBoundaries","boundary","padding","collisionPadding","filter","altBoundary","detectOverflowOptions","availableWidth","availableHeight","anchorWidth","anchorHeight","offset","mainAxis","sideOffset","alignmentAxis","alignOffset","avoidCollisions","shift","crossAxis","limiter","sticky","limitShift","flip","apply","rects","arrow","arrowPadding","transformOrigin","hideWhenDetached","hide","placedSide","getSideFromPlacement","placedAlign","getAlignFromPlacement","arrowX","arrowY","centerOffset","cannotCenterArrow","contentZIndex","arrowBaseSide","minWidth","zIndex","referenceHidden","dir","wrapperProps","styleToString","arrowStyle","customAnchor","desiredPlacement","FloatingAnchorState","virtualEl","from","setFloatingRootContext","getFloatingRootContext","createContext","setFloatingContentContext","getFloatingContentContext","useFloatingRootState","useFloatingContentState","useFloatingAnchorState","data","isArrowHidden","getSideAndAlignFromPlacement","noArrowAlign","start","center","end","arrowXCenter","arrowYCenter","split","content","contentState","mergedProps","mergeProps","pointerEvents","isStatic","$$slots","restProps","popper","floatingProps","focusScopeProps","dismissibleProps"],"mappings":"+jBACO,SAASA,UAAUC,IAChBC,OAACC,KAAKF,GAChB,CCSa,MAAAG,YACTC,OACIC,MAAO,EACPC,OAAQ,GAEZ,WAAAC,CAAYC,KAAMC,SAAYC,IAAK,eAC/BC,WAAU,CACNN,MAAOI,QAAQG,aAAaP,OAAS,EACrCC,OAAQG,QAAQG,aAAaN,QAAU,GAoB3C,SAAAD,UACOM,MAAIP,KAAOC,MAElB,UAAAC,UACOK,MAAIP,KAAOE,iBCjCjBO,WAAWC,QAASC,MAAOC,OAAQP,QAAO,CAAA,cACvCQ,KAAO,OAAUR,OAqB7B,CAsBgB,SAAAS,MAAMJ,QAASE,OAAQP,SACxBI,WAAAC,QAAS,OAAQE,OAAQP,QACxC,CACS,SAAAU,SAASL,QAASE,OAAQP,SACpBI,WAAAC,QAAS,MAAOE,OAAQP,QACvC,CACAS,MAAME,IAAMD,SC7DA,MAACE,iBAAmBC,WAAa,YActC,SAASC,cAAcC,SAC1B,OAAOA,mBAAmBC,WAC9B,CACO,SAASC,UAAUF,SACtB,OAAOA,mBAAmBG,OAC9B,CACO,SAASC,sBAAsBJ,SAC3B,OAAAA,mBAAmBG,SAAWH,mBAAmBK,UAC5D,CAOO,SAASC,QAAQC,GACpB,OAAOA,EAAEC,cAAgB,OAC7B,CACO,SAASC,eAAeT,SACpB,OAAAA,QAAQU,QAAQ,iBAC3B,CACO,SAASC,UAAUC,OACtB,OAAOA,QAAU,IACrB,CAKO,SAASC,kBAAkBb,SACvB,OAAAA,mBAAmBc,kBAAoB,WAAYd,OAC9D,CAMO,SAASe,gBAAgB/B,KAAMgC,QAC9B,GAAAC,iBAAiBjC,MAAMkC,aAAe,SAC/B,OAAA,KACX,MAAOlC,KAAM,CAEL,GAAAgC,iBAAwBhC,OAASgC,OAC1B,OAAA,MACP,GAAAC,iBAAiBjC,MAAMmC,UAAY,OAC5B,OAAA,KACXnC,KAAOA,KAAKoC,aACpB,CACW,OAAA,KACX,CClDgB,SAAAC,gBAAgBC,aAAcC,SACpC,MAAAC,MAAQtC,IAAIoC,uBACTG,QAAQC,OAEP,MAAAC,UAAYJ,QAAQC,MAAMI,SAASF,cAClCC,WAAaH,MAAMI,QAExB,MAAAC,SAAYH,QACRF,MAAAI,QAAUH,QAAQC,QAGxB,MAAA,CAAAF,YACAK,kBAER,CCtBgB,SAAAC,YAAYC,QAASC,IAG3B,MAAAV,aAAeS,QAAQH,QAAU,UAAY,YAY3C,MAAAJ,MAAAA,OAAoBH,gBAAgBC,aAAY,CACpDW,QAAO,CACHC,QAAS,YACTC,cAAe,oBAEnBC,kBACIC,MAAO,UACPC,cAAe,aAEnBC,UAAS,CACLF,MAAO,mBA6FTG,iBAAgB,CAAa,UAAW,oBAAoBC,SAASjB,MAAMI,gBAEzE,WAAAA,GACO,OAAAY,kBAGnB,0RC3HO,IAAAT,QAAAA,QAAAW,WAASA,WAAYC,SAAAA,SAAAX,GAAUA,IAAAY,QAE/B,MAAAC,UAAYf,YACjB5C,IAAI4D,KAAA,IAAWf,SACf7C,IAAI4D,SAAWd,KAIZ,GAAAU,YAAcX,SAAWc,UAAUjB,QAAO,iCACrCe,WAAQI,UAAA,CAAKhB,QAASc,8UCNzB,SAASG,iBAAiBC,OAAQvB,MAAOwB,QAASjE,SACrD,MAAMkE,OAASC,MAAMC,QAAQ3B,OAASA,MAAQ,CAACA,OAExCyB,OAAAG,QAASC,QAAWN,OAAOD,iBAAiBO,OAAQL,QAASjE,UAEpE,MAAO,KACIkE,OAAAG,QAASC,QAAWN,OAAOO,oBAAoBD,OAAQL,QAASjE,UAE/E,CCfO,SAASwE,SAASjF,GAAIkF,KAAO,KAChC,IAAIC,QAAU,KACR,MAAAC,UAAY,IAAIC,QAClB,GAAIF,UAAY,KAAM,CAClBG,aAAaH,QACzB,CACQA,QAAUI,WAAW,KACjBvF,MAAMqF,OACPH,OAEPE,UAAUI,QAAU,KAChB,GAAIL,UAAY,KAAM,CAClBG,aAAaH,SACHA,QAAA,IACtB,GAEW,OAAAC,SACX,CClBO,SAASK,mBAAmBjF,KAAMiE,QACrC,OAAOjE,OAASiE,QAAUjE,KAAKkF,SAASjB,OAC5C,CACO,SAASkB,iBAAiBC,IAC7B,OAAOA,IAAIC,eAAiBvE,QAChC,CCEAwE,WAAWC,4BAA8BC,IAC5B,MAAAC,4EAGS,CACdC,YAAa,OAEjBC,oBAAsB,MACtB3F,KAAOE,IAAI,MACX0F,kBAAe,WAEfC,sBAA+B,sBAE/BC,SAAkB,uBAElBC,oBAAsBC,KACtB,WAAAjG,CAAYkG,OACR9F,MAAK+F,QAAWD,MAAMC,QACtB/F,MAAKgG,iBAAoBF,MAAMG,aACrBC,WAAA,CACNrD,GAAIiD,MAAMjD,GACVsD,IAAKnG,KAAKH,KACVuG,KAAY,IAAApG,MAAK+F,QAAStD,QAC1B4D,YAAcxG,OACVG,KAAK2F,SAAW9F,QAGxBG,MAAKsG,aAAgBR,MAAMS,wBAC3BvG,MAAKwG,oBAAuBV,MAAMW,kBAClCzG,MAAK0G,eAAkBZ,MAAMY,4BAiCjBnE,QACR,GAAAA,MAAMoE,iBAAgB,OAErB,IAAA3G,KAAK2F,SAAQ,OAElBvG,mBACSY,KAAK2F,UAAY3F,0BAA0BuC,MAAMuB,QAAM,OAExD,GAAAvB,MAAMuB,SAAW9D,MAAK0F,qBAAuB,CACxC1F,MAAA0G,eAAgBjE,UAAUF,WAI3C,kBAAAqE,GACW,OAAAC,iBAQPhD,iBAAiB7D,MAAIyF,YAAe,cAAeoB,iBAAiB7G,2BAA4BA,MAAK8G,sBAAwB,MAM7HjD,iBAAiB7D,MAAKyF,YAAc,cAAeoB,iBAAiB7G,MAAK+G,wBAA0B/G,8BAInG6D,iBAAiB7D,MAAKyF,YAAc,UAAWzF,MAAIgH,6BAErC5F,IACV,IAAAmB,MAAQnB,KACRmB,MAAMoE,iBAAkB,CACxBpE,MAAQ0E,mBAAmB7F,GAE1BpB,MAAAwG,oBAAqB/D,QAAQrB,IAEtC8F,uBAAyB5C,SAAUlD,QAC1BpB,KAAK2F,SAAU,CAChB3F,kCAGE,MAAAmH,aAAenH,MAAIgG,iBAAmBvD,QAAQrB,EAAGpB,KAAK2F,WAAaM,aAAa7E,EAAGpB,KAAK2F,cACzF3F,MAAIwF,oBAAwBxF,gCAAkCmH,aAAc,CAC7EnH,kCAGA,IAAAuC,MAAQnB,KACRmB,MAAMoE,iBAAkB,CACxBpE,MAAQ0E,mBAAmB1E,OAE3B,GAAAvC,MAAKsG,aAAc7D,UAAY,SAC/BzC,MAAIsG,aAAe7D,UAAY,wBAAyB,CACxDzC,kCAGA,GAAAoB,EAAEC,cAAgB,QAAS,CAC3BrB,oDAE2B6D,iBAAiB7D,MAAKyF,YAAc,QAASzF,MAAIoH,cAAmB,CAAAC,KAAM,MACzG,KACK,CACIrH,MAAAwG,oBAAqB/D,QAAQF,SAEvC,0BACsBnB,4BACGA,EAAEkG,MAAQ,+BAEVlG,4BACAA,EAAEkG,MAAQ,OAEtCR,+BACS9G,KAAKH,KAAK4C,QAAO,OAEtBzC,MAAIwF,mBAAuBA,mBAAmBxF,KAAKH,KAAK4C,+BAEpCqB,SACf,IAAA9D,KAAKH,KAAK4C,QACJ,OAAA,MACJ,OAAAqC,mBAAmB9E,KAAKH,KAAK4C,QAASqB,SAEjDyD,YAAcjD,cACC,IAAA,MAAAkD,aAAaxH,MAAKyH,kBAAoB,CACxCzH,MAAAyH,kBAAmBD,WAAa,MAEzCxH,MAAIwF,mBAAuB,OAC5B,IACH,sBAAAkC,SACUC,EAAIC,OAAOC,OAAO7H,MAAIyH,mBAAqBK,KAAKC,SAC/C,OAAAJ,EAEXK,qBACIhI,MAAI0F,qBAAyB,MAEjCuC,oBACIjI,MAAI0F,qBAAyB,OAEjCI,MAAK,CACDkC,eAAgBhI,MAAIgI,eACpBC,cAAejI,MAAIiI,wBAGXC,oBAAoBpC,OACrB,OAAA,IAAAR,sBAAsBQ,MACrC,UACSqC,gBAAgBC,WACd,OAAAA,UAAUC,SAAW,EAAAC,GAAK7F,QAAS6D,iBAAoBA,eAAiB,SAAWA,eAAiB,SAC/G,UACSd,mBAAmB3F,YAClBuI,UAAS,IAAOjD,WAAWC,uBAO3B,MAAAmD,aAAeJ,gBAAgBC,cACjCG,aACO,OAAAA,aAAa,GAAG1I,KAAK4C,UAAY5C,WACrC2I,gBAAkBJ,UAAU,GAC5B,OAAAI,eAAe3I,KAAK4C,UAAY5C,IAC3C,CACS,SAAAoG,aAAa7E,EAAGvB,SACjB,WAAYuB,GAAKA,EAAEqH,OAAS,EACrB,OAAA,YACL3E,OAAS1C,EAAE0C,WACZ/C,UAAU+C,QACJ,OAAA,MACL,MAAAoB,cAAgBF,iBAAiBlB,QACjC,MAAA4E,QAAUxD,cAAcyD,gBAAgB5D,SAASjB,UAAYgB,mBAAmBjF,KAAMiE,QACrF,OAAA4E,OACX,UACSzB,mBAAmB7F,SAClBwH,sBAAwBxH,EAAEyH,oBAC1BC,eAAiB1H,EAAE0C,OACrB,IAAAiF,YACA3H,aAAa4H,aAAc,CAC3BD,aAAeC,aAAa5H,EAAEkG,KAAMlG,EACxC,KACK,CACc2H,SAAA,IAAAC,aAAa,cAAe5H,GAG3C,IAAA6H,YAAc,MAEZ,MAAAC,aAAY,IAAOC,MAAMJ,SAAQ,CACnCK,IAAM,CAAAtF,OAAQuF,WACNA,OAAS,gBAAiB,CACnB,OAAAT,yBAEPS,OAAS,SAAU,CACZ,OAAAP,kBAEPO,OAAS,iBAAkB,YAETJ,YAAA,KACH,UAAAnF,OAAOwF,iBAAmB,WAAY,CAC7CxF,OAAOwF,sBAIfD,OAAS,mBAAoB,CACtB,OAAAJ,eAEPI,QAAQvF,OAAQ,CAET,OAAAA,OAAOuF,MAGX,OAAAjI,EAAEiI,SAGV,OAAAH,YACX,qUC/OE3C,wBAA0B,QAAAE,kBAC1BA,kBAAoBZ,KAAAa,eACpBA,eAAiBb,KAAAhD,GACjBA,GAAA0G,SACAA,SAAAxD,QACAA,QACAE,aAAAA,cAAqB,IAAA,qBAGhBuD,sBAAwBtB,oBAAA,CAC7BrF,GAAI9C,IAAI4D,SAAWd,IACnB0D,wBAAyBxG,IAAI4D,SAAW4C,yBACxCE,kBAAmB1G,IAAI4D,SAAW8C,mBAClCV,QAAShG,IAAI4D,SAAWoC,SACxBW,eAAgB3G,IAAI4D,SAAW+C,gBAC/BT,aAAclG,IAAI4D,SAAWsC,iBAItBsD,WAAa3F,UAAA,CAAAkC,MAAO0D,sBAAsB1D,uQCtBnDX,WAAWsE,uBAAyBpE,IACvB,MAAAqE,sDAIT,WAAA9J,CAAYkG,OACR9F,MAAKsG,aAAgBR,MAAM6D,sBAC3B3J,MAAK4J,aAAgB9D,MAAM+D,gBAC3B7J,MAAK+F,QAAWD,MAAMC,QAa1BlC,sBACWA,iBAAiBlD,SAAU,UAAWX,MAAI8J,UAAW,CAAIC,QAAS,mBAE/D3I,OACNA,EAAE4I,MAAQC,SAAeC,yBAAyBlK,MAAI,OAEpD,MAAAmK,gBAAkBC,cAAchJ,EAAEkG,KAAMlG,GAC9CA,EAAEkI,iBACI,MAAAhD,aAAetG,MAAKsG,aAAc7D,QACpC,GAAA6D,eAAiB,SAAWA,eAAiB,wBAAuB,OAEnEtG,MAAA4J,aAAcnH,QAAQ0H,uBAGnBE,eAAevE,OAChB,OAAA,IAAA4D,iBAAiB5D,MAChC,UACSoE,yBAAyBI,gBACxBlC,UAAS,IAAOjD,WAAWsE,kBAO3B,MAAAlB,aAAeH,UAAUC,SAAQ,EAAGC,GAAK7F,QAAS6D,iBAAoBA,eAAiB,SAAWA,eAAiB,UACrH,GAAAiC,aACO,OAAAA,aAAa,KAAO+B,eACxB9B,gBAAkBJ,UAAU,GAC5B,OAAAI,iBAAmB8B,QAC9B,0SChDEX,sBAAwB,QAAAE,gBACxBA,gBAAkBhE,KAAA0D,SAClBA,SAAAxD,QACAA,iBAGDsE,eAAA,CACCV,sBAAuB5J,IAAI4D,SAAWgG,uBACtCE,gBAAiB9J,IAAI4D,SAAWkG,iBAChC9D,QAAShG,IAAI4D,SAAWoC,WAIjBwD,WAAQ3F,qQCED,SAAA2G,sBACR,IAAAC,OAAgB,aAEhB3H,GAAI4H,QACA,UAAAD,GACO,OAAAA,MACV,EACD,KAAAE,GACaF,OAAA,IACZ,EACD,MAAAG,GACaH,OAAA,OAGrB,CCJO,SAASI,MAAM/J,SAASgK,OAAEA,OAAS,OAAU,CAAA,GAC5C,KAAEhK,SAAWA,QAAQ+J,OACrB,OACJ,MAAME,yBAA2BnK,SAASoK,cAE1ClK,QAAQ+J,MAAM,CAAEI,cAAe,OAE/B,GAAInK,UAAYiK,0BAA4BpJ,kBAAkBb,UAAYgK,OAAQ,CAC9EhK,QAAQgK,QAChB,CACA,CAKO,SAASI,WAAWC,YAAYL,OAAEA,OAAS,OAAU,CAAA,GACxD,MAAMC,yBAA2BnK,SAASoK,cAC1C,IAAA,MAAWI,aAAaD,WAAY,CAC1BN,MAAAO,UAAW,CAAEN,gBACf,GAAAlK,SAASoK,gBAAkBD,yBAA0B,CAC9C,OAAA,IACnB,CACA,CACA,CAKO,SAASM,YAAYC,SAAUC,WAClC,IAAA,MAAWzK,WAAWwK,SAAU,CAExB,IAACzJ,gBAAgBf,QAASyK,WACnB,OAAAzK,OACnB,CACA,CAWO,SAAS0K,sBAAsBD,WAClC,MAAME,MAAQ,GACd,MAAMC,OAAS9K,SAAS+K,iBAAiBJ,UAAWK,WAAWC,aAAc,CAEzEC,WAAahM,OACT,MAAMiM,cAAgBjM,KAAKkM,UAAY,SAAWlM,KAAKyH,OAAS,SAC5D,GAAAzH,KAAKmM,UAAYnM,KAAKoM,QAAUH,cAChC,OAAOH,WAAWO,YAItB,OAAOrM,KAAKsM,UAAY,EAAIR,WAAWS,cAAgBT,WAAWO,eAG1E,MAAOT,OAAOY,WACJb,MAAAc,KAAKb,OAAOc,aAGf,OAAAf,KACX,CAKO,SAASgB,iBAAiBlB,WACvB,MAAAJ,WAAaK,sBAAsBD,WACnC,MAAAmB,MAAQrB,YAAYF,WAAYI,WACtC,MAAMoB,KAAOtB,YAAYF,WAAWyB,UAAWrB,WACxC,MAAA,CAACmB,MAAOC,KACnB,UChGgBE,kBAAgB/J,GAAAgK,KAAIA,KAAA9G,QAAMA,QAAA+G,gBAASA,gBAAAC,iBAAiBA,iBAAAxJ,WAAkBA,aAE5E,MAAAyJ,WAAazC,sBACb,MAAApE,IAAMpG,IAAI,MAChBmG,WAAU,CACNrD,MACAsD,QACAC,KAAI,IAAQL,QAAQtD,mBAiIfwK,cAAc7L,GACd,IAAA2E,QAAQtD,QAAO,OAEf,IAAAoK,KAAKpK,UAAYsD,QAAQtD,QAAO,OAEjC,GAAAuK,WAAWxC,OAAM,OAEf,MAAA0C,SAAW9L,EAAE4I,MAAQmD,MAAY/L,EAAEgM,UAAYhM,EAAEiM,SAAWjM,EAAEkM,cAC9DC,eAAiB5M,SAASoK,cAC1B,KAAAmC,UAAYK,gBAAc,aAE1BjC,UAAYnF,IAAI1D,YACjB6I,UAAS,OAEP,MAAAmB,MAAOC,MAAQF,iBAAiBlB,iBACjCkC,0BAA4Bf,OAASC,KACtC,IAAAc,0BAA2B,IACxBD,iBAAmBjC,UAAW,CAC9BlK,EAAEkI,iBAEV,KACK,CACI,IAAAlI,EAAEqM,UAAYF,iBAAmBb,KAAM,CACxCtL,EAAEkI,oBACEuD,KAAKpK,QACLmI,MAAM6B,MAAK,CAAI5B,OAAQ,MAC9B,MACQ,GAAAzJ,EAAEqM,UAAYF,iBAAmBd,MAAO,CAC7CrL,EAAEkI,oBACEuD,KAAKpK,QACLmI,MAAM8B,KAAI,CAAI7B,OAAQ,eAIhC/E,YAAK,CACPjD,GAAIA,GAAGJ,QACPiL,YACA5D,UAAWmD,0BAGP,SAAAnH,GACO,OAAAA,OAGnB,kRCvLEjD,GAAA8K,UACAA,UAAY,MAAAd,KACZA,KAAO,MAAAE,iBACPA,iBAAmBlH,KAAAiH,gBACnBA,gBAAkBjH,KAAAmH,WAClBA,WAAAzJ,WACAA,WAAa,qBAGRqK,gBAAkBhB,cAAA,CACvB7G,QAAShG,IAAI4D,SAAWgK,WACxBd,KAAM9M,IAAI4D,SAAWkJ,MACrBE,iBAAkBhN,IAAI4D,SAAWoJ,kBACjCD,gBAAiB/M,IAAI4D,SAAWmJ,iBAChCjK,GAAI9C,IAAI4D,SAAWd,IACnBU,WAAYxD,IAAI4D,SAAWJ,cAIpByJ,aAAepJ,UAAA,CAAAkC,MAAO8H,gBAAgB9H,iQCpB/CX,WAAW0I,8BAAgCxI,IAC9B,MAAAyI,yEAKTC,oBAAsBlI,UACf9F,IAAI,MACX,WAAAH,CAAYkG,OACR9F,MAAK6C,GAAMiD,MAAMjD,GACjB7C,MAAK+F,QAAWD,MAAMkI,6BACtBhO,MAAKiO,kBAAqBnI,MAAMoI,cAChClO,MAAKmO,gBAAmBrI,MAAMsI,YACpBlI,WAAA,CACNrD,GAAI7C,MAAI6C,GACRsD,IAAKnG,MAAImG,IACTC,KAAY,IAAApG,MAAK+F,QAAStD,UAelC,kBAAAmE,UACWC,iBAAiBhD,iBAAiBlD,SAAU,cAAeX,MAAKuF,aAAe1B,iBAAiBlD,SAAU,YAAa0N,gBAAgBrO,MAAIsO,mBAAsBtO,MAAImO,gCAEhK/M,IACN,MAAAvB,KAAOG,MAAKmG,IAAK1D,cACjBqB,OAAS1C,EAAE0C,WACZlD,cAAcf,QAAUe,cAAckD,UAAY9D,MAAI+F,QAAUtD,QAAO,OAOvE,IAAA8L,eAAevO,QAAU8E,mBAAmBjF,KAAMiE,QAAM,OAExD9D,MAAAiO,kBAAmBxL,QAAQrB,GAC5B,GAAAA,EAAEuF,iBAAgB,OAEjB3G,MAAA+N,mBAAsBS,6BAA6B3O,OAE5DyO,yBACItO,2BACAA,MAAI+N,mBAAuBlI,eAGnB4I,sBAAsB3I,OACvB,OAAA,IAAAgI,wBAAwBhI,MACvC,CACM,MAAA4I,cAAiB7O,MAASA,KAAK8O,MAAMC,YAAc/O,KAAK8O,MAAME,0BAC3DL,6BAA6B3O,YAC5BiP,KAAOnO,SAASmO,KAChB,MAAAC,uBAAyBL,cAAcI,MACvC,MAAAE,uBAAyBN,cAAc7O,MAC7CoP,cAAcH,KAAM,QACpBG,cAAcpP,KAAM,mBAEhBoP,cAAcH,KAAMC,wBACpBE,cAAcpP,KAAMmP,wBAE5B,CACS,SAAAC,cAAcpP,KAAM4B,OACzB5B,KAAK8O,MAAMC,WAAanN,MACxB5B,KAAK8O,MAAME,iBAAmBpN,KAClC,UACS8M,eAAejE,gBACdlC,UAAS,IAAOjD,WAAW0I,6BAC5BzF,UAAU8G,OACJ,OAAA,MACL,MAAAC,aAAe/G,UAAUgH,IAAK,GAC/B,IAAAD,aACM,OAAA,MACJ,OAAAA,aAAa,KAAO7E,QAC/B,yVClFE0D,6BAA+B,KAAAE,cAC/BA,cAAgBrI,KAAAuI,YAChBA,YAAcvI,KAAAhD,GACdA,GAAA0G,SACAA,SAAAxD,QACAA,iBAGD0I,sBAAA,CACC5L,GAAI9C,IAAI4D,SAAWd,IACnBmL,6BAA8BjO,IAAI4D,SAAWqK,8BAC7CE,cAAenO,IAAI4D,SAAWuK,eAC9BE,YAAarO,IAAI4D,SAAWyK,aAC5BrI,QAAShG,IAAI4D,SAAWoC,WAIjBwD,WAAQ3F,sRCxBDyL,iBAAiBC,aAEzBjN,WAAK,EAUG,MAAA,IAAAqC,OAYDrC,KAEf,OCnBMkN,sBAAwBF,mBAyEd,SAAAG,kBAAkBrN,aAAcsN,mBAA2B,IAAA,MACjE,MAAA5M,GAAK4H,QACL,MAAAiF,WAAaH,wBACoCE,qBACvDC,WAAWC,IAAIC,IAAI/M,GAAIV,cAAgB,aACjC0N,OAAS9P,IAAI4D,KAAI,IAAO+L,WAAWC,IAAIvG,IAAIvG,KAAO,MAAQiN,GAAMJ,WAAWC,IAAIC,IAAI/M,GAAIiN,IAgBtF,OAAAD,MACX,6RClGO7E,cAAgB,KAAAyE,mBAAMA,mBAAqB,cAE/BD,kBAAAxE,kBAAqByE,uPCNxBrG,IAAI2G,iBACF,cAAAA,kBAAoB,WAC5BA,kBACAA,eACV,UACgBC,OAAOnP,mBACRoP,SAAW,YACX,OAAA,EACL,MAAAC,IAAMrP,QAAQqE,cAAciL,aAAeF,cAC1CC,IAAIE,kBAAoB,CACnC,CACgB,SAAAC,WAAWxP,QAASY,OAC1B,MAAA6O,IAAMN,OAAOnP,SACZ,OAAA0P,KAAKC,MAAM/O,MAAQ6O,KAAOA,GACrC,UACgBG,0BAA0BC,wBAEvBA,iCAAI,mDACJA,gCAAI,kDACJA,iCAAI,mDACJA,qBAAI,+CACJA,sBAAI,qCAEvB,UCpBgBC,YAAY7Q,SAGQsJ,IAAAtJ,QAAQ8Q,OAAS,KAC3C,MAAAC,iBAA4BzH,IAAItJ,QAAQgR,YACxC,MAAAC,gBAA2B3H,IAAItJ,QAAQkR,YAAc,KACrD,MAAAC,gBAA2B7H,IAAItJ,QAAQoR,YAAc,SACrD,MAAAC,eAA0B/H,IAAItJ,QAAQsR,WAAa,iBACnDC,UAAYvR,QAAQuR,UAEtB,IAAAC,EAAW,EACX,IAAAC,EAAW,EACT,MAAAC,SAAWzR,IAAI,MACjB,IAAAqR,SAAkBD,eAClB,IAAAD,UAAmBD,oBACnBQ,eAAc,CAAA,EACd,IAAAC,aAAsB,MACpB,MAAAC,2BACIC,cAAa,CACfC,SAAUT,SACVU,KAAM,IACNC,IAAK,SAEJP,SAAS/O,QAAS,CACZ,OAAAmP,cAEL,MAAAI,KAAO3B,WAAWmB,SAAS/O,QAAS6O,GACpC,MAAAW,KAAO5B,WAAWmB,SAAS/O,QAAS8O,GACtC,GAAAR,gBAAiB,WAEVa,cACHZ,UAAS,aAAegB,WAAWC,aAC/BjC,OAAOwB,SAAS/O,UAAY,KAAG,CAC/ByP,WAAY,qBAKpBL,SAAUT,SACVU,QAASE,SACTD,OAAQE,SAEf,KAGQ,SAAAE,YACDd,UAAU5O,UAAY,MAAQ+O,SAAS/O,UAAY,KAAI,OAE3C2P,gBAAAf,UAAU5O,QAAS+O,SAAS/O,QAAO,CAC/CqO,WAAYD,iBACZK,UAAWD,gBACXG,SAAUD,iBACX5R,KAAMsS,WACLP,EAAIO,SAASP,EACbC,EAAIM,SAASN,EACbH,SAAWS,SAAST,SACpBF,UAAYW,SAASX,UACrBO,eAAiBI,SAASJ,eACXC,aAAA,cA6BnBF,kBACAH,oBACI,YAAAD,GACO,OAAAA,QACV,EACG,aAAAF,GACO,OAAAA,SACV,EACG,kBAAAO,GACO,OAAAA,cACV,EACG,gBAAAC,GACO,OAAAA,YACV,EACG,kBAAAC,GACO,OAAAA,cACV,EACG,UAAAQ,GACO,OAAAA,QAGnB,OCrGME,cAAa,CACfN,IAAK,SACLO,MAAO,OACPC,OAAQ,MACRT,KAAM,SAEJ,MAAAU,kBACFC,WAAa1S,IAAI,MACjB2S,iBAAmB3S,IAAI,MACvB4S,YAAc5S,IAAI,MAClB,WAAAH,KAgBE,MAAAgT,qBAEFC,KAEAC,WAAa/S,IAAI,MACjBgT,WAAahT,IAAI,MACjBiT,SAAWjT,IAAI,MAEfkT,QAAUlT,IAAI0K,SACd5H,GACAqQ,UACAvE,MACAwE,yCACenT,KAAK2O,QAAU,SACf,OAAAyE,cAAcpT,KAAK2O,OACzB,IAAA3O,KAAK2O,MAAK,MAAA,CAAA,uJAenB0E,6BAA0B,EAC1BC,SACAvN,mBACU,IAAOvG,YAAkB,IAAAQ,KAAKgT,SAASvQ,cAAoB,GACrE8Q,wBAAuBvT,MAAIwT,WAAa9T,OAAS,GACjD+T,yBAAwBzT,MAAIwT,WAAa7T,QAAU,qBAClC+T,QAAA,IAAsB1T,MAAK2T,MAAOlR,SAC9CzC,MAAK4T,MAAOnR,UAAY,SAAe,IAAAzC,YAAYyC,UAAY,eAC3DiR,QAAA,IAAqBzP,MAAMC,QAAQlE,MAAI6T,kBAAoBpR,SAC9DzC,MAAI6T,kBAAoBpR,SACvBzC,MAAI6T,kBAAoBpR,UACEqR,uBAAAJ,QAAA,IAAA1T,MAAK+T,WAAU7E,OAAS,4BAAzD4E,4JAEIE,QAAShU,MAAKiU,iBAAkBxR,QAChCsR,SAAU/T,MAAI+T,WAAWG,OAAO1S,WAChC2S,YAAanU,KAAK8T,kDAHtBM,uHAKAC,qBAAyB,EACzBC,sBAA0B,EAC1BC,kBAAsB,EACtBC,mBAAuB,2BAEnBC,OAAM,CACFC,SAAU1U,MAAK2U,WAAYlS,QAAUzC,MAAIyT,cACzCmB,cAAe5U,MAAK6U,YAAapS,UAErCzC,MAAK8U,gBAAiBrS,SAClBsS,MAAK,CACDL,SAAU,KACVM,UAAW,MACXC,QAASjV,MAAIkV,OAASzS,UAAY,UAAY0S,kBAAe,KAC1DnV,KAAKoU,wBAEhBpU,MAAI8U,gBAAkBrS,SAAW2S,KAAI,IAAMpV,KAAKoU,wBAChD3U,KAAI,IACGO,KAAKoU,sBACRiB,QAAUC,YAAOjB,8BAAgBC,0CACrB5U,MAAO6U,YAAa5U,OAAQ6U,cAAiBc,MAAMjE,UAC3DrR,MAAIqU,eAAmBA,eACvBrU,MAAIsU,gBAAoBA,gBACxBtU,MAAIuU,YAAgBA,YACpBvU,MAAIwU,aAAiBA,gBAG7BxU,KAAKgT,SAASvQ,SACV8S,MAAK,CAAG1U,QAASb,KAAKgT,SAASvQ,QAASuR,QAAShU,MAAKwV,aAAc/S,UACxEgT,gBAAe,CAAGlC,WAAYvT,MAAIuT,aAAcE,YAAazT,MAAIyT,gBACjEzT,MAAK0V,iBAAkBjT,SACnBkT,KAAI,CAAGvE,SAAU,qBAAsBpR,KAAKoU,yBAClDF,OAAOnM,wBA5BT+I,sFA6BAU,SAC+BoE,YAAAlC,QAAA,IAAAmC,qBAAqB7V,KAAKwR,SAASN,0BAAlE0E,sFACgCE,aAAApC,QAAA,IAAAqC,sBAAsB/V,KAAKwR,SAASN,2BAApE4E,6GAC2B9V,KAAKwR,SAASC,eAAe8D,OAAOjE,GAAK,aAApE0E,8FAC2BhW,KAAKwR,SAASC,eAAe8D,OAAOhE,GAAK,aAApE0E,yGACsCjW,KAAKwR,SAASC,eAAe8D,OAAOW,eAAiB,wBAA3FC,2GACAC,yCACyB/D,cAAcrS,KAAK4V,8BAA5CS,2HAEIxT,GAAI7C,KAAKkT,UAAUzQ,QACnB,qCAAsC,GACtCkM,MAAK,IACE3O,KAAKwR,SAASG,eAEjBX,UAAWhR,KAAKwR,SAASE,aACnB1R,KAAKwR,SAASG,eAAeX,UAC7B,sBACNsF,SAAU,cACVC,OAAQvW,KAAKoW,cACb,sCAAuCpW,KAAKwR,SAASC,eAAegE,iBAAiBnE,KAAKtR,KAAKwR,SAASC,eAAegE,iBAAiBlE,IACxI,kCAAiC,GAAKvR,MAAIqU,mBAC1C,mCAAkC,GAAKrU,MAAIsU,oBAC3C,+BAA8B,GAAKtU,MAAIuU,gBACvC,gCAA+B,GAAKvU,MAAIwU,oBAEpCxU,KAAKwR,SAASC,eAAekE,MAAMa,iBAAe,CAClDzU,WAAY,SACZ,iBAAkB,WAEnB/B,0BAGPyW,IAAKzW,MAAKyW,IAAKhU,2BAxBnBiU,iHA2BI,YAAa1W,KAAK4V,WAClB,aAAc5V,KAAK8V,YACnBnH,MAAOgI,cAAa,IACb3W,uCAJX8F,iGAWI+L,SAAU,WACVC,KAAM9R,KAAKgW,UAAYhW,KAAKgW,gBAAa,EACzCjE,IAAK/R,KAAKiW,UAAYjW,KAAKiW,gBAAa,GACvCjW,KAAKqW,eAAgB,EACtB,mBAAkB,CACdtE,IAAK,GACLO,MAAO,MACPC,OAAQ,WACRT,KAAM,UACR9R,KAAK4V,YACP5E,UAAS,CACLe,IAAK,mBACLO,MAAO,iDACPC,OAAQ,iBACRT,KAAM,kDACR9R,KAAK4V,YACP7T,WAAY/B,KAAKmW,kBAAoB,cAAW,mBAjBpDS,sFAmBA,WAAAhX,CAAYkG,MAAO+M,MACf7S,KAAK6C,GAAKiD,MAAMjD,GAChB7C,MAAK2T,KAAQ7N,MAAM6N,KACnB3T,MAAK2U,WAAc7O,MAAM6O,WACzB3U,MAAK4T,MAAS9N,MAAM8N,MACpB5T,MAAK6U,YAAe/O,MAAM+O,YAC1B7U,MAAKwV,aAAgB1P,MAAM0P,aAC3BxV,MAAK8U,gBAAmBhP,MAAMgP,gBAC9B9U,MAAK6T,kBAAqB/N,MAAM+N,kBAChC7T,MAAKiU,iBAAoBnO,MAAMmO,iBAC/BjU,MAAKkV,OAAUpP,MAAMoP,OACrBlV,MAAK0V,iBAAoB5P,MAAM4P,iBAC/B1V,MAAKqT,uBAA0BvN,MAAMuN,uBACrCrT,KAAKsT,SAAWxN,MAAMwN,SACtBtT,MAAKoR,SAAYtL,MAAMsL,SACvBpR,MAAKyW,IAAO3Q,MAAM2Q,IAClBzW,KAAK2O,MAAQ7I,MAAM6I,MACnB3O,KAAK6S,KAAOA,KACZ7S,KAAK+F,QAAUD,MAAMC,QACrB/F,KAAKkT,UAAYpN,MAAMoN,aACnBpN,MAAM+Q,aAAc,CACpB7W,KAAK6S,KAAKH,iBAAiBjQ,QAAUqD,MAAM+Q,aAAapU,QAQlDyD,WAAA,CACNrD,GAAI7C,KAAKkT,UACT/M,IAAKnG,KAAK+S,WACV3M,KAAY,IAAApG,KAAK+F,QAAQtD,UAEnByD,WAAA,CACNrD,GAAI7C,KAAK6C,GACTsD,IAAKnG,KAAK8S,WACV1M,KAAY,IAAApG,KAAK+F,QAAQtD,UAE7BzC,KAAKwR,SAAWb,YAAW,CACvBS,SAAgB,IAAApR,MAAKoR,SAAU3O,QAC/ByO,UAAS,IAAQlR,MAAI8W,mBACrBhG,WAAU,IAAQ9Q,KAAK8Q,WACvBO,UAAWrR,KAAK6S,KAAKJ,WAOrB7B,KAAY,IAAA5Q,KAAK+F,QAAQtD,WA2C/B,MAAAsU,oBACF5Q,IAAMpG,IAAI,MACV,WAAAH,CAAYkG,MAAO+M,SACX/M,MAAMkR,WAAalR,MAAMkR,UAAUvU,QAAS,CAC5CoQ,KAAKF,YAAc5S,IAAIkX,KAAKnR,MAAMkR,UAAUvU,QAChD,KACK,CACSyD,WAAA,CACNrD,GAAIiD,MAAMjD,GACVsD,IAAKnG,KAAKmG,IACVE,YAAcxG,OACVgT,KAAKF,YAAYlQ,QAAU5C,gBASxCqX,uBAAwBC,wBAA0BC,cAAc,uBAChEC,0BAA2BC,2BAA6BF,cAAc,oBAC7D,SAAAG,uBACL,OAAAL,2BAA2B1E,kBACtC,UACgBgF,wBAAwB1R,OAC7B,OAAAuR,0BAA8B,IAAAzE,qBAAqB9M,MAAOqR,0BACrE,UAIgBM,uBAAuB3R,kBACxBiR,oBAAoBjR,MAAOqR,yBAC1C,UAIS1B,gBAAgB3V,gBAEjB4Q,KAAM,kBACN5Q,gBACA,EAAAT,CAAGqY,MACS,MAAAxG,UAAAA,UAAAoE,MAAWA,MAAO7D,eAAAA,gBAAmBiG,KACvC,MAAAvB,kBAAoB1E,eAAe8D,OAAOW,eAAiB,EAC3D,MAAAyB,cAAgBxB,kBAChB,MAAA5C,WAAaoE,cAAgB,EAAI7X,QAAQyT,WACzC,MAAAE,YAAckE,cAAgB,EAAI7X,QAAQ2T,YACzC,MAAAmC,WAAYE,aAAe8B,6BAA6B1G,WACzD,MAAA2G,aAAiB,CAAAC,MAAO,KAAMC,OAAQ,MAAOC,IAAK,QAASlC,mBAC3DmC,cAAgBxG,eAAe8D,OAAOjE,GAAK,GAAKiC,WAAa,QAC7D2E,cAAgBzG,eAAe8D,OAAOhE,GAAK,GAAKkC,YAAc,EAChE,IAAAnC,EAAI,GACJ,IAAAC,EAAI,MACJqE,aAAe,SAAU,CACrBtE,EAAAqG,cAAgBE,gBAAkBI,uBAC9BxE,eACZ,MAAA,GACSmC,aAAe,MAAO,CACvBtE,EAAAqG,cAAgBE,gBAAkBI,iBACtC1G,KAAO+D,MAAM9D,SAAS7R,OAAS8T,eACnC,MAAA,GACSmC,aAAe,QAAS,OACrBnC,gBACJlC,EAAAoG,cAAgBE,gBAAkBK,gBAC1C,MAAA,GACStC,aAAe,OAAQ,CAC5BtE,KAAOgE,MAAM9D,SAAS9R,MAAQ+T,gBAC1BlC,EAAAoG,cAAgBE,gBAAkBK,wBAEjCR,KAAI,CAAIpG,IAAGC,OAGhC,UACSqG,6BAA6B1G,iBAC3ByC,KAAMC,MAAQ,UAAY1C,UAAUiH,MAAM,KACzC,MAAA,CAAAxE,KAAMC,MAClB,UACgBiC,qBAAqB3E,WAC1B,OAAA0G,6BAA6B1G,WAAW,EACnD,UACgB6E,sBAAsB7E,WAC3B,OAAA0G,6BAA6B1G,WAAW,EACnD,qSC9VO,IAAA3H,SAAAA,UAAA9F,QAEN8T,uBAGQhO,WAAQ3F,ukBCHV,IAAAf,GAAAA,GAAA0G,SAAIA,SAAUyN,UAAAA,WAAAvT,QAEpBgU,uBAAA,CACC5U,GAAI9C,IAAI4D,SAAWd,IACnBmU,UAAWjX,IAAI4D,SAAWqT,aAInBzN,WAAQ3F,8lBCPfwU,QAAAzE,KACAA,KAAO,SAAAgB,WACPA,WAAa,EAAAf,MACbA,MAAQ,SAAAiB,YACRA,YAAc,EAAAhS,GACdA,GAAA2S,aACAA,aAAe,EAAAV,gBACfA,gBAAkB,KAAAjB,kBAClBA,kBAAA,GAAAI,iBACAA,iBAAmB,EAAAyB,iBACnBA,iBAAmB,MAAApC,SACnBA,SAAA,OAAkB4B,OAClBA,OAAS,UAAA7B,uBACTA,uBAAyB,YAAAjC,SACzBA,SAAW,QAAAqF,IACXA,IAAM,MAAA9H,MACNA,MAAA,CAAA,EAAAuE,UACAA,UAAYzI,QAAAoM,aACZA,aAAe,oBAGVwB,aAAeb,wBAAA,CACpB7D,KAAM5T,IAAI4D,SAAWgQ,MACrBgB,WAAY5U,IAAI4D,SAAWgR,YAC3Bf,MAAO7T,IAAI4D,SAAWiQ,OACtBiB,YAAa9U,IAAI4D,SAAWkR,aAC5BhS,GAAI9C,IAAI4D,SAAWd,IACnB2S,aAAczV,IAAI4D,SAAW6R,cAC7BV,gBAAiB/U,IAAI4D,SAAWmR,iBAChCjB,kBAAmB9T,IAAI4D,SAAWkQ,mBAClCI,iBAAkBlU,IAAI4D,SAAWsQ,kBACjCyB,iBAAkB3V,IAAI4D,SAAW+R,kBACjCpC,SAAUvT,IAAI4D,SAAW2P,UACzB4B,OAAQnV,IAAI4D,SAAWuR,QACvB7B,uBAAwBtT,IAAI4D,SAAW0P,wBACvCjC,SAAUrR,IAAI4D,SAAWyN,UACzBqF,IAAK1W,IAAI4D,SAAW8S,KACpB9H,MAAO5O,IAAI4D,SAAWgL,OACtB5I,QAAShG,IAAI4D,SAAW,OACxBuP,UAAWnT,IAAI4D,SAAWuP,WAC1B2D,aAAc9W,IAAI4D,SAAWkT,gBAGxB,MAAAyB,YACLC,WAAWF,aAAa3B,aACvB,CAAA/H,MAAA,CACC6J,cAAe,UAMVJ,UAAOxU,UAAA,CAAKkC,MAAOuS,aAAavS,MAAO4Q,aAAc4B,8nBCvD5DF,QACA9E,SAAAA,UAAA7P,QAac2U,UAAAxU,UAAA,CAAKkC,MAAK,CAAA,EAAM4Q,aAAY,CAAA,kjBCZ1C0B,QAAAK,SACAA,SAAW,MAAAnF,SACXA,SAAAoF,qCACGC,sBAIAF,SAAQ,uOAGmCE,4jBCL9CC,OAAA/O,gBACAA,gBAAAF,sBACAA,sBAAAqE,6BACAA,6BAAAnL,GACAA,GAAAqL,cACAA,cAAAE,YACAA,YAAAuF,KACAA,KAAAgB,WACAA,WAAAf,MACAA,MAAAiB,YACAA,YAAAW,aACAA,aAAAV,gBACAA,gBAAAjB,kBACAA,kBAAAI,iBACAA,iBAAAiB,OACAA,OAAAQ,iBACAA,iBAAArC,uBACAA,uBAAAjC,SACAA,SAAAqF,IACAA,IAAAzL,cACAA,cAAAkI,UACAA,UAAAvE,MACAA,MAAA2E,SACAA,SAAA7M,kBACAA,kBAAAsG,iBACAA,iBAAAD,gBACAA,gBAAApG,eACAA,eAAAH,wBACAA,wBAA0B,QAAAsG,KAC1BA,KAAAc,UACAA,UAAY,KACZ1H,aAAAA,cAAqB,IAAA,MAAA4Q,aACrBA,aAAe,KAAA4B,SACfA,SAAW,MAAA1S,QACXA,QAAA2S,qCACGC,qDA2BgB7S,MAAO+S,cAAAnC,aAAeA,iDACpC,GAAAiC,UAAUpV,YAAcwC,QAAO,uFAEzB,MAAA,IAAA4S,UAAUpV,WAAU,mKAWP,IAAAyJ,WAAA,SAAApJ,YAAAkC,MAAOgT,gOAUN,IAAAvP,SAAA,SAAA3F,YAAAkC,MAAOiT,gRAQjBH,SAAMhV,WAAA,CACdkC,MAAOyS,WACNI,UACAE,cACAE,iBACAD,gBAEC,CAAAnK,MACC,CAAA6J,cAAe,UAIlB9B,4dAjCK/I,UAAA5H,SAAW4H,UACVpK,WAAAoV,UAAUpV,2kCC/EvBqV,OAAAhW,QACAA,QAAAiH,gBACAA,gBAAAF,sBACAA,sBAAAqE,6BACAA,6BAAAnL,GACAA,GAAAqL,cACAA,cAAAE,YACAA,YAAAuF,KACAA,KAAAgB,WACAA,WAAAf,MACAA,MAAAiB,YACAA,YAAAW,aACAA,aAAAV,gBACAA,gBAAAjB,kBACAA,kBAAAI,iBACAA,iBAAAiB,OACAA,OAAAQ,iBACAA,iBAAArC,uBACAA,uBAAAjC,SACAA,SAAAqF,IACAA,IAAAzL,cACAA,cAAAkI,UACAA,UAAAvE,MACAA,MAAA2E,SACAA,SAAA7M,kBACAA,kBAAAsG,iBACAA,iBAAAD,gBACAA,gBAAApG,eACAA,eAAAH,wBACAA,wBAA0B,QAAAsG,KAC1BA,KAAAc,UACAA,UAAY,KACZ1H,aAAAA,cAAqB,IAAA,MAAA4Q,aACrBA,aAAe,KAAA4B,SACfA,SAAW,MAAAC,qCACRC,sDAKiB/V,QAAAA,8tBA4BVmD,QAAAnD,SAAQH,gQASL,OACRkW,uHAvC2BA,8lBCxChCC,OAAA/O,gBACAA,gBAAAF,sBACAA,sBAAAqE,6BACAA,6BAAAnL,GACAA,GAAAqL,cACAA,cAAAE,YACAA,YAAAuF,KACAA,KAAAgB,WACAA,WAAAf,MACAA,MAAAiB,YACAA,YAAAW,aACAA,aAAAV,gBACAA,gBAAAjB,kBACAA,kBAAAI,iBACAA,iBAAAiB,OACAA,OAAAQ,iBACAA,iBAAArC,uBACAA,uBAAAjC,SACAA,SAAAqF,IACAA,IAAAzL,cACAA,cAAAkI,UACAA,UAAAvE,MACAA,MAAA2E,SACAA,SAAA7M,kBACAA,kBAAAsG,iBACAA,iBAAAD,gBACAA,gBAAApG,eACAA,eAAAH,wBACAA,wBAA0B,QAAAsG,KAC1BA,KAAAc,UACAA,UAAY,KACZ1H,aAAAA,cAAqB,IAAA,MAAA4Q,aACrBA,aAAe,KAAA4B,SACfA,SAAW,MAAA1S,QACXA,QAAA2S,qCACGC,i8BA0CAA,sBACQ","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33]}