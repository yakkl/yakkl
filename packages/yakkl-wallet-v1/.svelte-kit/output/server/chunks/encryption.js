import global from"vite-plugin-node-polyfills/shims/global";import{l as log$1,L as LogLevel,a as LogLevelDirection}from"./Logger.js";import{a as browser_ext}from"./environment.js";import{w as writable,d as derived,g as get}from"./index.js";import"./utils.js";import{ethers}from"ethers-v6";import{fetchJson}from"@ethersproject/web";import{isEqual}from"lodash-es";import{Buffer}from"vite-plugin-node-polyfills/shims/buffer";const log={debug:()=>{},debugStack:()=>{},warn:()=>{},errorStack:()=>{},info:()=>{},infoStack:()=>{},trace:()=>{},error:log$1.error.bind(log$1),setLevel:log$1.setLevel.bind(log$1),setLogFilterEnabled:log$1.setLogFilterEnabled.bind(log$1),setLogFilterRegex:log$1.setLogFilterRegex.bind(log$1),setStackIndex:log$1.setStackIndex.bind(log$1),setBackend:log$1.setBackend.bind(log$1),clearPersistedLogs:log$1.clearPersistedLogs.bind(log$1),getPersistedLogs:log$1.getPersistedLogs.bind(log$1)};const loggerWrapper=Object.freeze(Object.defineProperty({__proto__:null,LogLevel:LogLevel,LogLevelDirection:LogLevelDirection,log:log},Symbol.toStringTag,{value:"Module"}));var SystemTheme=(SystemTheme2=>{SystemTheme2["DARK"]="dark";SystemTheme2["LIGHT"]="light";SystemTheme2["SYSTEM"]="system";return SystemTheme2})(SystemTheme||{});var AccountTypeCategory=(AccountTypeCategory2=>{AccountTypeCategory2["PRIMARY"]="primary";AccountTypeCategory2["SUB"]="sub";AccountTypeCategory2["CONTRACT"]="contract";AccountTypeCategory2["IMPORTED"]="imported";return AccountTypeCategory2})(AccountTypeCategory||{});var PlanType=(PlanType2=>{PlanType2["TRIAL"]="trial";PlanType2["BASIC_MEMBER"]="basic_member";PlanType2["FOUNDING_MEMBER"]="founding_member";PlanType2["EARLY_ADOPTER"]="early_adopter";PlanType2["YAKKL_PRO"]="yakkl_pro";PlanType2["INSTITUTION"]="institution";PlanType2["BUSINESS"]="business";PlanType2["ENTERPRISE"]="enterprise";return PlanType2})(PlanType||{});var AccessSourceType=(AccessSourceType2=>{AccessSourceType2["STANDARD"]="standard";AccessSourceType2["SUBSCRIBED"]="subscribed";AccessSourceType2["TRIAL"]="trial";AccessSourceType2["PROMO"]="promo";return AccessSourceType2})(AccessSourceType||{});var PromoClassificationType=(PromoClassificationType2=>{PromoClassificationType2["FOUNDING_MEMBER"]="founding_member";PromoClassificationType2["EARLY_ADOPTER"]="early_adopter";PromoClassificationType2["YAKKL_PRO"]="yakkl_pro";PromoClassificationType2["INFLUENCER"]="influencer";PromoClassificationType2["EMPLOYEE"]="employee";PromoClassificationType2["SPECIAL"]="special";PromoClassificationType2["EVENT"]="event";PromoClassificationType2["OTHER"]="other";PromoClassificationType2["NONE"]="none";return PromoClassificationType2})(PromoClassificationType||{});var NetworkType=(NetworkType2=>{NetworkType2["MAINNET"]="mainnet";NetworkType2["TESTNET"]="testnet";NetworkType2["PRIVATE"]="private";NetworkType2["OTHER"]="other";return NetworkType2})(NetworkType||{});var MessageType=(MessageType2=>{MessageType2["ACTIVE_TAB_CHANGED"]="ACTIVE_TAB_CHANGED";MessageType2["TAB_UPDATED"]="TAB_UPDATED";MessageType2["TAB_REMOVED"]="TAB_REMOVED";MessageType2["WINDOW_FOCUSED"]="WINDOW_FOCUSED";return MessageType2})(MessageType||{});const VERSION="2.0.0";const YEAR="2025";const PRO_ELIGIBLE_PROMO_TYPES=["investor","influencer","employee","special","founding","early","partner","founder","internal","press"];const FOUNDING_MEMBER_DEADLINE="2025-08-15T04:00:00.000Z";const EARLY_ADOPTER_DEADLINES=[{date:"2025-10-01T04:00:00.000Z",price:120},{date:"2025-11-15T04:00:00.000Z",price:132},{date:"2026-01-01T04:00:00.000Z",price:144}];const DEFAULT_PERSONA="default";const TIMELINES=["1h","24h","7d","30d"];const NUM_OF_SPLASH_IMAGES=3;const SPLASH_DELAY=3e3;const ALERT_DELAY=3e3;const IDLE_AUTO_LOCK_CYCLE=2;const TIMER_PRICE_INTERVAL_TIME=1e4;const TIMER_TOKEN_PRICE_CYCLE_TIME=15e3;const TIMER_GAS_PRICE_CHECK="gas_checkGasPrices";const ETH_BASE_SWAP_GAS_UNITS=500000n;const YAKKL_FEE_BASIS_POINTS=42.25;const YAKKL_FEE_BASIS_POINTS_DIVISOR=1e4;const YAKKL_ZERO_ADDRESS="0x0000000000000000000000000000000000000000";const YAKKL_ZERO_ACCOUNT_NAME="YAKKL - Zero Account - YAKKL";const YAKKL_INTERNAL="yakkl-internal";const YAKKL_DAPP="yakkl-dapp";const DEFAULT_POPUP_WIDTH=428;const DEFAULT_POPUP_HEIGHT=926;const DEFAULT_EXT_HEIGHT=926;const DEFAULT_TITLE="YAKKLÂ® Smart Wallet";const DEFAULT_DERIVED_PATH_ETH="m/44'/60'/";const STORAGE_YAKKL_PREFERENCES="preferences";const STORAGE_YAKKL_SETTINGS="settings";const STORAGE_YAKKL_CURRENTLY_SELECTED="yakklCurrentlySelected";const STORAGE_YAKKL_REGISTERED_DATA="yakklRegisteredData";const STORAGE_YAKKL_PROFILE="profile";const STORAGE_YAKKL_ACCOUNTS="yakklAccounts";const STORAGE_YAKKL_PRIMARY_ACCOUNTS="yakklPrimaryAccounts";const STORAGE_YAKKL_CONTACTS="yakklContacts";const STORAGE_YAKKL_TOKENDATA="yakklTokenData";const STORAGE_YAKKL_TOKENDATA_CUSTOM="yakklTokenDataCustom";const STORAGE_YAKKL_COMBINED_TOKENS="yakklCombinedTokens";const STORAGE_YAKKL_CHATS="yakklChats";const STORAGE_YAKKL_WATCHLIST="yakklWatchList";const STORAGE_YAKKL_BLOCKEDLIST="yakklBlockedList";const STORAGE_YAKKL_CONNECTED_DOMAINS="yakklConnectedDomains";const STORAGE_YAKKL_WALLET_PROVIDERS="yakklWalletProviders";const STORAGE_YAKKL_WALLET_BLOCKCHAINS="yakklWalletBlockchains";const PATH_WELCOME="/welcome/welcome";const PATH_LOGOUT="/logout";const PATH_ACCOUNTS="/accounts";const PATH_SECURITY="/security";class YakklError extends Error{code;info;constructor(message,code,info){super(message);this.name="YakklError";this.code=code;this.info=info}}function makeError(message,code,info){return new YakklError(message,code,info)}function parseJsonRpcError(errorString){try{let parsed;try{parsed=typeof errorString==="string"?JSON.parse(errorString):errorString}catch{const jsonMatch=errorString.match(/\{.*\}/);if(jsonMatch){parsed=JSON.parse(jsonMatch[0])}}if(parsed){const errorObj=parsed.error||parsed;return{message:formatErrorMessage(errorObj.message||"Unknown error"),code:errorObj.code||-1,details:{requestMethod:extractValue(errorString,"requestMethod"),url:extractValue(errorString,"url"),jsonrpc:parsed.jsonrpc,id:parsed.id}}}return{message:errorString,code:-1}}catch(e){log$1.error("Error parsing error message:",false,e);return{message:errorString,code:-1}}}function formatErrorMessage(message){const errorMappings={"transaction underpriced":"Transaction failed: Gas price too low. Please try again with a higher gas price. Maybe add a tip as well.","insufficient funds":"Transaction failed: Insufficient funds to complete this transaction.","nonce too low":"Transaction failed: Please wait for your previous transaction to complete.","already known":"This transaction has already been submitted.","replacement transaction underpriced":"Cannot replace existing transaction: New gas price too low.","gas limit reached":"Transaction failed: Network is busy. Please try again later or increase gas limit."};for(const[pattern,friendlyMessage]of Object.entries(errorMappings)){if(message.toLowerCase().includes(pattern.toLowerCase())){return friendlyMessage}}message=message.replace(/[{}"\\]/g,"");message=message.charAt(0).toUpperCase()+message.slice(1);return message}function extractValue(errorString,key){const match=new RegExp(`${key}="([^"]*)"`,"i").exec(errorString);return match?match[1]:void 0}class BigNumber{_value;constructor(value=null){this._value=value}get value(){return this._value}set value(newValue){this._value=newValue}compare(other){const a=this.toBigInt();const b=BigNumber.from(other).toBigInt();if(a===null||b===null){throw new Error("Cannot compare null values")}if(a<b)return-1;if(a>b)return 1;return 0}static isBigNumber(value){return value instanceof BigNumber}static isHexObject(value){return typeof value==="object"&&value!==null&&"hex"in value&&"type"in value}toNumber(){if(this._value===null){return null}if(typeof this._value==="string"||typeof this._value==="number"){return Number(this._value)}if(typeof this._value==="bigint"){return Number(this._value)}if(BigNumber.isBigNumber(this._value)){return this._value.toNumber()}if(BigNumber.isHexObject(this._value)){return Number(BigInt(this._value.hex))}return null}toBigInt(){if(this._value===null){return null}if(typeof this._value==="string"){return BigInt(this._value)}if(typeof this._value==="number"){return BigInt(this._value)}if(typeof this._value==="bigint"){return this._value}if(BigNumber.isBigNumber(this._value)){return this._value.toBigInt()}if(BigNumber.isHexObject(this._value)){return BigInt(this._value.hex)}return null}fromValue(value){this._value=value}max(other){return BigNumber.max(this._value,other)}min(other){return BigNumber.min(this._value,other)}add(other){return BigNumber.add(this._value,other)}subtract(other){return BigNumber.subtract(this._value,other)}sub(other){return this.subtract(other)}div(other){return BigNumber.div(this._value,other)}mul(other){return BigNumber.mul(this._value,other)}mod(other){return BigNumber.mod(this._value,other)}toString(){const bigintValue=this.toBigInt();if(bigintValue===null){return""}return bigintValue.toString()}toHex(isEthereum=true){if(this._value===null){return""}if(typeof this._value==="string"){return this._value}const bigintValue=this.toBigInt();if(bigintValue===null){return""}let hexString=bigintValue.toString(16);if(isEthereum&&hexString.length%2!==0){hexString="0"+hexString}return"0x"+hexString}static from(value){if(BigNumber.isHexObject(value)){return new BigNumber(BigInt(value.hex))}return new BigNumber(value)}static toNumber(value){if(value===null){return null}if(typeof value==="string"||typeof value==="number"){return Number(value)}if(typeof value==="bigint"){return Number(value)}if(BigNumber.isBigNumber(value)){return value.toNumber()}if(BigNumber.isHexObject(value)){return Number(BigInt(value.hex))}return null}static toBigInt(value,decimals=18){if(value===null){return null}if(typeof value==="number"){if(!Number.isInteger(value)){const factor=Math.pow(10,decimals);return BigInt(Math.round(value*factor))}else{return BigInt(value)}}if(typeof value==="string"){if(value.includes(".")){const[integerPart,fractionalPart=""]=value.split(".");const factor=BigInt("1"+"0".repeat(decimals));const scaledValue=BigInt(integerPart)*factor+BigInt((fractionalPart+"0".repeat(decimals)).slice(0,decimals));return scaledValue}else{return BigInt(value)}}if(typeof value==="bigint"){return value}if(BigNumber.isBigNumber(value)){return value.toBigInt()}if(BigNumber.isHexObject(value)){return BigInt(value.hex)}return null}static max(value1,value2){const bigint1=BigNumber.toBigInt(value1);const bigint2=BigNumber.toBigInt(value2);if(bigint1===null||bigint2===null){throw new Error("Invalid BigNumberish value")}return new BigNumber(bigint1>bigint2?bigint1:bigint2)}static min(value1,value2){const bigint1=BigNumber.toBigInt(value1);const bigint2=BigNumber.toBigInt(value2);if(bigint1===null||bigint2===null){throw new Error("Invalid BigNumberish value")}return new BigNumber(bigint1<bigint2?bigint1:bigint2)}static add(value1,value2){const bigint1=BigNumber.toBigInt(value1);const bigint2=BigNumber.toBigInt(value2);if(bigint1===null||bigint2===null){throw new Error("Invalid BigNumberish value")}return new BigNumber(bigint1+bigint2)}static subtract(value1,value2){const bigint1=BigNumber.toBigInt(value1);const bigint2=BigNumber.toBigInt(value2);if(bigint1===null||bigint2===null){throw new Error("Invalid BigNumberish value")}return new BigNumber(bigint1-bigint2)}static sub(value1,value2){return BigNumber.subtract(value1,value2)}static div(value1,value2){const bigint1=BigNumber.toBigInt(value1);const bigint2=BigNumber.toBigInt(value2);if(bigint1===null||bigint2===null||bigint2===BigInt(0)){throw new Error("Invalid BigNumberish value or division by zero")}return new BigNumber(bigint1/bigint2)}static mul(value1,value2){const bigint1=BigNumber.toBigInt(value1);const bigint2=BigNumber.toBigInt(value2);if(bigint1===null||bigint2===null){throw new Error("Invalid BigNumberish value")}return new BigNumber(bigint1*bigint2)}static mod(value1,value2){const bigint1=BigNumber.toBigInt(value1);const bigint2=BigNumber.toBigInt(value2);if(bigint1===null||bigint2===null||bigint2===BigInt(0)){throw new Error("Invalid BigNumberish value or modulus by zero")}return new BigNumber(bigint1%bigint2)}static toHex(value){const bigintValue=BigNumber.toBigInt(value);if(bigintValue===null){throw new Error("Invalid BigNumberish value")}return"0x"+bigintValue.toString(16)}static fromHex(hex){if(typeof hex!=="string"||!/^0x[0-9a-fA-F]+$/.test(hex)){throw new Error("Invalid hex string")}return new BigNumber(BigInt(hex))}toFiat(price){const numberValue=this.toNumber();if(numberValue===null){throw new Error("Invalid BigNumberish value")}return numberValue*price}toFormattedFiat(price,currencyCode,locale=""){const fiatValue=this.toFiat(price);const formatter=new Intl.NumberFormat(locale||void 0,{style:"currency",currency:currencyCode});return formatter.format(fiatValue)}}function encodeJSON$1(obj){const jsonString=JSON.stringify(obj,(_,value)=>{if(typeof value==="bigint"){return value.toString()+"n"}if(typeof value==="object"&&value!==null&&Object.keys(value).length===0){if(Array.isArray(value)){return[]}return"{}"}return value});return jsonString}function isEmptyNullOrUndefined(obj){return obj===null||obj===void 0||typeof obj==="object"&&Object.keys(obj).length===0&&obj.constructor===Object}function isEncryptedData(data){return!isEmptyNullOrUndefined(data)&&typeof data.iv==="string"&&typeof data.data==="string"&&typeof data.salt==="string"}function isProfileData(data){return data.pincode!==void 0}function isMetaData(meta){return meta!==null&&typeof meta==="object"}function isString(value){return typeof value==="string"}function isBigNumber(value){return value instanceof BigNumber}function toHex(value){if(isBigNumber(value)){return value.toHex()}const hex=BigNumber.from(value).toHex();return hex.length%2===0?hex:"0x0"+hex.slice(2)}const Nibbles="0123456789abcdef";BigInt(0);BigInt(1);const maxValue=BigInt(2)**BigInt(256)-BigInt(1);function getBigInt(value,name){try{if(value===null){throw new Error("value cannot be null")}switch(typeof value){case"bigint":return value;case"number":if(!Number.isInteger(value)){throw new Error("underflow")}if(value<-maxValue||value>maxValue){throw new Error("overflow")}return BigInt(value);case"string":if(value===""){throw new Error("empty string")}if(value[0]==="-"&&value[1]!=="-"){return-BigInt(value.substring(1))}if(value==="0"||value==="0.0"||value==="0.00"){return 0n}return BigInt(value);default:throw new Error("invalid BigNumberish value")}}catch(error){log$1.error(`getBigInt: ${error}`);if(error instanceof Error){throw makeError(error.message,"INVALID_ARGUMENT",{argument:"value",value:value})}else{throw error}}}function toBigInt(value,decimals){if(value instanceof Uint8Array){let result="0x0";for(const v of value){result+=Nibbles[v>>4];result+=Nibbles[v&15]}return BigInt(result)}return getBigInt(value)}function safeConvertToBigInt(value){try{if(value===null||value===void 0)return void 0;if(typeof value==="bigint")return value;if(value instanceof BigNumber){return BigInt(value.toString())}if(typeof value==="object"&&value!==null&&"_hex"in value){return BigInt(value._hex)}return toBigInt(value)}catch(error){log$1.error(`safeConvertToBigInt: ${error}`);return 0n}}const getObjectFromLocalStorage=async(key,timeoutMs=1e3)=>{try{if(!browser_ext){return null}const storagePromise=browser_ext.storage.local.get(key);const timeoutPromise=new Promise(resolve=>setTimeout(()=>{resolve(null)},timeoutMs));const result=await Promise.race([storagePromise,timeoutPromise]);if(!result||!(key in result)){return null}return result[key]}catch(error){log$1.error("Error getting object from local storage",false,error);return null}};const setObjectInLocalStorage=async(key,obj)=>{if(!browser_ext)return;try{await browser_ext.storage.local.set({[key]:obj})}catch(error){log$1.error("Error setting object in local storage",false,error);throw error}};function dateString(){return(new Date).toISOString()}function formatDate(date){return date.toLocaleString()}function formatTimestamp(timestamp,{placeholder:placeholder="------",locale:locale="en-US",options:options={month:"short",day:"numeric",hour:"2-digit",minute:"2-digit"}}={}){try{if(timestamp===void 0||typeof timestamp==="number"&&Number.isNaN(timestamp)){return placeholder}let date;if(typeof timestamp==="string"||typeof timestamp==="number"){date=new Date(timestamp);if(isNaN(date.getTime())){return placeholder}}else if(timestamp instanceof Date){date=timestamp}else{return placeholder}return new Intl.DateTimeFormat(locale,options).format(date)}catch(e){log$1.error(e);return placeholder}}const yakklPreferences={id:"",persona:DEFAULT_PERSONA,idleDelayInterval:60,showTestNetworks:true,dark:SystemTheme.SYSTEM,chart:"line",screenWidth:0,screenHeight:0,idleAutoLock:true,idleAutoLockCycle:IDLE_AUTO_LOCK_CYCLE,locale:"en_US",currency:{code:"USD",symbol:"$"},words:32,wallet:{title:DEFAULT_TITLE,extensionHeight:DEFAULT_EXT_HEIGHT,popupHeight:DEFAULT_POPUP_HEIGHT,popupWidth:DEFAULT_POPUP_WIDTH,enableContextMenu:false,enableResize:false,splashDelay:SPLASH_DELAY,alertDelay:ALERT_DELAY,splashImages:NUM_OF_SPLASH_IMAGES,autoLockTimer:0,autoLockAsk:false,autoLockAskTimer:10,animationLockScreen:false,pinned:true,pinnedLocation:"M",defaultWallet:true},theme:"yakkl",themes:[{name:"yakkl",animation:{lockScreen:""},colors:{primary:"",secondary:"",primaryBackgroundLight:"",primaryBackgroundDark:""}}],version:VERSION,createDate:dateString(),updateDate:dateString()};let yakklSettings={id:"",persona:DEFAULT_PERSONA,version:VERSION,previousVersion:"",plan:{type:PlanType.BASIC_MEMBER,source:AccessSourceType.STANDARD,promo:null,trialEndDate:null,upgradeDate:null},trialCountdownPinned:false,legal:{termsAgreed:false,privacyViewed:false,updated:false},platform:{arch:"",nacl_arch:"",os:"",osVersion:"",browser:"",browserVersion:"",platform:""},init:false,showHints:true,isLocked:true,isLockedHow:"",transactions:{retry:{enabled:true,howManyAttempts:3,seconds:30,baseFeeIncrease:.1,priorityFeeIncrease:.1},retain:{enabled:true,days:-1,includeRaw:true}},meta:{},upgradeDate:"",lastAccessDate:dateString(),createDate:dateString(),updateDate:dateString()};let yakklWatch={id:"",persona:DEFAULT_PERSONA,blockchain:"",name:"",tags:[],quantity:0n,includeInPortfolio:false,explorer:"",address:"",addressAlias:"",version:VERSION,createDate:dateString(),updateDate:dateString()};({createDate:dateString(),updateDate:dateString()});let yakklBlocked={id:"",persona:DEFAULT_PERSONA,domain:""};let yakklRegisteredData={id:"",persona:DEFAULT_PERSONA,key:"",plan:{type:PlanType.BASIC_MEMBER,source:AccessSourceType.STANDARD,promo:PromoClassificationType.NONE,trialEndDate:"",upgradeDate:""},version:VERSION,createDate:dateString(),updateDate:dateString()};let profile={id:"",persona:DEFAULT_PERSONA,userName:"",preferences:yakklPreferences,data:{},version:VERSION,createDate:dateString(),updateDate:dateString()};let yakklChat={id:"",persona:DEFAULT_PERSONA,text:"",sender:"",timestamp:"",version:VERSION,createDate:dateString(),updateDate:dateString()};let yakklCurrentlySelected={id:"",persona:DEFAULT_PERSONA,shortcuts:{quantity:0n,accountType:AccountTypeCategory.PRIMARY,accountName:YAKKL_ZERO_ACCOUNT_NAME,smartContract:false,address:YAKKL_ZERO_ADDRESS,alias:"",primary:null,init:false,legal:false,isLocked:true,showTestNetworks:false,profile:{userName:"",name:null,email:""},gasLimit:21e3,networks:[{blockchain:"Ethereum",name:"Mainnet",chainId:1,symbol:"ETH",type:NetworkType.MAINNET,explorer:"https://etherscan.io",decimals:18},{blockchain:"Ethereum",name:"Sepolia",chainId:11155111,symbol:"ETH",type:NetworkType.TESTNET,explorer:"https://sepolia.etherscan.io",decimals:18}],network:{blockchain:"Ethereum",name:"Mainnet",chainId:1,symbol:"ETH",type:NetworkType.MAINNET,explorer:"https://etherscan.io",decimals:18},blockchain:"Ethereum",type:"Mainnet",chainId:1,symbol:"ETH",explorer:"https://etherscan.io"},preferences:{locale:"en_US",currency:{code:"USD",symbol:"$"}},data:{},version:VERSION,createDate:dateString(),updateDate:dateString()};let yakklPrimaryAccount={id:"",persona:DEFAULT_PERSONA,name:YAKKL_ZERO_ACCOUNT_NAME,address:YAKKL_ZERO_ADDRESS,quantity:0n,index:0,data:{},account:{},subIndex:0,subAccounts:[],version:VERSION,createDate:dateString(),updateDate:dateString()};let yakklAccount={id:"",persona:DEFAULT_PERSONA,index:0,blockchain:"Ethereum",smartContract:false,address:YAKKL_ZERO_ADDRESS,alias:"",accountType:AccountTypeCategory.PRIMARY,name:YAKKL_ZERO_ACCOUNT_NAME,description:"",primaryAccount:yakklPrimaryAccount,data:{},quantity:0n,class:"Default",level:"L1",isSigner:true,avatar:"",tags:["Ethereum"],includeInPortfolio:true,connectedDomains:[],version:VERSION,createDate:dateString(),updateDate:dateString()};yakklPrimaryAccount.account=yakklAccount;({createDate:dateString(),updateDate:dateString()});let yakklContact={id:"",persona:DEFAULT_PERSONA,name:"",address:"",addressType:"EOA",avatar:"",blockchain:"Ethereum",alias:"",note:"",version:VERSION,createDate:dateString(),updateDate:dateString(),meta:{}};({createDate:dateString(),updateDate:dateString()});let yakklAccounts=[yakklAccount];let yakklPrimaryAccounts=[yakklPrimaryAccount];let yakklContacts=[yakklContact];let yakklChats=[yakklChat];let yakklBlockedList=[yakklBlocked];let yakklWatchList=[yakklWatch];[{id:"",persona:DEFAULT_PERSONA,blockchain:"Ethereum",name:"Watcher 1",tags:["Binance 8","Uniswap"],quantity:".000455",includeInPortfolio:true,explorer:"",address:"0xf977814e90da44bfa03b6295a0616a897441acec",addressAlias:"",version:VERSION,createDate:dateString(),updateDate:dateString()},{id:"",persona:DEFAULT_PERSONA,blockchain:"Ethereum",name:"Watcher 2",tags:["Vb","Token holdings"],quantity:"0.0",includeInPortfolio:false,explorer:"https://etherscan.io/tokenholdings?a=0xab5801a7d398351b8be11c439e05c5b3259aec9b",address:"0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B",addressAlias:"Vb",version:VERSION,createDate:dateString(),updateDate:dateString()},{id:"",persona:DEFAULT_PERSONA,blockchain:"Ethereum",name:"Watcher 3",tags:["barmstrong.eth","coinbase","address"],quantity:"0.0",includeInPortfolio:false,explorer:"https://etherscan.io/address/0x5b76f5b8fc9d700624f78208132f91ad4e61a1f0",address:"0x5b76f5B8fc9D700624F78208132f91AD4e61a1f0",addressAlias:"barmstrong.eth",version:VERSION,createDate:dateString(),updateDate:dateString()}];class EthereumBigNumber extends BigNumber{toWei(){let ethValue;if(typeof this._value==="number"||typeof this._value==="string"&&this._value.includes(".")){const valueString=this._value.toString();const[integerPart,fractionalPartRaw=""]=valueString.split(".");const fractionalPart=fractionalPartRaw.padEnd(18,"0").slice(0,18);ethValue=BigInt(integerPart+fractionalPart)}else{ethValue=EthereumBigNumber.toBigInt(this._value)??BigInt(0)}return new EthereumBigNumber(ethValue)}toGwei(){let ethValue;if(typeof this._value==="number"||typeof this._value==="string"&&this._value.includes(".")){const valueString=this._value.toString();const[integerPart,fractionalPartRaw=""]=valueString.split(".");const fractionalPart=fractionalPartRaw.padEnd(9,"0").slice(0,9);ethValue=BigInt(integerPart+fractionalPart)}else{ethValue=EthereumBigNumber.toBigInt(this._value)??BigInt(0)}return new EthereumBigNumber(ethValue)}toEther(){const weiValue=EthereumBigNumber.toBigInt(this._value)??BigInt(0);return new EthereumBigNumber(weiValue/BigInt("1000000000000000000"))}toEtherString(){const weiValue=EthereumBigNumber.toBigInt(this._value)??BigInt(0);const etherValue=weiValue/BigInt("1000000000000000000");const remainder=weiValue%BigInt("1000000000000000000");const fractionalPart=remainder.toString().padStart(18,"0").slice(0,18);const etherString=`${etherValue}.${fractionalPart}`;return etherString}static from(value){if(typeof value==="string"&&/^0x[0-9a-fA-F]+$/.test(value)){return new EthereumBigNumber(BigInt(value))}if(value&&typeof value==="object"&&"_hex"in value&&"_isBigNumber"in value){return new EthereumBigNumber(BigInt(value._hex))}return new EthereumBigNumber(BigNumber.toBigInt(value))}static fromWei(value){const weiValue=EthereumBigNumber.from(value);const ethValue=weiValue.div(BigInt("1000000000000000000"));return new EthereumBigNumber(ethValue.toString())}static fromGwei(value){const gweiValue=EthereumBigNumber.from(value);const ethValue=gweiValue.div(BigInt("1000000000"));return new EthereumBigNumber(ethValue.toString())}static fromEther(value){if(value===null||value===void 0){throw new Error("Value cannot be null or undefined")}let etherString;if(typeof value==="number"||typeof value==="string"){etherString=value.toString()}else if(typeof value==="bigint"){etherString=value.toString()}else if(value instanceof BigNumber){etherString=value.toString()}else if(typeof value==="object"&&"_hex"in value&&"_isBigNumber"in value){etherString=BigInt(value._hex).toString()}else{throw new Error("Unsupported type for BigNumberish value")}if(!etherString.includes(".")){etherString+=".0"}const[integerPart,fractionalPart]=etherString.split(".");const fractionalPartPadded=(fractionalPart+"0".repeat(18)).slice(0,18);const weiValue=BigInt(integerPart+fractionalPartPadded);return new EthereumBigNumber(weiValue)}static toWei(value){let ethValue;if(typeof value==="number"||typeof value==="string"&&value.includes(".")){const valueString=value.toString();const[integerPart,fractionalPartRaw=""]=valueString.split(".");const fractionalPart=fractionalPartRaw.padEnd(18,"0").slice(0,18);ethValue=BigInt(integerPart+fractionalPart)}else{ethValue=EthereumBigNumber.toBigInt(value)??BigInt(0)}return new EthereumBigNumber(ethValue)}static toGwei(value){let ethValue;if(typeof value==="number"||typeof value==="string"&&value.includes(".")){const valueString=value.toString();const[integerPart,fractionalPartRaw=""]=valueString.split(".");const fractionalPart=fractionalPartRaw.padEnd(9,"0").slice(0,9);ethValue=BigInt(integerPart+fractionalPart)}else{ethValue=EthereumBigNumber.toBigInt(value)??BigInt(0)}return new EthereumBigNumber(ethValue)}static toEther(value){const weiValue=EthereumBigNumber.from(value).toBigInt()??BigInt(0);return new EthereumBigNumber(weiValue/BigInt("1000000000000000000"))}static toEtherString(value){const weiValue=EthereumBigNumber.from(value).toBigInt()??BigInt(0);const etherValue=weiValue/BigInt("1000000000000000000");const remainder=weiValue%BigInt("1000000000000000000");const fractionalPart=remainder.toString().padStart(18,"0").slice(0,18);const etherString=`${etherValue}.${fractionalPart}`;return etherString}static toFiat(value,price){const etherValue=parseFloat(EthereumBigNumber.toEtherString(value));if(isNaN(etherValue)){throw new Error("Invalid BigNumberish value")}return etherValue*price}static toFormattedFiat(value,price,currencyCode,locale=""){const fiatValue=EthereumBigNumber.toFiat(value,price);const formatter=new Intl.NumberFormat(locale||void 0,{style:"currency",currency:currencyCode});return formatter.format(fiatValue)}static toHex(value){const bigintValue=BigNumber.toBigInt(value);if(bigintValue===null){throw new Error("Invalid BigNumberish value")}let hexString=bigintValue.toString(16);if(hexString.length%2!==0){hexString="0"+hexString}return"0x"+hexString}}class EthersConverter{static toEthersHex(value){if(value===null||value===void 0)return null;if(typeof value==="string"&&value.startsWith("0x"))return value;return"0x"+BigInt(value.toString()).toString(16)}static transactionToEthersTransaction(transaction){return{to:transaction.to??void 0,from:transaction.from??void 0,nonce:transaction.nonce===-1?void 0:transaction.nonce,gasLimit:this.toEthersHex(transaction.gasLimit),gasPrice:this.toEthersHex(transaction.gasPrice),maxPriorityFeePerGas:this.toEthersHex(transaction.maxPriorityFeePerGas),maxFeePerGas:this.toEthersHex(transaction.maxFeePerGas),data:transaction.data?.toString()??void 0,value:this.toEthersHex(transaction.quantity),chainId:this.toEthersHex(transaction.chainId)??void 0,accessList:transaction.accessList??void 0,customData:transaction.customData,type:transaction.type}}static async ethersTransactionResponseToTransactionResponse(tx){return{hash:tx.hash,to:tx.to??"",from:tx.from,nonce:tx.nonce,gasLimit:tx.gasLimit,gasPrice:tx.gasPrice,data:tx.data,quantity:tx.value,chainId:tx.chainId,blockNumber:tx.blockNumber??void 0,blockHash:tx.blockHash??void 0,timestamp:(new Date).getTime(),confirmations:await tx.confirmations(),type:tx.type??void 0,accessList:tx.accessList??void 0,maxPriorityFeePerGas:tx.maxPriorityFeePerGas,maxFeePerGas:tx.maxFeePerGas,wait:async confirmations=>{const receipt=await tx.wait(confirmations);if(!receipt){throw new Error("Transaction receipt is null")}return this.ethersTransactionReceiptToTransactionReceipt(receipt)}}}static async ethersTransactionReceiptToTransactionReceipt(receipt){return{to:receipt.to??"",from:receipt.from,contractAddress:receipt.contractAddress??void 0,transactionIndex:receipt.index,root:receipt.root??void 0,gasUsed:receipt.gasUsed,logsBloom:receipt.logsBloom,blockHash:receipt.blockHash,transactionHash:receipt.hash,logs:receipt.logs.map(this.ethersLogToLog),blockNumber:receipt.blockNumber,confirmations:await receipt.confirmations(),cumulativeGasUsed:receipt.cumulativeGasUsed,effectiveGasPrice:receipt.gasPrice??void 0,byzantium:true,type:receipt.type,status:receipt.status!==null?receipt.status:void 0}}static ethersLogToLog(log2){return{blockNumber:log2.blockNumber,blockHash:log2.blockHash,transactionIndex:log2.transactionIndex,removed:log2.removed,address:log2.address,data:log2.data,topics:[...log2.topics],transactionHash:log2.transactionHash,logIndex:log2.index}}static ethersTransactionRequestToTransactionRequest(tx){try{if(!tx)return null;return{to:tx.to,from:tx.from,nonce:tx.nonce,gasLimit:tx.gasLimit?BigInt(tx.gasLimit.toString()):void 0,gasPrice:tx.gasPrice?BigInt(tx.gasPrice.toString()):void 0,maxPriorityFeePerGas:tx.maxPriorityFeePerGas?BigInt(tx.maxPriorityFeePerGas.toString()):void 0,maxFeePerGas:tx.maxFeePerGas?BigInt(tx.maxFeePerGas.toString()):void 0,data:tx.data,quantity:tx.value?BigInt(tx.value.toString()):null,chainId:tx.chainId,accessList:this.convertAccessList(tx.accessList),customData:tx.customData,type:tx.type}}catch(error){log$1.error("Error converting ethers transaction request to transaction request:",false,error);return null}}static convertAccessList(accessList){if(!accessList)return void 0;if(Array.isArray(accessList)){return accessList.map(item=>{if(Array.isArray(item)){return{address:item[0],storageKeys:item[1]}}else{return{address:item.address,storageKeys:item.storageKeys}}})}return Object.entries(accessList).map(([address,storageKeys])=>({address:address,storageKeys:storageKeys}))}}class BaseFeeManager{providers;initializationPromise;constructor(){this.providers=new Map;this.initializationPromise=Promise.resolve()}async addProvider(providerPromise){const provider=await providerPromise;this.providers.set(provider.getName(),provider)}removeProvider(providerName){this.providers.delete(providerName)}getProviders(){return Array.from(this.providers.keys())}async getGasEstimate(transaction){await this.initializationPromise;if(this.providers.size===0){throw new Error("No gas providers available")}const estimates=await Promise.all(Array.from(this.providers.values()).map(async provider=>provider.getGasEstimate(transaction).catch(error=>{console.log(`Failed to get gas estimate from ${provider.getName()}:`,false,error);return null}))).then(estimates2=>estimates2.filter(estimate=>estimate!==null));const gasLimits=estimates.map(e=>BigNumber.from(e.gasLimit)).sort((a,b)=>a.compare(b));const baseFees=estimates.map(e=>BigNumber.from(e.feeEstimate.baseFee)).sort((a,b)=>a.compare(b));const priorityFees=estimates.map(e=>BigNumber.from(e.feeEstimate.priorityFee)).sort((a,b)=>a.compare(b));const medianGasLimit=gasLimits[Math.floor(gasLimits.length/2)];const medianBaseFee=baseFees[Math.floor(baseFees.length/2)];const medianPriorityFee=priorityFees[Math.floor(priorityFees.length/2)];const feeEstimate={baseFee:medianBaseFee.toString(),priorityFee:medianPriorityFee.toString(),totalFee:medianBaseFee.add(medianPriorityFee).toString()};return{gasLimit:medianGasLimit.toString(),feeEstimate:feeEstimate}}async getHistoricalGasData(duration){if(this.providers.size===0){throw new Error("No gas providers available")}const allHistoricalData=await Promise.all(Array.from(this.providers.values()).map(provider=>provider.getHistoricalGasData(duration)));const aggregatedData=new Map;allHistoricalData.flat().forEach(data=>{if(!aggregatedData.has(data.timestamp)){aggregatedData.set(data.timestamp,{...data,count:1})}else{const existing=aggregatedData.get(data.timestamp);existing.baseFee=BigNumber.from(existing.baseFee).add(BigNumber.from(data.baseFee)).toString();existing.priorityFee=BigNumber.from(existing.priorityFee).add(BigNumber.from(data.priorityFee)).toString();existing.count++}});return Array.from(aggregatedData.values()).map(data=>({timestamp:data.timestamp,baseFee:BigNumber.from(data.baseFee).div(BigNumber.from(data.count)).toString(),priorityFee:BigNumber.from(data.priorityFee).div(BigNumber.from(data.count)).toString()}))}async predictFutureFees(duration){if(this.providers.size===0){throw new Error("No gas providers available")}const allPredictions=await Promise.all(Array.from(this.providers.values()).map(provider=>provider.predictFutureFees(duration)));const aggregatedPredictions=new Map;allPredictions.flat().forEach(prediction=>{if(!aggregatedPredictions.has(prediction.timestamp)){aggregatedPredictions.set(prediction.timestamp,{...prediction,count:1})}else{const existing=aggregatedPredictions.get(prediction.timestamp);existing.estimatedBaseFee=BigNumber.from(existing.estimatedBaseFee).add(BigNumber.from(prediction.estimatedBaseFee)).toString();existing.estimatedPriorityFee=BigNumber.from(existing.estimatedPriorityFee).add(BigNumber.from(prediction.estimatedPriorityFee)).toString();existing.count++}});return Array.from(aggregatedPredictions.values()).map(prediction=>({timestamp:prediction.timestamp,estimatedBaseFee:BigNumber.from(prediction.estimatedBaseFee).div(BigNumber.from(prediction.count)).toString(),estimatedPriorityFee:BigNumber.from(prediction.estimatedPriorityFee).div(BigNumber.from(prediction.count)).toString()}))}setPriorityOrder(providerNames){const orderedProviders=new Map;providerNames.forEach(name=>{if(this.providers.has(name)){orderedProviders.set(name,this.providers.get(name))}});this.providers=orderedProviders}setDefaultProvider(providerName){if(this.providers.has(providerName)){const defaultProvider=this.providers.get(providerName);this.providers.delete(providerName);this.providers=new Map([[providerName,defaultProvider],...this.providers])}}}var TransactionSpeed=(TransactionSpeed2=>{TransactionSpeed2["SLOW"]="SLOW";TransactionSpeed2["NORMAL"]="NORMAL";TransactionSpeed2["FAST"]="FAST";return TransactionSpeed2})(TransactionSpeed||{});const EOA_FALLBACK_GAS={LIMITS:{BASE:21000n},GWEI:{SLOW:{PRIORITY_FEE:1n,MAX_FEE:35n},NORMAL:{PRIORITY_FEE:2n,MAX_FEE:50n},FAST:{PRIORITY_FEE:3n,MAX_FEE:70n}}};var Web3Provider=(Web3Provider2=>{Web3Provider2["ALCHEMY"]="alchemy";Web3Provider2["INFURA"]="infura";Web3Provider2["CLOUDFLARE"]="cloudflare";Web3Provider2["QUICKNODE"]="quicknode";Web3Provider2["CUSTOM"]="custom";return Web3Provider2})(Web3Provider||{});class AnalyticsBase{networkInfo;provider;constructor(provider,web3Provider,chainId,networkName){this.provider=provider;this.networkInfo={provider:web3Provider,chainId:chainId,networkName:networkName}}}class EthereumAnalytics extends AnalyticsBase{gasEstimates=[];swapEstimates=[];MAX_STORED_ENTRIES=1e3;providerStats=new Map;lastNetworkCheck=0;NETWORK_CHECK_INTERVAL=6e4;constructor(provider,web3Provider,chainId,networkName){super(provider,web3Provider,chainId,networkName);this.initializeProviderStats()}static async create(provider,web3Provider,chainId,networkName){const analytics=new EthereumAnalytics(provider,web3Provider,chainId,networkName);await analytics.initializeNetworkInfo();return analytics}initializeProviderStats(){this.providerStats.set(this.networkInfo.provider,{totalCalls:0,failedCalls:0,averageLatency:0})}async initializeNetworkInfo(){try{const startTime=Date.now();const blockNumber=await this.provider.getBlockNumber();const latency=Date.now()-startTime;this.networkInfo={...this.networkInfo,blockNumber:blockNumber,rpcLatency:latency,providerUrl:this.maskProviderUrl(await this.provider.getProviderURL())};this.updateProviderStats("initializeNetworkInfo",true,latency)}catch(error){log.error("Failed to initialize network info:",false,false,error)}}maskProviderUrl(url){if(!url)return"unknown";try{const urlObj=new URL(url);return`${urlObj.protocol}//${urlObj.hostname}/*****`}catch{return"invalid-url"}}updateProviderStats(method,success,latency,error){const stats=this.providerStats.get(this.networkInfo.provider)||{totalCalls:0,failedCalls:0,averageLatency:0};stats.totalCalls++;if(!success){stats.failedCalls++;stats.lastError=error?.message;stats.lastErrorTime=Date.now()}stats.averageLatency=(stats.averageLatency*(stats.totalCalls-1)+latency)/stats.totalCalls;this.providerStats.set(this.networkInfo.provider,stats)}async trackGasEstimate(data){await this.checkAndUpdateNetworkInfo();const enrichedData={...data,timestamp:Date.now(),networkInfo:{...this.networkInfo}};this.gasEstimates.push(enrichedData);if(this.gasEstimates.length>this.MAX_STORED_ENTRIES){this.gasEstimates.shift()}this.updateProviderStats(data.methodName||"gasEstimate",data.success,this.networkInfo.rpcLatency||0);if(!data.success){log.warn(`Gas estimation failed for ${data.methodName}:`,false,data.errorMessage)}if(data.estimateType==="fallback"){log.info(`Using fallback gas estimation for ${data.methodName}:`,false,data.fallbackReason)}}async trackSwapEstimate(data){await this.checkAndUpdateNetworkInfo();const enrichedData={...data,timestamp:Date.now(),networkInfo:{...this.networkInfo}};this.swapEstimates.push(enrichedData);if(this.swapEstimates.length>this.MAX_STORED_ENTRIES){this.swapEstimates.shift()}this.updateProviderStats(`swap_${data.swapType}`,data.success,this.networkInfo.rpcLatency||0)}async checkAndUpdateNetworkInfo(){const now=Date.now();if(now-this.lastNetworkCheck>this.NETWORK_CHECK_INTERVAL){await this.initializeNetworkInfo();this.lastNetworkCheck=now}}async getAnalyticsSummary(){await this.checkAndUpdateNetworkInfo();return{gasStats:this.calculateGasStats(this.gasEstimates),swapStats:this.calculateSwapStats(this.swapEstimates),providerHealth:this.providerStats,networkInfo:this.networkInfo}}calculateGasStats(estimates){const timeWindow={start:estimates[0]?.timestamp||Date.now(),end:estimates[estimates.length-1]?.timestamp||Date.now()};const commonErrors=new Map;const methodUsage=new Map;let totalGasPrice=0n;let totalLatency=0;estimates.forEach(e=>{if(e.errorMessage){commonErrors.set(e.errorMessage,(commonErrors.get(e.errorMessage)||0)+1)}if(e.methodName){methodUsage.set(e.methodName,(methodUsage.get(e.methodName)||0)+1)}totalGasPrice+=BigInt(e.maxFee);totalLatency+=e.networkInfo.rpcLatency||0});return{total:estimates.length,successful:estimates.filter(e=>e.success).length,fallbackUsed:estimates.filter(e=>e.estimateType==="fallback").length,averageGasPrice:estimates.length?totalGasPrice/BigInt(estimates.length):0n,averageLatency:estimates.length?totalLatency/estimates.length:0,commonErrors:commonErrors,methodUsage:methodUsage,lastBlockNumber:this.networkInfo.blockNumber||0,timeWindow:timeWindow}}calculateSwapStats(estimates){const baseStats=this.calculateGasStats(estimates);const popularPairs=new Map;let totalHops=0;estimates.forEach(e=>{const pair=`${e.tokenInSymbol}/${e.tokenOutSymbol}`;popularPairs.set(pair,(popularPairs.get(pair)||0)+1);totalHops+=e.routeHops||1});return{...baseStats,averageHops:estimates.length?totalHops/estimates.length:0,popularPairs:popularPairs}}getProviderHealth(){const stats=this.providerStats.get(this.networkInfo.provider);if(!stats)return"Unknown";const successRate=(stats.totalCalls-stats.failedCalls)/stats.totalCalls;const latency=stats.averageLatency;if(successRate>.99&&latency<500)return"Excellent";if(successRate>.95&&latency<1e3)return"Good";if(successRate>.9&&latency<2e3)return"Fair";return"Poor"}}class EthereumGasProvider{provider;blockchain;priceProvider;analytics;PRIORITY_FEE_MULTIPLIERS={[TransactionSpeed.SLOW]:1n,[TransactionSpeed.NORMAL]:2n,[TransactionSpeed.FAST]:3n};BASE_FEE_MULTIPLIERS={[TransactionSpeed.SLOW]:1.2,[TransactionSpeed.NORMAL]:1.5,[TransactionSpeed.FAST]:2};FALLBACK_MULTIPLIERS={[TransactionSpeed.SLOW]:.8,[TransactionSpeed.NORMAL]:1,[TransactionSpeed.FAST]:1.5};SAFE_FALLBACK_VALUES={BASE_PRIORITY_FEE:1n,MAX_TOTAL_GWEI:100n,MIN_TOTAL_GWEI:25n};MIN_PRIORITY_FEE=1n;constructor(provider,blockchain,priceProvider,analytics){this.provider=provider;this.blockchain=blockchain;this.priceProvider=priceProvider;this.analytics=analytics}static async create(provider,blockchain,priceProvider){const web3ProviderType=await this.determineProviderType(provider);const network=blockchain.getNetwork();const analytics=await EthereumAnalytics.create(provider,web3ProviderType,network.chainId,network.name);return new EthereumGasProvider(provider,blockchain,priceProvider,analytics)}static async determineProviderType(provider){const providerUrl=await provider.getProviderURL()||"";if(providerUrl.includes("alchemy"))return Web3Provider.ALCHEMY;if(providerUrl.includes("infura"))return Web3Provider.INFURA;if(providerUrl.includes("cloudflare"))return Web3Provider.CLOUDFLARE;if(providerUrl.includes("quiknode"))return Web3Provider.QUICKNODE;return Web3Provider.CUSTOM}getName(){return"EthereumGasProvider"}async getFallbackGasPrice(speed=TransactionSpeed.NORMAL){try{const recentGasPrice=await this.provider.getGasPrice();const multiplier=this.FALLBACK_MULTIPLIERS[speed];return BigInt(Number(recentGasPrice)*multiplier)}catch(error){const errorMessage=error instanceof Error?error.message:"Unknown error";this.analytics.trackGasEstimate({estimateType:"fallback",gasLimit:"0",priorityFee:"0",maxFee:"0",success:false,methodName:"getFallbackGasPrice",errorMessage:errorMessage,networkInfo:this.analytics.networkInfo,timestamp:Date.now(),fallbackReason:"Gas price fetch failed"});return EOA_FALLBACK_GAS.GWEI[speed].MAX_FEE*BigInt(1e9)}}async getOptimizedGasFees(gasLimit,options={}){try{const speed=options.speed||TransactionSpeed.NORMAL;const feeData=await this.provider.getFeeData();let priorityFeePerGas;if(options.customPriorityFee){priorityFeePerGas=options.customPriorityFee}else{const basePriorityFee=BigInt(Math.max(Number(feeData.maxPriorityFeePerGas||this.MIN_PRIORITY_FEE),Number(this.MIN_PRIORITY_FEE)));priorityFeePerGas=basePriorityFee*this.PRIORITY_FEE_MULTIPLIERS[speed]}let maxFeePerGas;if(options.customMaxFee){maxFeePerGas=options.customMaxFee}else{const baseFee=feeData.lastBaseFeePerGas||0n;const multiplier=this.BASE_FEE_MULTIPLIERS[speed];maxFeePerGas=baseFee*BigInt(multiplier*10)/10n+priorityFeePerGas}const estimatedCostWei=gasLimit*maxFeePerGas;const estimatedCostEth=ethers.formatEther(estimatedCostWei);const ethPrice=await this.getEthPrice();const estimatedCostUsd=(Number(estimatedCostEth)*ethPrice).toFixed(2);const result={maxPriorityFeePerGas:priorityFeePerGas,maxFeePerGas:maxFeePerGas,estimatedCostWei:estimatedCostWei,estimatedCostEth:estimatedCostEth,estimatedCostUsd:`$${estimatedCostUsd}`};this.analytics.trackGasEstimate({estimateType:"optimized",gasLimit:gasLimit.toString(),priorityFee:priorityFeePerGas.toString(),maxFee:maxFeePerGas.toString(),success:true,methodName:"getOptimizedGasFees",networkInfo:this.analytics.networkInfo,timestamp:Date.now()});return result}catch(error){const errorMessage=error instanceof Error?error.message:"Unknown error";this.analytics.trackGasEstimate({estimateType:"fallback",gasLimit:gasLimit.toString(),priorityFee:"0",maxFee:"0",success:false,methodName:"getOptimizedGasFees",errorMessage:errorMessage,networkInfo:this.analytics.networkInfo,timestamp:Date.now(),fallbackReason:"Optimization failed"});throw error}}async getGasEstimate(transaction,options={}){try{const gasLimit=await this.provider.estimateGas(transaction);const optimizedFees=await this.getOptimizedGasFees(gasLimit,options);const result={gasLimit:gasLimit.toString(),feeEstimate:{baseFee:(optimizedFees.maxFeePerGas-optimizedFees.maxPriorityFeePerGas).toString(),priorityFee:optimizedFees.maxPriorityFeePerGas.toString(),totalFee:optimizedFees.maxFeePerGas.toString(),estimatedCostEth:optimizedFees.estimatedCostEth,estimatedCostUsd:optimizedFees.estimatedCostUsd}};this.analytics.trackGasEstimate({estimateType:"normal",gasLimit:gasLimit.toString(),priorityFee:optimizedFees.maxPriorityFeePerGas.toString(),maxFee:optimizedFees.maxFeePerGas.toString(),success:true,methodName:"getGasEstimate",networkInfo:this.analytics.networkInfo,timestamp:Date.now()});return result}catch(error){const errorMessage=error instanceof Error?error.message:"Unknown error";this.analytics.trackGasEstimate({estimateType:"fallback",gasLimit:"0",priorityFee:"0",maxFee:"0",success:false,methodName:"getGasEstimate",errorMessage:errorMessage,networkInfo:this.analytics.networkInfo,timestamp:Date.now(),fallbackReason:"Estimation failed"});throw error}}async getSafeGasEstimate(to,value,options={}){try{const estimate=await this.getEOATransferGasEstimate(to,value,options);const totalGwei=EthereumBigNumber.from(estimate.feeEstimate.totalFee).toBigInt();if(totalGwei>this.SAFE_FALLBACK_VALUES.MAX_TOTAL_GWEI){throw new Error("Gas estimate too high")}if(totalGwei<this.SAFE_FALLBACK_VALUES.MIN_TOTAL_GWEI){throw new Error("Gas estimate too low")}return estimate}catch(error){const baseGasPrice=await this.getFallbackGasPrice(options.speed);const priorityFee=this.SAFE_FALLBACK_VALUES.BASE_PRIORITY_FEE*BigInt(1e9);const maxFee=baseGasPrice+priorityFee;const errorMessage=error instanceof Error?error.message:"Unknown error";this.analytics.trackGasEstimate({estimateType:"fallback",gasLimit:"21000",priorityFee:priorityFee.toString(),maxFee:maxFee.toString(),success:false,methodName:"getSafeGasEstimate",errorMessage:errorMessage,networkInfo:this.analytics.networkInfo,timestamp:Date.now(),fallbackReason:"Safe estimate bounds exceeded"});return{gasLimit:"21000",feeEstimate:{baseFee:baseGasPrice.toString(),priorityFee:priorityFee.toString(),totalFee:maxFee.toString(),estimatedCostEth:ethers.formatEther(21000n*maxFee),estimatedCostUsd:"Using fallback values"}}}}async getEOATransferGasEstimate(to,value,options={}){const transaction={to:to,quantity:value,from:"0x0000000000000000000000000000000000000000",chainId:this.blockchain.getChainId()};return this.getGasEstimate(transaction,options)}async getEOATransferGasEstimateWithFallback(to,value,options={}){try{return await this.getEOATransferGasEstimate(to,value,options)}catch(error){const errorMessage=error instanceof Error?error.message:"Unknown error";log.error("Gas estimation failed, using fallback values:",false,errorMessage);const speed=options.speed||TransactionSpeed.NORMAL;const fallbackValues=EOA_FALLBACK_GAS.GWEI[speed];this.analytics.trackGasEstimate({estimateType:"fallback",gasLimit:EOA_FALLBACK_GAS.LIMITS.BASE.toString(),priorityFee:fallbackValues.PRIORITY_FEE.toString(),maxFee:fallbackValues.MAX_FEE.toString(),success:false,methodName:"getEOATransferGasEstimateWithFallback",errorMessage:errorMessage,networkInfo:this.analytics.networkInfo,timestamp:Date.now(),fallbackReason:"Estimation failed, using fallback"});return{gasLimit:EOA_FALLBACK_GAS.LIMITS.BASE.toString(),feeEstimate:{baseFee:(fallbackValues.MAX_FEE-fallbackValues.PRIORITY_FEE).toString(),priorityFee:fallbackValues.PRIORITY_FEE.toString(),totalFee:fallbackValues.MAX_FEE.toString(),estimatedCostEth:ethers.formatEther(EOA_FALLBACK_GAS.LIMITS.BASE*fallbackValues.MAX_FEE*BigInt(1e9)),estimatedCostUsd:"Fallback estimate"}}}}async getHistoricalGasData(duration){try{const response=await fetch("https://api.example.com/historical-gas-data");const data=await response.json();const historicalData=data.map(item=>({timestamp:item.timestamp,baseFee:item.baseFeePerGas,priorityFee:item.priorityFeePerGas}));this.analytics.trackGasEstimate({estimateType:"historical",gasLimit:"0",priorityFee:"0",maxFee:"0",success:true,methodName:"getHistoricalGasData",networkInfo:this.analytics.networkInfo,timestamp:Date.now()});return historicalData}catch(error){const errorMessage=error instanceof Error?error.message:"Unknown error";log.error("Error fetching historical gas data:",false,errorMessage);this.analytics.trackGasEstimate({estimateType:"historical",gasLimit:"0",priorityFee:"0",maxFee:"0",success:false,methodName:"getHistoricalGasData",errorMessage:errorMessage,networkInfo:this.analytics.networkInfo,timestamp:Date.now()});throw error}}async predictFutureFees(duration){try{const historicalData=await this.getHistoricalGasData(duration);const predictions=historicalData.map(item=>({timestamp:item.timestamp+duration,estimatedBaseFee:item.baseFee,estimatedPriorityFee:item.priorityFee}));this.analytics.trackGasEstimate({estimateType:"prediction",gasLimit:"0",priorityFee:"0",maxFee:"0",success:true,methodName:"predictFutureFees",networkInfo:this.analytics.networkInfo,timestamp:Date.now()});return predictions}catch(error){const errorMessage=error instanceof Error?error.message:"Unknown error";log.error("Error predicting future gas fees:",false,errorMessage);this.analytics.trackGasEstimate({estimateType:"prediction",gasLimit:"0",priorityFee:"0",maxFee:"0",success:false,methodName:"predictFutureFees",errorMessage:errorMessage,networkInfo:this.analytics.networkInfo,timestamp:Date.now()});throw error}}async estimateSwapGasFee(tokenIn,tokenOut,fromAmount,slippageTolerance,deadline,swapManager,fee=3e3){try{const BASE_SWAP_GAS=150000n;const APPROVAL_GAS=46000n;let totalGasUnits=BASE_SWAP_GAS;if(!tokenIn.isNative){totalGasUnits+=APPROVAL_GAS}const feeData=await this.provider.getFeeData();const maxFeePerGas=feeData.maxFeePerGas||feeData.gasPrice;if(!maxFeePerGas)throw new Error("Could not get gas price");const gasCostWei=totalGasUnits*BigInt(maxFeePerGas.toString());const gasCostEth=EthereumBigNumber.fromWei(gasCostWei.toString()).toEtherString();const ethPrice=await this.getEthPrice();const gasCostUsd=parseFloat(gasCostEth)*ethPrice;this.analytics.trackSwapEstimate({estimateType:"normal",gasLimit:totalGasUnits.toString(),priorityFee:feeData.maxPriorityFeePerGas?.toString()||"0",maxFee:maxFeePerGas.toString(),success:true,methodName:"estimateSwapGasFee",networkInfo:this.analytics.networkInfo,timestamp:Date.now(),tokenInSymbol:tokenIn.symbol,tokenOutSymbol:tokenOut.symbol,amount:fromAmount.toString(),isMultiHop:false,swapType:"exactIn",dexUsed:"Uniswap V3"});return`$${gasCostUsd.toFixed(2)} (${gasCostEth} ETH)`}catch(error){const errorMessage=error instanceof Error?error.message:"Unknown error";log.error("Gas estimation error:",false,errorMessage);this.analytics.trackSwapEstimate({estimateType:"fallback",gasLimit:"0",priorityFee:"0",maxFee:"0",success:false,methodName:"estimateSwapGasFee",errorMessage:errorMessage,networkInfo:this.analytics.networkInfo,timestamp:Date.now(),tokenInSymbol:tokenIn.symbol,tokenOutSymbol:tokenOut.symbol,amount:fromAmount.toString(),isMultiHop:false,swapType:"exactIn",dexUsed:"Uniswap V3"});return"Unable to estimate gas"}}async getEthPrice(){try{log.debug("getEthPrice - priceProvider",false,this.priceProvider);const marketPrice=this.priceProvider.getMarketPrice("ETH-USD");return(await marketPrice).price}catch(error){log.error("Error fetching ETH price:",false,false,error);return 0}}async getCurrentGasPriceInGwei(factor=1){const gasPrice=await this.provider.getGasPrice();return Number(ethers.formatUnits(gasPrice,"gwei"))*factor}async getGasPriceFromEtherscan(apiKey){const response=await fetch(`https://api.etherscan.io/api?module=gastracker&action=gasoracle&apikey=${apiKey}`);const data=await response.json();return Number(data.result.ProposeGasPrice)}async getFormattedGasEstimates(gasEstimate,factor=1.5,gasPriceInGwei=0,ethPriceInUsd=0){if(!gasEstimate){throw new Error("Gas estimate must be provided")}const gasEstimateBigInt=BigNumber.from(gasEstimate).toBigInt();if(gasEstimateBigInt<=0n){return 0}if(factor<=0){factor=1;log.warn("Factor must be greater than 0 - set to 1")}if(gasPriceInGwei<0){gasPriceInGwei=0;log.warn("Gas price must be greater than or equal to 0 - set to 0")}if(ethPriceInUsd<=0){ethPriceInUsd=0;log.warn("ETH price must be greater than 0 - set to 0")}if(gasPriceInGwei===0){gasPriceInGwei=await this.getCurrentGasPriceInGwei(factor)}if(ethPriceInUsd===0){ethPriceInUsd=await this.getEthPrice()}const gasPriceInEth=gasPriceInGwei*1e-9;const gasEstimateInEth=Number(gasEstimate)*gasPriceInEth;const gasEstimateInUsd=gasEstimateInEth*ethPriceInUsd;return gasEstimateInUsd}setPriceProvider(priceProvider){this.priceProvider=priceProvider}}class CoinbasePriceProvider{getAPIKey(){return""}getName(){return"Coinbase"}async getMarketPrice(pair){try{if(!pair){return{provider:this.getName(),price:0,lastUpdated:new Date,status:404,message:`Invalid pair - ${pair}`}}pair=await this.getProviderPairFormat(pair);const[tokenIn,tokenOut]=pair.split("-");if(!tokenIn||!tokenOut){return{provider:this.getName(),price:0,lastUpdated:new Date,status:404,message:`Invalid pair - ${pair}`}}if(tokenIn==="USDC"){return{provider:this.getName(),price:parseFloat("1.00"),lastUpdated:new Date,currency:tokenOut,status:0,message:""}}if(tokenIn==="WETH"){pair=`ETH-${tokenOut}`}if(tokenIn==="WBTC"){pair=`BTC-${tokenOut}`}const json=await fetchJson(`https://api.coinbase.com/api/v3/brokerage/market/products?limit=1&product_ids=${pair}`);if(json.num_products<=0){return{provider:this.getName(),price:0,lastUpdated:new Date,status:404,message:`No data found for - ${pair}`}}return{provider:this.getName(),price:parseFloat(json.products[0].price),lastUpdated:new Date,currency:tokenOut,status:0,message:""}}catch(e){log$1.error("CoinbasePriceProvider - getPrice - error",e);let status=404;let message=`Error - ${e}`;if(e.response&&e.response.status===429){status=429;message="Too Many Requests - Rate limit exceeded"}return{provider:this.getName(),price:0,lastUpdated:new Date,status:status,message:message}}}async getProviderPairFormat(pair){return pair}}class AbstractBlockchain{provider;providers=[];chainId;networks=[];network;symbol;icon;name;options;feeManager;constructor(name,chainId,providers,networks2,symbol,icon,options={}){this.name=name;this.providers=providers;if(providers.length===0)throw new Error("Providers list cannot be empty");this.chainId=chainId;this.networks=networks2;this.options=options;this.symbol=symbol;this.icon=icon;this.network=this.getNetwork();if(!this.isNetworkAndChainIdValid(chainId))throw new Error("Unsupported network and chain. Please check the chain ID and/or networks");if(!this.providers||this.providers.length===0)throw new Error("Providers list cannot be empty");this.provider=providers[0];this.feeManager=new BaseFeeManager;this.initializeBlockchain().catch(error=>{log$1.error("Failed to initialize blockchain:",false,error)})}async initializeBlockchain(){try{if(!this.provider){throw new Error("Provider not initialized")}const gasProvider=await EthereumGasProvider.create(this.provider,this,new CoinbasePriceProvider);await this.feeManager.addProvider(gasProvider)}catch(error){log$1.error("Failed to initialize blockchain:",false,false,error)}}async isInitialized(){try{const providers=this.feeManager.getProviders();return providers.length>0}catch{return false}}async ensureInitialized(){const providers=this.feeManager.getProviders();if(!this.feeManager||providers.length===0){throw new Error("Blockchain not properly initialized")}}async getGasEstimate(transaction){if(!(await this.isInitialized())){throw new Error("Gas provider not initialized")}return this.feeManager.getGasEstimate(transaction)}async getHistoricalGasData(duration){if(!this.feeManager||!duration)throw new Error("Fee manager or duration not set");return await this.feeManager.getHistoricalGasData(duration)}async predictFutureFees(duration){if(!this.feeManager||!duration)throw new Error("Fee manager or duration not set");return await this.feeManager.predictFutureFees(duration)}async call(transaction,blockTag){if(!transaction)throw new Error("Transaction not set");try{return await this.provider.call(transaction,blockTag)}catch(e){throw new Error(`Error calling - call: ${e}`)}}connect(provider,chainId){if(!this.providers||!this.providers.includes(provider))throw new Error("Provider(s) not supported");if(!this.isNetworkAndChainIdValid(chainId))throw new Error("Unsupported network and chain");this.provider=provider;this.chainId=chainId}getBlockchainName(){return this.name}getChainId(){return this.chainId}getNetwork(){this.network=this.networks.find(network=>network.chainId===this.chainId)||this.networks[0];return this.network}getNetworkByChainId(chainId){if(!chainId)throw new Error("Chain ID not set");if(!this.isNetworkAndChainIdValid(chainId))throw new Error("Unsupported network and chain");return this.networks.find(network=>network.chainId===chainId)||this.networks[0]}getIcon(){return this.icon}getNetworks(){log$1.info("Blockchain networks",false,this.networks);return this.networks}getSymbol(){return this.symbol}async setChainId(chainId){if(!chainId)throw new Error("Chain ID not set");if(!this.isNetworkAndChainIdValid(chainId))throw new Error("Unsupported network and chain");if(this.chainId===chainId){return}if(chainId<=0){throw new Error("Invalid chain ID")}if(this.provider.getChainIds()&&!this.provider.getChainIds().includes(chainId)){throw new Error("Provider does not support chain ID")}if(this.networks.find(network=>network.chainId===chainId)===void 0){throw new Error("Blockchain does not support chain ID")}this.network=this.getNetworkByChainId(chainId);this.chainId=chainId}setNetwork(network){if(!network)throw new Error("Network not set");try{if(!this.networks.includes(network)){return this.network}const oldNetwork=this.network;this.network=network;return oldNetwork}catch(e){throw new Error(`Error calling - switchNetwork: ${e}`)}}setNetworkByChainId(chainId){if(!chainId)throw new Error("Chain ID not set");try{const network=this.getNetworkByChainId(chainId);return this.setNetwork(network)}catch(e){throw new Error(`Error calling - switchNetwork: ${e}`)}}async getBalance(address){try{if(!address)return 0n;return await this.provider.getBalance(address)}catch(e){throw new Error(`Error calling - getBalance: ${e}`)}}getOptions(blockchain){if(!blockchain)throw new Error("Blockchain not set");return this.options[blockchain]}getProvider(){return this.provider}getSigner(){return this.provider.getSigner()}getSignerNative(){return this.provider.getSignerNative()}getProviders(){return this.providers}getProviderList(){return this.providers.map(provider=>provider.name)}isNetworkAndChainIdValid(chainId){if(!chainId)throw new Error("Chain ID not set");return this.networks.find(network=>network.chainId===chainId)!==void 0}isSmartContractSupported(){return false}async request(method,params){try{return await this.provider.request(method,params)}catch(e){throw new Error(`Error calling - request - ${method}: ${e}`)}}async sendRawTransaction(signedTransaction){try{return await this.provider.sendRawTransaction(signedTransaction)}catch(e){throw new Error(`Error calling - sendTransaction: ${e}`)}}setProvider(provider,chainId){if(!this.providers.includes(provider)){throw new Error("Provider not supported")}this.provider=provider;this.chainId=chainId}_updateOptions(newOptions,overrideAll=false){if(overrideAll){this.options=newOptions}else{this.options={...this.options,...newOptions}}}}class AbstractContract{address;abi;provider;constructor(address,abi,provider){if(!address||!abi||!provider)throw new Error("Invalid parameters");this.address=address;this.abi=abi;this.provider=provider}isSigner(value){if(!value)return false;return"signMessage"in value&&typeof value.signMessage==="function"}}class EthereumContract extends AbstractContract{contract;interface;constructor(address,abi,provider){super(address,abi,provider);this.contract=new ethers.Contract(address,abi,provider.getSignerNative());if(!this.contract){throw new Error("Invalid contract")}this.interface=new ethers.Interface(abi);if(!this.interface){throw new Error("Invalid interface")}}async call(functionName,...args){try{if(!functionName||!this.interface)throw new Error("Invalid function name or invalid interface");if(!this.interface.getFunction(functionName))throw new Error(`Function ${functionName} does not exist on contract`);return await this.contract[functionName](...args)}catch(error){log$1.error(`Error calling ${functionName}:`,false,error);throw error}}async estimateGas(functionName,...args){try{if(!functionName||!this.interface)throw new Error("Invalid function name or invalid interface");if(!this.interface.getFunction(functionName))throw new Error(`Function ${functionName} does not exist on contract`);const contractFunction=this.contract[functionName];if(typeof contractFunction!=="function"){throw new Error(`${functionName} is not a function`)}const estimation=await contractFunction.estimateGas(...args);return BigInt(estimation.toString())}catch(error){log$1.error(`Error estimating gas for ${functionName}:`,false,error);throw error}}async populateTransaction(functionName,...args){try{if(!functionName||!this.interface)throw new Error("Invalid function name or invalid interface");if(!this.interface.getFunction(functionName))throw new Error(`Function ${functionName} does not exist on contract`);const contractFunction=this.contract[functionName];if(typeof contractFunction!=="function"){throw new Error(`${functionName} is not a function`)}const tx=await contractFunction.populateTransaction(...args);if(!tx)throw new Error("Invalid transaction from populate transaction");return EthersConverter.ethersTransactionRequestToTransactionRequest(tx)}catch(error){log$1.error(`Error populating transaction for ${functionName}:`,false,error);throw error}}async sendTransaction(functionName,...args){try{if(!this.interface.getFunction(functionName)){throw new Error(`Function ${functionName} does not exist on contract`)}const tx=await this.contract[functionName](...args);if(!tx)throw new Error("Invalid transaction from send transaction");return EthersConverter.ethersTransactionResponseToTransactionResponse(tx)}catch(error){log$1.error(`Error sending transaction for ${functionName}:`,false,error);throw error}}encodeFunctionData(functionName,args=[]){if(!this.interface.getFunction(functionName)){throw new Error(`Function ${functionName} does not exist on contract`)}return this.interface.encodeFunctionData(functionName,args)}on(eventName,listener){this.contract.on(eventName,listener)}off(eventName,listener){this.contract.off(eventName,listener)}once(eventName,listener){this.contract.once(eventName,listener)}getFunctions(){const functions={};const functionFragments=Object.values(Object.fromEntries(Object.entries(this.interface.fragments).filter(([_,fragment])=>fragment.type==="function")));functionFragments.forEach(fragment=>{functions[fragment.name]=(...args)=>this.call(fragment.name,...args)});return functions}getEvents(){const eventFragments=Object.values(Object.fromEntries(Object.entries(this.interface.fragments).filter(([_,fragment])=>fragment.type==="event")));return eventFragments.map(event=>event.name)}}const networks=[{blockchain:"Ethereum",name:"Mainnet",chainId:1,symbol:"ETH",type:NetworkType.MAINNET,explorer:"https://etherscan.io",decimals:18},{blockchain:"Ethereum",name:"Sepolia",chainId:11155111,symbol:"ETH",type:NetworkType.TESTNET,explorer:"https://sepolia.etherscan.io",decimals:18},{blockchain:"Unichain",name:"Sepolia",chainId:1301,symbol:"ETH",type:NetworkType.TESTNET,explorer:"https://sepolia.uniscan.xyz/",decimals:18}];class Ethereum extends AbstractBlockchain{_options;constructor(providers,chainId=1,options={},overrideAll=false){super("Ethereum",chainId,providers,networks,"ETH","/images/ethereum_icon_purple.svg");this.chainId=chainId;this.options=options;this._updateOptions(options,overrideAll);this._options=this.getOptions("ethereum")}async createAccount(accountToDeriveFrom=null,accountInfo){if(!accountInfo)throw new Error("Account info is missing");if(accountToDeriveFrom===null){return this.createPrimaryAccount(accountInfo)}else{if(!accountInfo.path)throw new Error("Derive Path is missing from the account info");return this.createSubAccount(accountToDeriveFrom,accountInfo.path)}}async estimateGas(transaction){if(!transaction)throw new Error("Transaction is missing");return await this.provider.estimateGas(transaction)}async getBalance(addressOrName,blockTag){if(!addressOrName)throw new Error("Address is missing");return await this.provider.getBalance(addressOrName,blockTag!==void 0?blockTag:"latest")}async getBlock(blockHashOrBlockTag){if(!blockHashOrBlockTag)throw new Error("Block hash or tag is missing");throw new Error("Method not implemented.")}async getBlockNumber(){throw new Error("Method not implemented.")}async getBlockWithTransactions(blockHashOrBlockTag){if(!blockHashOrBlockTag)throw new Error("Block hash or tag is missing");throw new Error("Method not implemented.")}async getCode(addressOrName,blockTag){if(!addressOrName)throw new Error("Address is missing");throw new Error("Method not implemented.")}async getFeeData(){return await this.provider.getFeeData()}async getGasPrice(){throw new Error("Method not implemented.")}async getLogs(filter){if(!filter)throw new Error("Filter is missing");throw new Error("Method not implemented.")}async getStorageAt(addressOrName,position,blockTag){if(!addressOrName)throw new Error("Address is missing");throw new Error("Method not implemented.")}async signTypedData(transction){if(!transction)throw new Error("Transaction is missing");throw new Error("Method not implemented.")}async getTransaction(transactionHash){if(!transactionHash)throw new Error("Transaction hash is missing");return await this.provider.getTransaction(transactionHash)}async getTransactionCount(addressOrName,blockTag){if(!addressOrName)throw new Error("Address is missing");return await this.provider.getTransactionCount(addressOrName,blockTag)}async getTransactionHistory(address){if(!address)throw new Error("Address is missing");return await this.provider.getTransactionHistory(address)}async getTransactionReceipt(transactionHash){if(!transactionHash)throw new Error("Transaction hash is missing");return await this.provider.getTransactionReceipt(transactionHash)}isAddress(address){const returnValue=ethers.isAddress(address);return returnValue}async isSmartContract(address){if(!this.isAddress(address))return false;let contractCode;try{contractCode=await this.provider.getCode(address)}catch(e){contractCode=null}return contractCode&&contractCode!=="0x"&&contractCode!=="0x0"}isSmartContractSupported(){return true}async request(method,params){return await this.provider.request(method,params)}async sendTransaction(transaction){return await this.provider.sendTransaction(transaction)}async sendRawTransaction(signedTransaction){return await this.provider.sendRawTransaction(signedTransaction)}async signTransaction(transaction){return await this.provider.signTransaction(transaction)}async signMessage(message){return await this.provider.signMessage(message)}async createPrimaryAccount(accountInfo){const entropy=ethers.randomBytes(32);if(!entropy)throw new Error("Error generating entropy for the mnemonic");const randomMnemonic=ethers.Mnemonic.fromEntropy(entropy);if(!randomMnemonic)throw new Error("Error generating mnemonic from entropy");const ethWallet=ethers.HDNodeWallet.fromMnemonic(randomMnemonic,accountInfo.path);if(!ethWallet)throw new Error("Error creating wallet from mnemonic");({extendedKey:ethWallet.extendedKey,privateKey:ethWallet.privateKey,publicKey:ethWallet.publicKey,publicKeyUncompressed:ethWallet.publicKey,path:ethWallet.path?ethWallet.path:accountInfo.path,pathIndex:accountInfo.index,fingerPrint:ethWallet.fingerprint,parentFingerPrint:ethWallet.parentFingerprint,chainCode:ethWallet.chainCode});({id:accountInfo.id,index:accountInfo.index,address:ethWallet.address,accountType:AccountTypeCategory.PRIMARY,name:!accountInfo.accountName?`Portfolio Level Account ${accountInfo.index+1}`:accountInfo.accountName,createDate:dateString(),updateDate:dateString()});const primaryAccountData={extendedKey:ethWallet.extendedKey,privateKey:ethWallet.privateKey,publicKey:ethWallet.publicKey,publicKeyUncompressed:ethWallet.publicKey,path:ethWallet.path?ethWallet.path:accountInfo.path,pathIndex:accountInfo.index,fingerPrint:ethWallet.fingerprint,parentFingerPrint:ethWallet.parentFingerprint,chainCode:ethWallet.chainCode,mnemonic:randomMnemonic.phrase,entropy:entropy,password:ethWallet.mnemonic?.password,wordCount:ethWallet.mnemonic?.phrase.split(" ").length||24,wordListLocale:ethWallet.mnemonic?.wordlist.locale||"en"};const primaryAccount={id:accountInfo.id,name:"Primary Account",address:ethWallet.address,quantity:0n,index:0,data:primaryAccountData,account:{},subIndex:0,subAccounts:[],version:VERSION,createDate:dateString(),updateDate:dateString()};return primaryAccount}async createSubAccount(primaryAccount,derivedPath){const mnemonic=primaryAccount.data.mnemonic;if(!mnemonic)throw new Error("Mnemonic is missing from the primary account data");const ethWallet=ethers.HDNodeWallet.fromPhrase(mnemonic,void 0,derivedPath);if(!ethWallet)throw new Error("Error deriving sub account from primary account");const accountData={extendedKey:ethWallet.extendedKey,privateKey:ethWallet.privateKey,publicKey:ethWallet.publicKey,publicKeyUncompressed:ethWallet.publicKey,path:ethWallet.path,pathIndex:primaryAccount.subIndex+1,fingerPrint:ethWallet.fingerprint,parentFingerPrint:primaryAccount.data.fingerPrint,chainCode:"",assignedTo:[]};const subAccount={id:"1",index:primaryAccount.subIndex+1,blockchain:"Ethereum",smartContract:false,address:ethWallet.address,alias:"New Sub Account",accountType:AccountTypeCategory.SUB,name:"Sub Account Name",description:"Description of the sub account",primaryAccount:primaryAccount,data:accountData,quantity:0n,class:"standard",level:"L1",isSigner:true,avatar:"default-avatar.png",tags:[],includeInPortfolio:true,connectedDomains:[],version:"1.0",createDate:(new Date).toISOString(),updateDate:(new Date).toISOString()};return subAccount}async resolveName(name){if(!name)return null;return await this.provider.resolveName(name)}async lookupAddress(address){if(!address)return null;return await this.provider.lookupAddress(address)}createContract(address,abi){if(!address||!abi)return null;return new EthereumContract(address,abi,this.provider)}}const ADDRESSES={WETH:"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"};const walletStore=writable(null);const tokens=writable([]);const preferredTokenSymbols=writable(["ETH","WETH","USDC","USDT","WBTC"]);const sortedTokens=derived([tokens,preferredTokenSymbols],([$tokens,$preferredTokenSymbols])=>{const preferredTokens=$tokens.filter(token=>$preferredTokenSymbols.includes(token.symbol));const nonPreferredTokens=$tokens.filter(token=>!$preferredTokenSymbols.includes(token.symbol)&&token.chainId===1);let eth={chainId:1,address:ADDRESSES.WETH,name:"Ethereum",symbol:"ETH",decimals:18,isNative:true,isStablecoin:false,logoURI:"/images/ethereum.svg"};preferredTokens.unshift(eth);return[...preferredTokens,...nonPreferredTokens]});const prerender=false;const alert=writable({msg:"Welcome to the YAKKLÂ® Smart Wallet!",icon:1,color:{background:"bg-indigo-400",text:"text-indigo-800"},opacity:.5,ms:3e3});async function loadCheckCurrentlySelectedStore(){try{const currentlySelected=getYakklCurrentlySelectedStore();const miscStore=getMiscStore();if(miscStore&&currentlySelected!==null){if(isEncryptedData(currentlySelected.data)){decryptData(currentlySelected.data,miscStore).then(result=>{currentlySelected.data=result;return currentlySelected})}else{return currentlySelected}}return null}catch(error){log$1.error("Error in loadCheckCurrentlySelectedStore:",false,error);throw error}}async function verifyEncryption(value){try{const miscStore=getMiscStore();if(miscStore){const processItem=async item=>{if(!isEncryptedData(item.data)){const result=await encryptData(item.data,miscStore);item.data=result}return item};if(Array.isArray(value)){return Promise.all(value.map(processItem))}else{return processItem(value)}}return value}catch(error){log$1.error("Error in verifyEncryption:",false,error);throw error}}const yakklPreferencesStore=writable(yakklPreferences);const yakklSettingsStore=writable(yakklSettings);const profileStore=writable(profile);const yakklCurrentlySelectedStore=writable(yakklCurrentlySelected);const yakklContactsStore=writable(yakklContacts);const yakklChatsStore=writable(yakklChats);const yakklAccountsStore=writable(yakklAccounts);const yakklPrimaryAccountsStore=writable(yakklPrimaryAccounts);const yakklWatchListStore=writable(yakklWatchList);const yakklBlockedListStore=writable(yakklBlockedList);const yakklConnectedDomainsStore=writable(void 0);const yakklMiscStore=writable(void 0);const yakklVeryStore=writable(void 0);const yakklVersionStore=writable(void 0);const yakklUserNameStore=writable(void 0);const yakklPricingStore=writable(void 0);const yakklGasTransStore=writable(void 0);const yakklContactStore=writable(void 0);const yakklAccountStore=writable(void 0);const yakklWalletProvidersStore=writable([]);const yakklWalletBlockchainsStore=writable([]);const yakklTokenDataStore=writable([]);const yakklTokenDataCustomStore=writable([]);const yakklCombinedTokenStore=writable([]);const yakklInstancesStore=writable([null,null,null,null]);const yakklGPTRunningStore=writable(false);const yakklGPTKeyStore=writable(void 0);const yakklConnectionStore=writable(true);const yakklDappConnectRequestStore=writable(null);const priceStore=writable(null);const sessionInitialized=writable(false);const activeTabBackgroundStore=writable(null);const activeTabUIStore=writable(null);const backgroundUIConnectedStore=writable(false);const wallet=writable(null);const yakklContractStore=writable({address:"",abi:"",functions:[]});const yakklContextTypeStore=writable(void 0);const yakklBookmarkedArticlesStore=writable([]);function resetStores(){try{setPreferencesStore(yakklPreferences);setSettingsStore(yakklSettings);setProfileStore(profile);setYakklCurrentlySelectedStore(yakklCurrentlySelected);setYakklWatchListStore(yakklWatchList);setYakklBlockedListStore(yakklBlockedList);setYakklContactsStore(yakklContacts);setYakklChatsStore(yakklChats);setYakklAccountsStore(yakklAccounts);setYakklPrimaryAccountsStore(yakklPrimaryAccounts);setYakklTokenDataStore([]);setYakklTokenDataCustomStore([]);setYakklCombinedTokenStore([]);setYakklWalletBlockchainsStore([]);setYakklWalletProvidersStore([]);setYakklConnectedDomainsStore([]);yakklMiscStore.set(void 0);yakklContextTypeStore.set(void 0);yakklVeryStore.set(void 0);yakklVersionStore.set(void 0);yakklUserNameStore.set(void 0);yakklPricingStore.set(void 0);yakklGasTransStore.set(void 0);yakklContactStore.set(void 0);yakklAccountStore.set(void 0);yakklWalletProvidersStore.set([]);yakklWalletBlockchainsStore.set([]);yakklTokenDataStore.set([]);yakklTokenDataCustomStore.set([]);yakklCombinedTokenStore.set([]);yakklInstancesStore.set([null,null,null,null]);yakklGPTRunningStore.set(false);yakklGPTKeyStore.set(void 0);yakklConnectionStore.set(true);yakklDappConnectRequestStore.set(null);wallet.set(null);yakklContractStore.set({address:"",abi:"",functions:[]});tokens.set([]);walletStore.set(null);priceStore.set(null)}catch(error){log$1.error(error);throw error}}function onError(e){log$1.error(e)}function storageChange(changes){try{if(changes.yakklPreferences){setPreferencesStore(changes.yakklPreferences.newValue)}if(changes.yakklSettings){setSettingsStore(changes.yakklSettings.newValue)}if(changes.profile){setProfileStore(changes.profile.newValue)}if(changes.yakklCurrentlySelected){setYakklCurrentlySelectedStore(changes.yakklCurrentlySelected.newValue)}if(changes.yakklWatchList){setYakklWatchListStore(changes.yakklWatchList.newValue)}if(changes.yakklAccounts){setYakklAccountsStore(changes.yakklAccounts.newValue)}if(changes.yakklPrimaryAccounts){setYakklPrimaryAccountsStore(changes.yakklPrimaryAccounts.newValue)}if(changes.yakklContacts){setYakklContactsStore(changes.yakklContacts.newValue)}if(changes.yakklChats){setYakklChatsStore(changes.yakklChats.newValue)}if(changes.yakklConnectedDomains){setYakklConnectedDomainsStore(changes.yakklConnectedDomains.newValue)}if(changes.yakklBlockedList){setYakklBlockedListStore(changes.yakklBlockedList.newValue)}}catch(error){log$1.error(error);throw error}}async function syncStorageToStore(){try{const[preferences,settings,profileLocal,yakklCurrentlySelectedLocal,yakklWatchList2,yakklBlockedList2,yakklAccounts2,yakklPrimaryAccounts2,yakklContacts2,yakklChats2,yakklTokenData,yakklTokenDataCustom,yakklConnectedDomains]=await Promise.all([getPreferences(),getSettings(),getProfile(),getYakklCurrentlySelected(),getYakklWatchList(),getYakklBlockedList(),getYakklAccounts(),getYakklPrimaryAccounts(),getYakklContacts(),getYakklChats(),getYakklTokenData(),getYakklTokenDataCustom(),getYakklConnectedDomains()]);setPreferencesStore(preferences??yakklPreferences);setSettingsStore(settings??yakklSettings);setProfileStore(profileLocal??profile);setYakklCurrentlySelectedStore(yakklCurrentlySelectedLocal??yakklCurrentlySelected);setYakklWatchListStore(yakklWatchList2);setYakklBlockedListStore(yakklBlockedList2);setYakklAccountsStore(yakklAccounts2);setYakklPrimaryAccountsStore(yakklPrimaryAccounts2);setYakklContactsStore(yakklContacts2);setYakklChatsStore(yakklChats2);setYakklTokenDataStore(yakklTokenData);setYakklTokenDataCustomStore(yakklTokenDataCustom);setYakklConnectedDomainsStore(yakklConnectedDomains)}catch(error){log$1.error("Error syncing stores:",false,error);throw error}}async function setSettings(settings){return await setSettingsStorage(settings)}function getYakklPreferenceStore(){const store=get(yakklPreferencesStore);return store}function getSettingsStore(){const store=get(yakklSettingsStore);return store}function getProfileStore(values){const store=get(profileStore);profileStore.set(values);return store}function getYakklCurrentlySelectedStore(){const store=get(yakklCurrentlySelectedStore);return store}function getYakklWatchListStore(){const store=get(yakklWatchListStore);return store}function getYakklBlockedListStore(){const store=get(yakklBlockedListStore);return store}function getYakklAccountsStore(){const store=get(yakklAccountsStore);return store}function getYakklPrimaryAccountsStore(){const store=get(yakklPrimaryAccountsStore);return store}function getYakklContactsStore(){const store=get(yakklContactsStore);return store}function getYakklTokenDataStore(){const store=get(yakklTokenDataStore);return store}function getYakklTokenDataCustomStore(){const store=get(yakklTokenDataCustomStore);return store}function getYakklCombinedTokenStore(){const store=get(yakklCombinedTokenStore);return store}function getYakklChatsStore(){const store=get(yakklChatsStore);return store}function getYakklWalletBlockchainsStore(){const store=get(yakklWalletBlockchainsStore);return store}function getYakklWalletProvidersStore(){const store=get(yakklWalletProvidersStore);return store}function getYakklConnectedDomainsStore(){const store=get(yakklConnectedDomainsStore);return store}function getYakklContractStore(){return get(yakklContractStore)}function getMiscStore(){const store=get(yakklMiscStore);return store}function getContextTypeStore(){const store=get(yakklContextTypeStore);return store}function getVeryStore(){const store=get(yakklVeryStore);return store}function getDappConnectRequestStore(){const store=get(yakklDappConnectRequestStore);return store}function getContactStore(){const store=get(yakklContactStore);return store}function getAccountStore(){const store=get(yakklAccountStore);return store}function getVersionStore(){const store=get(yakklVersionStore);return store}function getUserNameStore(){const store=get(yakklUserNameStore);return store}function getYakklGPTKeyStore(){const store=get(yakklGPTKeyStore);return store}function getYakklConnectionStore(){const store=get(yakklConnectionStore);return store}function getYakklInstancesStore(){const store=get(yakklInstancesStore);return store}function setPreferencesStore(values){const store=get(yakklPreferencesStore);yakklPreferencesStore.set(values===null?yakklPreferences:values);return store}function setSettingsStore(values){const store=get(yakklSettingsStore);yakklSettingsStore.set(values===null?yakklSettings:values);return store}function setProfileStore(values){const store=get(profileStore);profileStore.set(values===null?profile:values);return store}function setYakklCurrentlySelectedStore(values){const store=get(yakklCurrentlySelectedStore);yakklCurrentlySelectedStore.set(values!==null?values:null);return store}function setYakklWatchListStore(values){const store=get(yakklWatchListStore);yakklWatchListStore.set(values);return store}function setYakklBlockedListStore(values){const store=get(yakklBlockedListStore);yakklBlockedListStore.set(values);return store}function setYakklContactsStore(values){const store=get(yakklContactsStore);yakklContactsStore.set(values);return store}function setYakklTokenDataStore(values){const store=get(yakklTokenDataStore);yakklTokenDataStore.set(values);return store}function setYakklTokenDataCustomStore(values){const store=get(yakklTokenDataCustomStore);yakklTokenDataCustomStore.set(values);return store}function setYakklCombinedTokenStore(values){const store=get(yakklCombinedTokenStore);yakklCombinedTokenStore.set(values);return store}function setYakklChatsStore(values){const store=get(yakklChatsStore);yakklChatsStore.set(values);return store}function setYakklWalletBlockchainsStore(values){const store=get(yakklWalletBlockchainsStore);yakklWalletBlockchainsStore.set(values);return store}function setYakklWalletProvidersStore(values){const store=get(yakklWalletProvidersStore);yakklWalletProvidersStore.set(values);return store}function setYakklConnectedDomainsStore(values){const store=get(yakklConnectedDomainsStore);yakklConnectedDomainsStore.set(values);return store}function setYakklAccountsStore(values){const store=get(yakklAccountsStore);yakklAccountsStore.set(values);return store}function setYakklPrimaryAccountsStore(values){const store=get(yakklPrimaryAccountsStore);yakklPrimaryAccountsStore.set(values);return store}function setMiscStore(values){const store=get(yakklMiscStore);yakklMiscStore.set(values);return store}function setContextTypeStore(values){const store=get(yakklContextTypeStore);yakklContextTypeStore.set(values);return store}function setVeryStore(values){const store=get(yakklVeryStore);yakklVeryStore.set(values);return store}function setDappConnectRequestStore(values){const store=get(yakklDappConnectRequestStore);yakklDappConnectRequestStore.set(values);return store}function setContactStore(values){const store=get(yakklContactStore);yakklContactStore.set(values);return store}function setAccountStore(values){const store=get(yakklAccountStore);yakklAccountStore.set(values);return store}function setVersionStore(values){const store=get(yakklVersionStore);yakklVersionStore.set(values);return store}function setUserNameStore(values){const store=get(yakklUserNameStore);yakklUserNameStore.set(values);return store}function setYakklGPTKeyStore(values){const store=get(yakklGPTKeyStore);yakklGPTKeyStore.set(values);return store}function setYakklConnectionStore(values){const store=get(yakklConnectionStore);yakklConnectionStore.set(values);return store}function setYakklContractStore(values){const store=get(yakklContractStore);yakklContractStore.set(values);return store}function setYakklInstancesStore(values){const store=get(yakklInstancesStore);yakklInstancesStore.set(values);return store}async function getYakklRegisteredData(id,persona){try{const value=await getObjectFromLocalStorage(STORAGE_YAKKL_REGISTERED_DATA);if(typeof value==="string"){throw new Error("Unexpected string value received from local storage")}if(id&&persona){}return value||null}catch(error){log$1.error("Error in getYakklRegisteredData:",false,error);throw error}}async function getYakklContacts(id,persona){try{const value=await getObjectFromLocalStorage(STORAGE_YAKKL_CONTACTS);if(typeof value==="string"){throw new Error("Unexpected string value received from local storage")}if(id&&persona){}return value||[]}catch(error){log$1.error("Error in getYakklContacts:",false,error);throw error}}async function getYakklTokenData(id,persona){try{const value=await getObjectFromLocalStorage(STORAGE_YAKKL_TOKENDATA);if(typeof value==="string"){throw new Error("Unexpected string value received from local storage")}if(id&&persona){}if(value)setYakklTokenDataStore(value);return value||[]}catch(error){log$1.error("Error in getYakklTokenData:",false,error);throw error}}async function getYakklTokenDataCustom(id,persona){try{const value=await getObjectFromLocalStorage(STORAGE_YAKKL_TOKENDATA_CUSTOM);if(typeof value==="string"){throw new Error("Unexpected string value received from local storage")}if(id&&persona){}if(value)setYakklTokenDataCustomStore(value);return value||[]}catch(error){log$1.error("Error in getYakklTokenDataCustom:",false,error);throw error}}async function getYakklCombinedToken(id,persona){try{const value=await getObjectFromLocalStorage(STORAGE_YAKKL_COMBINED_TOKENS);if(typeof value==="string"){throw new Error("Unexpected string value received from local storage")}if(id&&persona){}if(value)setYakklCombinedTokenStore(value);return value||[]}catch(error){log$1.error("Error in getYakklCombinedToken:",false,error);throw error}}async function getYakklChats(id,persona){try{let value=await getObjectFromLocalStorage(STORAGE_YAKKL_CHATS);if(typeof value==="string"){value=[];setYakklChatsStorage(value)}if(id&&persona){}if(value&&typeof value==="object"&&!Array.isArray(value)){value=Object.values(value)}return value||[]}catch(error){log$1.error("Error in getYakklChats:",false,error);return[]}}async function getYakklWalletBlockchains(){try{let value=await getObjectFromLocalStorage(STORAGE_YAKKL_WALLET_BLOCKCHAINS);if(typeof value==="string"){value=[];setYakklWalletBlockchainsStorage(value)}return value||[]}catch(error){log$1.error("Error in getYakklWalletBlockchains:",false,error);throw error}}async function getYakklWalletProviders(){try{let value=await getObjectFromLocalStorage(STORAGE_YAKKL_WALLET_PROVIDERS);if(typeof value==="string"){value=[];setYakklWalletProvidersStorage(value)}return value||[]}catch(error){log$1.error("Error in getYakklWalletProviders:",false,error);throw error}}async function getYakklConnectedDomains(id,persona){try{const value=await getObjectFromLocalStorage(STORAGE_YAKKL_CONNECTED_DOMAINS);log$1.info("getYakklConnectedDomains - value:",false,value);if(typeof value==="string"){throw new Error("Unexpected string value received from local storage")}if(id&&persona){return value.filter(d=>d.id===id&&d.persona===persona)||[]}return value||[]}catch(error){log$1.error("Error in getYakklConnectedDomains:",false,error);throw error}}async function getPreferences(id,persona){try{const value=await getObjectFromLocalStorage(STORAGE_YAKKL_PREFERENCES);if(typeof value==="string"){throw new Error("Unexpected string value received from local storage")}if(id&&persona){}return value}catch(error){log$1.error("Error in getPreferences:",false,error);throw error}}async function getSettings(id,persona){try{const value=await getObjectFromLocalStorage(STORAGE_YAKKL_SETTINGS);if(typeof value==="string"){throw new Error("Unexpected string value received from local storage")}if(id&&persona){}return value}catch(error){log$1.error("Error in getSettings:",false,error);throw error}}async function getProfile(id,persona){try{const value=await getObjectFromLocalStorage(STORAGE_YAKKL_PROFILE);if(typeof value==="string"){throw new Error("Unexpected string value received from local storage")}if(id&&persona){}return value}catch(error){log$1.error("Error in getProfile:",false,error);throw error}}async function getYakklCurrentlySelected(id,persona){try{const value=await getObjectFromLocalStorage(STORAGE_YAKKL_CURRENTLY_SELECTED);if(id&&persona){}if(!value||typeof value==="string"){log$1.warn("No currently selected Yakkl found, using defaults",false,value);return{id:"",shortcuts:{quantity:0n,accountType:AccountTypeCategory.PRIMARY,accountName:"YAKKL_ZERO_ACCOUNT",smartContract:false,address:"",alias:"",primary:null,init:false,legal:false,isLocked:true,showTestNetworks:false,profile:{userName:"",name:null,email:""},gasLimit:21e3,networks:[{blockchain:"Ethereum",name:"Mainnet",chainId:1,symbol:"ETH",type:NetworkType.MAINNET,explorer:"https://etherscan.io",decimals:18}],network:{blockchain:"Ethereum",name:"Mainnet",chainId:1,symbol:"ETH",type:NetworkType.MAINNET,explorer:"https://etherscan.io",decimals:18},blockchain:"Ethereum",type:NetworkType.MAINNET,chainId:1,symbol:"ETH",explorer:"https://etherscan.io"},preferences:{locale:"en_US",currency:{code:"USD",symbol:"$"}},data:{},version:"1.0.0",createDate:(new Date).toISOString(),updateDate:(new Date).toISOString()}}return value}catch(error){log$1.error("Error in getYakklCurrentlySelected:",false,error);throw error}}async function getYakklWatchList(id,persona){try{const value=await getObjectFromLocalStorage(STORAGE_YAKKL_WATCHLIST);if(typeof value==="string"){throw new Error("Unexpected string value received from local storage")}if(id&&persona){}return value||[]}catch(error){log$1.error("Error in getYakklWatchList:",false,error);throw error}}async function getYakklBlockedList(id,persona){try{const value=await getObjectFromLocalStorage(STORAGE_YAKKL_BLOCKEDLIST);if(typeof value==="string"){throw new Error("Unexpected string value received from local storage")}if(id&&persona){}return value||[]}catch(error){log$1.error("Error in getYakklBlockedList:",false,error);throw error}}async function getYakklAccounts(id,persona){try{const value=await getObjectFromLocalStorage(STORAGE_YAKKL_ACCOUNTS);if(typeof value==="string"){throw new Error("Unexpected string value received from local storage")}if(id&&persona){}return value||[]}catch(error){log$1.error("Error in getYakklAccounts:",false,error);throw error}}async function getYakklPrimaryAccounts(id,persona){try{const value=await getObjectFromLocalStorage(STORAGE_YAKKL_PRIMARY_ACCOUNTS);if(typeof value==="string"){throw new Error("Unexpected string value received from local storage")}if(id&&persona){}return value||[]}catch(error){log$1.error("Error in getYakklPrimaryAccounts:",false,error);throw error}}async function setYakklContactsStorage(values){try{yakklContactsStore.set(values);await setObjectInLocalStorage("yakklContacts",values)}catch(error){log$1.error("Error in setYakklContactsStorage:",false,error);throw error}}async function setYakklTokenDataStorage(values){try{yakklTokenDataStore.set(values);await setObjectInLocalStorage("yakklTokenData",values)}catch(error){log$1.error("Error in setYakklTokenDataStorage:",false,error);throw error}}async function setYakklTokenDataCustomStorage(values){try{yakklTokenDataCustomStore.set(values);await setObjectInLocalStorage("yakklTokenDataCustom",values)}catch(error){log$1.error("Error in setYakklTokenDataCustomStorage:",false,error);throw error}}async function setYakklCombinedTokenStorage(values){try{yakklCombinedTokenStore.set(values);await setObjectInLocalStorage("yakklCombinedTokens",values)}catch(error){log$1.error("Error in setYakklCombinedTokenStorage:",false,error);throw error}}async function setYakklChatsStorage(values){try{yakklChatsStore.set(values);await setObjectInLocalStorage("yakklChats",values)}catch(error){log$1.error("Error in setYakklChatsStorage:",false,error);throw error}}async function setYakklWalletBlockchainsStorage(values){try{yakklWalletBlockchainsStore.set(values);await setObjectInLocalStorage("yakklWalletBlockchains",values)}catch(error){log$1.error("Error in setYakklWalletBlockchainsStorage:",false,error);throw error}}async function setYakklWalletProvidersStorage(values){try{yakklWalletProvidersStore.set(values);await setObjectInLocalStorage("yakklWalletProviders",values)}catch(error){log$1.error("Error in setYakklWalletProvidersStorage:",false,error);throw error}}async function setYakklConnectedDomainsStorage(values){try{const current=get(yakklConnectedDomainsStore);if(!isEqual(current,values)){yakklConnectedDomainsStore.set(values);await setObjectInLocalStorage("yakklConnectedDomains",values)}}catch(error){log$1.error("Error in setYakklConnectedDomainsStorage:",false,error);throw error}}async function setSettingsStorage(values){try{yakklSettingsStore.set(values);await setObjectInLocalStorage("settings",values)}catch(error){log$1.error("Error in setSettingsStorage:",false,error);throw new Error("Error in setSettingsStorage: false",error)}}async function setPreferencesStorage(values){try{yakklPreferencesStore.set(values);await setObjectInLocalStorage("preferences",values)}catch(error){log$1.error("Error in setPreferencesStorage:",false,error);throw new Error("Error in setPreferencesStorage: false",error)}}async function setProfileStorage(values){try{profileStore.set(values);await setObjectInLocalStorage("profile",values)}catch(error){log$1.error("Error in setProfileStorage:",false,error);throw new Error("Error in setProfileStorage: false",error)}}async function setYakklCurrentlySelectedStorage(values){try{if(values.shortcuts.address.trim().length===0||values.shortcuts.accountName.trim().length===0){throw new Error("Attempting to save yakklCurrentlySelected with no address or no account name. Select a default account and retry.")}const newValues=await verifyEncryption(values);setYakklCurrentlySelectedStore(newValues);await setObjectInLocalStorage("yakklCurrentlySelected",newValues)}catch(error){log$1.error("Error in setYakklCurrentlySelectedStorage:",false,error);throw error}}async function setYakklWatchListStorage(values){try{yakklWatchListStore.set(values);await setObjectInLocalStorage("yakklWatchList",values)}catch(error){log$1.error("Error in setYakklWatchListStorage:",false,error);throw error}}async function setYakklBlockedListStorage(values){try{yakklBlockedListStore.set(values);await setObjectInLocalStorage("yakklBlockedList",values)}catch(error){log$1.error("Error in setYakklBlockedListStorage:",false,error);throw error}}async function setYakklAccountsStorage(values){try{const newValues=await verifyEncryption(values);yakklAccountsStore.set(newValues);await setObjectInLocalStorage("yakklAccounts",newValues)}catch(error){log$1.error("Error in setYakklAccountsStorage:",false,error);throw error}}async function setYakklPrimaryAccountsStorage(values){try{const newValues=await verifyEncryption(values);yakklPrimaryAccountsStore.set(newValues);await setObjectInLocalStorage("yakklPrimaryAccounts",newValues)}catch(error){log$1.error("Error in setYakklPrimaryAccountsStorage:",false,error);throw error}}async function updateYakklTokenData(updater){try{const currentData=get(yakklTokenDataStore);const updatedData=currentData.map(token=>updater(token));yakklTokenDataStore.set(updatedData);await setObjectInLocalStorage("yakklTokenData",updatedData)}catch(error){log$1.error("Error updating token data:",false,error);throw error}}async function updateYakklTokenDataCustom(updater){try{const currentData=get(yakklTokenDataCustomStore);const updatedData=currentData.map(token=>updater(token));yakklTokenDataCustomStore.set(updatedData);await setObjectInLocalStorage("yakklTokenDataCustom",updatedData)}catch(error){log$1.error("Error updating custom token data:",false,error);throw error}}function updateCombinedTokenStore(){const combinedTokens=[...get(yakklTokenDataStore),...get(yakklTokenDataCustomStore)];yakklCombinedTokenStore.set(combinedTokens)}async function getYakklBookmarkedArticles(){try{const result=await getObjectFromLocalStorage("yakklBookmarkedArticles");const articles=result||[];yakklBookmarkedArticlesStore.set(articles);return articles}catch(error){console.error("Error getting bookmarked articles:",error);return[]}}async function setYakklBookmarkedArticles(articles){try{await setObjectInLocalStorage("yakklBookmarkedArticles",articles);yakklBookmarkedArticlesStore.set(articles)}catch(error){console.error("Error setting bookmarked articles:",error)}}getYakklBookmarkedArticles().then(articles=>{yakklBookmarkedArticlesStore.set(articles)});const stores=Object.freeze(Object.defineProperty({__proto__:null,activeTabBackgroundStore:activeTabBackgroundStore,activeTabUIStore:activeTabUIStore,alert:alert,backgroundUIConnectedStore:backgroundUIConnectedStore,getAccountStore:getAccountStore,getContactStore:getContactStore,getContextTypeStore:getContextTypeStore,getDappConnectRequestStore:getDappConnectRequestStore,getMiscStore:getMiscStore,getPreferences:getPreferences,getProfile:getProfile,getProfileStore:getProfileStore,getSettings:getSettings,getSettingsStore:getSettingsStore,getUserNameStore:getUserNameStore,getVersionStore:getVersionStore,getVeryStore:getVeryStore,getYakklAccounts:getYakklAccounts,getYakklAccountsStore:getYakklAccountsStore,getYakklBlockedList:getYakklBlockedList,getYakklBlockedListStore:getYakklBlockedListStore,getYakklBookmarkedArticles:getYakklBookmarkedArticles,getYakklChats:getYakklChats,getYakklChatsStore:getYakklChatsStore,getYakklCombinedToken:getYakklCombinedToken,getYakklCombinedTokenStore:getYakklCombinedTokenStore,getYakklConnectedDomains:getYakklConnectedDomains,getYakklConnectedDomainsStore:getYakklConnectedDomainsStore,getYakklConnectionStore:getYakklConnectionStore,getYakklContacts:getYakklContacts,getYakklContactsStore:getYakklContactsStore,getYakklContractStore:getYakklContractStore,getYakklCurrentlySelected:getYakklCurrentlySelected,getYakklCurrentlySelectedStore:getYakklCurrentlySelectedStore,getYakklGPTKeyStore:getYakklGPTKeyStore,getYakklInstancesStore:getYakklInstancesStore,getYakklPreferenceStore:getYakklPreferenceStore,getYakklPrimaryAccounts:getYakklPrimaryAccounts,getYakklPrimaryAccountsStore:getYakklPrimaryAccountsStore,getYakklRegisteredData:getYakklRegisteredData,getYakklTokenData:getYakklTokenData,getYakklTokenDataCustom:getYakklTokenDataCustom,getYakklTokenDataCustomStore:getYakklTokenDataCustomStore,getYakklTokenDataStore:getYakklTokenDataStore,getYakklWalletBlockchains:getYakklWalletBlockchains,getYakklWalletBlockchainsStore:getYakklWalletBlockchainsStore,getYakklWalletProviders:getYakklWalletProviders,getYakklWalletProvidersStore:getYakklWalletProvidersStore,getYakklWatchList:getYakklWatchList,getYakklWatchListStore:getYakklWatchListStore,loadCheckCurrentlySelectedStore:loadCheckCurrentlySelectedStore,onError:onError,prerender:prerender,priceStore:priceStore,profileStore:profileStore,resetStores:resetStores,sessionInitialized:sessionInitialized,setAccountStore:setAccountStore,setContactStore:setContactStore,setContextTypeStore:setContextTypeStore,setDappConnectRequestStore:setDappConnectRequestStore,setMiscStore:setMiscStore,setPreferencesStorage:setPreferencesStorage,setPreferencesStore:setPreferencesStore,setProfileStorage:setProfileStorage,setProfileStore:setProfileStore,setSettings:setSettings,setSettingsStorage:setSettingsStorage,setSettingsStore:setSettingsStore,setUserNameStore:setUserNameStore,setVersionStore:setVersionStore,setVeryStore:setVeryStore,setYakklAccountsStorage:setYakklAccountsStorage,setYakklAccountsStore:setYakklAccountsStore,setYakklBlockedListStorage:setYakklBlockedListStorage,setYakklBlockedListStore:setYakklBlockedListStore,setYakklBookmarkedArticles:setYakklBookmarkedArticles,setYakklChatsStorage:setYakklChatsStorage,setYakklChatsStore:setYakklChatsStore,setYakklCombinedTokenStorage:setYakklCombinedTokenStorage,setYakklCombinedTokenStore:setYakklCombinedTokenStore,setYakklConnectedDomainsStorage:setYakklConnectedDomainsStorage,setYakklConnectedDomainsStore:setYakklConnectedDomainsStore,setYakklConnectionStore:setYakklConnectionStore,setYakklContactsStorage:setYakklContactsStorage,setYakklContactsStore:setYakklContactsStore,setYakklContractStore:setYakklContractStore,setYakklCurrentlySelectedStorage:setYakklCurrentlySelectedStorage,setYakklCurrentlySelectedStore:setYakklCurrentlySelectedStore,setYakklGPTKeyStore:setYakklGPTKeyStore,setYakklInstancesStore:setYakklInstancesStore,setYakklPrimaryAccountsStorage:setYakklPrimaryAccountsStorage,setYakklPrimaryAccountsStore:setYakklPrimaryAccountsStore,setYakklTokenDataCustomStorage:setYakklTokenDataCustomStorage,setYakklTokenDataCustomStore:setYakklTokenDataCustomStore,setYakklTokenDataStorage:setYakklTokenDataStorage,setYakklTokenDataStore:setYakklTokenDataStore,setYakklWalletBlockchainsStorage:setYakklWalletBlockchainsStorage,setYakklWalletBlockchainsStore:setYakklWalletBlockchainsStore,setYakklWalletProvidersStorage:setYakklWalletProvidersStorage,setYakklWalletProvidersStore:setYakklWalletProvidersStore,setYakklWatchListStorage:setYakklWatchListStorage,setYakklWatchListStore:setYakklWatchListStore,storageChange:storageChange,syncStorageToStore:syncStorageToStore,updateCombinedTokenStore:updateCombinedTokenStore,updateYakklTokenData:updateYakklTokenData,updateYakklTokenDataCustom:updateYakklTokenDataCustom,verifyEncryption:verifyEncryption,wallet:wallet,yakklAccountStore:yakklAccountStore,yakklAccountsStore:yakklAccountsStore,yakklBlockedListStore:yakklBlockedListStore,yakklBookmarkedArticlesStore:yakklBookmarkedArticlesStore,yakklChatsStore:yakklChatsStore,yakklCombinedTokenStore:yakklCombinedTokenStore,yakklConnectedDomainsStore:yakklConnectedDomainsStore,yakklConnectionStore:yakklConnectionStore,yakklContactStore:yakklContactStore,yakklContactsStore:yakklContactsStore,yakklContextTypeStore:yakklContextTypeStore,yakklContractStore:yakklContractStore,yakklCurrentlySelectedStore:yakklCurrentlySelectedStore,yakklDappConnectRequestStore:yakklDappConnectRequestStore,yakklGPTKeyStore:yakklGPTKeyStore,yakklGPTRunningStore:yakklGPTRunningStore,yakklGasTransStore:yakklGasTransStore,yakklInstancesStore:yakklInstancesStore,yakklMiscStore:yakklMiscStore,yakklPreferencesStore:yakklPreferencesStore,yakklPricingStore:yakklPricingStore,yakklPrimaryAccountsStore:yakklPrimaryAccountsStore,yakklSettingsStore:yakklSettingsStore,yakklTokenDataCustomStore:yakklTokenDataCustomStore,yakklTokenDataStore:yakklTokenDataStore,yakklUserNameStore:yakklUserNameStore,yakklVersionStore:yakklVersionStore,yakklVeryStore:yakklVeryStore,yakklWalletBlockchainsStore:yakklWalletBlockchainsStore,yakklWalletProvidersStore:yakklWalletProvidersStore,yakklWatchListStore:yakklWatchListStore},Symbol.toStringTag,{value:"Module"}));let crypto;if(typeof window!=="undefined"&&window.crypto){crypto=window.crypto}else if(typeof global!=="undefined"&&global?.crypto){crypto=global.crypto}else if(typeof require!=="undefined"){crypto=require("crypto").webcrypto}else{throw new Error("No crypto support found")}function bufferToBase64(array){return Buffer.from(array).toString("base64")}function bufferForCrypto(base64){const binaryString=atob(base64);const bytes=new Uint8Array(binaryString.length);for(let i=0;i<binaryString.length;i++){bytes[i]=binaryString.charCodeAt(i)}return bytes.buffer}async function generateSalt(){const saltBuffer=crypto.getRandomValues(new Uint8Array(64));return bufferToBase64(saltBuffer)}async function digestMessage(message){const encoder=new TextEncoder;const data=encoder.encode(message);const hashBuffer=await crypto.subtle.digest("SHA-256",data);const hashArray=Array.from(new Uint8Array(hashBuffer));const hashHex=hashArray.map(b=>b.toString(16).padStart(2,"0")).join("");return hashHex}async function deriveKeyFromPassword(password,existingSalt){const salt=existingSalt||await generateSalt();const encoder=new TextEncoder;const derivationKey=await crypto.subtle.importKey("raw",encoder.encode(password),{name:"PBKDF2"},false,["deriveKey"]);const key=await crypto.subtle.deriveKey({name:"PBKDF2",salt:encoder.encode(salt),iterations:1e6,hash:"SHA-256"},derivationKey,{name:"AES-GCM",length:256},false,["encrypt","decrypt"]);return{key:key,salt:salt}}function encodeJSON(obj){return JSON.stringify(obj,(_,value)=>{if(typeof value==="bigint"){return value.toString()}return value})}async function encryptData(data,passwordOrSaltedKey){try{if(!data){throw new Error("Missing data to encrypt")}if(!passwordOrSaltedKey){throw new Error("Missing password or key to encrypt data")}const{key:key,salt:salt}=typeof passwordOrSaltedKey==="string"?await deriveKeyFromPassword(passwordOrSaltedKey):passwordOrSaltedKey;const encoder=new TextEncoder;const iv=crypto.getRandomValues(new Uint8Array(16));const encodedData=encoder.encode(encodeJSON(data));const cipherData=await crypto.subtle.encrypt({name:"AES-GCM",iv:iv},key,encodedData);return{data:bufferToBase64(new Uint8Array(cipherData)),iv:bufferToBase64(iv),salt:salt}}catch(error){log$1.error("Error encrypting data:",false,error);throw error}}async function decryptData(encryptedData,passwordOrSaltedKey){try{if(!passwordOrSaltedKey){throw new Error("Missing password or key to decrypt data")}const{data:data,iv:iv,salt:salt}=encryptedData;const{key:key}=typeof passwordOrSaltedKey==="string"?await deriveKeyFromPassword(passwordOrSaltedKey,salt):passwordOrSaltedKey;const plaintext=await crypto.subtle.decrypt({name:"AES-GCM",iv:bufferForCrypto(iv)},key,bufferForCrypto(data));const txtDecoder=(new TextDecoder).decode(plaintext);return JSON.parse(txtDecoder)}catch(error){log$1.error("Error decrypting data:",false,error);throw error}}export{encodeJSON$1 as $,AccessSourceType as A,BigNumber as B,STORAGE_YAKKL_CURRENTLY_SELECTED as C,DEFAULT_POPUP_HEIGHT as D,EthereumBigNumber as E,PATH_WELCOME as F,yakklTokenDataCustomStore as G,yakklTokenDataStore as H,yakklCombinedTokenStore as I,yakklVersionStore as J,digestMessage as K,profile as L,PromoClassificationType as M,NUM_OF_SPLASH_IMAGES as N,YAKKL_ZERO_ACCOUNT_NAME as O,PlanType as P,YAKKL_ZERO_ADDRESS as Q,encryptData as R,STORAGE_YAKKL_SETTINGS as S,TIMER_GAS_PRICE_CHECK as T,setProfileStorage as U,VERSION as V,setYakklCurrentlySelectedStorage as W,setPreferencesStorage as X,YEAR as Y,setSettingsStorage as Z,DEFAULT_TITLE as _,DEFAULT_POPUP_WIDTH as a,setYakklBookmarkedArticles as a$,TIMELINES as a0,YAKKL_FEE_BASIS_POINTS_DIVISOR as a1,getMiscStore as a2,getYakklCurrentlySelected as a3,DEFAULT_DERIVED_PATH_ETH as a4,AccountTypeCategory as a5,setYakklPrimaryAccountsStorage as a6,NetworkType as a7,setSettings as a8,setYakklAccountsStorage as a9,setYakklTokenDataStorage as aA,setYakklCombinedTokenStorage as aB,yakklWalletProvidersStore as aC,setYakklWalletProvidersStorage as aD,yakklWalletBlockchainsStore as aE,setYakklWalletBlockchainsStorage as aF,yakklAccount as aG,getYakklWatchList as aH,CoinbasePriceProvider as aI,TIMER_TOKEN_PRICE_CYCLE_TIME as aJ,YAKKL_DAPP as aK,FOUNDING_MEMBER_DEADLINE as aL,EARLY_ADOPTER_DEADLINES as aM,TIMER_PRICE_INTERVAL_TIME as aN,priceStore as aO,formatDate as aP,SystemTheme as aQ,sortedTokens as aR,toBigInt as aS,safeConvertToBigInt as aT,YAKKL_FEE_BASIS_POINTS as aU,ETH_BASE_SWAP_GAS_UNITS as aV,getYakklGPTKeyStore as aW,yakklGPTRunningStore as aX,formatTimestamp as aY,yakklPricingStore as aZ,yakklBookmarkedArticlesStore as a_,isProfileData as aa,isMetaData as ab,isString as ac,DEFAULT_PERSONA as ad,yakklRegisteredData as ae,setYakklContactsStorage as af,setYakklTokenDataCustomStorage as ag,resetStores as ah,YAKKL_INTERNAL as ai,MessageType as aj,activeTabUIStore as ak,STORAGE_YAKKL_CONNECTED_DOMAINS as al,STORAGE_YAKKL_ACCOUNTS as am,setYakklConnectedDomainsStorage as an,yakklPreferencesStore as ao,profileStore as ap,yakklContactsStore as aq,yakklChatsStore as ar,setYakklChatsStorage as as,yakklAccountsStore as at,yakklPrimaryAccountsStore as au,yakklWatchListStore as av,setYakklWatchListStorage as aw,yakklBlockedListStore as ax,setYakklBlockedListStorage as ay,yakklConnectedDomainsStore as az,yakklDappConnectRequestStore as b,PATH_ACCOUNTS as b0,PATH_SECURITY as b1,loggerWrapper as b2,stores as b3,getYakklPrimaryAccounts as c,getSettings as d,PRO_ELIGIBLE_PROMO_TYPES as e,getContextTypeStore as f,getYakklAccounts as g,PATH_LOGOUT as h,isEncryptedData as i,decryptData as j,yakklMiscStore as k,log as l,yakklCurrentlySelectedStore as m,yakklConnectionStore as n,getProfile as o,EOA_FALLBACK_GAS as p,parseJsonRpcError as q,Ethereum as r,syncStorageToStore as s,toHex as t,setMiscStore as u,getObjectFromLocalStorage as v,dateString as w,setObjectInLocalStorage as x,yakklUserNameStore as y,yakklSettingsStore as z};
//# sourceMappingURL=encryption.js.map
