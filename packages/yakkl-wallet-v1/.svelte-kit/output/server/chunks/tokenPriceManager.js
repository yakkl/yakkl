import{w as writable,g as get}from"./index.js";import{aI as CoinbasePriceProvider,aJ as TIMER_TOKEN_PRICE_CYCLE_TIME,I as yakklCombinedTokenStore,aB as setYakklCombinedTokenStorage}from"./encryption.js";import{l as log}from"./Logger.js";import{fetchJson}from"@ethersproject/web";import"./environment.js";import"./utils.js";import"./UnifiedTimerManager.js";import{splitWords}from"./utilities.js";import"./gas.js";import"ethereum-blockies-base64";import{T as TimerManager}from"./TimerManager.js";class CoingeckoPriceProvider{getAPIKey(){return"CG-NXan3dhsnvnZG8NJrFjFAMDw"}getName(){return"Coingecko"}async getMarketPrice(pair){try{if(!pair){return{provider:this.getName(),price:0,lastUpdated:new Date,status:404,message:`Invalid pair - ${pair}`}}const[name,currencySymbol]=await this.getProviderPairFormat(pair);if(!name||!currencySymbol){return{provider:this.getName(),price:0,lastUpdated:new Date,status:404,message:`Invalid pair - ${pair}`}}const json=await fetchJson({url:`https://pro-api.coingecko.com/api/v3/simple/price?ids=${name}&include_last_updated_at=true&vs_currencies=${currencySymbol}`,headers:{Accept:"application/json","x-cg-pro-api-key":this.getAPIKey()}});const priceData=json[name.toLowerCase()];if(!priceData||!priceData[currencySymbol.toLowerCase()]){throw new Error("Invalid JSON structure or missing data from Coingecko")}return{provider:this.getName(),price:parseFloat(priceData[currencySymbol.toLowerCase()]),lastUpdated:new Date(priceData.last_updated_at*1e3),currency:currencySymbol,status:0,message:"Success"}}catch(e){log.error("CoingeckoPriceProvider - getPrice - error",e);let status=404;let message=`Error - ${e}`;if(e.response&&e.response.status===429){status=429;message="Too Many Requests - Rate limit exceeded"}return{provider:this.getName(),price:0,lastUpdated:new Date,status:status,message:message}}}async getProviderPairFormat(pair){let name="";const[symbol,currencySymbol]=splitWords(pair,"-");if(!symbol||!currencySymbol){return["",""]}switch(symbol){case"ETH":case"WETH":name="ethereum";break;case"BTC":name="bitcoin";break;case"USDC":name="usd-coin";break;case"DAI":name="dai";break;case"USDT":name="tether";break;case"BUSD":name="binance-usd";break;case"WBTC":name="wrapped-bitcoin";break;case"SOL":name="solana";break;case"MATIC":name="matic-network";break;case"BNB":name="binance-coin";break;case"AVAX":name="avalanche-2";break;default:name=symbol.toLowerCase();break}return[name,currencySymbol]}}class PriceManager{weightedProviders;totalWeight;DEFAULT_WEIGHT=1;constructor(weightedProviders=PriceManager.getDefaultProviders()){if(!weightedProviders||weightedProviders.length===0){throw new Error("At least one provider must be specified")}this.weightedProviders=this.normalizeWeights(weightedProviders);this.totalWeight=this.calculateTotalWeight()}static getDefaultProviders(){return[{provider:new CoinbasePriceProvider,weight:8},{provider:new CoingeckoPriceProvider,weight:5}]}normalizeWeights(providers){const allZeroWeights=providers.every(wp=>wp.weight===0);const allEqualWeights=providers.every(wp=>wp.weight===providers[0].weight);if(allZeroWeights||allEqualWeights){return providers.map(wp=>({...wp,weight:this.DEFAULT_WEIGHT}))}const smallestNonZeroWeight=Math.min(...providers.filter(wp=>wp.weight>0).map(wp=>wp.weight));return providers.map(wp=>({...wp,weight:wp.weight===0?smallestNonZeroWeight:wp.weight}))}calculateTotalWeight(){return this.weightedProviders.reduce((sum,wp)=>sum+wp.weight,0)}getAvailableProviders(){return this.weightedProviders.map(wp=>wp.provider)}async getMarketPrice(pair,availableProviders){let provider=null;let providersToUse=[];try{providersToUse=availableProviders||this.getAvailableProviders();if(providersToUse.length===0){throw new Error("No providers available to fetch market price")}provider=this.getWeightedRandomProvider(providersToUse);const price=await provider.getMarketPrice(pair);return price}catch(error){log.error(`Error fetching price from ${provider.getName()}:`,false,error);return this.getMarketPrice(pair,providersToUse.filter(p=>p!==provider))}}getWeightedRandomProvider(providers){if(!providers||providers.length===0){log.error("No providers available to fetch market price");throw new Error("No providers available to fetch market price")}if(providers.length===1){return providers[0]}try{const weightedProviders=this.weightedProviders.filter(wp=>providers.includes(wp.provider));const totalWeight=weightedProviders.reduce((sum,wp)=>sum+wp.weight,0);if(weightedProviders.every(wp=>wp.weight===weightedProviders[0].weight)){return weightedProviders[Math.floor(Math.random()*weightedProviders.length)].provider}let random=Math.random()*totalWeight;for(const wp of weightedProviders){if(random<wp.weight){return wp.provider}random-=wp.weight}return weightedProviders[0].provider}catch(error){log.error("Error selecting weighted random provider:",false,error);throw error}}}function createPriceUpdater(priceManager2){const tokens=writable([]);const{subscribe:subscribe,set:set}=tokens;async function fetchPrices(tokensArray){const BATCH_SIZE=8;const updatedTokens=[];if(!tokensArray||tokensArray.length===0){log.error("fetchPrices - No tokens to process. Exiting early.");return[]}for(let i=0;i<tokensArray.length;i+=BATCH_SIZE){const batch=tokensArray.slice(i,i+BATCH_SIZE);try{const batchResults=await Promise.all(batch.map(async token=>fetchTokenData(token,priceManager2)));updatedTokens.push(...batchResults)}catch(error){log.error("fetchPrices - Error processing batch:",false,batch,false,error)}}return updatedTokens}async function fetchTokenData(token,priceManager22){const pair=`${token.symbol}-USD`;try{const marketPrice=await priceManager22.getMarketPrice(pair);const price=marketPrice?.price??0;const adjustedBalance=token.balance?Number(token.balance)/10**token.decimals:0;const value=adjustedBalance*price;return{...token,price:{price:price,provider:marketPrice?.provider??"",lastUpdated:new Date},value:value,formattedValue:new Intl.NumberFormat("en-US",{style:"currency",currency:"USD"}).format(value)}}catch(error){log.error(`fetchTokenData - Failed to fetch price for ${token.symbol}`,false,error);return{...token,price:{price:0,provider:"",lastUpdated:new Date},value:0}}}return{subscribe:subscribe,fetchPrices:fetchPrices}}let priceManager=null;let priceUpdater=null;const fetchingActive=writable(false);async function updateTokenPrices(){if(get(fetchingActive))return;fetchingActive.set(true);try{log.info("updateTokenPrices: Starting price update");const tokens=get(yakklCombinedTokenStore);if(tokens.length===0){log.info("updateTokenPrices: No tokens to update");return}const updatedTokens=await priceUpdater.fetchPrices(tokens);if(!updatedTokens||updatedTokens.length===0){log.warn("updateTokenPrices: Fetched prices returned empty.");return}yakklCombinedTokenStore.update(()=>updatedTokens);await setYakklCombinedTokenStorage(updatedTokens);const{balanceCacheManager:balanceCacheManager}=await import("./BalanceCacheManager.js");const ethToken=updatedTokens.find(token=>token.isNative&&token.symbol==="ETH");if(ethToken&&ethToken.value&&ethToken.value>0){balanceCacheManager.updatePriceForAllEntries(ethToken.value);log.debug("[updateTokenPrices] Updated cached entries with ETH price:",false,{newPrice:ethToken.value})}log.info("updateTokenPrices: Successfully updated and persisted token prices")}catch(error){log.error("updateTokenPrices: Failed to update token prices",false,error)}finally{fetchingActive.set(false)}}const timerManager=TimerManager.getInstance();if(!timerManager.hasTimer("tokenPriceUpdater")){log.info("Setting up token price updater timer");if(!priceManager){priceManager=new PriceManager}if(!priceUpdater){priceUpdater=createPriceUpdater(priceManager)}timerManager.addTimer("tokenPriceUpdater",async()=>{await updateTokenPrices()},TIMER_TOKEN_PRICE_CYCLE_TIME)}if(!timerManager.isRunning("tokenPriceUpdater")){log.info("Starting token price updater timer");timerManager.startTimer("tokenPriceUpdater")}export{CoingeckoPriceProvider as C,PriceManager as P,updateTokenPrices as u};
//# sourceMappingURL=tokenPriceManager.js.map
