import"vite-plugin-node-polyfills/shims/process";import{openDB}from"idb";import Dexie from"dexie";var LogLevel=(LogLevel2=>{LogLevel2[LogLevel2["DEBUG"]=0]="DEBUG";LogLevel2[LogLevel2["DEBUG_TRACE"]=1]="DEBUG_TRACE";LogLevel2[LogLevel2["INFO"]=2]="INFO";LogLevel2[LogLevel2["INFO_TRACE"]=3]="INFO_TRACE";LogLevel2[LogLevel2["WARN"]=4]="WARN";LogLevel2[LogLevel2["ERROR"]=5]="ERROR";LogLevel2[LogLevel2["ERROR_TRACE"]=6]="ERROR_TRACE";LogLevel2[LogLevel2["TRACE"]=7]="TRACE";return LogLevel2})(LogLevel||{});var LogLevelDirection=(LogLevelDirection2=>{LogLevelDirection2[LogLevelDirection2["NONE"]=0]="NONE";LogLevelDirection2[LogLevelDirection2["CONTAINS"]=1]="CONTAINS";LogLevelDirection2[LogLevelDirection2["LESSTHAN"]=2]="LESSTHAN";LogLevelDirection2[LogLevelDirection2["GREATERTHAN"]=3]="GREATERTHAN";LogLevelDirection2[LogLevelDirection2["EQUAL"]=4]="EQUAL";LogLevelDirection2[LogLevelDirection2["GREATERTHANOREQUAL"]=5]="GREATERTHANOREQUAL";LogLevelDirection2[LogLevelDirection2["LESSTHANOREQUAL"]=6]="LESSTHANOREQUAL";return LogLevelDirection2})(LogLevelDirection||{});const COLORS={DEBUG:"color: purple; font-weight: bold;",INFO:"color: green; font-weight: bold;",WARN:"color: orange; font-weight: bold;",ERROR:"color: red; font-weight: bold;",TRACE:"color: blue; font-weight: bold;"};const MAX_STORED_LOGS=500;const STORAGE_KEY="yakklLogs";class Logger{static instance=null;logLevel;logLevelDirection;logsIncluded=[];logRegEx=/^(DEBUG|DEBUG_TRACE|INFO|INFO_TRACE|WARN|ERROR|ERROR_TRACE|TRACE)$/;logFilterEnabled=false;stackIndex=4;backend="localStorage";minLogLevel=5;constructor(level=0,direction=2,logsIncluded=["DEBUG","DEBUG_TRACE","INFO","INFO_TRACE","WARN","ERROR","ERROR_TRACE","TRACE"]){this.logLevel=level;this.logLevelDirection=direction;this.logsIncluded=logsIncluded}static getInstance(){if(!Logger.instance){Logger.instance=new Logger}return Logger.instance}setMinimumLogLevel(level){this.minLogLevel=level}setLevel(level,direction,logsIncluded=["DEBUG","DEBUG_TRACE","INFO","INFO_TRACE","WARN","ERROR","ERROR_TRACE","TRACE"]){this.logLevel=LogLevel[level];this.logLevelDirection=LogLevelDirection[direction];this.logsIncluded=logsIncluded}setLogFilterEnabled(enabled){this.logFilterEnabled=enabled}setLogFilterRegex(pattern){try{this.logRegEx=new RegExp(pattern,"i")}catch(error){this.error("Invalid regex pattern:",false,error)}}setStackIndex(index){if(index<0)throw new Error("Stack index must be a positive number");this.stackIndex=index}setBackend(backendType){this.backend=backendType}getMinimumLogLevel(){return this.minLogLevel}getTimestamp(){return(new Date).toISOString()}getCallerInfo(){const stack=(new Error).stack;if(!stack)return"Unknown Caller";const stackLines=stack.split("\n").length;const adjustedIndex=Math.min(this.stackIndex,stackLines-1)??this.stackIndex;const callerLine=stack.split("\n")[adjustedIndex]?.trim();return callerLine||"Unknown Caller"}normalizeInput(input){if(input instanceof Error){return{message:input.message,stack:input.stack}}else if(typeof input==="string"){return{message:input}}else if(input===null||input===void 0){return{message:String(input)}}else{return{message:JSON.stringify(input,null,2)}}}persistLog(entry){try{switch(this.backend){case"indexedDB":this.persistLogIndexedDB(entry);break;case"dexie":this.persistLogDexie(entry);break;case"sqlite":this.persistLogSQLite(entry);break;case"background":this.persistLogBackground(entry);break;case"localStorage":default:this.persistLogLocalStorage(entry);break}}catch(error){this.error("Failed to persist log:",false,error)}}persistLogLocalStorage(log2){try{return;if(typeof localStorage!=="undefined"){const logs=JSON.parse(localStorage.getItem(STORAGE_KEY)||"[]");if(log2.args){log2.args=log2.args.map(arg=>{try{JSON.parse(JSON.stringify(arg));return arg}catch{return String(arg)}})}logs.push(log2);while(logs.length>MAX_STORED_LOGS){logs.shift()}localStorage.setItem(STORAGE_KEY,JSON.stringify(logs))}}catch(error){this.error("Failed to persist to localStorage:",error)}}persistLogIndexedDB(log2){const dbPromise=openDB(STORAGE_KEY,1,{upgrade(db){if(!db.objectStoreNames.contains("logs")){db.createObjectStore("logs",{keyPath:"id",autoIncrement:true})}}});if(log2.args){log2.args=log2.args.map(arg=>{try{JSON.parse(JSON.stringify(arg));return arg}catch{return String(arg)}})}dbPromise.then(async db=>{const tx=db.transaction("logs","readwrite");const store=tx.objectStore("logs");await store.add(log2);const allLogs=await store.getAll();while(allLogs.length>MAX_STORED_LOGS){await store.delete(allLogs[0].id);allLogs.shift()}await tx.done})}persistLogDexie(log2){const dexieDB=new Dexie(STORAGE_KEY);dexieDB.version(1).stores({logs:"++id, timestamp, label, message, args"});if(log2.args){log2.args=log2.args.map(arg=>{try{JSON.parse(JSON.stringify(arg));return arg}catch{return String(arg)}})}dexieDB.table("logs").add(log2);dexieDB.table("logs").count().then(count=>{if(count>MAX_STORED_LOGS){dexieDB.table("logs").orderBy("id").first(firstLog=>{if(firstLog){dexieDB.table("logs").delete(firstLog.id)}})}})}persistLogSQLite(log2){}persistLogBackground(log2){}clearPersistedLogs(){switch(this.backend){case"indexedDB":openDB(STORAGE_KEY,1).then(db=>{db.transaction("logs","readwrite").objectStore("logs").clear()});break;case"dexie":const dexieDB=new Dexie(STORAGE_KEY);dexieDB.version(1).stores({logs:"++id, message, timestamp"});dexieDB.table("logs").clear();break;case"sqlite":break;case"background":break;case"localStorage":default:localStorage.removeItem(STORAGE_KEY);break}}getPersistedLogs(){try{switch(this.backend){case"indexedDB":openDB(STORAGE_KEY,1).then(db=>db.transaction("logs","readonly").objectStore("logs").getAll());case"dexie":break;case"sqlite":break;case"background":break;case"localstorage":default:return JSON.parse(localStorage.getItem(STORAGE_KEY)||"[]")}}catch{this.error("Failed to retrieve persisted logs");return[]}}log(level,label,color,input,includeStack=false,persist=false,...args){try{const isProduction=this.isProductionEnvironment();if(isProduction){if(level<this.minLogLevel){return}}const{message:message,stack:stack}=this.normalizeInput(input);const timestamp=this.getTimestamp();const callerInfo=this.getCallerInfo();console.log(`%c[${label}] ${timestamp}`,color,message,...args||[],"\nCaller:",callerInfo,stack?"\nStack:"+stack:"");if(persist){const entry={timestamp:timestamp,label:label,message:message,callerInfo:callerInfo,stack:includeStack?stack:void 0,args:args};this.persistLog(entry)}}catch(error){if(!this.isProductionEnvironment()||level>=4){this.error("Logging failed:",false,error)}}}isProductionEnvironment(){{return true}}debug(input,persist=false,...args){this.log(0,"DEBUG",COLORS.DEBUG,input,false,persist,...args)}debugStack(input,persist=false,...args){this.log(1,"DEBUG_TRACE",COLORS.DEBUG,input,true,persist,...args)}info(input,persist=false,...args){this.log(2,"INFO",COLORS.INFO,input,false,persist,...args)}infoStack(input,persist=false,...args){this.log(3,"INFO_TRACE",COLORS.INFO,input,false,persist,...args)}warn(input,persist=false,...args){this.log(4,"WARN",COLORS.WARN,input,false,persist,...args)}error(input,persist=false,...args){this.log(5,"ERROR",COLORS.ERROR,input,false,persist,...args)}errorStack(error,persist=false,...args){this.log(6,"ERROR_TRACE",COLORS.ERROR,false,persist,...args)}trace(input,persist=false,...args){this.log(7,"TRACE",COLORS.TRACE,input,false,persist,...args)}}const log=Logger.getInstance();export{LogLevel as L,LogLevelDirection as a,log as l};
//# sourceMappingURL=Logger.js.map
