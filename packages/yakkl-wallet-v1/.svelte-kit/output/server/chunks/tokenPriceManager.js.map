{"version":3,"file":"tokenPriceManager.js","sources":["../../../../src/lib/managers/providers/price/coingecko/CoingeckoPriceProvider.ts","../../../../src/lib/managers/PriceManager.ts","../../../../src/lib/common/createPriceUpdater.ts","../../../../src/lib/common/tokenPriceManager.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { fetchJson } from '@ethersproject/web';\nimport type { MarketPriceData, PriceProvider } from '$lib/common/interfaces';\nimport { splitWords } from '$lib/utilities';\nimport { log } from '$lib/managers/Logger';\n\n// Coingecko public API pulls from a number of exchanges.\n// Coingecko does not update their prices as frequently as other providers so it may appear that prices look like an arbitrage opportunity but it may not be.\nexport class CoingeckoPriceProvider implements PriceProvider {\n\tgetAPIKey(): string {\n\t\treturn import.meta.env.VITE_COINGECKO_API_KEY;\n\t}\n\n\tgetName() {\n\t\treturn 'Coingecko';\n\t}\n\n\tasync getMarketPrice(pair: string): Promise<MarketPriceData> {\n\t\ttry {\n\t\t\tif (!pair) {\n\t\t\t\treturn {\n\t\t\t\t\tprovider: this.getName(),\n\t\t\t\t\tprice: 0,\n\t\t\t\t\tlastUpdated: new Date(),\n\t\t\t\t\tstatus: 404,\n\t\t\t\t\tmessage: `Invalid pair - ${pair}`\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst [name, currencySymbol] = await this.getProviderPairFormat(pair);\n\t\t\tif (!name || !currencySymbol) {\n\t\t\t\treturn {\n\t\t\t\t\tprovider: this.getName(),\n\t\t\t\t\tprice: 0,\n\t\t\t\t\tlastUpdated: new Date(),\n\t\t\t\t\tstatus: 404,\n\t\t\t\t\tmessage: `Invalid pair - ${pair}`\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst json = await fetchJson({\n\t\t\t\turl: `https://pro-api.coingecko.com/api/v3/simple/price?ids=${name}&include_last_updated_at=true&vs_currencies=${currencySymbol}`,\n\t\t\t\theaders: {\n\t\t\t\t\tAccept: 'application/json',\n\t\t\t\t\t'x-cg-pro-api-key': this.getAPIKey()\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst priceData = json[name.toLowerCase()];\n\n\t\t\tif (!priceData || !priceData[currencySymbol.toLowerCase()]) {\n\t\t\t\tthrow new Error('Invalid JSON structure or missing data from Coingecko');\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tprovider: this.getName(),\n\t\t\t\tprice: parseFloat(priceData[currencySymbol.toLowerCase()]),\n\t\t\t\tlastUpdated: new Date(priceData.last_updated_at * 1000),\n\t\t\t\tcurrency: currencySymbol,\n\t\t\t\tstatus: 0,\n\t\t\t\tmessage: 'Success'\n\t\t\t};\n\t\t} catch (e: any) {\n\t\t\tlog.error('CoingeckoPriceProvider - getPrice - error', e);\n\n\t\t\tlet status = 404; // Default status\n\t\t\tlet message = `Error - ${e}`;\n\n\t\t\tif (e.response && e.response.status === 429) {\n\t\t\t\t// Handle 429 Too Many Requests error\n\t\t\t\tstatus = 429;\n\t\t\t\tmessage = 'Too Many Requests - Rate limit exceeded';\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tprovider: this.getName(),\n\t\t\t\tprice: 0,\n\t\t\t\tlastUpdated: new Date(),\n\t\t\t\tstatus,\n\t\t\t\tmessage\n\t\t\t};\n\t\t}\n\t}\n\n\tasync getProviderPairFormat(pair: string): Promise<[string, string]> {\n\t\tlet name: string = '';\n\t\tconst [symbol, currencySymbol] = splitWords(pair, '-');\n\n\t\tif (!symbol || !currencySymbol) {\n\t\t\treturn ['', ''];\n\t\t}\n\n\t\t// symbol to name mapping needs to be updated at times. You can find the list at https://api.coingecko.com/api/v3/coins/list?include_platform=true&status=active\n\t\t// NOTE: This is not a complete list. You may need to add more symbols as needed. Also, the symbol may not match the name exactly.\n\t\tswitch (symbol) {\n\t\t\tcase 'ETH':\n\t\t\tcase 'WETH':\n\t\t\t\tname = 'ethereum';\n\t\t\t\tbreak;\n\t\t\tcase 'BTC':\n\t\t\t\tname = 'bitcoin';\n\t\t\t\tbreak;\n\t\t\tcase 'USDC':\n\t\t\t\tname = 'usd-coin';\n\t\t\t\tbreak;\n\t\t\tcase 'DAI':\n\t\t\t\tname = 'dai';\n\t\t\t\tbreak;\n\t\t\tcase 'USDT':\n\t\t\t\tname = 'tether';\n\t\t\t\tbreak;\n\t\t\tcase 'BUSD':\n\t\t\t\tname = 'binance-usd';\n\t\t\t\tbreak;\n\t\t\tcase 'WBTC':\n\t\t\t\tname = 'wrapped-bitcoin';\n\t\t\t\tbreak;\n\t\t\tcase 'SOL':\n\t\t\t\tname = 'solana';\n\t\t\t\tbreak;\n\t\t\tcase 'MATIC':\n\t\t\t\tname = 'matic-network';\n\t\t\t\tbreak;\n\t\t\tcase 'BNB':\n\t\t\t\tname = 'binance-coin';\n\t\t\t\tbreak;\n\t\t\tcase 'AVAX':\n\t\t\t\tname = 'avalanche-2';\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// TBD: Add more symbols as needed. May want to add a mapping file for this that only loads when not found in above list. This will need to be implemented in a dynamically generated function call.\n\t\t\t\tname = symbol.toLowerCase();\n\t\t\t\tbreak;\n\t\t}\n\t\treturn [name, currencySymbol];\n\t}\n}\n","import type { PriceData, PriceProvider, WeightedProvider } from '$lib/common/interfaces';\nimport { CoinbasePriceProvider } from './providers/price/coinbase/CoinbasePriceProvider';\nimport { CoingeckoPriceProvider } from './providers/price/coingecko/CoingeckoPriceProvider';\nimport { log } from '$lib/managers/Logger';\n\n// import { AlchemyPriceProvider } from './providers/price/alchemy/AlchemyPriceProvider';\n// import { KrakenPriceProvider } from './providers/price/kraken/KrakenPriceProvider';\n\nexport class PriceManager {\n\tprivate weightedProviders: WeightedProvider[];\n\tprivate totalWeight: number;\n\tprivate readonly DEFAULT_WEIGHT = 1;\n\n\tconstructor(weightedProviders: WeightedProvider[] = PriceManager.getDefaultProviders()) {\n\t\tif (!weightedProviders || weightedProviders.length === 0) {\n\t\t\tthrow new Error('At least one provider must be specified');\n\t\t}\n\n\t\tthis.weightedProviders = this.normalizeWeights(weightedProviders);\n\t\tthis.totalWeight = this.calculateTotalWeight();\n\t}\n\n\tstatic getDefaultProviders(): WeightedProvider[] {\n\t\treturn [\n\t\t\t// { provider: new AlchemyPriceProvider(), weight: 2 },\n\t\t\t{ provider: new CoinbasePriceProvider(), weight: 8 },\n\t\t\t{ provider: new CoingeckoPriceProvider(), weight: 5 }\n\t\t\t// { provider: new KrakenPriceProvider(), weight: 1 },\n\t\t\t// Add other providers with their weights...\n\t\t];\n\t}\n\n\tprivate normalizeWeights(providers: WeightedProvider[]): WeightedProvider[] {\n\t\tconst allZeroWeights = providers.every((wp) => wp.weight === 0);\n\t\tconst allEqualWeights = providers.every((wp) => wp.weight === providers[0].weight);\n\n\t\tif (allZeroWeights || allEqualWeights) {\n\t\t\t// If all weights are zero or equal, assign default weight to all\n\t\t\treturn providers.map((wp) => ({ ...wp, weight: this.DEFAULT_WEIGHT }));\n\t\t}\n\n\t\t// Replace any zero weights with the smallest non-zero weight\n\t\tconst smallestNonZeroWeight = Math.min(\n\t\t\t...providers.filter((wp) => wp.weight > 0).map((wp) => wp.weight)\n\t\t);\n\t\treturn providers.map((wp) => ({\n\t\t\t...wp,\n\t\t\tweight: wp.weight === 0 ? smallestNonZeroWeight : wp.weight\n\t\t}));\n\t}\n\n\tprivate calculateTotalWeight(): number {\n\t\treturn this.weightedProviders.reduce((sum, wp) => sum + wp.weight, 0);\n\t}\n\n\tpublic getAvailableProviders(): PriceProvider[] {\n\t\treturn this.weightedProviders.map((wp) => wp.provider);\n\t}\n\n\tasync getMarketPrice(pair: string, availableProviders?: PriceProvider[]): Promise<PriceData> {\n\t\tlet provider: PriceProvider | null = null;\n\t\tlet providersToUse: PriceProvider[] = [];\n\n\t\ttry {\n\t\t\tprovidersToUse = availableProviders || this.getAvailableProviders();\n\t\t\tif (providersToUse.length === 0) {\n\t\t\t\tthrow new Error('No providers available to fetch market price');\n\t\t\t}\n\n\t\t\tprovider = this.getWeightedRandomProvider(providersToUse);\n\t\t\tconst price = await provider.getMarketPrice(pair);\n\t\t\treturn price;\n\t\t} catch (error) {\n\t\t\tlog.error(`Error fetching price from ${provider.getName()}:`, false, error);\n\t\t\t// Retry with a different provider\n\t\t\treturn this.getMarketPrice(\n\t\t\t\tpair,\n\t\t\t\tprovidersToUse.filter((p) => p !== provider)\n\t\t\t); // Avoid circular error by excluding failed provider\n\t\t}\n\t}\n\n\tprivate getWeightedRandomProvider(providers: PriceProvider[]): PriceProvider {\n\t\tif (!providers || providers.length === 0) {\n\t\t\tlog.error('No providers available to fetch market price');\n\t\t\tthrow new Error('No providers available to fetch market price');\n\t\t}\n\n\t\tif (providers.length === 1) {\n\t\t\treturn providers[0];\n\t\t}\n\n\t\ttry {\n\t\t\tconst weightedProviders = this.weightedProviders.filter((wp) =>\n\t\t\t\tproviders.includes(wp.provider)\n\t\t\t);\n\t\t\tconst totalWeight = weightedProviders.reduce((sum, wp) => sum + wp.weight, 0);\n\n\t\t\tif (weightedProviders.every((wp) => wp.weight === weightedProviders[0].weight)) {\n\t\t\t\t// If all weights are equal, choose randomly\n\t\t\t\treturn weightedProviders[Math.floor(Math.random() * weightedProviders.length)].provider;\n\t\t\t}\n\n\t\t\tlet random = Math.random() * totalWeight;\n\n\t\t\tfor (const wp of weightedProviders) {\n\t\t\t\tif (random < wp.weight) {\n\t\t\t\t\treturn wp.provider;\n\t\t\t\t}\n\t\t\t\trandom -= wp.weight;\n\t\t\t}\n\n\t\t\t// This should never happen if weights are set correctly\n\t\t\treturn weightedProviders[0].provider;\n\t\t} catch (error) {\n\t\t\tlog.error('Error selecting weighted random provider:', false, error);\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n","import { writable } from 'svelte/store';\nimport type { TokenData } from './interfaces';\nimport type { PriceManager } from '$lib/managers/PriceManager';\nimport { log } from '$lib/managers/Logger';\n\n// Utility for debouncing\nfunction debounce(func: (...args: any[]) => void, delay: number) {\n\tlet timeoutId: ReturnType<typeof setTimeout>;\n\treturn (...args: any[]) => {\n\t\tclearTimeout(timeoutId);\n\t\ttimeoutId = setTimeout(() => func(...args), delay);\n\t};\n}\n\nexport function createPriceUpdater(priceManager: PriceManager) {\n\tconst tokens = writable<TokenData[]>([]);\n\tconst { subscribe, set } = tokens;\n\n\tasync function fetchPrices(tokensArray: TokenData[]): Promise<TokenData[]> {\n\t\tconst BATCH_SIZE = 8; // Adjust batch size for performance\n\t\tconst updatedTokens: TokenData[] = [];\n\n\t\tif (!tokensArray || tokensArray.length === 0) {\n\t\t\tlog.error('fetchPrices - No tokens to process. Exiting early.');\n\t\t\treturn [];\n\t\t}\n\n\t\tfor (let i = 0; i < tokensArray.length; i += BATCH_SIZE) {\n\t\t\tconst batch = tokensArray.slice(i, i + BATCH_SIZE);\n\n\t\t\ttry {\n\t\t\t\tconst batchResults = await Promise.all(\n\t\t\t\t\tbatch.map(async (token) => {\n\t\t\t\t\t\treturn fetchTokenData(token, priceManager);\n\t\t\t\t\t})\n\t\t\t\t);\n\n\t\t\t\tupdatedTokens.push(...batchResults);\n\t\t\t} catch (error) {\n\t\t\t\tlog.error('fetchPrices - Error processing batch:', false, batch, false, error);\n\t\t\t}\n\t\t}\n\t\treturn updatedTokens;\n\t}\n\n\tasync function fetchTokenData(token: TokenData, priceManager: PriceManager): Promise<TokenData> {\n\t\tconst pair = `${token.symbol}-USD`;\n\t\ttry {\n\t\t\tconst marketPrice = await priceManager.getMarketPrice(pair);\n\t\t\tconst price = marketPrice?.price ?? 0;\n\n\t\t\t// Fix for handling decimals in calculations\n\t\t\tconst adjustedBalance = token.balance ? Number(token.balance) / 10 ** token.decimals : 0;\n\t\t\tconst value = adjustedBalance * price;\n\n\t\t\treturn {\n\t\t\t\t...token,\n\t\t\t\tprice: {\n\t\t\t\t\tprice: price,\n\t\t\t\t\tprovider: marketPrice?.provider ?? '',\n\t\t\t\t\tlastUpdated: new Date() // Ensure lastUpdated is present\n\t\t\t\t},\n\t\t\t\tvalue,\n\t\t\t\tformattedValue: new Intl.NumberFormat('en-US', {\n\t\t\t\t\tstyle: 'currency',\n\t\t\t\t\tcurrency: 'USD'\n\t\t\t\t}).format(value)\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlog.error(`fetchTokenData - Failed to fetch price for ${token.symbol}`, false, error);\n\t\t\treturn {\n\t\t\t\t...token,\n\t\t\t\tprice: { price: 0, provider: '', lastUpdated: new Date() }, // Ensures lastUpdated is present, status removed\n\t\t\t\tvalue: 0\n\t\t\t};\n\t\t}\n\t}\n\n\t// Debounced fetch to reduce frequent updates\n\tconst debouncedFetchPrices = debounce(fetchPrices, 5000);\n\n\treturn { subscribe, fetchPrices };\n}\n","import { writable, get } from 'svelte/store';\nimport { yakklCombinedTokenStore, setYakklCombinedTokenStorage } from '$lib/common/stores';\nimport { log } from '$lib/managers/Logger';\nimport { PriceManager } from '$lib/managers/PriceManager';\nimport { createPriceUpdater } from './createPriceUpdater';\nimport { TimerManager } from '$lib/managers/TimerManager';\nimport type { TokenData } from '$lib/common/interfaces';\nimport { TIMER_TOKEN_PRICE_CYCLE_TIME } from './constants';\n\nlet priceManager: PriceManager | null = null;\nlet priceUpdater: any | null = null;\n\nconst fetchingActive = writable(false); // Prevents duplicate fetches\n\n// NOTE: May want to pass in priceManager as a parameter to allow for different configurations\nexport async function updateTokenPrices() {\n\tif (get(fetchingActive)) return; // Prevent concurrent fetches\n\tfetchingActive.set(true);\n\n\ttry {\n\t\tlog.info('updateTokenPrices: Starting price update');\n\t\tconst tokens: TokenData[] = get(yakklCombinedTokenStore); // Ensure we're working with the correct store\n\t\tif (tokens.length === 0) {\n\t\t\tlog.info('updateTokenPrices: No tokens to update');\n\t\t\treturn;\n\t\t}\n\n\t\tconst updatedTokens: TokenData[] = await priceUpdater.fetchPrices(tokens);\n\t\tif (!updatedTokens || updatedTokens.length === 0) {\n\t\t\tlog.warn('updateTokenPrices: Fetched prices returned empty.');\n\t\t\treturn;\n\t\t}\n\n\t\t// Update the store\n\t\tyakklCombinedTokenStore.update(() => updatedTokens);\n\n\t\t// Persist to localStorage\n\t\tawait setYakklCombinedTokenStorage(updatedTokens);\n\n\t\t// Update cached balances with new token prices\n\t\tconst { balanceCacheManager } = await import('$lib/managers/BalanceCacheManager');\n\t\tconst ethToken = updatedTokens.find((token) => token.isNative && token.symbol === 'ETH');\n\t\tif (ethToken && ethToken.value && ethToken.value > 0) {\n\t\t\tbalanceCacheManager.updatePriceForAllEntries(ethToken.value);\n\t\t\tlog.debug('[updateTokenPrices] Updated cached entries with ETH price:', false, {\n\t\t\t\tnewPrice: ethToken.value\n\t\t\t});\n\t\t}\n\n\t\tlog.info('updateTokenPrices: Successfully updated and persisted token prices');\n\t} catch (error) {\n\t\tlog.error('updateTokenPrices: Failed to update token prices', false, error);\n\t} finally {\n\t\tfetchingActive.set(false);\n\t}\n}\n\n// Get the TimerManager instance\nconst timerManager = TimerManager.getInstance();\n\nif (!timerManager.hasTimer('tokenPriceUpdater')) {\n\tlog.info('Setting up token price updater timer');\n\tif (!priceManager) {\n\t\tpriceManager = new PriceManager();\n\t}\n\tif (!priceUpdater) {\n\t\tpriceUpdater = createPriceUpdater(priceManager);\n\t}\n\t// Setup a timer to call `updateTokenPrices()` every 15s\n\ttimerManager.addTimer(\n\t\t'tokenPriceUpdater',\n\t\tasync () => {\n\t\t\tawait updateTokenPrices();\n\t\t},\n\t\tTIMER_TOKEN_PRICE_CYCLE_TIME\n\t);\n}\n\nif (!timerManager.isRunning('tokenPriceUpdater')) {\n\tlog.info('Starting token price updater timer');\n\ttimerManager.startTimer('tokenPriceUpdater');\n}\n"],"names":["CoingeckoPriceProvider","getAPIKey","getName","getMarketPrice","pair","provider","this","price","lastUpdated","Date","status","message","name","currencySymbol","getProviderPairFormat","json","fetchJson","url","headers","Accept","priceData","toLowerCase","Error","parseFloat","last_updated_at","currency","e","log","error","response","symbol","splitWords","PriceManager","weightedProviders","totalWeight","DEFAULT_WEIGHT","constructor","getDefaultProviders","length","normalizeWeights","calculateTotalWeight","CoinbasePriceProvider","weight","providers","allZeroWeights","every","wp","allEqualWeights","map","smallestNonZeroWeight","Math","min","filter","reduce","sum","getAvailableProviders","availableProviders","providersToUse","getWeightedRandomProvider","p","includes","floor","random","createPriceUpdater","priceManager","tokens","writable","subscribe","set","async","fetchPrices","tokensArray","BATCH_SIZE","updatedTokens","i","batch","slice","batchResults","Promise","all","token","fetchTokenData","push","marketPrice","adjustedBalance","balance","Number","decimals","value","formattedValue","Intl","NumberFormat","style","format","priceUpdater","fetchingActive","updateTokenPrices","get","info","yakklCombinedTokenStore","warn","update","setYakklCombinedTokenStorage","balanceCacheManager","import","ethToken","find","isNative","updatePriceForAllEntries","debug","newPrice","timerManager","TimerManager","getInstance","hasTimer","addTimer","TIMER_TOKEN_PRICE_CYCLE_TIME","isRunning","startTimer"],"mappings":"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"}