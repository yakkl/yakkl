import{w as writable,d as derived,g as get}from"./index.js";var has=Object.prototype.hasOwnProperty;function dequal(foo,bar){var ctor,len;if(foo===bar)return true;if(foo&&bar&&(ctor=foo.constructor)===bar.constructor){if(ctor===Date)return foo.getTime()===bar.getTime();if(ctor===RegExp)return foo.toString()===bar.toString();if(ctor===Array){if((len=foo.length)===bar.length){while(len--&&dequal(foo[len],bar[len]));}return len===-1}if(!ctor||typeof foo==="object"){len=0;for(ctor in foo){if(has.call(foo,ctor)&&++len&&!has.call(bar,ctor))return false;if(!(ctor in bar)||!dequal(foo[ctor],bar[ctor]))return false}return Object.keys(bar).length===len}}return foo!==foo&&bar!==bar}function subscribeOnce(observable){return new Promise(resolve=>{observable.subscribe(resolve)()})}function update(object,path,value){object.update(o=>{set(o,path,value);return o})}function cloneDeep(object){return JSON.parse(JSON.stringify(object))}function isNullish(value){return value===void 0||value===null}function isEmpty(object){return isNullish(object)||Object.keys(object).length<=0}function getValues(object){let results=[];for(const[,value]of Object.entries(object)){const values=typeof value==="object"?getValues(value):[value];results=[...results,...values]}return results}function getErrorsFromSchema(initialValues,schema,errors={}){for(const key in schema){switch(true){case schema[key].type==="object"&&!isEmpty(schema[key].fields):{errors[key]=getErrorsFromSchema(initialValues[key],schema[key].fields,{...errors[key]});break}case schema[key].type==="array":{const values=initialValues&&initialValues[key]?initialValues[key]:[];errors[key]=values.map(value=>{const innerError=getErrorsFromSchema(value,schema[key].innerType.fields,{...errors[key]});return Object.keys(innerError).length>0?innerError:""});break}default:{errors[key]=""}}}return errors}const deepEqual=dequal;function assignDeep(object,value){if(Array.isArray(object)){return object.map(o=>assignDeep(o,value))}const copy={};for(const key in object){copy[key]=typeof object[key]==="object"&&!isNullish(object[key])?assignDeep(object[key],value):value}return copy}function set(object,path,value){if(new Object(object)!==object)return object;if(!Array.isArray(path)){path=path.toString().match(/[^.[\]]+/g)||[]}const result=path.slice(0,-1).reduce((accumulator,key,index)=>new Object(accumulator[key])===accumulator[key]?accumulator[key]:accumulator[key]=Math.trunc(Math.abs(path[index+1]))===+path[index+1]?[]:{},object);result[path[path.length-1]]=value;return object}const util={assignDeep:assignDeep,cloneDeep:cloneDeep,deepEqual:deepEqual,getErrorsFromSchema:getErrorsFromSchema,getValues:getValues,isEmpty:isEmpty,isNullish:isNullish,set:set,subscribeOnce:subscribeOnce,update:update};const NO_ERROR="";function isCheckbox(element){return element.getAttribute&&element.getAttribute("type")==="checkbox"}function isFileInput(element){return element.getAttribute&&element.getAttribute("type")==="file"}function resolveValue(element){if(isFileInput(element)){return element.files}else if(isCheckbox(element)){return element.checked}else{return element.value}}const createForm=config=>{let initialValues=config.initialValues||{};const validationSchema=config.validationSchema;const validateFunction=config.validate;const onSubmit=config.onSubmit;const getInitial={values:()=>util.cloneDeep(initialValues),errors:()=>validationSchema?util.getErrorsFromSchema(initialValues,validationSchema.fields):util.assignDeep(initialValues,NO_ERROR),touched:()=>util.assignDeep(initialValues,false)};const form=writable(getInitial.values());const errors=writable(getInitial.errors());const touched=writable(getInitial.touched());const isSubmitting=writable(false);const isValidating=writable(false);const isValid=derived(errors,$errors=>{const noErrors=util.getValues($errors).every(field=>field===NO_ERROR);return noErrors});const modified=derived(form,$form=>{const object=util.assignDeep($form,false);for(let key in $form){object[key]=!util.deepEqual($form[key],initialValues[key])}return object});const isModified=derived(modified,$modified=>util.getValues($modified).includes(true));function validateField(field){return util.subscribeOnce(form).then(values=>validateFieldValue(field,values[field]))}function validateFieldValue(field,value){updateTouched(field,true);if(validationSchema){isValidating.set(true);return validationSchema.validateAt(field,get(form)).then(()=>util.update(errors,field,"")).catch(error=>util.update(errors,field,error.message)).finally(()=>{isValidating.set(false)})}if(validateFunction){isValidating.set(true);return Promise.resolve().then(()=>validateFunction({[field]:value})).then(errs=>util.update(errors,field,!util.isNullish(errs)?errs[field]:"")).finally(()=>{isValidating.set(false)})}return Promise.resolve()}function updateValidateField(field,value){updateField(field,value);return validateFieldValue(field,value)}function handleChange(event){const element=event.target;const field=element.name||element.id;const value=resolveValue(element);return updateValidateField(field,value)}function handleSubmit(event){if(event&&event.preventDefault){event.preventDefault()}isSubmitting.set(true);return util.subscribeOnce(form).then(values=>{if(typeof validateFunction==="function"){isValidating.set(true);return Promise.resolve().then(()=>validateFunction(values)).then(error=>{if(util.isNullish(error)||util.getValues(error).length===0){return clearErrorsAndSubmit(values)}else{errors.set(error);isSubmitting.set(false)}}).finally(()=>isValidating.set(false))}if(validationSchema){isValidating.set(true);return validationSchema.validate(values,{abortEarly:false}).then(()=>clearErrorsAndSubmit(values)).catch(yupErrors=>{if(yupErrors&&yupErrors.inner){const updatedErrors=getInitial.errors();yupErrors.inner.map(error=>util.set(updatedErrors,error.path,error.message));errors.set(updatedErrors)}isSubmitting.set(false)}).finally(()=>isValidating.set(false))}return clearErrorsAndSubmit(values)})}function handleReset(){form.set(getInitial.values());errors.set(getInitial.errors());touched.set(getInitial.touched())}function clearErrorsAndSubmit(values){return Promise.resolve().then(()=>errors.set(getInitial.errors())).then(()=>onSubmit(values,form,errors)).finally(()=>isSubmitting.set(false))}function updateField(field,value){util.update(form,field,value)}function updateTouched(field,value){util.update(touched,field,value)}function updateInitialValues(newValues){initialValues=newValues;handleReset()}return{form:form,errors:errors,touched:touched,modified:modified,isValid:isValid,isSubmitting:isSubmitting,isValidating:isValidating,isModified:isModified,handleChange:handleChange,handleSubmit:handleSubmit,handleReset:handleReset,updateField:updateField,updateValidateField:updateValidateField,updateTouched:updateTouched,validateField:validateField,updateInitialValues:updateInitialValues,state:derived([form,errors,touched,modified,isValid,isValidating,isSubmitting,isModified],([$form,$errors,$touched,$modified,$isValid,$isValidating,$isSubmitting,$isModified])=>({form:$form,errors:$errors,touched:$touched,modified:$modified,isValid:$isValid,isSubmitting:$isSubmitting,isValidating:$isValidating,isModified:$isModified}))}};export{createForm as c};
//# sourceMappingURL=create-form.js.map
