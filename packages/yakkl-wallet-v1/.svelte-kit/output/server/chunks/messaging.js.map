{"version":3,"file":"messaging.js","sources":["../../../../src/lib/common/messaging.ts"],"sourcesContent":["// src/lib/common/messaging.ts\nimport { browser as isBrowser } from '$app/environment';\nimport { log } from '$lib/common/logger-wrapper';\nimport type { Browser, Runtime } from 'webextension-polyfill';\nimport { protectedContexts } from './globals';\nimport { UnifiedTimerManager } from '$lib/managers/UnifiedTimerManager';\n\n// Helper function to check if context needs idle protection\nfunction contextNeedsIdleProtection(contextType: string): boolean {\n\treturn protectedContexts.includes(contextType);\n}\n\n/**\n * A utility for reliable and efficient communication with the extension's background script\n */\nclass ExtensionMessaging {\n\tprivate static instance: ExtensionMessaging;\n\tprivate messageQueue: Map<string, any[]> = new Map();\n\tprivate processedResponses = new Map<string, { timestamp: number; result: any }>();\n\tprivate isProcessing: boolean = false;\n\tprivate retryCount: Map<string, number> = new Map();\n\tprivate MAX_RETRIES = 3;\n\tprivate RETRY_DELAY = 500; // ms\n\tprivate browserApi: Browser | null = null;\n\tprivate contextId: string = '';\n\tprivate pendingRequests = new Map<\n\t\tstring,\n\t\t{\n\t\t\tresolve: (result: any) => void;\n\t\t\treject: (error: any) => void;\n\t\t\ttimestamp: number;\n\t\t}\n\t>();\n\tprivate timerManager = UnifiedTimerManager.getInstance();\n\n\t// Add a list of message types that don't need responses\n\tprivate readonly FIRE_AND_FORGET_MESSAGES = [\n\t\t'clientReady',\n\t\t'ui_context_initialized',\n\t\t'ui_context_activity',\n\t\t'ui_context_closing',\n\t\t'SET_LOGIN_VERIFIED',\n\t\t'USER_ACTIVITY',\n\t\t'CLEAR_ALL_ENHANCED_ALERTS', // Add this to prevent feedback loops\n\t\t'CLEAR_NOTIFICATION',\n\t\t'CLEAR_NOTIFICATION_ENHANCED',\n\t\t'IDLE_STATUS_CHANGED',\n\t\t'LOCKDOWN_WARNING_ENHANCED',\n\t\t'SECURITY_ALERT_ENHANCED',\n\t\t'PLAY_URGENT_SOUND'\n\t];\n\n\t/**\n\t * Get the singleton instance\n\t */\n\tpublic static getInstance(): ExtensionMessaging {\n\t\tif (!ExtensionMessaging.instance) {\n\t\t\tExtensionMessaging.instance = new ExtensionMessaging();\n\t\t}\n\t\treturn ExtensionMessaging.instance;\n\t}\n\n\t/**\n\t * Initialize the messaging system\n\t * @param browserExtensionApi The browser extension API object from webextension-polyfill\n\t */\n\tpublic initialize(browserExtensionApi: Browser): void {\n\t\tif (!isBrowser) return; // Skip on server\n\n\t\tthis.browserApi = browserExtensionApi;\n\t\tthis.contextId = this.getContextId();\n\t\tlog.debug('[Messaging - initialize] Extension messaging initialized');\n\n\t\t// Start processing any queued messages\n\t\tthis.processQueue();\n\n\t\t// Set up message listener for responses\n\t\tif (this.browserApi && this.browserApi.runtime) {\n\t\t\tthis.browserApi.runtime.onMessage.addListener(this.handleIncomingMessage.bind(this));\n\t\t}\n\n\t\t// Start cleanup interval using UnifiedTimerManager\n\t\tthis.timerManager.addInterval('messaging-cleanup', () => this.cleanup(), 60000);\n\t\tthis.timerManager.startInterval('messaging-cleanup');\n\t}\n\n\t/**\n\t * Send a cleanup message that won't trigger response loops\n\t */\n\tpublic async sendCleanupMessage(\n\t\ttype: string,\n\t\tdata: any = {},\n\t\tsource: string = 'unknown'\n\t): Promise<void> {\n\t\tif (!isBrowser || !this.browserApi) return;\n\n\t\t// These messages should never wait for responses and should be rate-limited\n\t\tconst message = {\n\t\t\ttype,\n\t\t\t...data,\n\t\t\tmessageId: `cleanup-${source}-${Date.now()}`,\n\t\t\ttimestamp: Date.now(),\n\t\t\tcontextId: this.contextId,\n\t\t\tsource: source,\n\t\t\tisCleanup: true // Flag to identify cleanup messages\n\t\t};\n\n\t\ttry {\n\t\t\t// Send directly without waiting for response and with error suppression\n\t\t\tthis.browserApi.runtime.sendMessage(message).catch((error) => {\n\t\t\t\tlog.debug(\n\t\t\t\t\t`[Messaging - sendCleanupMessage] Cleanup message ${type} send failed (this is normal):`,\n\t\t\t\t\tfalse,\n\t\t\t\t\terror\n\t\t\t\t);\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlog.debug(\n\t\t\t\t`[Messaging - sendCleanupMessage] Cleanup message ${type} send error (this is normal):`,\n\t\t\t\tfalse,\n\t\t\t\terror\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Handle incoming messages, primarily to resolve pending promises\n\t */\n\tprivate handleIncomingMessage(\n\t\tmessage: any,\n\t\tsender: Runtime.MessageSender,\n\t\tsendResponse: (response?: any) => void\n\t): true {\n\t\t// Skip messages that don't have a response identifier\n\t\tif (!message || !message.responseId) return true;\n\n\t\tconst { responseId, result, error } = message;\n\n\t\t// Check if we have a pending request for this response\n\t\tconst pendingRequest = this.pendingRequests.get(responseId);\n\t\tif (pendingRequest) {\n\t\t\tif (error) {\n\t\t\t\tpendingRequest.reject(error);\n\t\t\t} else {\n\t\t\t\tpendingRequest.resolve(result);\n\t\t\t}\n\n\t\t\t// Remove from pending requests\n\t\t\tthis.pendingRequests.delete(responseId);\n\n\t\t\t// Cache the response for deduplication\n\t\t\tthis.processedResponses.set(responseId, {\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t\tresult: error || result\n\t\t\t});\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Send a message to the background script\n\t * @param type Message type\n\t * @param data Message data\n\t * @param options Message options\n\t * @returns Promise resolving to the response\n\t */\n\tpublic async sendMessage(\n\t\ttype: string,\n\t\tdata: any = {},\n\t\toptions: {\n\t\t\tpriority?: 'high' | 'normal' | 'low';\n\t\t\tretryOnFail?: boolean;\n\t\t\tcontextId?: string;\n\t\t\tdeduplicate?: boolean;\n\t\t\tresponseTimeout?: number;\n\t\t\twaitForResponse?: boolean;\n\t\t} = {}\n\t): Promise<any> {\n\t\tif (!isBrowser) {\n\t\t\t// Return a resolved promise when running on server\n\t\t\treturn Promise.resolve(null);\n\t\t}\n\n\t\tconst {\n\t\t\tpriority = 'normal',\n\t\t\tretryOnFail = true,\n\t\t\tcontextId = this.contextId,\n\t\t\tdeduplicate = true,\n\t\t\tresponseTimeout = 30000, // 30 second default timeout\n\t\t\t// If message type is in fire-and-forget list, don't wait for response\n\t\t\twaitForResponse = !this.FIRE_AND_FORGET_MESSAGES.includes(type)\n\t\t} = options;\n\n\t\t// Generate a unique ID for this message\n\t\tconst messageId = `${type}:${contextId}:${Date.now().toString(36)}`;\n\n\t\t// If deduplication is enabled and we've recently processed this exact message type+data\n\t\tif (deduplicate) {\n\t\t\tconst exactMessageKey = `${type}:${JSON.stringify(data)}`;\n\t\t\tconst recentResponse = this.processedResponses.get(exactMessageKey);\n\n\t\t\tif (recentResponse && Date.now() - recentResponse.timestamp < 5000) {\n\t\t\t\tlog.debug('[Messaging - sendMessage] Using cached response for identical message:', false, {\n\t\t\t\t\ttype\n\t\t\t\t});\n\t\t\t\treturn Promise.resolve(recentResponse.result);\n\t\t\t}\n\t\t}\n\n\t\t// Check if browserApi is available\n\t\tif (!this.browserApi) {\n\t\t\tlog.warn(\n\t\t\t\t'[Messaging - sendMessage] Browser extension API not available. Call initialize() first.'\n\t\t\t);\n\t\t\treturn Promise.reject(\n\t\t\t\tnew Error('Browser extension API not available. Call initialize() first.')\n\t\t\t);\n\t\t}\n\n\t\t// Prepare the message\n\t\tconst message = {\n\t\t\ttype,\n\t\t\t...data,\n\t\t\tmessageId,\n\t\t\ttimestamp: Date.now(),\n\t\t\tcontextId\n\t\t};\n\n\t\t// For fire-and-forget messages, just send and resolve immediately\n\t\tif (!waitForResponse) {\n\t\t\ttry {\n\t\t\t\t// Send directly without waiting for response\n\t\t\t\tthis.browserApi.runtime.sendMessage(message).catch((error) => {\n\t\t\t\t\tlog.debug(\n\t\t\t\t\t\t`[Messaging - sendMessage] Error sending fire-and-forget message ${type}:`,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\terror\n\t\t\t\t\t);\n\t\t\t\t});\n\n\t\t\t\t// Return resolved promise immediately\n\t\t\t\treturn Promise.resolve({ success: true, noResponseRequired: true });\n\t\t\t} catch (error) {\n\t\t\t\tlog.debug(\n\t\t\t\t\t`[Messaging - sendMessage] Error sending fire-and-forget message ${type}:`,\n\t\t\t\t\tfalse,\n\t\t\t\t\terror\n\t\t\t\t);\n\t\t\t\treturn Promise.resolve({ success: true, noResponseRequired: true, sendFailed: true });\n\t\t\t}\n\t\t}\n\n\t\t// For messages requiring response, use the queue system\n\t\treturn new Promise((resolve, reject) => {\n\t\t\t// Add to pending requests\n\t\t\tthis.pendingRequests.set(messageId, {\n\t\t\t\tresolve,\n\t\t\t\treject,\n\t\t\t\ttimestamp: Date.now()\n\t\t\t});\n\n\t\t\t// Set up timeout\n\t\t\tconst timeoutId = setTimeout(() => {\n\t\t\t\tif (this.pendingRequests.has(messageId)) {\n\t\t\t\t\tthis.pendingRequests.delete(messageId);\n\t\t\t\t\treject(new Error(`Message ${type} timed out after ${responseTimeout}ms`));\n\t\t\t\t}\n\t\t\t}, responseTimeout);\n\n\t\t\t// Add to queue\n\t\t\tconst queueKey = priority;\n\t\t\tif (!this.messageQueue.has(queueKey)) {\n\t\t\t\tthis.messageQueue.set(queueKey, []);\n\t\t\t}\n\n\t\t\tthis.messageQueue.get(queueKey)!.push({\n\t\t\t\tmessage,\n\t\t\t\tretryOnFail,\n\t\t\t\tretryCount: 0,\n\t\t\t\ttimeoutId\n\t\t\t});\n\n\t\t\t// Start processing the queue if not already processing\n\t\t\tif (!this.isProcessing) {\n\t\t\t\tthis.processQueue();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Process the message queue in priority order\n\t */\n\tprivate async processQueue(): Promise<void> {\n\t\tif (!isBrowser || this.isProcessing || !this.browserApi) return;\n\n\t\tthis.isProcessing = true;\n\n\t\t// Process high priority messages first, then normal, then low\n\t\tconst priorities = ['high', 'normal', 'low'];\n\n\t\ttry {\n\t\t\tfor (const priority of priorities) {\n\t\t\t\tconst queue = this.messageQueue.get(priority) || [];\n\n\t\t\t\t// Process all messages in this queue\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tconst item = queue.shift()!;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Send the message\n\t\t\t\t\t\tawait this.browserApi.runtime.sendMessage(item.message).catch((error: any) => {\n\t\t\t\t\t\t\tlog.debug('[Messaging - processQueue] Error sending message:', false, error);\n\n\t\t\t\t\t\t\t// If we should retry and haven't exceeded the retry limit\n\t\t\t\t\t\t\tif (item.retryOnFail && item.retryCount < this.MAX_RETRIES) {\n\t\t\t\t\t\t\t\t// Increment retry count and add back to queue\n\t\t\t\t\t\t\t\titem.retryCount++;\n\t\t\t\t\t\t\t\tqueue.push(item);\n\n\t\t\t\t\t\t\t\tlog.debug('[Messaging - processQueue] Retrying message:', false, {\n\t\t\t\t\t\t\t\t\ttype: item.message.type,\n\t\t\t\t\t\t\t\t\tattempt: item.retryCount\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Reject the promise\n\t\t\t\t\t\t\t\tconst pendingRequest = this.pendingRequests.get(item.message.messageId);\n\t\t\t\t\t\t\t\tif (pendingRequest) {\n\t\t\t\t\t\t\t\t\tpendingRequest.reject(error);\n\t\t\t\t\t\t\t\t\tthis.pendingRequests.delete(item.message.messageId);\n\t\t\t\t\t\t\t\t\tclearTimeout(item.timeoutId);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (error: any) {\n\t\t\t\t\t\t// If we should retry and haven't exceeded the retry limit\n\t\t\t\t\t\tif (item.retryOnFail && item.retryCount < this.MAX_RETRIES) {\n\t\t\t\t\t\t\t// Increment retry count and add back to queue\n\t\t\t\t\t\t\titem.retryCount++;\n\t\t\t\t\t\t\tqueue.push(item);\n\n\t\t\t\t\t\t\t// Add a small delay before next attempt\n\t\t\t\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, this.RETRY_DELAY));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Log the error and reject the promise\n\t\t\t\t\t\t\tlog.warn(\n\t\t\t\t\t\t\t\t`[Messaging - processQueue] Failed to send message (${item.message.type}) after ${item.retryCount} retries:`,\n\t\t\t\t\t\t\t\terror\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst pendingRequest = this.pendingRequests.get(item.message.messageId);\n\t\t\t\t\t\t\tif (pendingRequest) {\n\t\t\t\t\t\t\t\tpendingRequest.reject(error);\n\t\t\t\t\t\t\t\tthis.pendingRequests.delete(item.message.messageId);\n\t\t\t\t\t\t\t\tclearTimeout(item.timeoutId);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add a small delay between messages\n\t\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 10));\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.isProcessing = false;\n\n\t\t\t// If there are still messages in the queue, continue processing\n\t\t\tfor (const queue of this.messageQueue.values()) {\n\t\t\t\tif (queue.length > 0) {\n\t\t\t\t\tsetTimeout(() => this.processQueue(), 0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Clean up stale pending requests and responses\n\t */\n\tprivate cleanup(): void {\n\t\tconst now = Date.now();\n\n\t\t// Clean up stale pending requests (older than 1 minute)\n\t\tfor (const [messageId, request] of this.pendingRequests.entries()) {\n\t\t\tif (now - request.timestamp > 60000) {\n\t\t\t\trequest.reject(new Error('Request timed out'));\n\t\t\t\tthis.pendingRequests.delete(messageId);\n\t\t\t}\n\t\t}\n\n\t\t// Clean up old processed responses (older than 5 minutes)\n\t\tfor (const [messageId, response] of this.processedResponses.entries()) {\n\t\t\tif (now - response.timestamp > 300000) {\n\t\t\t\tthis.processedResponses.delete(messageId);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Generate or retrieve a context ID for this UI instance\n\t */\n\tprivate getContextId(): string {\n\t\t// if (!isBrowser) return 'server';\n\n\t\t// // Check for an existing context ID in window storage\n\t\t// if (typeof window !== 'undefined' &&\n\t\t//     window.EXTENSION_INIT_STATE &&\n\t\t//     window.EXTENSION_INIT_STATE.contextId) {\n\t\t//   return window.EXTENSION_INIT_STATE.contextId;\n\t\t// }\n\n\t\t// // Generate a new context ID\n\t\t// const contextId = Date.now().toString(36) + Math.random().toString(36).substring(2, 7);\n\n\t\t// // Store it in window storage if available\n\t\t// if (typeof window !== 'undefined') {\n\t\t//   if (!window.EXTENSION_INIT_STATE) {\n\t\t//     window.EXTENSION_INIT_STATE = {\n\t\t//       initialized: false,\n\t\t//       contextId: contextId,\n\t\t//       activityTrackingStarted: false,\n\t\t//       startTime: Date.now()\n\t\t//     };\n\t\t//   } else {\n\t\t//     window.EXTENSION_INIT_STATE.contextId = contextId;\n\t\t//   }\n\t\t// }\n\n\t\t// return contextId;\n\t\treturn this.contextId;\n\t}\n\n\t/**\n\t * Check if the messaging service has been initialized\n\t * @returns true if initialized, false otherwise\n\t */\n\tpublic isInitialized(): boolean {\n\t\treturn this.browserApi !== null;\n\t}\n\n\t/**\n\t * Manually trigger user activity detection (for testing)\n\t */\n\tpublic triggerActivityDetection(): void {\n\t\tif (!isBrowser || typeof window === 'undefined') return;\n\n\t\tconst handler = (window as any).__yakklActivityHandler;\n\t\tif (handler) {\n\t\t\tlog.info('[Messaging - triggerActivityDetection] Manually triggering activity detection');\n\t\t\thandler();\n\t\t} else {\n\t\t\tlog.warn(\n\t\t\t\t'[Messaging - triggerActivityDetection] Activity handler not found - activity tracking may not be set up'\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Send a UI context initialization message to the background script\n\t */\n\tpublic async registerUiContext(contextType: string): Promise<void> {\n\t\tif (!isBrowser || !this.browserApi) return;\n\n\t\tconst contextId = this.contextId;\n\n\t\tawait this.sendMessage(\n\t\t\t'ui_context_initialized',\n\t\t\t{\n\t\t\t\tcontextId,\n\t\t\t\tcontextType,\n\t\t\t\ttimestamp: Date.now()\n\t\t\t},\n\t\t\t{\n\t\t\t\tpriority: 'high',\n\t\t\t\tretryOnFail: true,\n\t\t\t\tdeduplicate: false\n\t\t\t}\n\t\t);\n\n\t\t// Set up unload handler\n\t\tif (typeof window !== 'undefined') {\n\t\t\ttry {\n\t\t\t\twindow.addEventListener('beforeunload', () => {\n\t\t\t\t\t// Send synchronously to ensure it gets through before page unloads\n\t\t\t\t\tif (this.browserApi && this.browserApi.runtime) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tthis.browserApi.runtime.sendMessage({\n\t\t\t\t\t\t\t\ttype: 'ui_context_closing',\n\t\t\t\t\t\t\t\tcontextId\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t// Can't do much about errors during unload\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\tconsole.warn(`[${contextId}] Failed to add unload handler:`, error);\n\t\t\t}\n\t\t}\n\n\t\tlog.debug(\n\t\t\t`[Messaging - registerUiContext] UI context registered: ${contextId} (${contextType})`\n\t\t);\n\t}\n\n\t/**\n\t * Send user activity update to keep context active (only for protected contexts)\n\t */\n\tpublic async sendActivityUpdate(): Promise<void> {\n\t\tif (!isBrowser || !this.browserApi) return;\n\n\t\tconst contextType = this.getContextType();\n\n\t\t// Only send activity updates for protected contexts\n\t\tif (!contextNeedsIdleProtection(contextType)) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tawait this.sendMessage(\n\t\t\t\t'ui_context_activity',\n\t\t\t\t{\n\t\t\t\t\tcontextId: this.contextId,\n\t\t\t\t\tcontextType: contextType,\n\t\t\t\t\ttimestamp: Date.now()\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tpriority: 'high', // Make activity updates high priority\n\t\t\t\t\tretryOnFail: true, // Retry if failed\n\t\t\t\t\tdeduplicate: false // Don't deduplicate activity messages\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tlog.debug('[Messaging - sendActivityUpdate] Activity update sent successfully');\n\t\t} catch (error) {\n\t\t\tlog.warn('[Messaging - sendActivityUpdate] Failed to send activity update:', false, error);\n\t\t}\n\t}\n\n\t/**\n\t * Notify the background script that login is verified or not (only for protected contexts)\n\t */\n\tpublic async setLoginVerified(verified: boolean, contextType?: string): Promise<void> {\n\t\tif (!isBrowser || !this.browserApi) {\n\t\t\tlog.warn(`[Messaging - setLoginVerified] ❌ CANNOT SET LOGIN VERIFIED:`, false, {\n\t\t\t\tisBrowser,\n\t\t\t\thasBrowserApi: !!this.browserApi,\n\t\t\t\tverified,\n\t\t\t\tcontextType\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tconst actualContextType = contextType || this.getContextType();\n\n\t\tlog.info(`[Messaging - setLoginVerified] 🔐 LOGIN VERIFICATION REQUEST:`, false, {\n\t\t\tverified,\n\t\t\tprovidedContextType: contextType,\n\t\t\tactualContextType,\n\t\t\tcontextId: this.contextId,\n\t\t\tisProtectedContext: contextNeedsIdleProtection(actualContextType),\n\t\t\tprotectedContexts\n\t\t});\n\n\t\t// Only send login verification for protected contexts\n\t\tif (!contextNeedsIdleProtection(actualContextType)) {\n\t\t\tlog.warn(`[Messaging - setLoginVerified] ❌ SKIPPING - not a protected context:`, false, {\n\t\t\t\tcontextType: actualContextType,\n\t\t\t\tprotectedContexts,\n\t\t\t\treason: 'Context type not in protected contexts list'\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tconst messageData = {\n\t\t\tverified,\n\t\t\tcontextId: this.contextId,\n\t\t\tcontextType: actualContextType\n\t\t};\n\n\t\tlog.info(\n\t\t\t`[Messaging - setLoginVerified] 📤 SENDING SET_LOGIN_VERIFIED message:`,\n\t\t\tfalse,\n\t\t\tmessageData\n\t\t);\n\n\t\ttry {\n\t\t\tawait this.sendMessage('SET_LOGIN_VERIFIED', messageData, {\n\t\t\t\tpriority: 'high',\n\t\t\t\tretryOnFail: true,\n\t\t\t\tdeduplicate: false\n\t\t\t});\n\n\t\t\tlog.info(`[Messaging - setLoginVerified] ✅ SET_LOGIN_VERIFIED sent successfully:`, false, {\n\t\t\t\tverified,\n\t\t\t\tcontextId: this.contextId,\n\t\t\t\tcontextType: actualContextType\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlog.error(`[Messaging - setLoginVerified] ❌ ERROR sending SET_LOGIN_VERIFIED:`, false, {\n\t\t\t\terror,\n\t\t\t\tmessageData,\n\t\t\t\tcontextId: this.contextId\n\t\t\t});\n\t\t\tthrow error;\n\t\t}\n\n\t\tlog.info(\n\t\t\t`[Messaging - setLoginVerified] 🎉 Login ${verified ? 'verified' : 'unverified'} for protected context: ${this.contextId}`\n\t\t);\n\t}\n\n\t/**\n\t * Determine the context type based on the current URL\n\t */\n\tprivate getContextType(): string {\n\t\ttry {\n\t\t\tif (!isBrowser || typeof window === 'undefined') return 'unknown';\n\n\t\t\tconst pathname = window.location.pathname;\n\t\t\tconst href = window.location.href;\n\n\t\t\tif (pathname.includes('sidepanel') || href.includes('sidepanel')) {\n\t\t\t\treturn 'sidepanel';\n\t\t\t} else if (\n\t\t\t\tpathname.includes('index.html') ||\n\t\t\t\thref.includes('index.html') ||\n\t\t\t\tpathname === '/' ||\n\t\t\t\tpathname === ''\n\t\t\t) {\n\t\t\t\treturn 'popup-wallet';\n\t\t\t} else if (pathname.includes('dapp/popups') || href.includes('dapp/popups')) {\n\t\t\t\treturn 'popup-dapp';\n\t\t\t} else if (pathname.includes('options') || href.includes('options')) {\n\t\t\t\treturn 'options';\n\t\t\t} else {\n\t\t\t\treturn 'popup-wallet'; // Default to popup-wallet for main extension\n\t\t\t}\n\t\t} catch (error) {\n\t\t\treturn 'unknown';\n\t\t}\n\t}\n\n\t/**\n\t * Set up activity tracking for this context (only for protected contexts)\n\t */\n\tpublic setupActivityTracking(): void {\n\t\tif (!isBrowser || typeof window === 'undefined') return;\n\n\t\tconst contextType = this.getContextType();\n\n\t\t// Only set up activity tracking for protected contexts\n\t\tif (!contextNeedsIdleProtection(contextType)) {\n\t\t\tlog.info(\n\t\t\t\t`[Messaging - setupActivityTracking] Skipping activity tracking setup for non-protected context: ${contextType}`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if already set up to prevent duplicate listeners\n\t\tif ((window as any).__yakklActivityTrackingSetup) {\n\t\t\tlog.info(\n\t\t\t\t'[Messaging - setupActivityTracking] Activity tracking already set up, skipping duplicate setup'\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tlog.info(\n\t\t\t`[Messaging - setupActivityTracking] Setting up activity tracking for protected context: ${contextType}`\n\t\t);\n\n\t\t// Track user activity\n\t\tconst activityEvents = [\n\t\t\t'mousedown',\n\t\t\t'mousemove',\n\t\t\t'keydown',\n\t\t\t'scroll',\n\t\t\t'touchstart',\n\t\t\t'focus',\n\t\t\t'click'\n\t\t];\n\n\t\t// Throttled activity tracker\n\t\tlet lastActivity = Date.now();\n\t\tconst ACTIVITY_THROTTLE = 2000; // Send at most every 2 seconds (reduced from 5 seconds)\n\n\t\tconst activityHandler = () => {\n\t\t\tconst now = Date.now();\n\t\t\tif (now - lastActivity > ACTIVITY_THROTTLE) {\n\t\t\t\tlastActivity = now;\n\n\t\t\t\tlog.debug(\n\t\t\t\t\t'[Messaging - setupActivityTracking] User activity detected, sending activity update'\n\t\t\t\t);\n\n\t\t\t\t// Send activity update immediately\n\t\t\t\tthis.sendActivityUpdate().catch((error) => {\n\t\t\t\t\tlog.debug(\n\t\t\t\t\t\t'[Messaging - setupActivityTracking] Failed to send activity update:',\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\terror\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t// Set up listeners with passive option for better performance\n\t\tactivityEvents.forEach((event) => {\n\t\t\twindow.addEventListener(event, activityHandler, {\n\t\t\t\tpassive: true,\n\t\t\t\tcapture: false\n\t\t\t});\n\t\t});\n\n\t\t// Mark as set up\n\t\t(window as any).__yakklActivityTrackingSetup = true;\n\t\t(window as any).__yakklActivityHandler = activityHandler;\n\t\t(window as any).__yakklActivityEvents = activityEvents;\n\n\t\t// Clean up on page unload\n\t\twindow.addEventListener('beforeunload', () => {\n\t\t\tactivityEvents.forEach((event) => {\n\t\t\t\twindow.removeEventListener(event, activityHandler);\n\t\t\t});\n\t\t\t(window as any).__yakklActivityTrackingSetup = false;\n\t\t});\n\n\t\tlog.info(\n\t\t\t'[Messaging - setupActivityTracking] Activity tracking set up successfully for protected context:',\n\t\t\tfalse,\n\t\t\t{\n\t\t\t\tcontextId: this.contextId,\n\t\t\t\tcontextType: contextType,\n\t\t\t\teventsTracked: activityEvents.length\n\t\t\t}\n\t\t);\n\t}\n}\n\n// Export a singleton instance\nexport const messagingService = ExtensionMessaging.getInstance();\n\n// Helper functions for common message patterns\n\n/**\n * Initialize the messaging service with the browser extension API\n * @param browserExtensionApi The browser extension API from webextension-polyfill\n */\nexport function initializeMessaging(browserExtensionApi: Browser): void {\n\tif (!isBrowser) return;\n\tmessagingService.initialize(browserExtensionApi);\n}\n\n/**\n * Send client ready message to background script\n */\nexport async function sendClientReady(): Promise<void> {\n\tif (!isBrowser) return;\n\n\tawait messagingService.sendMessage(\n\t\t'clientReady',\n\t\t{},\n\t\t{\n\t\t\tpriority: 'high',\n\t\t\tretryOnFail: true,\n\t\t\tdeduplicate: true\n\t\t}\n\t);\n}\n\n/**\n * Determine the most appropriate context type based on URL\n */\nfunction determineBestContextType(): string {\n\ttry {\n\t\tif (typeof window === 'undefined') return 'unknown';\n\n\t\tconst pathname = window.location.pathname;\n\t\tconst href = window.location.href;\n\n\t\tif (pathname.includes('sidepanel') || href.includes('sidepanel')) {\n\t\t\treturn 'sidepanel';\n\t\t} else if (\n\t\t\tpathname.includes('index.html') ||\n\t\t\thref.includes('index.html') ||\n\t\t\tpathname === '/' ||\n\t\t\tpathname === ''\n\t\t) {\n\t\t\treturn 'popup-wallet';\n\t\t} else if (pathname.includes('dapp/popups') || href.includes('dapp/popups')) {\n\t\t\treturn 'popup-dapp';\n\t\t} else if (pathname.includes('options') || href.includes('options')) {\n\t\t\treturn 'options';\n\t\t} else {\n\t\t\treturn 'popup-wallet'; // Default to popup-wallet for main extension\n\t\t}\n\t} catch (error) {\n\t\treturn 'unknown';\n\t}\n}\n\n/**\n * Initialize a UI context and start activity tracking\n * @param browserExtensionApi The browser extension API from webextension-polyfill\n * @param contextType Optional context type override\n */\nexport async function initializeUiContext(\n\tbrowserExtensionApi: Browser,\n\tcontextType?: string\n): Promise<void> {\n\tif (!isBrowser) return;\n\n\t// Initialize messaging service\n\tmessagingService.initialize(browserExtensionApi);\n\n\t// Register this UI context\n\tconst actualContextType = contextType || determineBestContextType();\n\tawait messagingService.registerUiContext(actualContextType);\n\n\t// Only set up activity tracking for protected contexts\n\tif (contextNeedsIdleProtection(actualContextType)) {\n\t\tlog.info(\n\t\t\t`[Messaging - initializeUiContext] Setting up activity tracking for protected context: ${actualContextType}`\n\t\t);\n\t\tmessagingService.setupActivityTracking();\n\t} else {\n\t\tlog.info(\n\t\t\t`[Messaging - initializeUiContext] Skipping activity tracking for non-protected context: ${actualContextType}`\n\t\t);\n\t}\n}\n\n/**\n * Start activity tracking after successful login (only for protected contexts)\n */\nexport async function startActivityTracking(contextType?: string): Promise<void> {\n\tif (!isBrowser) return;\n\n\tconst actualContextType = contextType || determineBestContextType();\n\n\tlog.info(`[Messaging - startActivityTracking] 🚀 STARTING ACTIVITY TRACKING:`, false, {\n\t\tprovidedContextType: contextType,\n\t\tactualContextType,\n\t\tisProtectedContext: contextNeedsIdleProtection(actualContextType),\n\t\texpectedProtectedTypes: protectedContexts,\n\t\tisBrowser: isBrowser,\n\t\tmessagingServiceExists: !!messagingService\n\t});\n\n\t// Only start activity tracking for protected contexts\n\tif (!contextNeedsIdleProtection(actualContextType)) {\n\t\tlog.warn(`[Messaging - startActivityTracking] ❌ SKIPPING - not a protected context:`, false, {\n\t\t\tcontextType: actualContextType,\n\t\t\tprotectedContexts,\n\t\t\treason: 'Context type not in protected contexts list'\n\t\t});\n\t\treturn;\n\t}\n\n\tlog.info(\n\t\t`[Messaging - startActivityTracking] 🔐 Setting login verified for protected context: ${actualContextType}`\n\t);\n\n\ttry {\n\t\t// Verify the login - this should trigger idle detection\n\t\tawait messagingService.setLoginVerified(true, actualContextType);\n\t\tlog.info(`[Messaging - startActivityTracking] ✅ Login verification message sent successfully`);\n\t} catch (error) {\n\t\tlog.error(\n\t\t\t`[Messaging - startActivityTracking] ❌ ERROR sending login verification:`,\n\t\t\tfalse,\n\t\t\terror\n\t\t);\n\t\tthrow error;\n\t}\n\n\ttry {\n\t\t// Ensure activity tracking is set up - should have been called in +layout.svelte at route level\n\t\tmessagingService.setupActivityTracking();\n\t\tlog.info(`[Messaging - startActivityTracking] ✅ Activity tracking setup completed`);\n\t} catch (error) {\n\t\tlog.error(\n\t\t\t`[Messaging - startActivityTracking] ❌ ERROR setting up activity tracking:`,\n\t\t\tfalse,\n\t\t\terror\n\t\t);\n\t}\n\n\tlog.info(\n\t\t`[Messaging - startActivityTracking] 🎉 ACTIVITY TRACKING STARTED for protected context: ${actualContextType}`\n\t);\n}\n\n/**\n * Stop activity tracking (e.g., at logout) (only for protected contexts)\n */\nexport async function stopActivityTracking(): Promise<void> {\n\tif (!isBrowser) return;\n\n\tconst contextType = determineBestContextType();\n\n\t// Only stop activity tracking for protected contexts\n\tif (!contextNeedsIdleProtection(contextType)) {\n\t\tlog.info(\n\t\t\t`[Messaging - stopActivityTracking] Skipping activity tracking stop for non-protected context: ${contextType}`\n\t\t);\n\t\treturn;\n\t}\n\n\tawait messagingService.setLoginVerified(false);\n\n\tlog.info(\n\t\t`[Messaging - stopActivityTracking] Activity tracking stopped for protected context: ${contextType}`\n\t);\n}\n\n/**\n * Get the context ID for this client instance\n */\nexport function getContextId(): string {\n\tif (\n\t\ttypeof window !== 'undefined' &&\n\t\twindow.EXTENSION_INIT_STATE &&\n\t\twindow.EXTENSION_INIT_STATE.contextId\n\t) {\n\t\treturn window.EXTENSION_INIT_STATE.contextId;\n\t}\n\treturn '';\n}\n\n/**\n * Apply this messaging utility to a global error handler\n * @param handler The error handler function or class\n */\nexport function hookErrorHandler(handler: any): void {\n\tif (!isBrowser || typeof handler.handleError !== 'function') {\n\t\treturn;\n\t}\n\n\t// Store original method\n\tconst originalHandleError = handler.handleError;\n\n\t// Override with our version\n\thandler.handleError = function (error: any) {\n\t\ttry {\n\t\t\t// Send error to background with context info\n\t\t\tmessagingService\n\t\t\t\t.sendMessage(\n\t\t\t\t\t'error_report',\n\t\t\t\t\t{\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\tmessage: error?.message || String(error),\n\t\t\t\t\t\t\tstack: error?.stack,\n\t\t\t\t\t\t\tname: error?.name\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlocation: typeof window !== 'undefined' ? window.location.href : 'unknown',\n\t\t\t\t\t\ttimestamp: Date.now()\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tpriority: 'high',\n\t\t\t\t\t\tretryOnFail: true\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t\t.catch(() => {\n\t\t\t\t\t// Silently fail - don't want errors in error handler\n\t\t\t\t});\n\t\t} catch (e) {\n\t\t\t// Ignore errors in our error handler\n\t\t}\n\n\t\t// Call original handler\n\t\treturn originalHandleError.call(handler, error);\n\t};\n}\n\nexport default messagingService;\n"],"names":["ExtensionMessaging","static","messageQueue","Map","processedResponses","isProcessing","retryCount","MAX_RETRIES","RETRY_DELAY","browserApi","contextId","pendingRequests","timerManager","UnifiedTimerManager","getInstance","FIRE_AND_FORGET_MESSAGES","instance","initialize","browserExtensionApi","sendCleanupMessage","type","data","source","handleIncomingMessage","message","sender","sendResponse","responseId","result","error","pendingRequest","this","get","reject","resolve","delete","set","timestamp","Date","now","sendMessage","options","Promise","processQueue","cleanup","messageId","request","entries","Error","response","getContextId","isInitialized","triggerActivityDetection","registerUiContext","contextType","sendActivityUpdate","setLoginVerified","verified","log","warn","isBrowser","hasBrowserApi","getContextType","window","pathname","location","href","includes","setupActivityTracking","messagingService","async","startActivityTracking","stopActivityTracking"],"mappings":"sIAeA,MAAMA,mBACLC,gBACQC,iBAAuCC,IACvCC,uBAAyBD,IACzBE,aAAwB,MACxBC,eAAsCH,IACtCI,YAAc,EACdC,YAAc,IACdC,WAA6B,KAC7BC,UAAoB,GACpBC,oBAAsBR,IAQtBS,aAAeC,oBAAoBC,cAG1BC,yBAA2B,CAC3C,cACA,yBACA,sBACA,qBACA,qBACA,gBACA,4BACA,qBACA,8BACA,sBACA,4BACA,0BACA,qBAMD,kBAAcD,GACT,IAACd,mBAAmBgB,SAAU,CACdhB,mBAAAgB,SAAW,IAAIhB,kBAAmB,CAEtD,OAAOA,mBAAmBgB,QAAA,CAOpB,UAAAC,CAAWC,qBACD,MAgBmC,CAMpD,wBAAaC,CACZC,KACAC,KAAY,CAAA,EACZC,OAAiB,WAEmB,MA4BpC,CAMO,qBAAAC,CACPC,QACAC,OACAC,cAGA,IAAKF,UAAYA,QAAQG,WAAmB,OAAA,KAE5C,MAAMA,WAAEA,WAAAC,OAAYA,OAAQC,MAAAA,OAAUL,QAGtC,MAAMM,eAAiBC,KAAKpB,gBAAgBqB,IAAIL,YAChD,GAAIG,eAAgB,CACnB,GAAID,MAAO,CACVC,eAAeG,OAAOJ,MAAK,KACrB,CACNC,eAAeI,QAAQN,OAAM,CAIzBG,KAAApB,gBAAgBwB,OAAOR,YAGvBI,KAAA3B,mBAAmBgC,IAAIT,WAAY,CACvCU,UAAWC,KAAKC,MAChBX,OAAQC,OAASD,QACjB,CAEK,OAAA,IAAA,CAUR,iBAAaY,CACZpB,KACAC,KAAY,CAAA,EACZoB,QAOI,CAAA,GAEY,CAER,OAAAC,QAAQR,QAAQ,KAAI,CA0G3B,CAMF,kBAAcS,GAC4C,MA8EzD,CAMO,OAAAC,GACD,MAAAL,IAAMD,KAAKC,MAGjB,IAAA,MAAYM,UAAWC,WAAYf,KAAKpB,gBAAgBoC,UAAW,CAC9D,GAAAR,IAAMO,QAAQT,UAAY,IAAO,CACpCS,QAAQb,OAAO,IAAIe,MAAM,sBACpBjB,KAAApB,gBAAgBwB,OAAOU,UAAS,CACtC,CAID,IAAA,MAAYA,UAAWI,YAAalB,KAAK3B,mBAAmB2C,UAAW,CAClE,GAAAR,IAAMU,SAASZ,UAAY,IAAQ,CACjCN,KAAA3B,mBAAmB+B,OAAOU,UAAS,CACzC,CACD,CAMO,YAAAK,GA4BP,OAAOnB,KAAKrB,SAAA,CAON,aAAAyC,GACN,OAAOpB,KAAKtB,aAAe,IAAA,CAMrB,wBAAA2C,GAC2C,MAUjD,CAMD,uBAAaC,CAAkBC,aACM,MAyCpC,CAMD,wBAAaC,GACwB,MA2BpC,CAMD,sBAAaC,CAAiBC,SAAmBH,aACZ,CAC/BI,IAAAC,KAAK,8DAA+D,MAAO,CAAAC,UAC9EA,QACAC,gBAAiB9B,KAAKtB,WACtBgD,kBACAH,0BAED,MAAA,CA2DD,CAMO,cAAAQ,GACH,IACH,IAAKF,gBAAoBG,SAAW,YAAoB,MAAA,UAElD,MAAAC,SAAWD,OAAOE,SAASD,SAC3B,MAAAE,KAAOH,OAAOE,SAASC,KAE7B,GAAIF,SAASG,SAAS,cAAgBD,KAAKC,SAAS,aAAc,CAC1D,MAAA,WAEP,MAAA,GAAAH,SAASG,SAAS,eAClBD,KAAKC,SAAS,eACdH,WAAa,KACbA,WAAa,GACZ,CACM,MAAA,cAAA,MAAA,GACGA,SAASG,SAAS,gBAAkBD,KAAKC,SAAS,eAAgB,CACrE,MAAA,YAAA,MAAA,GACGH,SAASG,SAAS,YAAcD,KAAKC,SAAS,WAAY,CAC7D,MAAA,SAAA,KACD,CACC,MAAA,cAAA,QAEAtC,OACD,MAAA,SAAA,CACR,CAMM,qBAAAuC,GAC2C,MAwFjD,EAKW,MAAAC,iBAAmBrE,mBAAmBc,cA+FnDwD,eAAsBC,sBAAsBjB,aAC3B,MAuDjB,CAKAgB,eAAsBE,uBACL,MAiBjB"}