{"version":3,"file":"UnifiedTimerManager.js","sources":["../../../../src/lib/managers/UnifiedTimerManager.ts"],"sourcesContent":["import { log } from '$lib/managers/Logger';\n\ntype TimerCallback = () => void;\ntype DebouncedFunction<T extends (...args: any[]) => void> = T & { cancel: () => void };\n\n// Use ReturnType to get the actual return type of setTimeout/setInterval in the current environment\ntype TimerId = ReturnType<typeof setTimeout>;\n\nexport interface Timer {\n\tid: string;\n\tcallback: TimerCallback;\n\tduration: number;\n\thandle: TimerId | null;\n\ttype: 'interval' | 'timeout';\n}\n\n// Simple singleton pattern - no events needed for service worker compatibility\n\nexport class UnifiedTimerManager {\n\tprivate intervals: Map<string, Timer> = new Map();\n\tprivate timeouts: Map<string, Timer> = new Map();\n\tprivate static instance: UnifiedTimerManager | null = null;\n\n\tconstructor() {\n\t\tif (UnifiedTimerManager.instance) {\n\t\t\treturn UnifiedTimerManager.instance;\n\t\t}\n\t\tUnifiedTimerManager.instance = this;\n\t}\n\n\tpublic static getInstance(): UnifiedTimerManager {\n\t\treturn UnifiedTimerManager.instance ?? new UnifiedTimerManager();\n\t}\n\n\tpublic static clearInstance(): void {\n\t\tif (this.instance) {\n\t\t\tthis.instance.clearAll();\n\t\t}\n\t\tthis.instance = null;\n\t}\n\n\tpublic static resetInstance(): UnifiedTimerManager {\n\t\tthis.clearInstance();\n\t\treturn this.getInstance();\n\t}\n\n\t// Interval methods\n\taddInterval(id: string, callback: TimerCallback, duration: number): void {\n\t\tif (this.intervals.has(id)) {\n\t\t\tlog.warn(`Interval \"${id}\" already exists.`);\n\t\t\treturn;\n\t\t}\n\t\tthis.intervals.set(id, { id, callback, duration, handle: null, type: 'interval' });\n\t}\n\n\tstartInterval(id: string, immediate = false): void {\n\t\tconst timer = this.intervals.get(id);\n\t\tif (!timer) return log.error(`Interval \"${id}\" not found.`);\n\t\tif (timer.handle) return log.warn(`Interval \"${id}\" is already running.`);\n\n\t\tif (immediate) {\n\t\t\ttimer.callback();\n\t\t}\n\t\ttimer.handle = setInterval(timer.callback, timer.duration);\n\t}\n\n\tstopInterval(id: string): void {\n\t\tconst timer = this.intervals.get(id);\n\t\tif (!timer) return log.warn(`Interval \"${id}\" not found.`);\n\t\tif (!timer.handle) return log.warn(`Interval \"${id}\" is not running.`);\n\n\t\tclearInterval(timer.handle);\n\t\ttimer.handle = null;\n\t}\n\n\tremoveInterval(id: string): void {\n\t\tthis.stopInterval(id);\n\t\tthis.intervals.delete(id);\n\t}\n\n\t// Timeout methods\n\taddTimeout(id: string, callback: TimerCallback, duration: number): void {\n\t\tif (this.timeouts.has(id)) {\n\t\t\tlog.warn(`Timeout \"${id}\" already exists.`);\n\t\t\treturn;\n\t\t}\n\t\tthis.timeouts.set(id, { id, callback, duration, handle: null, type: 'timeout' });\n\t}\n\n\tstartTimeout(id: string): void {\n\t\tconst timer = this.timeouts.get(id);\n\t\tif (!timer) return log.error(`Timeout \"${id}\" not found.`);\n\t\tif (timer.handle) return log.warn(`Timeout \"${id}\" is already running.`);\n\n\t\ttimer.handle = setTimeout(() => {\n\t\t\ttimer.callback();\n\t\t\ttimer.handle = null;\n\t\t}, timer.duration);\n\t}\n\n\tstopTimeout(id: string): void {\n\t\tconst timer = this.timeouts.get(id);\n\t\tif (!timer) return log.warn(`Timeout \"${id}\" not found.`);\n\t\tif (!timer.handle) return log.warn(`Timeout \"${id}\" is not running.`);\n\n\t\tclearTimeout(timer.handle);\n\t\ttimer.handle = null;\n\t}\n\n\tremoveTimeout(id: string): void {\n\t\tthis.stopTimeout(id);\n\t\tthis.timeouts.delete(id);\n\t}\n\n\t// Utility methods\n\tclearAll(): void {\n\t\t// Stop all intervals\n\t\tthis.intervals.forEach((_, id) => this.stopInterval(id));\n\t\tthis.intervals.clear();\n\n\t\t// Stop all timeouts\n\t\tthis.timeouts.forEach((_, id) => this.stopTimeout(id));\n\t\tthis.timeouts.clear();\n\t}\n\n\tgetRunningTimers(): { intervals: string[]; timeouts: string[] } {\n\t\tconst intervals = Array.from(this.intervals.entries())\n\t\t\t.filter(([_, timer]) => timer.handle !== null)\n\t\t\t.map(([id]) => id);\n\n\t\tconst timeouts = Array.from(this.timeouts.entries())\n\t\t\t.filter(([_, timer]) => timer.handle !== null)\n\t\t\t.map(([id]) => id);\n\n\t\treturn { intervals, timeouts };\n\t}\n\n\tisIntervalRunning(id: string): boolean {\n\t\treturn !!this.intervals.get(id)?.handle;\n\t}\n\n\tisTimeoutRunning(id: string): boolean {\n\t\treturn !!this.timeouts.get(id)?.handle;\n\t}\n\n\t// Backward compatibility methods (delegates to interval methods)\n\taddTimer(id: string, callback: TimerCallback, duration: number): void {\n\t\tthis.addInterval(id, callback, duration);\n\t}\n\n\tstartTimer(id: string): void {\n\t\tthis.startInterval(id);\n\t}\n\n\tstopTimer(id: string): void {\n\t\tthis.stopInterval(id);\n\t}\n\n\tremoveTimer(id: string): void {\n\t\tthis.removeInterval(id);\n\t}\n\n\thasTimer(id: string): boolean {\n\t\treturn this.intervals.has(id);\n\t}\n\n\tisRunning(id: string): boolean {\n\t\treturn this.isIntervalRunning(id);\n\t}\n\n\t// Debounce utility\n\tstatic createDebounce<T extends (...args: any[]) => void>(\n\t\tfunc: T,\n\t\tdelay: number\n\t): DebouncedFunction<T> {\n\t\tlet timeoutId: TimerId | null = null;\n\n\t\tconst debounced = ((...args: Parameters<T>) => {\n\t\t\tif (timeoutId) {\n\t\t\t\tclearTimeout(timeoutId);\n\t\t\t}\n\t\t\ttimeoutId = setTimeout(() => {\n\t\t\t\tfunc(...args);\n\t\t\t\ttimeoutId = null;\n\t\t\t}, delay);\n\t\t}) as DebouncedFunction<T>;\n\n\t\tdebounced.cancel = () => {\n\t\t\tif (timeoutId) {\n\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\ttimeoutId = null;\n\t\t\t}\n\t\t};\n\n\t\treturn debounced;\n\t}\n\n\t// Throttle utility\n\tstatic createThrottle<T extends (...args: any[]) => void>(func: T, limit: number): T {\n\t\tlet inThrottle = false;\n\n\t\treturn ((...args: Parameters<T>) => {\n\t\t\tif (!inThrottle) {\n\t\t\t\tfunc(...args);\n\t\t\t\tinThrottle = true;\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tinThrottle = false;\n\t\t\t\t}, limit);\n\t\t\t}\n\t\t}) as T;\n\t}\n}\n\n// Singleton instance\nexport const unifiedTimerManager = UnifiedTimerManager.getInstance();\n"],"names":["UnifiedTimerManager","intervals","Map","timeouts","static","constructor","instance","this","getInstance","clearInstance","clearAll","resetInstance","addInterval","id","callback","duration","has","log","warn","set","handle","type","startInterval","immediate","timer","get","error","setInterval","stopInterval","clearInterval","removeInterval","delete","addTimeout","startTimeout","setTimeout","stopTimeout","clearTimeout","removeTimeout","forEach","_","clear","getRunningTimers","Array","from","entries","filter","map","isIntervalRunning","isTimeoutRunning","addTimer","startTimer","stopTimer","removeTimer","hasTimer","isRunning","createDebounce","func","delay","timeoutId","debounced","args","cancel","createThrottle","limit","inThrottle"],"mappings":"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"}