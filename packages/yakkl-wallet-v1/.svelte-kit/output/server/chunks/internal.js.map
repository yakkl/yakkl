{"version":3,"file":"internal.js","sources":["../../../../../../node_modules/.pnpm/@sveltejs+kit@2.21.5_@sveltejs+vite-plugin-svelte@5.1.0_svelte@5.34.3_vite@6.3.5_@types+node@_kkg52bulj3afeke4e35iads2tm/node_modules/@sveltejs/kit/src/runtime/shared-server.js","../../../../../../node_modules/.pnpm/svelte@5.34.3/node_modules/svelte/src/internal/client/dom/hydration.js","../../../../../../node_modules/.pnpm/svelte@5.34.3/node_modules/svelte/src/internal/client/dom/elements/events.js","../../../../../../node_modules/.pnpm/svelte@5.34.3/node_modules/svelte/src/internal/client/dom/template.js","../../../../../../node_modules/.pnpm/svelte@5.34.3/node_modules/svelte/src/internal/client/render.js","../../../../../../node_modules/.pnpm/svelte@5.34.3/node_modules/svelte/src/legacy/legacy-client.js","../../../../../../node_modules/.pnpm/svelte@5.34.3/node_modules/svelte/src/legacy/legacy-server.js","../../../generated/root.svelte","../../../generated/root.js","../../../generated/server/internal.js"],"sourcesContent":["/**\n * `$env/dynamic/private`\n * @type {Record<string, string>}\n */\nexport let private_env = {};\n\n/**\n * `$env/dynamic/public`. When prerendering, this will be a proxy that forbids reads\n * @type {Record<string, string>}\n */\nexport let public_env = {};\n\n/**\n * The same as `public_env`, but without the proxy. Use for `%sveltekit.env.PUBLIC_FOO%`\n * @type {Record<string, string>}\n */\nexport let safe_public_env = {};\n\n/** @param {any} error */\nexport let fix_stack_trace = (error) => error?.stack;\n\n/** @type {(environment: Record<string, string>) => void} */\nexport function set_private_env(environment) {\n\tprivate_env = environment;\n}\n\n/** @type {(environment: Record<string, string>) => void} */\nexport function set_public_env(environment) {\n\tpublic_env = environment;\n}\n\n/** @type {(environment: Record<string, string>) => void} */\nexport function set_safe_public_env(environment) {\n\tsafe_public_env = environment;\n}\n\n/** @param {(error: Error) => string} value */\nexport function set_fix_stack_trace(value) {\n\tfix_stack_trace = value;\n}\n","/** @import { TemplateNode } from '#client' */\n\nimport {\n\tHYDRATION_END,\n\tHYDRATION_ERROR,\n\tHYDRATION_START,\n\tHYDRATION_START_ELSE\n} from '../../../constants.js';\nimport * as w from '../warnings.js';\nimport { get_next_sibling } from './operations.js';\n\n/**\n * Use this variable to guard everything related to hydration code so it can be treeshaken out\n * if the user doesn't use the `hydrate` method and these code paths are therefore not needed.\n */\nexport let hydrating = false;\n\n/** @param {boolean} value */\nexport function set_hydrating(value) {\n\thydrating = value;\n}\n\n/**\n * The node that is currently being hydrated. This starts out as the first node inside the opening\n * <!--[--> comment, and updates each time a component calls `$.child(...)` or `$.sibling(...)`.\n * When entering a block (e.g. `{#if ...}`), `hydrate_node` is the block opening comment; by the\n * time we leave the block it is the closing comment, which serves as the block's anchor.\n * @type {TemplateNode}\n */\nexport let hydrate_node;\n\n/** @param {TemplateNode} node */\nexport function set_hydrate_node(node) {\n\tif (node === null) {\n\t\tw.hydration_mismatch();\n\t\tthrow HYDRATION_ERROR;\n\t}\n\n\treturn (hydrate_node = node);\n}\n\nexport function hydrate_next() {\n\treturn set_hydrate_node(/** @type {TemplateNode} */ (get_next_sibling(hydrate_node)));\n}\n\n/** @param {TemplateNode} node */\nexport function reset(node) {\n\tif (!hydrating) return;\n\n\t// If the node has remaining siblings, something has gone wrong\n\tif (get_next_sibling(hydrate_node) !== null) {\n\t\tw.hydration_mismatch();\n\t\tthrow HYDRATION_ERROR;\n\t}\n\n\thydrate_node = node;\n}\n\n/**\n * @param {HTMLTemplateElement} template\n */\nexport function hydrate_template(template) {\n\tif (hydrating) {\n\t\t// @ts-expect-error TemplateNode doesn't include DocumentFragment, but it's actually fine\n\t\thydrate_node = template.content;\n\t}\n}\n\nexport function next(count = 1) {\n\tif (hydrating) {\n\t\tvar i = count;\n\t\tvar node = hydrate_node;\n\n\t\twhile (i--) {\n\t\t\tnode = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\t}\n\n\t\thydrate_node = node;\n\t}\n}\n\n/**\n * Removes all nodes starting at `hydrate_node` up until the next hydration end comment\n */\nexport function remove_nodes() {\n\tvar depth = 0;\n\tvar node = hydrate_node;\n\n\twhile (true) {\n\t\tif (node.nodeType === 8) {\n\t\t\tvar data = /** @type {Comment} */ (node).data;\n\n\t\t\tif (data === HYDRATION_END) {\n\t\t\t\tif (depth === 0) return node;\n\t\t\t\tdepth -= 1;\n\t\t\t} else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {\n\t\t\t\tdepth += 1;\n\t\t\t}\n\t\t}\n\n\t\tvar next = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\tnode.remove();\n\t\tnode = next;\n\t}\n}\n\n/**\n *\n * @param {TemplateNode} node\n */\nexport function read_hydration_instruction(node) {\n\tif (!node || node.nodeType !== 8) {\n\t\tw.hydration_mismatch();\n\t\tthrow HYDRATION_ERROR;\n\t}\n\n\treturn /** @type {Comment} */ (node).data;\n}\n","import { teardown } from '../../reactivity/effects.js';\nimport { define_property, is_array } from '../../../shared/utils.js';\nimport { hydrating } from '../hydration.js';\nimport { queue_micro_task } from '../task.js';\nimport { FILENAME } from '../../../../constants.js';\nimport * as w from '../../warnings.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tset_active_effect,\n\tset_active_reaction\n} from '../../runtime.js';\nimport { without_reactive_context } from './bindings/shared.js';\n\n/** @type {Set<string>} */\nexport const all_registered_events = new Set();\n\n/** @type {Set<(events: Array<string>) => void>} */\nexport const root_event_handles = new Set();\n\n/**\n * SSR adds onload and onerror attributes to catch those events before the hydration.\n * This function detects those cases, removes the attributes and replays the events.\n * @param {HTMLElement} dom\n */\nexport function replay_events(dom) {\n\tif (!hydrating) return;\n\n\tdom.removeAttribute('onload');\n\tdom.removeAttribute('onerror');\n\t// @ts-expect-error\n\tconst event = dom.__e;\n\tif (event !== undefined) {\n\t\t// @ts-expect-error\n\t\tdom.__e = undefined;\n\t\tqueueMicrotask(() => {\n\t\t\tif (dom.isConnected) {\n\t\t\t\tdom.dispatchEvent(event);\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * @param {string} event_name\n * @param {EventTarget} dom\n * @param {EventListener} [handler]\n * @param {AddEventListenerOptions} [options]\n */\nexport function create_event(event_name, dom, handler, options = {}) {\n\t/**\n\t * @this {EventTarget}\n\t */\n\tfunction target_handler(/** @type {Event} */ event) {\n\t\tif (!options.capture) {\n\t\t\t// Only call in the bubble phase, else delegated events would be called before the capturing events\n\t\t\thandle_event_propagation.call(dom, event);\n\t\t}\n\t\tif (!event.cancelBubble) {\n\t\t\treturn without_reactive_context(() => {\n\t\t\t\treturn handler?.call(this, event);\n\t\t\t});\n\t\t}\n\t}\n\n\t// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned\n\t// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we\n\t// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes\n\t// this bug. The same applies to wheel events and touch events.\n\tif (\n\t\tevent_name.startsWith('pointer') ||\n\t\tevent_name.startsWith('touch') ||\n\t\tevent_name === 'wheel'\n\t) {\n\t\tqueue_micro_task(() => {\n\t\t\tdom.addEventListener(event_name, target_handler, options);\n\t\t});\n\t} else {\n\t\tdom.addEventListener(event_name, target_handler, options);\n\t}\n\n\treturn target_handler;\n}\n\n/**\n * Attaches an event handler to an element and returns a function that removes the handler. Using this\n * rather than `addEventListener` will preserve the correct order relative to handlers added declaratively\n * (with attributes like `onclick`), which use event delegation for performance reasons\n *\n * @param {EventTarget} element\n * @param {string} type\n * @param {EventListener} handler\n * @param {AddEventListenerOptions} [options]\n */\nexport function on(element, type, handler, options = {}) {\n\tvar target_handler = create_event(type, element, handler, options);\n\n\treturn () => {\n\t\telement.removeEventListener(type, target_handler, options);\n\t};\n}\n\n/**\n * @param {string} event_name\n * @param {Element} dom\n * @param {EventListener} [handler]\n * @param {boolean} [capture]\n * @param {boolean} [passive]\n * @returns {void}\n */\nexport function event(event_name, dom, handler, capture, passive) {\n\tvar options = { capture, passive };\n\tvar target_handler = create_event(event_name, dom, handler, options);\n\n\tif (\n\t\tdom === document.body ||\n\t\t// @ts-ignore\n\t\tdom === window ||\n\t\t// @ts-ignore\n\t\tdom === document ||\n\t\t// Firefox has quirky behavior, it can happen that we still get \"canplay\" events when the element is already removed\n\t\tdom instanceof HTMLMediaElement\n\t) {\n\t\tteardown(() => {\n\t\t\tdom.removeEventListener(event_name, target_handler, options);\n\t\t});\n\t}\n}\n\n/**\n * @param {Array<string>} events\n * @returns {void}\n */\nexport function delegate(events) {\n\tfor (var i = 0; i < events.length; i++) {\n\t\tall_registered_events.add(events[i]);\n\t}\n\n\tfor (var fn of root_event_handles) {\n\t\tfn(events);\n\t}\n}\n\n/**\n * @this {EventTarget}\n * @param {Event} event\n * @returns {void}\n */\nexport function handle_event_propagation(event) {\n\tvar handler_element = this;\n\tvar owner_document = /** @type {Node} */ (handler_element).ownerDocument;\n\tvar event_name = event.type;\n\tvar path = event.composedPath?.() || [];\n\tvar current_target = /** @type {null | Element} */ (path[0] || event.target);\n\n\t// composedPath contains list of nodes the event has propagated through.\n\t// We check __root to skip all nodes below it in case this is a\n\t// parent of the __root node, which indicates that there's nested\n\t// mounted apps. In this case we don't want to trigger events multiple times.\n\tvar path_idx = 0;\n\n\t// @ts-expect-error is added below\n\tvar handled_at = event.__root;\n\n\tif (handled_at) {\n\t\tvar at_idx = path.indexOf(handled_at);\n\t\tif (\n\t\t\tat_idx !== -1 &&\n\t\t\t(handler_element === document || handler_element === /** @type {any} */ (window))\n\t\t) {\n\t\t\t// This is the fallback document listener or a window listener, but the event was already handled\n\t\t\t// -> ignore, but set handle_at to document/window so that we're resetting the event\n\t\t\t// chain in case someone manually dispatches the same event object again.\n\t\t\t// @ts-expect-error\n\t\t\tevent.__root = handler_element;\n\t\t\treturn;\n\t\t}\n\n\t\t// We're deliberately not skipping if the index is higher, because\n\t\t// someone could create an event programmatically and emit it multiple times,\n\t\t// in which case we want to handle the whole propagation chain properly each time.\n\t\t// (this will only be a false negative if the event is dispatched multiple times and\n\t\t// the fallback document listener isn't reached in between, but that's super rare)\n\t\tvar handler_idx = path.indexOf(handler_element);\n\t\tif (handler_idx === -1) {\n\t\t\t// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)\n\t\t\t// so guard against that, too, and assume that everything was handled at this point.\n\t\t\treturn;\n\t\t}\n\n\t\tif (at_idx <= handler_idx) {\n\t\t\tpath_idx = at_idx;\n\t\t}\n\t}\n\n\tcurrent_target = /** @type {Element} */ (path[path_idx] || event.target);\n\t// there can only be one delegated event per element, and we either already handled the current target,\n\t// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe\n\t// to handle a possible delegated event on it later (through the root delegation listener for example).\n\tif (current_target === handler_element) return;\n\n\t// Proxy currentTarget to correct target\n\tdefine_property(event, 'currentTarget', {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn current_target || owner_document;\n\t\t}\n\t});\n\n\t// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,\n\t// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic\n\t// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,\n\t// it's probably best that all event handled by Svelte have this behaviour, as we don't really want\n\t// an event handler to run in the context of another reaction or effect.\n\tvar previous_reaction = active_reaction;\n\tvar previous_effect = active_effect;\n\tset_active_reaction(null);\n\tset_active_effect(null);\n\n\ttry {\n\t\t/**\n\t\t * @type {unknown}\n\t\t */\n\t\tvar throw_error;\n\t\t/**\n\t\t * @type {unknown[]}\n\t\t */\n\t\tvar other_errors = [];\n\n\t\twhile (current_target !== null) {\n\t\t\t/** @type {null | Element} */\n\t\t\tvar parent_element =\n\t\t\t\tcurrent_target.assignedSlot ||\n\t\t\t\tcurrent_target.parentNode ||\n\t\t\t\t/** @type {any} */ (current_target).host ||\n\t\t\t\tnull;\n\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvar delegated = current_target['__' + event_name];\n\n\t\t\t\tif (\n\t\t\t\t\tdelegated != null &&\n\t\t\t\t\t(!(/** @type {any} */ (current_target).disabled) ||\n\t\t\t\t\t\t// DOM could've been updated already by the time this is reached, so we check this as well\n\t\t\t\t\t\t// -> the target could not have been disabled because it emits the event in the first place\n\t\t\t\t\t\tevent.target === current_target)\n\t\t\t\t) {\n\t\t\t\t\tif (is_array(delegated)) {\n\t\t\t\t\t\tvar [fn, ...data] = delegated;\n\t\t\t\t\t\tfn.apply(current_target, [event, ...data]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelegated.call(current_target, event);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (throw_error) {\n\t\t\t\t\tother_errors.push(error);\n\t\t\t\t} else {\n\t\t\t\t\tthrow_error = error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (event.cancelBubble || parent_element === handler_element || parent_element === null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_target = parent_element;\n\t\t}\n\n\t\tif (throw_error) {\n\t\t\tfor (let error of other_errors) {\n\t\t\t\t// Throw the rest of the errors, one-by-one on a microtask\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t\t}\n\t\t\tthrow throw_error;\n\t\t}\n\t} finally {\n\t\t// @ts-expect-error is used above\n\t\tevent.__root = handler_element;\n\t\t// @ts-ignore remove proxy on currentTarget\n\t\tdelete event.currentTarget;\n\t\tset_active_reaction(previous_reaction);\n\t\tset_active_effect(previous_effect);\n\t}\n}\n\n/**\n * In dev, warn if an event handler is not a function, as it means the\n * user probably called the handler or forgot to add a `() =>`\n * @param {() => (event: Event, ...args: any) => void} thunk\n * @param {EventTarget} element\n * @param {[Event, ...any]} args\n * @param {any} component\n * @param {[number, number]} [loc]\n * @param {boolean} [remove_parens]\n */\nexport function apply(\n\tthunk,\n\telement,\n\targs,\n\tcomponent,\n\tloc,\n\thas_side_effects = false,\n\tremove_parens = false\n) {\n\tlet handler;\n\tlet error;\n\n\ttry {\n\t\thandler = thunk();\n\t} catch (e) {\n\t\terror = e;\n\t}\n\n\tif (typeof handler !== 'function' && (has_side_effects || handler != null || error)) {\n\t\tconst filename = component?.[FILENAME];\n\t\tconst location = loc ? ` at ${filename}:${loc[0]}:${loc[1]}` : ` in ${filename}`;\n\t\tconst phase = args[0]?.eventPhase < Event.BUBBLING_PHASE ? 'capture' : '';\n\t\tconst event_name = args[0]?.type + phase;\n\t\tconst description = `\\`${event_name}\\` handler${location}`;\n\t\tconst suggestion = remove_parens ? 'remove the trailing `()`' : 'add a leading `() =>`';\n\n\t\tw.event_handler_invalid(description, suggestion);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\t}\n\thandler?.apply(element, args);\n}\n","/** @import { Effect, TemplateNode } from '#client' */\n/** @import { TemplateStructure } from './types' */\nimport { hydrate_next, hydrate_node, hydrating, set_hydrate_node } from './hydration.js';\nimport {\n\tcreate_text,\n\tget_first_child,\n\tis_firefox,\n\tcreate_element,\n\tcreate_fragment,\n\tcreate_comment,\n\tset_attribute\n} from './operations.js';\nimport { create_fragment_from_html } from './reconciler.js';\nimport { active_effect } from '../runtime.js';\nimport {\n\tNAMESPACE_MATHML,\n\tNAMESPACE_SVG,\n\tTEMPLATE_FRAGMENT,\n\tTEMPLATE_USE_IMPORT_NODE,\n\tTEMPLATE_USE_MATHML,\n\tTEMPLATE_USE_SVG\n} from '../../../constants.js';\n\n/**\n * @param {TemplateNode} start\n * @param {TemplateNode | null} end\n */\nexport function assign_nodes(start, end) {\n\tvar effect = /** @type {Effect} */ (active_effect);\n\tif (effect.nodes_start === null) {\n\t\teffect.nodes_start = start;\n\t\teffect.nodes_end = end;\n\t}\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function from_html(content, flags) {\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;\n\n\t/** @type {Node} */\n\tvar node;\n\n\t/**\n\t * Whether or not the first item is a text/element node. If not, we need to\n\t * create an additional comment node to act as `effect.nodes.start`\n\t */\n\tvar has_start = !content.startsWith('<!>');\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (node === undefined) {\n\t\t\tnode = create_fragment_from_html(has_start ? content : '<!>' + content);\n\t\t\tif (!is_fragment) node = /** @type {Node} */ (get_first_child(node));\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (\n\t\t\tuse_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)\n\t\t);\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @param {'svg' | 'math'} ns\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nfunction from_namespace(content, flags, ns = 'svg') {\n\t/**\n\t * Whether or not the first item is a text/element node. If not, we need to\n\t * create an additional comment node to act as `effect.nodes.start`\n\t */\n\tvar has_start = !content.startsWith('<!>');\n\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar wrapped = `<${ns}>${has_start ? content : '<!>' + content}</${ns}>`;\n\n\t/** @type {Element | DocumentFragment} */\n\tvar node;\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (!node) {\n\t\t\tvar fragment = /** @type {DocumentFragment} */ (create_fragment_from_html(wrapped));\n\t\t\tvar root = /** @type {Element} */ (get_first_child(fragment));\n\n\t\t\tif (is_fragment) {\n\t\t\t\tnode = document.createDocumentFragment();\n\t\t\t\twhile (get_first_child(root)) {\n\t\t\t\t\tnode.appendChild(/** @type {Node} */ (get_first_child(root)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = /** @type {Element} */ (get_first_child(root));\n\t\t\t}\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (node.cloneNode(true));\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function from_svg(content, flags) {\n\treturn from_namespace(content, flags, 'svg');\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function from_mathml(content, flags) {\n\treturn from_namespace(content, flags, 'math');\n}\n\n/**\n * @param {TemplateStructure[]} structure\n * @param {NAMESPACE_SVG | NAMESPACE_MATHML | undefined} [ns]\n */\nfunction fragment_from_tree(structure, ns) {\n\tvar fragment = create_fragment();\n\n\tfor (var item of structure) {\n\t\tif (typeof item === 'string') {\n\t\t\tfragment.append(create_text(item));\n\t\t\tcontinue;\n\t\t}\n\n\t\t// if `preserveComments === true`, comments are represented as `['// <data>']`\n\t\tif (item === undefined || item[0][0] === '/') {\n\t\t\tfragment.append(create_comment(item ? item[0].slice(3) : ''));\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst [name, attributes, ...children] = item;\n\n\t\tconst namespace = name === 'svg' ? NAMESPACE_SVG : name === 'math' ? NAMESPACE_MATHML : ns;\n\n\t\tvar element = create_element(name, namespace, attributes?.is);\n\n\t\tfor (var key in attributes) {\n\t\t\tset_attribute(element, key, attributes[key]);\n\t\t}\n\n\t\tif (children.length > 0) {\n\t\t\tvar target =\n\t\t\t\telement.tagName === 'TEMPLATE'\n\t\t\t\t\t? /** @type {HTMLTemplateElement} */ (element).content\n\t\t\t\t\t: element;\n\n\t\t\ttarget.append(\n\t\t\t\tfragment_from_tree(children, element.tagName === 'foreignObject' ? undefined : namespace)\n\t\t\t);\n\t\t}\n\n\t\tfragment.append(element);\n\t}\n\n\treturn fragment;\n}\n\n/**\n * @param {TemplateStructure[]} structure\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function from_tree(structure, flags) {\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;\n\n\t/** @type {Node} */\n\tvar node;\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (node === undefined) {\n\t\t\tconst ns =\n\t\t\t\t(flags & TEMPLATE_USE_SVG) !== 0\n\t\t\t\t\t? NAMESPACE_SVG\n\t\t\t\t\t: (flags & TEMPLATE_USE_MATHML) !== 0\n\t\t\t\t\t\t? NAMESPACE_MATHML\n\t\t\t\t\t\t: undefined;\n\n\t\t\tnode = fragment_from_tree(structure, ns);\n\t\t\tif (!is_fragment) node = /** @type {Node} */ (get_first_child(node));\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (\n\t\t\tuse_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)\n\t\t);\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {() => Element | DocumentFragment} fn\n */\nexport function with_script(fn) {\n\treturn () => run_scripts(fn());\n}\n\n/**\n * Creating a document fragment from HTML that contains script tags will not execute\n * the scripts. We need to replace the script tags with new ones so that they are executed.\n * @param {Element | DocumentFragment} node\n * @returns {Node | Node[]}\n */\nfunction run_scripts(node) {\n\t// scripts were SSR'd, in which case they will run\n\tif (hydrating) return node;\n\n\tconst is_fragment = node.nodeType === 11;\n\tconst scripts =\n\t\t/** @type {HTMLElement} */ (node).tagName === 'SCRIPT'\n\t\t\t? [/** @type {HTMLScriptElement} */ (node)]\n\t\t\t: node.querySelectorAll('script');\n\tconst effect = /** @type {Effect} */ (active_effect);\n\n\tfor (const script of scripts) {\n\t\tconst clone = document.createElement('script');\n\t\tfor (var attribute of script.attributes) {\n\t\t\tclone.setAttribute(attribute.name, attribute.value);\n\t\t}\n\n\t\tclone.textContent = script.textContent;\n\n\t\t// The script has changed - if it's at the edges, the effect now points at dead nodes\n\t\tif (is_fragment ? node.firstChild === script : node === script) {\n\t\t\teffect.nodes_start = clone;\n\t\t}\n\t\tif (is_fragment ? node.lastChild === script : node === script) {\n\t\t\teffect.nodes_end = clone;\n\t\t}\n\n\t\tscript.replaceWith(clone);\n\t}\n\treturn node;\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @param {any} value\n */\nexport function text(value = '') {\n\tif (!hydrating) {\n\t\tvar t = create_text(value + '');\n\t\tassign_nodes(t, t);\n\t\treturn t;\n\t}\n\n\tvar node = hydrate_node;\n\n\tif (node.nodeType !== 3) {\n\t\t// if an {expression} is empty during SSR, we need to insert an empty text node\n\t\tnode.before((node = create_text()));\n\t\tset_hydrate_node(node);\n\t}\n\n\tassign_nodes(node, node);\n\treturn node;\n}\n\nexport function comment() {\n\t// we're not delegating to `template` here for performance reasons\n\tif (hydrating) {\n\t\tassign_nodes(hydrate_node, null);\n\t\treturn hydrate_node;\n\t}\n\n\tvar frag = document.createDocumentFragment();\n\tvar start = document.createComment('');\n\tvar anchor = create_text();\n\tfrag.append(start, anchor);\n\n\tassign_nodes(start, anchor);\n\n\treturn frag;\n}\n\n/**\n * Assign the created (or in hydration mode, traversed) dom elements to the current block\n * and insert the elements into the dom (in client mode).\n * @param {Text | Comment | Element} anchor\n * @param {DocumentFragment | Element} dom\n */\nexport function append(anchor, dom) {\n\tif (hydrating) {\n\t\t/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;\n\t\thydrate_next();\n\t\treturn;\n\t}\n\n\tif (anchor === null) {\n\t\t// edge case — void `<svelte:element>` with content\n\t\treturn;\n\t}\n\n\tanchor.before(/** @type {Node} */ (dom));\n}\n\n/**\n * Create (or hydrate) an unique UID for the component instance.\n */\nexport function props_id() {\n\tif (\n\t\thydrating &&\n\t\thydrate_node &&\n\t\thydrate_node.nodeType === 8 &&\n\t\thydrate_node.textContent?.startsWith(`#`)\n\t) {\n\t\tconst id = hydrate_node.textContent.substring(1);\n\t\thydrate_next();\n\t\treturn id;\n\t}\n\n\t// @ts-expect-error This way we ensure the id is unique even across Svelte runtimes\n\t(window.__svelte ??= {}).uid ??= 1;\n\n\t// @ts-expect-error\n\treturn `c${window.__svelte.uid++}`;\n}\n","/** @import { ComponentContext, Effect, TemplateNode } from '#client' */\n/** @import { Component, ComponentType, SvelteComponent, MountOptions } from '../../index.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tclear_text_content,\n\tcreate_text,\n\tget_first_child,\n\tget_next_sibling,\n\tinit_operations\n} from './dom/operations.js';\nimport { HYDRATION_END, HYDRATION_ERROR, HYDRATION_START } from '../../constants.js';\nimport { active_effect } from './runtime.js';\nimport { push, pop, component_context } from './context.js';\nimport { component_root, branch } from './reactivity/effects.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tset_hydrate_node,\n\tset_hydrating\n} from './dom/hydration.js';\nimport { array_from } from '../shared/utils.js';\nimport {\n\tall_registered_events,\n\thandle_event_propagation,\n\troot_event_handles\n} from './dom/elements/events.js';\nimport { reset_head_anchor } from './dom/blocks/svelte-head.js';\nimport * as w from './warnings.js';\nimport * as e from './errors.js';\nimport { assign_nodes } from './dom/template.js';\nimport { is_passive_event } from '../../utils.js';\n\n/**\n * This is normally true — block effects should run their intro transitions —\n * but is false during hydration (unless `options.intro` is `true`) and\n * when creating the children of a `<svelte:element>` that just changed tag\n */\nexport let should_intro = true;\n\n/** @param {boolean} value */\nexport function set_should_intro(value) {\n\tshould_intro = value;\n}\n\n/**\n * @param {Element} text\n * @param {string} value\n * @returns {void}\n */\nexport function set_text(text, value) {\n\t// For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing\n\tvar str = value == null ? '' : typeof value === 'object' ? value + '' : value;\n\t// @ts-expect-error\n\tif (str !== (text.__t ??= text.nodeValue)) {\n\t\t// @ts-expect-error\n\t\ttext.__t = str;\n\t\ttext.nodeValue = str + '';\n\t}\n}\n\n/**\n * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component.\n * Transitions will play during the initial render unless the `intro` option is set to `false`.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component\n * @param {MountOptions<Props>} options\n * @returns {Exports}\n */\nexport function mount(component, options) {\n\treturn _mount(component, options);\n}\n\n/**\n * Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component\n * @param {{} extends Props ? {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops?: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\trecover?: boolean;\n * \t} : {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\trecover?: boolean;\n * \t}} options\n * @returns {Exports}\n */\nexport function hydrate(component, options) {\n\tinit_operations();\n\toptions.intro = options.intro ?? false;\n\tconst target = options.target;\n\tconst was_hydrating = hydrating;\n\tconst previous_hydrate_node = hydrate_node;\n\n\ttry {\n\t\tvar anchor = /** @type {TemplateNode} */ (get_first_child(target));\n\t\twhile (\n\t\t\tanchor &&\n\t\t\t(anchor.nodeType !== 8 || /** @type {Comment} */ (anchor).data !== HYDRATION_START)\n\t\t) {\n\t\t\tanchor = /** @type {TemplateNode} */ (get_next_sibling(anchor));\n\t\t}\n\n\t\tif (!anchor) {\n\t\t\tthrow HYDRATION_ERROR;\n\t\t}\n\n\t\tset_hydrating(true);\n\t\tset_hydrate_node(/** @type {Comment} */ (anchor));\n\t\thydrate_next();\n\n\t\tconst instance = _mount(component, { ...options, anchor });\n\n\t\tif (\n\t\t\thydrate_node === null ||\n\t\t\thydrate_node.nodeType !== 8 ||\n\t\t\t/** @type {Comment} */ (hydrate_node).data !== HYDRATION_END\n\t\t) {\n\t\t\tw.hydration_mismatch();\n\t\t\tthrow HYDRATION_ERROR;\n\t\t}\n\n\t\tset_hydrating(false);\n\n\t\treturn /**  @type {Exports} */ (instance);\n\t} catch (error) {\n\t\tif (error === HYDRATION_ERROR) {\n\t\t\tif (options.recover === false) {\n\t\t\t\te.hydration_failed();\n\t\t\t}\n\n\t\t\t// If an error occured above, the operations might not yet have been initialised.\n\t\t\tinit_operations();\n\t\t\tclear_text_content(target);\n\n\t\t\tset_hydrating(false);\n\t\t\treturn mount(component, options);\n\t\t}\n\n\t\tthrow error;\n\t} finally {\n\t\tset_hydrating(was_hydrating);\n\t\tset_hydrate_node(previous_hydrate_node);\n\t\treset_head_anchor();\n\t}\n}\n\n/** @type {Map<string, number>} */\nconst document_listeners = new Map();\n\n/**\n * @template {Record<string, any>} Exports\n * @param {ComponentType<SvelteComponent<any>> | Component<any>} Component\n * @param {MountOptions} options\n * @returns {Exports}\n */\nfunction _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {\n\tinit_operations();\n\n\tvar registered_events = new Set();\n\n\t/** @param {Array<string>} events */\n\tvar event_handle = (events) => {\n\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\tvar event_name = events[i];\n\n\t\t\tif (registered_events.has(event_name)) continue;\n\t\t\tregistered_events.add(event_name);\n\n\t\t\tvar passive = is_passive_event(event_name);\n\n\t\t\t// Add the event listener to both the container and the document.\n\t\t\t// The container listener ensures we catch events from within in case\n\t\t\t// the outer content stops propagation of the event.\n\t\t\ttarget.addEventListener(event_name, handle_event_propagation, { passive });\n\n\t\t\tvar n = document_listeners.get(event_name);\n\n\t\t\tif (n === undefined) {\n\t\t\t\t// The document listener ensures we catch events that originate from elements that were\n\t\t\t\t// manually moved outside of the container (e.g. via manual portals).\n\t\t\t\tdocument.addEventListener(event_name, handle_event_propagation, { passive });\n\t\t\t\tdocument_listeners.set(event_name, 1);\n\t\t\t} else {\n\t\t\t\tdocument_listeners.set(event_name, n + 1);\n\t\t\t}\n\t\t}\n\t};\n\n\tevent_handle(array_from(all_registered_events));\n\troot_event_handles.add(event_handle);\n\n\t/** @type {Exports} */\n\t// @ts-expect-error will be defined because the render effect runs synchronously\n\tvar component = undefined;\n\n\tvar unmount = component_root(() => {\n\t\tvar anchor_node = anchor ?? target.appendChild(create_text());\n\n\t\tbranch(() => {\n\t\t\tif (context) {\n\t\t\t\tpush({});\n\t\t\t\tvar ctx = /** @type {ComponentContext} */ (component_context);\n\t\t\t\tctx.c = context;\n\t\t\t}\n\n\t\t\tif (events) {\n\t\t\t\t// We can't spread the object or else we'd lose the state proxy stuff, if it is one\n\t\t\t\t/** @type {any} */ (props).$$events = events;\n\t\t\t}\n\n\t\t\tif (hydrating) {\n\t\t\t\tassign_nodes(/** @type {TemplateNode} */ (anchor_node), null);\n\t\t\t}\n\n\t\t\tshould_intro = intro;\n\t\t\t// @ts-expect-error the public typings are not what the actual function looks like\n\t\t\tcomponent = Component(anchor_node, props) || {};\n\t\t\tshould_intro = true;\n\n\t\t\tif (hydrating) {\n\t\t\t\t/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;\n\t\t\t}\n\n\t\t\tif (context) {\n\t\t\t\tpop();\n\t\t\t}\n\t\t});\n\n\t\treturn () => {\n\t\t\tfor (var event_name of registered_events) {\n\t\t\t\ttarget.removeEventListener(event_name, handle_event_propagation);\n\n\t\t\t\tvar n = /** @type {number} */ (document_listeners.get(event_name));\n\n\t\t\t\tif (--n === 0) {\n\t\t\t\t\tdocument.removeEventListener(event_name, handle_event_propagation);\n\t\t\t\t\tdocument_listeners.delete(event_name);\n\t\t\t\t} else {\n\t\t\t\t\tdocument_listeners.set(event_name, n);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\troot_event_handles.delete(event_handle);\n\n\t\t\tif (anchor_node !== anchor) {\n\t\t\t\tanchor_node.parentNode?.removeChild(anchor_node);\n\t\t\t}\n\t\t};\n\t});\n\n\tmounted_components.set(component, unmount);\n\treturn component;\n}\n\n/**\n * References of the components that were mounted or hydrated.\n * Uses a `WeakMap` to avoid memory leaks.\n */\nlet mounted_components = new WeakMap();\n\n/**\n * Unmounts a component that was previously mounted using `mount` or `hydrate`.\n *\n * Since 5.13.0, if `options.outro` is `true`, [transitions](https://svelte.dev/docs/svelte/transition) will play before the component is removed from the DOM.\n *\n * Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).\n *\n * ```js\n * import { mount, unmount } from 'svelte';\n * import App from './App.svelte';\n *\n * const app = mount(App, { target: document.body });\n *\n * // later...\n * unmount(app, { outro: true });\n * ```\n * @param {Record<string, any>} component\n * @param {{ outro?: boolean }} [options]\n * @returns {Promise<void>}\n */\nexport function unmount(component, options) {\n\tconst fn = mounted_components.get(component);\n\n\tif (fn) {\n\t\tmounted_components.delete(component);\n\t\treturn fn(options);\n\t}\n\n\tif (DEV) {\n\t\tw.lifecycle_double_unmount();\n\t}\n\n\treturn Promise.resolve();\n}\n","/** @import { ComponentConstructorOptions, ComponentType, SvelteComponent, Component } from 'svelte' */\nimport { DIRTY, LEGACY_PROPS, MAYBE_DIRTY } from '../internal/client/constants.js';\nimport { user_pre_effect } from '../internal/client/reactivity/effects.js';\nimport { mutable_source, set } from '../internal/client/reactivity/sources.js';\nimport { hydrate, mount, unmount } from '../internal/client/render.js';\nimport { active_effect, flushSync, get, set_signal_status } from '../internal/client/runtime.js';\nimport { lifecycle_outside_component } from '../internal/shared/errors.js';\nimport { define_property, is_array } from '../internal/shared/utils.js';\nimport * as w from '../internal/client/warnings.js';\nimport { DEV } from 'esm-env';\nimport { FILENAME } from '../constants.js';\nimport { component_context, dev_current_component_function } from '../internal/client/context.js';\n\n/**\n * Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.\n *\n * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @template {Record<string, any>} Events\n * @template {Record<string, any>} Slots\n *\n * @param {ComponentConstructorOptions<Props> & {\n * \tcomponent: ComponentType<SvelteComponent<Props, Events, Slots>> | Component<Props>;\n * }} options\n * @returns {SvelteComponent<Props, Events, Slots> & Exports}\n */\nexport function createClassComponent(options) {\n\t// @ts-expect-error $$prop_def etc are not actually defined\n\treturn new Svelte4Component(options);\n}\n\n/**\n * Takes the component function and returns a Svelte 4 compatible component constructor.\n *\n * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @template {Record<string, any>} Events\n * @template {Record<string, any>} Slots\n *\n * @param {SvelteComponent<Props, Events, Slots> | Component<Props>} component\n * @returns {ComponentType<SvelteComponent<Props, Events, Slots> & Exports>}\n */\nexport function asClassComponent(component) {\n\t// @ts-expect-error $$prop_def etc are not actually defined\n\treturn class extends Svelte4Component {\n\t\t/** @param {any} options */\n\t\tconstructor(options) {\n\t\t\tsuper({\n\t\t\t\tcomponent,\n\t\t\t\t...options\n\t\t\t});\n\t\t}\n\t};\n}\n\n/**\n * Support using the component as both a class and function during the transition period\n * @typedef  {{new (o: ComponentConstructorOptions): SvelteComponent;(...args: Parameters<Component<Record<string, any>>>): ReturnType<Component<Record<string, any>, Record<string, any>>>;}} LegacyComponentType\n */\n\nclass Svelte4Component {\n\t/** @type {any} */\n\t#events;\n\n\t/** @type {Record<string, any>} */\n\t#instance;\n\n\t/**\n\t * @param {ComponentConstructorOptions & {\n\t *  component: any;\n\t * }} options\n\t */\n\tconstructor(options) {\n\t\tvar sources = new Map();\n\n\t\t/**\n\t\t * @param {string | symbol} key\n\t\t * @param {unknown} value\n\t\t */\n\t\tvar add_source = (key, value) => {\n\t\t\tvar s = mutable_source(value, false, false);\n\t\t\tsources.set(key, s);\n\t\t\treturn s;\n\t\t};\n\n\t\t// Replicate coarse-grained props through a proxy that has a version source for\n\t\t// each property, which is incremented on updates to the property itself. Do not\n\t\t// use our $state proxy because that one has fine-grained reactivity.\n\t\tconst props = new Proxy(\n\t\t\t{ ...(options.props || {}), $$events: {} },\n\t\t\t{\n\t\t\t\tget(target, prop) {\n\t\t\t\t\treturn get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));\n\t\t\t\t},\n\t\t\t\thas(target, prop) {\n\t\t\t\t\t// Necessary to not throw \"invalid binding\" validation errors on the component side\n\t\t\t\t\tif (prop === LEGACY_PROPS) return true;\n\n\t\t\t\t\tget(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));\n\t\t\t\t\treturn Reflect.has(target, prop);\n\t\t\t\t},\n\t\t\t\tset(target, prop, value) {\n\t\t\t\t\tset(sources.get(prop) ?? add_source(prop, value), value);\n\t\t\t\t\treturn Reflect.set(target, prop, value);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tthis.#instance = (options.hydrate ? hydrate : mount)(options.component, {\n\t\t\ttarget: options.target,\n\t\t\tanchor: options.anchor,\n\t\t\tprops,\n\t\t\tcontext: options.context,\n\t\t\tintro: options.intro ?? false,\n\t\t\trecover: options.recover\n\t\t});\n\n\t\t// We don't flushSync for custom element wrappers or if the user doesn't want it\n\t\tif (!options?.props?.$$host || options.sync === false) {\n\t\t\tflushSync();\n\t\t}\n\n\t\tthis.#events = props.$$events;\n\n\t\tfor (const key of Object.keys(this.#instance)) {\n\t\t\tif (key === '$set' || key === '$destroy' || key === '$on') continue;\n\t\t\tdefine_property(this, key, {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.#instance[key];\n\t\t\t\t},\n\t\t\t\t/** @param {any} value */\n\t\t\t\tset(value) {\n\t\t\t\t\tthis.#instance[key] = value;\n\t\t\t\t},\n\t\t\t\tenumerable: true\n\t\t\t});\n\t\t}\n\n\t\tthis.#instance.$set = /** @param {Record<string, any>} next */ (next) => {\n\t\t\tObject.assign(props, next);\n\t\t};\n\n\t\tthis.#instance.$destroy = () => {\n\t\t\tunmount(this.#instance);\n\t\t};\n\t}\n\n\t/** @param {Record<string, any>} props */\n\t$set(props) {\n\t\tthis.#instance.$set(props);\n\t}\n\n\t/**\n\t * @param {string} event\n\t * @param {(...args: any[]) => any} callback\n\t * @returns {any}\n\t */\n\t$on(event, callback) {\n\t\tthis.#events[event] = this.#events[event] || [];\n\n\t\t/** @param {any[]} args */\n\t\tconst cb = (...args) => callback.call(this, ...args);\n\t\tthis.#events[event].push(cb);\n\t\treturn () => {\n\t\t\tthis.#events[event] = this.#events[event].filter(/** @param {any} fn */ (fn) => fn !== cb);\n\t\t};\n\t}\n\n\t$destroy() {\n\t\tthis.#instance.$destroy();\n\t}\n}\n\n/**\n * Runs the given function once immediately on the server, and works like `$effect.pre` on the client.\n *\n * @deprecated Use this only as a temporary solution to migrate your component code to Svelte 5.\n * @param {() => void | (() => void)} fn\n * @returns {void}\n */\nexport function run(fn) {\n\tuser_pre_effect(() => {\n\t\tfn();\n\t\tvar effect = /** @type {import('#client').Effect} */ (active_effect);\n\t\t// If the effect is immediately made dirty again, mark it as maybe dirty to emulate legacy behaviour\n\t\tif ((effect.f & DIRTY) !== 0) {\n\t\t\tlet filename = \"a file (we can't know which one)\";\n\t\t\tif (DEV) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tfilename = dev_current_component_function?.[FILENAME] ?? filename;\n\t\t\t}\n\t\t\tw.legacy_recursive_reactive_block(filename);\n\t\t\tset_signal_status(effect, MAYBE_DIRTY);\n\t\t}\n\t});\n}\n\n/**\n * Function to mimic the multiple listeners available in svelte 4\n * @deprecated\n * @param {EventListener[]} handlers\n * @returns {EventListener}\n */\nexport function handlers(...handlers) {\n\treturn function (event) {\n\t\tconst { stopImmediatePropagation } = event;\n\t\tlet stopped = false;\n\n\t\tevent.stopImmediatePropagation = () => {\n\t\t\tstopped = true;\n\t\t\tstopImmediatePropagation.call(event);\n\t\t};\n\n\t\tconst errors = [];\n\n\t\tfor (const handler of handlers) {\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error `this` is not typed\n\t\t\t\thandler?.call(this, event);\n\t\t\t} catch (e) {\n\t\t\t\terrors.push(e);\n\t\t\t}\n\n\t\t\tif (stopped) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (let error of errors) {\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tthrow error;\n\t\t\t});\n\t\t}\n\t};\n}\n\n/**\n * Function to create a `bubble` function that mimic the behavior of `on:click` without handler available in svelte 4.\n * @deprecated Use this only as a temporary solution to migrate your automatically delegated events in Svelte 5.\n */\nexport function createBubbler() {\n\tconst active_component_context = component_context;\n\tif (active_component_context === null) {\n\t\tlifecycle_outside_component('createBubbler');\n\t}\n\n\treturn (/**@type {string}*/ type) => (/**@type {Event}*/ event) => {\n\t\tconst events = /** @type {Record<string, Function | Function[]>} */ (\n\t\t\tactive_component_context.s.$$events\n\t\t)?.[/** @type {any} */ (type)];\n\n\t\tif (events) {\n\t\t\tconst callbacks = is_array(events) ? events.slice() : [events];\n\t\t\tfor (const fn of callbacks) {\n\t\t\t\tfn.call(active_component_context.x, event);\n\t\t\t}\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\t\treturn true;\n\t};\n}\n\nexport {\n\tonce,\n\tpreventDefault,\n\tself,\n\tstopImmediatePropagation,\n\tstopPropagation,\n\ttrusted,\n\tpassive,\n\tnonpassive\n} from '../internal/client/dom/legacy/event-modifiers.js';\n","/** @import { SvelteComponent } from '../index.js' */\nimport { asClassComponent as as_class_component, createClassComponent } from './legacy-client.js';\nimport { render } from '../internal/server/index.js';\n\n// By having this as a separate entry point for server environments, we save the client bundle from having to include the server runtime\n\nexport { createClassComponent };\n\n/**\n * Takes a Svelte 5 component and returns a Svelte 4 compatible component constructor.\n *\n * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @template {Record<string, any>} Events\n * @template {Record<string, any>} Slots\n *\n * @param {SvelteComponent<Props, Events, Slots>} component\n * @returns {typeof SvelteComponent<Props, Events, Slots> & Exports}\n */\nexport function asClassComponent(component) {\n\tconst component_constructor = as_class_component(component);\n\t/** @type {(props?: {}, opts?: { $$slots?: {}; context?: Map<any, any>; }) => { html: any; css: { code: string; map: any; }; head: string; } } */\n\tconst _render = (props, { context } = {}) => {\n\t\t// @ts-expect-error the typings are off, but this will work if the component is compiled in SSR mode\n\t\tconst result = render(component, { props, context });\n\t\treturn {\n\t\t\tcss: { code: '', map: null },\n\t\t\thead: result.head,\n\t\t\thtml: result.body\n\t\t};\n\t};\n\t// @ts-expect-error this is present for SSR\n\tcomponent_constructor.render = _render;\n\n\t// @ts-ignore\n\treturn component_constructor;\n}\n\n/**\n * Runs the given function once immediately on the server, and works like `$effect.pre` on the client.\n *\n * @deprecated Use this only as a temporary solution to migrate your component code to Svelte 5.\n * @param {() => void | (() => void)} fn\n * @returns {void}\n */\nexport function run(fn) {\n\tfn();\n}\n\nconst noop = () => {};\n\n// event stuff, no need to worry about it for SSR but needs to be there or it will crash\nexport {\n\tnoop as handlers,\n\tnoop as createBubbler,\n\tnoop as once,\n\tnoop as preventDefault,\n\tnoop as self,\n\tnoop as stopImmediatePropagation,\n\tnoop as stopPropagation,\n\tnoop as trusted,\n\tnoop as passive,\n\tnoop as nonpassive\n};\n","<!-- This file is generated by @sveltejs/kit — do not edit it! -->\n<svelte:options runes={true} />\n<script>\n\timport { setContext, onMount, tick } from 'svelte';\n\timport { browser } from '$app/environment';\n\n\t// stores\n\tlet { stores, page, constructors, components = [], form, data_0 = null, data_1 = null, data_2 = null, data_3 = null } = $props();\n\n\tif (!browser) {\n\t\tsetContext('__svelte__', stores);\n\t}\n\n\tif (browser) {\n\t\t$effect.pre(() => stores.page.set(page));\n\t} else {\n\t\tstores.page.set(page);\n\t}\n\t$effect(() => {\n\t\tstores;page;constructors;components;form;data_0;data_1;data_2;data_3;\n\t\tstores.page.notify();\n\t});\n\n\tlet mounted = $state(false);\n\tlet navigated = $state(false);\n\tlet title = $state(null);\n\n\tonMount(() => {\n\t\tconst unsubscribe = stores.page.subscribe(() => {\n\t\t\tif (mounted) {\n\t\t\t\tnavigated = true;\n\t\t\t\ttick().then(() => {\n\t\t\t\t\ttitle = document.title || 'untitled page';\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tmounted = true;\n\t\treturn unsubscribe;\n\t});\n\n\tconst Pyramid_3=$derived(constructors[3])\n</script>\n\n{#if constructors[1]}\n\t{@const Pyramid_0 = constructors[0]}\n\t\t\t\t\t\t\t<!-- svelte-ignore binding_property_non_reactive -->\n\t\t\t\t\t\t\t<Pyramid_0 bind:this={components[0]} data={data_0} {form}>\n\t\t\t\t\t\t\t\t{#if constructors[2]}\n\t\t\t\t\t\t\t\t\t{@const Pyramid_1 = constructors[1]}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- svelte-ignore binding_property_non_reactive -->\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<Pyramid_1 bind:this={components[1]} data={data_1} {form}>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{#if constructors[3]}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{@const Pyramid_2 = constructors[2]}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- svelte-ignore binding_property_non_reactive -->\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<Pyramid_2 bind:this={components[2]} data={data_2} {form}>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- svelte-ignore binding_property_non_reactive -->\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<Pyramid_3 bind:this={components[3]} data={data_3} {form} />\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</Pyramid_2>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{:else}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{@const Pyramid_2 = constructors[2]}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- svelte-ignore binding_property_non_reactive -->\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<Pyramid_2 bind:this={components[2]} data={data_2} {form} />\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</Pyramid_1>\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t{:else}\n\t\t\t\t\t\t\t\t\t{@const Pyramid_1 = constructors[1]}\n\t\t\t\t\t\t\t\t\t<!-- svelte-ignore binding_property_non_reactive -->\n\t\t\t\t\t\t\t\t\t<Pyramid_1 bind:this={components[1]} data={data_1} {form} />\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t\t</Pyramid_0>\n\t\n{:else}\n\t{@const Pyramid_0 = constructors[0]}\n\t<!-- svelte-ignore binding_property_non_reactive -->\n\t<Pyramid_0 bind:this={components[0]} data={data_0} {form} />\n\t\n{/if}\n\n{#if mounted}\n\t<div id=\"svelte-announcer\" aria-live=\"assertive\" aria-atomic=\"true\" style=\"position: absolute; left: 0; top: 0; clip: rect(0 0 0 0); clip-path: inset(50%); overflow: hidden; white-space: nowrap; width: 1px; height: 1px\">\n\t\t{#if navigated}\n\t\t\t{title}\n\t\t{/if}\n\t</div>\n{/if}","import { asClassComponent } from 'svelte/legacy';\nimport Root from './root.svelte';\nexport default asClassComponent(Root);","\nimport root from '../root.js';\nimport { set_building, set_prerendering } from '__sveltekit/environment';\nimport { set_assets } from '__sveltekit/paths';\nimport { set_manifest, set_read_implementation } from '__sveltekit/server';\nimport { set_private_env, set_public_env, set_safe_public_env } from '../../../../../node_modules/.pnpm/@sveltejs+kit@2.21.5_@sveltejs+vite-plugin-svelte@5.1.0_svelte@5.34.3_vite@6.3.5_@types+node@_kkg52bulj3afeke4e35iads2tm/node_modules/@sveltejs/kit/src/runtime/shared-server.js';\n\nexport const options = {\n\tapp_template_contains_nonce: false,\n\tcsp: {\"mode\":\"auto\",\"directives\":{\"upgrade-insecure-requests\":false,\"block-all-mixed-content\":false},\"reportOnly\":{\"upgrade-insecure-requests\":false,\"block-all-mixed-content\":false}},\n\tcsrf_check_origin: true,\n\tembedded: false,\n\tenv_public_prefix: 'PUBLIC_',\n\tenv_private_prefix: '',\n\thash_routing: false,\n\thooks: null, // added lazily, via `get_hooks`\n\tpreload_strategy: \"modulepreload\",\n\troot,\n\tservice_worker: false,\n\ttemplates: {\n\t\tapp: ({ head, body, assets, nonce, env }) => \"<!doctype html>\\n<html\\n\\tlang=\\\"en\\\"\\n\\tclass=\\\"h-full bg-base-100 no-js dark\\\"\\n\\tstyle=\\\"overscroll-behavior-x: none\\\"\\n\\tdata-theme=\\\"yakkl\\\"\\n>\\n\\t<!-- <html lang=\\\"en\\\" class=\\\"h-full bg-base-100 bg-dotted-spacing-1 bg-dotted-gray-600 no-js dark\\\" style=\\\"overscroll-behavior-x: none;\\\" data-theme=\\\"yakkl\\\"> -->\\n\\t<head>\\n\\t\\t<!-- <meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html\\\" charset=\\\"utf-8\\\" /> -->\\n\\n\\t\\t<meta charset=\\\"utf-8\\\" />\\n\\t\\t<meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge,chrome=1\\\" />\\n\\t\\t<meta\\n\\t\\t\\tname=\\\"viewport\\\"\\n\\t\\t\\tcontent=\\\"width=device-width, initial-scale=1.0, shrink-to-fit=no, viewport-fit=cover\\\"\\n\\t\\t/>\\n\\n\\t\\t<!-- <meta http-equiv=\\\"content-security-policy\\\" content=\\\"script-src 'self' ; script-src-elem 'self' \\\"> -->\\n\\n\\t\\t<link rel=\\\"shortcut icon\\\" href=\\\"/images/favicon.png\\\" />\\n\\t\\t<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"/css/inter.css\\\" />\\n\\n\\t\\t<script src=\\\"/ext/browser-polyfill.js\\\"></script>\\n\\n\\t\\t<style>\\n\\t\\t\\t@media print {\\n\\t\\t\\t\\t@page {\\n\\t\\t\\t\\t\\tmargin-top: 0;\\n\\t\\t\\t\\t\\tmargin-bottom: 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbody {\\n\\t\\t\\t\\t\\tpadding-top: 72px;\\n\\t\\t\\t\\t\\tpadding-bottom: 72px;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t/* Turns off spinners on number inputs */\\n\\t\\t\\tinput::-webkit-outer-spin-button,\\n\\t\\t\\tinput::-webkit-inner-spin-button {\\n\\t\\t\\t\\t-webkit-appearance: none;\\n\\t\\t\\t\\tmargin: 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\t/*\\n\\t\\tinput[type=number]{\\n\\t\\t\\t-moz-appearance: textfield;\\n\\t\\t}\\n\\t\\t*/\\n\\n\\t\\t\\t::-webkit-scrollbar {\\n\\t\\t\\t\\tdisplay: none;\\n\\t\\t\\t}\\n\\n\\t\\t\\tbody {\\n\\t\\t\\t\\t-ms-overflow-style: none; /* IE and Edge */\\n\\t\\t\\t\\tscrollbar-width: none; /* Firefox */\\n\\t\\t\\t}\\n\\t\\t</style>\\n\\n\\t\\t\" + head + \"\\n\\t</head>\\n\\t<!-- For sidepanel -->\\n\\t<body\\n\\t\\tstyle=\\\"resize: none; overflow: hidden\\\"\\n\\t\\tclass=\\\"text-base-content font-inter antialiased h-full w-full overscroll-hidden selection:bg-fuchsia-300 selection:text-fuchsia-900\\\"\\n\\t>\\n\\t\\t<!-- For popup-->\\n\\t\\t<!-- <body style=\\\"resize: none; overflow: hidden;\\\" class=\\\"text-base-content font-inter antialiased min-h-[926px] min-w-[428px] max-h-[926px] max-w-[428px] selection:bg-fuchsia-300 selection:text-fuchsia-900\\\"> -->\\n\\n\\t\\t<div id=\\\"sk-body\\\" style=\\\"display: contents\\\">\" + body + \"</div>\\n\\n\\t\\t<!-- <script src=\\\"/js/errorHandler.js\\\"></script> -->\\n\\t\\t<script src=\\\"/js/helpers.js\\\"></script>\\n\\t\\t<script src=\\\"/js/fontawesome-8d8e5192b2.js\\\"></script>\\n\\t\\t<script src=\\\"/js/darkmode.js\\\"></script>\\n\\t\\t<script src=\\\"/js/clipboard.min.js\\\"></script>\\n\\t\\t<script src=\\\"/js/index.min.js\\\"></script>\\n\\t\\t<script src=\\\"/js/popper.min.js\\\"></script>\\n\\t\\t<script src=\\\"/js/console.js\\\"></script>\\n\\t\\t<!-- <script src=\\\"/js/in/in.js\\\" type=\\\"text/javascript\\\">lang: en_US</script> -->\\n\\t\\t<!-- <script src=\\\"js/fb/sdk.js\\\"></script> -->\\n\\t</body>\\n</html>\\n\",\n\t\terror: ({ status, message }) => \"<h1>Fallback Error</h1>\\n<p>Code \" + status + \"</p>\\n<p>\" + message + \"</p>\\n\"\n\t},\n\tversion_hash: \"jgwjpy\"\n};\n\nexport async function get_hooks() {\n\tlet handle;\n\tlet handleFetch;\n\tlet handleError;\n\tlet init;\n\t\n\n\tlet reroute;\n\tlet transport;\n\t\n\n\treturn {\n\t\thandle,\n\t\thandleFetch,\n\t\thandleError,\n\t\tinit,\n\t\treroute,\n\t\ttransport\n\t};\n}\n\nexport { set_assets, set_building, set_manifest, set_prerendering, set_private_env, set_public_env, set_read_implementation, set_safe_public_env };\n"],"names":["public_env","safe_public_env","set_private_env","environment","set_public_env","set_safe_public_env","hydrating","set_hydrating","value","hydrate_node","set_hydrate_node","node","hydration_mismatch","HYDRATION_ERROR","hydrate_next","get_next_sibling","all_registered_events","Set","root_event_handles","handle_event_propagation","event","handler_element","this","owner_document","event_name","type","path","composedPath","current_target","target","path_idx","handled_at","__root","at_idx","indexOf","document","window","handler_idx","define_property","configurable","get","previous_reaction","active_reaction","previous_effect","active_effect","set_active_reaction","set_active_effect","throw_error","other_errors","parent_element","assignedSlot","parentNode","host","delegated","disabled","is_array","fn","data","apply","call","error","push","cancelBubble","queueMicrotask","currentTarget","assign_nodes","start","end","effect","nodes_start","nodes_end","mount","component","options","_mount","hydrate","init_operations","intro","was_hydrating","previous_hydrate_node","anchor","get_first_child","nodeType","HYDRATION_START","instance","HYDRATION_END","recover","hydration_failed","clear_text_content","document_listeners","Map","Component","props","events","context","registered_events","event_handle","i","length","has","add","passive","is_passive_event","addEventListener","n","set","array_from","unmount","component_root","anchor_node","appendChild","create_text","branch","ctx","c","$$events","pop","removeEventListener","delete","removeChild","mounted_components","WeakMap","lifecycle_double_unmount","Promise","resolve","asClassComponent","Svelte4Component","constructor","super","sources","add_source","key","s","mutable_source","Proxy","prop","Reflect","LEGACY_PROPS","$$host","sync","flushSync","Object","keys","enumerable","$set","next","assign","$destroy","$on","callback","cb","args","filter","component_constructor","as_class_component","_render","result","render","css","code","map","head","html","body","stores","page","constructors","components","form","data_0","data_1","data_2","data_3","setContext","Pyramid_3","Pyramid_0","Pyramid_1","Pyramid_2","root","Root","app_template_contains_nonce","csp","mode","directives","reportOnly","csrf_check_origin","embedded","env_public_prefix","env_private_prefix","hash_routing","hooks","preload_strategy","service_worker","templates","app","assets","nonce","env","status","message","version_hash","async","get_hooks","handle","handleFetch","handleError","init","reroute","transport"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}