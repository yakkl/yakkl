{"version":3,"file":"EmergencyKitModal.js","sources":["../../../../src/lib/managers/EmergencyKitManager.ts","../../../../src/lib/components/EmergencyKit.svelte","../../../../src/lib/components/EmergencyKitModal.svelte"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { decryptData, encryptData, isEncryptedData, VERSION, type SaltedKey } from '$lib/common';\nimport type {\n\tEmergencyKitAccountData,\n\tEmergencyKitData,\n\tEmergencyKitMetaData,\n\tEncryptedData,\n\tYakklAccount,\n\tYakklPrimaryAccount,\n\tYakklContact,\n\tYakklConnectedDomain,\n\tPreferences,\n\tSettings,\n\tProfile,\n\tYakklWatch,\n\tYakklChat,\n\tYakklBlocked,\n\tProfileData,\n\tTokenData\n} from '$lib/common';\n\ninterface BulkEmergencyKitData {\n\tmeta: EmergencyKitMetaData;\n\tdata: {\n\t\tyakklPreferencesStore: EncryptedData;\n\t\tyakklSettingsStore: EncryptedData;\n\t\tprofileStore: EncryptedData;\n\t\tyakklCurrentlySelectedStore: EncryptedData;\n\t\tyakklContactsStore: EncryptedData;\n\t\tyakklChatsStore: EncryptedData;\n\t\tyakklAccountsStore: EncryptedData;\n\t\tyakklPrimaryAccountsStore: EncryptedData;\n\t\tyakklWatchListStore: EncryptedData;\n\t\tyakklBlockedListStore: EncryptedData;\n\t\tyakklConnectedDomainsStore: EncryptedData;\n\t\tyakklTokenDataStore: EncryptedData;\n\t\tyakklTokenDataCustomStore: EncryptedData;\n\t\tyakklCombinedTokenStore: EncryptedData;\n\t\tyakklWalletProvidersStore: EncryptedData;\n\t\tyakklWalletBlockchainsStore: EncryptedData;\n\t};\n\tcs: string;\n}\n\n// import * as fs from 'fs';\n// import { promisify } from 'util';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n// import * as path from 'path';\n// ADD other cloud/edge environment imports here\n// When ready to implement S3, uncomment the following line\n// import { S3 } from 'aws-sdk';\n// import { profile } from '../models/dataModels';\nimport {\n\tAccessSourceType,\n\tPlanType,\n\tPromoClassificationType,\n\tRegisteredType\n} from '../common/types';\nimport { log } from './Logger';\n// import type { Token } from './Token';\n// Then do: npm install aws-sdk\n\n// Note: Browser extension environment - Node.js modules not available\n// File operations are handled through browser File API only\n\nexport class EmergencyKitManager {\n\tstatic async createEmergencyKit(\n\t\taccountData: EmergencyKitAccountData[],\n\t\tencryptDownload: boolean,\n\t\tpasswordOrSaltedKey: string | SaltedKey\n\t): Promise<EmergencyKitData> {\n\t\tconst createDate = new Date().toISOString();\n\t\tconst updateDate = createDate;\n\t\tconst version = VERSION; // Your versioning logic\n\t\tconst id = this.generateId(); // Generate a unique ID for the kit\n\n\t\tconst encryptedAccounts = await Promise.all(\n\t\t\taccountData.map(async (account) => {\n\t\t\t\tconst checksum = await this.createHash(JSON.stringify(account)); //encodeJSON(account)); // JSON.stringify(account));\n\t\t\t\taccount.hash = checksum;\n\t\t\t\treturn encryptDownload ? await encryptData(account, passwordOrSaltedKey) : account;\n\t\t\t})\n\t\t);\n\n\t\tconst dataToEncrypt = JSON.stringify(encryptedAccounts); //encodeJSON(encryptedAccounts);// JSON.stringify(encryptedAccounts);\n\t\tconst encryptedData = encryptDownload\n\t\t\t? await encryptData(dataToEncrypt, passwordOrSaltedKey)\n\t\t\t: { data: dataToEncrypt, iv: '', salt: '' };\n\t\tconst overallChecksum = await this.createHash(dataToEncrypt);\n\n\t\tconst meta: EmergencyKitMetaData = {\n\t\t\tid,\n\t\t\tcreateDate,\n\t\t\tupdateDate,\n\t\t\tversion,\n\t\t\ttype: 'yakkl',\n\t\t\tportfolioName: accountData[0].portfolioName,\n\t\t\tsubPortfolioName: accountData[0].subPortfolioName || '',\n\t\t\tsubPortfolioAddress: accountData[0].subPortfolioAddress || '',\n\t\t\thash: overallChecksum,\n\t\t\tfiles: ['YakklAccount'],\n\t\t\tplan: {\n\t\t\t\ttype: accountData[0].registered.plan.type,\n\t\t\t\tsource: AccessSourceType.STANDARD,\n\t\t\t\tpromo: PromoClassificationType.INFLUENCER,\n\t\t\t\ttrialEndDate: '',\n\t\t\t\tupgradeDate: ''\n\t\t\t}\n\t\t};\n\n\t\tconst emergencyKit: EmergencyKitData = {\n\t\t\tid,\n\t\t\tdata: encryptedData as EncryptedData,\n\t\t\taccounts: encryptedAccounts as EmergencyKitAccountData[],\n\t\t\tmeta,\n\t\t\tcs: overallChecksum\n\t\t};\n\n\t\treturn emergencyKit;\n\t}\n\n\tstatic async createBulkEmergencyKit(\n\t\tpreferences: Preferences,\n\t\tsettings: Settings,\n\t\tprofile: Profile,\n\t\tcurrentlySelected: any,\n\t\tcontacts: YakklContact[],\n\t\tchats: YakklChat[],\n\t\taccounts: YakklAccount[],\n\t\tprimaryAccounts: YakklPrimaryAccount[],\n\t\twatchList: YakklWatch[],\n\t\tblockedList: YakklBlocked[],\n\t\tconnectedDomains: YakklConnectedDomain[],\n\t\tpasswordOrSaltedKey: string | SaltedKey,\n\t\ttokenData: TokenData[],\n\t\ttokenDataCustom: TokenData[],\n\t\tcombinedTokenStore: TokenData[],\n\t\twalletProviders: string[],\n\t\twalletBlockchains: string[]\n\t): Promise<BulkEmergencyKitData> {\n\t\tconst createDate = new Date().toISOString();\n\t\tconst id = this.generateId();\n\n\t\tconst encryptedData: BulkEmergencyKitData['data'] = {\n\t\t\tyakklPreferencesStore: await this.encryptWithChecksum(preferences, passwordOrSaltedKey),\n\t\t\tyakklSettingsStore: await this.encryptWithChecksum(settings, passwordOrSaltedKey),\n\t\t\tprofileStore: await this.encryptWithChecksum(profile, passwordOrSaltedKey),\n\t\t\tyakklCurrentlySelectedStore: await this.encryptWithChecksum(\n\t\t\t\tcurrentlySelected,\n\t\t\t\tpasswordOrSaltedKey\n\t\t\t),\n\t\t\tyakklContactsStore: await this.encryptWithChecksum(contacts, passwordOrSaltedKey),\n\t\t\tyakklChatsStore: await this.encryptWithChecksum(chats, passwordOrSaltedKey),\n\t\t\tyakklAccountsStore: await this.encryptWithChecksum(accounts, passwordOrSaltedKey),\n\t\t\tyakklPrimaryAccountsStore: await this.encryptWithChecksum(\n\t\t\t\tprimaryAccounts,\n\t\t\t\tpasswordOrSaltedKey\n\t\t\t),\n\t\t\tyakklWatchListStore: await this.encryptWithChecksum(watchList, passwordOrSaltedKey),\n\t\t\tyakklBlockedListStore: await this.encryptWithChecksum(blockedList, passwordOrSaltedKey),\n\t\t\tyakklConnectedDomainsStore: await this.encryptWithChecksum(\n\t\t\t\tconnectedDomains,\n\t\t\t\tpasswordOrSaltedKey\n\t\t\t),\n\t\t\tyakklTokenDataStore: await this.encryptWithChecksum(tokenData, passwordOrSaltedKey),\n\t\t\tyakklTokenDataCustomStore: await this.encryptWithChecksum(\n\t\t\t\ttokenDataCustom,\n\t\t\t\tpasswordOrSaltedKey\n\t\t\t),\n\t\t\tyakklCombinedTokenStore: await this.encryptWithChecksum(\n\t\t\t\tcombinedTokenStore,\n\t\t\t\tpasswordOrSaltedKey\n\t\t\t),\n\t\t\tyakklWalletProvidersStore: await this.encryptWithChecksum(\n\t\t\t\twalletProviders,\n\t\t\t\tpasswordOrSaltedKey\n\t\t\t),\n\t\t\tyakklWalletBlockchainsStore: await this.encryptWithChecksum(\n\t\t\t\twalletBlockchains,\n\t\t\t\tpasswordOrSaltedKey\n\t\t\t)\n\t\t};\n\n\t\tlet profileData: ProfileData | null = null;\n\t\tif (isEncryptedData(profile.data)) {\n\t\t\tprofileData = await decryptData(profile.data, passwordOrSaltedKey);\n\t\t}\n\n\t\t// Update this when new data stores are added to the wallet UNLESS it's not important to restore the given data store.\n\t\t// Compare with EmergencyKit.svelte for the list of data stores that need to be updated.\n\t\tconst meta: EmergencyKitMetaData = {\n\t\t\tid,\n\t\t\tcreateDate,\n\t\t\tupdateDate: createDate,\n\t\t\tversion: VERSION,\n\t\t\ttype: 'yakkl_bulk',\n\t\t\tplan: {\n\t\t\t\ttype: profileData?.registered?.plan.type ?? PlanType.BASIC_MEMBER,\n\t\t\t\tsource: AccessSourceType.STANDARD,\n\t\t\t\tpromo: PromoClassificationType.INFLUENCER,\n\t\t\t\ttrialEndDate: '',\n\t\t\t\tupgradeDate: ''\n\t\t\t},\n\t\t\thash: await this.createHash(JSON.stringify(encryptedData)),\n\t\t\tfiles: [\n\t\t\t\t'yakklPreferencesStore',\n\t\t\t\t'yakklSettingsStore',\n\t\t\t\t'profileStore',\n\t\t\t\t'yakklCurrentlySelectedStore',\n\t\t\t\t'yakklContactsStore',\n\t\t\t\t'yakklChatsStore',\n\t\t\t\t'yakklAccountsStore',\n\t\t\t\t'yakklPrimaryAccountsStore',\n\t\t\t\t'yakklWatchListStore',\n\t\t\t\t'yakklBlockedListStore',\n\t\t\t\t'yakklConnectedDomainsStore',\n\t\t\t\t'yakklTokenDataStore',\n\t\t\t\t'yakklTokenDataCustomStore',\n\t\t\t\t'yakklCombinedTokenStore',\n\t\t\t\t'yakklWalletProvidersStore',\n\t\t\t\t'yakklWalletBlockchainsStore'\n\t\t\t]\n\t\t};\n\n\t\tprofileData = null;\n\n\t\tconst bulkEmergencyKit: BulkEmergencyKitData = {\n\t\t\tmeta,\n\t\t\tdata: encryptedData,\n\t\t\tcs: await this.createHash(JSON.stringify(meta) + JSON.stringify(encryptedData))\n\t\t};\n\n\t\treturn bulkEmergencyKit;\n\t}\n\n\tstatic async downloadEmergencyKit(\n\t\temergencyKit: EmergencyKitData,\n\t\tfilePath?: string\n\t): Promise<string> {\n\t\tif (typeof window !== 'undefined' && window.document) {\n\t\t\tconst fileName = `yakkl-emergency-kit-${emergencyKit.id}-${emergencyKit?.meta?.createDate}.json`;\n\t\t\t// Browser environment\n\t\t\tthis.downloadObjectAsJson(emergencyKit, fileName);\n\t\t\treturn fileName;\n\t\t} else {\n\t\t\tthrow new Error('Download not supported in this environment');\n\t\t}\n\t}\n\n\tstatic async downloadBulkEmergencyKit(bulkEmergencyKit: BulkEmergencyKitData): Promise<string> {\n\t\ttry {\n\t\t\tif (typeof window !== 'undefined' && window.document) {\n\t\t\t\tconst fileName = `yakkl-bulk-emergency-kit-${bulkEmergencyKit.meta.id}-${bulkEmergencyKit.meta.createDate}.json`;\n\t\t\t\t// Browser environment\n\t\t\t\tthis.downloadObjectAsJson(bulkEmergencyKit, fileName);\n\t\t\t\treturn fileName;\n\t\t\t} else {\n\t\t\t\tthrow new Error('Download not supported in this environment');\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.log('[ERROR]: Error downloading bulk emergency kit:', false, error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async importEmergencyKit(\n\t\tsource: File | string | { bucket: string; key: string },\n\t\tpasswordOrSaltedKey: string | SaltedKey\n\t): Promise<EmergencyKitData> {\n\t\tlet fileContent: string;\n\n\t\tif (source instanceof File) {\n\t\t\t// Browser environment\n\t\t\tfileContent = await source.text();\n\t\t} else {\n\t\t\tfileContent = this.cloudImport('source'); // Dummy implementation\n\t\t}\n\n\t\tconst emergencyKit: EmergencyKitData = JSON.parse(fileContent);\n\n\t\t// Decrypt the data if it is encrypted\n\t\tif (isEncryptedData(emergencyKit.data)) {\n\t\t\temergencyKit.accounts = await decryptData<EmergencyKitAccountData[]>(\n\t\t\t\temergencyKit.data,\n\t\t\t\tpasswordOrSaltedKey\n\t\t\t);\n\t\t}\n\n\t\treturn emergencyKit;\n\t}\n\n\tstatic async importBulkEmergencyKit(\n\t\tsource: File | string,\n\t\tpasswordOrSaltedKey: string | SaltedKey\n\t): Promise<{\n\t\tnewData: any;\n\t\texistingData: any;\n\t}> {\n\t\ttry {\n\t\t\tlet fileContent: string;\n\n\t\t\tif (source instanceof File) {\n\t\t\t\t// Browser environment\n\t\t\t\tfileContent = await source.text();\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unsupported source type');\n\t\t\t}\n\n\t\t\tconst bulkEmergencyKit: BulkEmergencyKitData = JSON.parse(fileContent);\n\n\t\t\t// Verify the overall checksum\n\t\t\tconst calculatedCS = await this.createHash(\n\t\t\t\tJSON.stringify(bulkEmergencyKit.meta) + JSON.stringify(bulkEmergencyKit.data)\n\t\t\t);\n\t\t\tif (calculatedCS !== bulkEmergencyKit.cs) {\n\t\t\t\tthrow new Error('Data integrity check failed');\n\t\t\t}\n\n\t\t\tconst newData: any = {};\n\t\t\tconst existingData: any = {};\n\n\t\t\tfor (const [key, encryptedValue] of Object.entries(bulkEmergencyKit.data)) {\n\t\t\t\tconst decryptedData = await this.decryptWithChecksumVerification(\n\t\t\t\t\tencryptedValue,\n\t\t\t\t\tpasswordOrSaltedKey\n\t\t\t\t);\n\n\t\t\t\t// Check if data already exists (you'll need to implement this check based on your data structure)\n\t\t\t\tconst dataExists = await this.checkDataExists(key, decryptedData); // Currently a placeholder for future use and is not used\n\n\t\t\t\tif (dataExists) {\n\t\t\t\t\texistingData[key] = decryptedData; // Currently a placeholder for future use and is not used\n\t\t\t\t} else {\n\t\t\t\t\tnewData[key] = decryptedData;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn { newData, existingData };\n\t\t} catch (error) {\n\t\t\tlog.error('Error importing bulk emergency kit:', false, error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tstatic async readEmergencyKitMetadata(\n\t\tsource: File | string\n\t): Promise<EmergencyKitMetaData | undefined> {\n\t\tlet fileContent: string;\n\n\t\tif (source instanceof File) {\n\t\t\t// Browser environment\n\t\t\tfileContent = await source.text();\n\t\t} else {\n\t\t\tthrow new Error('Unsupported source type');\n\t\t}\n\n\t\tconst emergencyKit: EmergencyKitData = JSON.parse(fileContent);\n\t\treturn emergencyKit.meta;\n\t}\n\n\tstatic async readBulkEmergencyKitMetadata(source: File | string): Promise<EmergencyKitMetaData> {\n\t\ttry {\n\t\t\tlet fileContent: string;\n\n\t\t\tif (source instanceof File) {\n\t\t\t\t// Browser environment\n\t\t\t\tfileContent = await source.text();\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unsupported source type');\n\t\t\t}\n\n\t\t\tconst bulkEmergencyKit: BulkEmergencyKitData = JSON.parse(fileContent);\n\t\t\treturn bulkEmergencyKit.meta;\n\t\t} catch (error) {\n\t\t\tlog.error('Error reading bulk emergency kit metadata:', false, error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t// Internal methods...\n\tprivate static async checkDataExists(key: string, data: any): Promise<boolean> {\n\t\t// Implement this method based on your data structure and storage mechanism\n\t\t// For example, you might check against a database or local storage\n\t\t// Return true if the data already exists, false otherwise\n\t\treturn false; // Placeholder implementation\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tprivate static cloudImport(source: File | string): string {\n\t\treturn '';\n\t}\n\n\tprivate static async createHash(data: string): Promise<string> {\n\t\tconst encoder = new TextEncoder();\n\t\tconst dataBuffer = encoder.encode(data);\n\t\tconst hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);\n\t\tconst hashArray = Array.from(new Uint8Array(hashBuffer));\n\t\treturn hashArray.map((byte) => byte.toString(16).padStart(2, '0')).join('');\n\t}\n\n\tprivate static async decryptWithChecksumVerification(\n\t\tencryptedData: EncryptedData,\n\t\tpasswordOrSaltedKey: string | SaltedKey\n\t): Promise<any> {\n\t\ttry {\n\t\t\tconst decryptedData = await decryptData<{ cs: string; data: any }>(\n\t\t\t\tencryptedData,\n\t\t\t\tpasswordOrSaltedKey\n\t\t\t);\n\t\t\tconst calculatedChecksum = await this.createHash(JSON.stringify(decryptedData.data));\n\n\t\t\tif (calculatedChecksum !== decryptedData.cs) {\n\t\t\t\tthrow new Error('Data integrity check failed');\n\t\t\t}\n\n\t\t\treturn decryptedData.data;\n\t\t} catch (error) {\n\t\t\tlog.error('Error decrypting data:', false, error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate static downloadObjectAsJson(exportObj: any, exportName: string) {\n\t\ttry {\n\t\t\tconst dataStr =\n\t\t\t\t'data:text/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(exportObj)); //encodeJSON(exportObj)); //JSON.stringify(exportObj));\n\t\t\tconst downloadAnchorNode = document.createElement('a');\n\t\t\tdownloadAnchorNode.setAttribute('href', dataStr);\n\t\t\tdownloadAnchorNode.setAttribute('download', exportName);\n\t\t\tdocument.body.appendChild(downloadAnchorNode); // required for Firefox\n\t\t\tdownloadAnchorNode.click();\n\t\t\tdownloadAnchorNode.remove();\n\t\t} catch (e) {\n\t\t\tlog.error(`Download failed: ${e}`);\n\t\t}\n\t}\n\n\tprivate static async encryptWithChecksum(\n\t\tdata: any,\n\t\tpasswordOrSaltedKey: string | SaltedKey\n\t): Promise<EncryptedData> {\n\t\ttry {\n\t\t\tconst jsonString = JSON.stringify(data);\n\t\t\tconst checksum = await this.createHash(jsonString);\n\t\t\tconst encryptedData = await encryptData({ cs: checksum, data }, passwordOrSaltedKey);\n\t\t\treturn encryptedData;\n\t\t} catch (error) {\n\t\t\tlog.error('Error encrypting data:', false, error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate static generateId(): string {\n\t\treturn 'xxxxxx'.replace(/x/g, () => Math.floor(Math.random() * 16).toString(16));\n\t}\n\n\t// File saving is not supported in browser extension environment\n\t// Use downloadObjectAsJson for browser-based downloads\n}\n\n// Usage:\n// Create a bulk emergency kit\n// const bulkEmergencyKit = await EmergencyKitManager.createBulkEmergencyKit(\n//   preferences,\n//   settings,\n//   profile,\n//   currentlySelected,\n//   contacts,\n//   chats,\n//   accounts,\n//   primaryAccounts,\n//   watchList,\n//   blockedList,\n//   connectedDomains,\n// );\n\n// Download the bulk emergency kit\n// await EmergencyKitManager.downloadBulkEmergencyKit(bulkEmergencyKit);\n\n// Read metadata from a bulk emergency kit file\n// const metadata = await EmergencyKitManager.readBulkEmergencyKitMetadata(file);\n\n// Import a bulk emergency kit\n// const { newData, existingData } = await .importBulkEmergencyKit(file, password);\n\n// console.log('New data:', newData);\n// console.log('Existing data:', existingData);\n\n// For a single account emergency kit\n// const singleAccountMetadata = await EmergencyKitManager.readEmergencyKitMetadata(file);\n// console.log('Single Account Emergency Kit Metadata:', singleAccountMetadata);\n\n// For a bulk emergency kit\n// const bulkMetadata = await .readBulkEmergencyKitMetadata(file);\n// console.log('Bulk Emergency Kit Metadata:', bulkMetadata);\n","<script lang=\"ts\">\n\t//\n\t// NOTE: This for the Bulk Emergency Kit. The single EmergencyKit is only for YakklAccount or yakklPrimaryAccount.\n\t//\n\n\timport { EmergencyKitManager } from '$lib/managers/EmergencyKitManager';\n\timport {\n\t\tgetProfile,\n\t\tgetPreferences,\n\t\tgetSettings,\n\t\tgetYakklCurrentlySelected,\n\t\tgetYakklContacts,\n\t\tgetYakklChats,\n\t\tgetYakklAccounts,\n\t\tgetYakklPrimaryAccounts,\n\t\tgetYakklWatchList,\n\t\tgetYakklBlockedList,\n\t\tgetYakklConnectedDomains,\n\t\tgetMiscStore,\n\t\tsetProfileStorage,\n\t\tsetPreferencesStorage,\n\t\tsetSettingsStorage,\n\t\tsetYakklCurrentlySelectedStorage,\n\t\tsetYakklContactsStorage,\n\t\tsetYakklChatsStorage,\n\t\tsetYakklAccountsStorage,\n\t\tsetYakklPrimaryAccountsStorage,\n\t\tsetYakklWatchListStorage,\n\t\tsetYakklBlockedListStorage,\n\t\tsetYakklConnectedDomainsStorage,\n\t\tprofileStore,\n\t\tyakklPreferencesStore,\n\t\tyakklSettingsStore,\n\t\tyakklCurrentlySelectedStore,\n\t\tyakklContactsStore,\n\t\tyakklChatsStore,\n\t\tyakklAccountsStore,\n\t\tyakklPrimaryAccountsStore,\n\t\tyakklWatchListStore,\n\t\tyakklBlockedListStore,\n\t\tyakklConnectedDomainsStore,\n\t\tgetYakklTokenData,\n\t\tgetYakklTokenDataCustom,\n\t\tsetYakklTokenDataStorage,\n\t\tyakklTokenDataStore,\n\t\tsetYakklTokenDataCustomStorage,\n\t\tyakklTokenDataCustomStore,\n\t\tsetYakklCombinedTokenStorage,\n\t\tyakklCombinedTokenStore,\n\t\tsetYakklWalletProvidersStorage,\n\t\tsetYakklWalletBlockchainsStorage,\n\t\tyakklWalletBlockchainsStore,\n\t\tyakklWalletProvidersStore,\n\t\tgetYakklCombinedToken,\n\t\tgetYakklWalletProviders,\n\t\tgetYakklWalletBlockchains\n\t} from '$lib/common/stores';\n\timport {\n\t\tVERSION,\n\t\ttype EmergencyKitMetaData,\n\t\tisEncryptedData,\n\t\ttype CurrentlySelectedData\n\t} from '$lib/common';\n\timport { browserSvelte, browser_ext } from '$lib/common/environment';\n\timport { decryptData } from '$lib/common/encryption';\n\timport Confirmation from './Confirmation.svelte';\n\timport { log } from '$lib/managers/Logger';\n\timport { safeLogout } from '$lib/common/safeNavigate';\n\n\tinterface Props {\n\t\tmode?: 'import' | 'export' | 'restore';\n\t\tonComplete: (success: boolean, message: string) => void;\n\t\tonCancel?: () => void;\n\t}\n\n\tlet { mode = 'export', onComplete, onCancel = () => {} }: Props = $props();\n\n\tlet file: File | null = $state(null); // File name to export to or import from\n\tlet metadata: EmergencyKitMetaData | null = $state(null);\n\tlet loading = $state(false);\n\tlet error = $state('');\n\tlet showConfirmation = $state(false);\n\n\tasync function handleFileSelect(event: Event) {\n\t\tconst target = event.target as HTMLInputElement;\n\t\tif (target.files && target.files.length > 0) {\n\t\t\tfile = target.files[0];\n\t\t\ttry {\n\t\t\t\tmetadata = await EmergencyKitManager.readBulkEmergencyKitMetadata(file);\n\t\t\t} catch (err) {\n\t\t\t\terror = 'Failed to read emergency kit metadata';\n\t\t\t\tlog.error(err);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync function handleExport() {\n\t\tloading = true;\n\t\terror = '';\n\t\ttry {\n\t\t\tconst preferences = await getPreferences();\n\t\t\tconst settings = await getSettings();\n\t\t\tconst profile = await getProfile();\n\t\t\tconst currentlySelected = await getYakklCurrentlySelected();\n\t\t\tconst contacts = await getYakklContacts();\n\t\t\tconst chats = await getYakklChats();\n\t\t\tconst accounts = await getYakklAccounts();\n\t\t\tconst primaryAccounts = await getYakklPrimaryAccounts();\n\t\t\tconst watchList = await getYakklWatchList();\n\t\t\tconst blockedList = await getYakklBlockedList();\n\t\t\tconst connectedDomains = await getYakklConnectedDomains();\n\t\t\tconst passwordOrSaltedKey = getMiscStore();\n\t\t\tconst tokenData = await getYakklTokenData();\n\t\t\tconst tokenDataCustom = await getYakklTokenDataCustom();\n\t\t\tconst combinedTokenStore = await getYakklCombinedToken();\n\t\t\tconst walletProviders = await getYakklWalletProviders();\n\t\t\tconst walletBlockchains = await getYakklWalletBlockchains();\n\n\t\t\tif (!preferences || !settings || !profile || !currentlySelected || !passwordOrSaltedKey) {\n\t\t\t\tthrow new Error('Missing required data for export');\n\t\t\t}\n\n\t\t\tconst bulkEmergencyKit = await EmergencyKitManager.createBulkEmergencyKit(\n\t\t\t\tpreferences,\n\t\t\t\tsettings,\n\t\t\t\tprofile,\n\t\t\t\tcurrentlySelected,\n\t\t\t\tcontacts ?? [],\n\t\t\t\tchats ?? [],\n\t\t\t\taccounts ?? [],\n\t\t\t\tprimaryAccounts ?? [],\n\t\t\t\twatchList ?? [],\n\t\t\t\tblockedList ?? [],\n\t\t\t\tconnectedDomains ?? [],\n\t\t\t\tpasswordOrSaltedKey,\n\t\t\t\ttokenData ?? [],\n\t\t\t\ttokenDataCustom ?? [],\n\t\t\t\tcombinedTokenStore ?? [],\n\t\t\t\twalletProviders ?? [],\n\t\t\t\twalletBlockchains ?? []\n\t\t\t);\n\n\t\t\tconst fileName = await EmergencyKitManager.downloadBulkEmergencyKit(bulkEmergencyKit);\n\t\t\tonComplete(true, 'Emergency kit exported successfully as ' + fileName);\n\t\t} catch (err) {\n\t\t\terror = err instanceof Error ? err.message : 'Failed to export emergency kit';\n\t\t\tlog.error(err);\n\t\t\tonComplete(false, error);\n\t\t} finally {\n\t\t\tloading = false;\n\t\t}\n\t}\n\n\tasync function handleImport() {\n\t\tif (!file) {\n\t\t\terror = 'Please select a file to import';\n\t\t\treturn;\n\t\t}\n\t\tshowConfirmation = true;\n\t}\n\n\tasync function confirmImport() {\n\t\tshowConfirmation = false;\n\t\tloading = true;\n\t\terror = '';\n\t\ttry {\n\t\t\tconst passwordOrSaltedKey = getMiscStore();\n\t\t\tconst { newData, existingData } = await EmergencyKitManager.importBulkEmergencyKit(\n\t\t\t\tfile!,\n\t\t\t\tpasswordOrSaltedKey\n\t\t\t);\n\n\t\t\t// Update local storage and Svelte stores\n\t\t\tawait updateStorageAndStores(newData, existingData);\n\n\t\t\t// After successful import, send YAKKL_ACCOUNT message with the currently selected account\n\t\t\t// Come back to this later - this is more cosmetic and not needed for now.\n\t\t\t// if (browserSvelte) {\n\t\t\t//   const currentlySelected = await getYakklCurrentlySelected();\n\t\t\t//   if (currentlySelected && currentlySelected.data) {\n\t\t\t//     let accountData = currentlySelected.data;\n\t\t\t//     if (isEncryptedData(accountData)) {\n\t\t\t//       accountData = await decryptData(accountData, passwordOrSaltedKey) as CurrentlySelectedData;\n\t\t\t//     }\n\t\t\t//     const account = (accountData as CurrentlySelectedData).account;\n\n\t\t\t//     browser_ext.runtime.sendMessage({\n\t\t\t//       type: 'YAKKL_ACCOUNT',\n\t\t\t//       data: account\n\t\t\t//     }).catch((error: Error) => {\n\t\t\t//       log.error('Error sending account message', true, error);\n\t\t\t//     });\n\t\t\t//   }\n\t\t\t// }\n\n\t\t\tonComplete(true, `Emergency kit imported successfully for: ${file!.name}`);\n\t\t\tsafeLogout();\n\t\t} catch (err) {\n\t\t\terror = `Failed to import emergency kit for: ${file!.name}`;\n\t\t\tlog.error(err);\n\t\t\tonComplete(false, `Failed to import emergency kit for: ${file!.name}`);\n\t\t} finally {\n\t\t\tloading = false;\n\t\t}\n\t}\n\n\tasync function updateStorageAndStores(newData: any, existingData: any) {\n\t\t// Update this when new data stores are added to the wallet UNLESS it's not important to restore the given data store.\n\t\t// Compare with EmergencyKitManager.ts for the list of data stores that are updated.\n\t\tconst updateFunctions = [\n\t\t\t{\n\t\t\t\tkey: 'yakklPreferencesStore',\n\t\t\t\tsetStorage: setPreferencesStorage,\n\t\t\t\tstore: yakklPreferencesStore\n\t\t\t},\n\t\t\t{ key: 'yakklSettingsStore', setStorage: setSettingsStorage, store: yakklSettingsStore },\n\t\t\t{ key: 'profileStore', setStorage: setProfileStorage, store: profileStore },\n\t\t\t{\n\t\t\t\tkey: 'yakklCurrentlySelectedStore',\n\t\t\t\tsetStorage: setYakklCurrentlySelectedStorage,\n\t\t\t\tstore: yakklCurrentlySelectedStore\n\t\t\t},\n\t\t\t{ key: 'yakklContactsStore', setStorage: setYakklContactsStorage, store: yakklContactsStore },\n\t\t\t{ key: 'yakklChatsStore', setStorage: setYakklChatsStorage, store: yakklChatsStore },\n\t\t\t{ key: 'yakklAccountsStore', setStorage: setYakklAccountsStorage, store: yakklAccountsStore },\n\t\t\t{\n\t\t\t\tkey: 'yakklPrimaryAccountsStore',\n\t\t\t\tsetStorage: setYakklPrimaryAccountsStorage,\n\t\t\t\tstore: yakklPrimaryAccountsStore\n\t\t\t},\n\t\t\t{\n\t\t\t\tkey: 'yakklWatchListStore',\n\t\t\t\tsetStorage: setYakklWatchListStorage,\n\t\t\t\tstore: yakklWatchListStore\n\t\t\t},\n\t\t\t{\n\t\t\t\tkey: 'yakklBlockedListStore',\n\t\t\t\tsetStorage: setYakklBlockedListStorage,\n\t\t\t\tstore: yakklBlockedListStore\n\t\t\t},\n\t\t\t{\n\t\t\t\tkey: 'yakklConnectedDomainsStore',\n\t\t\t\tsetStorage: setYakklConnectedDomainsStorage,\n\t\t\t\tstore: yakklConnectedDomainsStore\n\t\t\t},\n\t\t\t{\n\t\t\t\tkey: 'yakklTokenDataStore',\n\t\t\t\tsetStorage: setYakklTokenDataStorage,\n\t\t\t\tstore: yakklTokenDataStore\n\t\t\t},\n\t\t\t{\n\t\t\t\tkey: 'yakklTokenDataCustomStore',\n\t\t\t\tsetStorage: setYakklTokenDataCustomStorage,\n\t\t\t\tstore: yakklTokenDataCustomStore\n\t\t\t},\n\t\t\t{\n\t\t\t\tkey: 'yakklCombinedTokenStore',\n\t\t\t\tsetStorage: setYakklCombinedTokenStorage,\n\t\t\t\tstore: yakklCombinedTokenStore\n\t\t\t},\n\t\t\t{\n\t\t\t\tkey: 'yakklWalletProvidersStore',\n\t\t\t\tsetStorage: setYakklWalletProvidersStorage,\n\t\t\t\tstore: yakklWalletProvidersStore\n\t\t\t},\n\t\t\t{\n\t\t\t\tkey: 'yakklWalletBlockchainsStore',\n\t\t\t\tsetStorage: setYakklWalletBlockchainsStorage,\n\t\t\t\tstore: yakklWalletBlockchainsStore\n\t\t\t}\n\t\t];\n\n\t\t// Validate VERSION once before the loop\n\t\tif (typeof VERSION === 'undefined' || typeof VERSION !== 'string' || VERSION.trim() === '') {\n\t\t\tlog.error('VERSION is not properly defined.');\n\t\t\treturn;\n\t\t}\n\n\t\t// This version now updates the version of all of the data stores that have a version property.\n\t\tfor (const { key, setStorage, store } of updateFunctions) {\n\t\t\tconst data = newData[key] || existingData[key]; // Currently a placeholder for future use and existingData is not used! This is for future use if using something like a backend database.\n\t\t\tif (data) {\n\t\t\t\t// Check if data is a valid object and has a version property\n\t\t\t\tif (data && typeof data === 'object' && !Array.isArray(data)) {\n\t\t\t\t\t// Update version if it exists (either as 'version' or 'VERSION')\n\t\t\t\t\tif ('version' in data || 'VERSION' in data) {\n\t\t\t\t\t\tdata['version'] = VERSION;\n\t\t\t\t\t\tlog.info(`Updated version for ${key} to ${VERSION}`);\n\t\t\t\t\t}\n\t\t\t\t} else if (data && typeof data === 'object' && Array.isArray(data)) {\n\t\t\t\t\tlog.warn(`${key} contains array data - version not updated`);\n\t\t\t\t} else {\n\t\t\t\t\tlog.error(`Invalid data object for ${key}. Cannot assign version.`);\n\t\t\t\t\tcontinue; // Skip this iteration\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tawait setStorage(data);\n\t\t\t\t\tstore.set(data);\n\t\t\t\t} catch (error: any) {\n\t\t\t\t\tlog.error(`Failed to update ${key}:`, false, error);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Previous version of the code that only updated the version of preferences\n\t\t// for (const { key, setStorage, store } of updateFunctions) {\n\t\t//   const data = newData[key] || existingData[key];\n\t\t//   if (data) {\n\t\t//     if ( key === 'yakklPreferencesStore') {\n\t\t//       if (data && typeof data === 'object' && !Array.isArray(data)) {\n\t\t//         // Keep the metadata version of the latest version\n\t\t//         if (typeof VERSION !== 'undefined' && typeof VERSION === 'string' && VERSION.trim() !== '') {\n\t\t//           data['version'] = VERSION;\n\t\t//         } else {\n\t\t//           log.error(\"VERSION is not properly defined.\");\n\t\t//         }\n\t\t//       } else {\n\t\t//         log.error(\"Invalid 'data' object. Cannot assign 'version'.\");\n\t\t//       }\n\t\t//     }\n\n\t\t//     await setStorage(data);\n\t\t//     store.set(data);\n\t\t//   }\n\t\t// }\n\t}\n</script>\n\n<div class=\"p-4\">\n\t<h2 class=\"text-2xl font-bold mb-4\">{mode === 'export' ? 'Export' : 'Import'} Emergency Kit</h2>\n\n\t{#if mode === 'export'}\n\t\t<button\n\t\t\tonclick={handleExport}\n\t\t\tclass=\"bg-blue-500 text-white px-4 py-2 rounded\"\n\t\t\tdisabled={loading}\n\t\t>\n\t\t\t{loading ? 'Exporting...' : 'Export Emergency Kit'}\n\t\t</button>\n\t{:else}\n\t\t<div class=\"mb-4\">\n\t\t\t<label for=\"importFile\" class=\"block mb-2\">Select File to Import:</label>\n\t\t\t<input\n\t\t\t\ttype=\"file\"\n\t\t\t\tid=\"importFile\"\n\t\t\t\tonchange={handleFileSelect}\n\t\t\t\taccept=\".json\"\n\t\t\t\tclass=\"w-full p-2 border rounded\"\n\t\t\t/>\n\t\t</div>\n\t\t{#if metadata}\n\t\t\t<div class=\"mb-4\">\n\t\t\t\t<h3 class=\"text-lg font-semibold\">Emergency Kit Metadata:</h3>\n\t\t\t\t<p>ID: {metadata.id}</p>\n\t\t\t\t<p>Created: {new Date(metadata.createDate).toLocaleString()}</p>\n\t\t\t\t<p>Version: {metadata.version}</p>\n\t\t\t\t<p>Type: {metadata.type}</p>\n\t\t\t\t<p>Files: {metadata.files}</p>\n\t\t\t</div>\n\t\t\t<div class=\"mb-4\">\n\t\t\t\t<h4 class=\"text-lg font-bold\">\n\t\t\t\t\tYAKKL will <span class=\"text-red-500 underline\">auto logout</span> once the import is complete!\n\t\t\t\t\tSimply login again to continue.\n\t\t\t\t</h4>\n\t\t\t</div>\n\t\t{/if}\n\t\t<button\n\t\t\tonclick={handleImport}\n\t\t\tclass=\"bg-green-500 text-white px-4 py-2 rounded\"\n\t\t\tdisabled={loading || !file}\n\t\t>\n\t\t\t{loading ? 'Importing...' : 'Import'}\n\t\t</button>\n\t\t<button onclick={onCancel} class=\"bg-red-400 text-white px-4 py-2 rounded\"> Cancel </button>\n\t{/if}\n\n\t{#if error}\n\t\t<p class=\"text-red-500 mt-4\">{error}</p>\n\t{/if}\n</div>\n\n<Confirmation\n\tbind:show={showConfirmation}\n\ttitle=\"Confirm Import\"\n\tmessage=\"Are you sure you want to continue? Doing so will override your current Smart Wallet data!\"\n\tconfirmText=\"Yes, Import\"\n\trejectText=\"Cancel\"\n\tonConfirm={confirmImport}\n/>\n","<script lang=\"ts\">\n\timport Modal from './Modal.svelte';\n\timport EmergencyKit from './EmergencyKit.svelte';\n\n\tinterface Props {\n\t\tshow?: boolean;\n\t\tmode?: 'import' | 'export';\n\t\tonComplete?: (success: boolean, message: string) => void;\n\t\tonCancel?: () => void;\n\t\tonClose?: () => void;\n\t}\n\n\tlet {\n\t\tshow = $bindable(false),\n\t\tmode = 'import',\n\t\tonComplete = handleEmergencyKitComplete,\n\t\tonCancel = $bindable(() => {\n\t\t\tshow = false;\n\t\t}),\n\t\tonClose = $bindable(() => {\n\t\t\tshow = false;\n\t\t})\n\t}: Props = $props();\n\n\tfunction handleEmergencyKitComplete(success: boolean, message: string) {\n\t\tshow = false;\n\t\tonComplete?.(success, message);\n\t}\n</script>\n\n<Modal bind:show {onCancel} {onClose} title=\"Emergency Kit\">\n\t<EmergencyKit {mode} {onComplete} {onCancel} />\n</Modal>\n"],"names":["EmergencyKitManager","createEmergencyKit","accountData","encryptDownload","passwordOrSaltedKey","createDate","Date","toISOString","updateDate","version","VERSION","id","this","generateId","encryptedAccounts","Promise","all","map","async","account","checksum","createHash","JSON","stringify","hash","encryptData","dataToEncrypt","encryptedData","data","iv","salt","overallChecksum","meta","type","portfolioName","subPortfolioName","subPortfolioAddress","files","plan","registered","source","AccessSourceType","STANDARD","promo","PromoClassificationType","INFLUENCER","trialEndDate","upgradeDate","emergencyKit","accounts","cs","createBulkEmergencyKit","preferences","settings","profile","currentlySelected","contacts","chats","primaryAccounts","watchList","blockedList","connectedDomains","tokenData","tokenDataCustom","combinedTokenStore","walletProviders","walletBlockchains","yakklPreferencesStore","encryptWithChecksum","yakklSettingsStore","profileStore","yakklCurrentlySelectedStore","yakklContactsStore","yakklChatsStore","yakklAccountsStore","yakklPrimaryAccountsStore","yakklWatchListStore","yakklBlockedListStore","yakklConnectedDomainsStore","yakklTokenDataStore","yakklTokenDataCustomStore","yakklCombinedTokenStore","yakklWalletProvidersStore","yakklWalletBlockchainsStore","profileData","isEncryptedData","decryptData","PlanType","BASIC_MEMBER","bulkEmergencyKit","downloadEmergencyKit","filePath","window","document","fileName","downloadObjectAsJson","Error","downloadBulkEmergencyKit","error","console","log","importEmergencyKit","fileContent","File","text","cloudImport","parse","importBulkEmergencyKit","calculatedCS","newData","existingData","key","encryptedValue","Object","entries","decryptedData","decryptWithChecksumVerification","dataExists","checkDataExists","readEmergencyKitMetadata","readBulkEmergencyKitMetadata","encoder","TextEncoder","dataBuffer","encode","hashBuffer","crypto","subtle","digest","hashArray","Array","from","Uint8Array","byte","toString","padStart","join","calculatedChecksum","exportObj","exportName","dataStr","encodeURIComponent","downloadAnchorNode","createElement","setAttribute","body","appendChild","click","remove","e","jsonString","replace","Math","floor","random","mode","onComplete","onCancel","file","loading","showConfirmation","confirmImport","getMiscStore","updateStorageAndStores","name","safeLogout","err","updateFunctions","setStorage","setPreferencesStorage","store","setSettingsStorage","setProfileStorage","setYakklCurrentlySelectedStorage","setYakklContactsStorage","setYakklChatsStorage","setYakklAccountsStorage","setYakklPrimaryAccountsStorage","setYakklWatchListStorage","setYakklBlockedListStorage","setYakklConnectedDomainsStorage","setYakklTokenDataStorage","setYakklTokenDataCustomStorage","setYakklCombinedTokenStorage","setYakklWalletProvidersStorage","setYakklWalletBlockchainsStorage","trim","isArray","info","warn","set","$$payload","out","$.escape","$.attr","$$value","show","handleEmergencyKitComplete","onClose","success","message"],"mappings":"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"}