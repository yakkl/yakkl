{"version":3,"file":"TimerManager.js","sources":["../../../../src/lib/managers/TimerManager.ts"],"sourcesContent":["import { writable } from 'svelte/store';\nimport { UnifiedTimerManager } from './UnifiedTimerManager';\n\ntype TimerCallback = () => void;\n\nexport interface Timer {\n\tid: string;\n\tcallback: TimerCallback;\n\tduration: number;\n\thandleIntervalID: NodeJS.Timeout | null;\n}\n\nexport const timerManagerStore = writable<TimerManager | null>(null);\n\n// TimerManager wraps UnifiedTimerManager for backward compatibility\nexport class TimerManager {\n\tprivate timers: Map<string, Timer> = new Map();\n\tprivate static instance: TimerManager | null = null;\n\tprivate unifiedManager: UnifiedTimerManager;\n\n\tconstructor() {\n\t\tif (TimerManager.instance) {\n\t\t\tif (!timerManagerStore) {\n\t\t\t\ttimerManagerStore.set(this);\n\t\t\t}\n\t\t\treturn TimerManager.instance;\n\t\t}\n\t\tthis.unifiedManager = UnifiedTimerManager.getInstance();\n\t\tTimerManager.instance = this;\n\t\ttimerManagerStore.set(this);\n\t}\n\n\tpublic static getInstance(): TimerManager {\n\t\treturn TimerManager.instance ?? new TimerManager();\n\t}\n\n\tpublic static clearInstance(): void {\n\t\tif (this.instance) {\n\t\t\tthis.instance.unifiedManager.clearAll();\n\t\t}\n\t\tthis.instance = null;\n\t\ttimerManagerStore.set(null);\n\t}\n\n\tpublic static resetInstance(): TimerManager {\n\t\tthis.clearInstance();\n\t\treturn this.getInstance();\n\t}\n\n\t/**\n\t * Add a new timer.\n\t * @param id - Unique ID for the timer.\n\t * @param callback - Function to execute when the timer triggers.\n\t * @param duration - Duration in milliseconds.\n\t */\n\taddTimer(id: string, callback: TimerCallback, duration: number): void {\n\t\t// Store locally for backward compatibility\n\t\tthis.timers.set(id, { id, callback, duration, handleIntervalID: null });\n\t\t// Delegate to unified manager\n\t\tthis.unifiedManager.addInterval(id, callback, duration);\n\t}\n\n\thasTimer(id: string): boolean {\n\t\treturn this.timers.has(id);\n\t}\n\n\t/**\n\t * Start a timer by ID.\n\t */\n\tstartTimer(id: string): void {\n\t\tthis.unifiedManager.startInterval(id);\n\t}\n\n\tstartTimerDelayed(id: string): void {\n\t\tthis.unifiedManager.startInterval(id);\n\t}\n\n\tstartTimerImmediate(id: string): void {\n\t\tthis.unifiedManager.startInterval(id, true);\n\t}\n\n\t/**\n\t * Stop a timer by ID.\n\t */\n\tstopTimer(id: string): void {\n\t\tthis.unifiedManager.stopInterval(id);\n\t}\n\n\t/**\n\t * Start all timers.\n\t */\n\tstartAll(): void {\n\t\tthis.timers.forEach((_, id) => this.unifiedManager.startInterval(id));\n\t}\n\n\t/**\n\t * Stop all timers.\n\t */\n\tstopAll(): void {\n\t\tthis.timers.forEach((_, id) => this.unifiedManager.stopInterval(id));\n\t}\n\n\t/**\n\t * Remove a timer by ID.\n\t */\n\tremoveTimer(id: string): void {\n\t\tthis.unifiedManager.removeInterval(id);\n\t\tthis.timers.delete(id);\n\t}\n\n\t/**\n\t * Remove all timers.\n\t */\n\tremoveAll(): void {\n\t\tthis.unifiedManager.clearAll();\n\t\tthis.timers.clear();\n\t}\n\n\t/**\n\t * Check if a timer is running.\n\t */\n\tisRunning(id: string): boolean {\n\t\treturn this.unifiedManager.isIntervalRunning(id);\n\t}\n\n\tgetTimeoutID(_id: string): NodeJS.Timeout | null {\n\t\t// This method name is misleading but kept for backward compatibility\n\t\treturn null; // UnifiedTimerManager doesn't expose handles directly\n\t}\n\n\t/**\n\t * List active timers.\n\t */\n\tgetRunningTimers(): string[] {\n\t\treturn this.unifiedManager.getRunningTimers().intervals;\n\t}\n\n\t/**\n\t * List all registered timers.\n\t */\n\tlistTimers(): string[] {\n\t\treturn Array.from(this.timers.keys());\n\t}\n}\n\n// Lazy instantiation function to prevent circular dependencies\nexport const getTimerManager = () => TimerManager.getInstance();\n"],"names":["timerManagerStore","writable","TimerManager","timers","Map","static","unifiedManager","constructor","instance","set","this","UnifiedTimerManager","getInstance","clearInstance","clearAll","resetInstance","addTimer","id","callback","duration","handleIntervalID","addInterval","hasTimer","has","startTimer","startInterval","startTimerDelayed","startTimerImmediate","stopTimer","stopInterval","startAll","forEach","_","stopAll","removeTimer","removeInterval","delete","removeAll","clear","isRunning","isIntervalRunning","getTimeoutID","_id","getRunningTimers","intervals","listTimers","Array","from","keys","getTimerManager"],"mappings":"gGAYa,MAAAA,kBAAoBC,SAA8B,MAGxD,MAAMC,aACJC,WAAiCC,IACzCC,gBAA+C,KACvCC,eAER,WAAAC,GACC,GAAIL,aAAaM,SAAU,CAC1B,IAAKR,kBAAmB,CACvBA,kBAAkBS,IAAIC,KAAI,CAE3B,OAAOR,aAAaM,QAAA,CAEhBE,KAAAJ,eAAiBK,oBAAoBC,cAC1CV,aAAaM,SAAWE,KACxBV,kBAAkBS,IAAIC,KAAI,CAG3B,kBAAcE,GACN,OAAAV,aAAaM,UAAY,IAAIN,YAAa,CAGlD,oBAAcW,GACb,GAAIH,KAAKF,SAAU,CACbE,KAAAF,SAASF,eAAeQ,UAAS,CAEvCJ,KAAKF,SAAW,KAChBR,kBAAkBS,IAAI,KAAI,CAG3B,oBAAcM,GACbL,KAAKG,gBACL,OAAOH,KAAKE,aAAY,CASzB,QAAAI,CAASC,GAAYC,SAAyBC,UAExCT,KAAAP,OAAOM,IAAIQ,GAAI,CAAEA,MAAIC,kBAAUC,kBAAUC,iBAAkB,OAEhEV,KAAKJ,eAAee,YAAYJ,GAAIC,SAAUC,SAAQ,CAGvD,QAAAG,CAASL,IACD,OAAAP,KAAKP,OAAOoB,IAAIN,GAAE,CAM1B,UAAAO,CAAWP,IACLP,KAAAJ,eAAemB,cAAcR,GAAE,CAGrC,iBAAAS,CAAkBT,IACZP,KAAAJ,eAAemB,cAAcR,GAAE,CAGrC,mBAAAU,CAAoBV,IACdP,KAAAJ,eAAemB,cAAcR,GAAI,KAAI,CAM3C,SAAAW,CAAUX,IACJP,KAAAJ,eAAeuB,aAAaZ,GAAE,CAMpC,QAAAa,GACMpB,KAAAP,OAAO4B,QAAQ,CAACC,EAAGf,KAAOP,KAAKJ,eAAemB,cAAcR,IAAG,CAMrE,OAAAgB,GACMvB,KAAAP,OAAO4B,QAAQ,CAACC,EAAGf,KAAOP,KAAKJ,eAAeuB,aAAaZ,IAAG,CAMpE,WAAAiB,CAAYjB,IACNP,KAAAJ,eAAe6B,eAAelB,IAC9BP,KAAAP,OAAOiC,OAAOnB,GAAE,CAMtB,SAAAoB,GACC3B,KAAKJ,eAAeQ,WACpBJ,KAAKP,OAAOmC,OAAM,CAMnB,SAAAC,CAAUtB,IACF,OAAAP,KAAKJ,eAAekC,kBAAkBvB,GAAE,CAGhD,YAAAwB,CAAaC,KAEL,OAAA,IAAA,CAMR,gBAAAC,GACQ,OAAAjC,KAAKJ,eAAeqC,mBAAmBC,SAAA,CAM/C,UAAAC,GACC,OAAOC,MAAMC,KAAKrC,KAAKP,OAAO6C,OAAM,EAKzB,MAAAC,gBAAkB,IAAM/C,aAAaU"}