{"version":3,"file":"session.js","sources":["../../../../src/lib/common/auth/session.ts"],"sourcesContent":["// File: src/lib/auth/session.ts\nimport { writable, get } from 'svelte/store';\nimport { log } from '$lib/common/logger-wrapper';\nimport { browser_ext, browserSvelte } from '../environment';\nimport type { SessionToken } from '../interfaces';\nimport type { StoreHashResponse } from '../interfaces';\n\n// This is for svelte client side only\nexport const sessionToken = writable<string | null>(null);\nexport const sessionExpiresAt = writable<number | null>(null);\n\nlet expiryTimer: ReturnType<typeof setTimeout> | null = null;\n\nfunction startExpiryCountdown(expiresAt: number) {\n\ttry {\n\t\tconst timeout = expiresAt - Date.now();\n\n\t\t// This line checks if there's an existing timer and clears it\n\t\tif (expiryTimer) clearTimeout(expiryTimer);\n\n\t\t// If the new expiry time is in the future, set a new timer\n\t\tif (timeout > 0) {\n\t\t\texpiryTimer = setTimeout(() => {\n\t\t\t\tsessionToken.set(null);\n\t\t\t\tsessionExpiresAt.set(null);\n\t\t\t\tlog.info('Session expired automatically');\n\t\t\t}, timeout);\n\t\t\t// log.debug('Expiry countdown set', false, { timeout });\n\t\t}\n\t} catch (error) {\n\t\tlog.error('Error starting expiry countdown', false, error);\n\t}\n}\n\nexport async function storeSessionToken(\n\ttoken: string,\n\texpiresAt: number,\n\toverride: boolean = true\n): Promise<SessionToken | null> {\n\tif (override) {\n\t\tsessionToken.set(token);\n\t\tsessionExpiresAt.set(expiresAt);\n\t\tstartExpiryCountdown(expiresAt);\n\t\treturn { token, expiresAt };\n\t} else {\n\t\treturn null;\n\t}\n}\n\nexport async function storeEncryptedHash(encryptedHash: string): Promise<SessionToken | null> {\n\ttry {\n\t\tif (browserSvelte) {\n\t\t\tif (!encryptedHash) {\n\t\t\t\tlog.warn('No encrypted hash provided', false, { encryptedHash });\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst res: StoreHashResponse = await browser_ext.runtime.sendMessage({\n\t\t\t\ttype: 'STORE_SESSION_HASH',\n\t\t\t\tpayload: encryptedHash\n\t\t\t});\n\t\t\tif (res && res.token && res.expiresAt) {\n\t\t\t\tstoreSessionToken(res.token, res.expiresAt);\n\t\t\t\tlog.debug('Session token stored', false, res);\n\t\t\t\treturn { token: res.token, expiresAt: res.expiresAt };\n\t\t\t} else {\n\t\t\t\tlog.warn('Session token storage failed', false, res);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\tlog.error('Error storing encrypted hash', false, error);\n\t\treturn null;\n\t}\n}\n\nexport async function refreshSession(currentToken: string): Promise<SessionToken | null> {\n\ttry {\n\t\tif (browserSvelte) {\n\t\t\tconst res: StoreHashResponse = await browser_ext.runtime.sendMessage({\n\t\t\t\ttype: 'REFRESH_SESSION',\n\t\t\t\ttoken: currentToken\n\t\t\t});\n\n\t\t\tif (res.token && res.expiresAt) {\n\t\t\t\tstoreSessionToken(res.token, res.expiresAt);\n\t\t\t\tlog.debug('Session refreshed', false, res);\n\t\t\t\treturn { token: res.token, expiresAt: res.expiresAt };\n\t\t\t} else {\n\t\t\t\tlog.warn('Session refresh failed or token invalid', false, res);\n\t\t\t\tstoreSessionToken(null, null, false);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\tlog.error('Error refreshing session', false, error);\n\t\treturn null;\n\t}\n}\n\nexport async function verifySessionToken(token: string): Promise<boolean> {\n\ttry {\n\t\tif (!token) {\n\t\t\tlog.warn('No token provided for verification', false);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst currentToken = get(sessionToken);\n\t\tconst currentExpiresAt = get(sessionExpiresAt);\n\n\t\tif (!currentToken || !currentExpiresAt) {\n\t\t\tlog.warn('No active session found', false);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (currentToken !== token) {\n\t\t\tlog.warn('Token mismatch', false);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (Date.now() >= currentExpiresAt) {\n\t\t\tlog.warn('Session expired', false);\n\t\t\tsessionToken.set(null);\n\t\t\tsessionExpiresAt.set(null);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (error) {\n\t\tlog.error('Error verifying session token', false, error);\n\t\treturn false;\n\t}\n}\n"],"names":["sessionToken","writable","sessionExpiresAt","expiryTimer","startExpiryCountdown","expiresAt","timeout","Date","now","setTimeout","set","log","info","error","async","storeSessionToken","token","override","storeEncryptedHash","encryptedHash","browserSvelte","warn","res","browser_ext","runtime","sendMessage","type","payload","debug","verifySessionToken","currentToken","get","currentExpiresAt"],"mappings":"uJAQa,MAAAA,aAAeC,SAAwB,MACvC,MAAAC,iBAAmBD,SAAwB,MAExD,IAAIE,YAAoD,KAExD,SAASC,qBAAqBC,WACzB,IACG,MAAAC,QAAUD,UAAYE,KAAKC,MAG7B,GAAAL,yBAA0BA,aAG9B,GAAIG,QAAU,EAAG,CAChBH,YAAcM,WAAW,KACxBT,aAAaU,IAAI,MACjBR,iBAAiBQ,IAAI,MACrBC,IAAIC,KAAK,kCACPN,QAAO,QAGHO,OACJF,IAAAE,MAAM,kCAAmC,MAAOA,MAAK,CAE3D,CAEAC,eAAsBC,kBACrBC,MACAX,UACAY,SAAoB,MAEpB,GAAIA,SAAU,CACbjB,aAAaU,IAAIM,OACjBd,iBAAiBQ,IAAIL,WACrBD,qBAAqBC,WACd,MAAA,CAAEW,YAAOX,oBAAU,KACpB,CACC,OAAA,IAAA,CAET,CAEAS,eAAsBI,mBAAmBC,eACpC,IACH,GAAIC,cAAe,CAClB,IAAKD,cAAe,CACnBR,IAAIU,KAAK,6BAA8B,MAAO,CAAEF,8BACzC,OAAA,IAAA,CAER,MAAMG,UAA+BC,YAAYC,QAAQC,YAAY,CACpEC,KAAM,qBACNC,QAASR,gBAEV,GAAIG,KAAOA,IAAIN,OAASM,IAAIjB,UAAW,CACpBU,kBAAAO,IAAIN,MAAOM,IAAIjB,WAC7BM,IAAAiB,MAAM,uBAAwB,MAAON,KACzC,MAAO,CAAEN,MAAOM,IAAIN,MAAOX,UAAWiB,IAAIjB,UAAU,KAC9C,CACFM,IAAAU,KAAK,+BAAgC,MAAOC,KACzC,OAAA,IAAA,CACR,QAEOT,OACJF,IAAAE,MAAM,+BAAgC,MAAOA,OAC1C,OAAA,IAAA,CAET,CA0BAC,eAAsBe,mBAAmBb,OACpC,IACH,IAAKA,MAAO,CACPL,IAAAU,KAAK,qCAAsC,OACxC,OAAA,KAAA,CAGF,MAAAS,aAAeC,IAAI/B,cACnB,MAAAgC,iBAAmBD,IAAI7B,kBAEzB,IAAC4B,eAAiBE,iBAAkB,CACnCrB,IAAAU,KAAK,0BAA2B,OAC7B,OAAA,KAAA,CAGR,GAAIS,eAAiBd,MAAO,CACvBL,IAAAU,KAAK,iBAAkB,OACpB,OAAA,KAAA,CAGJ,GAAAd,KAAKC,OAASwB,iBAAkB,CAC/BrB,IAAAU,KAAK,kBAAmB,OAC5BrB,aAAaU,IAAI,MACjBR,iBAAiBQ,IAAI,MACd,OAAA,KAAA,CAGD,OAAA,WACCG,OACJF,IAAAE,MAAM,gCAAiC,MAAOA,OAC3C,OAAA,KAAA,CAET"}