{"version":3,"file":"auth-store.js","sources":["../../../../src/lib/common/security.ts","../../../../src/lib/utilities/jwt.ts","../../../../src/lib/managers/SessionManager.ts","../../../../src/lib/stores/auth-store.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { decryptData, digestMessage } from '$lib/common/encryption';\nimport type {\n\tAccountData,\n\tCurrentlySelectedData,\n\tProfile,\n\tProfileData,\n\tSessionToken\n} from '$lib/common/interfaces';\nimport { isEncryptedData } from '$lib/common/misc';\nimport {\n\tgetProfile,\n\tsetMiscStore,\n\tgetYakklCurrentlySelected,\n\tgetMiscStore\n} from '$lib/common/stores';\nimport { log } from '$lib/common/logger-wrapper';\nimport { storeEncryptedHash, storeSessionToken } from './auth/session';\n\nexport interface AccountKey {\n\taddress: string;\n\tprivateKey: string;\n}\n\nexport async function verify(id: string): Promise<Profile | undefined> {\n\ttry {\n\t\tif (!id) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst profile = await getProfile();\n\t\tconst digest = await digestMessage(id);\n\t\tif (!profile || !digest) {\n\t\t\treturn undefined; // Don't set the store to anything here\n\t\t} else {\n\t\t\tif (isEncryptedData(profile.data)) {\n\t\t\t\tconst profileData = (await decryptData(profile.data, digest)) as ProfileData;\n\t\t\t\tif (profileData) {\n\t\t\t\t\tsetMiscStore(digest); // Works for client side\n\n\t\t\t\t\tconst sessionToken: SessionToken = await storeEncryptedHash(digest); // Works for background context\n\n\t\t\t\t\tif (sessionToken) {\n\t\t\t\t\t\tstoreSessionToken(sessionToken.token, sessionToken.expiresAt);\n\t\t\t\t\t}\n\t\t\t\t\tlog.info('verify - sessionToken', false, sessionToken);\n\t\t\t\t} else {\n\t\t\t\t\tthrow 'Verification failed!';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn profile;\n\t\t}\n\t} catch (e) {\n\t\tlog.error('Verification failed!', false, e);\n\t\tthrow `Verification failed! - ${e}`;\n\t}\n}\n\nexport async function getYakklCurrentlySelectedAccountKey(): Promise<AccountKey | null> {\n\ttry {\n\t\tconst currentlySelected = await getYakklCurrentlySelected();\n\t\tconst yakklMiscStore = getMiscStore();\n\t\tlet accountKey: AccountKey | null = null;\n\t\tlet address: string | null = null;\n\t\tlet privateKey: string | null | undefined = null;\n\n\t\tif (!yakklMiscStore || !currentlySelected) {\n\t\t\treturn null;\n\t\t}\n\t\t// May want to put this in a function\n\t\tif (isEncryptedData(currentlySelected.data)) {\n\t\t\tconst result = await decryptData(currentlySelected.data, yakklMiscStore);\n\t\t\tconst data = result as CurrentlySelectedData;\n\t\t\taddress = data?.account?.address || null;\n\t\t\tif (isEncryptedData(data?.account?.data)) {\n\t\t\t\tconst result = await decryptData(data.account.data, yakklMiscStore);\n\t\t\t\tconst accountData = result as AccountData;\n\t\t\t\tprivateKey = accountData.privateKey;\n\t\t\t} else {\n\t\t\t\tprivateKey = data ? data.account?.data.privateKey : null;\n\t\t\t}\n\t\t} else {\n\t\t\tprivateKey = currentlySelected.data\n\t\t\t\t? (((currentlySelected.data as CurrentlySelectedData).account?.data as AccountData)\n\t\t\t\t\t\t?.privateKey ?? null)\n\t\t\t\t: null;\n\t\t}\n\n\t\tif (privateKey && address) {\n\t\t\taccountKey = {\n\t\t\t\taddress: address,\n\t\t\t\tprivateKey: privateKey\n\t\t\t};\n\t\t}\n\t\treturn accountKey;\n\t} catch (e: any) {\n\t\t// error_log(e);\n\t\tlog.errorStack(e);\n\t\tthrow `Error getting account key - ${e}`;\n\t}\n}\n\nexport function extractSecureDomain(url: string): string | null {\n\ttry {\n\t\t// Parse the URL\n\t\tconst parsedUrl = new URL(url);\n\n\t\t// Check if the protocol is secure (https) or if it's a special case\n\t\tconst isSecure = parsedUrl.protocol === 'https:';\n\t\tconst isLocalhost = parsedUrl.hostname === 'localhost' || parsedUrl.hostname === '127.0.0.1';\n\t\tconst isChromeExtension = parsedUrl.protocol === 'chrome:';\n\n\t\tif (!isSecure && !isLocalhost && !isChromeExtension) {\n\t\t\tthrow new Error(\n\t\t\t\t'Insecure protocol detected. Only HTTPS, localhost, and chrome:// are allowed.'\n\t\t\t);\n\t\t}\n\n\t\t// Return just the hostname (domain)\n\t\treturn parsedUrl.hostname;\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\tthrow new Error(`Invalid URL or security violation: ${error.message}`);\n\t\t}\n\t\tthrow new Error('Invalid URL format');\n\t}\n}\n","/**\n * JWT Token Utilities for YAKKL Wallet\n * Handles JWT token generation and validation for Cloudflare Workers API authentication\n *\n * Note: This manager uses Svelte stores and is for client contexts only.\n * For background/service worker contexts, use jwt-background.ts instead.\n */\n\nimport { browser } from '$app/environment';\nimport { log } from '$lib/common/logger-wrapper';\nimport { backgroundJWTManager } from './jwt-background';\n\nexport interface JWTPayload {\n\tsub: string; // Subject (user ID)\n\tiat: number; // Issued at\n\texp: number; // Expiration time\n\tiss: string; // Issuer\n\taud: string; // Audience\n\tprofileId?: string; // YAKKL profile ID\n\tusername?: string; // YAKKL username\n\tplanLevel?: string; // User's plan level\n\tsessionId?: string; // Session identifier\n}\n\nexport interface JWTHeader {\n\talg: string;\n\ttyp: string;\n}\n\nexport class JWTManager {\n\tprivate static instance: JWTManager | null = null;\n\tprivate readonly issuer = 'yakkl-wallet';\n\tprivate readonly audience = 'yakkl-api';\n\tprivate readonly algorithm = 'HS256';\n\n\tprivate constructor() {}\n\n\tstatic getInstance(): JWTManager {\n\t\tif (!JWTManager.instance) {\n\t\t\tJWTManager.instance = new JWTManager();\n\t\t}\n\t\treturn JWTManager.instance;\n\t}\n\n\t/**\n\t * Generate a JWT token for API authentication\n\t */\n\tasync generateToken(\n\t\tuserId: string,\n\t\tusername: string,\n\t\tprofileId: string,\n\t\tplanLevel: string = 'basic',\n\t\texpirationMinutes: number = 60\n\t): Promise<string> {\n\t\ttry {\n\t\t\tconst now = Math.floor(Date.now() / 1000);\n\t\t\tconst sessionId = this.generateSessionId();\n\n\t\t\tconst header: JWTHeader = {\n\t\t\t\talg: this.algorithm,\n\t\t\t\ttyp: 'JWT'\n\t\t\t};\n\n\t\t\tconst payload: JWTPayload = {\n\t\t\t\tsub: userId,\n\t\t\t\tiat: now,\n\t\t\t\texp: now + expirationMinutes * 60,\n\t\t\t\tiss: this.issuer,\n\t\t\t\taud: this.audience,\n\t\t\t\tprofileId,\n\t\t\t\tusername,\n\t\t\t\tplanLevel,\n\t\t\t\tsessionId\n\t\t\t};\n\n\t\t\tconst encodedHeader = this.base64UrlEncode(JSON.stringify(header));\n\t\t\tconst encodedPayload = this.base64UrlEncode(JSON.stringify(payload));\n\n\t\t\tconst signature = await this.generateSignature(\n\t\t\t\t`${encodedHeader}.${encodedPayload}`,\n\t\t\t\tawait this.getSigningKey()\n\t\t\t);\n\n\t\t\tconst token = `${encodedHeader}.${encodedPayload}.${signature}`;\n\n\t\t\tlog.debug('JWT token generated', false, {\n\t\t\t\tuserId,\n\t\t\t\tusername,\n\t\t\t\texpirationMinutes,\n\t\t\t\tsessionId\n\t\t\t});\n\n\t\t\treturn token;\n\t\t} catch (error) {\n\t\t\tlog.error('Failed to generate JWT token:', false, error);\n\t\t\tthrow new Error('Token generation failed');\n\t\t}\n\t}\n\n\t/**\n\t * Validate and decode a JWT token\n\t */\n\tasync validateToken(token: string): Promise<JWTPayload | null> {\n\t\ttry {\n\t\t\tconst parts = token.split('.');\n\t\t\tif (parts.length !== 3) {\n\t\t\t\tthrow new Error('Invalid token format');\n\t\t\t}\n\n\t\t\tconst [encodedHeader, encodedPayload, signature] = parts;\n\n\t\t\t// Verify signature\n\t\t\tconst signingKey = await this.getSigningKey();\n\t\t\tconst expectedSignature = await this.generateSignature(\n\t\t\t\t`${encodedHeader}.${encodedPayload}`,\n\t\t\t\tsigningKey\n\t\t\t);\n\n\t\t\tif (signature !== expectedSignature) {\n\t\t\t\tthrow new Error('Invalid token signature');\n\t\t\t}\n\n\t\t\t// Decode payload\n\t\t\tconst payload: JWTPayload = JSON.parse(this.base64UrlDecode(encodedPayload));\n\n\t\t\t// Check expiration\n\t\t\tconst now = Math.floor(Date.now() / 1000);\n\t\t\tif (payload.exp <= now) {\n\t\t\t\tthrow new Error('Token expired');\n\t\t\t}\n\n\t\t\t// Validate issuer and audience\n\t\t\tif (payload.iss !== this.issuer || payload.aud !== this.audience) {\n\t\t\t\tthrow new Error('Invalid token issuer or audience');\n\t\t\t}\n\n\t\t\tlog.debug('JWT token validated successfully', false, {\n\t\t\t\tsub: payload.sub,\n\t\t\t\tusername: payload.username,\n\t\t\t\tsessionId: payload.sessionId\n\t\t\t});\n\n\t\t\treturn payload;\n\t\t} catch (error) {\n\t\t\tlog.warn('JWT token validation failed:', false, error);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Refresh a token if it's close to expiration\n\t */\n\tasync refreshTokenIfNeeded(\n\t\ttoken: string,\n\t\trefreshThresholdMinutes: number = 10\n\t): Promise<string | null> {\n\t\ttry {\n\t\t\tconst payload = await this.validateToken(token);\n\t\t\tif (!payload) return null;\n\n\t\t\tconst now = Math.floor(Date.now() / 1000);\n\t\t\tconst timeUntilExpiry = payload.exp - now;\n\n\t\t\t// Refresh if token expires within threshold\n\t\t\tif (timeUntilExpiry <= refreshThresholdMinutes * 60) {\n\t\t\t\tlog.debug('Refreshing JWT token', false, {\n\t\t\t\t\ttimeUntilExpiry,\n\t\t\t\t\tthreshold: refreshThresholdMinutes * 60\n\t\t\t\t});\n\n\t\t\t\treturn await this.generateToken(\n\t\t\t\t\tpayload.sub,\n\t\t\t\t\tpayload.username || '',\n\t\t\t\t\tpayload.profileId || '',\n\t\t\t\t\tpayload.planLevel || 'basic'\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn token; // Token is still valid\n\t\t} catch (error) {\n\t\t\tlog.error('Failed to refresh token:', false, error);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Extract token information without validation\n\t */\n\tdecodeToken(token: string): { header: JWTHeader; payload: JWTPayload } | null {\n\t\ttry {\n\t\t\tconst parts = token.split('.');\n\t\t\tif (parts.length !== 3) return null;\n\n\t\t\tconst header = JSON.parse(this.base64UrlDecode(parts[0]));\n\t\t\tconst payload = JSON.parse(this.base64UrlDecode(parts[1]));\n\n\t\t\treturn { header, payload };\n\t\t} catch {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get time until token expiration\n\t */\n\tgetTimeUntilExpiration(token: string): number | null {\n\t\tconst decoded = this.decodeToken(token);\n\t\tif (!decoded) return null;\n\n\t\tconst now = Math.floor(Date.now() / 1000);\n\t\treturn Math.max(0, decoded.payload.exp - now);\n\t}\n\n\t/**\n\t * Generate a unique session ID\n\t */\n\tprivate generateSessionId(): string {\n\t\tconst timestamp = Date.now().toString(36);\n\t\tconst random = Math.random().toString(36).substring(2);\n\t\treturn `${timestamp}-${random}`;\n\t}\n\n\t/**\n\t * Get signing key (in production, this should be from secure storage)\n\t */\n\tprivate async getSigningKey(): Promise<string> {\n\t\t// In production, this should be retrieved from secure storage\n\t\t// For now, we'll generate a key based on the user's profile\n\t\tif (browser) {\n\t\t\ttry {\n\t\t\t\tconst { getSettings } = await import('$lib/common/stores');\n\t\t\t\tconst settings = await getSettings();\n\n\t\t\t\t// Create a signing key from user settings and current date (changes daily for security)\n\t\t\t\tconst today = new Date().toISOString().split('T')[0];\n\t\t\t\tconst keyMaterial = `${settings?.id || 'default'}-${today}-yakkl-jwt-key`;\n\n\t\t\t\t// Hash the key material to create a consistent signing key\n\t\t\t\tconst encoder = new TextEncoder();\n\t\t\t\tconst data = encoder.encode(keyMaterial);\n\t\t\t\tconst hashBuffer = await crypto.subtle.digest('SHA-256', data);\n\t\t\t\tconst hashArray = Array.from(new Uint8Array(hashBuffer));\n\t\t\t\treturn hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');\n\t\t\t} catch (error) {\n\t\t\t\tlog.warn('Failed to generate signing key from settings, using fallback', false, error);\n\t\t\t}\n\t\t}\n\n\t\t// Fallback key (not secure for production)\n\t\treturn 'yakkl-fallback-signing-key-change-in-production';\n\t}\n\n\t/**\n\t * Generate HMAC signature\n\t */\n\tprivate async generateSignature(data: string, key: string): Promise<string> {\n\t\tconst encoder = new TextEncoder();\n\t\tconst keyData = encoder.encode(key);\n\t\tconst messageData = encoder.encode(data);\n\n\t\tconst cryptoKey = await crypto.subtle.importKey(\n\t\t\t'raw',\n\t\t\tkeyData,\n\t\t\t{ name: 'HMAC', hash: 'SHA-256' },\n\t\t\tfalse,\n\t\t\t['sign']\n\t\t);\n\n\t\tconst signature = await crypto.subtle.sign('HMAC', cryptoKey, messageData);\n\t\treturn this.base64UrlEncode(new Uint8Array(signature));\n\t}\n\n\t/**\n\t * Base64 URL encode\n\t */\n\tprivate base64UrlEncode(data: string | Uint8Array): string {\n\t\tconst input = typeof data === 'string' ? new TextEncoder().encode(data) : data;\n\t\tconst base64 = btoa(String.fromCharCode(...input));\n\t\treturn base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n\t}\n\n\t/**\n\t * Base64 URL decode\n\t */\n\tprivate base64UrlDecode(data: string): string {\n\t\tconst base64 = data.replace(/-/g, '+').replace(/_/g, '/');\n\t\tconst padded = base64.padEnd(base64.length + ((4 - (base64.length % 4)) % 4), '=');\n\t\treturn atob(padded);\n\t}\n}\n\n// Export singleton instance\nexport const jwtManager = JWTManager.getInstance();\n\n/**\n * Context-aware JWT manager that automatically uses the appropriate implementation\n * - Uses backgroundJWTManager for service workers/background contexts\n * - Uses regular JWTManager for client contexts with Svelte stores\n */\nexport class ContextAwareJWTManager {\n\tprivate static instance: ContextAwareJWTManager | null = null;\n\n\tstatic getInstance(): ContextAwareJWTManager {\n\t\tif (!ContextAwareJWTManager.instance) {\n\t\t\tContextAwareJWTManager.instance = new ContextAwareJWTManager();\n\t\t}\n\t\treturn ContextAwareJWTManager.instance;\n\t}\n\n\t/**\n\t * Detect current execution context\n\t */\n\tprivate isBackgroundContext(): boolean {\n\t\t// Check for service worker context\n\t\ttry {\n\t\t\tif (\n\t\t\t\ttypeof self !== 'undefined' &&\n\t\t\t\t'ServiceWorkerGlobalScope' in globalThis &&\n\t\t\t\tself instanceof (globalThis as any).ServiceWorkerGlobalScope\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} catch {\n\t\t\t// ServiceWorkerGlobalScope not available\n\t\t}\n\n\t\t// Check for extension background context\n\t\tif (typeof chrome !== 'undefined' && chrome.storage && chrome.storage.local && !browser) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Generate JWT token using appropriate manager\n\t */\n\tasync generateToken(\n\t\tuserId: string,\n\t\tusername: string,\n\t\tprofileId: string,\n\t\tplanLevel: string = 'basic',\n\t\tsessionId?: string,\n\t\texpirationMinutes: number = 60\n\t): Promise<string> {\n\t\tif (this.isBackgroundContext()) {\n\t\t\treturn await backgroundJWTManager.generateToken(\n\t\t\t\tuserId,\n\t\t\t\tusername,\n\t\t\t\tprofileId,\n\t\t\t\tplanLevel,\n\t\t\t\tsessionId,\n\t\t\t\texpirationMinutes\n\t\t\t);\n\t\t} else {\n\t\t\treturn await jwtManager.generateToken(\n\t\t\t\tuserId,\n\t\t\t\tusername,\n\t\t\t\tprofileId,\n\t\t\t\tplanLevel,\n\t\t\t\texpirationMinutes\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Get current JWT token using appropriate manager\n\t */\n\tasync getCurrentToken(): Promise<string | null> {\n\t\tif (this.isBackgroundContext()) {\n\t\t\treturn await backgroundJWTManager.getCurrentToken();\n\t\t} else {\n\t\t\t// For client context, we'd need to get from auth store or session manager\n\t\t\t// This would typically be called from the auth store itself\n\t\t\tconsole.warn('getCurrentToken called from client context - use authStore instead');\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Validate token using appropriate manager\n\t */\n\tasync validateToken(token: string): Promise<boolean> {\n\t\tif (this.isBackgroundContext()) {\n\t\t\treturn await backgroundJWTManager.validateToken(token);\n\t\t} else {\n\t\t\tconst payload = await jwtManager.validateToken(token);\n\t\t\treturn payload !== null;\n\t\t}\n\t}\n\n\t/**\n\t * Clear token using appropriate manager\n\t */\n\tasync clearToken(): Promise<void> {\n\t\tif (this.isBackgroundContext()) {\n\t\t\tawait backgroundJWTManager.clearToken();\n\t\t} else {\n\t\t\t// For client context, this would be handled by auth store\n\t\t\tconsole.warn('clearToken called from client context - use authStore instead');\n\t\t}\n\t}\n}\n\n// Export context-aware instance\nexport const contextAwareJWT = ContextAwareJWTManager.getInstance();\n\n// Helper functions for easy background script usage\nexport async function getJWTForBackground(): Promise<string | null> {\n\treturn await backgroundJWTManager.getCurrentToken();\n}\n\nexport async function createJWTInBackground(\n\tuserId: string,\n\tusername: string,\n\tprofileId: string,\n\tplanLevel: string = 'basic',\n\tsessionId?: string\n): Promise<string> {\n\treturn await backgroundJWTManager.generateToken(\n\t\tuserId,\n\t\tusername,\n\t\tprofileId,\n\t\tplanLevel,\n\t\tsessionId\n\t);\n}\n","/**\n * Session Manager for YAKKL Wallet\n * Handles session lifecycle, timeouts, and JWT token management\n * Browser extension context-aware implementation\n */\n\nimport { browser } from '$app/environment';\nimport { browser_ext } from '$lib/common/environment';\nimport { log } from '$lib/common/logger-wrapper';\nimport { jwtManager, type JWTPayload } from '$lib/utilities/jwt';\n\nexport interface SessionState {\n\tisActive: boolean;\n\tuserId: string | null;\n\tusername: string | null;\n\tprofileId: string | null;\n\tplanLevel: string | null;\n\tsessionId: string | null;\n\tlastActivity: number;\n\texpiresAt: number;\n\tjwtToken: string | null;\n\twarningShown: boolean;\n}\n\nexport interface SessionConfig {\n\ttimeoutMinutes: number;\n\twarningMinutes: number;\n\tmaxInactivityMinutes: number;\n\tautoExtendOnActivity: boolean;\n\tjwtExpirationMinutes: number;\n}\n\nconst DEFAULT_CONFIG: SessionConfig = {\n\ttimeoutMinutes: 30,\n\twarningMinutes: 2,\n\tmaxInactivityMinutes: 60,\n\tautoExtendOnActivity: true,\n\tjwtExpirationMinutes: 60\n};\n\nexport class SessionManager {\n\tprivate static instance: SessionManager | null = null;\n\tprivate config: SessionConfig = DEFAULT_CONFIG;\n\tprivate sessionState: SessionState | null = null;\n\tprivate timeoutTimer: ReturnType<typeof setTimeout> | null = null;\n\tprivate warningTimer: ReturnType<typeof setTimeout> | null = null;\n\tprivate activityListenersAdded = false;\n\n\t// Event callbacks\n\tprivate onSessionWarning: ((timeRemaining: number) => void) | null = null;\n\tprivate onSessionExpired: (() => void) | null = null;\n\tprivate onSessionExtended: (() => void) | null = null;\n\n\tprivate constructor() {\n\t\tthis.initializeFromStorage();\n\t}\n\n\tstatic getInstance(): SessionManager {\n\t\tif (!SessionManager.instance) {\n\t\t\tSessionManager.instance = new SessionManager();\n\t\t}\n\t\treturn SessionManager.instance;\n\t}\n\n\t/**\n\t * Start a new session\n\t */\n\tasync startSession(\n\t\tuserId: string,\n\t\tusername: string,\n\t\tprofileId: string,\n\t\tplanLevel: string = 'basic'\n\t): Promise<string> {\n\t\ttry {\n\t\t\t// Generate JWT token\n\t\t\tconst jwtToken = await jwtManager.generateToken(\n\t\t\t\tuserId,\n\t\t\t\tusername,\n\t\t\t\tprofileId,\n\t\t\t\tplanLevel,\n\t\t\t\tthis.config.jwtExpirationMinutes\n\t\t\t);\n\n\t\t\tconst now = Date.now();\n\t\t\tconst sessionId = this.generateSessionId();\n\n\t\t\tthis.sessionState = {\n\t\t\t\tisActive: true,\n\t\t\t\tuserId,\n\t\t\t\tusername,\n\t\t\t\tprofileId,\n\t\t\t\tplanLevel,\n\t\t\t\tsessionId,\n\t\t\t\tlastActivity: now,\n\t\t\t\texpiresAt: now + this.config.timeoutMinutes * 60 * 1000,\n\t\t\t\tjwtToken,\n\t\t\t\twarningShown: false\n\t\t\t};\n\n\t\t\tawait this.saveSessionState();\n\t\t\tthis.startActivityTracking();\n\t\t\tthis.scheduleWarning();\n\n\t\t\tlog.debug('Session started', false, {\n\t\t\t\tuserId,\n\t\t\t\tusername,\n\t\t\t\tsessionId,\n\t\t\t\texpiresAt: new Date(this.sessionState.expiresAt)\n\t\t\t});\n\n\t\t\t// Notify background script if in extension\n\t\t\tif (browser && browser_ext) {\n\t\t\t\tthis.notifyBackgroundScript('SESSION_STARTED', {\n\t\t\t\t\tsessionId,\n\t\t\t\t\texpiresAt: this.sessionState.expiresAt\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn jwtToken;\n\t\t} catch (error) {\n\t\t\tlog.error('Failed to start session:', false, error);\n\t\t\tthrow new Error('Session start failed');\n\t\t}\n\t}\n\n\t/**\n\t * Extend current session\n\t */\n\tasync extendSession(additionalMinutes: number = 30): Promise<void> {\n\t\tif (!this.sessionState || !this.sessionState.isActive) {\n\t\t\tthrow new Error('No active session to extend');\n\t\t}\n\n\t\ttry {\n\t\t\tconst now = Date.now();\n\t\t\tconst newExpiresAt = now + additionalMinutes * 60 * 1000;\n\n\t\t\t// Refresh JWT token if needed\n\t\t\tif (this.sessionState.jwtToken) {\n\t\t\t\tconst refreshedToken = await jwtManager.refreshTokenIfNeeded(\n\t\t\t\t\tthis.sessionState.jwtToken,\n\t\t\t\t\t10 // Refresh if expires within 10 minutes\n\t\t\t\t);\n\n\t\t\t\tif (refreshedToken && refreshedToken !== this.sessionState.jwtToken) {\n\t\t\t\t\tthis.sessionState.jwtToken = refreshedToken;\n\t\t\t\t\tlog.debug('JWT token refreshed during session extension', false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.sessionState.lastActivity = now;\n\t\t\tthis.sessionState.expiresAt = newExpiresAt;\n\t\t\tthis.sessionState.warningShown = false;\n\n\t\t\tawait this.saveSessionState();\n\t\t\tthis.clearTimers();\n\t\t\tthis.scheduleWarning();\n\n\t\t\tlog.debug('Session extended', false, {\n\t\t\t\tsessionId: this.sessionState.sessionId,\n\t\t\t\tadditionalMinutes,\n\t\t\t\tnewExpiresAt: new Date(newExpiresAt)\n\t\t\t});\n\n\t\t\tif (this.onSessionExtended) {\n\t\t\t\tthis.onSessionExtended();\n\t\t\t}\n\n\t\t\t// Notify background script\n\t\t\tif (browser && browser_ext) {\n\t\t\t\tthis.notifyBackgroundScript('SESSION_EXTENDED', {\n\t\t\t\t\tsessionId: this.sessionState.sessionId,\n\t\t\t\t\texpiresAt: newExpiresAt\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlog.error('Failed to extend session:', false, error);\n\t\t\tthrow new Error('Session extension failed');\n\t\t}\n\t}\n\n\t/**\n\t * End current session\n\t */\n\tasync endSession(): Promise<void> {\n\t\tif (this.sessionState) {\n\t\t\tlog.debug('Ending session', false, {\n\t\t\t\tsessionId: this.sessionState.sessionId\n\t\t\t});\n\n\t\t\t// Notify background script before clearing state\n\t\t\tif (browser && browser_ext) {\n\t\t\t\tthis.notifyBackgroundScript('SESSION_ENDED', {\n\t\t\t\t\tsessionId: this.sessionState.sessionId\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tthis.sessionState = null;\n\t\tthis.clearTimers();\n\t\tthis.removeActivityListeners();\n\n\t\ttry {\n\t\t\tawait this.clearSessionStorage();\n\t\t} catch (error) {\n\t\t\tlog.warn('Failed to clear session storage:', false, error);\n\t\t}\n\n\t\tif (this.onSessionExpired) {\n\t\t\tthis.onSessionExpired();\n\t\t}\n\t}\n\n\t/**\n\t * Get current session state\n\t */\n\tgetSessionState(): SessionState | null {\n\t\treturn this.sessionState ? { ...this.sessionState } : null;\n\t}\n\n\t/**\n\t * Get current JWT token\n\t */\n\tgetCurrentJWTToken(): string | null {\n\t\treturn this.sessionState?.jwtToken || null;\n\t}\n\n\t/**\n\t * Check if session is active and valid\n\t */\n\tisSessionActive(): boolean {\n\t\tif (!this.sessionState || !this.sessionState.isActive) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst now = Date.now();\n\t\tif (now >= this.sessionState.expiresAt) {\n\t\t\tthis.endSession();\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Update activity timestamp\n\t */\n\tupdateActivity(): void {\n\t\tif (!this.sessionState || !this.sessionState.isActive) return;\n\n\t\tconst now = Date.now();\n\t\tthis.sessionState.lastActivity = now;\n\n\t\t// Auto-extend session if configured and close to expiration\n\t\tif (this.config.autoExtendOnActivity) {\n\t\t\tconst timeUntilExpiry = this.sessionState.expiresAt - now;\n\t\t\tconst warningThreshold = this.config.warningMinutes * 60 * 1000;\n\n\t\t\tif (timeUntilExpiry <= warningThreshold && !this.sessionState.warningShown) {\n\t\t\t\tthis.extendSession(this.config.timeoutMinutes);\n\t\t\t}\n\t\t}\n\n\t\tthis.saveSessionState(); // Save updated activity time\n\t}\n\n\t/**\n\t * Set event callbacks\n\t */\n\tsetCallbacks(callbacks: {\n\t\tonWarning?: (timeRemaining: number) => void;\n\t\tonExpired?: () => void;\n\t\tonExtended?: () => void;\n\t}): void {\n\t\tthis.onSessionWarning = callbacks.onWarning || null;\n\t\tthis.onSessionExpired = callbacks.onExpired || null;\n\t\tthis.onSessionExtended = callbacks.onExtended || null;\n\t}\n\n\t/**\n\t * Update session configuration\n\t */\n\tupdateConfig(newConfig: Partial<SessionConfig>): void {\n\t\tthis.config = { ...this.config, ...newConfig };\n\t\tlog.debug('Session config updated', false, this.config);\n\t}\n\n\t/**\n\t * Initialize session from storage\n\t */\n\tprivate async initializeFromStorage(): Promise<void> {\n\t\tif (!browser) return;\n\n\t\ttry {\n\t\t\tconst stored = await this.loadSessionState();\n\t\t\tif (stored && stored.isActive) {\n\t\t\t\tconst now = Date.now();\n\n\t\t\t\t// Check if session is still valid\n\t\t\t\tif (now < stored.expiresAt) {\n\t\t\t\t\tthis.sessionState = stored;\n\t\t\t\t\tthis.startActivityTracking();\n\t\t\t\t\tthis.scheduleWarning();\n\n\t\t\t\t\tlog.debug('Session restored from storage', false, {\n\t\t\t\t\t\tsessionId: stored.sessionId,\n\t\t\t\t\t\ttimeRemaining: Math.round((stored.expiresAt - now) / 1000)\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// Session expired, clean up\n\t\t\t\t\tawait this.clearSessionStorage();\n\t\t\t\t\tlog.debug('Expired session cleared from storage', false);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlog.warn('Failed to initialize session from storage:', false, error);\n\t\t}\n\t}\n\n\t/**\n\t * Schedule session warning\n\t */\n\tprivate scheduleWarning(): void {\n\t\tif (!this.sessionState) return;\n\n\t\tconst now = Date.now();\n\t\tconst timeUntilWarning =\n\t\t\tthis.sessionState.expiresAt - now - this.config.warningMinutes * 60 * 1000;\n\n\t\tif (timeUntilWarning > 0) {\n\t\t\tthis.warningTimer = setTimeout(() => {\n\t\t\t\tthis.showSessionWarning();\n\t\t\t}, timeUntilWarning);\n\t\t} else {\n\t\t\t// Should show warning immediately\n\t\t\tthis.showSessionWarning();\n\t\t}\n\t}\n\n\t/**\n\t * Show session warning\n\t */\n\tprivate showSessionWarning(): void {\n\t\tif (!this.sessionState || this.sessionState.warningShown) return;\n\n\t\tthis.sessionState.warningShown = true;\n\n\t\tconst now = Date.now();\n\t\tconst timeRemaining = Math.max(0, Math.round((this.sessionState.expiresAt - now) / 1000));\n\n\t\tlog.debug('Showing session warning', false, { timeRemaining });\n\n\t\tif (this.onSessionWarning) {\n\t\t\tthis.onSessionWarning(timeRemaining);\n\t\t}\n\n\t\t// Schedule automatic logout\n\t\tthis.timeoutTimer = setTimeout(() => {\n\t\t\tthis.endSession();\n\t\t}, timeRemaining * 1000);\n\t}\n\n\t/**\n\t * Start activity tracking\n\t */\n\tprivate startActivityTracking(): void {\n\t\tif (!browser || this.activityListenersAdded) return;\n\n\t\tconst events = ['mousedown', 'keydown', 'scroll', 'touchstart', 'mousemove'];\n\t\tconst handleActivity = () => this.updateActivity();\n\n\t\tevents.forEach((event) => {\n\t\t\tdocument.addEventListener(event, handleActivity, { passive: true });\n\t\t});\n\n\t\tthis.activityListenersAdded = true;\n\t\tlog.debug('Activity tracking started', false);\n\t}\n\n\t/**\n\t * Remove activity listeners\n\t */\n\tprivate removeActivityListeners(): void {\n\t\tif (!browser || !this.activityListenersAdded) return;\n\n\t\tconst events = ['mousedown', 'keydown', 'scroll', 'touchstart', 'mousemove'];\n\t\tconst handleActivity = () => this.updateActivity();\n\n\t\tevents.forEach((event) => {\n\t\t\tdocument.removeEventListener(event, handleActivity);\n\t\t});\n\n\t\tthis.activityListenersAdded = false;\n\t\tlog.debug('Activity tracking stopped', false);\n\t}\n\n\t/**\n\t * Clear all timers\n\t */\n\tprivate clearTimers(): void {\n\t\tif (this.timeoutTimer) {\n\t\t\tclearTimeout(this.timeoutTimer);\n\t\t\tthis.timeoutTimer = null;\n\t\t}\n\t\tif (this.warningTimer) {\n\t\t\tclearTimeout(this.warningTimer);\n\t\t\tthis.warningTimer = null;\n\t\t}\n\t}\n\n\t/**\n\t * Generate unique session ID\n\t */\n\tprivate generateSessionId(): string {\n\t\tconst timestamp = Date.now().toString(36);\n\t\tconst random = Math.random().toString(36).substring(2);\n\t\treturn `session-${timestamp}-${random}`;\n\t}\n\n\t/**\n\t * Save session state to storage\n\t */\n\tprivate async saveSessionState(): Promise<void> {\n\t\tif (!browser || !this.sessionState) return;\n\n\t\ttry {\n\t\t\tif (browser_ext) {\n\t\t\t\tawait browser_ext.storage.local.set({\n\t\t\t\t\tyakklSession: this.sessionState\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlocalStorage.setItem('yakklSession', JSON.stringify(this.sessionState));\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlog.warn('Failed to save session state:', false, error);\n\t\t}\n\t}\n\n\t/**\n\t * Load session state from storage\n\t */\n\tprivate async loadSessionState(): Promise<SessionState | null> {\n\t\tif (!browser) return null;\n\n\t\ttry {\n\t\t\tif (browser_ext) {\n\t\t\t\tconst result = await browser_ext.storage.local.get(['yakklSession']);\n\t\t\t\treturn (result.yakklSession as SessionState) || null;\n\t\t\t} else {\n\t\t\t\tconst stored = localStorage.getItem('yakklSession');\n\t\t\t\treturn stored ? JSON.parse(stored) : null;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlog.warn('Failed to load session state:', false, error);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Clear session storage\n\t */\n\tprivate async clearSessionStorage(): Promise<void> {\n\t\tif (!browser) return;\n\n\t\ttry {\n\t\t\tif (browser_ext) {\n\t\t\t\tawait browser_ext.storage.local.remove(['yakklSession']);\n\t\t\t} else {\n\t\t\t\tlocalStorage.removeItem('yakklSession');\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlog.warn('Failed to clear session storage:', false, error);\n\t\t}\n\t}\n\n\t/**\n\t * Notify background script of session events\n\t */\n\tprivate notifyBackgroundScript(type: string, data: any): void {\n\t\tif (!browser || !browser_ext) return;\n\n\t\ttry {\n\t\t\tbrowser_ext.runtime.sendMessage({\n\t\t\t\ttype: `SESSION_${type}`,\n\t\t\t\tdata\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlog.warn('Failed to notify background script:', false, error);\n\t\t}\n\t}\n}\n\n// Export singleton instance\nexport const sessionManager = SessionManager.getInstance();\n","import { writable, derived, get } from 'svelte/store';\nimport { browser } from '$app/environment';\nimport { verify } from '$lib/common/security';\nimport { getSettings, getMiscStore, setMiscStore } from '$lib/common/stores';\nimport type { Profile } from '$lib/common/interfaces';\nimport { log } from '$lib/common/logger-wrapper';\nimport { sessionManager, type SessionState } from '$lib/managers/SessionManager';\nimport { jwtManager } from '$lib/utilities/jwt';\n\ninterface AuthState {\n\tisAuthenticated: boolean;\n\tisRegistered: boolean;\n\tprofile: Profile | null;\n\tlastActivity: number;\n\tsessionTimeout: number; // in minutes\n\tisInitializing: boolean;\n\tsessionState: SessionState | null;\n\tjwtToken: string | null;\n\tshowSessionWarning: boolean;\n\tsessionTimeRemaining: number; // seconds until session expires\n}\n\nconst defaultAuthState: AuthState = {\n\tisAuthenticated: false,\n\tisRegistered: false,\n\tprofile: null,\n\tlastActivity: Date.now(),\n\tsessionTimeout: 30, // 30 minutes default\n\tisInitializing: false,\n\tsessionState: null,\n\tjwtToken: null,\n\tshowSessionWarning: false,\n\tsessionTimeRemaining: 0\n};\n\nfunction createAuthStore() {\n\tconst { subscribe, set, update } = writable<AuthState>(defaultAuthState);\n\n\tlet activityListenersAdded = false;\n\n\t// Setup session management callbacks\n\tfunction setupSessionCallbacks() {\n\t\tsessionManager.setCallbacks({\n\t\t\tonWarning: (timeRemaining: number) => {\n\t\t\t\tupdate((state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tshowSessionWarning: true,\n\t\t\t\t\tsessionTimeRemaining: timeRemaining\n\t\t\t\t}));\n\t\t\t\tlog.debug('Session warning triggered', false, { timeRemaining });\n\t\t\t},\n\t\t\tonExpired: () => {\n\t\t\t\tupdate((state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tisAuthenticated: false,\n\t\t\t\t\tsessionState: null,\n\t\t\t\t\tjwtToken: null,\n\t\t\t\t\tshowSessionWarning: false,\n\t\t\t\t\tprofile: null\n\t\t\t\t}));\n\t\t\t\tsetMiscStore('');\n\t\t\t\tlog.debug('Session expired', false);\n\t\t\t},\n\t\t\tonExtended: () => {\n\t\t\t\tconst newSessionState = sessionManager.getSessionState();\n\t\t\t\tupdate((state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tsessionState: newSessionState,\n\t\t\t\t\tjwtToken: newSessionState?.jwtToken || null,\n\t\t\t\t\tshowSessionWarning: false,\n\t\t\t\t\tlastActivity: Date.now()\n\t\t\t\t}));\n\t\t\t\tlog.debug('Session extended', false);\n\t\t\t}\n\t\t});\n\t}\n\n\t// Activity tracker - only add listeners once\n\tfunction addActivityListeners() {\n\t\tif (browser && !activityListenersAdded) {\n\t\t\tconst events = ['mousedown', 'keydown', 'scroll', 'touchstart', 'mousemove'];\n\n\t\t\tconst updateActivity = () => {\n\t\t\t\tupdate((state) => ({ ...state, lastActivity: Date.now() }));\n\t\t\t};\n\n\t\t\tevents.forEach((event) => {\n\t\t\t\tdocument.addEventListener(event, updateActivity, { passive: true });\n\t\t\t});\n\n\t\t\tactivityListenersAdded = true;\n\t\t}\n\t}\n\n\treturn {\n\t\tsubscribe,\n\n\t\tasync initialize() {\n\t\t\ttry {\n\t\t\t\tupdate((state) => ({ ...state, isInitializing: true }));\n\n\t\t\t\tconst settings = await getSettings();\n\t\t\t\tconst miscStore = getMiscStore();\n\n\t\t\t\tconst isRegistered = !!(settings?.init && settings?.legal?.termsAgreed);\n\t\t\t\tconst isAuthenticated = !!(miscStore && miscStore.length > 0);\n\n\t\t\t\tupdate((state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tisRegistered,\n\t\t\t\t\tisAuthenticated,\n\t\t\t\t\tlastActivity: Date.now(),\n\t\t\t\t\tisInitializing: false\n\t\t\t\t}));\n\n\t\t\t\t// Add activity listeners after initialization\n\t\t\t\taddActivityListeners();\n\n\t\t\t\t// Setup session management callbacks\n\t\t\t\tsetupSessionCallbacks();\n\n\t\t\t\t// Check for existing session\n\t\t\t\tconst sessionState = sessionManager.getSessionState();\n\t\t\t\tif (sessionState && sessionManager.isSessionActive()) {\n\t\t\t\t\tupdate((state) => ({\n\t\t\t\t\t\t...state,\n\t\t\t\t\t\tsessionState,\n\t\t\t\t\t\tjwtToken: sessionState.jwtToken,\n\t\t\t\t\t\tisAuthenticated: true\n\t\t\t\t\t}));\n\t\t\t\t}\n\n\t\t\t\tlog.debug('Auth store initialized', false, { isRegistered, isAuthenticated });\n\t\t\t} catch (error) {\n\t\t\t\tlog.error('Error initializing auth store:', false, error);\n\t\t\t\tupdate((state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tisInitializing: false,\n\t\t\t\t\tisAuthenticated: false,\n\t\t\t\t\tisRegistered: false\n\t\t\t\t}));\n\t\t\t}\n\t\t},\n\n\t\tasync login(username: string, password: string): Promise<Profile> {\n\t\t\ttry {\n\t\t\t\t// Format the username properly (removing .nfs.id if already present, then adding it)\n\t\t\t\tconst normalizedUsername = username.toLowerCase().trim().replace('.nfs.id', '');\n\t\t\t\tconst loginString = normalizedUsername + '.nfs.id' + password;\n\n\t\t\t\t// Call the existing verify function - this is the core authentication\n\t\t\t\tconst profile = await verify(loginString);\n\n\t\t\t\tif (!profile) {\n\t\t\t\t\tthrow new Error('Invalid credentials or profile not found');\n\t\t\t\t}\n\n\t\t\t\t// Get the digest that was set during verification\n\t\t\t\tconst digest = getMiscStore();\n\t\t\t\tif (!digest) {\n\t\t\t\t\tthrow new Error('Authentication succeeded but failed to retrieve security digest');\n\t\t\t\t}\n\n\t\t\t\t// Get user's plan level for JWT\n\t\t\t\tconst settings = await getSettings();\n\t\t\t\tconst planLevel = settings?.plan?.type || 'basic';\n\n\t\t\t\t// Start session with JWT token generation\n\t\t\t\tconst jwtToken = await sessionManager.startSession(\n\t\t\t\t\tprofile.id || profile.userName,\n\t\t\t\t\tprofile.userName,\n\t\t\t\t\tprofile.id || profile.userName,\n\t\t\t\t\tplanLevel\n\t\t\t\t);\n\n\t\t\t\tconst sessionState = sessionManager.getSessionState();\n\n\t\t\t\tupdate((state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tisAuthenticated: true,\n\t\t\t\t\tprofile,\n\t\t\t\t\tlastActivity: Date.now(),\n\t\t\t\t\tsessionState,\n\t\t\t\t\tjwtToken\n\t\t\t\t}));\n\n\t\t\t\tlog.debug('User logged in successfully', false, {\n\t\t\t\t\tusername: normalizedUsername,\n\t\t\t\t\tsessionId: sessionState?.sessionId\n\t\t\t\t});\n\t\t\t\treturn profile;\n\t\t\t} catch (error) {\n\t\t\t\tlog.error('Login failed:', false, error);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t},\n\n\t\tasync logout() {\n\t\t\ttry {\n\t\t\t\t// End session\n\t\t\t\tawait sessionManager.endSession();\n\n\t\t\t\tsetMiscStore('');\n\t\t\t\tupdate((state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tisAuthenticated: false,\n\t\t\t\t\tprofile: null,\n\t\t\t\t\tlastActivity: Date.now(),\n\t\t\t\t\tsessionState: null,\n\t\t\t\t\tjwtToken: null,\n\t\t\t\t\tshowSessionWarning: false\n\t\t\t\t}));\n\t\t\t\tlog.debug('User logged out', false);\n\t\t\t} catch (error) {\n\t\t\t\tlog.error('Error during logout:', false, error);\n\t\t\t}\n\t\t},\n\n\t\tcheckSession(): boolean {\n\t\t\ttry {\n\t\t\t\tconst state = get(authStore);\n\t\t\t\tconst now = Date.now();\n\t\t\t\tconst timeoutMs = state.sessionTimeout * 60 * 1000;\n\n\t\t\t\tif (state.isAuthenticated && now - state.lastActivity > timeoutMs) {\n\t\t\t\t\tlog.warn('Session expired due to inactivity', false);\n\t\t\t\t\tthis.logout();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn state.isAuthenticated;\n\t\t\t} catch (error) {\n\t\t\t\tlog.error('Error checking session:', false, error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\t\tupdateLastActivity() {\n\t\t\tupdate((state) => ({ ...state, lastActivity: Date.now() }));\n\t\t},\n\n\t\tsetSessionTimeout(minutes: number) {\n\t\t\tupdate((state) => ({ ...state, sessionTimeout: minutes }));\n\t\t},\n\n\t\t// Helper method to refresh registration status\n\t\tasync refreshRegistrationStatus() {\n\t\t\ttry {\n\t\t\t\tconst settings = await getSettings();\n\t\t\t\tconst isRegistered = !!(settings?.init && settings?.legal?.termsAgreed);\n\n\t\t\t\tupdate((state) => ({ ...state, isRegistered }));\n\t\t\t\treturn isRegistered;\n\t\t\t} catch (error) {\n\t\t\t\tlog.error('Error refreshing registration status:', false, error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\t\t// Session management methods\n\t\tasync extendSession(additionalMinutes: number = 30): Promise<void> {\n\t\t\ttry {\n\t\t\t\tawait sessionManager.extendSession(additionalMinutes);\n\n\t\t\t\tconst sessionState = sessionManager.getSessionState();\n\t\t\t\tupdate((state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tsessionState,\n\t\t\t\t\tjwtToken: sessionState?.jwtToken || null,\n\t\t\t\t\tshowSessionWarning: false,\n\t\t\t\t\tlastActivity: Date.now()\n\t\t\t\t}));\n\t\t\t} catch (error) {\n\t\t\t\tlog.error('Failed to extend session:', false, error);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t},\n\n\t\tdismissSessionWarning() {\n\t\t\tupdate((state) => ({\n\t\t\t\t...state,\n\t\t\t\tshowSessionWarning: false\n\t\t\t}));\n\t\t},\n\n\t\tgetCurrentJWTToken(): string | null {\n\t\t\tconst state = get(authStore);\n\t\t\treturn state.jwtToken;\n\t\t},\n\n\t\tgetSessionTimeRemaining(): number {\n\t\t\tconst state = get(authStore);\n\t\t\tif (!state.sessionState) return 0;\n\n\t\t\tconst now = Date.now();\n\t\t\treturn Math.max(0, Math.round((state.sessionState.expiresAt - now) / 1000));\n\t\t}\n\t};\n}\n\nexport const authStore = createAuthStore();\n\n// Derived stores for convenient access\nexport const isAuthenticated = derived(authStore, ($auth) => $auth.isAuthenticated);\nexport const isRegistered = derived(authStore, ($auth) => $auth.isRegistered);\nexport const authProfile = derived(authStore, ($auth) => $auth.profile);\nexport const lastActivity = derived(authStore, ($auth) => $auth.lastActivity);\nexport const isAuthInitializing = derived(authStore, ($auth) => $auth.isInitializing);\n\n// Session management derived stores\nexport const sessionState = derived(authStore, ($auth) => $auth.sessionState);\nexport const jwtToken = derived(authStore, ($auth) => $auth.jwtToken);\nexport const showSessionWarning = derived(authStore, ($auth) => $auth.showSessionWarning);\nexport const sessionTimeRemaining = derived(authStore, ($auth) => $auth.sessionTimeRemaining);\nexport const hasValidJWT = derived(authStore, ($auth) => {\n\tif (!$auth.jwtToken) return false;\n\n\ttry {\n\t\tconst decoded = jwtManager.decodeToken($auth.jwtToken);\n\t\tif (!decoded) return false;\n\n\t\tconst now = Math.floor(Date.now() / 1000);\n\t\treturn decoded.payload.exp > now;\n\t} catch {\n\t\treturn false;\n\t}\n});\n\n// Helper function to get current auth state\nexport function getAuthState() {\n\treturn get(authStore);\n}\n\n// Auto-initialize on import if in browser\nif (browser) {\n\tauthStore.initialize().catch((error) => {\n\t\tlog.error('Failed to auto-initialize auth store:', false, error);\n\t});\n}\n"],"names":["async","verify","id","profile","getProfile","digest","digestMessage","isEncryptedData","data","profileData","decryptData","setMiscStore","sessionToken","storeEncryptedHash","storeSessionToken","token","expiresAt","log","info","e","error","JWTManager","static","issuer","audience","algorithm","constructor","getInstance","instance","generateToken","userId","username","profileId","planLevel","expirationMinutes","now","Math","floor","Date","sessionId","this","generateSessionId","header","alg","typ","payload","sub","iat","exp","iss","aud","encodedHeader","base64UrlEncode","JSON","stringify","encodedPayload","signature","generateSignature","getSigningKey","debug","Error","validateToken","parts","split","length","signingKey","expectedSignature","parse","base64UrlDecode","warn","refreshTokenIfNeeded","refreshThresholdMinutes","timeUntilExpiry","threshold","decodeToken","getTimeUntilExpiration","decoded","max","timestamp","toString","random","substring","key","encoder","TextEncoder","keyData","encode","messageData","cryptoKey","crypto","subtle","importKey","name","hash","sign","Uint8Array","input","base64","btoa","String","fromCharCode","replace","padded","padEnd","atob","jwtManager","DEFAULT_CONFIG","timeoutMinutes","warningMinutes","maxInactivityMinutes","autoExtendOnActivity","jwtExpirationMinutes","SessionManager","config","sessionState","timeoutTimer","warningTimer","activityListenersAdded","onSessionWarning","onSessionExpired","onSessionExtended","initializeFromStorage","startSession","jwtToken","isActive","lastActivity","warningShown","saveSessionState","startActivityTracking","scheduleWarning","browser","browser_ext","extendSession","additionalMinutes","newExpiresAt","refreshedToken","clearTimers","endSession","removeActivityListeners","clearSessionStorage","getSessionState","getCurrentJWTToken","isSessionActive","updateActivity","warningThreshold","setCallbacks","callbacks","onWarning","onExpired","onExtended","updateConfig","newConfig","timeUntilWarning","setTimeout","showSessionWarning","timeRemaining","round","clearTimeout","loadSessionState","notifyBackgroundScript","type","sessionManager","defaultAuthState","isAuthenticated","isRegistered","sessionTimeout","isInitializing","sessionTimeRemaining","createAuthStore","subscribe","set","update","writable","setupSessionCallbacks","state","newSessionState","addActivityListeners","initialize","settings","getSettings","miscStore","getMiscStore","init","legal","termsAgreed","login","password","normalizedUsername","toLowerCase","trim","loginString","plan","userName","logout","checkSession","get","authStore","timeoutMs","updateLastActivity","setSessionTimeout","minutes","refreshRegistrationStatus","dismissSessionWarning","getSessionTimeRemaining","derived","$auth"],"mappings":"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"}