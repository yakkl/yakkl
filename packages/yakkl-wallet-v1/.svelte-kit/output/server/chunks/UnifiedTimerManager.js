import{l as log}from"./Logger.js";class UnifiedTimerManager{intervals=new Map;timeouts=new Map;static instance=null;constructor(){if(UnifiedTimerManager.instance){return UnifiedTimerManager.instance}UnifiedTimerManager.instance=this}static getInstance(){return UnifiedTimerManager.instance??new UnifiedTimerManager}static clearInstance(){if(this.instance){this.instance.clearAll()}this.instance=null}static resetInstance(){this.clearInstance();return this.getInstance()}addInterval(id,callback,duration){if(this.intervals.has(id)){log.warn(`Interval "${id}" already exists.`);return}this.intervals.set(id,{id:id,callback:callback,duration:duration,handle:null,type:"interval"})}startInterval(id,immediate=false){const timer=this.intervals.get(id);if(!timer)return log.error(`Interval "${id}" not found.`);if(timer.handle)return log.warn(`Interval "${id}" is already running.`);if(immediate){timer.callback()}timer.handle=setInterval(timer.callback,timer.duration)}stopInterval(id){const timer=this.intervals.get(id);if(!timer)return log.warn(`Interval "${id}" not found.`);if(!timer.handle)return log.warn(`Interval "${id}" is not running.`);clearInterval(timer.handle);timer.handle=null}removeInterval(id){this.stopInterval(id);this.intervals.delete(id)}addTimeout(id,callback,duration){if(this.timeouts.has(id)){log.warn(`Timeout "${id}" already exists.`);return}this.timeouts.set(id,{id:id,callback:callback,duration:duration,handle:null,type:"timeout"})}startTimeout(id){const timer=this.timeouts.get(id);if(!timer)return log.error(`Timeout "${id}" not found.`);if(timer.handle)return log.warn(`Timeout "${id}" is already running.`);timer.handle=setTimeout(()=>{timer.callback();timer.handle=null},timer.duration)}stopTimeout(id){const timer=this.timeouts.get(id);if(!timer)return log.warn(`Timeout "${id}" not found.`);if(!timer.handle)return log.warn(`Timeout "${id}" is not running.`);clearTimeout(timer.handle);timer.handle=null}removeTimeout(id){this.stopTimeout(id);this.timeouts.delete(id)}clearAll(){this.intervals.forEach((_,id)=>this.stopInterval(id));this.intervals.clear();this.timeouts.forEach((_,id)=>this.stopTimeout(id));this.timeouts.clear()}getRunningTimers(){const intervals=Array.from(this.intervals.entries()).filter(([_,timer])=>timer.handle!==null).map(([id])=>id);const timeouts=Array.from(this.timeouts.entries()).filter(([_,timer])=>timer.handle!==null).map(([id])=>id);return{intervals:intervals,timeouts:timeouts}}isIntervalRunning(id){return!!this.intervals.get(id)?.handle}isTimeoutRunning(id){return!!this.timeouts.get(id)?.handle}addTimer(id,callback,duration){this.addInterval(id,callback,duration)}startTimer(id){this.startInterval(id)}stopTimer(id){this.stopInterval(id)}removeTimer(id){this.removeInterval(id)}hasTimer(id){return this.intervals.has(id)}isRunning(id){return this.isIntervalRunning(id)}static createDebounce(func,delay){let timeoutId=null;const debounced=(...args)=>{if(timeoutId){clearTimeout(timeoutId)}timeoutId=setTimeout(()=>{func(...args);timeoutId=null},delay)};debounced.cancel=()=>{if(timeoutId){clearTimeout(timeoutId);timeoutId=null}};return debounced}static createThrottle(func,limit){let inThrottle=false;return(...args)=>{if(!inThrottle){func(...args);inThrottle=true;setTimeout(()=>{inThrottle=false},limit)}}}}UnifiedTimerManager.getInstance();export{UnifiedTimerManager};
//# sourceMappingURL=UnifiedTimerManager.js.map
