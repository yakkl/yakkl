{"version":3,"file":"AccountTokenCacheManager.js","sources":["../../../../src/lib/managers/AccountTokenCacheManager.ts"],"sourcesContent":["import { log } from '$lib/managers/Logger';\nimport type { TokenData } from '$lib/common/interfaces';\nimport type { BigNumberish } from '$lib/common/bignumber';\n\nexport interface CachedTokenData extends TokenData {\n\ttimestamp: number;\n\taccountAddress: string;\n}\n\nexport interface AccountTokenCache {\n\t[accountAddress: string]: {\n\t\ttokens: Map<string, CachedTokenData>;\n\t\tlastUpdated: number;\n\t\tportfolioValue?: number;\n\t\tportfolioValueCurrency?: string;\n\t};\n}\n\nexport class AccountTokenCacheManager {\n\tprivate static instance: AccountTokenCacheManager | null = null;\n\tprivate readonly CACHE_KEY = 'yakkl_account_token_cache';\n\tprivate readonly CACHE_DURATION = 15 * 60 * 1000; // 15 minutes (increased from 5 to reduce API calls)\n\tprivate readonly STALE_DURATION = 10 * 60 * 1000; // 10 minutes (increased from 2 to reduce background refreshes)\n\tprivate readonly PORTFOLIO_CACHE_DURATION = 20 * 60 * 1000; // 20 minutes for portfolio calculations (increased from 10)\n\tprivate cache: AccountTokenCache = {};\n\n\tprivate constructor() {\n\t\tthis.loadFromStorage();\n\t}\n\n\tpublic static getInstance(): AccountTokenCacheManager {\n\t\tif (!AccountTokenCacheManager.instance) {\n\t\t\tAccountTokenCacheManager.instance = new AccountTokenCacheManager();\n\t\t}\n\t\treturn AccountTokenCacheManager.instance;\n\t}\n\n\t/**\n\t * Get cached tokens for a specific account\n\t */\n\tpublic getCachedTokensForAccount(accountAddress: string): TokenData[] | null {\n\t\tconst account = this.cache[accountAddress.toLowerCase()];\n\t\tif (!account) return null;\n\n\t\t// Check if cache is expired\n\t\tconst age = Date.now() - account.lastUpdated;\n\t\tif (age > this.CACHE_DURATION) {\n\t\t\tdelete this.cache[accountAddress.toLowerCase()];\n\t\t\tthis.saveToStorage();\n\t\t\treturn null;\n\t\t}\n\n\t\treturn Array.from(account.tokens.values()).map((token) => {\n\t\t\tconst { timestamp, ...tokenData } = token;\n\t\t\treturn tokenData as TokenData;\n\t\t});\n\t}\n\n\t/**\n\t * Get a specific cached token for an account\n\t */\n\tpublic getCachedToken(accountAddress: string, tokenAddress: string): TokenData | null {\n\t\tconst account = this.cache[accountAddress.toLowerCase()];\n\t\tif (!account) return null;\n\n\t\tconst token = account.tokens.get(tokenAddress.toLowerCase());\n\t\tif (!token) return null;\n\n\t\t// Check if cache is expired\n\t\tconst age = Date.now() - token.timestamp;\n\t\tif (age > this.CACHE_DURATION) {\n\t\t\taccount.tokens.delete(tokenAddress.toLowerCase());\n\t\t\tthis.saveToStorage();\n\t\t\treturn null;\n\t\t}\n\n\t\tconst { timestamp, ...tokenData } = token;\n\t\treturn tokenData as TokenData;\n\t}\n\n\t/**\n\t * Check if cached data is stale for an account\n\t */\n\tpublic isAccountTokensStale(accountAddress: string): boolean {\n\t\tconst account = this.cache[accountAddress.toLowerCase()];\n\t\tif (!account) return false;\n\n\t\tconst age = Date.now() - account.lastUpdated;\n\t\treturn age > this.STALE_DURATION;\n\t}\n\n\t/**\n\t * Check if a specific token is stale for an account\n\t */\n\tpublic isTokenStale(accountAddress: string, tokenAddress: string): boolean {\n\t\tconst account = this.cache[accountAddress.toLowerCase()];\n\t\tif (!account) return false;\n\n\t\tconst token = account.tokens.get(tokenAddress.toLowerCase());\n\t\tif (!token) return false;\n\n\t\tconst age = Date.now() - token.timestamp;\n\t\treturn age > this.STALE_DURATION;\n\t}\n\n\t/**\n\t * Cache tokens for a specific account\n\t */\n\tpublic setCachedTokensForAccount(accountAddress: string, tokens: TokenData[]): void {\n\t\tconst normalizedAddress = accountAddress.toLowerCase();\n\t\tconst timestamp = Date.now();\n\n\t\tif (!this.cache[normalizedAddress]) {\n\t\t\tthis.cache[normalizedAddress] = {\n\t\t\t\ttokens: new Map(),\n\t\t\t\tlastUpdated: timestamp\n\t\t\t};\n\t\t}\n\n\t\t// Clear existing tokens and add new ones\n\t\tthis.cache[normalizedAddress].tokens.clear();\n\t\tthis.cache[normalizedAddress].lastUpdated = timestamp;\n\n\t\ttokens.forEach((token) => {\n\t\t\tif (token.address) {\n\t\t\t\tconst cachedToken: CachedTokenData = {\n\t\t\t\t\t...token,\n\t\t\t\t\ttimestamp,\n\t\t\t\t\taccountAddress: normalizedAddress\n\t\t\t\t};\n\t\t\t\tthis.cache[normalizedAddress].tokens.set(token.address.toLowerCase(), cachedToken);\n\t\t\t}\n\t\t});\n\n\t\tthis.saveToStorage();\n\n\t\tlog.debug('[AccountTokenCacheManager] Cached tokens for account:', false, {\n\t\t\taddress: normalizedAddress,\n\t\t\ttokenCount: tokens.length\n\t\t});\n\t}\n\n\t/**\n\t * Update a specific token for an account\n\t */\n\tpublic updateTokenForAccount(accountAddress: string, token: TokenData): void {\n\t\tconst normalizedAddress = accountAddress.toLowerCase();\n\t\tconst timestamp = Date.now();\n\n\t\tif (!this.cache[normalizedAddress]) {\n\t\t\tthis.cache[normalizedAddress] = {\n\t\t\t\ttokens: new Map(),\n\t\t\t\tlastUpdated: timestamp\n\t\t\t};\n\t\t}\n\n\t\tif (token.address) {\n\t\t\tconst cachedToken: CachedTokenData = {\n\t\t\t\t...token,\n\t\t\t\ttimestamp,\n\t\t\t\taccountAddress: normalizedAddress\n\t\t\t};\n\n\t\t\tthis.cache[normalizedAddress].tokens.set(token.address.toLowerCase(), cachedToken);\n\t\t\tthis.cache[normalizedAddress].lastUpdated = timestamp;\n\t\t\tthis.saveToStorage();\n\n\t\t\tlog.debug('[AccountTokenCacheManager] Updated token for account:', false, {\n\t\t\t\taddress: normalizedAddress,\n\t\t\t\ttokenSymbol: token.symbol,\n\t\t\t\ttokenAddress: token.address\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Cache portfolio value for an account\n\t */\n\tpublic setCachedPortfolioValue(\n\t\taccountAddress: string,\n\t\tvalue: number,\n\t\tcurrency: string = 'USD'\n\t): void {\n\t\tconst normalizedAddress = accountAddress.toLowerCase();\n\n\t\tif (!this.cache[normalizedAddress]) {\n\t\t\tthis.cache[normalizedAddress] = {\n\t\t\t\ttokens: new Map(),\n\t\t\t\tlastUpdated: Date.now()\n\t\t\t};\n\t\t}\n\n\t\tthis.cache[normalizedAddress].portfolioValue = value;\n\t\tthis.cache[normalizedAddress].portfolioValueCurrency = currency;\n\t\tthis.saveToStorage();\n\n\t\tlog.debug('[AccountTokenCacheManager] Cached portfolio value for account:', false, {\n\t\t\taddress: normalizedAddress,\n\t\t\tvalue,\n\t\t\tcurrency\n\t\t});\n\t}\n\n\t/**\n\t * Get cached portfolio value for an account\n\t */\n\tpublic getCachedPortfolioValue(\n\t\taccountAddress: string\n\t): { value: number; currency: string } | null {\n\t\tconst account = this.cache[accountAddress.toLowerCase()];\n\t\tif (!account || account.portfolioValue === undefined) return null;\n\n\t\t// Check if portfolio cache is expired\n\t\tconst age = Date.now() - account.lastUpdated;\n\t\tif (age > this.PORTFOLIO_CACHE_DURATION) {\n\t\t\tif (account.portfolioValue !== undefined) {\n\t\t\t\tdelete account.portfolioValue;\n\t\t\t\tdelete account.portfolioValueCurrency;\n\t\t\t\tthis.saveToStorage();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tvalue: account.portfolioValue,\n\t\t\tcurrency: account.portfolioValueCurrency || 'USD'\n\t\t};\n\t}\n\n\t/**\n\t * Check if portfolio value is stale for an account\n\t */\n\tpublic isPortfolioValueStale(accountAddress: string): boolean {\n\t\tconst account = this.cache[accountAddress.toLowerCase()];\n\t\tif (!account || account.portfolioValue === undefined) return false;\n\n\t\tconst age = Date.now() - account.lastUpdated;\n\t\treturn age > this.STALE_DURATION;\n\t}\n\n\t/**\n\t * Remove a specific token from account cache\n\t */\n\tpublic removeTokenFromAccount(accountAddress: string, tokenAddress: string): void {\n\t\tconst account = this.cache[accountAddress.toLowerCase()];\n\t\tif (!account) return;\n\n\t\taccount.tokens.delete(tokenAddress.toLowerCase());\n\t\taccount.lastUpdated = Date.now();\n\t\tthis.saveToStorage();\n\n\t\tlog.debug('[AccountTokenCacheManager] Removed token from account cache:', false, {\n\t\t\taccountAddress: accountAddress.toLowerCase(),\n\t\t\ttokenAddress: tokenAddress.toLowerCase()\n\t\t});\n\t}\n\n\t/**\n\t * Clear all cached data for a specific account\n\t */\n\tpublic clearAccountCache(accountAddress: string): void {\n\t\tdelete this.cache[accountAddress.toLowerCase()];\n\t\tthis.saveToStorage();\n\t\tlog.info('[AccountTokenCacheManager] Cleared cache for account:', false, {\n\t\t\taddress: accountAddress.toLowerCase()\n\t\t});\n\t}\n\n\t/**\n\t * Clear all cached data\n\t */\n\tpublic clearAllCache(): void {\n\t\tthis.cache = {};\n\t\tlocalStorage.removeItem(this.CACHE_KEY);\n\t\tlog.info('[AccountTokenCacheManager] All cache cleared');\n\t}\n\n\t/**\n\t * Get all cached account addresses\n\t */\n\tpublic getCachedAccountAddresses(): string[] {\n\t\treturn Object.keys(this.cache);\n\t}\n\n\t/**\n\t * Clean up expired entries\n\t */\n\tpublic cleanupExpired(): void {\n\t\tconst now = Date.now();\n\t\tlet cleanedAccounts = 0;\n\t\tlet cleanedTokens = 0;\n\n\t\tfor (const [accountAddress, account] of Object.entries(this.cache)) {\n\t\t\t// Check if entire account cache is expired\n\t\t\tif (now - account.lastUpdated > this.CACHE_DURATION) {\n\t\t\t\tdelete this.cache[accountAddress];\n\t\t\t\tcleanedAccounts++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Clean up individual expired tokens\n\t\t\tfor (const [tokenAddress, token] of account.tokens.entries()) {\n\t\t\t\tif (now - token.timestamp > this.CACHE_DURATION) {\n\t\t\t\t\taccount.tokens.delete(tokenAddress);\n\t\t\t\t\tcleanedTokens++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Clean up expired portfolio values\n\t\t\tif (\n\t\t\t\taccount.portfolioValue !== undefined &&\n\t\t\t\tnow - account.lastUpdated > this.PORTFOLIO_CACHE_DURATION\n\t\t\t) {\n\t\t\t\tdelete account.portfolioValue;\n\t\t\t\tdelete account.portfolioValueCurrency;\n\t\t\t}\n\t\t}\n\n\t\tif (cleanedAccounts > 0 || cleanedTokens > 0) {\n\t\t\tthis.saveToStorage();\n\t\t\tlog.info(\n\t\t\t\t`[AccountTokenCacheManager] Cleaned up ${cleanedAccounts} accounts and ${cleanedTokens} tokens`\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Preload tokens for multiple accounts\n\t */\n\tpublic preloadTokensForAccounts(accountAddresses: string[]): Map<string, TokenData[]> {\n\t\tconst preloaded = new Map<string, TokenData[]>();\n\n\t\tfor (const address of accountAddresses) {\n\t\t\tconst tokens = this.getCachedTokensForAccount(address);\n\t\t\tif (tokens) {\n\t\t\t\tpreloaded.set(address.toLowerCase(), tokens);\n\t\t\t}\n\t\t}\n\n\t\tlog.debug(\n\t\t\t`[AccountTokenCacheManager] Preloaded tokens for ${preloaded.size}/${accountAddresses.length} accounts`\n\t\t);\n\t\treturn preloaded;\n\t}\n\n\t/**\n\t * Update token prices for all cached tokens\n\t */\n\tpublic updateTokenPricesForAllAccounts(\n\t\tpriceUpdates: Map<string, { price: number; change?: any }>\n\t): void {\n\t\tlet updatedCount = 0;\n\n\t\tfor (const [accountAddress, account] of Object.entries(this.cache)) {\n\t\t\tfor (const [tokenAddress, token] of account.tokens.entries()) {\n\t\t\t\tconst priceUpdate = priceUpdates.get(tokenAddress);\n\t\t\t\tif (priceUpdate) {\n\t\t\t\t\ttoken.price = {\n\t\t\t\t\t\tprice: priceUpdate.price,\n\t\t\t\t\t\tprovider: 'cache-update',\n\t\t\t\t\t\tlastUpdated: new Date()\n\t\t\t\t\t};\n\t\t\t\t\tif (priceUpdate.change) {\n\t\t\t\t\t\ttoken.change = priceUpdate.change;\n\t\t\t\t\t}\n\t\t\t\t\ttoken.timestamp = Date.now(); // Refresh timestamp since price changed\n\t\t\t\t\tupdatedCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (updatedCount > 0) {\n\t\t\tthis.saveToStorage();\n\t\t\tlog.info(`[AccountTokenCacheManager] Updated prices for ${updatedCount} cached tokens`);\n\t\t}\n\t}\n\n\t/**\n\t * Get cache statistics\n\t */\n\tpublic getCacheStats(): {\n\t\ttotalAccounts: number;\n\t\ttotalTokens: number;\n\t\tfreshAccounts: number;\n\t\tstaleAccounts: number;\n\t\texpiredAccounts: number;\n\t} {\n\t\tconst now = Date.now();\n\t\tlet totalTokens = 0;\n\t\tlet fresh = 0;\n\t\tlet stale = 0;\n\t\tlet expired = 0;\n\n\t\tfor (const account of Object.values(this.cache)) {\n\t\t\ttotalTokens += account.tokens.size;\n\t\t\tconst age = now - account.lastUpdated;\n\n\t\t\tif (age > this.CACHE_DURATION) {\n\t\t\t\texpired++;\n\t\t\t} else if (age > this.STALE_DURATION) {\n\t\t\t\tstale++;\n\t\t\t} else {\n\t\t\t\tfresh++;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttotalAccounts: Object.keys(this.cache).length,\n\t\t\ttotalTokens,\n\t\t\tfreshAccounts: fresh,\n\t\t\tstaleAccounts: stale,\n\t\t\texpiredAccounts: expired\n\t\t};\n\t}\n\n\t/**\n\t * Load cache from localStorage\n\t */\n\tprivate loadFromStorage(): void {\n\t\ttry {\n\t\t\tconst stored = localStorage.getItem(this.CACHE_KEY);\n\t\t\tif (stored) {\n\t\t\t\tconst parsed = JSON.parse(stored);\n\n\t\t\t\t// Convert the stored data back to the proper structure\n\t\t\t\tthis.cache = {};\n\t\t\t\tfor (const [accountAddress, accountData] of Object.entries(parsed)) {\n\t\t\t\t\tconst typedAccountData = accountData as any;\n\t\t\t\t\tthis.cache[accountAddress] = {\n\t\t\t\t\t\tlastUpdated: typedAccountData.lastUpdated,\n\t\t\t\t\t\tportfolioValue: typedAccountData.portfolioValue,\n\t\t\t\t\t\tportfolioValueCurrency: typedAccountData.portfolioValueCurrency,\n\t\t\t\t\t\ttokens: new Map()\n\t\t\t\t\t};\n\n\t\t\t\t\t// Restore tokens map\n\t\t\t\t\tif (typedAccountData.tokens) {\n\t\t\t\t\t\tfor (const [tokenAddress, tokenData] of Object.entries(typedAccountData.tokens)) {\n\t\t\t\t\t\t\tconst typedTokenData = tokenData as any;\n\t\t\t\t\t\t\t// Convert balance back to BigInt if it exists\n\t\t\t\t\t\t\tif (typedTokenData.balance && typeof typedTokenData.balance === 'string') {\n\t\t\t\t\t\t\t\ttypedTokenData.balance = BigInt(typedTokenData.balance);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.cache[accountAddress].tokens.set(tokenAddress, typedTokenData);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Clean up expired entries on load\n\t\t\t\tthis.cleanupExpired();\n\n\t\t\t\tlog.debug(\n\t\t\t\t\t`[AccountTokenCacheManager] Loaded cache for ${Object.keys(this.cache).length} accounts`\n\t\t\t\t);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlog.warn('[AccountTokenCacheManager] Failed to load cache from storage:', false, error);\n\t\t\tthis.cache = {};\n\t\t}\n\t}\n\n\t/**\n\t * Save cache to localStorage\n\t */\n\tprivate saveToStorage(): void {\n\t\ttry {\n\t\t\t// Convert Maps to objects for JSON serialization\n\t\t\tconst serializable: any = {};\n\n\t\t\tfor (const [accountAddress, account] of Object.entries(this.cache)) {\n\t\t\t\tserializable[accountAddress] = {\n\t\t\t\t\tlastUpdated: account.lastUpdated,\n\t\t\t\t\tportfolioValue: account.portfolioValue,\n\t\t\t\t\tportfolioValueCurrency: account.portfolioValueCurrency,\n\t\t\t\t\ttokens: {}\n\t\t\t\t};\n\n\t\t\t\t// Convert token Map to object and handle BigInt serialization\n\t\t\t\tfor (const [tokenAddress, token] of account.tokens.entries()) {\n\t\t\t\t\tconst serializableToken = { ...token };\n\n\t\t\t\t\t// Convert BigInt to string for JSON serialization\n\t\t\t\t\tif (serializableToken.balance && typeof serializableToken.balance === 'bigint') {\n\t\t\t\t\t\tserializableToken.balance = serializableToken.balance.toString() as any;\n\t\t\t\t\t}\n\n\t\t\t\t\tserializable[accountAddress].tokens[tokenAddress] = serializableToken;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlocalStorage.setItem(this.CACHE_KEY, JSON.stringify(serializable));\n\t\t} catch (error) {\n\t\t\tlog.warn('[AccountTokenCacheManager] Failed to save cache to storage:', false, error);\n\t\t}\n\t}\n}\n\n// Export singleton instance\nexport const accountTokenCacheManager = AccountTokenCacheManager.getInstance();\n"],"names":["AccountTokenCacheManager","static","CACHE_KEY","CACHE_DURATION","STALE_DURATION","PORTFOLIO_CACHE_DURATION","cache","constructor","this","loadFromStorage","getInstance","instance","getCachedTokensForAccount","accountAddress","account","toLowerCase","age","Date","now","lastUpdated","saveToStorage","Array","from","tokens","values","map","token","timestamp","tokenData","getCachedToken","tokenAddress","get","delete","isAccountTokensStale","isTokenStale","setCachedTokensForAccount","normalizedAddress","Map","clear","forEach","address","cachedToken","set","log","debug","tokenCount","length","updateTokenForAccount","tokenSymbol","symbol","setCachedPortfolioValue","value","currency","portfolioValue","portfolioValueCurrency","getCachedPortfolioValue","isPortfolioValueStale","removeTokenFromAccount","clearAccountCache","info","clearAllCache","localStorage","removeItem","getCachedAccountAddresses","Object","keys","cleanupExpired","cleanedAccounts","cleanedTokens","entries","preloadTokensForAccounts","accountAddresses","preloaded","size","updateTokenPricesForAllAccounts","priceUpdates","updatedCount","priceUpdate","price","provider","change","getCacheStats","totalTokens","fresh","stale","expired","totalAccounts","freshAccounts","staleAccounts","expiredAccounts","stored","getItem","parsed","JSON","parse","accountData","typedAccountData","typedTokenData","balance","BigInt","error","warn","serializable","serializableToken","toString","setItem","stringify"],"mappings":"kCAkBO,MAAMA,yBACZC,gBAA2D,KAC1CC,UAAY,4BACZC,eAAiB,GAAK,GAAK,IAC3BC,eAAiB,GAAK,GAAK,IAC3BC,yBAA2B,GAAK,GAAK,IAC9CC,MAA2B,CAAC,EAE5B,WAAAC,GACPC,KAAKC,iBAAgB,CAGtB,kBAAcC,GACT,IAACV,yBAAyBW,SAAU,CACdX,yBAAAW,SAAW,IAAIX,wBAAyB,CAElE,OAAOA,yBAAyBW,QAAA,CAM1B,yBAAAC,CAA0BC,gBAChC,MAAMC,QAAUN,KAAKF,MAAMO,eAAeE,eACtC,IAACD,QAAgB,OAAA,KAGrB,MAAME,IAAMC,KAAKC,MAAQJ,QAAQK,YAC7B,GAAAH,IAAMR,KAAKL,eAAgB,QACvBK,KAAKF,MAAMO,eAAeE,eACjCP,KAAKY,gBACE,OAAA,IAAA,CAGD,OAAAC,MAAMC,KAAKR,QAAQS,OAAOC,UAAUC,IAAKC,QAC/C,MAAMC,UAAEA,aAAcC,WAAcF,MAC7B,OAAAE,WACP,CAMK,cAAAC,CAAehB,eAAwBiB,cAC7C,MAAMhB,QAAUN,KAAKF,MAAMO,eAAeE,eACtC,IAACD,QAAgB,OAAA,KAErB,MAAMY,MAAQZ,QAAQS,OAAOQ,IAAID,aAAaf,eAC1C,IAACW,MAAc,OAAA,KAGnB,MAAMV,IAAMC,KAAKC,MAAQQ,MAAMC,UAC3B,GAAAX,IAAMR,KAAKL,eAAgB,CAC9BW,QAAQS,OAAOS,OAAOF,aAAaf,eACnCP,KAAKY,gBACE,OAAA,IAAA,CAGR,MAAMO,UAAEA,aAAcC,WAAcF,MAC7B,OAAAE,SAAA,CAMD,oBAAAK,CAAqBpB,gBAC3B,MAAMC,QAAUN,KAAKF,MAAMO,eAAeE,eACtC,IAACD,QAAgB,OAAA,MAErB,MAAME,IAAMC,KAAKC,MAAQJ,QAAQK,YACjC,OAAOH,IAAMR,KAAKJ,cAAA,CAMZ,YAAA8B,CAAarB,eAAwBiB,cAC3C,MAAMhB,QAAUN,KAAKF,MAAMO,eAAeE,eACtC,IAACD,QAAgB,OAAA,MAErB,MAAMY,MAAQZ,QAAQS,OAAOQ,IAAID,aAAaf,eAC1C,IAACW,MAAc,OAAA,MAEnB,MAAMV,IAAMC,KAAKC,MAAQQ,MAAMC,UAC/B,OAAOX,IAAMR,KAAKJ,cAAA,CAMZ,yBAAA+B,CAA0BtB,eAAwBU,QAClD,MAAAa,kBAAoBvB,eAAeE,cACnC,MAAAY,UAAYV,KAAKC,MAEvB,IAAKV,KAAKF,MAAM8B,mBAAoB,CAC9B5B,KAAAF,MAAM8B,mBAAqB,CAC/Bb,WAAYc,IACZlB,YAAaQ,UACd,CAIDnB,KAAKF,MAAM8B,mBAAmBb,OAAOe,QAChC9B,KAAAF,MAAM8B,mBAAmBjB,YAAcQ,UAErCJ,OAAAgB,QAASb,QACf,GAAIA,MAAMc,QAAS,CAClB,MAAMC,YAA+B,IACjCf,MACHC,oBACAd,eAAgBuB,mBAEZ5B,KAAAF,MAAM8B,mBAAmBb,OAAOmB,IAAIhB,MAAMc,QAAQzB,cAAe0B,YAAW,IAInFjC,KAAKY,gBAEDuB,IAAAC,MAAM,wDAAyD,MAAO,CACzEJ,QAASJ,kBACTS,WAAYtB,OAAOuB,QACnB,CAMK,qBAAAC,CAAsBlC,eAAwBa,OAC9C,MAAAU,kBAAoBvB,eAAeE,cACnC,MAAAY,UAAYV,KAAKC,MAEvB,IAAKV,KAAKF,MAAM8B,mBAAoB,CAC9B5B,KAAAF,MAAM8B,mBAAqB,CAC/Bb,WAAYc,IACZlB,YAAaQ,UACd,CAGD,GAAID,MAAMc,QAAS,CAClB,MAAMC,YAA+B,IACjCf,MACHC,oBACAd,eAAgBuB,mBAGZ5B,KAAAF,MAAM8B,mBAAmBb,OAAOmB,IAAIhB,MAAMc,QAAQzB,cAAe0B,aACjEjC,KAAAF,MAAM8B,mBAAmBjB,YAAcQ,UAC5CnB,KAAKY,gBAEDuB,IAAAC,MAAM,wDAAyD,MAAO,CACzEJ,QAASJ,kBACTY,YAAatB,MAAMuB,OACnBnB,aAAcJ,MAAMc,SACpB,CACF,CAMM,uBAAAU,CACNrC,eACAsC,MACAC,SAAmB,OAEb,MAAAhB,kBAAoBvB,eAAeE,cAEzC,IAAKP,KAAKF,MAAM8B,mBAAoB,CAC9B5B,KAAAF,MAAM8B,mBAAqB,CAC/Bb,WAAYc,IACZlB,YAAaF,KAAKC,MACnB,CAGIV,KAAAF,MAAM8B,mBAAmBiB,eAAiBF,MAC1C3C,KAAAF,MAAM8B,mBAAmBkB,uBAAyBF,SACvD5C,KAAKY,gBAEDuB,IAAAC,MAAM,iEAAkE,MAAO,CAClFJ,QAASJ,kBACTe,YACAC,mBACA,CAMK,uBAAAG,CACN1C,gBAEA,MAAMC,QAAUN,KAAKF,MAAMO,eAAeE,eAC1C,IAAKD,SAAWA,QAAQuC,wBAAqC,OAAA,KAG7D,MAAMrC,IAAMC,KAAKC,MAAQJ,QAAQK,YAC7B,GAAAH,IAAMR,KAAKH,yBAA0B,CACpC,GAAAS,QAAQuC,sBAA8B,EAAA,QAClCvC,QAAQuC,sBACRvC,QAAQwC,uBACf9C,KAAKY,eAAc,CAEb,OAAA,IAAA,CAGD,MAAA,CACN+B,MAAOrC,QAAQuC,eACfD,SAAUtC,QAAQwC,wBAA0B,MAC7C,CAMM,qBAAAE,CAAsB3C,gBAC5B,MAAMC,QAAUN,KAAKF,MAAMO,eAAeE,eAC1C,IAAKD,SAAWA,QAAQuC,wBAAqC,OAAA,MAE7D,MAAMrC,IAAMC,KAAKC,MAAQJ,QAAQK,YACjC,OAAOH,IAAMR,KAAKJ,cAAA,CAMZ,sBAAAqD,CAAuB5C,eAAwBiB,cACrD,MAAMhB,QAAUN,KAAKF,MAAMO,eAAeE,eAC1C,IAAKD,QAAS,OAEdA,QAAQS,OAAOS,OAAOF,aAAaf,eAC3BD,QAAAK,YAAcF,KAAKC,MAC3BV,KAAKY,gBAEDuB,IAAAC,MAAM,+DAAgE,MAAO,CAChF/B,eAAgBA,eAAeE,cAC/Be,aAAcA,aAAaf,eAC3B,CAMK,iBAAA2C,CAAkB7C,uBACjBL,KAAKF,MAAMO,eAAeE,eACjCP,KAAKY,gBACDuB,IAAAgB,KAAK,wDAAyD,MAAO,CACxEnB,QAAS3B,eAAeE,eACxB,CAMK,aAAA6C,GACNpD,KAAKF,MAAQ,CAAC,EACDuD,aAAAC,WAAWtD,KAAKN,WAC7ByC,IAAIgB,KAAK,+CAA8C,CAMjD,yBAAAI,GACC,OAAAC,OAAOC,KAAKzD,KAAKF,MAAK,CAMvB,cAAA4D,GACA,MAAAhD,IAAMD,KAAKC,MACjB,IAAIiD,gBAAkB,EACtB,IAAIC,cAAgB,EAET,IAAA,MAACvD,eAAgBC,WAAYkD,OAAOK,QAAQ7D,KAAKF,OAAQ,CAEnE,GAAIY,IAAMJ,QAAQK,YAAcX,KAAKL,eAAgB,QAC7CK,KAAKF,MAAMO,gBAClBsD,kBACA,QAAA,CAID,IAAA,MAAYrC,aAAcJ,SAAUZ,QAAQS,OAAO8C,UAAW,CAC7D,GAAInD,IAAMQ,MAAMC,UAAYnB,KAAKL,eAAgB,CACxCW,QAAAS,OAAOS,OAAOF,cACtBsC,eAAA,CACD,CAID,GACCtD,QAAQuC,sBAAmB,GAC3BnC,IAAMJ,QAAQK,YAAcX,KAAKH,yBAChC,QACMS,QAAQuC,sBACRvC,QAAQwC,sBAAA,CAChB,CAGG,GAAAa,gBAAkB,GAAKC,cAAgB,EAAG,CAC7C5D,KAAKY,gBACDuB,IAAAgB,KACH,yCAAyCQ,gCAAgCC,uBAC1E,CACD,CAMM,wBAAAE,CAAyBC,kBACzB,MAAAC,cAAgBnC,IAEtB,IAAA,MAAWG,WAAW+B,iBAAkB,CACjC,MAAAhD,OAASf,KAAKI,0BAA0B4B,SAC9C,GAAIjB,OAAQ,CACXiD,UAAU9B,IAAIF,QAAQzB,cAAeQ,OAAM,CAC5C,CAGGoB,IAAAC,MACH,mDAAmD4B,UAAUC,QAAQF,iBAAiBzB,mBAEhF,OAAA0B,SAAA,CAMD,+BAAAE,CACNC,cAEA,IAAIC,aAAe,EAER,IAAA,MAAC/D,eAAgBC,WAAYkD,OAAOK,QAAQ7D,KAAKF,OAAQ,CACnE,IAAA,MAAYwB,aAAcJ,SAAUZ,QAAQS,OAAO8C,UAAW,CACvD,MAAAQ,YAAcF,aAAa5C,IAAID,cACrC,GAAI+C,YAAa,CAChBnD,MAAMoD,MAAQ,CACbA,MAAOD,YAAYC,MACnBC,SAAU,eACV5D,gBAAiBF,MAElB,GAAI4D,YAAYG,OAAQ,CACvBtD,MAAMsD,OAASH,YAAYG,MAAA,CAEtBtD,MAAAC,UAAYV,KAAKC,MACvB0D,cAAA,CACD,CACD,CAGD,GAAIA,aAAe,EAAG,CACrBpE,KAAKY,gBACDuB,IAAAgB,KAAK,iDAAiDiB,6BAA4B,CACvF,CAMM,aAAAK,GAOA,MAAA/D,IAAMD,KAAKC,MACjB,IAAIgE,YAAc,EAClB,IAAIC,MAAQ,EACZ,IAAIC,MAAQ,EACZ,IAAIC,QAAU,EAEd,IAAA,MAAWvE,WAAWkD,OAAOxC,OAAOhB,KAAKF,OAAQ,CAChD4E,aAAepE,QAAQS,OAAOkD,KACxB,MAAAzD,IAAME,IAAMJ,QAAQK,YAEtB,GAAAH,IAAMR,KAAKL,eAAgB,CAC9BkF,SAAA,MAAA,GACUrE,IAAMR,KAAKJ,eAAgB,CACrCgF,OAAA,KACM,CACND,OAAA,CACD,CAGM,MAAA,CACNG,cAAetB,OAAOC,KAAKzD,KAAKF,OAAOwC,OACvCoC,wBACAK,cAAeJ,MACfK,cAAeJ,MACfK,gBAAiBJ,QAClB,CAMO,eAAA5E,GACH,IACH,MAAMiF,OAAS7B,aAAa8B,QAAQnF,KAAKN,WACzC,GAAIwF,OAAQ,CACL,MAAAE,OAASC,KAAKC,MAAMJ,QAG1BlF,KAAKF,MAAQ,CAAC,EACd,IAAA,MAAYO,eAAgBkF,eAAgB/B,OAAOK,QAAQuB,QAAS,CACnE,MAAMI,iBAAmBD,YACpBvF,KAAAF,MAAMO,gBAAkB,CAC5BM,YAAa6E,iBAAiB7E,YAC9BkC,eAAgB2C,iBAAiB3C,eACjCC,uBAAwB0C,iBAAiB1C,uBACzC/B,WAAYc,KAIb,GAAI2D,iBAAiBzE,OAAQ,CACjB,IAAA,MAACO,aAAcF,aAAcoC,OAAOK,QAAQ2B,iBAAiBzE,QAAS,CAChF,MAAM0E,eAAiBrE,UAEvB,GAAIqE,eAAeC,gBAAkBD,eAAeC,UAAY,SAAU,CAC1DD,eAAAC,QAAUC,OAAOF,eAAeC,QAAO,CAEvD1F,KAAKF,MAAMO,gBAAgBU,OAAOmB,IAAIZ,aAAcmE,eAAc,CACnE,CACD,CAIDzF,KAAK0D,iBAEDvB,IAAAC,MACH,+CAA+CoB,OAAOC,KAAKzD,KAAKF,OAAOwC,kBACxE,QAEOsD,OACJzD,IAAA0D,KAAK,gEAAiE,MAAOD,OACjF5F,KAAKF,MAAQ,CAAC,CAAA,CACf,CAMO,aAAAc,GACH,IAEH,MAAMkF,aAAoB,CAAC,EAEhB,IAAA,MAACzF,eAAgBC,WAAYkD,OAAOK,QAAQ7D,KAAKF,OAAQ,CACnEgG,aAAazF,gBAAkB,CAC9BM,YAAaL,QAAQK,YACrBkC,eAAgBvC,QAAQuC,eACxBC,uBAAwBxC,QAAQwC,uBAChC/B,OAAQ,CAAA,GAIT,IAAA,MAAYO,aAAcJ,SAAUZ,QAAQS,OAAO8C,UAAW,CACvD,MAAAkC,kBAAoB,IAAK7E,OAG/B,GAAI6E,kBAAkBL,gBAAkBK,kBAAkBL,UAAY,SAAU,CAC7DK,kBAAAL,QAAUK,kBAAkBL,QAAQM,UAAS,CAGhEF,aAAazF,gBAAgBU,OAAOO,cAAgByE,iBAAA,CACrD,CAGD1C,aAAa4C,QAAQjG,KAAKN,UAAW2F,KAAKa,UAAUJ,qBAC5CF,OACJzD,IAAA0D,KAAK,8DAA+D,MAAOD,MAAK,CACrF,EAKsCpG,yBAAyBU"}