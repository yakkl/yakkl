{"version":3,"file":"Logger.js","sources":["../../../../src/lib/managers/Logger.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { LoggerError } from './Errors';\nimport { openDB } from 'idb'; // IndexedDB support\nimport Dexie from 'dexie'; // Dexie.js for IndexedDB\n// import { browser_ext } from \"$lib/common/environment\";\n// import { initSQLite, saveToSQLite } from \"./LoggerSQLite\"; // SQLite integration\n\nconst isBrowser = typeof window !== 'undefined';\n\n// Define log levels\nenum LogLevel {\n\tDEBUG = 0,\n\tDEBUG_TRACE = 1,\n\tINFO = 2,\n\tINFO_TRACE = 3,\n\tWARN = 4,\n\tERROR = 5,\n\tERROR_TRACE = 6,\n\tTRACE = 7\n}\n\nenum LogLevelDirection {\n\tNONE = 0,\n\tCONTAINS = 1,\n\tLESSTHAN = 2,\n\tGREATERTHAN = 3,\n\tEQUAL = 4,\n\tGREATERTHANOREQUAL = 5,\n\tLESSTHANOREQUAL = 6\n}\n\n// Color styles for browser console logs\nconst COLORS = {\n\tDEBUG: 'color: purple; font-weight: bold;',\n\tDEBUG_TRACE: 'color: purple; font-weight: bold;',\n\tINFO: 'color: green; font-weight: bold;',\n\tINFO_TRACE: 'color: green; font-weight: bold;',\n\tWARN: 'color: orange; font-weight: bold;',\n\tERROR: 'color: red; font-weight: bold;',\n\tERROR_TRACE: 'color: red; font-weight: bold;',\n\tTRACE: 'color: blue; font-weight: bold;'\n};\n\nconst MAX_STORED_LOGS = 500; // Maximum number of logs to keep in storage\nconst STORAGE_KEY = 'yakklLogs'; // Key for localStorage\n\n// TBD - Add id and persona to the log entry??? Not sure\n// Add these interfaces\nexport interface LogEntry {\n\ttimestamp: string;\n\tlabel: string;\n\tmessage: string;\n\tcallerInfo: string;\n\tstack?: string;\n\targs?: any[];\n}\n\n/**\n * Logger class with structured logging, log levels, and optional regex filtering.\n */\nclass Logger {\n\tprivate static instance: Logger | null = null;\n\tprivate logLevel: LogLevel;\n\tprivate logLevelDirection: LogLevelDirection;\n\tprivate logsIncluded: string[] = [];\n\tprivate logRegEx: RegExp = /^(DEBUG|DEBUG_TRACE|INFO|INFO_TRACE|WARN|ERROR|ERROR_TRACE|TRACE)$/;\n\tprivate logFilterEnabled: boolean = false;\n\tprivate stackIndex = 4;\n\tprivate backend: string = 'localStorage'; // Default logging backend. 'console' should always display and the other values will only get used if persist is true\n\tprivate minLogLevel: LogLevel = LogLevel.ERROR;\n\n\tconstructor(\n\t\tlevel: LogLevel = LogLevel.DEBUG,\n\t\tdirection: LogLevelDirection = LogLevelDirection.LESSTHAN,\n\t\tlogsIncluded: string[] = [\n\t\t\t'DEBUG',\n\t\t\t'DEBUG_TRACE',\n\t\t\t'INFO',\n\t\t\t'INFO_TRACE',\n\t\t\t'WARN',\n\t\t\t'ERROR',\n\t\t\t'ERROR_TRACE',\n\t\t\t'TRACE'\n\t\t]\n\t) {\n\t\tthis.logLevel = level;\n\t\tthis.logLevelDirection = direction;\n\t\tthis.logsIncluded = logsIncluded;\n\t}\n\n\t// Add singleton getter\n\tpublic static getInstance(): Logger {\n\t\tif (!Logger.instance) {\n\t\t\tLogger.instance = new Logger();\n\t\t}\n\t\treturn Logger.instance;\n\t}\n\n\t// Add setter for minimum log level\n\tsetMinimumLogLevel(level: LogLevel): void {\n\t\tthis.minLogLevel = level;\n\t}\n\n\tsetLevel(\n\t\tlevel: keyof typeof LogLevel,\n\t\tdirection: keyof typeof LogLevelDirection,\n\t\tlogsIncluded: string[] = [\n\t\t\t'DEBUG',\n\t\t\t'DEBUG_TRACE',\n\t\t\t'INFO',\n\t\t\t'INFO_TRACE',\n\t\t\t'WARN',\n\t\t\t'ERROR',\n\t\t\t'ERROR_TRACE',\n\t\t\t'TRACE'\n\t\t]\n\t): void {\n\t\tthis.logLevel = LogLevel[level];\n\t\tthis.logLevelDirection = LogLevelDirection[direction];\n\t\tthis.logsIncluded = logsIncluded;\n\t}\n\n\t/**\n\t * Enables or disables regex-based log filtering.\n\t */\n\tsetLogFilterEnabled(enabled: boolean): void {\n\t\tthis.logFilterEnabled = enabled;\n\t}\n\n\t/**\n\t * Sets a regex pattern to filter log messages.\n\t */\n\tsetLogFilterRegex(pattern: string): void {\n\t\ttry {\n\t\t\tthis.logRegEx = new RegExp(pattern, 'i'); // Case-insensitive\n\t\t} catch (error: any) {\n\t\t\tthis.error('Invalid regex pattern:', false, error);\n\t\t}\n\t}\n\n\tsetStackIndex(index: number): void {\n\t\tif (index < 0) throw new Error('Stack index must be a positive number');\n\t\tthis.stackIndex = index;\n\t}\n\n\t/**\n\t * Updates the logging backend dynamically.\n\t */\n\tsetBackend(backendType: string): void {\n\t\tthis.backend = backendType;\n\t}\n\n\tgetMinimumLogLevel(): LogLevel {\n\t\treturn this.minLogLevel;\n\t}\n\n\tprivate getTimestamp(): string {\n\t\treturn new Date().toISOString();\n\t}\n\n\tprivate getCallerInfo(): string {\n\t\tconst stack = new Error().stack;\n\t\tif (!stack) return 'Unknown Caller';\n\t\tconst stackLines = stack.split('\\n').length;\n\t\tconst adjustedIndex = Math.min(this.stackIndex, stackLines - 1) ?? this.stackIndex;\n\t\tconst callerLine = stack.split('\\n')[adjustedIndex]?.trim();\n\t\treturn callerLine || 'Unknown Caller';\n\t}\n\n\tprivate normalizeInput(input: unknown): { message: string; stack?: string } {\n\t\tif (input instanceof Error) {\n\t\t\treturn { message: input.message, stack: input.stack };\n\t\t} else if (typeof input === 'string') {\n\t\t\treturn { message: input };\n\t\t} else if (input === null || input === undefined) {\n\t\t\treturn { message: String(input) };\n\t\t} else {\n\t\t\treturn { message: JSON.stringify(input, null, 2) };\n\t\t}\n\t}\n\n\tprivate persistLog(entry: LogEntry): void {\n\t\ttry {\n\t\t\tswitch (this.backend) {\n\t\t\t\tcase 'indexedDB':\n\t\t\t\t\tthis.persistLogIndexedDB(entry);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'dexie':\n\t\t\t\t\tthis.persistLogDexie(entry);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'sqlite':\n\t\t\t\t\tthis.persistLogSQLite(entry);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'background':\n\t\t\t\t\tthis.persistLogBackground(entry);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'localStorage':\n\t\t\t\tdefault:\n\t\t\t\t\tthis.persistLogLocalStorage(entry);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} catch (error: any) {\n\t\t\tthis.error('Failed to persist log:', false, error);\n\t\t}\n\t}\n\n\tprivate persistLogLocalStorage(log: LogEntry): void {\n\t\ttry {\n\t\t\t// Do not store at this time. localStorage could fail for local environment reasons.\n\t\t\treturn;\n\n\t\t\tif (typeof localStorage !== 'undefined') {\n\t\t\t\tconst logs = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');\n\n\t\t\t\t// Ensure args are serializable\n\t\t\t\tif (log.args) {\n\t\t\t\t\tlog.args = log.args.map((arg) => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// Test if the arg can be properly serialized\n\t\t\t\t\t\t\tJSON.parse(JSON.stringify(arg));\n\t\t\t\t\t\t\treturn arg;\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t// If not serializable, convert to string representation\n\t\t\t\t\t\t\treturn String(arg);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tlogs.push(log);\n\t\t\t\twhile (logs.length > MAX_STORED_LOGS) {\n\t\t\t\t\tlogs.shift();\n\t\t\t\t}\n\t\t\t\tlocalStorage.setItem(STORAGE_KEY, JSON.stringify(logs));\n\t\t\t}\n\t\t} catch (error: any) {\n\t\t\tthis.error('Failed to persist to localStorage:', error);\n\t\t}\n\t}\n\n\tprivate persistLogIndexedDB(log: LogEntry): void {\n\t\tconst dbPromise = openDB(STORAGE_KEY, 1, {\n\t\t\tupgrade(db) {\n\t\t\t\tif (!db.objectStoreNames.contains('logs')) {\n\t\t\t\t\tdb.createObjectStore('logs', {\n\t\t\t\t\t\tkeyPath: 'id',\n\t\t\t\t\t\tautoIncrement: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// Ensure args are serializable\n\t\tif (log.args) {\n\t\t\tlog.args = log.args.map((arg) => {\n\t\t\t\ttry {\n\t\t\t\t\tJSON.parse(JSON.stringify(arg));\n\t\t\t\t\treturn arg;\n\t\t\t\t} catch {\n\t\t\t\t\treturn String(arg);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tdbPromise.then(async (db) => {\n\t\t\tconst tx = db.transaction('logs', 'readwrite');\n\t\t\tconst store = tx.objectStore('logs');\n\t\t\tawait store.add(log);\n\n\t\t\t// Keep only latest logs\n\t\t\tconst allLogs = await store.getAll();\n\t\t\twhile (allLogs.length > MAX_STORED_LOGS) {\n\t\t\t\tawait store.delete(allLogs[0].id);\n\t\t\t\tallLogs.shift();\n\t\t\t}\n\t\t\tawait tx.done;\n\t\t});\n\t}\n\n\tprivate persistLogDexie(log: LogEntry): void {\n\t\tconst dexieDB = new Dexie(STORAGE_KEY);\n\t\tdexieDB.version(1).stores({\n\t\t\tlogs: '++id, timestamp, label, message, args'\n\t\t});\n\n\t\t// Ensure args are serializable\n\t\tif (log.args) {\n\t\t\tlog.args = log.args.map((arg) => {\n\t\t\t\ttry {\n\t\t\t\t\tJSON.parse(JSON.stringify(arg));\n\t\t\t\t\treturn arg;\n\t\t\t\t} catch {\n\t\t\t\t\treturn String(arg);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tdexieDB.table('logs').add(log);\n\n\t\t// Keep only latest logs\n\t\tdexieDB\n\t\t\t.table('logs')\n\t\t\t.count()\n\t\t\t.then((count) => {\n\t\t\t\tif (count > MAX_STORED_LOGS) {\n\t\t\t\t\tdexieDB\n\t\t\t\t\t\t.table('logs')\n\t\t\t\t\t\t.orderBy('id')\n\t\t\t\t\t\t.first((firstLog) => {\n\t\t\t\t\t\t\tif (firstLog) {\n\t\t\t\t\t\t\t\tdexieDB.table('logs').delete(firstLog.id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\tprivate persistLogSQLite(log: LogEntry): void {\n\t\t// saveToSQLite(log);\n\t\t// Keep only the latest MAX_STORED_LOGS entries\n\t\t// const db = initSQLite();\n\t\t// db.transaction((tx) => {\n\t\t//   tx.executeSql(\"SELECT COUNT(*) FROM logs\", [], (tx, result) => {\n\t\t//     const count = result.rows.item(0)[\"COUNT(*)\"];\n\t\t//     if (count > MAX_STORED_LOGS) {\n\t\t//       tx.executeSql(\"DELETE FROM logs WHERE id = (SELECT MIN(id) FROM logs)\");\n\t\t//     }\n\t\t//   });\n\t\t//   tx.executeSql(\"INSERT INTO logs (timestamp, label, message) VALUES (?, ?, ?)\", [log.timestamp, log.label, log.message]);\n\t\t// });\n\t}\n\n\tprivate persistLogBackground(log: LogEntry): void {\n\t\t// if (!browser_ext) return;\n\t\t// browser_ext.runtime.sendMessage({ type: \"LOG_MESSAGE\", key: STORAGE_KEY, maxStored: MAX_STORED_LOGS, log: log });\n\t}\n\n\t// Add utility methods for persistent logs\n\tclearPersistedLogs(): void {\n\t\tswitch (this.backend) {\n\t\t\tcase 'indexedDB':\n\t\t\t\topenDB(STORAGE_KEY, 1).then((db) => {\n\t\t\t\t\tdb.transaction('logs', 'readwrite').objectStore('logs').clear();\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'dexie':\n\t\t\t\tconst dexieDB = new Dexie(STORAGE_KEY);\n\t\t\t\tdexieDB.version(1).stores({ logs: '++id, message, timestamp' });\n\t\t\t\tdexieDB.table('logs').clear();\n\t\t\t\tbreak;\n\t\t\tcase 'sqlite':\n\t\t\t\t//   const db = initSQLite();\n\t\t\t\t//   db.transaction((tx) => {\n\t\t\t\t//     tx.executeSql(\"DELETE FROM logs\");\n\t\t\t\t//   });\n\t\t\t\tbreak;\n\t\t\tcase 'background':\n\t\t\t\t// if (!browser_ext) return;\n\t\t\t\t// browser_ext.runtime.sendMessage({ type: \"CLEAR_LOGS\", key: STORAGE_KEY });\n\t\t\t\tbreak;\n\n\t\t\tcase 'localStorage':\n\t\t\tdefault:\n\t\t\t\tlocalStorage.removeItem(STORAGE_KEY);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tgetPersistedLogs(): LogEntry[] {\n\t\ttry {\n\t\t\tswitch (this.backend) {\n\t\t\t\tcase 'indexedDB':\n\t\t\t\t\topenDB(STORAGE_KEY, 1).then((db) => {\n\t\t\t\t\t\treturn db.transaction('logs', 'readonly').objectStore('logs').getAll();\n\t\t\t\t\t});\n\t\t\t\tcase 'dexie':\n\t\t\t\t\t// const dexieDB = new Dexie(STORAGE_KEY);\n\t\t\t\t\t// dexieDB.version(1).stores({ logs: \"++id, message, timestamp\" });\n\t\t\t\t\t// return dexieDB.table(\"logs\").toArray();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'sqlite':\n\t\t\t\t\t//   const db = initSQLite();\n\t\t\t\t\t//   return new Promise((resolve, reject) => {\n\t\t\t\t\t//     db.transaction((tx) => {\n\t\t\t\t\t//       tx.executeSql(\"SELECT * FROM logs\", [], (tx, result) => {\n\t\t\t\t\t//         const logs: LogEntry[] = [];\n\t\t\t\t\t//         for (let i = 0; i < result.rows.length; i++) {\n\t\t\t\t\t//           logs.push(result.rows.item(i));\n\t\t\t\t\t//         }\n\t\t\t\t\t//         resolve(logs);\n\t\t\t\t\t//       }, (tx, error) => {\n\t\t\t\t\t//         reject(error);\n\t\t\t\t\t//       });\n\t\t\t\t\t//     });\n\t\t\t\t\t//   });\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'background':\n\t\t\t\t\t// Send to request a background script to fetch logs by sending to a more local listener for the logs\n\t\t\t\t\t// return browser_ext.runtime.sendMessage({ type: \"GET_LOGS\", key: STORAGE_KEY });\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'localstorage':\n\t\t\t\tdefault:\n\t\t\t\t\treturn JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');\n\t\t\t}\n\t\t} catch {\n\t\t\tthis.error('Failed to retrieve persisted logs');\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t/**\n\t * Generic logging function.\n\t */\n\tprivate log(\n\t\tlevel: LogLevel,\n\t\tlabel: string,\n\t\tcolor: string,\n\t\tinput: unknown,\n\t\tincludeStack = false,\n\t\tpersist = false,\n\t\t...args: any[]\n\t): void {\n\t\ttry {\n\t\t\t// Environment check that works in both Vite and pure TS environments\n\t\t\tconst isProduction = this.isProductionEnvironment();\n\n\t\t\t// Check if we should log based on environment and level\n\t\t\tif (isProduction) {\n\t\t\t\t// In production, only log WARN and above\n\t\t\t\tif (level < this.minLogLevel) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Always log to console first\n\t\t\tconst { message, stack } = this.normalizeInput(input);\n\t\t\tconst timestamp = this.getTimestamp();\n\t\t\tconst callerInfo = this.getCallerInfo();\n\n\t\t\t// Force console output for debugging\n\t\t\tconsole.log(\n\t\t\t\t`%c[${label}] ${timestamp}`,\n\t\t\t\tcolor,\n\t\t\t\tmessage,\n\t\t\t\t...(args || []),\n\t\t\t\t'\\nCaller:',\n\t\t\t\tcallerInfo,\n\t\t\t\tstack ? '\\nStack:' + stack : ''\n\t\t\t);\n\n\t\t\tif (persist) {\n\t\t\t\tconst entry: LogEntry = {\n\t\t\t\t\ttimestamp,\n\t\t\t\t\tlabel,\n\t\t\t\t\tmessage,\n\t\t\t\t\tcallerInfo,\n\t\t\t\t\tstack: includeStack ? stack : undefined,\n\t\t\t\t\targs\n\t\t\t\t};\n\t\t\t\tthis.persistLog(entry);\n\t\t\t}\n\t\t} catch (error: any) {\n\t\t\tif (!this.isProductionEnvironment() || level >= LogLevel.WARN) {\n\t\t\t\tthis.error('Logging failed:', false, error);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate isProductionEnvironment(): boolean {\n\t\t// Check various ways to determine if we're in production\n\t\tif (typeof __PROD__ !== 'undefined') {\n\t\t\treturn __PROD__;\n\t\t}\n\n\t\t// For background scripts or environments without Vite\n\t\tif (typeof process !== 'undefined' && process.env) {\n\t\t\treturn process.env.NODE_ENV === 'production';\n\t\t}\n\n\t\t// Fallback for browser environments\n\t\tif (typeof window !== 'undefined' && window.location) {\n\t\t\t// You might want to adjust this based on your production URL patterns\n\t\t\treturn (\n\t\t\t\t!window.location.hostname.includes('localhost') &&\n\t\t\t\t!window.location.hostname.includes('127.0.0.1')\n\t\t\t);\n\t\t}\n\n\t\t// Default to development if we can't determine\n\t\treturn false;\n\t}\n\n\tdebug(input: unknown, persist: boolean = false, ...args: any[]): void {\n\t\tthis.log(LogLevel.DEBUG, 'DEBUG', COLORS.DEBUG, input, false, persist, ...args);\n\t}\n\n\tdebugStack(input: unknown, persist: boolean = false, ...args: any[]): void {\n\t\tthis.log(LogLevel.DEBUG_TRACE, 'DEBUG_TRACE', COLORS.DEBUG, input, true, persist, ...args);\n\t}\n\n\tinfo(input: unknown, persist: boolean = false, ...args: any[]): void {\n\t\tthis.log(LogLevel.INFO, 'INFO', COLORS.INFO, input, false, persist, ...args);\n\t}\n\n\tinfoStack(input: unknown, persist: boolean = false, ...args: any[]): void {\n\t\tthis.log(LogLevel.INFO_TRACE, 'INFO_TRACE', COLORS.INFO, input, false, persist, ...args);\n\t}\n\n\twarn(input: unknown, persist: boolean = false, ...args: any[]): void {\n\t\tthis.log(LogLevel.WARN, 'WARN', COLORS.WARN, input, false, persist, ...args);\n\t}\n\n\terror(input: unknown, persist: boolean = false, ...args: any[]): void {\n\t\tthis.log(LogLevel.ERROR, 'ERROR', COLORS.ERROR, input, false, persist, ...args);\n\t}\n\n\terrorStack(error: unknown, persist: boolean = false, ...args: any[]): void {\n\t\tthis.log(LogLevel.ERROR_TRACE, 'ERROR_TRACE', COLORS.ERROR, false, persist, ...args);\n\t}\n\n\ttrace(input: unknown, persist: boolean = false, ...args: any[]): void {\n\t\tthis.log(LogLevel.TRACE, 'TRACE', COLORS.TRACE, input, false, persist, ...args);\n\t}\n}\n\n// Singleton instance\nconst log = Logger.getInstance();\n\nexport { log, Logger, LogLevel, LogLevelDirection };\n"],"names":["LogLevel","LogLevelDirection","COLORS","DEBUG","INFO","WARN","ERROR","TRACE","MAX_STORED_LOGS","STORAGE_KEY","Logger","static","logLevel","logLevelDirection","logsIncluded","logRegEx","logFilterEnabled","stackIndex","backend","minLogLevel","constructor","level","direction","this","getInstance","instance","setMinimumLogLevel","setLevel","setLogFilterEnabled","enabled","setLogFilterRegex","pattern","RegExp","error","setStackIndex","index","Error","setBackend","backendType","getMinimumLogLevel","getTimestamp","Date","toISOString","getCallerInfo","stack","stackLines","split","length","adjustedIndex","Math","min","callerLine","trim","normalizeInput","input","message","String","JSON","stringify","persistLog","entry","persistLogIndexedDB","persistLogDexie","persistLogSQLite","persistLogBackground","persistLogLocalStorage","log","localStorage","logs","parse","getItem","args","map","arg","push","shift","setItem","dbPromise","openDB","upgrade","db","objectStoreNames","contains","createObjectStore","keyPath","autoIncrement","then","async","tx","transaction","store","objectStore","add","allLogs","getAll","delete","id","done","dexieDB","Dexie","version","stores","table","count","orderBy","first","firstLog","clearPersistedLogs","clear","removeItem","getPersistedLogs","label","color","includeStack","persist","isProduction","isProductionEnvironment","timestamp","callerInfo","console","debug","debugStack","info","infoStack","warn","errorStack","trace"],"mappings":"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"}