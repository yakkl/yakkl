import{d as derived,w as writable,g as get}from"./index.js";import{o as getProfile,K as digestMessage,i as isEncryptedData,j as decryptData,u as setMiscStore,l as log,d as getSettings,a2 as getMiscStore}from"./encryption.js";import{a as storeEncryptedHash,b as storeSessionToken}from"./session.js";import{b as browser}from"./index4.js";import{a as browser_ext}from"./environment.js";async function verify(id){try{if(!id){return void 0}const profile=await getProfile();const digest=await digestMessage(id);if(!profile||!digest){return void 0}else{if(isEncryptedData(profile.data)){const profileData=await decryptData(profile.data,digest);if(profileData){setMiscStore(digest);const sessionToken=await storeEncryptedHash(digest);if(sessionToken){storeSessionToken(sessionToken.token,sessionToken.expiresAt)}log.info("verify - sessionToken",false,sessionToken)}else{throw"Verification failed!"}}return profile}}catch(e){log.error("Verification failed!",false,e);throw`Verification failed! - ${e}`}}class JWTManager{static instance=null;issuer="yakkl-wallet";audience="yakkl-api";algorithm="HS256";constructor(){}static getInstance(){if(!JWTManager.instance){JWTManager.instance=new JWTManager}return JWTManager.instance}async generateToken(userId,username,profileId,planLevel="basic",expirationMinutes=60){try{const now=Math.floor(Date.now()/1e3);const sessionId=this.generateSessionId();const header={alg:this.algorithm,typ:"JWT"};const payload={sub:userId,iat:now,exp:now+expirationMinutes*60,iss:this.issuer,aud:this.audience,profileId:profileId,username:username,planLevel:planLevel,sessionId:sessionId};const encodedHeader=this.base64UrlEncode(JSON.stringify(header));const encodedPayload=this.base64UrlEncode(JSON.stringify(payload));const signature=await this.generateSignature(`${encodedHeader}.${encodedPayload}`,await this.getSigningKey());const token=`${encodedHeader}.${encodedPayload}.${signature}`;log.debug("JWT token generated",false,{userId:userId,username:username,expirationMinutes:expirationMinutes,sessionId:sessionId});return token}catch(error){log.error("Failed to generate JWT token:",false,error);throw new Error("Token generation failed")}}async validateToken(token){try{const parts=token.split(".");if(parts.length!==3){throw new Error("Invalid token format")}const[encodedHeader,encodedPayload,signature]=parts;const signingKey=await this.getSigningKey();const expectedSignature=await this.generateSignature(`${encodedHeader}.${encodedPayload}`,signingKey);if(signature!==expectedSignature){throw new Error("Invalid token signature")}const payload=JSON.parse(this.base64UrlDecode(encodedPayload));const now=Math.floor(Date.now()/1e3);if(payload.exp<=now){throw new Error("Token expired")}if(payload.iss!==this.issuer||payload.aud!==this.audience){throw new Error("Invalid token issuer or audience")}log.debug("JWT token validated successfully",false,{sub:payload.sub,username:payload.username,sessionId:payload.sessionId});return payload}catch(error){log.warn("JWT token validation failed:",false,error);return null}}async refreshTokenIfNeeded(token,refreshThresholdMinutes=10){try{const payload=await this.validateToken(token);if(!payload)return null;const now=Math.floor(Date.now()/1e3);const timeUntilExpiry=payload.exp-now;if(timeUntilExpiry<=refreshThresholdMinutes*60){log.debug("Refreshing JWT token",false,{timeUntilExpiry:timeUntilExpiry,threshold:refreshThresholdMinutes*60});return await this.generateToken(payload.sub,payload.username||"",payload.profileId||"",payload.planLevel||"basic")}return token}catch(error){log.error("Failed to refresh token:",false,error);return null}}decodeToken(token){try{const parts=token.split(".");if(parts.length!==3)return null;const header=JSON.parse(this.base64UrlDecode(parts[0]));const payload=JSON.parse(this.base64UrlDecode(parts[1]));return{header:header,payload:payload}}catch{return null}}getTimeUntilExpiration(token){const decoded=this.decodeToken(token);if(!decoded)return null;const now=Math.floor(Date.now()/1e3);return Math.max(0,decoded.payload.exp-now)}generateSessionId(){const timestamp=Date.now().toString(36);const random=Math.random().toString(36).substring(2);return`${timestamp}-${random}`}async getSigningKey(){return"yakkl-fallback-signing-key-change-in-production"}async generateSignature(data,key){const encoder=new TextEncoder;const keyData=encoder.encode(key);const messageData=encoder.encode(data);const cryptoKey=await crypto.subtle.importKey("raw",keyData,{name:"HMAC",hash:"SHA-256"},false,["sign"]);const signature=await crypto.subtle.sign("HMAC",cryptoKey,messageData);return this.base64UrlEncode(new Uint8Array(signature))}base64UrlEncode(data){const input=typeof data==="string"?(new TextEncoder).encode(data):data;const base64=btoa(String.fromCharCode(...input));return base64.replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}base64UrlDecode(data){const base64=data.replace(/-/g,"+").replace(/_/g,"/");const padded=base64.padEnd(base64.length+(4-base64.length%4)%4,"=");return atob(padded)}}const jwtManager=JWTManager.getInstance();const DEFAULT_CONFIG={timeoutMinutes:30,warningMinutes:2,maxInactivityMinutes:60,autoExtendOnActivity:true,jwtExpirationMinutes:60};class SessionManager{static instance=null;config=DEFAULT_CONFIG;sessionState=null;timeoutTimer=null;warningTimer=null;activityListenersAdded=false;onSessionWarning=null;onSessionExpired=null;onSessionExtended=null;constructor(){this.initializeFromStorage()}static getInstance(){if(!SessionManager.instance){SessionManager.instance=new SessionManager}return SessionManager.instance}async startSession(userId,username,profileId,planLevel="basic"){try{const jwtToken=await jwtManager.generateToken(userId,username,profileId,planLevel,this.config.jwtExpirationMinutes);const now=Date.now();const sessionId=this.generateSessionId();this.sessionState={isActive:true,userId:userId,username:username,profileId:profileId,planLevel:planLevel,sessionId:sessionId,lastActivity:now,expiresAt:now+this.config.timeoutMinutes*60*1e3,jwtToken:jwtToken,warningShown:false};await this.saveSessionState();this.startActivityTracking();this.scheduleWarning();log.debug("Session started",false,{userId:userId,username:username,sessionId:sessionId,expiresAt:new Date(this.sessionState.expiresAt)});if(browser&&browser_ext);return jwtToken}catch(error){log.error("Failed to start session:",false,error);throw new Error("Session start failed")}}async extendSession(additionalMinutes=30){if(!this.sessionState||!this.sessionState.isActive){throw new Error("No active session to extend")}try{const now=Date.now();const newExpiresAt=now+additionalMinutes*60*1e3;if(this.sessionState.jwtToken){const refreshedToken=await jwtManager.refreshTokenIfNeeded(this.sessionState.jwtToken,10);if(refreshedToken&&refreshedToken!==this.sessionState.jwtToken){this.sessionState.jwtToken=refreshedToken;log.debug("JWT token refreshed during session extension",false)}}this.sessionState.lastActivity=now;this.sessionState.expiresAt=newExpiresAt;this.sessionState.warningShown=false;await this.saveSessionState();this.clearTimers();this.scheduleWarning();log.debug("Session extended",false,{sessionId:this.sessionState.sessionId,additionalMinutes:additionalMinutes,newExpiresAt:new Date(newExpiresAt)});if(this.onSessionExtended){this.onSessionExtended()}if(browser&&browser_ext);}catch(error){log.error("Failed to extend session:",false,error);throw new Error("Session extension failed")}}async endSession(){if(this.sessionState){log.debug("Ending session",false,{sessionId:this.sessionState.sessionId})}this.sessionState=null;this.clearTimers();this.removeActivityListeners();try{await this.clearSessionStorage()}catch(error){log.warn("Failed to clear session storage:",false,error)}if(this.onSessionExpired){this.onSessionExpired()}}getSessionState(){return this.sessionState?{...this.sessionState}:null}getCurrentJWTToken(){return this.sessionState?.jwtToken||null}isSessionActive(){if(!this.sessionState||!this.sessionState.isActive){return false}const now=Date.now();if(now>=this.sessionState.expiresAt){this.endSession();return false}return true}updateActivity(){if(!this.sessionState||!this.sessionState.isActive)return;const now=Date.now();this.sessionState.lastActivity=now;if(this.config.autoExtendOnActivity){const timeUntilExpiry=this.sessionState.expiresAt-now;const warningThreshold=this.config.warningMinutes*60*1e3;if(timeUntilExpiry<=warningThreshold&&!this.sessionState.warningShown){this.extendSession(this.config.timeoutMinutes)}}this.saveSessionState()}setCallbacks(callbacks){this.onSessionWarning=callbacks.onWarning||null;this.onSessionExpired=callbacks.onExpired||null;this.onSessionExtended=callbacks.onExtended||null}updateConfig(newConfig){this.config={...this.config,...newConfig};log.debug("Session config updated",false,this.config)}async initializeFromStorage(){return}scheduleWarning(){if(!this.sessionState)return;const now=Date.now();const timeUntilWarning=this.sessionState.expiresAt-now-this.config.warningMinutes*60*1e3;if(timeUntilWarning>0){this.warningTimer=setTimeout(()=>{this.showSessionWarning()},timeUntilWarning)}else{this.showSessionWarning()}}showSessionWarning(){if(!this.sessionState||this.sessionState.warningShown)return;this.sessionState.warningShown=true;const now=Date.now();const timeRemaining=Math.max(0,Math.round((this.sessionState.expiresAt-now)/1e3));log.debug("Showing session warning",false,{timeRemaining:timeRemaining});if(this.onSessionWarning){this.onSessionWarning(timeRemaining)}this.timeoutTimer=setTimeout(()=>{this.endSession()},timeRemaining*1e3)}startActivityTracking(){return}removeActivityListeners(){return}clearTimers(){if(this.timeoutTimer){clearTimeout(this.timeoutTimer);this.timeoutTimer=null}if(this.warningTimer){clearTimeout(this.warningTimer);this.warningTimer=null}}generateSessionId(){const timestamp=Date.now().toString(36);const random=Math.random().toString(36).substring(2);return`session-${timestamp}-${random}`}async saveSessionState(){return}async loadSessionState(){return null}async clearSessionStorage(){return}notifyBackgroundScript(type,data){return}}const sessionManager=SessionManager.getInstance();const defaultAuthState={isAuthenticated:false,isRegistered:false,profile:null,lastActivity:Date.now(),sessionTimeout:30,isInitializing:false,sessionState:null,jwtToken:null,showSessionWarning:false,sessionTimeRemaining:0};function createAuthStore(){const{subscribe:subscribe,set:set,update:update}=writable(defaultAuthState);function setupSessionCallbacks(){sessionManager.setCallbacks({onWarning:timeRemaining=>{update(state=>({...state,showSessionWarning:true,sessionTimeRemaining:timeRemaining}));log.debug("Session warning triggered",false,{timeRemaining:timeRemaining})},onExpired:()=>{update(state=>({...state,isAuthenticated:false,sessionState:null,jwtToken:null,showSessionWarning:false,profile:null}));setMiscStore("");log.debug("Session expired",false)},onExtended:()=>{const newSessionState=sessionManager.getSessionState();update(state=>({...state,sessionState:newSessionState,jwtToken:newSessionState?.jwtToken||null,showSessionWarning:false,lastActivity:Date.now()}));log.debug("Session extended",false)}})}function addActivityListeners(){}return{subscribe:subscribe,async initialize(){try{update(state=>({...state,isInitializing:true}));const settings=await getSettings();const miscStore=getMiscStore();const isRegistered2=!!(settings?.init&&settings?.legal?.termsAgreed);const isAuthenticated2=!!(miscStore&&miscStore.length>0);update(state=>({...state,isRegistered:isRegistered2,isAuthenticated:isAuthenticated2,lastActivity:Date.now(),isInitializing:false}));addActivityListeners();setupSessionCallbacks();const sessionState2=sessionManager.getSessionState();if(sessionState2&&sessionManager.isSessionActive()){update(state=>({...state,sessionState:sessionState2,jwtToken:sessionState2.jwtToken,isAuthenticated:true}))}log.debug("Auth store initialized",false,{isRegistered:isRegistered2,isAuthenticated:isAuthenticated2})}catch(error){log.error("Error initializing auth store:",false,error);update(state=>({...state,isInitializing:false,isAuthenticated:false,isRegistered:false}))}},async login(username,password){try{const normalizedUsername=username.toLowerCase().trim().replace(".nfs.id","");const loginString=normalizedUsername+".nfs.id"+password;const profile=await verify(loginString);if(!profile){throw new Error("Invalid credentials or profile not found")}const digest=getMiscStore();if(!digest){throw new Error("Authentication succeeded but failed to retrieve security digest")}const settings=await getSettings();const planLevel=settings?.plan?.type||"basic";const jwtToken2=await sessionManager.startSession(profile.id||profile.userName,profile.userName,profile.id||profile.userName,planLevel);const sessionState2=sessionManager.getSessionState();update(state=>({...state,isAuthenticated:true,profile:profile,lastActivity:Date.now(),sessionState:sessionState2,jwtToken:jwtToken2}));log.debug("User logged in successfully",false,{username:normalizedUsername,sessionId:sessionState2?.sessionId});return profile}catch(error){log.error("Login failed:",false,error);throw error}},async logout(){try{await sessionManager.endSession();setMiscStore("");update(state=>({...state,isAuthenticated:false,profile:null,lastActivity:Date.now(),sessionState:null,jwtToken:null,showSessionWarning:false}));log.debug("User logged out",false)}catch(error){log.error("Error during logout:",false,error)}},checkSession(){try{const state=get(authStore);const now=Date.now();const timeoutMs=state.sessionTimeout*60*1e3;if(state.isAuthenticated&&now-state.lastActivity>timeoutMs){log.warn("Session expired due to inactivity",false);this.logout();return false}return state.isAuthenticated}catch(error){log.error("Error checking session:",false,error);return false}},updateLastActivity(){update(state=>({...state,lastActivity:Date.now()}))},setSessionTimeout(minutes){update(state=>({...state,sessionTimeout:minutes}))},async refreshRegistrationStatus(){try{const settings=await getSettings();const isRegistered2=!!(settings?.init&&settings?.legal?.termsAgreed);update(state=>({...state,isRegistered:isRegistered2}));return isRegistered2}catch(error){log.error("Error refreshing registration status:",false,error);return false}},async extendSession(additionalMinutes=30){try{await sessionManager.extendSession(additionalMinutes);const sessionState2=sessionManager.getSessionState();update(state=>({...state,sessionState:sessionState2,jwtToken:sessionState2?.jwtToken||null,showSessionWarning:false,lastActivity:Date.now()}))}catch(error){log.error("Failed to extend session:",false,error);throw error}},dismissSessionWarning(){update(state=>({...state,showSessionWarning:false}))},getCurrentJWTToken(){const state=get(authStore);return state.jwtToken},getSessionTimeRemaining(){const state=get(authStore);if(!state.sessionState)return 0;const now=Date.now();return Math.max(0,Math.round((state.sessionState.expiresAt-now)/1e3))}}}const authStore=createAuthStore();const isAuthenticated=derived(authStore,$auth=>$auth.isAuthenticated);derived(authStore,$auth=>$auth.isRegistered);derived(authStore,$auth=>$auth.profile);derived(authStore,$auth=>$auth.lastActivity);derived(authStore,$auth=>$auth.isInitializing);derived(authStore,$auth=>$auth.sessionState);derived(authStore,$auth=>$auth.jwtToken);derived(authStore,$auth=>$auth.showSessionWarning);derived(authStore,$auth=>$auth.sessionTimeRemaining);derived(authStore,$auth=>{if(!$auth.jwtToken)return false;try{const decoded=jwtManager.decodeToken($auth.jwtToken);if(!decoded)return false;const now=Math.floor(Date.now()/1e3);return decoded.payload.exp>now}catch{return false}});export{authStore as a,isAuthenticated as i,jwtManager as j,sessionManager as s,verify as v};
//# sourceMappingURL=auth-store.js.map
