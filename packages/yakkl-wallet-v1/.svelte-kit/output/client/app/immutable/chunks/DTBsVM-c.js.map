{"version":3,"file":"DTBsVM-c.js","sources":["../../../../../../../../node_modules/.pnpm/svelte@5.34.3/node_modules/svelte/src/internal/client/dom/elements/attachments.js","../../../../../../../../node_modules/.pnpm/svelte@5.34.3/node_modules/svelte/src/internal/client/dom/elements/bindings/select.js","../../../../../../../../node_modules/.pnpm/svelte@5.34.3/node_modules/svelte/src/internal/client/dom/elements/attributes.js"],"sourcesContent":["/** @import { Effect } from '#client' */\nimport { block, branch, effect, destroy_effect } from '../../reactivity/effects.js';\n\n// TODO in 6.0 or 7.0, when we remove legacy mode, we can simplify this by\n// getting rid of the block/branch stuff and just letting the effect rip.\n// see https://github.com/sveltejs/svelte/pull/15962\n\n/**\n * @param {Element} node\n * @param {() => (node: Element) => void} get_fn\n */\nexport function attach(node, get_fn) {\n\t/** @type {false | undefined | ((node: Element) => void)} */\n\tvar fn = undefined;\n\n\t/** @type {Effect | null} */\n\tvar e;\n\n\tblock(() => {\n\t\tif (fn !== (fn = get_fn())) {\n\t\t\tif (e) {\n\t\t\t\tdestroy_effect(e);\n\t\t\t\te = null;\n\t\t\t}\n\n\t\t\tif (fn) {\n\t\t\t\te = branch(() => {\n\t\t\t\t\teffect(() => /** @type {(node: Element) => void} */ (fn)(node));\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n}\n","import { effect } from '../../../reactivity/effects.js';\nimport { listen_to_event_and_reset_event } from './shared.js';\nimport { untrack } from '../../../runtime.js';\nimport { is } from '../../../proxy.js';\nimport { is_array } from '../../../../shared/utils.js';\nimport * as w from '../../../warnings.js';\n\n/**\n * Selects the correct option(s) (depending on whether this is a multiple select)\n * @template V\n * @param {HTMLSelectElement} select\n * @param {V} value\n * @param {boolean} [mounting]\n */\nexport function select_option(select, value, mounting) {\n\tif (select.multiple) {\n\t\t// If value is null or undefined, keep the selection as is\n\t\tif (value == undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If not an array, warn and keep the selection as is\n\t\tif (!is_array(value)) {\n\t\t\treturn w.select_multiple_invalid_value();\n\t\t}\n\n\t\t// Otherwise, update the selection\n\t\tfor (var option of select.options) {\n\t\t\toption.selected = value.includes(get_option_value(option));\n\t\t}\n\n\t\treturn;\n\t}\n\n\tfor (option of select.options) {\n\t\tvar option_value = get_option_value(option);\n\t\tif (is(option_value, value)) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!mounting || value !== undefined) {\n\t\tselect.selectedIndex = -1; // no option should be selected\n\t}\n}\n\n/**\n * Selects the correct option(s) if `value` is given,\n * and then sets up a mutation observer to sync the\n * current selection to the dom when it changes. Such\n * changes could for example occur when options are\n * inside an `#each` block.\n * @template V\n * @param {HTMLSelectElement} select\n * @param {() => V} [get_value]\n */\nexport function init_select(select, get_value) {\n\tlet mounting = true;\n\teffect(() => {\n\t\tif (get_value) {\n\t\t\tselect_option(select, untrack(get_value), mounting);\n\t\t}\n\t\tmounting = false;\n\n\t\tvar observer = new MutationObserver(() => {\n\t\t\t// @ts-ignore\n\t\t\tvar value = select.__value;\n\t\t\tselect_option(select, value);\n\t\t\t// Deliberately don't update the potential binding value,\n\t\t\t// the model should be preserved unless explicitly changed\n\t\t});\n\n\t\tobserver.observe(select, {\n\t\t\t// Listen to option element changes\n\t\t\tchildList: true,\n\t\t\tsubtree: true, // because of <optgroup>\n\t\t\t// Listen to option element value attribute changes\n\t\t\t// (doesn't get notified of select value changes,\n\t\t\t// because that property is not reflected as an attribute)\n\t\t\tattributes: true,\n\t\t\tattributeFilter: ['value']\n\t\t});\n\n\t\treturn () => {\n\t\t\tobserver.disconnect();\n\t\t};\n\t});\n}\n\n/**\n * @param {HTMLSelectElement} select\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_select_value(select, get, set = get) {\n\tvar mounting = true;\n\n\tlisten_to_event_and_reset_event(select, 'change', (is_reset) => {\n\t\tvar query = is_reset ? '[selected]' : ':checked';\n\t\t/** @type {unknown} */\n\t\tvar value;\n\n\t\tif (select.multiple) {\n\t\t\tvalue = [].map.call(select.querySelectorAll(query), get_option_value);\n\t\t} else {\n\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\tvar selected_option =\n\t\t\t\tselect.querySelector(query) ??\n\t\t\t\t// will fall back to first non-disabled option if no option is selected\n\t\t\t\tselect.querySelector('option:not([disabled])');\n\t\t\tvalue = selected_option && get_option_value(selected_option);\n\t\t}\n\n\t\tset(value);\n\t});\n\n\t// Needs to be an effect, not a render_effect, so that in case of each loops the logic runs after the each block has updated\n\teffect(() => {\n\t\tvar value = get();\n\t\tselect_option(select, value, mounting);\n\n\t\t// Mounting and value undefined -> take selection from dom\n\t\tif (mounting && value === undefined) {\n\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\tvar selected_option = select.querySelector(':checked');\n\t\t\tif (selected_option !== null) {\n\t\t\t\tvalue = get_option_value(selected_option);\n\t\t\t\tset(value);\n\t\t\t}\n\t\t}\n\n\t\t// @ts-ignore\n\t\tselect.__value = value;\n\t\tmounting = false;\n\t});\n\n\t// don't pass get_value, we already initialize it in the effect above\n\tinit_select(select);\n}\n\n/** @param {HTMLOptionElement} option */\nfunction get_option_value(option) {\n\t// __value only exists if the <option> has a value attribute\n\tif ('__value' in option) {\n\t\treturn option.__value;\n\t} else {\n\t\treturn option.value;\n\t}\n}\n","/** @import { Effect } from '#client' */\nimport { DEV } from 'esm-env';\nimport { hydrating, set_hydrating } from '../hydration.js';\nimport { get_descriptors, get_prototype_of } from '../../../shared/utils.js';\nimport { create_event, delegate } from './events.js';\nimport { add_form_reset_listener, autofocus } from './misc.js';\nimport * as w from '../../warnings.js';\nimport { LOADING_ATTR_SYMBOL } from '#client/constants';\nimport { queue_idle_task } from '../task.js';\nimport { is_capture_event, is_delegated, normalize_attribute } from '../../../../utils.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tget,\n\tset_active_effect,\n\tset_active_reaction\n} from '../../runtime.js';\nimport { attach } from './attachments.js';\nimport { clsx } from '../../../shared/attributes.js';\nimport { set_class } from './class.js';\nimport { set_style } from './style.js';\nimport { ATTACHMENT_KEY, NAMESPACE_HTML } from '../../../../constants.js';\nimport { block, branch, destroy_effect } from '../../reactivity/effects.js';\nimport { derived } from '../../reactivity/deriveds.js';\nimport { init_select, select_option } from './bindings/select.js';\n\nexport const CLASS = Symbol('class');\nexport const STYLE = Symbol('style');\n\nconst IS_CUSTOM_ELEMENT = Symbol('is custom element');\nconst IS_HTML = Symbol('is html');\n\n/**\n * The value/checked attribute in the template actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLInputElement} input\n * @returns {void}\n */\nexport function remove_input_defaults(input) {\n\tif (!hydrating) return;\n\n\tvar already_removed = false;\n\n\t// We try and remove the default attributes later, rather than sync during hydration.\n\t// Doing it sync during hydration has a negative impact on performance, but deferring the\n\t// work in an idle task alleviates this greatly. If a form reset event comes in before\n\t// the idle callback, then we ensure the input defaults are cleared just before.\n\tvar remove_defaults = () => {\n\t\tif (already_removed) return;\n\t\talready_removed = true;\n\n\t\t// Remove the attributes but preserve the values\n\t\tif (input.hasAttribute('value')) {\n\t\t\tvar value = input.value;\n\t\t\tset_attribute(input, 'value', null);\n\t\t\tinput.value = value;\n\t\t}\n\n\t\tif (input.hasAttribute('checked')) {\n\t\t\tvar checked = input.checked;\n\t\t\tset_attribute(input, 'checked', null);\n\t\t\tinput.checked = checked;\n\t\t}\n\t};\n\n\t// @ts-expect-error\n\tinput.__on_r = remove_defaults;\n\tqueue_idle_task(remove_defaults);\n\tadd_form_reset_listener();\n}\n\n/**\n * @param {Element} element\n * @param {any} value\n */\nexport function set_value(element, value) {\n\tvar attributes = get_attributes(element);\n\n\tif (\n\t\tattributes.value ===\n\t\t\t(attributes.value =\n\t\t\t\t// treat null and undefined the same for the initial value\n\t\t\t\tvalue ?? undefined) ||\n\t\t// @ts-expect-error\n\t\t// `progress` elements always need their value set when it's `0`\n\t\t(element.value === value && (value !== 0 || element.nodeName !== 'PROGRESS'))\n\t) {\n\t\treturn;\n\t}\n\n\t// @ts-expect-error\n\telement.value = value ?? '';\n}\n\n/**\n * @param {Element} element\n * @param {boolean} checked\n */\nexport function set_checked(element, checked) {\n\tvar attributes = get_attributes(element);\n\n\tif (\n\t\tattributes.checked ===\n\t\t(attributes.checked =\n\t\t\t// treat null and undefined the same for the initial value\n\t\t\tchecked ?? undefined)\n\t) {\n\t\treturn;\n\t}\n\n\t// @ts-expect-error\n\telement.checked = checked;\n}\n\n/**\n * Sets the `selected` attribute on an `option` element.\n * Not set through the property because that doesn't reflect to the DOM,\n * which means it wouldn't be taken into account when a form is reset.\n * @param {HTMLOptionElement} element\n * @param {boolean} selected\n */\nexport function set_selected(element, selected) {\n\tif (selected) {\n\t\t// The selected option could've changed via user selection, and\n\t\t// setting the value without this check would set it back.\n\t\tif (!element.hasAttribute('selected')) {\n\t\t\telement.setAttribute('selected', '');\n\t\t}\n\t} else {\n\t\telement.removeAttribute('selected');\n\t}\n}\n\n/**\n * Applies the default checked property without influencing the current checked property.\n * @param {HTMLInputElement} element\n * @param {boolean} checked\n */\nexport function set_default_checked(element, checked) {\n\tconst existing_value = element.checked;\n\telement.defaultChecked = checked;\n\telement.checked = existing_value;\n}\n\n/**\n * Applies the default value property without influencing the current value property.\n * @param {HTMLInputElement | HTMLTextAreaElement} element\n * @param {string} value\n */\nexport function set_default_value(element, value) {\n\tconst existing_value = element.value;\n\telement.defaultValue = value;\n\telement.value = existing_value;\n}\n\n/**\n * @param {Element} element\n * @param {string} attribute\n * @param {string | null} value\n * @param {boolean} [skip_warning]\n */\nexport function set_attribute(element, attribute, value, skip_warning) {\n\tvar attributes = get_attributes(element);\n\n\tif (hydrating) {\n\t\tattributes[attribute] = element.getAttribute(attribute);\n\n\t\tif (\n\t\t\tattribute === 'src' ||\n\t\t\tattribute === 'srcset' ||\n\t\t\t(attribute === 'href' && element.nodeName === 'LINK')\n\t\t) {\n\t\t\tif (!skip_warning) {\n\t\t\t\tcheck_src_in_dev_hydration(element, attribute, value ?? '');\n\t\t\t}\n\n\t\t\t// If we reset these attributes, they would result in another network request, which we want to avoid.\n\t\t\t// We assume they are the same between client and server as checking if they are equal is expensive\n\t\t\t// (we can't just compare the strings as they can be different between client and server but result in the\n\t\t\t// same url, so we would need to create hidden anchor elements to compare them)\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (attributes[attribute] === (attributes[attribute] = value)) return;\n\n\tif (attribute === 'loading') {\n\t\t// @ts-expect-error\n\t\telement[LOADING_ATTR_SYMBOL] = value;\n\t}\n\n\tif (value == null) {\n\t\telement.removeAttribute(attribute);\n\t} else if (typeof value !== 'string' && get_setters(element).includes(attribute)) {\n\t\t// @ts-ignore\n\t\telement[attribute] = value;\n\t} else {\n\t\telement.setAttribute(attribute, value);\n\t}\n}\n\n/**\n * @param {Element} dom\n * @param {string} attribute\n * @param {string} value\n */\nexport function set_xlink_attribute(dom, attribute, value) {\n\tdom.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {HTMLElement} node\n * @param {string} prop\n * @param {any} value\n */\nexport function set_custom_element_data(node, prop, value) {\n\t// We need to ensure that setting custom element props, which can\n\t// invoke lifecycle methods on other custom elements, does not also\n\t// associate those lifecycle methods with the current active reaction\n\t// or effect\n\tvar previous_reaction = active_reaction;\n\tvar previous_effect = active_effect;\n\n\t// If we're hydrating but the custom element is from Svelte, and it already scaffolded,\n\t// then it might run block logic in hydration mode, which we have to prevent.\n\tlet was_hydrating = hydrating;\n\tif (hydrating) {\n\t\tset_hydrating(false);\n\t}\n\n\tset_active_reaction(null);\n\tset_active_effect(null);\n\n\ttry {\n\t\tif (\n\t\t\t// `style` should use `set_attribute` rather than the setter\n\t\t\tprop !== 'style' &&\n\t\t\t// Don't compute setters for custom elements while they aren't registered yet,\n\t\t\t// because during their upgrade/instantiation they might add more setters.\n\t\t\t// Instead, fall back to a simple \"an object, then set as property\" heuristic.\n\t\t\t(setters_cache.has(node.nodeName) ||\n\t\t\t// customElements may not be available in browser extension contexts\n\t\t\t!customElements ||\n\t\t\tcustomElements.get(node.tagName.toLowerCase())\n\t\t\t\t? get_setters(node).includes(prop)\n\t\t\t\t: value && typeof value === 'object')\n\t\t) {\n\t\t\t// @ts-expect-error\n\t\t\tnode[prop] = value;\n\t\t} else {\n\t\t\t// We did getters etc checks already, stringify before passing to set_attribute\n\t\t\t// to ensure it doesn't invoke the same logic again, and potentially populating\n\t\t\t// the setters cache too early.\n\t\t\tset_attribute(node, prop, value == null ? value : String(value));\n\t\t}\n\t} finally {\n\t\tset_active_reaction(previous_reaction);\n\t\tset_active_effect(previous_effect);\n\t\tif (was_hydrating) {\n\t\t\tset_hydrating(true);\n\t\t}\n\t}\n}\n\n/**\n * Spreads attributes onto a DOM element, taking into account the currently set attributes\n * @param {Element & ElementCSSInlineStyle} element\n * @param {Record<string | symbol, any> | undefined} prev\n * @param {Record<string | symbol, any>} next New attributes - this function mutates this object\n * @param {string} [css_hash]\n * @param {boolean} [skip_warning]\n * @returns {Record<string, any>}\n */\nexport function set_attributes(element, prev, next, css_hash, skip_warning = false) {\n\tvar attributes = get_attributes(element);\n\n\tvar is_custom_element = attributes[IS_CUSTOM_ELEMENT];\n\tvar preserve_attribute_case = !attributes[IS_HTML];\n\n\t// If we're hydrating but the custom element is from Svelte, and it already scaffolded,\n\t// then it might run block logic in hydration mode, which we have to prevent.\n\tlet is_hydrating_custom_element = hydrating && is_custom_element;\n\tif (is_hydrating_custom_element) {\n\t\tset_hydrating(false);\n\t}\n\n\tvar current = prev || {};\n\tvar is_option_element = element.tagName === 'OPTION';\n\n\tfor (var key in prev) {\n\t\tif (!(key in next)) {\n\t\t\tnext[key] = null;\n\t\t}\n\t}\n\n\tif (next.class) {\n\t\tnext.class = clsx(next.class);\n\t} else if (css_hash || next[CLASS]) {\n\t\tnext.class = null; /* force call to set_class() */\n\t}\n\n\tif (next[STYLE]) {\n\t\tnext.style ??= null; /* force call to set_style() */\n\t}\n\n\tvar setters = get_setters(element);\n\n\t// since key is captured we use const\n\tfor (const key in next) {\n\t\t// let instead of var because referenced in a closure\n\t\tlet value = next[key];\n\n\t\t// Up here because we want to do this for the initial value, too, even if it's undefined,\n\t\t// and this wouldn't be reached in case of undefined because of the equality check below\n\t\tif (is_option_element && key === 'value' && value == null) {\n\t\t\t// The <option> element is a special case because removing the value attribute means\n\t\t\t// the value is set to the text content of the option element, and setting the value\n\t\t\t// to null or undefined means the value is set to the string \"null\" or \"undefined\".\n\t\t\t// To align with how we handle this case in non-spread-scenarios, this logic is needed.\n\t\t\t// There's a super-edge-case bug here that is left in in favor of smaller code size:\n\t\t\t// Because of the \"set missing props to null\" logic above, we can't differentiate\n\t\t\t// between a missing value and an explicitly set value of null or undefined. That means\n\t\t\t// that once set, the value attribute of an <option> element can't be removed. This is\n\t\t\t// a very rare edge case, and removing the attribute altogether isn't possible either\n\t\t\t// for the <option value={undefined}> case, so we're not losing any functionality here.\n\t\t\t// @ts-ignore\n\t\t\telement.value = element.__value = '';\n\t\t\tcurrent[key] = value;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (key === 'class') {\n\t\t\tvar is_html = element.namespaceURI === 'http://www.w3.org/1999/xhtml';\n\t\t\tset_class(element, is_html, value, css_hash, prev?.[CLASS], next[CLASS]);\n\t\t\tcurrent[key] = value;\n\t\t\tcurrent[CLASS] = next[CLASS];\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (key === 'style') {\n\t\t\tset_style(element, value, prev?.[STYLE], next[STYLE]);\n\t\t\tcurrent[key] = value;\n\t\t\tcurrent[STYLE] = next[STYLE];\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar prev_value = current[key];\n\t\tif (value === prev_value) continue;\n\n\t\tcurrent[key] = value;\n\n\t\tvar prefix = key[0] + key[1]; // this is faster than key.slice(0, 2)\n\t\tif (prefix === '$$') continue;\n\n\t\tif (prefix === 'on') {\n\t\t\t/** @type {{ capture?: true }} */\n\t\t\tconst opts = {};\n\t\t\tconst event_handle_key = '$$' + key;\n\t\t\tlet event_name = key.slice(2);\n\t\t\tvar delegated = is_delegated(event_name);\n\n\t\t\tif (is_capture_event(event_name)) {\n\t\t\t\tevent_name = event_name.slice(0, -7);\n\t\t\t\topts.capture = true;\n\t\t\t}\n\n\t\t\tif (!delegated && prev_value) {\n\t\t\t\t// Listening to same event but different handler -> our handle function below takes care of this\n\t\t\t\t// If we were to remove and add listeners in this case, it could happen that the event is \"swallowed\"\n\t\t\t\t// (the browser seems to not know yet that a new one exists now) and doesn't reach the handler\n\t\t\t\t// https://github.com/sveltejs/svelte/issues/11903\n\t\t\t\tif (value != null) continue;\n\n\t\t\t\telement.removeEventListener(event_name, current[event_handle_key], opts);\n\t\t\t\tcurrent[event_handle_key] = null;\n\t\t\t}\n\n\t\t\tif (value != null) {\n\t\t\t\tif (!delegated) {\n\t\t\t\t\t/**\n\t\t\t\t\t * @this {any}\n\t\t\t\t\t * @param {Event} evt\n\t\t\t\t\t */\n\t\t\t\t\tfunction handle(evt) {\n\t\t\t\t\t\tcurrent[key].call(this, evt);\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrent[event_handle_key] = create_event(event_name, element, handle, opts);\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\telement[`__${event_name}`] = value;\n\t\t\t\t\tdelegate([event_name]);\n\t\t\t\t}\n\t\t\t} else if (delegated) {\n\t\t\t\t// @ts-ignore\n\t\t\t\telement[`__${event_name}`] = undefined;\n\t\t\t}\n\t\t} else if (key === 'style') {\n\t\t\t// avoid using the setter\n\t\t\tset_attribute(element, key, value);\n\t\t} else if (key === 'autofocus') {\n\t\t\tautofocus(/** @type {HTMLElement} */ (element), Boolean(value));\n\t\t} else if (!is_custom_element && (key === '__value' || (key === 'value' && value != null))) {\n\t\t\t// @ts-ignore We're not running this for custom elements because __value is actually\n\t\t\t// how Lit stores the current value on the element, and messing with that would break things.\n\t\t\telement.value = element.__value = value;\n\t\t} else if (key === 'selected' && is_option_element) {\n\t\t\tset_selected(/** @type {HTMLOptionElement} */ (element), value);\n\t\t} else {\n\t\t\tvar name = key;\n\t\t\tif (!preserve_attribute_case) {\n\t\t\t\tname = normalize_attribute(name);\n\t\t\t}\n\n\t\t\tvar is_default = name === 'defaultValue' || name === 'defaultChecked';\n\n\t\t\tif (value == null && !is_custom_element && !is_default) {\n\t\t\t\tattributes[key] = null;\n\n\t\t\t\tif (name === 'value' || name === 'checked') {\n\t\t\t\t\t// removing value/checked also removes defaultValue/defaultChecked — preserve\n\t\t\t\t\tlet input = /** @type {HTMLInputElement} */ (element);\n\t\t\t\t\tconst use_default = prev === undefined;\n\t\t\t\t\tif (name === 'value') {\n\t\t\t\t\t\tlet previous = input.defaultValue;\n\t\t\t\t\t\tinput.removeAttribute(name);\n\t\t\t\t\t\tinput.defaultValue = previous;\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tinput.value = input.__value = use_default ? previous : null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet previous = input.defaultChecked;\n\t\t\t\t\t\tinput.removeAttribute(name);\n\t\t\t\t\t\tinput.defaultChecked = previous;\n\t\t\t\t\t\tinput.checked = use_default ? previous : false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\telement.removeAttribute(key);\n\t\t\t\t}\n\t\t\t} else if (\n\t\t\t\tis_default ||\n\t\t\t\t(setters.includes(name) && (is_custom_element || typeof value !== 'string'))\n\t\t\t) {\n\t\t\t\t// @ts-ignore\n\t\t\t\telement[name] = value;\n\t\t\t} else if (typeof value !== 'function') {\n\t\t\t\tset_attribute(element, name, value, skip_warning);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (is_hydrating_custom_element) {\n\t\tset_hydrating(true);\n\t}\n\n\treturn current;\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} element\n * @param {(...expressions: any) => Record<string | symbol, any>} fn\n * @param {Array<() => any>} thunks\n * @param {string} [css_hash]\n * @param {boolean} [skip_warning]\n */\nexport function attribute_effect(\n\telement,\n\tfn,\n\tthunks = [],\n\tcss_hash,\n\tskip_warning = false,\n\td = derived\n) {\n\tconst deriveds = thunks.map(d);\n\n\t/** @type {Record<string | symbol, any> | undefined} */\n\tvar prev = undefined;\n\n\t/** @type {Record<symbol, Effect>} */\n\tvar effects = {};\n\n\tvar is_select = element.nodeName === 'SELECT';\n\tvar inited = false;\n\n\tblock(() => {\n\t\tvar next = fn(...deriveds.map(get));\n\n\t\tset_attributes(element, prev, next, css_hash, skip_warning);\n\n\t\tif (inited && is_select && 'value' in next) {\n\t\t\tselect_option(/** @type {HTMLSelectElement} */ (element), next.value, false);\n\t\t}\n\n\t\tfor (let symbol of Object.getOwnPropertySymbols(effects)) {\n\t\t\tif (!next[symbol]) destroy_effect(effects[symbol]);\n\t\t}\n\n\t\tfor (let symbol of Object.getOwnPropertySymbols(next)) {\n\t\t\tvar n = next[symbol];\n\n\t\t\tif (symbol.description === ATTACHMENT_KEY && (!prev || n !== prev[symbol])) {\n\t\t\t\tif (effects[symbol]) destroy_effect(effects[symbol]);\n\t\t\t\teffects[symbol] = branch(() => attach(element, () => n));\n\t\t\t}\n\t\t}\n\n\t\tprev = next;\n\t});\n\n\tif (is_select) {\n\t\tinit_select(\n\t\t\t/** @type {HTMLSelectElement} */ (element),\n\t\t\t() => /** @type {Record<string | symbol, any>} */ (prev).value\n\t\t);\n\t}\n\n\tinited = true;\n}\n\n/**\n *\n * @param {Element} element\n */\nfunction get_attributes(element) {\n\treturn /** @type {Record<string | symbol, unknown>} **/ (\n\t\t// @ts-expect-error\n\t\telement.__attributes ??= {\n\t\t\t[IS_CUSTOM_ELEMENT]: element.nodeName.includes('-'),\n\t\t\t[IS_HTML]: element.namespaceURI === NAMESPACE_HTML\n\t\t}\n\t);\n}\n\n/** @type {Map<string, string[]>} */\nvar setters_cache = new Map();\n\n/** @param {Element} element */\nfunction get_setters(element) {\n\tvar setters = setters_cache.get(element.nodeName);\n\tif (setters) return setters;\n\tsetters_cache.set(element.nodeName, (setters = []));\n\n\tvar descriptors;\n\tvar proto = element; // In the case of custom elements there might be setters on the instance\n\tvar element_proto = Element.prototype;\n\n\t// Stop at Element, from there on there's only unnecessary setters we're not interested in\n\t// Do not use contructor.name here as that's unreliable in some browser environments\n\twhile (element_proto !== proto) {\n\t\tdescriptors = get_descriptors(proto);\n\n\t\tfor (var key in descriptors) {\n\t\t\tif (descriptors[key].set) {\n\t\t\t\tsetters.push(key);\n\t\t\t}\n\t\t}\n\n\t\tproto = get_prototype_of(proto);\n\t}\n\n\treturn setters;\n}\n\n/**\n * @param {any} element\n * @param {string} attribute\n * @param {string} value\n */\nfunction check_src_in_dev_hydration(element, attribute, value) {\n\tif (!DEV) return;\n\tif (attribute === 'srcset' && srcset_url_equal(element, value)) return;\n\tif (src_url_equal(element.getAttribute(attribute) ?? '', value)) return;\n\n\tw.hydration_attribute_changed(\n\t\tattribute,\n\t\telement.outerHTML.replace(element.innerHTML, element.innerHTML && '...'),\n\t\tString(value)\n\t);\n}\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nfunction src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\treturn new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element\n * @param {string} srcset\n * @returns {boolean}\n */\nfunction srcset_url_equal(element, srcset) {\n\tvar element_urls = split_srcset(element.srcset);\n\tvar urls = split_srcset(srcset);\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n"],"names":["attach","node","get_fn","fn","e","block","destroy_effect","branch","effect","select_option","select","value","mounting","multiple","is_array","w.select_multiple_invalid_value","option","options","selected","includes","get_option_value","option_value","is","selectedIndex","init_select","get_value","untrack","observer","MutationObserver","__value","observe","childList","subtree","attributes","attributeFilter","disconnect","bind_select_value","get","set","listen_to_event_and_reset_event","is_reset","query","map","call","querySelectorAll","selected_option","querySelector","CLASS","Symbol","STYLE","IS_CUSTOM_ELEMENT","IS_HTML","remove_input_defaults","input","hydrating","already_removed","remove_defaults","hasAttribute","set_attribute","checked","__on_r","queue_idle_task","add_form_reset_listener","set_value","element","get_attributes","nodeName","set_checked","set_selected","setAttribute","removeAttribute","attribute","skip_warning","getAttribute","check_src_in_dev_hydration","LOADING_ATTR_SYMBOL","get_setters","set_attributes","prev","next","css_hash","is_custom_element","preserve_attribute_case","is_hydrating_custom_element","set_hydrating","current","is_option_element","tagName","key","class","clsx","style","setters","is_html","namespaceURI","set_class","set_style","prev_value","prefix","opts","event_handle_key","event_name","slice","delegated","is_delegated","is_capture_event","capture","removeEventListener","handle","evt","this","create_event","delegate","autofocus","Boolean","name","normalize_attribute","is_default","use_default","previous","defaultValue","defaultChecked","attribute_effect","thunks","d","derived","deriveds","effects","is_select","inited","symbol","Object","getOwnPropertySymbols","n","description","ATTACHMENT_KEY","__attributes","NAMESPACE_HTML","setters_cache","Map","descriptors","proto","element_proto","Element","prototype","get_descriptors","push","get_prototype_of","srcset_url_equal","src_url_equal","w.hydration_attribute_changed","outerHTML","replace","innerHTML","String","element_src","url","URL","document","baseURI","href","split_srcset","srcset","split","src","trim","filter","element_urls","urls","length","every","width","i"],"mappings":"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","x_google_ignoreList":[0,1,2]}