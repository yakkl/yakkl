{"version":3,"file":"DT3ZCMgr.js","sources":["../../../../../../src/lib/common/messaging.ts"],"sourcesContent":["// src/lib/common/messaging.ts\nimport { browser as isBrowser } from '$app/environment';\nimport { log } from '$lib/common/logger-wrapper';\nimport type { Browser, Runtime } from 'webextension-polyfill';\nimport { protectedContexts } from './globals';\nimport { UnifiedTimerManager } from '$lib/managers/UnifiedTimerManager';\n\n// Helper function to check if context needs idle protection\nfunction contextNeedsIdleProtection(contextType: string): boolean {\n\treturn protectedContexts.includes(contextType);\n}\n\n/**\n * A utility for reliable and efficient communication with the extension's background script\n */\nclass ExtensionMessaging {\n\tprivate static instance: ExtensionMessaging;\n\tprivate messageQueue: Map<string, any[]> = new Map();\n\tprivate processedResponses = new Map<string, { timestamp: number; result: any }>();\n\tprivate isProcessing: boolean = false;\n\tprivate retryCount: Map<string, number> = new Map();\n\tprivate MAX_RETRIES = 3;\n\tprivate RETRY_DELAY = 500; // ms\n\tprivate browserApi: Browser | null = null;\n\tprivate contextId: string = '';\n\tprivate pendingRequests = new Map<\n\t\tstring,\n\t\t{\n\t\t\tresolve: (result: any) => void;\n\t\t\treject: (error: any) => void;\n\t\t\ttimestamp: number;\n\t\t}\n\t>();\n\tprivate timerManager = UnifiedTimerManager.getInstance();\n\n\t// Add a list of message types that don't need responses\n\tprivate readonly FIRE_AND_FORGET_MESSAGES = [\n\t\t'clientReady',\n\t\t'ui_context_initialized',\n\t\t'ui_context_activity',\n\t\t'ui_context_closing',\n\t\t'SET_LOGIN_VERIFIED',\n\t\t'USER_ACTIVITY',\n\t\t'CLEAR_ALL_ENHANCED_ALERTS', // Add this to prevent feedback loops\n\t\t'CLEAR_NOTIFICATION',\n\t\t'CLEAR_NOTIFICATION_ENHANCED',\n\t\t'IDLE_STATUS_CHANGED',\n\t\t'LOCKDOWN_WARNING_ENHANCED',\n\t\t'SECURITY_ALERT_ENHANCED',\n\t\t'PLAY_URGENT_SOUND'\n\t];\n\n\t/**\n\t * Get the singleton instance\n\t */\n\tpublic static getInstance(): ExtensionMessaging {\n\t\tif (!ExtensionMessaging.instance) {\n\t\t\tExtensionMessaging.instance = new ExtensionMessaging();\n\t\t}\n\t\treturn ExtensionMessaging.instance;\n\t}\n\n\t/**\n\t * Initialize the messaging system\n\t * @param browserExtensionApi The browser extension API object from webextension-polyfill\n\t */\n\tpublic initialize(browserExtensionApi: Browser): void {\n\t\tif (!isBrowser) return; // Skip on server\n\n\t\tthis.browserApi = browserExtensionApi;\n\t\tthis.contextId = this.getContextId();\n\t\tlog.debug('[Messaging - initialize] Extension messaging initialized');\n\n\t\t// Start processing any queued messages\n\t\tthis.processQueue();\n\n\t\t// Set up message listener for responses\n\t\tif (this.browserApi && this.browserApi.runtime) {\n\t\t\tthis.browserApi.runtime.onMessage.addListener(this.handleIncomingMessage.bind(this));\n\t\t}\n\n\t\t// Start cleanup interval using UnifiedTimerManager\n\t\tthis.timerManager.addInterval('messaging-cleanup', () => this.cleanup(), 60000);\n\t\tthis.timerManager.startInterval('messaging-cleanup');\n\t}\n\n\t/**\n\t * Send a cleanup message that won't trigger response loops\n\t */\n\tpublic async sendCleanupMessage(\n\t\ttype: string,\n\t\tdata: any = {},\n\t\tsource: string = 'unknown'\n\t): Promise<void> {\n\t\tif (!isBrowser || !this.browserApi) return;\n\n\t\t// These messages should never wait for responses and should be rate-limited\n\t\tconst message = {\n\t\t\ttype,\n\t\t\t...data,\n\t\t\tmessageId: `cleanup-${source}-${Date.now()}`,\n\t\t\ttimestamp: Date.now(),\n\t\t\tcontextId: this.contextId,\n\t\t\tsource: source,\n\t\t\tisCleanup: true // Flag to identify cleanup messages\n\t\t};\n\n\t\ttry {\n\t\t\t// Send directly without waiting for response and with error suppression\n\t\t\tthis.browserApi.runtime.sendMessage(message).catch((error) => {\n\t\t\t\tlog.debug(\n\t\t\t\t\t`[Messaging - sendCleanupMessage] Cleanup message ${type} send failed (this is normal):`,\n\t\t\t\t\tfalse,\n\t\t\t\t\terror\n\t\t\t\t);\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlog.debug(\n\t\t\t\t`[Messaging - sendCleanupMessage] Cleanup message ${type} send error (this is normal):`,\n\t\t\t\tfalse,\n\t\t\t\terror\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Handle incoming messages, primarily to resolve pending promises\n\t */\n\tprivate handleIncomingMessage(\n\t\tmessage: any,\n\t\tsender: Runtime.MessageSender,\n\t\tsendResponse: (response?: any) => void\n\t): true {\n\t\t// Skip messages that don't have a response identifier\n\t\tif (!message || !message.responseId) return true;\n\n\t\tconst { responseId, result, error } = message;\n\n\t\t// Check if we have a pending request for this response\n\t\tconst pendingRequest = this.pendingRequests.get(responseId);\n\t\tif (pendingRequest) {\n\t\t\tif (error) {\n\t\t\t\tpendingRequest.reject(error);\n\t\t\t} else {\n\t\t\t\tpendingRequest.resolve(result);\n\t\t\t}\n\n\t\t\t// Remove from pending requests\n\t\t\tthis.pendingRequests.delete(responseId);\n\n\t\t\t// Cache the response for deduplication\n\t\t\tthis.processedResponses.set(responseId, {\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t\tresult: error || result\n\t\t\t});\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Send a message to the background script\n\t * @param type Message type\n\t * @param data Message data\n\t * @param options Message options\n\t * @returns Promise resolving to the response\n\t */\n\tpublic async sendMessage(\n\t\ttype: string,\n\t\tdata: any = {},\n\t\toptions: {\n\t\t\tpriority?: 'high' | 'normal' | 'low';\n\t\t\tretryOnFail?: boolean;\n\t\t\tcontextId?: string;\n\t\t\tdeduplicate?: boolean;\n\t\t\tresponseTimeout?: number;\n\t\t\twaitForResponse?: boolean;\n\t\t} = {}\n\t): Promise<any> {\n\t\tif (!isBrowser) {\n\t\t\t// Return a resolved promise when running on server\n\t\t\treturn Promise.resolve(null);\n\t\t}\n\n\t\tconst {\n\t\t\tpriority = 'normal',\n\t\t\tretryOnFail = true,\n\t\t\tcontextId = this.contextId,\n\t\t\tdeduplicate = true,\n\t\t\tresponseTimeout = 30000, // 30 second default timeout\n\t\t\t// If message type is in fire-and-forget list, don't wait for response\n\t\t\twaitForResponse = !this.FIRE_AND_FORGET_MESSAGES.includes(type)\n\t\t} = options;\n\n\t\t// Generate a unique ID for this message\n\t\tconst messageId = `${type}:${contextId}:${Date.now().toString(36)}`;\n\n\t\t// If deduplication is enabled and we've recently processed this exact message type+data\n\t\tif (deduplicate) {\n\t\t\tconst exactMessageKey = `${type}:${JSON.stringify(data)}`;\n\t\t\tconst recentResponse = this.processedResponses.get(exactMessageKey);\n\n\t\t\tif (recentResponse && Date.now() - recentResponse.timestamp < 5000) {\n\t\t\t\tlog.debug('[Messaging - sendMessage] Using cached response for identical message:', false, {\n\t\t\t\t\ttype\n\t\t\t\t});\n\t\t\t\treturn Promise.resolve(recentResponse.result);\n\t\t\t}\n\t\t}\n\n\t\t// Check if browserApi is available\n\t\tif (!this.browserApi) {\n\t\t\tlog.warn(\n\t\t\t\t'[Messaging - sendMessage] Browser extension API not available. Call initialize() first.'\n\t\t\t);\n\t\t\treturn Promise.reject(\n\t\t\t\tnew Error('Browser extension API not available. Call initialize() first.')\n\t\t\t);\n\t\t}\n\n\t\t// Prepare the message\n\t\tconst message = {\n\t\t\ttype,\n\t\t\t...data,\n\t\t\tmessageId,\n\t\t\ttimestamp: Date.now(),\n\t\t\tcontextId\n\t\t};\n\n\t\t// For fire-and-forget messages, just send and resolve immediately\n\t\tif (!waitForResponse) {\n\t\t\ttry {\n\t\t\t\t// Send directly without waiting for response\n\t\t\t\tthis.browserApi.runtime.sendMessage(message).catch((error) => {\n\t\t\t\t\tlog.debug(\n\t\t\t\t\t\t`[Messaging - sendMessage] Error sending fire-and-forget message ${type}:`,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\terror\n\t\t\t\t\t);\n\t\t\t\t});\n\n\t\t\t\t// Return resolved promise immediately\n\t\t\t\treturn Promise.resolve({ success: true, noResponseRequired: true });\n\t\t\t} catch (error) {\n\t\t\t\tlog.debug(\n\t\t\t\t\t`[Messaging - sendMessage] Error sending fire-and-forget message ${type}:`,\n\t\t\t\t\tfalse,\n\t\t\t\t\terror\n\t\t\t\t);\n\t\t\t\treturn Promise.resolve({ success: true, noResponseRequired: true, sendFailed: true });\n\t\t\t}\n\t\t}\n\n\t\t// For messages requiring response, use the queue system\n\t\treturn new Promise((resolve, reject) => {\n\t\t\t// Add to pending requests\n\t\t\tthis.pendingRequests.set(messageId, {\n\t\t\t\tresolve,\n\t\t\t\treject,\n\t\t\t\ttimestamp: Date.now()\n\t\t\t});\n\n\t\t\t// Set up timeout\n\t\t\tconst timeoutId = setTimeout(() => {\n\t\t\t\tif (this.pendingRequests.has(messageId)) {\n\t\t\t\t\tthis.pendingRequests.delete(messageId);\n\t\t\t\t\treject(new Error(`Message ${type} timed out after ${responseTimeout}ms`));\n\t\t\t\t}\n\t\t\t}, responseTimeout);\n\n\t\t\t// Add to queue\n\t\t\tconst queueKey = priority;\n\t\t\tif (!this.messageQueue.has(queueKey)) {\n\t\t\t\tthis.messageQueue.set(queueKey, []);\n\t\t\t}\n\n\t\t\tthis.messageQueue.get(queueKey)!.push({\n\t\t\t\tmessage,\n\t\t\t\tretryOnFail,\n\t\t\t\tretryCount: 0,\n\t\t\t\ttimeoutId\n\t\t\t});\n\n\t\t\t// Start processing the queue if not already processing\n\t\t\tif (!this.isProcessing) {\n\t\t\t\tthis.processQueue();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Process the message queue in priority order\n\t */\n\tprivate async processQueue(): Promise<void> {\n\t\tif (!isBrowser || this.isProcessing || !this.browserApi) return;\n\n\t\tthis.isProcessing = true;\n\n\t\t// Process high priority messages first, then normal, then low\n\t\tconst priorities = ['high', 'normal', 'low'];\n\n\t\ttry {\n\t\t\tfor (const priority of priorities) {\n\t\t\t\tconst queue = this.messageQueue.get(priority) || [];\n\n\t\t\t\t// Process all messages in this queue\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tconst item = queue.shift()!;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Send the message\n\t\t\t\t\t\tawait this.browserApi.runtime.sendMessage(item.message).catch((error: any) => {\n\t\t\t\t\t\t\tlog.debug('[Messaging - processQueue] Error sending message:', false, error);\n\n\t\t\t\t\t\t\t// If we should retry and haven't exceeded the retry limit\n\t\t\t\t\t\t\tif (item.retryOnFail && item.retryCount < this.MAX_RETRIES) {\n\t\t\t\t\t\t\t\t// Increment retry count and add back to queue\n\t\t\t\t\t\t\t\titem.retryCount++;\n\t\t\t\t\t\t\t\tqueue.push(item);\n\n\t\t\t\t\t\t\t\tlog.debug('[Messaging - processQueue] Retrying message:', false, {\n\t\t\t\t\t\t\t\t\ttype: item.message.type,\n\t\t\t\t\t\t\t\t\tattempt: item.retryCount\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Reject the promise\n\t\t\t\t\t\t\t\tconst pendingRequest = this.pendingRequests.get(item.message.messageId);\n\t\t\t\t\t\t\t\tif (pendingRequest) {\n\t\t\t\t\t\t\t\t\tpendingRequest.reject(error);\n\t\t\t\t\t\t\t\t\tthis.pendingRequests.delete(item.message.messageId);\n\t\t\t\t\t\t\t\t\tclearTimeout(item.timeoutId);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (error: any) {\n\t\t\t\t\t\t// If we should retry and haven't exceeded the retry limit\n\t\t\t\t\t\tif (item.retryOnFail && item.retryCount < this.MAX_RETRIES) {\n\t\t\t\t\t\t\t// Increment retry count and add back to queue\n\t\t\t\t\t\t\titem.retryCount++;\n\t\t\t\t\t\t\tqueue.push(item);\n\n\t\t\t\t\t\t\t// Add a small delay before next attempt\n\t\t\t\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, this.RETRY_DELAY));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Log the error and reject the promise\n\t\t\t\t\t\t\tlog.warn(\n\t\t\t\t\t\t\t\t`[Messaging - processQueue] Failed to send message (${item.message.type}) after ${item.retryCount} retries:`,\n\t\t\t\t\t\t\t\terror\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst pendingRequest = this.pendingRequests.get(item.message.messageId);\n\t\t\t\t\t\t\tif (pendingRequest) {\n\t\t\t\t\t\t\t\tpendingRequest.reject(error);\n\t\t\t\t\t\t\t\tthis.pendingRequests.delete(item.message.messageId);\n\t\t\t\t\t\t\t\tclearTimeout(item.timeoutId);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add a small delay between messages\n\t\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 10));\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.isProcessing = false;\n\n\t\t\t// If there are still messages in the queue, continue processing\n\t\t\tfor (const queue of this.messageQueue.values()) {\n\t\t\t\tif (queue.length > 0) {\n\t\t\t\t\tsetTimeout(() => this.processQueue(), 0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Clean up stale pending requests and responses\n\t */\n\tprivate cleanup(): void {\n\t\tconst now = Date.now();\n\n\t\t// Clean up stale pending requests (older than 1 minute)\n\t\tfor (const [messageId, request] of this.pendingRequests.entries()) {\n\t\t\tif (now - request.timestamp > 60000) {\n\t\t\t\trequest.reject(new Error('Request timed out'));\n\t\t\t\tthis.pendingRequests.delete(messageId);\n\t\t\t}\n\t\t}\n\n\t\t// Clean up old processed responses (older than 5 minutes)\n\t\tfor (const [messageId, response] of this.processedResponses.entries()) {\n\t\t\tif (now - response.timestamp > 300000) {\n\t\t\t\tthis.processedResponses.delete(messageId);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Generate or retrieve a context ID for this UI instance\n\t */\n\tprivate getContextId(): string {\n\t\t// if (!isBrowser) return 'server';\n\n\t\t// // Check for an existing context ID in window storage\n\t\t// if (typeof window !== 'undefined' &&\n\t\t//     window.EXTENSION_INIT_STATE &&\n\t\t//     window.EXTENSION_INIT_STATE.contextId) {\n\t\t//   return window.EXTENSION_INIT_STATE.contextId;\n\t\t// }\n\n\t\t// // Generate a new context ID\n\t\t// const contextId = Date.now().toString(36) + Math.random().toString(36).substring(2, 7);\n\n\t\t// // Store it in window storage if available\n\t\t// if (typeof window !== 'undefined') {\n\t\t//   if (!window.EXTENSION_INIT_STATE) {\n\t\t//     window.EXTENSION_INIT_STATE = {\n\t\t//       initialized: false,\n\t\t//       contextId: contextId,\n\t\t//       activityTrackingStarted: false,\n\t\t//       startTime: Date.now()\n\t\t//     };\n\t\t//   } else {\n\t\t//     window.EXTENSION_INIT_STATE.contextId = contextId;\n\t\t//   }\n\t\t// }\n\n\t\t// return contextId;\n\t\treturn this.contextId;\n\t}\n\n\t/**\n\t * Check if the messaging service has been initialized\n\t * @returns true if initialized, false otherwise\n\t */\n\tpublic isInitialized(): boolean {\n\t\treturn this.browserApi !== null;\n\t}\n\n\t/**\n\t * Manually trigger user activity detection (for testing)\n\t */\n\tpublic triggerActivityDetection(): void {\n\t\tif (!isBrowser || typeof window === 'undefined') return;\n\n\t\tconst handler = (window as any).__yakklActivityHandler;\n\t\tif (handler) {\n\t\t\tlog.info('[Messaging - triggerActivityDetection] Manually triggering activity detection');\n\t\t\thandler();\n\t\t} else {\n\t\t\tlog.warn(\n\t\t\t\t'[Messaging - triggerActivityDetection] Activity handler not found - activity tracking may not be set up'\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Send a UI context initialization message to the background script\n\t */\n\tpublic async registerUiContext(contextType: string): Promise<void> {\n\t\tif (!isBrowser || !this.browserApi) return;\n\n\t\tconst contextId = this.contextId;\n\n\t\tawait this.sendMessage(\n\t\t\t'ui_context_initialized',\n\t\t\t{\n\t\t\t\tcontextId,\n\t\t\t\tcontextType,\n\t\t\t\ttimestamp: Date.now()\n\t\t\t},\n\t\t\t{\n\t\t\t\tpriority: 'high',\n\t\t\t\tretryOnFail: true,\n\t\t\t\tdeduplicate: false\n\t\t\t}\n\t\t);\n\n\t\t// Set up unload handler\n\t\tif (typeof window !== 'undefined') {\n\t\t\ttry {\n\t\t\t\twindow.addEventListener('beforeunload', () => {\n\t\t\t\t\t// Send synchronously to ensure it gets through before page unloads\n\t\t\t\t\tif (this.browserApi && this.browserApi.runtime) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tthis.browserApi.runtime.sendMessage({\n\t\t\t\t\t\t\t\ttype: 'ui_context_closing',\n\t\t\t\t\t\t\t\tcontextId\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t// Can't do much about errors during unload\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\tconsole.warn(`[${contextId}] Failed to add unload handler:`, error);\n\t\t\t}\n\t\t}\n\n\t\tlog.debug(\n\t\t\t`[Messaging - registerUiContext] UI context registered: ${contextId} (${contextType})`\n\t\t);\n\t}\n\n\t/**\n\t * Send user activity update to keep context active (only for protected contexts)\n\t */\n\tpublic async sendActivityUpdate(): Promise<void> {\n\t\tif (!isBrowser || !this.browserApi) return;\n\n\t\tconst contextType = this.getContextType();\n\n\t\t// Only send activity updates for protected contexts\n\t\tif (!contextNeedsIdleProtection(contextType)) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tawait this.sendMessage(\n\t\t\t\t'ui_context_activity',\n\t\t\t\t{\n\t\t\t\t\tcontextId: this.contextId,\n\t\t\t\t\tcontextType: contextType,\n\t\t\t\t\ttimestamp: Date.now()\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tpriority: 'high', // Make activity updates high priority\n\t\t\t\t\tretryOnFail: true, // Retry if failed\n\t\t\t\t\tdeduplicate: false // Don't deduplicate activity messages\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tlog.debug('[Messaging - sendActivityUpdate] Activity update sent successfully');\n\t\t} catch (error) {\n\t\t\tlog.warn('[Messaging - sendActivityUpdate] Failed to send activity update:', false, error);\n\t\t}\n\t}\n\n\t/**\n\t * Notify the background script that login is verified or not (only for protected contexts)\n\t */\n\tpublic async setLoginVerified(verified: boolean, contextType?: string): Promise<void> {\n\t\tif (!isBrowser || !this.browserApi) {\n\t\t\tlog.warn(`[Messaging - setLoginVerified] ❌ CANNOT SET LOGIN VERIFIED:`, false, {\n\t\t\t\tisBrowser,\n\t\t\t\thasBrowserApi: !!this.browserApi,\n\t\t\t\tverified,\n\t\t\t\tcontextType\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tconst actualContextType = contextType || this.getContextType();\n\n\t\tlog.info(`[Messaging - setLoginVerified] 🔐 LOGIN VERIFICATION REQUEST:`, false, {\n\t\t\tverified,\n\t\t\tprovidedContextType: contextType,\n\t\t\tactualContextType,\n\t\t\tcontextId: this.contextId,\n\t\t\tisProtectedContext: contextNeedsIdleProtection(actualContextType),\n\t\t\tprotectedContexts\n\t\t});\n\n\t\t// Only send login verification for protected contexts\n\t\tif (!contextNeedsIdleProtection(actualContextType)) {\n\t\t\tlog.warn(`[Messaging - setLoginVerified] ❌ SKIPPING - not a protected context:`, false, {\n\t\t\t\tcontextType: actualContextType,\n\t\t\t\tprotectedContexts,\n\t\t\t\treason: 'Context type not in protected contexts list'\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tconst messageData = {\n\t\t\tverified,\n\t\t\tcontextId: this.contextId,\n\t\t\tcontextType: actualContextType\n\t\t};\n\n\t\tlog.info(\n\t\t\t`[Messaging - setLoginVerified] 📤 SENDING SET_LOGIN_VERIFIED message:`,\n\t\t\tfalse,\n\t\t\tmessageData\n\t\t);\n\n\t\ttry {\n\t\t\tawait this.sendMessage('SET_LOGIN_VERIFIED', messageData, {\n\t\t\t\tpriority: 'high',\n\t\t\t\tretryOnFail: true,\n\t\t\t\tdeduplicate: false\n\t\t\t});\n\n\t\t\tlog.info(`[Messaging - setLoginVerified] ✅ SET_LOGIN_VERIFIED sent successfully:`, false, {\n\t\t\t\tverified,\n\t\t\t\tcontextId: this.contextId,\n\t\t\t\tcontextType: actualContextType\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlog.error(`[Messaging - setLoginVerified] ❌ ERROR sending SET_LOGIN_VERIFIED:`, false, {\n\t\t\t\terror,\n\t\t\t\tmessageData,\n\t\t\t\tcontextId: this.contextId\n\t\t\t});\n\t\t\tthrow error;\n\t\t}\n\n\t\tlog.info(\n\t\t\t`[Messaging - setLoginVerified] 🎉 Login ${verified ? 'verified' : 'unverified'} for protected context: ${this.contextId}`\n\t\t);\n\t}\n\n\t/**\n\t * Determine the context type based on the current URL\n\t */\n\tprivate getContextType(): string {\n\t\ttry {\n\t\t\tif (!isBrowser || typeof window === 'undefined') return 'unknown';\n\n\t\t\tconst pathname = window.location.pathname;\n\t\t\tconst href = window.location.href;\n\n\t\t\tif (pathname.includes('sidepanel') || href.includes('sidepanel')) {\n\t\t\t\treturn 'sidepanel';\n\t\t\t} else if (\n\t\t\t\tpathname.includes('index.html') ||\n\t\t\t\thref.includes('index.html') ||\n\t\t\t\tpathname === '/' ||\n\t\t\t\tpathname === ''\n\t\t\t) {\n\t\t\t\treturn 'popup-wallet';\n\t\t\t} else if (pathname.includes('dapp/popups') || href.includes('dapp/popups')) {\n\t\t\t\treturn 'popup-dapp';\n\t\t\t} else if (pathname.includes('options') || href.includes('options')) {\n\t\t\t\treturn 'options';\n\t\t\t} else {\n\t\t\t\treturn 'popup-wallet'; // Default to popup-wallet for main extension\n\t\t\t}\n\t\t} catch (error) {\n\t\t\treturn 'unknown';\n\t\t}\n\t}\n\n\t/**\n\t * Set up activity tracking for this context (only for protected contexts)\n\t */\n\tpublic setupActivityTracking(): void {\n\t\tif (!isBrowser || typeof window === 'undefined') return;\n\n\t\tconst contextType = this.getContextType();\n\n\t\t// Only set up activity tracking for protected contexts\n\t\tif (!contextNeedsIdleProtection(contextType)) {\n\t\t\tlog.info(\n\t\t\t\t`[Messaging - setupActivityTracking] Skipping activity tracking setup for non-protected context: ${contextType}`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if already set up to prevent duplicate listeners\n\t\tif ((window as any).__yakklActivityTrackingSetup) {\n\t\t\tlog.info(\n\t\t\t\t'[Messaging - setupActivityTracking] Activity tracking already set up, skipping duplicate setup'\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tlog.info(\n\t\t\t`[Messaging - setupActivityTracking] Setting up activity tracking for protected context: ${contextType}`\n\t\t);\n\n\t\t// Track user activity\n\t\tconst activityEvents = [\n\t\t\t'mousedown',\n\t\t\t'mousemove',\n\t\t\t'keydown',\n\t\t\t'scroll',\n\t\t\t'touchstart',\n\t\t\t'focus',\n\t\t\t'click'\n\t\t];\n\n\t\t// Throttled activity tracker\n\t\tlet lastActivity = Date.now();\n\t\tconst ACTIVITY_THROTTLE = 2000; // Send at most every 2 seconds (reduced from 5 seconds)\n\n\t\tconst activityHandler = () => {\n\t\t\tconst now = Date.now();\n\t\t\tif (now - lastActivity > ACTIVITY_THROTTLE) {\n\t\t\t\tlastActivity = now;\n\n\t\t\t\tlog.debug(\n\t\t\t\t\t'[Messaging - setupActivityTracking] User activity detected, sending activity update'\n\t\t\t\t);\n\n\t\t\t\t// Send activity update immediately\n\t\t\t\tthis.sendActivityUpdate().catch((error) => {\n\t\t\t\t\tlog.debug(\n\t\t\t\t\t\t'[Messaging - setupActivityTracking] Failed to send activity update:',\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\terror\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t// Set up listeners with passive option for better performance\n\t\tactivityEvents.forEach((event) => {\n\t\t\twindow.addEventListener(event, activityHandler, {\n\t\t\t\tpassive: true,\n\t\t\t\tcapture: false\n\t\t\t});\n\t\t});\n\n\t\t// Mark as set up\n\t\t(window as any).__yakklActivityTrackingSetup = true;\n\t\t(window as any).__yakklActivityHandler = activityHandler;\n\t\t(window as any).__yakklActivityEvents = activityEvents;\n\n\t\t// Clean up on page unload\n\t\twindow.addEventListener('beforeunload', () => {\n\t\t\tactivityEvents.forEach((event) => {\n\t\t\t\twindow.removeEventListener(event, activityHandler);\n\t\t\t});\n\t\t\t(window as any).__yakklActivityTrackingSetup = false;\n\t\t});\n\n\t\tlog.info(\n\t\t\t'[Messaging - setupActivityTracking] Activity tracking set up successfully for protected context:',\n\t\t\tfalse,\n\t\t\t{\n\t\t\t\tcontextId: this.contextId,\n\t\t\t\tcontextType: contextType,\n\t\t\t\teventsTracked: activityEvents.length\n\t\t\t}\n\t\t);\n\t}\n}\n\n// Export a singleton instance\nexport const messagingService = ExtensionMessaging.getInstance();\n\n// Helper functions for common message patterns\n\n/**\n * Initialize the messaging service with the browser extension API\n * @param browserExtensionApi The browser extension API from webextension-polyfill\n */\nexport function initializeMessaging(browserExtensionApi: Browser): void {\n\tif (!isBrowser) return;\n\tmessagingService.initialize(browserExtensionApi);\n}\n\n/**\n * Send client ready message to background script\n */\nexport async function sendClientReady(): Promise<void> {\n\tif (!isBrowser) return;\n\n\tawait messagingService.sendMessage(\n\t\t'clientReady',\n\t\t{},\n\t\t{\n\t\t\tpriority: 'high',\n\t\t\tretryOnFail: true,\n\t\t\tdeduplicate: true\n\t\t}\n\t);\n}\n\n/**\n * Determine the most appropriate context type based on URL\n */\nfunction determineBestContextType(): string {\n\ttry {\n\t\tif (typeof window === 'undefined') return 'unknown';\n\n\t\tconst pathname = window.location.pathname;\n\t\tconst href = window.location.href;\n\n\t\tif (pathname.includes('sidepanel') || href.includes('sidepanel')) {\n\t\t\treturn 'sidepanel';\n\t\t} else if (\n\t\t\tpathname.includes('index.html') ||\n\t\t\thref.includes('index.html') ||\n\t\t\tpathname === '/' ||\n\t\t\tpathname === ''\n\t\t) {\n\t\t\treturn 'popup-wallet';\n\t\t} else if (pathname.includes('dapp/popups') || href.includes('dapp/popups')) {\n\t\t\treturn 'popup-dapp';\n\t\t} else if (pathname.includes('options') || href.includes('options')) {\n\t\t\treturn 'options';\n\t\t} else {\n\t\t\treturn 'popup-wallet'; // Default to popup-wallet for main extension\n\t\t}\n\t} catch (error) {\n\t\treturn 'unknown';\n\t}\n}\n\n/**\n * Initialize a UI context and start activity tracking\n * @param browserExtensionApi The browser extension API from webextension-polyfill\n * @param contextType Optional context type override\n */\nexport async function initializeUiContext(\n\tbrowserExtensionApi: Browser,\n\tcontextType?: string\n): Promise<void> {\n\tif (!isBrowser) return;\n\n\t// Initialize messaging service\n\tmessagingService.initialize(browserExtensionApi);\n\n\t// Register this UI context\n\tconst actualContextType = contextType || determineBestContextType();\n\tawait messagingService.registerUiContext(actualContextType);\n\n\t// Only set up activity tracking for protected contexts\n\tif (contextNeedsIdleProtection(actualContextType)) {\n\t\tlog.info(\n\t\t\t`[Messaging - initializeUiContext] Setting up activity tracking for protected context: ${actualContextType}`\n\t\t);\n\t\tmessagingService.setupActivityTracking();\n\t} else {\n\t\tlog.info(\n\t\t\t`[Messaging - initializeUiContext] Skipping activity tracking for non-protected context: ${actualContextType}`\n\t\t);\n\t}\n}\n\n/**\n * Start activity tracking after successful login (only for protected contexts)\n */\nexport async function startActivityTracking(contextType?: string): Promise<void> {\n\tif (!isBrowser) return;\n\n\tconst actualContextType = contextType || determineBestContextType();\n\n\tlog.info(`[Messaging - startActivityTracking] 🚀 STARTING ACTIVITY TRACKING:`, false, {\n\t\tprovidedContextType: contextType,\n\t\tactualContextType,\n\t\tisProtectedContext: contextNeedsIdleProtection(actualContextType),\n\t\texpectedProtectedTypes: protectedContexts,\n\t\tisBrowser: isBrowser,\n\t\tmessagingServiceExists: !!messagingService\n\t});\n\n\t// Only start activity tracking for protected contexts\n\tif (!contextNeedsIdleProtection(actualContextType)) {\n\t\tlog.warn(`[Messaging - startActivityTracking] ❌ SKIPPING - not a protected context:`, false, {\n\t\t\tcontextType: actualContextType,\n\t\t\tprotectedContexts,\n\t\t\treason: 'Context type not in protected contexts list'\n\t\t});\n\t\treturn;\n\t}\n\n\tlog.info(\n\t\t`[Messaging - startActivityTracking] 🔐 Setting login verified for protected context: ${actualContextType}`\n\t);\n\n\ttry {\n\t\t// Verify the login - this should trigger idle detection\n\t\tawait messagingService.setLoginVerified(true, actualContextType);\n\t\tlog.info(`[Messaging - startActivityTracking] ✅ Login verification message sent successfully`);\n\t} catch (error) {\n\t\tlog.error(\n\t\t\t`[Messaging - startActivityTracking] ❌ ERROR sending login verification:`,\n\t\t\tfalse,\n\t\t\terror\n\t\t);\n\t\tthrow error;\n\t}\n\n\ttry {\n\t\t// Ensure activity tracking is set up - should have been called in +layout.svelte at route level\n\t\tmessagingService.setupActivityTracking();\n\t\tlog.info(`[Messaging - startActivityTracking] ✅ Activity tracking setup completed`);\n\t} catch (error) {\n\t\tlog.error(\n\t\t\t`[Messaging - startActivityTracking] ❌ ERROR setting up activity tracking:`,\n\t\t\tfalse,\n\t\t\terror\n\t\t);\n\t}\n\n\tlog.info(\n\t\t`[Messaging - startActivityTracking] 🎉 ACTIVITY TRACKING STARTED for protected context: ${actualContextType}`\n\t);\n}\n\n/**\n * Stop activity tracking (e.g., at logout) (only for protected contexts)\n */\nexport async function stopActivityTracking(): Promise<void> {\n\tif (!isBrowser) return;\n\n\tconst contextType = determineBestContextType();\n\n\t// Only stop activity tracking for protected contexts\n\tif (!contextNeedsIdleProtection(contextType)) {\n\t\tlog.info(\n\t\t\t`[Messaging - stopActivityTracking] Skipping activity tracking stop for non-protected context: ${contextType}`\n\t\t);\n\t\treturn;\n\t}\n\n\tawait messagingService.setLoginVerified(false);\n\n\tlog.info(\n\t\t`[Messaging - stopActivityTracking] Activity tracking stopped for protected context: ${contextType}`\n\t);\n}\n\n/**\n * Get the context ID for this client instance\n */\nexport function getContextId(): string {\n\tif (\n\t\ttypeof window !== 'undefined' &&\n\t\twindow.EXTENSION_INIT_STATE &&\n\t\twindow.EXTENSION_INIT_STATE.contextId\n\t) {\n\t\treturn window.EXTENSION_INIT_STATE.contextId;\n\t}\n\treturn '';\n}\n\n/**\n * Apply this messaging utility to a global error handler\n * @param handler The error handler function or class\n */\nexport function hookErrorHandler(handler: any): void {\n\tif (!isBrowser || typeof handler.handleError !== 'function') {\n\t\treturn;\n\t}\n\n\t// Store original method\n\tconst originalHandleError = handler.handleError;\n\n\t// Override with our version\n\thandler.handleError = function (error: any) {\n\t\ttry {\n\t\t\t// Send error to background with context info\n\t\t\tmessagingService\n\t\t\t\t.sendMessage(\n\t\t\t\t\t'error_report',\n\t\t\t\t\t{\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\tmessage: error?.message || String(error),\n\t\t\t\t\t\t\tstack: error?.stack,\n\t\t\t\t\t\t\tname: error?.name\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlocation: typeof window !== 'undefined' ? window.location.href : 'unknown',\n\t\t\t\t\t\ttimestamp: Date.now()\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tpriority: 'high',\n\t\t\t\t\t\tretryOnFail: true\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t\t.catch(() => {\n\t\t\t\t\t// Silently fail - don't want errors in error handler\n\t\t\t\t});\n\t\t} catch (e) {\n\t\t\t// Ignore errors in our error handler\n\t\t}\n\n\t\t// Call original handler\n\t\treturn originalHandleError.call(handler, error);\n\t};\n}\n\nexport default messagingService;\n"],"names":["contextNeedsIdleProtection","contextType","protectedContexts","includes","_ExtensionMessaging","constructor","__publicField","this","Map","UnifiedTimerManager","getInstance","instance","initialize","browserExtensionApi","browserApi","contextId","getContextId","log","debug","processQueue","runtime","onMessage","addListener","handleIncomingMessage","bind","timerManager","addInterval","cleanup","startInterval","sendCleanupMessage","type","data","source","message","messageId","Date","now","timestamp","isCleanup","sendMessage","catch","error","sender","sendResponse","responseId","result","pendingRequest","pendingRequests","get","reject","resolve","delete","processedResponses","set","options","priority","retryOnFail","deduplicate","responseTimeout","waitForResponse","FIRE_AND_FORGET_MESSAGES","toString","exactMessageKey","JSON","stringify","recentResponse","Promise","warn","Error","success","noResponseRequired","sendFailed","timeoutId","setTimeout","has","queueKey","messageQueue","push","retryCount","isProcessing","priorities","queue","length","item","shift","MAX_RETRIES","attempt","clearTimeout","RETRY_DELAY","values","request","entries","response","isInitialized","triggerActivityDetection","window","handler","__yakklActivityHandler","info","registerUiContext","addEventListener","console","sendActivityUpdate","getContextType","setLoginVerified","verified","isBrowser","hasBrowserApi","actualContextType","providedContextType","isProtectedContext","reason","messageData","pathname","location","href","setupActivityTracking","__yakklActivityTrackingSetup","activityEvents","lastActivity","ACTIVITY_THROTTLE","activityHandler","forEach","event","passive","capture","__yakklActivityEvents","removeEventListener","eventsTracked","ExtensionMessaging","messagingService","determineBestContextType","async","initializeUiContext","startActivityTracking","expectedProtectedTypes","messagingServiceExists","stopActivityTracking"],"mappings":"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"}