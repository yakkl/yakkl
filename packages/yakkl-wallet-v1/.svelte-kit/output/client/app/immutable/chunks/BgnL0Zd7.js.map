{"version":3,"file":"BgnL0Zd7.js","sources":["../../../../../../src/lib/common/utils.ts"],"sourcesContent":["/* eslint-disable no-debugger */\nimport {\n\tPRO_ELIGIBLE_PROMO_TYPES,\n\tTRIAL_DAYS,\n\ttype ErrorBody,\n\ttype ParsedError\n} from '$lib/common';\nimport { AccessSourceType, AccountTypeCategory, PlanType } from '$lib/common/types';\nimport type { Settings, YakklAccount, YakklPrimaryAccount } from '$lib/common/interfaces';\nimport {\n\tgetYakklAccounts,\n\tgetYakklPrimaryAccounts,\n\tyakklAccountsStore,\n\tsetYakklAccountsStorage,\n\tsetYakklPrimaryAccountsStorage,\n\tyakklPrimaryAccountsStore,\n\tgetSettings,\n\tsetSettingsStorage\n} from '$lib/common/stores';\nimport { browser_ext } from './environment';\nimport { ethers as ethersv6 } from 'ethers-v6';\nimport { get } from 'svelte/store';\nimport { log } from '$lib/managers/Logger';\nimport type { Runtime } from 'webextension-polyfill';\n\n// Global flag to track extension context validity\nlet extensionContextValid = true;\n\n// Queue for operations that need valid extension context\nconst contextDependentOperations: Array<() => void> = [];\n\nexport function isExtensionContextValid(): boolean {\n\ttry {\n\t\t// Multiple checks to ensure context is valid\n\t\tif (!browser_ext?.runtime?.id) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Try to access extension URL to test context\n\t\tif (browser_ext.runtime.getURL) {\n\t\t\tbrowser_ext.runtime.getURL('/');\n\t\t}\n\n\t\treturn true;\n\t} catch (error) {\n\t\treturn false;\n\t}\n}\n\n/**\n * Validate extension context and update global flag\n */\nfunction validateExtensionContext(): boolean {\n\tconst wasValid = extensionContextValid;\n\textensionContextValid = isExtensionContextValid();\n\n\tif (wasValid && !extensionContextValid) {\n\t\tlog.warn('[ExtensionContext] Extension context became invalid');\n\t\t// Clear any pending operations\n\t\tcontextDependentOperations.length = 0;\n\t} else if (!wasValid && extensionContextValid) {\n\t\tlog.info('[ExtensionContext] Extension context restored');\n\t\t// Execute queued operations\n\t\twhile (contextDependentOperations.length > 0) {\n\t\t\tconst operation = contextDependentOperations.shift();\n\t\t\ttry {\n\t\t\t\toperation?.();\n\t\t\t} catch (error) {\n\t\t\t\tlog.warn('[ExtensionContext] Error executing queued operation:', false, error);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn extensionContextValid;\n}\n\n// This is used to get the current function name and location\nexport function getCurrentFunctionInfo(depth = 2): { name: string; location: string } {\n\tconst err = new Error();\n\tconst stack = err.stack?.split('\\n');\n\n\tif (!stack || stack.length <= depth) {\n\t\treturn { name: 'unknown', location: 'unknown' };\n\t}\n\n\tconst rawLine = stack[depth].trim(); // e.g., at myFunction (src/myfile.ts:10:5)\n\n\tconst match = rawLine.match(/at\\s+(.*)\\s+\\((.*)\\)/) || rawLine.match(/at\\s+(.*)/);\n\n\tif (match) {\n\t\tconst [, name, location] = match;\n\t\treturn {\n\t\t\tname: name?.split(' ')[0] ?? 'anonymous',\n\t\t\tlocation: location ?? 'unknown'\n\t\t};\n\t}\n\n\treturn { name: 'unknown', location: 'unknown' };\n}\n\nexport async function isProLevel(): Promise<boolean> {\n\tconst settings = await getSettings();\n\treturn (\n\t\tsettings?.plan.type === PlanType.YAKKL_PRO ||\n\t\tsettings?.plan.type === PlanType.FOUNDING_MEMBER ||\n\t\tsettings?.plan.type === PlanType.EARLY_ADOPTER\n\t);\n}\n\nexport async function isStandard(): Promise<boolean> {\n\tconst settings = await getSettings();\n\treturn settings?.plan.type === PlanType.BASIC_MEMBER;\n}\n\nexport async function setRegisteredType(type: PlanType): Promise<void> {\n\tconst settings = await getSettings();\n\tif (settings) {\n\t\tsettings.plan.type = type;\n\t\tawait setSettingsStorage(settings); // You should have something that handles both local state and extension storage sync\n\t}\n}\n\nexport async function isTrialing(): Promise<boolean> {\n\tconst settings = await getSettings();\n\treturn settings.plan.source === AccessSourceType.TRIAL;\n}\n\nexport async function trialExpiresSoon(): Promise<boolean> {\n\tconst settings = await getSettings();\n\tif (!settings.plan.trialEndDate) return false;\n\treturn new Date(settings.plan.trialEndDate).getTime() - Date.now() < 1000 * 60 * 60 * 24; // < 1 day\n}\n\nexport async function isFullyPro(providedSettings?: Settings): Promise<boolean> {\n\tconst settings = providedSettings ?? (await getSettings());\n\n\tif (!settings) return false;\n\n\tconst { plan } = settings;\n\n\treturn (\n\t\t(plan.type === PlanType.YAKKL_PRO ||\n\t\t\tplan.type === PlanType.FOUNDING_MEMBER ||\n\t\t\tplan.type === PlanType.EARLY_ADOPTER) &&\n\t\tplan.source !== AccessSourceType.TRIAL &&\n\t\t!plan.trialEndDate &&\n\t\t!plan.promo\n\t);\n}\n\nexport async function canUpgrade(providedSettings?: Settings): Promise<boolean> {\n\tconst settings = providedSettings ?? (await getSettings());\n\n\tif (!settings) return false;\n\n\tconst { plan } = settings;\n\n\t// Fully Pro users (paid or promo) can't upgrade\n\tif (\n\t\t(plan.type === PlanType.YAKKL_PRO ||\n\t\t\tplan.type === PlanType.FOUNDING_MEMBER ||\n\t\t\tplan.type === PlanType.EARLY_ADOPTER) &&\n\t\tplan.source !== AccessSourceType.TRIAL &&\n\t\t!plan.trialEndDate &&\n\t\t!plan.promo // optional check: may allow influencer accounts to upgrade again\n\t) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nexport function normalizeUserPlan(settings: Settings): Settings {\n\tconst now = new Date();\n\n\tconst isTrialExpired =\n\t\tsettings.plan.trialEndDate && new Date(settings.plan.trialEndDate).getTime() < now.getTime();\n\n\tconst hasPromo =\n\t\tsettings.plan.promo && PRO_ELIGIBLE_PROMO_TYPES.includes(settings.plan.promo.toLowerCase());\n\n\tif (isTrialExpired && !hasPromo) {\n\t\treturn {\n\t\t\t...settings,\n\t\t\tplan: {\n\t\t\t\t...settings.plan,\n\t\t\t\ttype: PlanType.BASIC_MEMBER,\n\t\t\t\tsource: AccessSourceType.STANDARD,\n\t\t\t\ttrialEndDate: null,\n\t\t\t\tpromo: null,\n\t\t\t\tupgradeDate: null\n\t\t\t}\n\t\t};\n\t}\n\n\treturn settings;\n}\n\nexport async function getNormalizedSettings(): Promise<Settings> {\n\tconst raw = await getSettings();\n\tconst normalized = normalizeUserPlan(raw);\n\n\tif (JSON.stringify(normalized.plan) !== JSON.stringify(raw.plan)) {\n\t\tawait setSettingsStorage(normalized);\n\t}\n\n\treturn normalized;\n}\n\n// Use for messaging to let the user know that their trial has expired\nexport function wasTrialExpiredRecently(\n\tsettings: Settings,\n\tthresholdInMs = 1000 * 60 * 60 * 24\n): boolean {\n\tif (!settings.plan.trialEndDate) return false;\n\n\tconst trialEndedAt = new Date(settings.plan.trialEndDate).getTime();\n\tconst now = Date.now();\n\n\treturn trialEndedAt < now && now - trialEndedAt < thresholdInMs;\n}\n\nexport function getTrialEndDate(): string {\n\tconst days = TRIAL_DAYS;\n\tconst now = new Date();\n\tnow.setDate(now.getDate() + days);\n\treturn now.toISOString();\n}\n\nexport function safeRuntimeCall<T>(callback: () => T, fallback?: T): T | undefined {\n\tif (!isExtensionContextValid()) {\n\t\tconsole.warn('Extension context invalidated');\n\t\treturn fallback;\n\t}\n\n\ttry {\n\t\treturn callback();\n\t} catch (error: any) {\n\t\tif (error.message?.includes('Extension context invalidated')) {\n\t\t\tconsole.warn('Extension context invalidated during call');\n\t\t\treturn fallback;\n\t\t}\n\t\tthrow error;\n\t}\n}\n\nexport async function safeSendMessage<T>(\n\tmessage: any,\n\toptions?: Runtime.SendMessageOptionsType\n): Promise<T | null> {\n\treturn safeRuntimeCall(async () => {\n\t\ttry {\n\t\t\treturn browser_ext.runtime.sendMessage(message, options);\n\t\t} catch (error: any) {\n\t\t\tif (error.message?.includes('receiving end does not exist')) {\n\t\t\t\tconsole.warn('Message receiver not available');\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthrow error;\n\t\t}\n\t}, null);\n}\n\n// For ssr checks during compiling\nexport function isServerSide(): boolean {\n\treturn typeof window === 'undefined' || typeof document === 'undefined';\n}\n\n// This should represent the .id property of given objects for uniqueness\nexport function getUserId(): string {\n\tlet userId = localStorage.getItem('anonymous_user_id');\n\tif (!userId) {\n\t\tuserId = crypto.randomUUID(); //  `${string}-${string}-${string}-${string}-${string}` format of very random string\n\t\tlocalStorage.setItem('anonymous_user_id', userId);\n\t}\n\treturn userId;\n}\n\nexport function detectExecutionContext():\n\t| 'background'\n\t| 'content_script'\n\t| 'popup'\n\t| 'options'\n\t| 'unknown' {\n\t// Background Service Worker (No `window` object)\n\tif (typeof window === 'undefined') {\n\t\treturn 'background';\n\t}\n\n\t// Content Script (Has `document`, but no `chrome-extension://` URL)\n\tif (typeof document !== 'undefined' && window.location.protocol !== 'chrome-extension:') {\n\t\treturn 'content_script';\n\t}\n\n\t// Popup or Options Page (Runs within the extension UI)\n\tif (window.location.protocol === 'chrome-extension:') {\n\t\t// Check if running in a popup\n\t\tif (window.location.pathname.includes('popup')) {\n\t\t\treturn 'popup';\n\t\t}\n\n\t\t// Check if running in the options page\n\t\tif (window.location.pathname.includes('options')) {\n\t\t\treturn 'options';\n\t\t}\n\n\t\treturn 'unknown'; // Some other extension UI page\n\t}\n\n\treturn 'unknown'; // Fallback if none of the above match\n}\n\n// export async function checkAccountRegistration(): Promise<boolean> {\n//   try {\n//     const accounts: YakklAccount[] = get(yakklAccountsStore);\n\n//     if (!accounts || accounts.length === 0) {\n//       return false;\n//     }\n\n//     let hasPrimaryOrImported = false;\n//     if (Array.isArray(accounts)) {\n//       hasPrimaryOrImported = accounts.some(account =>\n//         account.accountType === AccountTypeCategory.PRIMARY ||\n//         account.accountType === AccountTypeCategory.IMPORTED\n//       );\n//     } else {\n//       log.warn('Accounts is currently not an array:', false, accounts);\n//     }\n\n//     return hasPrimaryOrImported;\n//   } catch (error) {\n//     log.error('Error checking registration:', false, error);\n//     return false;\n//   }\n// }\n\nexport async function checkAccountRegistration(): Promise<boolean> {\n\ttry {\n\t\tlet accounts: YakklAccount[] | Record<string, YakklAccount> = get(yakklAccountsStore);\n\t\tlet primaryAccounts: YakklPrimaryAccount[] | Record<string, YakklPrimaryAccount> =\n\t\t\tget(yakklPrimaryAccountsStore);\n\n\t\t// Ensure accounts is an array\n\t\tif (!Array.isArray(accounts)) {\n\t\t\taccounts = Object.values(accounts);\n\t\t\tlog.warn('Accounts is currently not an array:', false, accounts);\n\t\t\tawait setYakklAccountsStorage(accounts);\n\t\t\tyakklAccountsStore.set(accounts);\n\t\t\tif (Array.isArray(accounts))\n\t\t\t\tlog.info('Accounts has been converted to an array and stored:', false, accounts);\n\t\t}\n\n\t\tif (!accounts || accounts.length === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst hasPrimaryOrImported = accounts.some(\n\t\t\t(account) =>\n\t\t\t\taccount.accountType === AccountTypeCategory.PRIMARY ||\n\t\t\t\taccount.accountType === AccountTypeCategory.IMPORTED\n\t\t);\n\n\t\t// Ensure primaryAccounts is an array of values and if not return false\n\t\tif (!primaryAccounts || primaryAccounts.length === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn hasPrimaryOrImported;\n\t} catch (error) {\n\t\tlog.error('Error checking registration:', false, error);\n\t\treturn false;\n\t}\n}\n\nexport function parseAmount(amount: string, decimals: number): bigint {\n\t// Normalize input\n\tconst normalizedAmount = amount.startsWith('.') ? `0${amount}` : amount;\n\n\ttry {\n\t\t// Use a more robust parsing method\n\t\tconst [integerPart, fractionalPart = ''] = normalizedAmount.split('.');\n\n\t\t// Truncate or pad fractional part\n\t\tconst truncatedFractional = fractionalPart.slice(0, decimals).padEnd(decimals, '0');\n\n\t\t// Combine parts\n\t\tconst fullAmount = `${integerPart}${truncatedFractional}`;\n\n\t\treturn BigInt(fullAmount);\n\t} catch (error) {\n\t\tlog.error('Failed to parse amount:', false, error);\n\t\treturn 0n;\n\t}\n}\n\nexport function parseAmountAlternative(amount: string, decimals: number): bigint {\n\t// Handle empty or invalid inputs\n\tif (!amount || amount === '.' || amount.trim() === '') {\n\t\treturn 0n;\n\t}\n\n\ttry {\n\t\t// Convert to number first to handle scientific notation and precision\n\t\tconst numericValue = Number(amount);\n\n\t\t// Multiply by 10^decimals and convert to bigint\n\t\treturn BigInt(Math.round(numericValue * 10 ** decimals));\n\t} catch (error) {\n\t\tlog.error('Error parsing amount:', false, error);\n\t\treturn 0n;\n\t}\n}\n\n// Format USD amounts to 2 decimal places\nexport function formatUsd(amount: number): string {\n\treturn amount.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });\n}\n\n// Format token amounts based on decimals\nexport function formatAmount(amount: bigint, decimals: number): string {\n\tif (amount === 0n) return '0';\n\tconst value = Number(amount) / Math.pow(10, decimals);\n\treturn value.toLocaleString(undefined, {\n\t\tminimumFractionDigits: 0,\n\t\tmaximumFractionDigits: decimals\n\t});\n}\n\nexport function convertUsdToTokenAmount(\n\tusdAmount: number,\n\tmarketPrice: number,\n\tdecimals: number\n): string {\n\tif (marketPrice <= 0) return '0';\n\tconst tokenAmount = usdAmount / marketPrice;\n\treturn ethersv6.formatUnits(\n\t\tethersv6.parseUnits(tokenAmount.toFixed(decimals), decimals),\n\t\tdecimals\n\t);\n}\n\nexport function convertTokenToUsd(tokenAmount: number, marketPrice: number): number {\n\tif (marketPrice <= 0) return 0;\n\treturn tokenAmount * marketPrice;\n}\n\n/**\n * <p transition:typewriter>\n\t\tThe quick brown fox jumps over the lazy dog\n\t</p>\n */\n\ninterface TypewriterOptions {\n\tspeed?: number;\n}\n\nexport function typewriter(node: HTMLElement, { speed = 1 }: TypewriterOptions) {\n\tif (node.childNodes.length !== 1 || node.childNodes[0].nodeType !== Node.TEXT_NODE) {\n\t\tthrow new Error(`This transition only works on elements with a single text node child`);\n\t}\n\n\tconst text = node.textContent ?? '';\n\tconst duration = text.length / (speed * 0.01);\n\n\treturn {\n\t\tduration,\n\t\ttick: (t: number) => {\n\t\t\tconst i = Math.trunc(text.length * t);\n\t\t\tnode.textContent = text.slice(0, i);\n\t\t}\n\t};\n}\n\n// TODO: Add more blockchain support here - Audit functions and classes and remove any duplicates (this could be one)\nexport function supportedChainId(chainId: number) {\n\tswitch (chainId) {\n\t\tcase 1:\n\t\tcase 5:\n\t\tcase 11155111:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn false;\n}\n\n// chainId is a number and returns a hex string\nexport function toHexChainId(chainId: number): string {\n\treturn `0x${chainId.toString(16)}`;\n}\n\nexport const gweiToWeiHex = (gwei: number) => {\n\treturn `0x${(gwei * 1e9).toString(16)}`;\n};\n\nexport const wait = (time: number | undefined) =>\n\tnew Promise((resolve) => setTimeout(resolve, time));\n\nexport function parseErrorMessageFromJSON(errorMessage: string): ParsedError {\n\ttry {\n\t\tconst parsedError: ErrorBody = JSON.parse(errorMessage);\n\n\t\tif (parsedError.body) {\n\t\t\tconst body: ErrorBody = JSON.parse(parsedError.body);\n\t\t\treturn body.error ?? null;\n\t\t}\n\n\t\tif (parsedError.reason) {\n\t\t\treturn parsedError.reason;\n\t\t}\n\n\t\treturn parsedError;\n\t} catch (error) {\n\t\tlog.error('Failed to parse errorMessage, body or error:', false, error);\n\t}\n\n\treturn null;\n}\n// Used for the 'data' field in the transaction\nexport function getLengthInBytes(value: string): number {\n\tif (typeof value === 'string' && value !== '0x') {\n\t\tif (value.startsWith('0x')) return Math.round(value.length / 2);\n\t\treturn value.length;\n\t}\n\treturn 0;\n}\n\n/**\n * Checks if an address exists in either accounts or primary accounts tables\n * @param address The address to check\n * @returns An object with exists (boolean) and table (string) properties\n */\nexport async function addressExist(\n\taddress: string\n): Promise<{ exists: boolean; table: string | null }> {\n\ttry {\n\t\t// Check in accounts table\n\t\tconst yakklAccounts = await getYakklAccounts();\n\t\tfor (const account of yakklAccounts) {\n\t\t\tif (account.address === address) {\n\t\t\t\treturn { exists: true, table: 'accounts' };\n\t\t\t}\n\t\t}\n\n\t\t// Check in primary accounts table\n\t\tconst yakklPrimaryAccounts = await getYakklPrimaryAccounts();\n\t\tfor (const account of yakklPrimaryAccounts) {\n\t\t\tif (account.address === address) {\n\t\t\t\treturn { exists: true, table: 'primaryAccounts' };\n\t\t\t}\n\t\t}\n\n\t\t// Address not found in either table\n\t\treturn { exists: false, table: null };\n\t} catch (error) {\n\t\tlog.error('Error checking if address exists:', false, error);\n\t\treturn { exists: false, table: null };\n\t}\n}\n\n/**\n * Removes duplicate addresses from yakklAccounts and yakklPrimaryAccounts\n * @returns An object with the number of duplicates removed from each table\n */\nexport async function removeDuplicateAddress(): Promise<{\n\taccountsRemoved: number;\n\tprimaryAccountsRemoved: number;\n}> {\n\ttry {\n\t\t// Get current accounts\n\t\tconst yakklAccounts = await getYakklAccounts();\n\t\tconst yakklPrimaryAccounts = await getYakklPrimaryAccounts();\n\n\t\t// Track original counts\n\t\tconst originalAccountsCount = yakklAccounts.length;\n\t\tconst originalPrimaryAccountsCount = yakklPrimaryAccounts.length;\n\n\t\t// Create maps to track unique addresses\n\t\tconst uniqueAccounts = new Map<string, YakklAccount>();\n\t\tconst uniquePrimaryAccounts = new Map<string, YakklPrimaryAccount>();\n\n\t\t// Process accounts - keep only the most recent entry for each address\n\t\tfor (const account of yakklAccounts) {\n\t\t\tif (uniqueAccounts.has(account.address)) {\n\t\t\t\t// If we already have this address, keep the one with the most recent update date\n\t\t\t\tconst existingAccount = uniqueAccounts.get(account.address)!;\n\t\t\t\tif (account.updateDate > existingAccount.updateDate) {\n\t\t\t\t\tuniqueAccounts.set(account.address, account);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tuniqueAccounts.set(account.address, account);\n\t\t\t}\n\t\t}\n\n\t\t// Process primary accounts - keep only the most recent entry for each address\n\t\tfor (const account of yakklPrimaryAccounts) {\n\t\t\tif (uniquePrimaryAccounts.has(account.address)) {\n\t\t\t\t// If we already have this address, keep the one with the most recent update date\n\t\t\t\tconst existingAccount = uniquePrimaryAccounts.get(account.address)!;\n\t\t\t\tif (account.updateDate > existingAccount.updateDate) {\n\t\t\t\t\tuniquePrimaryAccounts.set(account.address, account);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tuniquePrimaryAccounts.set(account.address, account);\n\t\t\t}\n\t\t}\n\n\t\t// Convert maps back to arrays\n\t\tconst deduplicatedAccounts = Array.from(uniqueAccounts.values());\n\t\tconst deduplicatedPrimaryAccounts = Array.from(uniquePrimaryAccounts.values());\n\n\t\t// Calculate how many duplicates were removed\n\t\tconst accountsRemoved = originalAccountsCount - deduplicatedAccounts.length;\n\t\tconst primaryAccountsRemoved =\n\t\t\toriginalPrimaryAccountsCount - deduplicatedPrimaryAccounts.length;\n\n\t\t// Only update storage if duplicates were found and removed\n\t\tif (accountsRemoved > 0) {\n\t\t\tawait setYakklAccountsStorage(deduplicatedAccounts);\n\t\t}\n\n\t\tif (primaryAccountsRemoved > 0) {\n\t\t\tawait setYakklPrimaryAccountsStorage(deduplicatedPrimaryAccounts);\n\t\t}\n\n\t\treturn { accountsRemoved, primaryAccountsRemoved };\n\t} catch (error) {\n\t\tlog.error('Error removing duplicate addresses:', false, error);\n\t\treturn { accountsRemoved: 0, primaryAccountsRemoved: 0 };\n\t}\n}\n"],"names":["async","isProLevel","settings","getSettings","plan","type","PlanType","YAKKL_PRO","FOUNDING_MEMBER","EARLY_ADOPTER","canUpgrade","providedSettings","source","AccessSourceType","TRIAL","trialEndDate","promo","normalizeUserPlan","now","Date","isTrialExpired","getTime","hasPromo","PRO_ELIGIBLE_PROMO_TYPES","includes","toLowerCase","BASIC_MEMBER","STANDARD","upgradeDate","getNormalizedSettings","raw","normalized","JSON","stringify","setSettingsStorage","isServerSide","window","document","getUserId","userId","localStorage","getItem","crypto","randomUUID","setItem","parseAmount","amount","decimals","normalizedAmount","startsWith","integerPart","fractionalPart","split","truncatedFractional","slice","padEnd","fullAmount","BigInt","error","log","convertUsdToTokenAmount","usdAmount","marketPrice","tokenAmount","ethersv6.formatUnits","ethersv6.parseUnits","toFixed","convertTokenToUsd","wait","time","Promise","resolve","setTimeout","getLengthInBytes","value","Math","round","length","addressExist","address","yakklAccounts","getYakklAccounts","account","exists","table","yakklPrimaryAccounts","getYakklPrimaryAccounts"],"mappings":"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"}