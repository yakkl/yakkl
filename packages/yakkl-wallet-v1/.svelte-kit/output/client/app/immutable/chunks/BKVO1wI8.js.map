{"version":3,"file":"BKVO1wI8.js","sources":["../../../../../../src/lib/managers/TimerManager.ts"],"sourcesContent":["import { writable } from 'svelte/store';\nimport { UnifiedTimerManager } from './UnifiedTimerManager';\n\ntype TimerCallback = () => void;\n\nexport interface Timer {\n\tid: string;\n\tcallback: TimerCallback;\n\tduration: number;\n\thandleIntervalID: NodeJS.Timeout | null;\n}\n\nexport const timerManagerStore = writable<TimerManager | null>(null);\n\n// TimerManager wraps UnifiedTimerManager for backward compatibility\nexport class TimerManager {\n\tprivate timers: Map<string, Timer> = new Map();\n\tprivate static instance: TimerManager | null = null;\n\tprivate unifiedManager: UnifiedTimerManager;\n\n\tconstructor() {\n\t\tif (TimerManager.instance) {\n\t\t\tif (!timerManagerStore) {\n\t\t\t\ttimerManagerStore.set(this);\n\t\t\t}\n\t\t\treturn TimerManager.instance;\n\t\t}\n\t\tthis.unifiedManager = UnifiedTimerManager.getInstance();\n\t\tTimerManager.instance = this;\n\t\ttimerManagerStore.set(this);\n\t}\n\n\tpublic static getInstance(): TimerManager {\n\t\treturn TimerManager.instance ?? new TimerManager();\n\t}\n\n\tpublic static clearInstance(): void {\n\t\tif (this.instance) {\n\t\t\tthis.instance.unifiedManager.clearAll();\n\t\t}\n\t\tthis.instance = null;\n\t\ttimerManagerStore.set(null);\n\t}\n\n\tpublic static resetInstance(): TimerManager {\n\t\tthis.clearInstance();\n\t\treturn this.getInstance();\n\t}\n\n\t/**\n\t * Add a new timer.\n\t * @param id - Unique ID for the timer.\n\t * @param callback - Function to execute when the timer triggers.\n\t * @param duration - Duration in milliseconds.\n\t */\n\taddTimer(id: string, callback: TimerCallback, duration: number): void {\n\t\t// Store locally for backward compatibility\n\t\tthis.timers.set(id, { id, callback, duration, handleIntervalID: null });\n\t\t// Delegate to unified manager\n\t\tthis.unifiedManager.addInterval(id, callback, duration);\n\t}\n\n\thasTimer(id: string): boolean {\n\t\treturn this.timers.has(id);\n\t}\n\n\t/**\n\t * Start a timer by ID.\n\t */\n\tstartTimer(id: string): void {\n\t\tthis.unifiedManager.startInterval(id);\n\t}\n\n\tstartTimerDelayed(id: string): void {\n\t\tthis.unifiedManager.startInterval(id);\n\t}\n\n\tstartTimerImmediate(id: string): void {\n\t\tthis.unifiedManager.startInterval(id, true);\n\t}\n\n\t/**\n\t * Stop a timer by ID.\n\t */\n\tstopTimer(id: string): void {\n\t\tthis.unifiedManager.stopInterval(id);\n\t}\n\n\t/**\n\t * Start all timers.\n\t */\n\tstartAll(): void {\n\t\tthis.timers.forEach((_, id) => this.unifiedManager.startInterval(id));\n\t}\n\n\t/**\n\t * Stop all timers.\n\t */\n\tstopAll(): void {\n\t\tthis.timers.forEach((_, id) => this.unifiedManager.stopInterval(id));\n\t}\n\n\t/**\n\t * Remove a timer by ID.\n\t */\n\tremoveTimer(id: string): void {\n\t\tthis.unifiedManager.removeInterval(id);\n\t\tthis.timers.delete(id);\n\t}\n\n\t/**\n\t * Remove all timers.\n\t */\n\tremoveAll(): void {\n\t\tthis.unifiedManager.clearAll();\n\t\tthis.timers.clear();\n\t}\n\n\t/**\n\t * Check if a timer is running.\n\t */\n\tisRunning(id: string): boolean {\n\t\treturn this.unifiedManager.isIntervalRunning(id);\n\t}\n\n\tgetTimeoutID(_id: string): NodeJS.Timeout | null {\n\t\t// This method name is misleading but kept for backward compatibility\n\t\treturn null; // UnifiedTimerManager doesn't expose handles directly\n\t}\n\n\t/**\n\t * List active timers.\n\t */\n\tgetRunningTimers(): string[] {\n\t\treturn this.unifiedManager.getRunningTimers().intervals;\n\t}\n\n\t/**\n\t * List all registered timers.\n\t */\n\tlistTimers(): string[] {\n\t\treturn Array.from(this.timers.keys());\n\t}\n}\n\n// Lazy instantiation function to prevent circular dependencies\nexport const getTimerManager = () => TimerManager.getInstance();\n"],"names":["timerManagerStore","writable","_TimerManager","constructor","__publicField","this","Map","instance","set","unifiedManager","UnifiedTimerManager","getInstance","clearInstance","clearAll","resetInstance","addTimer","id","callback","duration","timers","handleIntervalID","addInterval","hasTimer","has","startTimer","startInterval","startTimerDelayed","startTimerImmediate","stopTimer","stopInterval","startAll","forEach","_","stopAll","removeTimer","removeInterval","delete","removeAll","clear","isRunning","isIntervalRunning","getTimeoutID","_id","getRunningTimers","intervals","listTimers","Array","from","keys","TimerManager","getTimerManager"],"mappings":"2WAYa,MAAAA,kBAAoBC,SAA8B,MAGxD,MAAMC,cAAN,MAAMA,cAKZ,WAAAC,GAJQC,cAAAC,KAAA,aAAiCC,KAEjCF,cAAAC,KAAA,kBAGP,GAAIH,cAAaK,SAAU,CAC1B,IAAKP,kBAAmB,CACvBA,kBAAkBQ,IAAIH,KAAI,CAE3B,OAAOH,cAAaK,QAAA,CAEhBF,KAAAI,eAAiBC,oBAAoBC,cAC1CT,cAAaK,SAAWF,KACxBL,kBAAkBQ,IAAIH,KAAI,CAG3B,kBAAcM,GACN,OAAAT,cAAaK,UAAY,IAAIL,aAAa,CAGlD,oBAAcU,GACb,GAAIP,KAAKE,SAAU,CACbF,KAAAE,SAASE,eAAeI,UAAS,CAEvCR,KAAKE,SAAW,KAChBP,kBAAkBQ,IAAI,KAAI,CAG3B,oBAAcM,GACbT,KAAKO,gBACL,OAAOP,KAAKM,aAAY,CASzB,QAAAI,CAASC,GAAYC,SAAyBC,UAExCb,KAAAc,OAAOX,IAAIQ,GAAI,CAAEA,MAAIC,kBAAUC,kBAAUE,iBAAkB,OAEhEf,KAAKI,eAAeY,YAAYL,GAAIC,SAAUC,SAAQ,CAGvD,QAAAI,CAASN,IACD,OAAAX,KAAKc,OAAOI,IAAIP,GAAE,CAM1B,UAAAQ,CAAWR,IACLX,KAAAI,eAAegB,cAAcT,GAAE,CAGrC,iBAAAU,CAAkBV,IACZX,KAAAI,eAAegB,cAAcT,GAAE,CAGrC,mBAAAW,CAAoBX,IACdX,KAAAI,eAAegB,cAAcT,GAAI,KAAI,CAM3C,SAAAY,CAAUZ,IACJX,KAAAI,eAAeoB,aAAab,GAAE,CAMpC,QAAAc,GACMzB,KAAAc,OAAOY,QAAQ,CAACC,EAAGhB,KAAOX,KAAKI,eAAegB,cAAcT,IAAG,CAMrE,OAAAiB,GACM5B,KAAAc,OAAOY,QAAQ,CAACC,EAAGhB,KAAOX,KAAKI,eAAeoB,aAAab,IAAG,CAMpE,WAAAkB,CAAYlB,IACNX,KAAAI,eAAe0B,eAAenB,IAC9BX,KAAAc,OAAOiB,OAAOpB,GAAE,CAMtB,SAAAqB,GACChC,KAAKI,eAAeI,WACpBR,KAAKc,OAAOmB,OAAM,CAMnB,SAAAC,CAAUvB,IACF,OAAAX,KAAKI,eAAe+B,kBAAkBxB,GAAE,CAGhD,YAAAyB,CAAaC,KAEL,OAAA,IAAA,CAMR,gBAAAC,GACQ,OAAAtC,KAAKI,eAAekC,mBAAmBC,SAAA,CAM/C,UAAAC,GACC,OAAOC,MAAMC,KAAK1C,KAAKc,OAAO6B,OAAM,GA5HrC5C,cAFYF,cAEG,WAAgC,MAFzC,IAAM+C,aAAN/C,cAmIM,MAAAgD,gBAAkB,IAAMD,aAAatC"}