var __defProp=Object.defineProperty;var __defNormalProp=(obj,key,value)=>key in obj?__defProp(obj,key,{enumerable:true,configurable:true,writable:true,value:value}):obj[key]=value;var __publicField=(obj,key,value)=>__defNormalProp(obj,typeof key!=="symbol"?key+"":key,value);import{b as browser}from"./D-5FeuF0.js";import{l as log}from"./Cb2naUpm.js";import{p as protectedContexts}from"./D59oTG1g.js";import{UnifiedTimerManager}from"./z-nmOEXa.js";function contextNeedsIdleProtection(contextType){return protectedContexts.includes(contextType)}const _ExtensionMessaging=class _ExtensionMessaging{constructor(){__publicField(this,"messageQueue",new Map);__publicField(this,"processedResponses",new Map);__publicField(this,"isProcessing",false);__publicField(this,"retryCount",new Map);__publicField(this,"MAX_RETRIES",3);__publicField(this,"RETRY_DELAY",500);__publicField(this,"browserApi",null);__publicField(this,"contextId","");__publicField(this,"pendingRequests",new Map);__publicField(this,"timerManager",UnifiedTimerManager.getInstance());__publicField(this,"FIRE_AND_FORGET_MESSAGES",["clientReady","ui_context_initialized","ui_context_activity","ui_context_closing","SET_LOGIN_VERIFIED","USER_ACTIVITY","CLEAR_ALL_ENHANCED_ALERTS","CLEAR_NOTIFICATION","CLEAR_NOTIFICATION_ENHANCED","IDLE_STATUS_CHANGED","LOCKDOWN_WARNING_ENHANCED","SECURITY_ALERT_ENHANCED","PLAY_URGENT_SOUND"])}static getInstance(){if(!_ExtensionMessaging.instance){_ExtensionMessaging.instance=new _ExtensionMessaging}return _ExtensionMessaging.instance}initialize(browserExtensionApi){this.browserApi=browserExtensionApi;this.contextId=this.getContextId();log.debug("[Messaging - initialize] Extension messaging initialized");this.processQueue();if(this.browserApi&&this.browserApi.runtime){this.browserApi.runtime.onMessage.addListener(this.handleIncomingMessage.bind(this))}this.timerManager.addInterval("messaging-cleanup",()=>this.cleanup(),6e4);this.timerManager.startInterval("messaging-cleanup")}async sendCleanupMessage(type,data={},source="unknown"){if(!this.browserApi)return;const message={type:type,...data,messageId:`cleanup-${source}-${Date.now()}`,timestamp:Date.now(),contextId:this.contextId,source:source,isCleanup:true};try{this.browserApi.runtime.sendMessage(message).catch(error=>{log.debug(`[Messaging - sendCleanupMessage] Cleanup message ${type} send failed (this is normal):`,false,error)})}catch(error){log.debug(`[Messaging - sendCleanupMessage] Cleanup message ${type} send error (this is normal):`,false,error)}}handleIncomingMessage(message,sender,sendResponse){if(!message||!message.responseId)return true;const{responseId:responseId,result:result,error:error}=message;const pendingRequest=this.pendingRequests.get(responseId);if(pendingRequest){if(error){pendingRequest.reject(error)}else{pendingRequest.resolve(result)}this.pendingRequests.delete(responseId);this.processedResponses.set(responseId,{timestamp:Date.now(),result:error||result})}return true}async sendMessage(type,data={},options={}){const{priority:priority="normal",retryOnFail:retryOnFail=true,contextId:contextId=this.contextId,deduplicate:deduplicate=true,responseTimeout:responseTimeout=3e4,waitForResponse:waitForResponse=!this.FIRE_AND_FORGET_MESSAGES.includes(type)}=options;const messageId=`${type}:${contextId}:${Date.now().toString(36)}`;if(deduplicate){const exactMessageKey=`${type}:${JSON.stringify(data)}`;const recentResponse=this.processedResponses.get(exactMessageKey);if(recentResponse&&Date.now()-recentResponse.timestamp<5e3){log.debug("[Messaging - sendMessage] Using cached response for identical message:",false,{type:type});return Promise.resolve(recentResponse.result)}}if(!this.browserApi){log.warn("[Messaging - sendMessage] Browser extension API not available. Call initialize() first.");return Promise.reject(new Error("Browser extension API not available. Call initialize() first."))}const message={type:type,...data,messageId:messageId,timestamp:Date.now(),contextId:contextId};if(!waitForResponse){try{this.browserApi.runtime.sendMessage(message).catch(error=>{log.debug(`[Messaging - sendMessage] Error sending fire-and-forget message ${type}:`,false,error)});return Promise.resolve({success:true,noResponseRequired:true})}catch(error){log.debug(`[Messaging - sendMessage] Error sending fire-and-forget message ${type}:`,false,error);return Promise.resolve({success:true,noResponseRequired:true,sendFailed:true})}}return new Promise((resolve,reject)=>{this.pendingRequests.set(messageId,{resolve:resolve,reject:reject,timestamp:Date.now()});const timeoutId=setTimeout(()=>{if(this.pendingRequests.has(messageId)){this.pendingRequests.delete(messageId);reject(new Error(`Message ${type} timed out after ${responseTimeout}ms`))}},responseTimeout);const queueKey=priority;if(!this.messageQueue.has(queueKey)){this.messageQueue.set(queueKey,[])}this.messageQueue.get(queueKey).push({message:message,retryOnFail:retryOnFail,retryCount:0,timeoutId:timeoutId});if(!this.isProcessing){this.processQueue()}})}async processQueue(){if(this.isProcessing||!this.browserApi)return;this.isProcessing=true;const priorities=["high","normal","low"];try{for(const priority of priorities){const queue=this.messageQueue.get(priority)||[];while(queue.length>0){const item=queue.shift();try{await this.browserApi.runtime.sendMessage(item.message).catch(error=>{log.debug("[Messaging - processQueue] Error sending message:",false,error);if(item.retryOnFail&&item.retryCount<this.MAX_RETRIES){item.retryCount++;queue.push(item);log.debug("[Messaging - processQueue] Retrying message:",false,{type:item.message.type,attempt:item.retryCount})}else{const pendingRequest=this.pendingRequests.get(item.message.messageId);if(pendingRequest){pendingRequest.reject(error);this.pendingRequests.delete(item.message.messageId);clearTimeout(item.timeoutId)}}})}catch(error){if(item.retryOnFail&&item.retryCount<this.MAX_RETRIES){item.retryCount++;queue.push(item);await new Promise(resolve=>setTimeout(resolve,this.RETRY_DELAY))}else{log.warn(`[Messaging - processQueue] Failed to send message (${item.message.type}) after ${item.retryCount} retries:`,error);const pendingRequest=this.pendingRequests.get(item.message.messageId);if(pendingRequest){pendingRequest.reject(error);this.pendingRequests.delete(item.message.messageId);clearTimeout(item.timeoutId)}}}await new Promise(resolve=>setTimeout(resolve,10))}}}finally{this.isProcessing=false;for(const queue of this.messageQueue.values()){if(queue.length>0){setTimeout(()=>this.processQueue(),0);break}}}}cleanup(){const now=Date.now();for(const[messageId,request]of this.pendingRequests.entries()){if(now-request.timestamp>6e4){request.reject(new Error("Request timed out"));this.pendingRequests.delete(messageId)}}for(const[messageId,response]of this.processedResponses.entries()){if(now-response.timestamp>3e5){this.processedResponses.delete(messageId)}}}getContextId(){return this.contextId}isInitialized(){return this.browserApi!==null}triggerActivityDetection(){if(typeof window==="undefined")return;const handler=window.__yakklActivityHandler;if(handler){log.info("[Messaging - triggerActivityDetection] Manually triggering activity detection");handler()}else{log.warn("[Messaging - triggerActivityDetection] Activity handler not found - activity tracking may not be set up")}}async registerUiContext(contextType){if(!this.browserApi)return;const contextId=this.contextId;await this.sendMessage("ui_context_initialized",{contextId:contextId,contextType:contextType,timestamp:Date.now()},{priority:"high",retryOnFail:true,deduplicate:false});if(typeof window!=="undefined"){try{window.addEventListener("beforeunload",()=>{if(this.browserApi&&this.browserApi.runtime){try{this.browserApi.runtime.sendMessage({type:"ui_context_closing",contextId:contextId})}catch(error){}}})}catch(error){console.warn(`[${contextId}] Failed to add unload handler:`,error)}}log.debug(`[Messaging - registerUiContext] UI context registered: ${contextId} (${contextType})`)}async sendActivityUpdate(){if(!this.browserApi)return;const contextType=this.getContextType();if(!contextNeedsIdleProtection(contextType)){return}try{await this.sendMessage("ui_context_activity",{contextId:this.contextId,contextType:contextType,timestamp:Date.now()},{priority:"high",retryOnFail:true,deduplicate:false});log.debug("[Messaging - sendActivityUpdate] Activity update sent successfully")}catch(error){log.warn("[Messaging - sendActivityUpdate] Failed to send activity update:",false,error)}}async setLoginVerified(verified,contextType){if(!this.browserApi){log.warn(`[Messaging - setLoginVerified] ‚ùå CANNOT SET LOGIN VERIFIED:`,false,{isBrowser:browser,hasBrowserApi:!!this.browserApi,verified:verified,contextType:contextType});return}const actualContextType=contextType||this.getContextType();log.info(`[Messaging - setLoginVerified] üîê LOGIN VERIFICATION REQUEST:`,false,{verified:verified,providedContextType:contextType,actualContextType:actualContextType,contextId:this.contextId,isProtectedContext:contextNeedsIdleProtection(actualContextType),protectedContexts:protectedContexts});if(!contextNeedsIdleProtection(actualContextType)){log.warn(`[Messaging - setLoginVerified] ‚ùå SKIPPING - not a protected context:`,false,{contextType:actualContextType,protectedContexts:protectedContexts,reason:"Context type not in protected contexts list"});return}const messageData={verified:verified,contextId:this.contextId,contextType:actualContextType};log.info(`[Messaging - setLoginVerified] üì§ SENDING SET_LOGIN_VERIFIED message:`,false,messageData);try{await this.sendMessage("SET_LOGIN_VERIFIED",messageData,{priority:"high",retryOnFail:true,deduplicate:false});log.info(`[Messaging - setLoginVerified] ‚úÖ SET_LOGIN_VERIFIED sent successfully:`,false,{verified:verified,contextId:this.contextId,contextType:actualContextType})}catch(error){log.error(`[Messaging - setLoginVerified] ‚ùå ERROR sending SET_LOGIN_VERIFIED:`,false,{error:error,messageData:messageData,contextId:this.contextId});throw error}log.info(`[Messaging - setLoginVerified] üéâ Login ${verified?"verified":"unverified"} for protected context: ${this.contextId}`)}getContextType(){try{if(!browser||typeof window==="undefined")return"unknown";const pathname=window.location.pathname;const href=window.location.href;if(pathname.includes("sidepanel")||href.includes("sidepanel")){return"sidepanel"}else if(pathname.includes("index.html")||href.includes("index.html")||pathname==="/"||pathname===""){return"popup-wallet"}else if(pathname.includes("dapp/popups")||href.includes("dapp/popups")){return"popup-dapp"}else if(pathname.includes("options")||href.includes("options")){return"options"}else{return"popup-wallet"}}catch(error){return"unknown"}}setupActivityTracking(){if(typeof window==="undefined")return;const contextType=this.getContextType();if(!contextNeedsIdleProtection(contextType)){log.info(`[Messaging - setupActivityTracking] Skipping activity tracking setup for non-protected context: ${contextType}`);return}if(window.__yakklActivityTrackingSetup){log.info("[Messaging - setupActivityTracking] Activity tracking already set up, skipping duplicate setup");return}log.info(`[Messaging - setupActivityTracking] Setting up activity tracking for protected context: ${contextType}`);const activityEvents=["mousedown","mousemove","keydown","scroll","touchstart","focus","click"];let lastActivity=Date.now();const ACTIVITY_THROTTLE=2e3;const activityHandler=()=>{const now=Date.now();if(now-lastActivity>ACTIVITY_THROTTLE){lastActivity=now;log.debug("[Messaging - setupActivityTracking] User activity detected, sending activity update");this.sendActivityUpdate().catch(error=>{log.debug("[Messaging - setupActivityTracking] Failed to send activity update:",false,error)})}};activityEvents.forEach(event=>{window.addEventListener(event,activityHandler,{passive:true,capture:false})});window.__yakklActivityTrackingSetup=true;window.__yakklActivityHandler=activityHandler;window.__yakklActivityEvents=activityEvents;window.addEventListener("beforeunload",()=>{activityEvents.forEach(event=>{window.removeEventListener(event,activityHandler)});window.__yakklActivityTrackingSetup=false});log.info("[Messaging - setupActivityTracking] Activity tracking set up successfully for protected context:",false,{contextId:this.contextId,contextType:contextType,eventsTracked:activityEvents.length})}};__publicField(_ExtensionMessaging,"instance");let ExtensionMessaging=_ExtensionMessaging;const messagingService=ExtensionMessaging.getInstance();function determineBestContextType(){try{if(typeof window==="undefined")return"unknown";const pathname=window.location.pathname;const href=window.location.href;if(pathname.includes("sidepanel")||href.includes("sidepanel")){return"sidepanel"}else if(pathname.includes("index.html")||href.includes("index.html")||pathname==="/"||pathname===""){return"popup-wallet"}else if(pathname.includes("dapp/popups")||href.includes("dapp/popups")){return"popup-dapp"}else if(pathname.includes("options")||href.includes("options")){return"options"}else{return"popup-wallet"}}catch(error){return"unknown"}}async function initializeUiContext(browserExtensionApi,contextType){messagingService.initialize(browserExtensionApi);const actualContextType=contextType||determineBestContextType();await messagingService.registerUiContext(actualContextType);if(contextNeedsIdleProtection(actualContextType)){log.info(`[Messaging - initializeUiContext] Setting up activity tracking for protected context: ${actualContextType}`);messagingService.setupActivityTracking()}else{log.info(`[Messaging - initializeUiContext] Skipping activity tracking for non-protected context: ${actualContextType}`)}}async function startActivityTracking(contextType){const actualContextType=contextType||determineBestContextType();log.info(`[Messaging - startActivityTracking] üöÄ STARTING ACTIVITY TRACKING:`,false,{providedContextType:contextType,actualContextType:actualContextType,isProtectedContext:contextNeedsIdleProtection(actualContextType),expectedProtectedTypes:protectedContexts,isBrowser:browser,messagingServiceExists:!!messagingService});if(!contextNeedsIdleProtection(actualContextType)){log.warn(`[Messaging - startActivityTracking] ‚ùå SKIPPING - not a protected context:`,false,{contextType:actualContextType,protectedContexts:protectedContexts,reason:"Context type not in protected contexts list"});return}log.info(`[Messaging - startActivityTracking] üîê Setting login verified for protected context: ${actualContextType}`);try{await messagingService.setLoginVerified(true,actualContextType);log.info(`[Messaging - startActivityTracking] ‚úÖ Login verification message sent successfully`)}catch(error){log.error(`[Messaging - startActivityTracking] ‚ùå ERROR sending login verification:`,false,error);throw error}try{messagingService.setupActivityTracking();log.info(`[Messaging - startActivityTracking] ‚úÖ Activity tracking setup completed`)}catch(error){log.error(`[Messaging - startActivityTracking] ‚ùå ERROR setting up activity tracking:`,false,error)}log.info(`[Messaging - startActivityTracking] üéâ ACTIVITY TRACKING STARTED for protected context: ${actualContextType}`)}async function stopActivityTracking(){const contextType=determineBestContextType();if(!contextNeedsIdleProtection(contextType)){log.info(`[Messaging - stopActivityTracking] Skipping activity tracking stop for non-protected context: ${contextType}`);return}await messagingService.setLoginVerified(false);log.info(`[Messaging - stopActivityTracking] Activity tracking stopped for protected context: ${contextType}`)}export{messagingService as default,initializeUiContext,messagingService,startActivityTracking,stopActivityTracking};
//# sourceMappingURL=DT3ZCMgr.js.map
