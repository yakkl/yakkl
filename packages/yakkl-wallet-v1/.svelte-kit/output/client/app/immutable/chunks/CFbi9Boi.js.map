{"version":3,"file":"CFbi9Boi.js","sources":["../../../../../../../../node_modules/.pnpm/@ethersproject+base64@5.7.0/node_modules/@ethersproject/base64/lib.esm/base64.js","../../../../../../../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js","../../../../../../../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js","../../../../../../../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js","../../../../../../../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/namehash.js","../../../../../../../../node_modules/.pnpm/@ethersproject+constants@5.7.0/node_modules/@ethersproject/constants/lib.esm/addresses.js","../../../../../../../../node_modules/.pnpm/@ethersproject+constants@5.7.0/node_modules/@ethersproject/constants/lib.esm/bignumbers.js","../../../../../../../../node_modules/.pnpm/@ethersproject+constants@5.7.0/node_modules/@ethersproject/constants/lib.esm/hashes.js","../../../../../../../../node_modules/.pnpm/@ethersproject+transactions@5.7.0/node_modules/@ethersproject/transactions/lib.esm/_version.js","../../../../../../../../node_modules/.pnpm/@ethersproject+transactions@5.7.0/node_modules/@ethersproject/transactions/lib.esm/index.js","../../../../../../../../node_modules/.pnpm/@ethersproject+networks@5.7.1/node_modules/@ethersproject/networks/lib.esm/_version.js","../../../../../../../../node_modules/.pnpm/@ethersproject+networks@5.7.1/node_modules/@ethersproject/networks/lib.esm/index.js","../../../../../../../../node_modules/.pnpm/@ethersproject+basex@5.7.0/node_modules/@ethersproject/basex/lib.esm/index.js","../../../../../../../../node_modules/.pnpm/@ethersproject+sha2@5.7.0/node_modules/@ethersproject/sha2/lib.esm/sha2.js","../../../../../../../../node_modules/.pnpm/bech32@1.1.4/node_modules/bech32/index.js","../../../../../../../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/_version.js","../../../../../../../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/formatter.js","../../../../../../../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/base-provider.js","../../../../../../../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js","../../../../../../../../node_modules/.pnpm/alchemy-sdk@3.6.0_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10/node_modules/alchemy-sdk/dist/esm/alchemy-provider-0066b792.js"],"sourcesContent":["\"use strict\";\nimport { arrayify } from \"@ethersproject/bytes\";\nexport function decode(textData) {\n    textData = atob(textData);\n    const data = [];\n    for (let i = 0; i < textData.length; i++) {\n        data.push(textData.charCodeAt(i));\n    }\n    return arrayify(data);\n}\nexport function encode(data) {\n    data = arrayify(data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n//# sourceMappingURL=base64.js.map","/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n// https://github.com/behnammodi/polyfill/blob/master/array.polyfill.js\nfunction flat(array, depth) {\n    if (depth == null) {\n        depth = 1;\n    }\n    const result = [];\n    const forEach = result.forEach;\n    const flatDeep = function (arr, depth) {\n        forEach.call(arr, function (val) {\n            if (depth > 0 && Array.isArray(val)) {\n                flatDeep(val, depth - 1);\n            }\n            else {\n                result.push(val);\n            }\n        });\n    };\n    flatDeep(array, depth);\n    return result;\n}\nfunction fromEntries(array) {\n    const result = {};\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i];\n        result[value[0]] = value[1];\n    }\n    return result;\n}\nexport function decode_arithmetic(bytes) {\n    let pos = 0;\n    function u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\n    // decode the frequency table\n    let symbol_count = u16();\n    let total = 1;\n    let acc = [0, 1]; // first symbol has frequency 1\n    for (let i = 1; i < symbol_count; i++) {\n        acc.push(total += u16());\n    }\n    // skip the sized-payload that the last 3 symbols index into\n    let skip = u16();\n    let pos_payload = pos;\n    pos += skip;\n    let read_width = 0;\n    let read_buffer = 0;\n    function read_bit() {\n        if (read_width == 0) {\n            // this will read beyond end of buffer\n            // but (undefined|0) => zero pad\n            read_buffer = (read_buffer << 8) | bytes[pos++];\n            read_width = 8;\n        }\n        return (read_buffer >> --read_width) & 1;\n    }\n    const N = 31;\n    const FULL = Math.pow(2, N);\n    const HALF = FULL >>> 1;\n    const QRTR = HALF >> 1;\n    const MASK = FULL - 1;\n    // fill register\n    let register = 0;\n    for (let i = 0; i < N; i++)\n        register = (register << 1) | read_bit();\n    let symbols = [];\n    let low = 0;\n    let range = FULL; // treat like a float\n    while (true) {\n        let value = Math.floor((((register - low + 1) * total) - 1) / range);\n        let start = 0;\n        let end = symbol_count;\n        while (end - start > 1) { // binary search\n            let mid = (start + end) >>> 1;\n            if (value < acc[mid]) {\n                end = mid;\n            }\n            else {\n                start = mid;\n            }\n        }\n        if (start == 0)\n            break; // first symbol is end mark\n        symbols.push(start);\n        let a = low + Math.floor(range * acc[start] / total);\n        let b = low + Math.floor(range * acc[start + 1] / total) - 1;\n        while (((a ^ b) & HALF) == 0) {\n            register = (register << 1) & MASK | read_bit();\n            a = (a << 1) & MASK;\n            b = (b << 1) & MASK | 1;\n        }\n        while (a & ~b & QRTR) {\n            register = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\n            a = (a << 1) ^ HALF;\n            b = ((b ^ HALF) << 1) | HALF | 1;\n        }\n        low = a;\n        range = 1 + b - a;\n    }\n    let offset = symbol_count - 4;\n    return symbols.map(x => {\n        switch (x - offset) {\n            case 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\n            case 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\n            case 1: return offset + bytes[pos_payload++];\n            default: return x - 1;\n        }\n    });\n}\n// returns an iterator which returns the next symbol\nexport function read_payload(v) {\n    let pos = 0;\n    return () => v[pos++];\n}\nexport function read_compressed_payload(bytes) {\n    return read_payload(decode_arithmetic(bytes));\n}\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nexport function signed(i) {\n    return (i & 1) ? (~i >> 1) : (i >> 1);\n}\nfunction read_counts(n, next) {\n    let v = Array(n);\n    for (let i = 0; i < n; i++)\n        v[i] = 1 + next();\n    return v;\n}\nfunction read_ascending(n, next) {\n    let v = Array(n);\n    for (let i = 0, x = -1; i < n; i++)\n        v[i] = x += 1 + next();\n    return v;\n}\nfunction read_deltas(n, next) {\n    let v = Array(n);\n    for (let i = 0, x = 0; i < n; i++)\n        v[i] = x += signed(next());\n    return v;\n}\nexport function read_member_array(next, lookup) {\n    let v = read_ascending(next(), next);\n    let n = next();\n    let vX = read_ascending(n, next);\n    let vN = read_counts(n, next);\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < vN[i]; j++) {\n            v.push(vX[i] + j);\n        }\n    }\n    return lookup ? v.map(x => lookup[x]) : v;\n}\n// returns array of \n// [x, ys] => single replacement rule\n// [x, ys, n, dx, dx] => linear map\nexport function read_mapped_map(next) {\n    let ret = [];\n    while (true) {\n        let w = next();\n        if (w == 0)\n            break;\n        ret.push(read_linear_table(w, next));\n    }\n    while (true) {\n        let w = next() - 1;\n        if (w < 0)\n            break;\n        ret.push(read_replacement_table(w, next));\n    }\n    return fromEntries(flat(ret));\n}\nexport function read_zero_terminated_array(next) {\n    let v = [];\n    while (true) {\n        let i = next();\n        if (i == 0)\n            break;\n        v.push(i);\n    }\n    return v;\n}\nfunction read_transposed(n, w, next) {\n    let m = Array(n).fill(undefined).map(() => []);\n    for (let i = 0; i < w; i++) {\n        read_deltas(n, next).forEach((x, j) => m[j].push(x));\n    }\n    return m;\n}\nfunction read_linear_table(w, next) {\n    let dx = 1 + next();\n    let dy = next();\n    let vN = read_zero_terminated_array(next);\n    let m = read_transposed(vN.length, 1 + w, next);\n    return flat(m.map((v, i) => {\n        const x = v[0], ys = v.slice(1);\n        //let [x, ...ys] = v;\n        //return Array(vN[i]).fill().map((_, j) => {\n        return Array(vN[i]).fill(undefined).map((_, j) => {\n            let j_dy = j * dy;\n            return [x + j * dx, ys.map(y => y + j_dy)];\n        });\n    }));\n}\nfunction read_replacement_table(w, next) {\n    let n = 1 + next();\n    let m = read_transposed(n, 1 + w, next);\n    return m.map(v => [v[0], v.slice(1)]);\n}\nexport function read_emoji_trie(next) {\n    let sorted = read_member_array(next).sort((a, b) => a - b);\n    return read();\n    function read() {\n        let branches = [];\n        while (true) {\n            let keys = read_member_array(next, sorted);\n            if (keys.length == 0)\n                break;\n            branches.push({ set: new Set(keys), node: read() });\n        }\n        branches.sort((a, b) => b.set.size - a.set.size); // sort by likelihood\n        let temp = next();\n        let valid = temp % 3;\n        temp = (temp / 3) | 0;\n        let fe0f = !!(temp & 1);\n        temp >>= 1;\n        let save = temp == 1;\n        let check = temp == 2;\n        return { branches, valid, fe0f, save, check };\n    }\n}\n//# sourceMappingURL=decoder.js.map","/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\nimport { decode } from \"@ethersproject/base64\";\nimport { read_compressed_payload } from './decoder.js';\nexport function getData() {\n    return read_compressed_payload(decode('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'));\n}\n//# sourceMappingURL=include.js.map","/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\nimport { toUtf8CodePoints } from \"@ethersproject/strings\";\nimport { getData } from './include.js';\nconst r = getData();\nimport { read_member_array, read_mapped_map, read_emoji_trie } from './decoder.js';\n// @TODO: This should be lazily loaded\nconst VALID = new Set(read_member_array(r));\nconst IGNORED = new Set(read_member_array(r));\nconst MAPPED = read_mapped_map(r);\nconst EMOJI_ROOT = read_emoji_trie(r);\n//const NFC_CHECK = new Set(read_member_array(r, Array.from(VALID.values()).sort((a, b) => a - b)));\n//const STOP = 0x2E;\nconst HYPHEN = 0x2D;\nconst UNDERSCORE = 0x5F;\nfunction explode_cp(name) {\n    return toUtf8CodePoints(name);\n}\nfunction filter_fe0f(cps) {\n    return cps.filter(cp => cp != 0xFE0F);\n}\nexport function ens_normalize_post_check(name) {\n    for (let label of name.split('.')) {\n        let cps = explode_cp(label);\n        try {\n            for (let i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) {\n                if (cps[i] !== UNDERSCORE) {\n                    throw new Error(`underscore only allowed at start`);\n                }\n            }\n            if (cps.length >= 4 && cps.every(cp => cp < 0x80) && cps[2] === HYPHEN && cps[3] === HYPHEN) {\n                throw new Error(`invalid label extension`);\n            }\n        }\n        catch (err) {\n            throw new Error(`Invalid label \"${label}\": ${err.message}`);\n        }\n    }\n    return name;\n}\nexport function ens_normalize(name) {\n    return ens_normalize_post_check(normalize(name, filter_fe0f));\n}\nfunction normalize(name, emoji_filter) {\n    let input = explode_cp(name).reverse(); // flip for pop\n    let output = [];\n    while (input.length) {\n        let emoji = consume_emoji_reversed(input);\n        if (emoji) {\n            output.push(...emoji_filter(emoji));\n            continue;\n        }\n        let cp = input.pop();\n        if (VALID.has(cp)) {\n            output.push(cp);\n            continue;\n        }\n        if (IGNORED.has(cp)) {\n            continue;\n        }\n        let cps = MAPPED[cp];\n        if (cps) {\n            output.push(...cps);\n            continue;\n        }\n        throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);\n    }\n    return ens_normalize_post_check(nfc(String.fromCodePoint(...output)));\n}\nfunction nfc(s) {\n    return s.normalize('NFC');\n}\nfunction consume_emoji_reversed(cps, eaten) {\n    var _a;\n    let node = EMOJI_ROOT;\n    let emoji;\n    let saved;\n    let stack = [];\n    let pos = cps.length;\n    if (eaten)\n        eaten.length = 0; // clear input buffer (if needed)\n    while (pos) {\n        let cp = cps[--pos];\n        node = (_a = node.branches.find(x => x.set.has(cp))) === null || _a === void 0 ? void 0 : _a.node;\n        if (!node)\n            break;\n        if (node.save) { // remember\n            saved = cp;\n        }\n        else if (node.check) { // check exclusion\n            if (cp === saved)\n                break;\n        }\n        stack.push(cp);\n        if (node.fe0f) {\n            stack.push(0xFE0F);\n            if (pos > 0 && cps[pos - 1] == 0xFE0F)\n                pos--; // consume optional FE0F\n        }\n        if (node.valid) { // this is a valid emoji (so far)\n            emoji = stack.slice(); // copy stack\n            if (node.valid == 2)\n                emoji.splice(1, 1); // delete FE0F at position 1 (RGI ZWJ don't follow spec!)\n            if (eaten)\n                eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)\n            cps.length = pos; // truncate\n        }\n    }\n    return emoji;\n}\n//# sourceMappingURL=lib.js.map","import { concat, hexlify } from \"@ethersproject/bytes\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { ens_normalize } from \"./ens-normalize/lib\";\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n    if (comp.length === 0) {\n        throw new Error(\"invalid ENS name; empty component\");\n    }\n    return comp;\n}\nfunction ensNameSplit(name) {\n    const bytes = toUtf8Bytes(ens_normalize(name));\n    const comps = [];\n    if (name.length === 0) {\n        return comps;\n    }\n    let last = 0;\n    for (let i = 0; i < bytes.length; i++) {\n        const d = bytes[i];\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n    // There was a stray separator at the end of the name\n    if (last >= bytes.length) {\n        throw new Error(\"invalid ENS name; empty component\");\n    }\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\nexport function ensNormalize(name) {\n    return ensNameSplit(name).map((comp) => toUtf8String(comp)).join(\".\");\n}\nexport function isValidName(name) {\n    try {\n        return (ensNameSplit(name).length !== 0);\n    }\n    catch (error) { }\n    return false;\n}\nexport function namehash(name) {\n    /* istanbul ignore if */\n    if (typeof (name) !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n    let result = Zeros;\n    const comps = ensNameSplit(name);\n    while (comps.length) {\n        result = keccak256(concat([result, keccak256(comps.pop())]));\n    }\n    return hexlify(result);\n}\nexport function dnsEncode(name) {\n    return hexlify(concat(ensNameSplit(name).map((comp) => {\n        // DNS does not allow components over 63 bytes in length\n        if (comp.length > 63) {\n            throw new Error(\"invalid DNS encoded entry; length exceeds 63 bytes\");\n        }\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n}\n//# sourceMappingURL=namehash.js.map","export const AddressZero = \"0x0000000000000000000000000000000000000000\";\n//# sourceMappingURL=addresses.js.map","import { BigNumber } from \"@ethersproject/bignumber\";\nconst NegativeOne = ( /*#__PURE__*/BigNumber.from(-1));\nconst Zero = ( /*#__PURE__*/BigNumber.from(0));\nconst One = ( /*#__PURE__*/BigNumber.from(1));\nconst Two = ( /*#__PURE__*/BigNumber.from(2));\nconst WeiPerEther = ( /*#__PURE__*/BigNumber.from(\"1000000000000000000\"));\nconst MaxUint256 = ( /*#__PURE__*/BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\nconst MinInt256 = ( /*#__PURE__*/BigNumber.from(\"-0x8000000000000000000000000000000000000000000000000000000000000000\"));\nconst MaxInt256 = ( /*#__PURE__*/BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\nexport { NegativeOne, Zero, One, Two, WeiPerEther, MaxUint256, MinInt256, MaxInt256, };\n//# sourceMappingURL=bignumbers.js.map","export const HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n//# sourceMappingURL=hashes.js.map","export const version = \"transactions/5.7.0\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, hexConcat, hexDataLength, hexDataSlice, hexlify, hexZeroPad, isBytesLike, splitSignature, stripZeros, } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { checkProperties } from \"@ethersproject/properties\";\nimport * as RLP from \"@ethersproject/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport var TransactionTypes;\n(function (TransactionTypes) {\n    TransactionTypes[TransactionTypes[\"legacy\"] = 0] = \"legacy\";\n    TransactionTypes[TransactionTypes[\"eip2930\"] = 1] = \"eip2930\";\n    TransactionTypes[TransactionTypes[\"eip1559\"] = 2] = \"eip1559\";\n})(TransactionTypes || (TransactionTypes = {}));\n;\n///////////////////////////////\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return getAddress(value);\n}\nfunction handleNumber(value) {\n    if (value === \"0x\") {\n        return Zero;\n    }\n    return BigNumber.from(value);\n}\n// Legacy Transaction Fields\nconst transactionFields = [\n    { name: \"nonce\", maxLength: 32, numeric: true },\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\n    { name: \"to\", length: 20 },\n    { name: \"value\", maxLength: 32, numeric: true },\n    { name: \"data\" },\n];\nconst allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, type: true, value: true\n};\nexport function computeAddress(key) {\n    const publicKey = computePublicKey(key);\n    return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\nexport function recoverAddress(digest, signature) {\n    return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\nfunction formatNumber(value, name) {\n    const result = stripZeros(BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\n    }\n    return result;\n}\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: getAddress(addr),\n        storageKeys: (storageKeys || []).map((storageKey, index) => {\n            if (hexDataLength(storageKey) !== 32) {\n                logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${addr}:${index}]`, storageKey);\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\nexport function accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map((set, index) => {\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${index}]`, set);\n                }\n                return accessSetify(set[0], set[1]);\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    const result = Object.keys(value).map((addr) => {\n        const storageKeys = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\nfunction formatAccessList(value) {\n    return accessListify(value).map((set) => [set.address, set.storageKeys]);\n}\nfunction _serializeEip1559(transaction, signature) {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        const gasPrice = BigNumber.from(transaction.gasPrice);\n        const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice, maxFeePerGas\n            });\n        }\n    }\n    const fields = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to) : \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n    return hexConcat([\"0x02\", RLP.encode(fields)]);\n}\nfunction _serializeEip2930(transaction, signature) {\n    const fields = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to) : \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n    return hexConcat([\"0x01\", RLP.encode(fields)]);\n}\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction, signature) {\n    checkProperties(transaction, allowedTransactionKeys);\n    const raw = [];\n    transactionFields.forEach(function (fieldInfo) {\n        let value = transaction[fieldInfo.name] || ([]);\n        const options = {};\n        if (fieldInfo.numeric) {\n            options.hexPad = \"left\";\n        }\n        value = arrayify(hexlify(value, options));\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n        }\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = stripZeros(value);\n            if (value.length > fieldInfo.maxLength) {\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n            }\n        }\n        raw.push(hexlify(value));\n    });\n    let chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n        if (typeof (chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n    }\n    else if (signature && !isBytesLike(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push(hexlify(chainId)); // @TODO: hexValue?\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n    // Requesting an unsigned transaction\n    if (!signature) {\n        return RLP.encode(raw);\n    }\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    const sig = splitSignature(signature);\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    let v = 27 + sig.recoveryParam;\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n            logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    }\n    else if (sig.v !== v) {\n        logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n    raw.push(hexlify(v));\n    raw.push(stripZeros(arrayify(sig.r)));\n    raw.push(stripZeros(arrayify(sig.s)));\n    return RLP.encode(raw);\n}\nexport function serialize(transaction, signature) {\n    // Legacy and EIP-155 Transactions\n    if (transaction.type == null || transaction.type === 0) {\n        if (transaction.accessList != null) {\n            logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n        }\n        return _serialize(transaction, signature);\n    }\n    // Typed Transactions (EIP-2718)\n    switch (transaction.type) {\n        case 1:\n            return _serializeEip2930(transaction, signature);\n        case 2:\n            return _serializeEip1559(transaction, signature);\n        default:\n            break;\n    }\n    return logger.throwError(`unsupported transaction type: ${transaction.type}`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\nfunction _parseEipSignature(tx, fields, serialize) {\n    try {\n        const recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) {\n            throw new Error(\"bad recid\");\n        }\n        tx.v = recid;\n    }\n    catch (error) {\n        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n    tx.r = hexZeroPad(fields[1], 32);\n    tx.s = hexZeroPad(fields[2], 32);\n    try {\n        const digest = keccak256(serialize(tx));\n        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\n    }\n    catch (error) { }\n}\nfunction _parseEip1559(payload) {\n    const transaction = RLP.decode(payload.slice(1));\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", hexlify(payload));\n    }\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx = {\n        type: 2,\n        chainId: handleNumber(transaction[0]).toNumber(),\n        nonce: handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas: maxPriorityFeePerGas,\n        maxFeePerGas: maxFeePerGas,\n        gasPrice: null,\n        gasLimit: handleNumber(transaction[4]),\n        to: handleAddress(transaction[5]),\n        value: handleNumber(transaction[6]),\n        data: transaction[7],\n        accessList: accessListify(transaction[8]),\n    };\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) {\n        return tx;\n    }\n    tx.hash = keccak256(payload);\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n    return tx;\n}\nfunction _parseEip2930(payload) {\n    const transaction = RLP.decode(payload.slice(1));\n    if (transaction.length !== 8 && transaction.length !== 11) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\n    }\n    const tx = {\n        type: 1,\n        chainId: handleNumber(transaction[0]).toNumber(),\n        nonce: handleNumber(transaction[1]).toNumber(),\n        gasPrice: handleNumber(transaction[2]),\n        gasLimit: handleNumber(transaction[3]),\n        to: handleAddress(transaction[4]),\n        value: handleNumber(transaction[5]),\n        data: transaction[6],\n        accessList: accessListify(transaction[7])\n    };\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) {\n        return tx;\n    }\n    tx.hash = keccak256(payload);\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n    return tx;\n}\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction) {\n    const transaction = RLP.decode(rawTransaction);\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n    const tx = {\n        nonce: handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to: handleAddress(transaction[3]),\n        value: handleNumber(transaction[4]),\n        data: transaction[5],\n        chainId: 0\n    };\n    // Legacy unsigned transaction\n    if (transaction.length === 6) {\n        return tx;\n    }\n    try {\n        tx.v = BigNumber.from(transaction[6]).toNumber();\n    }\n    catch (error) {\n        // @TODO: What makes snese to do? The v is too big\n        return tx;\n    }\n    tx.r = hexZeroPad(transaction[7], 32);\n    tx.s = hexZeroPad(transaction[8], 32);\n    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n    }\n    else {\n        // Signed Transaction\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) {\n            tx.chainId = 0;\n        }\n        let recoveryParam = tx.v - 27;\n        const raw = transaction.slice(0, 6);\n        if (tx.chainId !== 0) {\n            raw.push(hexlify(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n        const digest = keccak256(RLP.encode(raw));\n        try {\n            tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam: recoveryParam });\n        }\n        catch (error) { }\n        tx.hash = keccak256(rawTransaction);\n    }\n    tx.type = null;\n    return tx;\n}\nexport function parse(rawTransaction) {\n    const payload = arrayify(rawTransaction);\n    // Legacy and EIP-155 Transactions\n    if (payload[0] > 0x7f) {\n        return _parse(payload);\n    }\n    // Typed Transaction (EIP-2718)\n    switch (payload[0]) {\n        case 1:\n            return _parseEip2930(payload);\n        case 2:\n            return _parseEip1559(payload);\n        default:\n            break;\n    }\n    return logger.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n}\n//# sourceMappingURL=index.js.map","export const version = \"networks/5.7.1\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n;\nfunction isRenetworkable(value) {\n    return (value && typeof (value.renetwork) === \"function\");\n}\nfunction ethDefaultProvider(network) {\n    const func = function (providers, options) {\n        if (options == null) {\n            options = {};\n        }\n        const providerList = [];\n        if (providers.InfuraProvider && options.infura !== \"-\") {\n            try {\n                providerList.push(new providers.InfuraProvider(network, options.infura));\n            }\n            catch (error) { }\n        }\n        if (providers.EtherscanProvider && options.etherscan !== \"-\") {\n            try {\n                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n            }\n            catch (error) { }\n        }\n        if (providers.AlchemyProvider && options.alchemy !== \"-\") {\n            try {\n                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n            }\n            catch (error) { }\n        }\n        if (providers.PocketProvider && options.pocket !== \"-\") {\n            // These networks are currently faulty on Pocket as their\n            // network does not handle the Berlin hardfork, which is\n            // live on these ones.\n            // @TODO: This goes away once Pocket has upgraded their nodes\n            const skip = [\"goerli\", \"ropsten\", \"rinkeby\", \"sepolia\"];\n            try {\n                const provider = new providers.PocketProvider(network, options.pocket);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            }\n            catch (error) { }\n        }\n        if (providers.CloudflareProvider && options.cloudflare !== \"-\") {\n            try {\n                providerList.push(new providers.CloudflareProvider(network));\n            }\n            catch (error) { }\n        }\n        if (providers.AnkrProvider && options.ankr !== \"-\") {\n            try {\n                const skip = [\"ropsten\"];\n                const provider = new providers.AnkrProvider(network, options.ankr);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            }\n            catch (error) { }\n        }\n        if (providerList.length === 0) {\n            return null;\n        }\n        if (providers.FallbackProvider) {\n            let quorum = 1;\n            if (options.quorum != null) {\n                quorum = options.quorum;\n            }\n            else if (network === \"homestead\") {\n                quorum = 2;\n            }\n            return new providers.FallbackProvider(providerList, quorum);\n        }\n        return providerList[0];\n    };\n    func.renetwork = function (network) {\n        return ethDefaultProvider(network);\n    };\n    return func;\n}\nfunction etcDefaultProvider(url, network) {\n    const func = function (providers, options) {\n        if (providers.JsonRpcProvider) {\n            return new providers.JsonRpcProvider(url, network);\n        }\n        return null;\n    };\n    func.renetwork = function (network) {\n        return etcDefaultProvider(url, network);\n    };\n    return func;\n}\nconst homestead = {\n    chainId: 1,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"homestead\",\n    _defaultProvider: ethDefaultProvider(\"homestead\")\n};\nconst ropsten = {\n    chainId: 3,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"ropsten\",\n    _defaultProvider: ethDefaultProvider(\"ropsten\")\n};\nconst classicMordor = {\n    chainId: 63,\n    name: \"classicMordor\",\n    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n};\n// See: https://chainlist.org\nconst networks = {\n    unspecified: { chainId: 0, name: \"unspecified\" },\n    homestead: homestead,\n    mainnet: homestead,\n    morden: { chainId: 2, name: \"morden\" },\n    ropsten: ropsten,\n    testnet: ropsten,\n    rinkeby: {\n        chainId: 4,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"rinkeby\",\n        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n    },\n    kovan: {\n        chainId: 42,\n        name: \"kovan\",\n        _defaultProvider: ethDefaultProvider(\"kovan\")\n    },\n    goerli: {\n        chainId: 5,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"goerli\",\n        _defaultProvider: ethDefaultProvider(\"goerli\")\n    },\n    kintsugi: { chainId: 1337702, name: \"kintsugi\" },\n    sepolia: {\n        chainId: 11155111,\n        name: \"sepolia\",\n        _defaultProvider: ethDefaultProvider(\"sepolia\")\n    },\n    // ETC (See: #351)\n    classic: {\n        chainId: 61,\n        name: \"classic\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/etc\", \"classic\")\n    },\n    classicMorden: { chainId: 62, name: \"classicMorden\" },\n    classicMordor: classicMordor,\n    classicTestnet: classicMordor,\n    classicKotti: {\n        chainId: 6,\n        name: \"classicKotti\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/kotti\", \"classicKotti\")\n    },\n    xdai: { chainId: 100, name: \"xdai\" },\n    matic: {\n        chainId: 137,\n        name: \"matic\",\n        _defaultProvider: ethDefaultProvider(\"matic\")\n    },\n    maticmum: { chainId: 80001, name: \"maticmum\" },\n    optimism: {\n        chainId: 10,\n        name: \"optimism\",\n        _defaultProvider: ethDefaultProvider(\"optimism\")\n    },\n    \"optimism-kovan\": { chainId: 69, name: \"optimism-kovan\" },\n    \"optimism-goerli\": { chainId: 420, name: \"optimism-goerli\" },\n    arbitrum: { chainId: 42161, name: \"arbitrum\" },\n    \"arbitrum-rinkeby\": { chainId: 421611, name: \"arbitrum-rinkeby\" },\n    \"arbitrum-goerli\": { chainId: 421613, name: \"arbitrum-goerli\" },\n    bnb: { chainId: 56, name: \"bnb\" },\n    bnbt: { chainId: 97, name: \"bnbt\" },\n};\n/**\n *  getNetwork\n *\n *  Converts a named common networks or chain ID (network ID) to a Network\n *  and verifies a network is a valid Network..\n */\nexport function getNetwork(network) {\n    // No network (null)\n    if (network == null) {\n        return null;\n    }\n    if (typeof (network) === \"number\") {\n        for (const name in networks) {\n            const standard = networks[name];\n            if (standard.chainId === network) {\n                return {\n                    name: standard.name,\n                    chainId: standard.chainId,\n                    ensAddress: (standard.ensAddress || null),\n                    _defaultProvider: (standard._defaultProvider || null)\n                };\n            }\n        }\n        return {\n            chainId: network,\n            name: \"unknown\"\n        };\n    }\n    if (typeof (network) === \"string\") {\n        const standard = networks[network];\n        if (standard == null) {\n            return null;\n        }\n        return {\n            name: standard.name,\n            chainId: standard.chainId,\n            ensAddress: standard.ensAddress,\n            _defaultProvider: (standard._defaultProvider || null)\n        };\n    }\n    const standard = networks[network.name];\n    // Not a standard network; check that it is a valid network in general\n    if (!standard) {\n        if (typeof (network.chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n        }\n        return network;\n    }\n    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n        logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n    }\n    // @TODO: In the next major version add an attach function to a defaultProvider\n    // class and move the _defaultProvider internal to this file (extend Network)\n    let defaultProvider = network._defaultProvider || null;\n    if (defaultProvider == null && standard._defaultProvider) {\n        if (isRenetworkable(standard._defaultProvider)) {\n            defaultProvider = standard._defaultProvider.renetwork(network);\n        }\n        else {\n            defaultProvider = standard._defaultProvider;\n        }\n    }\n    // Standard Network (allow overriding the ENS address)\n    return {\n        name: network.name,\n        chainId: standard.chainId,\n        ensAddress: (network.ensAddress || standard.ensAddress || null),\n        _defaultProvider: defaultProvider\n    };\n}\n//# sourceMappingURL=index.js.map","/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\nimport { arrayify } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nexport class BaseX {\n    constructor(alphabet) {\n        defineReadOnly(this, \"alphabet\", alphabet);\n        defineReadOnly(this, \"base\", alphabet.length);\n        defineReadOnly(this, \"_alphabetMap\", {});\n        defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n    encode(value) {\n        let source = arrayify(value);\n        if (source.length === 0) {\n            return \"\";\n        }\n        let digits = [0];\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n        let string = \"\";\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n        return string;\n    }\n    decode(value) {\n        if (typeof (value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        let bytes = [];\n        if (value.length === 0) {\n            return new Uint8Array(bytes);\n        }\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0);\n        }\n        return arrayify(new Uint8Array(bytes.reverse()));\n    }\n}\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\nexport { Base32, Base58 };\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n//# sourceMappingURL=index.js.map","\"use strict\";\nimport hash from \"hash.js\";\n//const _ripemd160 = _hash.ripemd160;\nimport { arrayify } from \"@ethersproject/bytes\";\nimport { SupportedAlgorithm } from \"./types\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport function ripemd160(data) {\n    return \"0x\" + (hash.ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\nexport function sha256(data) {\n    return \"0x\" + (hash.sha256().update(arrayify(data)).digest(\"hex\"));\n}\nexport function sha512(data) {\n    return \"0x\" + (hash.sha512().update(arrayify(data)).digest(\"hex\"));\n}\nexport function computeHmac(algorithm, key, data) {\n    if (!SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n    return \"0x\" + hash.hmac(hash[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n//# sourceMappingURL=sha2.js.map","'use strict'\nvar ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'\n\n// pre-compute lookup table\nvar ALPHABET_MAP = {}\nfor (var z = 0; z < ALPHABET.length; z++) {\n  var x = ALPHABET.charAt(z)\n\n  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')\n  ALPHABET_MAP[x] = z\n}\n\nfunction polymodStep (pre) {\n  var b = pre >> 25\n  return ((pre & 0x1FFFFFF) << 5) ^\n    (-((b >> 0) & 1) & 0x3b6a57b2) ^\n    (-((b >> 1) & 1) & 0x26508e6d) ^\n    (-((b >> 2) & 1) & 0x1ea119fa) ^\n    (-((b >> 3) & 1) & 0x3d4233dd) ^\n    (-((b >> 4) & 1) & 0x2a1462b3)\n}\n\nfunction prefixChk (prefix) {\n  var chk = 1\n  for (var i = 0; i < prefix.length; ++i) {\n    var c = prefix.charCodeAt(i)\n    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'\n\n    chk = polymodStep(chk) ^ (c >> 5)\n  }\n  chk = polymodStep(chk)\n\n  for (i = 0; i < prefix.length; ++i) {\n    var v = prefix.charCodeAt(i)\n    chk = polymodStep(chk) ^ (v & 0x1f)\n  }\n  return chk\n}\n\nfunction encode (prefix, words, LIMIT) {\n  LIMIT = LIMIT || 90\n  if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')\n\n  prefix = prefix.toLowerCase()\n\n  // determine chk mod\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') throw new Error(chk)\n\n  var result = prefix + '1'\n  for (var i = 0; i < words.length; ++i) {\n    var x = words[i]\n    if ((x >> 5) !== 0) throw new Error('Non 5-bit word')\n\n    chk = polymodStep(chk) ^ x\n    result += ALPHABET.charAt(x)\n  }\n\n  for (i = 0; i < 6; ++i) {\n    chk = polymodStep(chk)\n  }\n  chk ^= 1\n\n  for (i = 0; i < 6; ++i) {\n    var v = (chk >> ((5 - i) * 5)) & 0x1f\n    result += ALPHABET.charAt(v)\n  }\n\n  return result\n}\n\nfunction __decode (str, LIMIT) {\n  LIMIT = LIMIT || 90\n  if (str.length < 8) return str + ' too short'\n  if (str.length > LIMIT) return 'Exceeds length limit'\n\n  // don't allow mixed case\n  var lowered = str.toLowerCase()\n  var uppered = str.toUpperCase()\n  if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str\n  str = lowered\n\n  var split = str.lastIndexOf('1')\n  if (split === -1) return 'No separator character for ' + str\n  if (split === 0) return 'Missing prefix for ' + str\n\n  var prefix = str.slice(0, split)\n  var wordChars = str.slice(split + 1)\n  if (wordChars.length < 6) return 'Data too short'\n\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') return chk\n\n  var words = []\n  for (var i = 0; i < wordChars.length; ++i) {\n    var c = wordChars.charAt(i)\n    var v = ALPHABET_MAP[c]\n    if (v === undefined) return 'Unknown character ' + c\n    chk = polymodStep(chk) ^ v\n\n    // not in the checksum?\n    if (i + 6 >= wordChars.length) continue\n    words.push(v)\n  }\n\n  if (chk !== 1) return 'Invalid checksum for ' + str\n  return { prefix: prefix, words: words }\n}\n\nfunction decodeUnsafe () {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n}\n\nfunction decode (str) {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n\n  throw new Error(res)\n}\n\nfunction convert (data, inBits, outBits, pad) {\n  var value = 0\n  var bits = 0\n  var maxV = (1 << outBits) - 1\n\n  var result = []\n  for (var i = 0; i < data.length; ++i) {\n    value = (value << inBits) | data[i]\n    bits += inBits\n\n    while (bits >= outBits) {\n      bits -= outBits\n      result.push((value >> bits) & maxV)\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push((value << (outBits - bits)) & maxV)\n    }\n  } else {\n    if (bits >= inBits) return 'Excess padding'\n    if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'\n  }\n\n  return result\n}\n\nfunction toWordsUnsafe (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n}\n\nfunction toWords (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nfunction fromWordsUnsafe (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n}\n\nfunction fromWords (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nmodule.exports = {\n  decodeUnsafe: decodeUnsafe,\n  decode: decode,\n  encode: encode,\n  toWordsUnsafe: toWordsUnsafe,\n  toWords: toWords,\n  fromWordsUnsafe: fromWordsUnsafe,\n  fromWords: fromWords\n}\n","export const version = \"providers/5.7.2\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexDataLength, hexDataSlice, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { accessListify, parse as parseTransaction } from \"@ethersproject/transactions\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport class Formatter {\n    constructor() {\n        this.formats = this.getDefaultFormats();\n    }\n    getDefaultFormats() {\n        const formats = ({});\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n        const strictData = (v) => { return this.data(v, true); };\n        formats.transaction = {\n            hash: hash,\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n            confirmations: Formatter.allowNull(number, null),\n            from: address,\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n            creates: Formatter.allowNull(address, null),\n            raw: Formatter.allowNull(data),\n        };\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n        formats.block = {\n            hash: Formatter.allowNull(hash),\n            parentHash: hash,\n            number: number,\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n            miner: Formatter.allowNull(address),\n            extraData: data,\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n            topics: Formatter.arrayOf(hash),\n            transactionHash: hash,\n            logIndex: number,\n        };\n        return formats;\n    }\n    accessList(accessList) {\n        return accessListify(accessList || []);\n    }\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number) {\n        if (number === \"0x\") {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    type(number) {\n        if (number === \"0x\" || number == null) {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    // Strict! Used on input.\n    bigNumber(value) {\n        return BigNumber.from(value);\n    }\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value) {\n        if (typeof (value) === \"boolean\") {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") {\n                return true;\n            }\n            if (value === \"false\") {\n                return false;\n            }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n    hex(value, strict) {\n        if (typeof (value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") {\n                value = \"0x\" + value;\n            }\n            if (isHexString(value)) {\n                return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n    data(value, strict) {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n    // Requires an address\n    // Strict! Used on input.\n    address(value) {\n        return getAddress(value);\n    }\n    callAddress(value) {\n        if (!isHexString(value, 32)) {\n            return null;\n        }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null : address;\n    }\n    contractAddress(value) {\n        return getContractAddress(value);\n    }\n    // Strict! Used on input.\n    blockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        if (blockTag === \"earliest\") {\n            return \"0x0\";\n        }\n        switch (blockTag) {\n            case \"earliest\": return \"0x0\";\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n            case \"finalized\":\n                return blockTag;\n        }\n        if (typeof (blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(blockTag);\n        }\n        throw new Error(\"invalid blockTag\");\n    }\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value, strict) {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value) {\n        if (value == null) {\n            return null;\n        }\n        const v = BigNumber.from(value);\n        try {\n            return v.toNumber();\n        }\n        catch (error) { }\n        return null;\n    }\n    uint256(value) {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n    _block(value, format) {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty : value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null : BigNumber.from(difficulty));\n        return result;\n    }\n    block(value) {\n        return this._block(value, this.formats.block);\n    }\n    blockWithTransactions(value) {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n    // Strict! Used on input.\n    transactionRequest(value) {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n    transactionResponse(transaction) {\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {\n            transaction.accessList = [];\n        }\n        const result = Formatter.check(this.formats.transaction, transaction);\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            result.chainId = chainId;\n        }\n        else {\n            let chainId = transaction.networkId;\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            if (typeof (chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) {\n                    chainId = 0;\n                }\n                chainId = parseInt(chainId);\n            }\n            if (typeof (chainId) !== \"number\") {\n                chainId = 0;\n            }\n            result.chainId = chainId;\n        }\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n        return result;\n    }\n    transaction(value) {\n        return parseTransaction(value);\n    }\n    receiptLog(value) {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n    receipt(value) {\n        const result = Formatter.check(this.formats.receipt, value);\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                }\n                else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            }\n            else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n        return result;\n    }\n    topics(value) {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n        }\n        else if (value != null) {\n            return this.hash(value, true);\n        }\n        return null;\n    }\n    filter(value) {\n        return Formatter.check(this.formats.filter, value);\n    }\n    filterLog(value) {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n    static check(format, object) {\n        const result = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) {\n                    result[key] = value;\n                }\n            }\n            catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n    // if value is null-ish, nullValue is returned\n    static allowNull(format, nullValue) {\n        return (function (value) {\n            if (value == null) {\n                return nullValue;\n            }\n            return format(value);\n        });\n    }\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format, replaceValue) {\n        return (function (value) {\n            if (!value) {\n                return replaceValue;\n            }\n            return format(value);\n        });\n    }\n    // Requires an Array satisfying check\n    static arrayOf(format) {\n        return (function (array) {\n            if (!Array.isArray(array)) {\n                throw new Error(\"not an array\");\n            }\n            const result = [];\n            array.forEach(function (value) {\n                result.push(format(value));\n            });\n            return result;\n        });\n    }\n}\nexport function isCommunityResourcable(value) {\n    return (value && typeof (value.isCommunityResource) === \"function\");\n}\nexport function isCommunityResource(value) {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n// Show the throttle message only once\nlet throttleMessage = false;\nexport function showThrottleMessage() {\n    if (throttleMessage) {\n        return;\n    }\n    throttleMessage = true;\n    console.log(\"========= NOTICE =========\");\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n//# sourceMappingURL=formatter.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ForkEvent, Provider } from \"@ethersproject/abstract-provider\";\nimport { encode as base64Encode } from \"@ethersproject/base64\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexConcat, hexDataLength, hexDataSlice, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { HashZero } from \"@ethersproject/constants\";\nimport { dnsEncode, namehash } from \"@ethersproject/hash\";\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { defineReadOnly, getStatic, resolveProperties } from \"@ethersproject/properties\";\nimport { sha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\nimport bech32 from \"bech32\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { Formatter } from \"./formatter\";\nconst MAX_CCIP_REDIRECTS = 10;\n//////////////////////////////\n// Event Serializeing\nfunction checkTopic(topic) {\n    if (topic == null) {\n        return \"null\";\n    }\n    if (hexDataLength(topic) !== 32) {\n        logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n    }\n    return topic.toLowerCase();\n}\nfunction serializeTopics(topics) {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) {\n        topics.pop();\n    }\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            // Only track unique OR-topics\n            const unique = {};\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n            return sorted.join(\"|\");\n        }\n        else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\nfunction deserializeTopics(data) {\n    if (data === \"\") {\n        return [];\n    }\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") {\n            return [];\n        }\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null : topic);\n        });\n        return ((comps.length === 1) ? comps[0] : comps);\n    });\n}\nfunction getEventTag(eventName) {\n    if (typeof (eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n    }\n    else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n    }\n    else if (ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n    }\n    else if (eventName && typeof (eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n    throw new Error(\"invalid event - \" + eventName);\n}\n//////////////////////////////\n// Helper Object\nfunction getTime() {\n    return (new Date()).getTime();\n}\nfunction stall(duration) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n//////////////////////////////\n// Provider Object\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\nconst PollableEvents = [\"block\", \"network\", \"pending\", \"poll\"];\nexport class Event {\n    constructor(tag, listener, once) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n        this._lastBlockNumber = -2;\n        this._inflight = false;\n    }\n    get event() {\n        switch (this.type) {\n            case \"tx\":\n                return this.hash;\n            case \"filter\":\n                return this.filter;\n        }\n        return this.tag;\n    }\n    get type() {\n        return this.tag.split(\":\")[0];\n    }\n    get hash() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") {\n            return null;\n        }\n        return comps[1];\n    }\n    get filter() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") {\n            return null;\n        }\n        const address = comps[1];\n        const topics = deserializeTopics(comps[2]);\n        const filter = {};\n        if (topics.length > 0) {\n            filter.topics = topics;\n        }\n        if (address && address !== \"*\") {\n            filter.address = address;\n        }\n        return filter;\n    }\n    pollable() {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n;\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos = {\n    \"0\": { symbol: \"btc\", p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\": { symbol: \"ltc\", p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\": { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\": { symbol: \"eth\", ilk: \"eth\" },\n    \"61\": { symbol: \"etc\", ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\nfunction bytes32ify(value) {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data) {\n    return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));\n}\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\nfunction _parseString(result, start) {\n    try {\n        return toUtf8String(_parseBytes(result, start));\n    }\n    catch (error) { }\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();\n    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n    return hexDataSlice(result, offset + 32, offset + 32 + length);\n}\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    }\n    else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    }\n    else {\n        logger.throwArgumentError(\"unsupported IPFS format\", \"link\", link);\n    }\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\nfunction numPad(value) {\n    const result = arrayify(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if ((value.length % 32) === 0) {\n        return value;\n    }\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    const result = [];\n    let byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for (let i = 0; i < datas.length; i++) {\n        result.push(null);\n        byteCount += 32;\n    }\n    for (let i = 0; i < datas.length; i++) {\n        const data = arrayify(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return hexConcat(result);\n}\nexport class Resolver {\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider, address, name, resolvedAddress) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n        defineReadOnly(this, \"_resolvedAddress\", resolvedAddress);\n    }\n    supportsWildcard() {\n        if (!this._supportsEip2544) {\n            // supportsInterface(bytes4 = selector(\"resolve(bytes,bytes)\"))\n            this._supportsEip2544 = this.provider.call({\n                to: this.address,\n                data: \"0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000\"\n            }).then((result) => {\n                return BigNumber.from(result).eq(1);\n            }).catch((error) => {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return false;\n                }\n                // Rethrow the error: link is down, etc. Let future attempts retry.\n                this._supportsEip2544 = null;\n                throw error;\n            });\n        }\n        return this._supportsEip2544;\n    }\n    _fetch(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // e.g. keccak256(\"addr(bytes32,uint256)\")\n            const tx = {\n                to: this.address,\n                ccipReadEnabled: true,\n                data: hexConcat([selector, namehash(this.name), (parameters || \"0x\")])\n            };\n            // Wildcard support; use EIP-2544 to resolve the request\n            let parseBytes = false;\n            if (yield this.supportsWildcard()) {\n                parseBytes = true;\n                // selector(\"resolve(bytes,bytes)\")\n                tx.data = hexConcat([\"0x9061b923\", encodeBytes([dnsEncode(this.name), tx.data])]);\n            }\n            try {\n                let result = yield this.provider.call(tx);\n                if ((arrayify(result).length % 32) === 4) {\n                    logger.throwError(\"resolver threw error\", Logger.errors.CALL_EXCEPTION, {\n                        transaction: tx, data: result\n                    });\n                }\n                if (parseBytes) {\n                    result = _parseBytes(result, 0);\n                }\n                return result;\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                throw error;\n            }\n        });\n    }\n    _fetchBytes(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield this._fetch(selector, parameters);\n            if (result != null) {\n                return _parseBytes(result, 0);\n            }\n            return null;\n        });\n    }\n    _getAddress(coinType, hexBytes) {\n        const coinInfo = coinInfos[String(coinType)];\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${coinType})`\n            });\n        }\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n        const bytes = arrayify(hexBytes);\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2pkh], (\"0x\" + p2pkh[2])]));\n                }\n            }\n        }\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2sh], (\"0x\" + p2sh[2])]));\n                }\n            }\n        }\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            }\n            else {\n                version = -1;\n            }\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32.toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32.encode(coinInfo.prefix, words);\n            }\n        }\n        return null;\n    }\n    getAddress(coinType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (coinType == null) {\n                coinType = 60;\n            }\n            // If Ethereum, use the standard `addr(bytes32)`\n            if (coinType === 60) {\n                try {\n                    // keccak256(\"addr(bytes32)\")\n                    const result = yield this._fetch(\"0x3b3b57de\");\n                    // No address\n                    if (result === \"0x\" || result === HashZero) {\n                        return null;\n                    }\n                    return this.provider.formatter.callAddress(result);\n                }\n                catch (error) {\n                    if (error.code === Logger.errors.CALL_EXCEPTION) {\n                        return null;\n                    }\n                    throw error;\n                }\n            }\n            // keccak256(\"addr(bytes32,uint256\")\n            const hexBytes = yield this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n            // No address\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // Compute the address\n            const address = this._getAddress(coinType, hexBytes);\n            if (address == null) {\n                logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `getAddress(${coinType})`,\n                    coinType: coinType,\n                    data: hexBytes\n                });\n            }\n            return address;\n        });\n    }\n    getAvatar() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const linkage = [{ type: \"name\", content: this.name }];\n            try {\n                // test data for ricmoo.eth\n                //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n                const avatar = yield this.getText(\"avatar\");\n                if (avatar == null) {\n                    return null;\n                }\n                for (let i = 0; i < matchers.length; i++) {\n                    const match = avatar.match(matchers[i]);\n                    if (match == null) {\n                        continue;\n                    }\n                    const scheme = match[1].toLowerCase();\n                    switch (scheme) {\n                        case \"https\":\n                            linkage.push({ type: \"url\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"data\":\n                            linkage.push({ type: \"data\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"ipfs\":\n                            linkage.push({ type: \"ipfs\", content: avatar });\n                            return { linkage, url: getIpfsLink(avatar) };\n                        case \"erc721\":\n                        case \"erc1155\": {\n                            // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                            const selector = (scheme === \"erc721\") ? \"0xc87b56dd\" : \"0x0e89341c\";\n                            linkage.push({ type: scheme, content: avatar });\n                            // The owner of this name\n                            const owner = (this._resolvedAddress || (yield this.getAddress()));\n                            const comps = (match[2] || \"\").split(\"/\");\n                            if (comps.length !== 2) {\n                                return null;\n                            }\n                            const addr = yield this.provider.formatter.address(comps[0]);\n                            const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);\n                            // Check that this account owns the token\n                            if (scheme === \"erc721\") {\n                                // ownerOf(uint256 tokenId)\n                                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({\n                                    to: addr, data: hexConcat([\"0x6352211e\", tokenId])\n                                }));\n                                if (owner !== tokenOwner) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"owner\", content: tokenOwner });\n                            }\n                            else if (scheme === \"erc1155\") {\n                                // balanceOf(address owner, uint256 tokenId)\n                                const balance = BigNumber.from(yield this.provider.call({\n                                    to: addr, data: hexConcat([\"0x00fdd58e\", hexZeroPad(owner, 32), tokenId])\n                                }));\n                                if (balance.isZero()) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"balance\", content: balance.toString() });\n                            }\n                            // Call the token contract for the metadata URL\n                            const tx = {\n                                to: this.provider.formatter.address(comps[0]),\n                                data: hexConcat([selector, tokenId])\n                            };\n                            let metadataUrl = _parseString(yield this.provider.call(tx), 0);\n                            if (metadataUrl == null) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata-url-base\", content: metadataUrl });\n                            // ERC-1155 allows a generic {id} in the URL\n                            if (scheme === \"erc1155\") {\n                                metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                                linkage.push({ type: \"metadata-url-expanded\", content: metadataUrl });\n                            }\n                            // Transform IPFS metadata links\n                            if (metadataUrl.match(/^ipfs:/i)) {\n                                metadataUrl = getIpfsLink(metadataUrl);\n                            }\n                            linkage.push({ type: \"metadata-url\", content: metadataUrl });\n                            // Get the token metadata\n                            const metadata = yield fetchJson(metadataUrl);\n                            if (!metadata) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n                            // Pull the image URL out\n                            let imageUrl = metadata.image;\n                            if (typeof (imageUrl) !== \"string\") {\n                                return null;\n                            }\n                            if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                                // Allow\n                            }\n                            else {\n                                // Transform IPFS link to gateway\n                                const ipfs = imageUrl.match(matcherIpfs);\n                                if (ipfs == null) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"url-ipfs\", content: imageUrl });\n                                imageUrl = getIpfsLink(imageUrl);\n                            }\n                            linkage.push({ type: \"url\", content: imageUrl });\n                            return { linkage, url: imageUrl };\n                        }\n                    }\n                }\n            }\n            catch (error) { }\n            return null;\n        });\n    }\n    getContentHash() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // keccak256(\"contenthash()\")\n            const hexBytes = yield this._fetchBytes(\"0xbc1c58d1\");\n            // No contenthash\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // IPFS (CID: 1, Type: DAG-PB)\n            const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipfs) {\n                const length = parseInt(ipfs[3], 16);\n                if (ipfs[4].length === length * 2) {\n                    return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n                }\n            }\n            // IPNS (CID: 1, Type: libp2p-key)\n            const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipns) {\n                const length = parseInt(ipns[3], 16);\n                if (ipns[4].length === length * 2) {\n                    return \"ipns:/\\/\" + Base58.encode(\"0x\" + ipns[1]);\n                }\n            }\n            // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n            const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n            if (swarm) {\n                if (swarm[1].length === (32 * 2)) {\n                    return \"bzz:/\\/\" + swarm[1];\n                }\n            }\n            const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);\n            if (skynet) {\n                if (skynet[1].length === (34 * 2)) {\n                    // URL Safe base64; https://datatracker.ietf.org/doc/html/rfc4648#section-5\n                    const urlSafe = { \"=\": \"\", \"+\": \"-\", \"/\": \"_\" };\n                    const hash = base64Encode(\"0x\" + skynet[1]).replace(/[=+\\/]/g, (a) => (urlSafe[a]));\n                    return \"sia:/\\/\" + hash;\n                }\n            }\n            return logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"getContentHash()\",\n                data: hexBytes\n            });\n        });\n    }\n    getText(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // The key encoded as parameter to fetchBytes\n            let keyBytes = toUtf8Bytes(key);\n            // The nodehash consumes the first slot, so the string pointer targets\n            // offset 64, with the length at offset 64 and data starting at offset 96\n            keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);\n            // Pad to word-size (32 bytes)\n            if ((keyBytes.length % 32) !== 0) {\n                keyBytes = concat([keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32))]);\n            }\n            const hexBytes = yield this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            return toUtf8String(hexBytes);\n        });\n    }\n}\nlet defaultFormatter = null;\nlet nextPollId = 1;\nexport class BaseProvider extends Provider {\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n    constructor(network) {\n        super();\n        // Events being listened to\n        this._events = [];\n        this._emitted = { block: -2 };\n        this.disableCcipRead = false;\n        this.formatter = new.target.getFormatter();\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) {\n            network = this.detectNetwork();\n        }\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n        }\n        else {\n            const knownNetwork = getStatic(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n            }\n            else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n        this._maxInternalBlockNumber = -1024;\n        this._lastBlockNumber = -2;\n        this._maxFilterBlockRange = 10;\n        this._pollingInterval = 4000;\n        this._fastQueryDate = 0;\n    }\n    _ready() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._network == null) {\n                let network = null;\n                if (this._networkPromise) {\n                    try {\n                        network = yield this._networkPromise;\n                    }\n                    catch (error) { }\n                }\n                // Try the Provider's network detection (this MUST throw if it cannot)\n                if (network == null) {\n                    network = yield this.detectNetwork();\n                }\n                // This should never happen; every Provider sub-class should have\n                // suggested a network by here (or have thrown).\n                if (!network) {\n                    logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // Possible this call stacked so do not call defineReadOnly again\n                if (this._network == null) {\n                    if (this.anyNetwork) {\n                        this._network = network;\n                    }\n                    else {\n                        defineReadOnly(this, \"_network\", network);\n                    }\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return this._network;\n        });\n    }\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready() {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter() {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network) {\n        return getNetwork((network == null) ? \"homestead\" : network);\n    }\n    ccipReadFetch(tx, calldata, urls) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.disableCcipRead || urls.length === 0) {\n                return null;\n            }\n            const sender = tx.to.toLowerCase();\n            const data = calldata.toLowerCase();\n            const errorMessages = [];\n            for (let i = 0; i < urls.length; i++) {\n                const url = urls[i];\n                // URL expansion\n                const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n                // If no {data} is present, use POST; otherwise GET\n                const json = (url.indexOf(\"{data}\") >= 0) ? null : JSON.stringify({ data, sender });\n                const result = yield fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n                    value.status = response.statusCode;\n                    return value;\n                });\n                if (result.data) {\n                    return result.data;\n                }\n                const errorMessage = (result.message || \"unknown error\");\n                // 4xx indicates the result is not present; stop\n                if (result.status >= 400 && result.status < 500) {\n                    return logger.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger.errors.SERVER_ERROR, { url, errorMessage });\n                }\n                // 5xx indicates server issue; try the next url\n                errorMessages.push(errorMessage);\n            }\n            return logger.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(\", \")}`, Logger.errors.SERVER_ERROR, {\n                urls, errorMessages\n            });\n        });\n    }\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    _getInternalBlockNumber(maxAge) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._ready();\n            // Allowing stale data up to maxAge old\n            if (maxAge > 0) {\n                // While there are pending internal block requests...\n                while (this._internalBlockNumber) {\n                    // ...\"remember\" which fetch we started with\n                    const internalBlockNumber = this._internalBlockNumber;\n                    try {\n                        // Check the result is not too stale\n                        const result = yield internalBlockNumber;\n                        if ((getTime() - result.respTime) <= maxAge) {\n                            return result.blockNumber;\n                        }\n                        // Too old; fetch a new value\n                        break;\n                    }\n                    catch (error) {\n                        // The fetch rejected; if we are the first to get the\n                        // rejection, drop through so we replace it with a new\n                        // fetch; all others blocked will then get that fetch\n                        // which won't match the one they \"remembered\" and loop\n                        if (this._internalBlockNumber === internalBlockNumber) {\n                            break;\n                        }\n                    }\n                }\n            }\n            const reqTime = getTime();\n            const checkInternalBlockNumber = resolveProperties({\n                blockNumber: this.perform(\"getBlockNumber\", {}),\n                networkError: this.getNetwork().then((network) => (null), (error) => (error))\n            }).then(({ blockNumber, networkError }) => {\n                if (networkError) {\n                    // Unremember this bad internal block number\n                    if (this._internalBlockNumber === checkInternalBlockNumber) {\n                        this._internalBlockNumber = null;\n                    }\n                    throw networkError;\n                }\n                const respTime = getTime();\n                blockNumber = BigNumber.from(blockNumber).toNumber();\n                if (blockNumber < this._maxInternalBlockNumber) {\n                    blockNumber = this._maxInternalBlockNumber;\n                }\n                this._maxInternalBlockNumber = blockNumber;\n                this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n                return { blockNumber, reqTime, respTime };\n            });\n            this._internalBlockNumber = checkInternalBlockNumber;\n            // Swallow unhandled exceptions; if needed they are handled else where\n            checkInternalBlockNumber.catch((error) => {\n                // Don't null the dead (rejected) fetch, if it has already been updated\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n            });\n            return (yield checkInternalBlockNumber).blockNumber;\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const pollId = nextPollId++;\n            // Track all running promises, so we can trigger a post-poll once they are complete\n            const runners = [];\n            let blockNumber = null;\n            try {\n                blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n            }\n            catch (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this._setFastBlockNumber(blockNumber);\n            // Emit a poll event after we have the latest (fast) block number\n            this.emit(\"poll\", pollId, blockNumber);\n            // If the block has not changed, meh.\n            if (blockNumber === this._lastBlockNumber) {\n                this.emit(\"didPoll\", pollId);\n                return;\n            }\n            // First polling cycle, trigger a \"block\" events\n            if (this._emitted.block === -2) {\n                this._emitted.block = blockNumber - 1;\n            }\n            if (Math.abs((this._emitted.block) - blockNumber) > 1000) {\n                logger.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);\n                this.emit(\"error\", logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                    blockNumber: blockNumber,\n                    event: \"blockSkew\",\n                    previousBlockNumber: this._emitted.block\n                }));\n                this.emit(\"block\", blockNumber);\n            }\n            else {\n                // Notify all listener for each block that has passed\n                for (let i = this._emitted.block + 1; i <= blockNumber; i++) {\n                    this.emit(\"block\", i);\n                }\n            }\n            // The emitted block was updated, check for obsolete events\n            if (this._emitted.block !== blockNumber) {\n                this._emitted.block = blockNumber;\n                Object.keys(this._emitted).forEach((key) => {\n                    // The block event does not expire\n                    if (key === \"block\") {\n                        return;\n                    }\n                    // The block we were at when we emitted this event\n                    const eventBlockNumber = this._emitted[key];\n                    // We cannot garbage collect pending transactions or blocks here\n                    // They should be garbage collected by the Provider when setting\n                    // \"pending\" events\n                    if (eventBlockNumber === \"pending\") {\n                        return;\n                    }\n                    // Evict any transaction hashes or block hashes over 12 blocks\n                    // old, since they should not return null anyways\n                    if (blockNumber - eventBlockNumber > 12) {\n                        delete this._emitted[key];\n                    }\n                });\n            }\n            // First polling cycle\n            if (this._lastBlockNumber === -2) {\n                this._lastBlockNumber = blockNumber - 1;\n            }\n            // Find all transaction hashes we are waiting on\n            this._events.forEach((event) => {\n                switch (event.type) {\n                    case \"tx\": {\n                        const hash = event.hash;\n                        let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                            if (!receipt || receipt.blockNumber == null) {\n                                return null;\n                            }\n                            this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                            this.emit(hash, receipt);\n                            return null;\n                        }).catch((error) => { this.emit(\"error\", error); });\n                        runners.push(runner);\n                        break;\n                    }\n                    case \"filter\": {\n                        // We only allow a single getLogs to be in-flight at a time\n                        if (!event._inflight) {\n                            event._inflight = true;\n                            // This is the first filter for this event, so we want to\n                            // restrict events to events that happened no earlier than now\n                            if (event._lastBlockNumber === -2) {\n                                event._lastBlockNumber = blockNumber - 1;\n                            }\n                            // Filter from the last *known* event; due to load-balancing\n                            // and some nodes returning updated block numbers before\n                            // indexing events, a logs result with 0 entries cannot be\n                            // trusted and we must retry a range which includes it again\n                            const filter = event.filter;\n                            filter.fromBlock = event._lastBlockNumber + 1;\n                            filter.toBlock = blockNumber;\n                            // Prevent fitler ranges from growing too wild, since it is quite\n                            // likely there just haven't been any events to move the lastBlockNumber.\n                            const minFromBlock = filter.toBlock - this._maxFilterBlockRange;\n                            if (minFromBlock > filter.fromBlock) {\n                                filter.fromBlock = minFromBlock;\n                            }\n                            if (filter.fromBlock < 0) {\n                                filter.fromBlock = 0;\n                            }\n                            const runner = this.getLogs(filter).then((logs) => {\n                                // Allow the next getLogs\n                                event._inflight = false;\n                                if (logs.length === 0) {\n                                    return;\n                                }\n                                logs.forEach((log) => {\n                                    // Only when we get an event for a given block number\n                                    // can we trust the events are indexed\n                                    if (log.blockNumber > event._lastBlockNumber) {\n                                        event._lastBlockNumber = log.blockNumber;\n                                    }\n                                    // Make sure we stall requests to fetch blocks and txs\n                                    this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                    this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                                    this.emit(filter, log);\n                                });\n                            }).catch((error) => {\n                                this.emit(\"error\", error);\n                                // Allow another getLogs (the range was not updated)\n                                event._inflight = false;\n                            });\n                            runners.push(runner);\n                        }\n                        break;\n                    }\n                }\n            });\n            this._lastBlockNumber = blockNumber;\n            // Once all events for this loop have been processed, emit \"didPoll\"\n            Promise.all(runners).then(() => {\n                this.emit(\"didPoll\", pollId);\n            }).catch((error) => { this.emit(\"error\", error); });\n            return;\n        });\n    }\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber) {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) {\n            this.poll();\n        }\n    }\n    get network() {\n        return this._network;\n    }\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"provider.detectNetwork\"\n            });\n        });\n    }\n    getNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const network = yield this._ready();\n            // Make sure we are still connected to the same network; this is\n            // only an external call for backends which can have the underlying\n            // network change spontaneously\n            const currentNetwork = yield this.detectNetwork();\n            if (network.chainId !== currentNetwork.chainId) {\n                // We are allowing network changes, things can get complex fast;\n                // make sure you know what you are doing if you use \"any\"\n                if (this.anyNetwork) {\n                    this._network = currentNetwork;\n                    // Reset all internal block number guards and caches\n                    this._lastBlockNumber = -2;\n                    this._fastBlockNumber = null;\n                    this._fastBlockNumberPromise = null;\n                    this._fastQueryDate = 0;\n                    this._emitted.block = -2;\n                    this._maxInternalBlockNumber = -1024;\n                    this._internalBlockNumber = null;\n                    // The \"network\" event MUST happen before this method resolves\n                    // so any events have a chance to unregister, so we stall an\n                    // additional event loop before returning from /this/ call\n                    this.emit(\"network\", currentNetwork, network);\n                    yield stall(0);\n                    return this._network;\n                }\n                const error = logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                    event: \"changed\",\n                    network: network,\n                    detectedNetwork: currentNetwork\n                });\n                this.emit(\"error\", error);\n                throw error;\n            }\n            return network;\n        });\n    }\n    get blockNumber() {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber : -1;\n    }\n    get polling() {\n        return (this._poller != null);\n    }\n    set polling(value) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) {\n                            this.poll();\n                        }\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n        }\n        else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n    get pollingInterval() {\n        return this._pollingInterval;\n    }\n    set pollingInterval(value) {\n        if (typeof (value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n        this._pollingInterval = value;\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n    _getFastBlockNumber() {\n        const now = getTime();\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n        return this._fastBlockNumberPromise;\n    }\n    _setFastBlockNumber(blockNumber) {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n            return;\n        }\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n    waitForTransaction(transactionHash, confirmations, timeout) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._waitForTransaction(transactionHash, (confirmations == null) ? 1 : confirmations, timeout || 0, null);\n        });\n    }\n    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const receipt = yield this.getTransactionReceipt(transactionHash);\n            // Receipt is already good\n            if ((receipt ? receipt.confirmations : 0) >= confirmations) {\n                return receipt;\n            }\n            // Poll until the receipt is good...\n            return new Promise((resolve, reject) => {\n                const cancelFuncs = [];\n                let done = false;\n                const alreadyDone = function () {\n                    if (done) {\n                        return true;\n                    }\n                    done = true;\n                    cancelFuncs.forEach((func) => { func(); });\n                    return false;\n                };\n                const minedHandler = (receipt) => {\n                    if (receipt.confirmations < confirmations) {\n                        return;\n                    }\n                    if (alreadyDone()) {\n                        return;\n                    }\n                    resolve(receipt);\n                };\n                this.on(transactionHash, minedHandler);\n                cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n                if (replaceable) {\n                    let lastBlockNumber = replaceable.startBlock;\n                    let scannedBlock = null;\n                    const replaceHandler = (blockNumber) => __awaiter(this, void 0, void 0, function* () {\n                        if (done) {\n                            return;\n                        }\n                        // Wait 1 second; this is only used in the case of a fault, so\n                        // we will trade off a little bit of latency for more consistent\n                        // results and fewer JSON-RPC calls\n                        yield stall(1000);\n                        this.getTransactionCount(replaceable.from).then((nonce) => __awaiter(this, void 0, void 0, function* () {\n                            if (done) {\n                                return;\n                            }\n                            if (nonce <= replaceable.nonce) {\n                                lastBlockNumber = blockNumber;\n                            }\n                            else {\n                                // First check if the transaction was mined\n                                {\n                                    const mined = yield this.getTransaction(transactionHash);\n                                    if (mined && mined.blockNumber != null) {\n                                        return;\n                                    }\n                                }\n                                // First time scanning. We start a little earlier for some\n                                // wiggle room here to handle the eventually consistent nature\n                                // of blockchain (e.g. the getTransactionCount was for a\n                                // different block)\n                                if (scannedBlock == null) {\n                                    scannedBlock = lastBlockNumber - 3;\n                                    if (scannedBlock < replaceable.startBlock) {\n                                        scannedBlock = replaceable.startBlock;\n                                    }\n                                }\n                                while (scannedBlock <= blockNumber) {\n                                    if (done) {\n                                        return;\n                                    }\n                                    const block = yield this.getBlockWithTransactions(scannedBlock);\n                                    for (let ti = 0; ti < block.transactions.length; ti++) {\n                                        const tx = block.transactions[ti];\n                                        // Successfully mined!\n                                        if (tx.hash === transactionHash) {\n                                            return;\n                                        }\n                                        // Matches our transaction from and nonce; its a replacement\n                                        if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                            if (done) {\n                                                return;\n                                            }\n                                            // Get the receipt of the replacement\n                                            const receipt = yield this.waitForTransaction(tx.hash, confirmations);\n                                            // Already resolved or rejected (prolly a timeout)\n                                            if (alreadyDone()) {\n                                                return;\n                                            }\n                                            // The reason we were replaced\n                                            let reason = \"replaced\";\n                                            if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                                reason = \"repriced\";\n                                            }\n                                            else if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                                reason = \"cancelled\";\n                                            }\n                                            // Explain why we were replaced\n                                            reject(logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                                cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                                reason,\n                                                replacement: this._wrapTransaction(tx),\n                                                hash: transactionHash,\n                                                receipt\n                                            }));\n                                            return;\n                                        }\n                                    }\n                                    scannedBlock++;\n                                }\n                            }\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        }), (error) => {\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        });\n                    });\n                    if (done) {\n                        return;\n                    }\n                    this.once(\"block\", replaceHandler);\n                    cancelFuncs.push(() => {\n                        this.removeListener(\"block\", replaceHandler);\n                    });\n                }\n                if (typeof (timeout) === \"number\" && timeout > 0) {\n                    const timer = setTimeout(() => {\n                        if (alreadyDone()) {\n                            return;\n                        }\n                        reject(logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                    }, timeout);\n                    if (timer.unref) {\n                        timer.unref();\n                    }\n                    cancelFuncs.push(() => { clearTimeout(timer); });\n                }\n            });\n        });\n    }\n    getBlockNumber() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._getInternalBlockNumber(0);\n        });\n    }\n    getGasPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const result = yield this.perform(\"getGasPrice\", {});\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getGasPrice\",\n                    result, error\n                });\n            }\n        });\n    }\n    getBalance(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getBalance\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getBalance\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getTransactionCount(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getTransactionCount\", params);\n            try {\n                return BigNumber.from(result).toNumber();\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getTransactionCount\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getCode(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getCode\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getCode\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getStorageAt(addressOrName, position, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag),\n                position: Promise.resolve(position).then((p) => hexValue(p))\n            });\n            const result = yield this.perform(\"getStorageAt\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getStorageAt\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx, hash, startBlock) {\n        if (hash != null && hexDataLength(hash) !== 32) {\n            throw new Error(\"invalid response - sendTransaction\");\n        }\n        const result = tx;\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n        result.wait = (confirms, timeout) => __awaiter(this, void 0, void 0, function* () {\n            if (confirms == null) {\n                confirms = 1;\n            }\n            if (timeout == null) {\n                timeout = 0;\n            }\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n            const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) {\n                return null;\n            }\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n            if (receipt.status === 0) {\n                logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        });\n        return result;\n    }\n    sendTransaction(signedTransaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const hexTx = yield Promise.resolve(signedTransaction).then(t => hexlify(t));\n            const tx = this.formatter.transaction(signedTransaction);\n            if (tx.confirmations == null) {\n                tx.confirmations = 0;\n            }\n            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            try {\n                const hash = yield this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n                return this._wrapTransaction(tx, hash, blockNumber);\n            }\n            catch (error) {\n                error.transaction = tx;\n                error.transactionHash = tx.hash;\n                throw error;\n            }\n        });\n    }\n    _getTransactionRequest(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const values = yield transaction;\n            const tx = {};\n            [\"from\", \"to\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v) : null));\n            });\n            [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v) : null));\n            });\n            [\"type\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v : null));\n            });\n            if (values.accessList) {\n                tx.accessList = this.formatter.accessList(values.accessList);\n            }\n            [\"data\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v) : null));\n            });\n            return this.formatter.transactionRequest(yield resolveProperties(tx));\n        });\n    }\n    _getFilter(filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            filter = yield filter;\n            const result = {};\n            if (filter.address != null) {\n                result.address = this._getAddress(filter.address);\n            }\n            [\"blockHash\", \"topics\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = filter[key];\n            });\n            [\"fromBlock\", \"toBlock\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = this._getBlockTag(filter[key]);\n            });\n            return this.formatter.filter(yield resolveProperties(result));\n        });\n    }\n    _call(transaction, blockTag, attempt) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (attempt >= MAX_CCIP_REDIRECTS) {\n                logger.throwError(\"CCIP read exceeded maximum redirections\", Logger.errors.SERVER_ERROR, {\n                    redirects: attempt, transaction\n                });\n            }\n            const txSender = transaction.to;\n            const result = yield this.perform(\"call\", { transaction, blockTag });\n            // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)\n            if (attempt >= 0 && blockTag === \"latest\" && txSender != null && result.substring(0, 10) === \"0x556f1830\" && (hexDataLength(result) % 32 === 4)) {\n                try {\n                    const data = hexDataSlice(result, 4);\n                    // Check the sender of the OffchainLookup matches the transaction\n                    const sender = hexDataSlice(data, 0, 32);\n                    if (!BigNumber.from(sender).eq(txSender)) {\n                        logger.throwError(\"CCIP Read sender did not match\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    // Read the URLs from the response\n                    const urls = [];\n                    const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();\n                    const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();\n                    const urlsData = hexDataSlice(data, urlsOffset + 32);\n                    for (let u = 0; u < urlsLength; u++) {\n                        const url = _parseString(urlsData, u * 32);\n                        if (url == null) {\n                            logger.throwError(\"CCIP Read contained corrupt URL string\", Logger.errors.CALL_EXCEPTION, {\n                                name: \"OffchainLookup\",\n                                signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                                transaction, data: result\n                            });\n                        }\n                        urls.push(url);\n                    }\n                    // Get the CCIP calldata to forward\n                    const calldata = _parseBytes(data, 64);\n                    // Get the callbackSelector (bytes4)\n                    if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {\n                        logger.throwError(\"CCIP Read callback selector included junk\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    const callbackSelector = hexDataSlice(data, 96, 100);\n                    // Get the extra data to send back to the contract as context\n                    const extraData = _parseBytes(data, 128);\n                    const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);\n                    if (ccipResult == null) {\n                        logger.throwError(\"CCIP Read disabled or provided no URLs\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    const tx = {\n                        to: txSender,\n                        data: hexConcat([callbackSelector, encodeBytes([ccipResult, extraData])])\n                    };\n                    return this._call(tx, blockTag, attempt + 1);\n                }\n                catch (error) {\n                    if (error.code === Logger.errors.SERVER_ERROR) {\n                        throw error;\n                    }\n                }\n            }\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"call\",\n                    params: { transaction, blockTag }, result, error\n                });\n            }\n        });\n    }\n    call(transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const resolved = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction),\n                blockTag: this._getBlockTag(blockTag),\n                ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)\n            });\n            return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);\n        });\n    }\n    estimateGas(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction)\n            });\n            const result = yield this.perform(\"estimateGas\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"estimateGas\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    _getAddress(addressOrName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            addressOrName = yield addressOrName;\n            if (typeof (addressOrName) !== \"string\") {\n                logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n            }\n            const address = yield this.resolveName(addressOrName);\n            if (address == null) {\n                logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `resolveName(${JSON.stringify(addressOrName)})`\n                });\n            }\n            return address;\n        });\n    }\n    _getBlock(blockHashOrBlockTag, includeTransactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            blockHashOrBlockTag = yield blockHashOrBlockTag;\n            // If blockTag is a number (not \"latest\", etc), this is the block number\n            let blockNumber = -128;\n            const params = {\n                includeTransactions: !!includeTransactions\n            };\n            if (isHexString(blockHashOrBlockTag, 32)) {\n                params.blockHash = blockHashOrBlockTag;\n            }\n            else {\n                try {\n                    params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);\n                    if (isHexString(params.blockTag)) {\n                        blockNumber = parseInt(params.blockTag.substring(2), 16);\n                    }\n                }\n                catch (error) {\n                    logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n                }\n            }\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const block = yield this.perform(\"getBlock\", params);\n                // Block was not found\n                if (block == null) {\n                    // For blockhashes, if we didn't say it existed, that blockhash may\n                    // not exist. If we did see it though, perhaps from a log, we know\n                    // it exists, and this node is just not caught up yet.\n                    if (params.blockHash != null) {\n                        if (this._emitted[\"b:\" + params.blockHash] == null) {\n                            return null;\n                        }\n                    }\n                    // For block tags, if we are asking for a future block, we return null\n                    if (params.blockTag != null) {\n                        if (blockNumber > this._emitted.block) {\n                            return null;\n                        }\n                    }\n                    // Retry on the next block\n                    return undefined;\n                }\n                // Add transactions\n                if (includeTransactions) {\n                    let blockNumber = null;\n                    for (let i = 0; i < block.transactions.length; i++) {\n                        const tx = block.transactions[i];\n                        if (tx.blockNumber == null) {\n                            tx.confirmations = 0;\n                        }\n                        else if (tx.confirmations == null) {\n                            if (blockNumber == null) {\n                                blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                            }\n                            // Add the confirmations using the fast block number (pessimistic)\n                            let confirmations = (blockNumber - tx.blockNumber) + 1;\n                            if (confirmations <= 0) {\n                                confirmations = 1;\n                            }\n                            tx.confirmations = confirmations;\n                        }\n                    }\n                    const blockWithTxs = this.formatter.blockWithTransactions(block);\n                    blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));\n                    return blockWithTxs;\n                }\n                return this.formatter.block(block);\n            }), { oncePoll: this });\n        });\n    }\n    getBlock(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, false));\n    }\n    getBlockWithTransactions(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, true));\n    }\n    getTransaction(transactionHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransaction\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                const tx = this.formatter.transactionResponse(result);\n                if (tx.blockNumber == null) {\n                    tx.confirmations = 0;\n                }\n                else if (tx.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - tx.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    tx.confirmations = confirmations;\n                }\n                return this._wrapTransaction(tx);\n            }), { oncePoll: this });\n        });\n    }\n    getTransactionReceipt(transactionHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransactionReceipt\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                // \"geth-etc\" returns receipts before they are ready\n                if (result.blockHash == null) {\n                    return undefined;\n                }\n                const receipt = this.formatter.receipt(result);\n                if (receipt.blockNumber == null) {\n                    receipt.confirmations = 0;\n                }\n                else if (receipt.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    receipt.confirmations = confirmations;\n                }\n                return receipt;\n            }), { oncePoll: this });\n        });\n    }\n    getLogs(filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({ filter: this._getFilter(filter) });\n            const logs = yield this.perform(\"getLogs\", params);\n            logs.forEach((log) => {\n                if (log.removed == null) {\n                    log.removed = false;\n                }\n            });\n            return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n        });\n    }\n    getEtherPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            return this.perform(\"getEtherPrice\", {});\n        });\n    }\n    _getBlockTag(blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            blockTag = yield blockTag;\n            if (typeof (blockTag) === \"number\" && blockTag < 0) {\n                if (blockTag % 1) {\n                    logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n                }\n                let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                blockNumber += blockTag;\n                if (blockNumber < 0) {\n                    blockNumber = 0;\n                }\n                return this.formatter.blockTag(blockNumber);\n            }\n            return this.formatter.blockTag(blockTag);\n        });\n    }\n    getResolver(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let currentName = name;\n            while (true) {\n                if (currentName === \"\" || currentName === \".\") {\n                    return null;\n                }\n                // Optimization since the eth node cannot change and does\n                // not have a wildcard resolver\n                if (name !== \"eth\" && currentName === \"eth\") {\n                    return null;\n                }\n                // Check the current node for a resolver\n                const addr = yield this._getResolver(currentName, \"getResolver\");\n                // Found a resolver!\n                if (addr != null) {\n                    const resolver = new Resolver(this, addr, name);\n                    // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                    if (currentName !== name && !(yield resolver.supportsWildcard())) {\n                        return null;\n                    }\n                    return resolver;\n                }\n                // Get the parent node\n                currentName = currentName.split(\".\").slice(1).join(\".\");\n            }\n        });\n    }\n    _getResolver(name, operation) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (operation == null) {\n                operation = \"ENS\";\n            }\n            const network = yield this.getNetwork();\n            // No ENS...\n            if (!network.ensAddress) {\n                logger.throwError(\"network does not support ENS\", Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });\n            }\n            try {\n                // keccak256(\"resolver(bytes32)\")\n                const addrData = yield this.call({\n                    to: network.ensAddress,\n                    data: (\"0x0178b8bf\" + namehash(name).substring(2))\n                });\n                return this.formatter.callAddress(addrData);\n            }\n            catch (error) {\n                // ENS registry cannot throw errors on resolver(bytes32)\n            }\n            return null;\n        });\n    }\n    resolveName(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            name = yield name;\n            // If it is already an address, nothing to resolve\n            try {\n                return Promise.resolve(this.formatter.address(name));\n            }\n            catch (error) {\n                // If is is a hexstring, the address is bad (See #694)\n                if (isHexString(name)) {\n                    throw error;\n                }\n            }\n            if (typeof (name) !== \"string\") {\n                logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n            }\n            // Get the addr from the resolver\n            const resolver = yield this.getResolver(name);\n            if (!resolver) {\n                return null;\n            }\n            return yield resolver.getAddress();\n        });\n    }\n    lookupAddress(address) {\n        return __awaiter(this, void 0, void 0, function* () {\n            address = yield address;\n            address = this.formatter.address(address);\n            const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n            const resolverAddr = yield this._getResolver(node, \"lookupAddress\");\n            if (resolverAddr == null) {\n                return null;\n            }\n            // keccak(\"name(bytes32)\")\n            const name = _parseString(yield this.call({\n                to: resolverAddr,\n                data: (\"0x691f3431\" + namehash(node).substring(2))\n            }), 0);\n            const addr = yield this.resolveName(name);\n            if (addr != address) {\n                return null;\n            }\n            return name;\n        });\n    }\n    getAvatar(nameOrAddress) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let resolver = null;\n            if (isHexString(nameOrAddress)) {\n                // Address; reverse lookup\n                const address = this.formatter.address(nameOrAddress);\n                const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n                const resolverAddress = yield this._getResolver(node, \"getAvatar\");\n                if (!resolverAddress) {\n                    return null;\n                }\n                // Try resolving the avatar against the addr.reverse resolver\n                resolver = new Resolver(this, resolverAddress, node);\n                try {\n                    const avatar = yield resolver.getAvatar();\n                    if (avatar) {\n                        return avatar.url;\n                    }\n                }\n                catch (error) {\n                    if (error.code !== Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                }\n                // Try getting the name and performing forward lookup; allowing wildcards\n                try {\n                    // keccak(\"name(bytes32)\")\n                    const name = _parseString(yield this.call({\n                        to: resolverAddress,\n                        data: (\"0x691f3431\" + namehash(node).substring(2))\n                    }), 0);\n                    resolver = yield this.getResolver(name);\n                }\n                catch (error) {\n                    if (error.code !== Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                    return null;\n                }\n            }\n            else {\n                // ENS name; forward lookup with wildcard\n                resolver = yield this.getResolver(nameOrAddress);\n                if (!resolver) {\n                    return null;\n                }\n            }\n            const avatar = yield resolver.getAvatar();\n            if (avatar == null) {\n                return null;\n            }\n            return avatar.url;\n        });\n    }\n    perform(method, params) {\n        return logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n    _startEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _stopEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _addEventListener(eventName, listener, once) {\n        const event = new Event(getEventTag(eventName), listener, once);\n        this._events.push(event);\n        this._startEvent(event);\n        return this;\n    }\n    on(eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    }\n    once(eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    }\n    emit(eventName, ...args) {\n        let result = false;\n        let stopped = [];\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) {\n                return true;\n            }\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n            result = true;\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n            return true;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!eventName) {\n            return this._events.length;\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n    listeners(eventName) {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n    off(eventName, listener) {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n        const stopped = [];\n        let found = false;\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) {\n                return true;\n            }\n            if (found) {\n                return true;\n            }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n    removeAllListeners(eventName) {\n        let stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        }\n        else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n}\n//# sourceMappingURL=base-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Signer } from \"@ethersproject/abstract-signer\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { checkProperties, deepCopy, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BaseProvider } from \"./base-provider\";\nconst errorGas = [\"call\", \"estimateGas\"];\nfunction spelunk(value, requireData) {\n    if (value == null) {\n        return null;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof (value.message) === \"string\" && value.message.match(\"reverted\")) {\n        const data = isHexString(value.data) ? value.data : null;\n        if (!requireData || data) {\n            return { message: value.message, data };\n        }\n    }\n    // Spelunk further...\n    if (typeof (value) === \"object\") {\n        for (const key in value) {\n            const result = spelunk(value[key], requireData);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof (value) === \"string\") {\n        try {\n            return spelunk(JSON.parse(value), requireData);\n        }\n        catch (error) { }\n    }\n    return null;\n}\nfunction checkError(method, error, params) {\n    const transaction = params.transaction || params.signedTransaction;\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\") {\n        const result = spelunk(error, true);\n        if (result) {\n            return result.data;\n        }\n        // Nothing descriptive..\n        logger.throwError(\"missing revert data in call exception; Transaction reverted without a reason string\", Logger.errors.CALL_EXCEPTION, {\n            data: \"0x\", transaction, error\n        });\n    }\n    if (method === \"estimateGas\") {\n        // Try to find something, with a preference on SERVER_ERROR body\n        let result = spelunk(error.body, false);\n        if (result == null) {\n            result = spelunk(error, false);\n        }\n        // Found \"reverted\", this is a CALL_EXCEPTION\n        if (result) {\n            logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                reason: result.message, method, transaction, error\n            });\n        }\n    }\n    // @TODO: Should we spelunk for message too?\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof (error.error.message) === \"string\") {\n        message = error.error.message;\n    }\n    else if (typeof (error.body) === \"string\") {\n        message = error.body;\n    }\n    else if (typeof (error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n    // \"nonce too low\"\n    if (message.match(/nonce (is )?too low/i)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/i)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n    throw error;\n}\nfunction timer(timeout) {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\nfunction getResult(payload) {\n    if (payload.error) {\n        // @TODO: not any\n        const error = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n    return payload.result;\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nconst _constructorGuard = {};\nexport class JsonRpcSigner extends Signer {\n    constructor(constructorGuard, provider, addressOrIndex) {\n        super();\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n        defineReadOnly(this, \"provider\", provider);\n        if (addressOrIndex == null) {\n            addressOrIndex = 0;\n        }\n        if (typeof (addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n        }\n        else if (typeof (addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n        }\n        else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n    connect(provider) {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n    connectUnchecked() {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n    getAddress() {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index]);\n        });\n    }\n    sendUncheckedTransaction(transaction) {\n        transaction = shallowCopy(transaction);\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) {\n                address = address.toLowerCase();\n            }\n            return address;\n        });\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter(this, void 0, void 0, function* () {\n                if (to == null) {\n                    return null;\n                }\n                const address = yield this.provider.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            }));\n        }\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            }\n            else {\n                tx.from = sender;\n            }\n            const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });\n            return this.provider.send(\"eth_sendTransaction\", [hexTx]).then((hash) => {\n                return hash;\n            }, (error) => {\n                if (typeof (error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected transaction\", Logger.errors.ACTION_REJECTED, {\n                        action: \"sendTransaction\",\n                        transaction: tx\n                    });\n                }\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n    signTransaction(transaction) {\n        return logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // This cannot be mined any earlier than any recent block\n            const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n            // Send the transaction\n            const hash = yield this.sendUncheckedTransaction(transaction);\n            try {\n                // Unfortunately, JSON-RPC only provides and opaque transaction hash\n                // for a response, and we need the actual transaction, so we poll\n                // for it; it should show up very quickly\n                return yield poll(() => __awaiter(this, void 0, void 0, function* () {\n                    const tx = yield this.provider.getTransaction(hash);\n                    if (tx === null) {\n                        return undefined;\n                    }\n                    return this.provider._wrapTransaction(tx, hash, blockNumber);\n                }), { oncePoll: this.provider });\n            }\n            catch (error) {\n                error.transactionHash = hash;\n                throw error;\n            }\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? toUtf8Bytes(message) : message);\n            const address = yield this.getAddress();\n            try {\n                return yield this.provider.send(\"personal_sign\", [hexlify(data), address.toLowerCase()]);\n            }\n            catch (error) {\n                if (typeof (error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                        action: \"signMessage\",\n                        from: address,\n                        messageData: message\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    _legacySignMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? toUtf8Bytes(message) : message);\n            const address = yield this.getAddress();\n            try {\n                // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n                return yield this.provider.send(\"eth_sign\", [address.toLowerCase(), hexlify(data)]);\n            }\n            catch (error) {\n                if (typeof (error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                        action: \"_legacySignMessage\",\n                        from: address,\n                        messageData: message\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    _signTypedData(domain, types, value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Populate any ENS names (in-place)\n            const populated = yield _TypedDataEncoder.resolveNames(domain, types, value, (name) => {\n                return this.provider.resolveName(name);\n            });\n            const address = yield this.getAddress();\n            try {\n                return yield this.provider.send(\"eth_signTypedData_v4\", [\n                    address.toLowerCase(),\n                    JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n                ]);\n            }\n            catch (error) {\n                if (typeof (error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                        action: \"_signTypedData\",\n                        from: address,\n                        messageData: { domain: populated.domain, types, value: populated.value }\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    unlock(password) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const provider = this.provider;\n            const address = yield this.getAddress();\n            return provider.send(\"personal_unlockAccount\", [address.toLowerCase(), password, null]);\n        });\n    }\n}\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction) {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return {\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\nconst allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n};\nexport class JsonRpcProvider extends BaseProvider {\n    constructor(url, network) {\n        let networkOrReady = network;\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Default URL\n        if (!url) {\n            url = getStatic(this.constructor, \"defaultUrl\")();\n        }\n        if (typeof (url) === \"string\") {\n            defineReadOnly(this, \"connection\", Object.freeze({\n                url: url\n            }));\n        }\n        else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n        this._nextId = 42;\n    }\n    get _cache() {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = {};\n        }\n        return this._eventLoopCache;\n    }\n    static defaultUrl() {\n        return \"http:/\\/localhost:8545\";\n    }\n    detectNetwork() {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n    _uncachedDetectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield timer(0);\n            let chainId = null;\n            try {\n                chainId = yield this.send(\"eth_chainId\", []);\n            }\n            catch (error) {\n                try {\n                    chainId = yield this.send(\"net_version\", []);\n                }\n                catch (error) { }\n            }\n            if (chainId != null) {\n                const getNetwork = getStatic(this.constructor, \"getNetwork\");\n                try {\n                    return getNetwork(BigNumber.from(chainId).toNumber());\n                }\n                catch (error) {\n                    return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                        chainId: chainId,\n                        event: \"invalidNetwork\",\n                        serverError: error\n                    });\n                }\n            }\n            return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                event: \"noNetwork\"\n            });\n        });\n    }\n    getSigner(addressOrIndex) {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n    getUncheckedSigner(addressOrIndex) {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n    listAccounts() {\n        return this.send(\"eth_accounts\", []).then((accounts) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([\"eth_chainId\", \"eth_blockNumber\"].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n            return result;\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n            throw error;\n        });\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n        return result;\n    }\n    prepareRequest(method, params) {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [\"eth_blockNumber\", []];\n            case \"getGasPrice\":\n                return [\"eth_gasPrice\", []];\n            case \"getBalance\":\n                return [\"eth_getBalance\", [getLowerCase(params.address), params.blockTag]];\n            case \"getTransactionCount\":\n                return [\"eth_getTransactionCount\", [getLowerCase(params.address), params.blockTag]];\n            case \"getCode\":\n                return [\"eth_getCode\", [getLowerCase(params.address), params.blockTag]];\n            case \"getStorageAt\":\n                return [\"eth_getStorageAt\", [getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag]];\n            case \"sendTransaction\":\n                return [\"eth_sendRawTransaction\", [params.signedTransaction]];\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [\"eth_getBlockByNumber\", [params.blockTag, !!params.includeTransactions]];\n                }\n                else if (params.blockHash) {\n                    return [\"eth_getBlockByHash\", [params.blockHash, !!params.includeTransactions]];\n                }\n                return null;\n            case \"getTransaction\":\n                return [\"eth_getTransactionByHash\", [params.transactionHash]];\n            case \"getTransactionReceipt\":\n                return [\"eth_getTransactionReceipt\", [params.transactionHash]];\n            case \"call\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_call\", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];\n            }\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_estimateGas\", [hexlifyTransaction(params.transaction, { from: true })]];\n            }\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [\"eth_getLogs\", [params.filter]];\n            default:\n                break;\n        }\n        return null;\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Legacy networks do not like the type field being passed along (which\n            // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n            if (method === \"call\" || method === \"estimateGas\") {\n                const tx = params.transaction;\n                if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                    // If there are no EIP-1559 properties, it might be non-EIP-1559\n                    if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                        const feeData = yield this.getFeeData();\n                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                            // Network doesn't know about EIP-1559 (and hence type)\n                            params = shallowCopy(params);\n                            params.transaction = shallowCopy(tx);\n                            delete params.transaction.type;\n                        }\n                    }\n                }\n            }\n            const args = this.prepareRequest(method, params);\n            if (args == null) {\n                logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n            }\n            try {\n                return yield this.send(args[0], args[1]);\n            }\n            catch (error) {\n                return checkError(method, error, params);\n            }\n        });\n    }\n    _startEvent(event) {\n        if (event.tag === \"pending\") {\n            this._startPending();\n        }\n        super._startEvent(event);\n    }\n    _startPending() {\n        if (this._pendingFilter != null) {\n            return;\n        }\n        const self = this;\n        const pendingFilter = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n        pendingFilter.then(function (filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [filterId]).then(function (hashes) {\n                    if (self._pendingFilter != pendingFilter) {\n                        return null;\n                    }\n                    let seq = Promise.resolve();\n                    hashes.forEach(function (hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function () {\n                            return self.getTransaction(hash).then(function (tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n                    return seq.then(function () {\n                        return timer(1000);\n                    });\n                }).then(function () {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [filterId]);\n                        return;\n                    }\n                    setTimeout(function () { poll(); }, 0);\n                    return null;\n                }).catch((error) => { });\n            }\n            poll();\n            return filterId;\n        }).catch((error) => { });\n    }\n    _stopEvent(event) {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction, allowExtra) {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) {\n                    allowed[key] = true;\n                }\n            }\n        }\n        checkProperties(transaction, allowed);\n        const result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            const value = hexValue(BigNumber.from(transaction[key]));\n            if (key === \"gasLimit\") {\n                key = \"gas\";\n            }\n            result[key] = value;\n        });\n        [\"from\", \"to\", \"data\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            result[key] = hexlify(transaction[key]);\n        });\n        if (transaction.accessList) {\n            result[\"accessList\"] = accessListify(transaction.accessList);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=json-rpc-provider.js.map","import { _ as __awaiter, D as DEFAULT_ALCHEMY_API_KEY, C as CustomNetworks, a as DEFAULT_NETWORK, N as Network, I as IS_BROWSER, V as VERSION, l as logWarn, d as deepCopy, E as EthersNetwork, g as getAlchemyHttpUrl, b as getAlchemyWsUrl } from './index-643dc9bc.js';\nimport { getNetwork } from '@ethersproject/networks';\nimport { JsonRpcProvider } from '@ethersproject/providers';\nimport { fetchJson } from '@ethersproject/web';\nimport './api/utils';\nimport '@ethersproject/bignumber';\nimport 'axios';\nimport '@ethersproject/abstract-provider';\nimport '@ethersproject/wallet';\nimport '@ethersproject/contracts';\n\n/** Maximum size of a batch on the rpc provider. */\r\nconst DEFAULT_MAX_REQUEST_BATCH_SIZE = 100;\r\n/** Timeout interval before the pending batch is sent. */\r\nconst DEFAULT_REQUEST_BATCH_DELAY_MS = 10;\r\n/**\r\n * Internal class to enqueue requests and automatically send/process batches.\r\n *\r\n * The underlying batching mechanism is loosely based on ethers.js's\r\n * `JsonRpcBatchProvider`.\r\n *\r\n * @internal\r\n */\r\nclass RequestBatcher {\r\n    constructor(sendBatchFn, maxBatchSize = DEFAULT_MAX_REQUEST_BATCH_SIZE) {\r\n        this.sendBatchFn = sendBatchFn;\r\n        this.maxBatchSize = maxBatchSize;\r\n        /**\r\n         * Array of enqueued requests along with the constructed promise handlers for\r\n         * each request.\r\n         */\r\n        this.pendingBatch = [];\r\n    }\r\n    /**\r\n     * Enqueues the provided request. The batch is immediately sent if the maximum\r\n     * batch size is reached. Otherwise, the request is enqueued onto a batch that\r\n     * is sent after 10ms.\r\n     *\r\n     * Returns a promise that resolves with the result of the request.\r\n     */\r\n    enqueueRequest(request) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const inflightRequest = {\r\n                request,\r\n                resolve: undefined,\r\n                reject: undefined\r\n            };\r\n            const promise = new Promise((resolve, reject) => {\r\n                inflightRequest.resolve = resolve;\r\n                inflightRequest.reject = reject;\r\n            });\r\n            this.pendingBatch.push(inflightRequest);\r\n            if (this.pendingBatch.length === this.maxBatchSize) {\r\n                // Send batch immediately if we are at the maximum batch size.\r\n                void this.sendBatchRequest();\r\n            }\r\n            else if (!this.pendingBatchTimer) {\r\n                // Schedule batch for next event loop + short duration\r\n                this.pendingBatchTimer = setTimeout(() => this.sendBatchRequest(), DEFAULT_REQUEST_BATCH_DELAY_MS);\r\n            }\r\n            return promise;\r\n        });\r\n    }\r\n    /**\r\n     * Sends the currently queued batches and resets the batch and timer. Processes\r\n     * the batched response results back to the original promises.\r\n     */\r\n    sendBatchRequest() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Get the current batch and clear it, so new requests\r\n            // go into the next batch\r\n            const batch = this.pendingBatch;\r\n            this.pendingBatch = [];\r\n            if (this.pendingBatchTimer) {\r\n                clearTimeout(this.pendingBatchTimer);\r\n                this.pendingBatchTimer = undefined;\r\n            }\r\n            // Get the request as an array of requests\r\n            const request = batch.map(inflight => inflight.request);\r\n            return this.sendBatchFn(request).then(result => {\r\n                // For each result, feed it to the correct Promise, depending\r\n                // on whether it was a success or error\r\n                batch.forEach((inflightRequest, index) => {\r\n                    const payload = result[index];\r\n                    if (payload.error) {\r\n                        const error = new Error(payload.error.message);\r\n                        error.code = payload.error.code;\r\n                        error.data = payload.error.data;\r\n                        inflightRequest.reject(error);\r\n                    }\r\n                    else {\r\n                        inflightRequest.resolve(payload.result);\r\n                    }\r\n                });\r\n            }, error => {\r\n                batch.forEach(inflightRequest => {\r\n                    inflightRequest.reject(error);\r\n                });\r\n            });\r\n        });\r\n    }\r\n}\n\n/**\r\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getProvider()}.\r\n *\r\n * @public\r\n */\r\nclass AlchemyProvider extends JsonRpcProvider {\r\n    /** @internal */\r\n    constructor(config) {\r\n        // Normalize the API Key to a string.\r\n        const apiKey = AlchemyProvider.getApiKey(config.apiKey);\r\n        // Generate our own connection info with the correct endpoint URLs.\r\n        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\r\n        let connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'http');\r\n        // If a hardcoded url was specified in the config, use that instead of the\r\n        // provided apiKey or network.\r\n        if (config.url !== undefined) {\r\n            connection.url = config.url;\r\n        }\r\n        connection.throttleLimit = config.maxRetries;\r\n        // Add user provided overrides if they exist.\r\n        if (config.connectionInfoOverrides) {\r\n            connection = Object.assign(Object.assign({}, connection), config.connectionInfoOverrides);\r\n        }\r\n        // Normalize the Alchemy named network input to the network names used by\r\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\r\n        // correctly set the network.\r\n        const ethersNetwork = EthersNetwork[alchemyNetwork];\r\n        if (!ethersNetwork) {\r\n            throw new Error(`Unsupported network: ${alchemyNetwork}`);\r\n        }\r\n        super(connection, ethersNetwork);\r\n        this.apiKey = config.apiKey;\r\n        this.maxRetries = config.maxRetries;\r\n        this.batchRequests = config.batchRequests;\r\n        // TODO: support individual headers when calling batch\r\n        const batcherConnection = Object.assign(Object.assign({}, this.connection), { headers: Object.assign(Object.assign({}, this.connection.headers), { 'Alchemy-Ethers-Sdk-Method': 'batchSend' }) });\r\n        const sendBatchFn = (requests) => {\r\n            return fetchJson(batcherConnection, JSON.stringify(requests));\r\n        };\r\n        this.batcher = new RequestBatcher(sendBatchFn);\r\n        this.modifyFormatter();\r\n    }\r\n    /**\r\n     * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\r\n     * ethers.js. Returns the API key for an Alchemy provider.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getApiKey(apiKey) {\r\n        if (apiKey == null) {\r\n            return DEFAULT_ALCHEMY_API_KEY;\r\n        }\r\n        if (apiKey && typeof apiKey !== 'string') {\r\n            throw new Error(`Invalid apiKey '${apiKey}' provided. apiKey must be a string.`);\r\n        }\r\n        return apiKey;\r\n    }\r\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getNetwork(network) {\r\n        if (typeof network === 'string' && network in CustomNetworks) {\r\n            return CustomNetworks[network];\r\n        }\r\n        // Call the standard ethers.js getNetwork method for other networks.\r\n        return getNetwork(network);\r\n    }\r\n    /**\r\n     * Converts the `Networkish` input to the network enum used by Alchemy.\r\n     *\r\n     * @internal\r\n     */\r\n    static getAlchemyNetwork(network) {\r\n        if (network === undefined) {\r\n            return DEFAULT_NETWORK;\r\n        }\r\n        if (typeof network === 'number') {\r\n            throw new Error(`Invalid network '${network}' provided. Network must be a string.`);\r\n        }\r\n        // Guaranteed that `typeof network === 'string`.\r\n        const isValidNetwork = Object.values(Network).includes(network);\r\n        if (!isValidNetwork) {\r\n            throw new Error(`Invalid network '${network}' provided. Network must be one of: ` +\r\n                `${Object.values(Network).join(', ')}.`);\r\n        }\r\n        return network;\r\n    }\r\n    /**\r\n     * Returns a {@link ConnectionInfo} object compatible with ethers that contains\r\n     * the correct URLs for Alchemy.\r\n     *\r\n     * @internal\r\n     */\r\n    static getAlchemyConnectionInfo(network, apiKey, type) {\r\n        const url = type === 'http'\r\n            ? getAlchemyHttpUrl(network, apiKey)\r\n            : getAlchemyWsUrl(network, apiKey);\r\n        return {\r\n            headers: IS_BROWSER\r\n                ? {\r\n                    'Alchemy-Ethers-Sdk-Version': VERSION\r\n                }\r\n                : {\r\n                    'Alchemy-Ethers-Sdk-Version': VERSION,\r\n                    'Accept-Encoding': 'gzip'\r\n                },\r\n            allowGzip: true,\r\n            url\r\n        };\r\n    }\r\n    /**\r\n     * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\r\n     * method is called when calling methods on the parent class `BaseProvider`.\r\n     *\r\n     * @override\r\n     */\r\n    detectNetwork() {\r\n        const _super = Object.create(null, {\r\n            detectNetwork: { get: () => super.detectNetwork }\r\n        });\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let network = this.network;\r\n            if (network == null) {\r\n                network = yield _super.detectNetwork.call(this);\r\n                if (!network) {\r\n                    throw new Error('No network detected');\r\n                }\r\n            }\r\n            return network;\r\n        });\r\n    }\r\n    _startPending() {\r\n        logWarn('WARNING: Alchemy Provider does not support pending filters');\r\n    }\r\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\r\n    isCommunityResource() {\r\n        return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\r\n    }\r\n    /**\r\n     * Overrides the base {@link JsonRpcProvider.send} method to implement custom\r\n     * logic for sending requests to Alchemy.\r\n     *\r\n     * @param method The method name to use for the request.\r\n     * @param params The parameters to use for the request.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Add headers for `perform()` override.\r\n    send(method, params) {\r\n        return this._send(method, params, 'send');\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `JsonRpcProvider.send()`.\r\n     *\r\n     * This method is copied over directly in order to implement custom headers\r\n     *\r\n     * @internal\r\n     */\r\n    _send(method, params, methodName) {\r\n        const request = {\r\n            method,\r\n            params,\r\n            id: this._nextId++,\r\n            jsonrpc: '2.0'\r\n        };\r\n        // START MODIFIED CODE\r\n        const connection = Object.assign({}, this.connection);\r\n        connection.headers['Alchemy-Ethers-Sdk-Method'] = methodName;\r\n        if (this.batchRequests) {\r\n            return this.batcher.enqueueRequest(request);\r\n        }\r\n        // END MODIFIED CODE\r\n        this.emit('debug', {\r\n            action: 'request',\r\n            request: deepCopy(request),\r\n            provider: this\r\n        });\r\n        // We can expand this in the future to any call, but for now these\r\n        // are the biggest wins and do not require any serializing parameters.\r\n        const cache = ['eth_chainId', 'eth_blockNumber'].indexOf(method) >= 0;\r\n        if (cache && this._cache[method]) {\r\n            return this._cache[method];\r\n        }\r\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then(result => {\r\n            this.emit('debug', {\r\n                action: 'response',\r\n                request,\r\n                response: result,\r\n                provider: this\r\n            });\r\n            return result;\r\n        }, error => {\r\n            this.emit('debug', {\r\n                action: 'response',\r\n                error,\r\n                request,\r\n                provider: this\r\n            });\r\n            throw error;\r\n        });\r\n        // Cache the fetch, but clear it on the next event loop\r\n        if (cache) {\r\n            this._cache[method] = result;\r\n            setTimeout(() => {\r\n                // @ts-ignore - This is done by ethers.\r\n                this._cache[method] = null;\r\n            }, 0);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Overrides the base `Formatter` class inherited from ethers to support\r\n     * returning custom fields in Ethers response types.\r\n     *\r\n     * For context, ethers has a `Formatter` class that is used to format the\r\n     * response from a JSON-RPC request. Any fields that are not defined in the\r\n     * `Formatter` class are removed from the returned response. By modifying the\r\n     * `Formatter` class in this method, we can add support for fields that are\r\n     * not defined in ethers.\r\n     */\r\n    modifyFormatter() {\r\n        this.formatter.formats['receiptLog']['removed'] = val => {\r\n            if (typeof val === 'boolean') {\r\n                return val;\r\n            }\r\n            return undefined;\r\n        };\r\n    }\r\n}\r\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * Original code copied over from ether.js's\r\n * `@ethersproject/web/src.ts/index.ts`. Used to support\r\n * {@link AlchemyProvider._send}, which is also copied over.\r\n */\r\nfunction getResult(payload) {\r\n    if (payload.error) {\r\n        const error = new Error(payload.error.message);\r\n        error.code = payload.error.code;\r\n        error.data = payload.error.data;\r\n        throw error;\r\n    }\r\n    return payload.result;\r\n}\n\nexport { AlchemyProvider };\n//# sourceMappingURL=alchemy-provider-0066b792.js.map\n"],"names":["decode","textData","atob","data","i","length","push","charCodeAt","arrayify","encode","String","fromCharCode","btoa","flat","array","depth","result","forEach","flatDeep","arr","call","val","Array","isArray","fromEntries","value","decode_arithmetic","bytes","pos","u16","symbol_count","total","acc","skip","pos_payload","read_width","read_buffer","read_bit","N","FULL","Math","pow","HALF","QRTR","MASK","register","symbols","low","range","floor","start","end","mid","a","b","offset","map","x","read_payload","v","read_compressed_payload","signed","read_counts","n","next","read_ascending","read_deltas","read_member_array","lookup","vX","vN","j","read_mapped_map","ret","w","read_linear_table","read_replacement_table","read_zero_terminated_array","read_transposed","m","fill","dx","dy","ys","slice","_","j_dy","y","read_emoji_trie","sorted","sort","read","branches","keys","set","Set","node","size","temp","valid","fe0f","save","check","getData","r","VALID","IGNORED","MAPPED","EMOJI_ROOT","HYPHEN","UNDERSCORE","explode_cp","name","toUtf8CodePoints","filter_fe0f","cps","filter","cp","ens_normalize_post_check","label","split","lastIndexOf","Error","every","err","message","ens_normalize","normalize","emoji_filter","input","reverse","output","emoji","consume_emoji_reversed","pop","has","toString","toUpperCase","nfc","fromCodePoint","s","eaten","_a","saved","stack","find","splice","logger","Logger","version","Zeros","Uint8Array","checkComponent","comp","ensNameSplit","toUtf8Bytes","comps","last","d","namehash","logger$5","throwArgumentError","keccak256","concat","hexlify","dnsEncode","AddressZero","Zero","BigNumber","from","HashZero","TransactionTypes","handleAddress","getAddress","handleNumber","computeAddress","key","publicKey","computePublicKey","hexDataSlice","recoverAddress","digest","signature","recoverPublicKey","formatNumber","stripZeros","toHexString","accessSetify","addr","storageKeys","address","storageKey","index","hexDataLength","toLowerCase","accessListify","Object","reduce","accum","localeCompare","formatAccessList","_serializeEip1559","transaction","gasPrice","maxFeePerGas","eq","logger$4","fields","chainId","nonce","maxPriorityFeePerGas","gasLimit","to","accessList","sig","splitSignature","recoveryParam","hexConcat","RLP.encode","_serializeEip2930","_parseEipSignature","tx","serialize","recid","toNumber","error","hexZeroPad","_parseEip1559","payload","RLP.decode","type","hash","_parseEip2930","_parse","rawTransaction","isZero","raw","parse","throwError","errors","UNSUPPORTED_OPERATION","operation","transactionType","isRenetworkable","renetwork","ethDefaultProvider","network","func","providers","options","providerList","InfuraProvider","infura","EtherscanProvider","etherscan","AlchemyProvider","alchemy","PocketProvider","pocket","provider","indexOf","CloudflareProvider","cloudflare","AnkrProvider","ankr","FallbackProvider","quorum","etcDefaultProvider","url","JsonRpcProvider","homestead","ensAddress","_defaultProvider","ropsten","classicMordor","networks","unspecified","mainnet","morden","testnet","rinkeby","kovan","goerli","kintsugi","sepolia","classic","classicMorden","classicTestnet","classicKotti","xdai","matic","maticmum","optimism","arbitrum","bnb","bnbt","getNetwork","standard","logger$3","defaultProvider","BaseX","constructor","alphabet","defineReadOnly","this","charAt","_alphabetMap","source","digits","carry","base","string","k","_leader","q","TypeError","byte","Base58","sha256","update","ALPHABET","ALPHABET_MAP","z","polymodStep","pre","prefixChk","prefix","chk","c","words","LIMIT","__decode","str","lowered","uppered","wordChars","decodeUnsafe","res","apply","arguments","convert","inBits","outBits","pad","bits","maxV","toWordsUnsafe","toWords","fromWordsUnsafe","fromWords","bech32$1","Formatter","formats","getDefaultFormats","bind","bigNumber","blockTag","hex","number","strictData","allowNull","blockHash","blockNumber","transactionIndex","confirmations","uint256","creates","transactionRequest","receiptLog","transactionHash","topics","arrayOf","logIndex","receipt","contractAddress","root","gasUsed","logsBloom","logs","cumulativeGasUsed","effectiveGasPrice","status","block","parentHash","timestamp","difficulty","miner","extraData","transactions","baseFeePerGas","blockWithTransactions","shallowCopy","transactionResponse","fromBlock","toBlock","filterLog","removed","boolean","allowFalsish","strict","substring","isHexString","callAddress","getContractAddress","hexValue","_block","format","author","_difficulty","gas","networkId","parseInt","replace","parseTransaction","logger$2","byzantium","object","checkKey","checkValue","nullValue","replaceValue","__awaiter","thisArg","_arguments","P","generator","adopt","resolve","Promise","reject","fulfilled","step","e","rejected","done","then","MAX_CCIP_REDIRECTS","checkTopic","topic","logger$1","serializeTopics","unique","join","deserializeTopics","getEventTag","eventName","ForkEvent","isForkEvent","warn","getTime","Date","stall","duration","setTimeout","PollableEvents","Event","tag","listener","once","_lastBlockNumber","_inflight","event","pollable","coinInfos","symbol","p2pkh","p2sh","ilk","bytes32ify","base58Encode","matcherIpfs","RegExp","matchers","_parseString","toUtf8String","_parseBytes","getIpfsLink","link","match","numPad","padded","bytesPad","ceil","encodeBytes","datas","byteCount","Resolver","resolvedAddress","formatter","supportsWildcard","_supportsEip2544","catch","code","CALL_EXCEPTION","_fetch","selector","parameters","ccipReadEnabled","parseBytes","_fetchBytes","_getAddress","coinType","hexBytes","coinInfo","bech32","unshift","getAvatar","linkage","content","avatar","getText","scheme","owner","_resolvedAddress","tokenId","tokenOwner","balance","metadataUrl","metadata","fetchJson","JSON","stringify","imageUrl","image","ipfs","getContentHash","ipns","swarm","skynet","urlSafe","base64Encode","keyBytes","defaultFormatter","nextPollId","BaseProvider","Provider","super","_events","_emitted","disableCcipRead","getFormatter","anyNetwork","detectNetwork","_networkPromise","_ready","knownNetwork","getStatic","emit","_maxInternalBlockNumber","_maxFilterBlockRange","_pollingInterval","_fastQueryDate","_network","UNKNOWN_ERROR","ready","poll","NETWORK_ERROR","ccipReadFetch","calldata","urls","sender","errorMessages","href","json","errorPassThrough","response","statusCode","errorMessage","SERVER_ERROR","_getInternalBlockNumber","maxAge","_internalBlockNumber","internalBlockNumber","respTime","reqTime","checkInternalBlockNumber","resolveProperties","perform","networkError","_setFastBlockNumber","pollId","runners","pollingInterval","abs","makeError","previousBlockNumber","eventBlockNumber","runner","getTransactionReceipt","minFromBlock","getLogs","log","all","resetEventsBlock","polling","currentNetwork","_fastBlockNumber","_fastBlockNumberPromise","detectedNetwork","_poller","setInterval","_bootstrapPoll","clearInterval","_getFastBlockNumber","now","getBlockNumber","waitForTransaction","timeout","_waitForTransaction","replaceable","cancelFuncs","alreadyDone","minedHandler","on","removeListener","lastBlockNumber","startBlock","scannedBlock","replaceHandler","getTransactionCount","mined","getTransaction","getBlockWithTransactions","ti","reason","TRANSACTION_REPLACED","cancelled","replacement","_wrapTransaction","timer","TIMEOUT","unref","clearTimeout","getGasPrice","method","getBalance","addressOrName","params","_getBlockTag","getCode","getStorageAt","position","p","expectedHash","returnedHash","wait","confirms","sendTransaction","signedTransaction","hexTx","t","_getTransactionRequest","values","_getFilter","_call","attempt","redirects","txSender","urlsOffset","urlsLength","urlsData","u","callbackSelector","ccipResult","resolved","estimateGas","resolveName","_getBlock","blockHashOrBlockTag","includeTransactions","blockWithTxs","oncePoll","getBlock","getEtherPrice","getResolver","currentName","_getResolver","resolver","addrData","lookupAddress","resolverAddr","nameOrAddress","resolverAddress","NOT_IMPLEMENTED","_startEvent","_stopEvent","_addEventListener","args","stopped","eventTag","listenerCount","listeners","off","removeAllListeners","found","errorGas","spelunk","requireData","checkError","body","UNPREDICTABLE_GAS_LIMIT","responseText","INSUFFICIENT_FUNDS","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","getResult","getLowerCase","_constructorGuard","JsonRpcSigner","Signer","constructorGuard","addressOrIndex","connect","connectUnchecked","UncheckedJsonRpcSigner","_address","_index","send","accounts","sendUncheckedTransaction","fromAddress","estimate","hexlifyTransaction","ACTION_REJECTED","action","signTransaction","signMessage","messageData","_legacySignMessage","_signTypedData","domain","types","populated","_TypedDataEncoder","resolveNames","getPayload","unlock","password","allowedTransactionKeys","networkOrReady","freeze","_nextId","_cache","_eventLoopCache","defaultUrl","_uncachedDetectNetwork","serverError","getSigner","getUncheckedSigner","listAccounts","request","id","jsonrpc","deepCopy","cache","connection","prepareRequest","feeData","getFeeData","_startPending","_pendingFilter","self","pendingFilter","filterId","hashes","seq","allowExtra","allowed","checkProperties","DEFAULT_MAX_REQUEST_BATCH_SIZE","DEFAULT_REQUEST_BATCH_DELAY_MS","RequestBatcher","sendBatchFn","maxBatchSize","pendingBatch","enqueueRequest","inflightRequest","promise","sendBatchRequest","pendingBatchTimer","batch","inflight","config","apiKey","getApiKey","alchemyNetwork","getAlchemyNetwork","getAlchemyConnectionInfo","throttleLimit","maxRetries","connectionInfoOverrides","assign","ethersNetwork","EthersNetwork","batchRequests","batcherConnection","headers","requests","batcher","modifyFormatter","DEFAULT_ALCHEMY_API_KEY","CustomNetworks","DEFAULT_NETWORK","isValidNetwork","Network","includes","getAlchemyHttpUrl","getAlchemyWsUrl","IS_BROWSER","VERSION","allowGzip","_super","create","get","logWarn","isCommunityResource","_send","methodName"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]}