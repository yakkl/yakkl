const sides=["top","right","bottom","left"];const min=Math.min;const max=Math.max;const round=Math.round;const floor=Math.floor;const createCoords=v=>({x:v,y:v});const oppositeSideMap={left:"right",right:"left",bottom:"top",top:"bottom"};const oppositeAlignmentMap={start:"end",end:"start"};function clamp(start,value,end){return max(start,min(value,end))}function evaluate(value,param){return typeof value==="function"?value(param):value}function getSide(placement){return placement.split("-")[0]}function getAlignment(placement){return placement.split("-")[1]}function getOppositeAxis(axis){return axis==="x"?"y":"x"}function getAxisLength(axis){return axis==="y"?"height":"width"}function getSideAxis(placement){return["top","bottom"].includes(getSide(placement))?"y":"x"}function getAlignmentAxis(placement){return getOppositeAxis(getSideAxis(placement))}function getAlignmentSides(placement,rects,rtl){if(rtl===void 0){rtl=false}const alignment=getAlignment(placement);const alignmentAxis=getAlignmentAxis(placement);const length=getAxisLength(alignmentAxis);let mainAlignmentSide=alignmentAxis==="x"?alignment===(rtl?"end":"start")?"right":"left":alignment==="start"?"bottom":"top";if(rects.reference[length]>rects.floating[length]){mainAlignmentSide=getOppositePlacement(mainAlignmentSide)}return[mainAlignmentSide,getOppositePlacement(mainAlignmentSide)]}function getExpandedPlacements(placement){const oppositePlacement=getOppositePlacement(placement);return[getOppositeAlignmentPlacement(placement),oppositePlacement,getOppositeAlignmentPlacement(oppositePlacement)]}function getOppositeAlignmentPlacement(placement){return placement.replace(/start|end/g,alignment=>oppositeAlignmentMap[alignment])}function getSideList(side,isStart,rtl){const lr=["left","right"];const rl=["right","left"];const tb=["top","bottom"];const bt=["bottom","top"];switch(side){case"top":case"bottom":if(rtl)return isStart?rl:lr;return isStart?lr:rl;case"left":case"right":return isStart?tb:bt;default:return[]}}function getOppositeAxisPlacements(placement,flipAlignment,direction,rtl){const alignment=getAlignment(placement);let list=getSideList(getSide(placement),direction==="start",rtl);if(alignment){list=list.map(side=>side+"-"+alignment);if(flipAlignment){list=list.concat(list.map(getOppositeAlignmentPlacement))}}return list}function getOppositePlacement(placement){return placement.replace(/left|right|bottom|top/g,side=>oppositeSideMap[side])}function expandPaddingObject(padding){return{top:0,right:0,bottom:0,left:0,...padding}}function getPaddingObject(padding){return typeof padding!=="number"?expandPaddingObject(padding):{top:padding,right:padding,bottom:padding,left:padding}}function rectToClientRect(rect){const{x:x,y:y,width:width,height:height}=rect;return{width:width,height:height,top:y,left:x,right:x+width,bottom:y+height,x:x,y:y}}function computeCoordsFromPlacement(_ref,placement,rtl){let{reference:reference,floating:floating}=_ref;const sideAxis=getSideAxis(placement);const alignmentAxis=getAlignmentAxis(placement);const alignLength=getAxisLength(alignmentAxis);const side=getSide(placement);const isVertical=sideAxis==="y";const commonX=reference.x+reference.width/2-floating.width/2;const commonY=reference.y+reference.height/2-floating.height/2;const commonAlign=reference[alignLength]/2-floating[alignLength]/2;let coords;switch(side){case"top":coords={x:commonX,y:reference.y-floating.height};break;case"bottom":coords={x:commonX,y:reference.y+reference.height};break;case"right":coords={x:reference.x+reference.width,y:commonY};break;case"left":coords={x:reference.x-floating.width,y:commonY};break;default:coords={x:reference.x,y:reference.y}}switch(getAlignment(placement)){case"start":coords[alignmentAxis]-=commonAlign*(rtl&&isVertical?-1:1);break;case"end":coords[alignmentAxis]+=commonAlign*(rtl&&isVertical?-1:1);break}return coords}const computePosition$1=async(reference,floating,config)=>{const{placement:placement="bottom",strategy:strategy="absolute",middleware:middleware=[],platform:platform2}=config;const validMiddleware=middleware.filter(Boolean);const rtl=await(platform2.isRTL==null?void 0:platform2.isRTL(floating));let rects=await platform2.getElementRects({reference:reference,floating:floating,strategy:strategy});let{x:x,y:y}=computeCoordsFromPlacement(rects,placement,rtl);let statefulPlacement=placement;let middlewareData={};let resetCount=0;for(let i=0;i<validMiddleware.length;i++){const{name:name,fn:fn}=validMiddleware[i];const{x:nextX,y:nextY,data:data,reset:reset}=await fn({x:x,y:y,initialPlacement:placement,placement:statefulPlacement,strategy:strategy,middlewareData:middlewareData,rects:rects,platform:platform2,elements:{reference:reference,floating:floating}});x=nextX!=null?nextX:x;y=nextY!=null?nextY:y;middlewareData={...middlewareData,[name]:{...middlewareData[name],...data}};if(reset&&resetCount<=50){resetCount++;if(typeof reset==="object"){if(reset.placement){statefulPlacement=reset.placement}if(reset.rects){rects=reset.rects===true?await platform2.getElementRects({reference:reference,floating:floating,strategy:strategy}):reset.rects}({x:x,y:y}=computeCoordsFromPlacement(rects,statefulPlacement,rtl))}i=-1}}return{x:x,y:y,placement:statefulPlacement,strategy:strategy,middlewareData:middlewareData}};async function detectOverflow(state,options){var _await$platform$isEle;if(options===void 0){options={}}const{x:x,y:y,platform:platform2,rects:rects,elements:elements,strategy:strategy}=state;const{boundary:boundary="clippingAncestors",rootBoundary:rootBoundary="viewport",elementContext:elementContext="floating",altBoundary:altBoundary=false,padding:padding=0}=evaluate(options,state);const paddingObject=getPaddingObject(padding);const altContext=elementContext==="floating"?"reference":"floating";const element=elements[altBoundary?altContext:elementContext];const clippingClientRect=rectToClientRect(await platform2.getClippingRect({element:((_await$platform$isEle=await(platform2.isElement==null?void 0:platform2.isElement(element)))!=null?_await$platform$isEle:true)?element:element.contextElement||await(platform2.getDocumentElement==null?void 0:platform2.getDocumentElement(elements.floating)),boundary:boundary,rootBoundary:rootBoundary,strategy:strategy}));const rect=elementContext==="floating"?{x:x,y:y,width:rects.floating.width,height:rects.floating.height}:rects.reference;const offsetParent=await(platform2.getOffsetParent==null?void 0:platform2.getOffsetParent(elements.floating));const offsetScale=await(platform2.isElement==null?void 0:platform2.isElement(offsetParent))?await(platform2.getScale==null?void 0:platform2.getScale(offsetParent))||{x:1,y:1}:{x:1,y:1};const elementClientRect=rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect?await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({elements:elements,rect:rect,offsetParent:offsetParent,strategy:strategy}):rect);return{top:(clippingClientRect.top-elementClientRect.top+paddingObject.top)/offsetScale.y,bottom:(elementClientRect.bottom-clippingClientRect.bottom+paddingObject.bottom)/offsetScale.y,left:(clippingClientRect.left-elementClientRect.left+paddingObject.left)/offsetScale.x,right:(elementClientRect.right-clippingClientRect.right+paddingObject.right)/offsetScale.x}}const arrow$1=options=>({name:"arrow",options:options,async fn(state){const{x:x,y:y,placement:placement,rects:rects,platform:platform2,elements:elements,middlewareData:middlewareData}=state;const{element:element,padding:padding=0}=evaluate(options,state)||{};if(element==null){return{}}const paddingObject=getPaddingObject(padding);const coords={x:x,y:y};const axis=getAlignmentAxis(placement);const length=getAxisLength(axis);const arrowDimensions=await platform2.getDimensions(element);const isYAxis=axis==="y";const minProp=isYAxis?"top":"left";const maxProp=isYAxis?"bottom":"right";const clientProp=isYAxis?"clientHeight":"clientWidth";const endDiff=rects.reference[length]+rects.reference[axis]-coords[axis]-rects.floating[length];const startDiff=coords[axis]-rects.reference[axis];const arrowOffsetParent=await(platform2.getOffsetParent==null?void 0:platform2.getOffsetParent(element));let clientSize=arrowOffsetParent?arrowOffsetParent[clientProp]:0;if(!clientSize||!(await(platform2.isElement==null?void 0:platform2.isElement(arrowOffsetParent)))){clientSize=elements.floating[clientProp]||rects.floating[length]}const centerToReference=endDiff/2-startDiff/2;const largestPossiblePadding=clientSize/2-arrowDimensions[length]/2-1;const minPadding=min(paddingObject[minProp],largestPossiblePadding);const maxPadding=min(paddingObject[maxProp],largestPossiblePadding);const min$1=minPadding;const max2=clientSize-arrowDimensions[length]-maxPadding;const center=clientSize/2-arrowDimensions[length]/2+centerToReference;const offset2=clamp(min$1,center,max2);const shouldAddOffset=!middlewareData.arrow&&getAlignment(placement)!=null&&center!==offset2&&rects.reference[length]/2-(center<min$1?minPadding:maxPadding)-arrowDimensions[length]/2<0;const alignmentOffset=shouldAddOffset?center<min$1?center-min$1:center-max2:0;return{[axis]:coords[axis]+alignmentOffset,data:{[axis]:offset2,centerOffset:center-offset2-alignmentOffset,...shouldAddOffset&&{alignmentOffset:alignmentOffset}},reset:shouldAddOffset}}});const flip$1=function(options){if(options===void 0){options={}}return{name:"flip",options:options,async fn(state){var _middlewareData$arrow,_middlewareData$flip;const{placement:placement,middlewareData:middlewareData,rects:rects,initialPlacement:initialPlacement,platform:platform2,elements:elements}=state;const{mainAxis:checkMainAxis=true,crossAxis:checkCrossAxis=true,fallbackPlacements:specifiedFallbackPlacements,fallbackStrategy:fallbackStrategy="bestFit",fallbackAxisSideDirection:fallbackAxisSideDirection="none",flipAlignment:flipAlignment=true,...detectOverflowOptions}=evaluate(options,state);if((_middlewareData$arrow=middlewareData.arrow)!=null&&_middlewareData$arrow.alignmentOffset){return{}}const side=getSide(placement);const initialSideAxis=getSideAxis(initialPlacement);const isBasePlacement=getSide(initialPlacement)===initialPlacement;const rtl=await(platform2.isRTL==null?void 0:platform2.isRTL(elements.floating));const fallbackPlacements=specifiedFallbackPlacements||(isBasePlacement||!flipAlignment?[getOppositePlacement(initialPlacement)]:getExpandedPlacements(initialPlacement));const hasFallbackAxisSideDirection=fallbackAxisSideDirection!=="none";if(!specifiedFallbackPlacements&&hasFallbackAxisSideDirection){fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement,flipAlignment,fallbackAxisSideDirection,rtl))}const placements=[initialPlacement,...fallbackPlacements];const overflow=await detectOverflow(state,detectOverflowOptions);const overflows=[];let overflowsData=((_middlewareData$flip=middlewareData.flip)==null?void 0:_middlewareData$flip.overflows)||[];if(checkMainAxis){overflows.push(overflow[side])}if(checkCrossAxis){const sides2=getAlignmentSides(placement,rects,rtl);overflows.push(overflow[sides2[0]],overflow[sides2[1]])}overflowsData=[...overflowsData,{placement:placement,overflows:overflows}];if(!overflows.every(side2=>side2<=0)){var _middlewareData$flip2,_overflowsData$filter;const nextIndex=(((_middlewareData$flip2=middlewareData.flip)==null?void 0:_middlewareData$flip2.index)||0)+1;const nextPlacement=placements[nextIndex];if(nextPlacement){const ignoreCrossAxisOverflow=checkCrossAxis==="alignment"?initialSideAxis!==getSideAxis(nextPlacement):false;if(!ignoreCrossAxisOverflow||overflowsData.every(d=>d.overflows[0]>0&&getSideAxis(d.placement)===initialSideAxis)){return{data:{index:nextIndex,overflows:overflowsData},reset:{placement:nextPlacement}}}}let resetPlacement=(_overflowsData$filter=overflowsData.filter(d=>d.overflows[0]<=0).sort((a,b)=>a.overflows[1]-b.overflows[1])[0])==null?void 0:_overflowsData$filter.placement;if(!resetPlacement){switch(fallbackStrategy){case"bestFit":{var _overflowsData$filter2;const placement2=(_overflowsData$filter2=overflowsData.filter(d=>{if(hasFallbackAxisSideDirection){const currentSideAxis=getSideAxis(d.placement);return currentSideAxis===initialSideAxis||currentSideAxis==="y"}return true}).map(d=>[d.placement,d.overflows.filter(overflow2=>overflow2>0).reduce((acc,overflow2)=>acc+overflow2,0)]).sort((a,b)=>a[1]-b[1])[0])==null?void 0:_overflowsData$filter2[0];if(placement2){resetPlacement=placement2}break}case"initialPlacement":resetPlacement=initialPlacement;break}}if(placement!==resetPlacement){return{reset:{placement:resetPlacement}}}}return{}}}};function getSideOffsets(overflow,rect){return{top:overflow.top-rect.height,right:overflow.right-rect.width,bottom:overflow.bottom-rect.height,left:overflow.left-rect.width}}function isAnySideFullyClipped(overflow){return sides.some(side=>overflow[side]>=0)}const hide$1=function(options){if(options===void 0){options={}}return{name:"hide",options:options,async fn(state){const{rects:rects}=state;const{strategy:strategy="referenceHidden",...detectOverflowOptions}=evaluate(options,state);switch(strategy){case"referenceHidden":{const overflow=await detectOverflow(state,{...detectOverflowOptions,elementContext:"reference"});const offsets=getSideOffsets(overflow,rects.reference);return{data:{referenceHiddenOffsets:offsets,referenceHidden:isAnySideFullyClipped(offsets)}}}case"escaped":{const overflow=await detectOverflow(state,{...detectOverflowOptions,altBoundary:true});const offsets=getSideOffsets(overflow,rects.floating);return{data:{escapedOffsets:offsets,escaped:isAnySideFullyClipped(offsets)}}}default:{return{}}}}}};async function convertValueToCoords(state,options){const{placement:placement,platform:platform2,elements:elements}=state;const rtl=await(platform2.isRTL==null?void 0:platform2.isRTL(elements.floating));const side=getSide(placement);const alignment=getAlignment(placement);const isVertical=getSideAxis(placement)==="y";const mainAxisMulti=["left","top"].includes(side)?-1:1;const crossAxisMulti=rtl&&isVertical?-1:1;const rawValue=evaluate(options,state);let{mainAxis:mainAxis,crossAxis:crossAxis,alignmentAxis:alignmentAxis}=typeof rawValue==="number"?{mainAxis:rawValue,crossAxis:0,alignmentAxis:null}:{mainAxis:rawValue.mainAxis||0,crossAxis:rawValue.crossAxis||0,alignmentAxis:rawValue.alignmentAxis};if(alignment&&typeof alignmentAxis==="number"){crossAxis=alignment==="end"?alignmentAxis*-1:alignmentAxis}return isVertical?{x:crossAxis*crossAxisMulti,y:mainAxis*mainAxisMulti}:{x:mainAxis*mainAxisMulti,y:crossAxis*crossAxisMulti}}const offset$1=function(options){if(options===void 0){options=0}return{name:"offset",options:options,async fn(state){var _middlewareData$offse,_middlewareData$arrow;const{x:x,y:y,placement:placement,middlewareData:middlewareData}=state;const diffCoords=await convertValueToCoords(state,options);if(placement===((_middlewareData$offse=middlewareData.offset)==null?void 0:_middlewareData$offse.placement)&&(_middlewareData$arrow=middlewareData.arrow)!=null&&_middlewareData$arrow.alignmentOffset){return{}}return{x:x+diffCoords.x,y:y+diffCoords.y,data:{...diffCoords,placement:placement}}}}};const shift$1=function(options){if(options===void 0){options={}}return{name:"shift",options:options,async fn(state){const{x:x,y:y,placement:placement}=state;const{mainAxis:checkMainAxis=true,crossAxis:checkCrossAxis=false,limiter:limiter={fn:_ref=>{let{x:x2,y:y2}=_ref;return{x:x2,y:y2}}},...detectOverflowOptions}=evaluate(options,state);const coords={x:x,y:y};const overflow=await detectOverflow(state,detectOverflowOptions);const crossAxis=getSideAxis(getSide(placement));const mainAxis=getOppositeAxis(crossAxis);let mainAxisCoord=coords[mainAxis];let crossAxisCoord=coords[crossAxis];if(checkMainAxis){const minSide=mainAxis==="y"?"top":"left";const maxSide=mainAxis==="y"?"bottom":"right";const min2=mainAxisCoord+overflow[minSide];const max2=mainAxisCoord-overflow[maxSide];mainAxisCoord=clamp(min2,mainAxisCoord,max2)}if(checkCrossAxis){const minSide=crossAxis==="y"?"top":"left";const maxSide=crossAxis==="y"?"bottom":"right";const min2=crossAxisCoord+overflow[minSide];const max2=crossAxisCoord-overflow[maxSide];crossAxisCoord=clamp(min2,crossAxisCoord,max2)}const limitedCoords=limiter.fn({...state,[mainAxis]:mainAxisCoord,[crossAxis]:crossAxisCoord});return{...limitedCoords,data:{x:limitedCoords.x-x,y:limitedCoords.y-y,enabled:{[mainAxis]:checkMainAxis,[crossAxis]:checkCrossAxis}}}}}};const limitShift$1=function(options){if(options===void 0){options={}}return{options:options,fn(state){const{x:x,y:y,placement:placement,rects:rects,middlewareData:middlewareData}=state;const{offset:offset2=0,mainAxis:checkMainAxis=true,crossAxis:checkCrossAxis=true}=evaluate(options,state);const coords={x:x,y:y};const crossAxis=getSideAxis(placement);const mainAxis=getOppositeAxis(crossAxis);let mainAxisCoord=coords[mainAxis];let crossAxisCoord=coords[crossAxis];const rawOffset=evaluate(offset2,state);const computedOffset=typeof rawOffset==="number"?{mainAxis:rawOffset,crossAxis:0}:{mainAxis:0,crossAxis:0,...rawOffset};if(checkMainAxis){const len=mainAxis==="y"?"height":"width";const limitMin=rects.reference[mainAxis]-rects.floating[len]+computedOffset.mainAxis;const limitMax=rects.reference[mainAxis]+rects.reference[len]-computedOffset.mainAxis;if(mainAxisCoord<limitMin){mainAxisCoord=limitMin}else if(mainAxisCoord>limitMax){mainAxisCoord=limitMax}}if(checkCrossAxis){var _middlewareData$offse,_middlewareData$offse2;const len=mainAxis==="y"?"width":"height";const isOriginSide=["top","left"].includes(getSide(placement));const limitMin=rects.reference[crossAxis]-rects.floating[len]+(isOriginSide?((_middlewareData$offse=middlewareData.offset)==null?void 0:_middlewareData$offse[crossAxis])||0:0)+(isOriginSide?0:computedOffset.crossAxis);const limitMax=rects.reference[crossAxis]+rects.reference[len]+(isOriginSide?0:((_middlewareData$offse2=middlewareData.offset)==null?void 0:_middlewareData$offse2[crossAxis])||0)-(isOriginSide?computedOffset.crossAxis:0);if(crossAxisCoord<limitMin){crossAxisCoord=limitMin}else if(crossAxisCoord>limitMax){crossAxisCoord=limitMax}}return{[mainAxis]:mainAxisCoord,[crossAxis]:crossAxisCoord}}}};const size$1=function(options){if(options===void 0){options={}}return{name:"size",options:options,async fn(state){var _state$middlewareData,_state$middlewareData2;const{placement:placement,rects:rects,platform:platform2,elements:elements}=state;const{apply:apply=()=>{},...detectOverflowOptions}=evaluate(options,state);const overflow=await detectOverflow(state,detectOverflowOptions);const side=getSide(placement);const alignment=getAlignment(placement);const isYAxis=getSideAxis(placement)==="y";const{width:width,height:height}=rects.floating;let heightSide;let widthSide;if(side==="top"||side==="bottom"){heightSide=side;widthSide=alignment===(await(platform2.isRTL==null?void 0:platform2.isRTL(elements.floating))?"start":"end")?"left":"right"}else{widthSide=side;heightSide=alignment==="end"?"top":"bottom"}const maximumClippingHeight=height-overflow.top-overflow.bottom;const maximumClippingWidth=width-overflow.left-overflow.right;const overflowAvailableHeight=min(height-overflow[heightSide],maximumClippingHeight);const overflowAvailableWidth=min(width-overflow[widthSide],maximumClippingWidth);const noShift=!state.middlewareData.shift;let availableHeight=overflowAvailableHeight;let availableWidth=overflowAvailableWidth;if((_state$middlewareData=state.middlewareData.shift)!=null&&_state$middlewareData.enabled.x){availableWidth=maximumClippingWidth}if((_state$middlewareData2=state.middlewareData.shift)!=null&&_state$middlewareData2.enabled.y){availableHeight=maximumClippingHeight}if(noShift&&!alignment){const xMin=max(overflow.left,0);const xMax=max(overflow.right,0);const yMin=max(overflow.top,0);const yMax=max(overflow.bottom,0);if(isYAxis){availableWidth=width-2*(xMin!==0||xMax!==0?xMin+xMax:max(overflow.left,overflow.right))}else{availableHeight=height-2*(yMin!==0||yMax!==0?yMin+yMax:max(overflow.top,overflow.bottom))}}await apply({...state,availableWidth:availableWidth,availableHeight:availableHeight});const nextDimensions=await platform2.getDimensions(elements.floating);if(width!==nextDimensions.width||height!==nextDimensions.height){return{reset:{rects:true}}}return{}}}};function hasWindow(){return typeof window!=="undefined"}function getNodeName(node){if(isNode(node)){return(node.nodeName||"").toLowerCase()}return"#document"}function getWindow(node){var _node$ownerDocument;return(node==null||(_node$ownerDocument=node.ownerDocument)==null?void 0:_node$ownerDocument.defaultView)||window}function getDocumentElement(node){var _ref;return(_ref=(isNode(node)?node.ownerDocument:node.document)||window.document)==null?void 0:_ref.documentElement}function isNode(value){if(!hasWindow()){return false}return value instanceof Node||value instanceof getWindow(value).Node}function isElement(value){if(!hasWindow()){return false}return value instanceof Element||value instanceof getWindow(value).Element}function isHTMLElement(value){if(!hasWindow()){return false}return value instanceof HTMLElement||value instanceof getWindow(value).HTMLElement}function isShadowRoot(value){if(!hasWindow()||typeof ShadowRoot==="undefined"){return false}return value instanceof ShadowRoot||value instanceof getWindow(value).ShadowRoot}function isOverflowElement(element){const{overflow:overflow,overflowX:overflowX,overflowY:overflowY,display:display}=getComputedStyle(element);return/auto|scroll|overlay|hidden|clip/.test(overflow+overflowY+overflowX)&&!["inline","contents"].includes(display)}function isTableElement(element){return["table","td","th"].includes(getNodeName(element))}function isTopLayer(element){return[":popover-open",":modal"].some(selector=>{try{return element.matches(selector)}catch(e){return false}})}function isContainingBlock(elementOrCss){const webkit=isWebKit();const css=isElement(elementOrCss)?getComputedStyle(elementOrCss):elementOrCss;return["transform","translate","scale","rotate","perspective"].some(value=>css[value]?css[value]!=="none":false)||(css.containerType?css.containerType!=="normal":false)||!webkit&&(css.backdropFilter?css.backdropFilter!=="none":false)||!webkit&&(css.filter?css.filter!=="none":false)||["transform","translate","scale","rotate","perspective","filter"].some(value=>(css.willChange||"").includes(value))||["paint","layout","strict","content"].some(value=>(css.contain||"").includes(value))}function getContainingBlock(element){let currentNode=getParentNode(element);while(isHTMLElement(currentNode)&&!isLastTraversableNode(currentNode)){if(isContainingBlock(currentNode)){return currentNode}else if(isTopLayer(currentNode)){return null}currentNode=getParentNode(currentNode)}return null}function isWebKit(){if(typeof CSS==="undefined"||!CSS.supports)return false;return CSS.supports("-webkit-backdrop-filter","none")}function isLastTraversableNode(node){return["html","body","#document"].includes(getNodeName(node))}function getComputedStyle(element){return getWindow(element).getComputedStyle(element)}function getNodeScroll(element){if(isElement(element)){return{scrollLeft:element.scrollLeft,scrollTop:element.scrollTop}}return{scrollLeft:element.scrollX,scrollTop:element.scrollY}}function getParentNode(node){if(getNodeName(node)==="html"){return node}const result=node.assignedSlot||node.parentNode||isShadowRoot(node)&&node.host||getDocumentElement(node);return isShadowRoot(result)?result.host:result}function getNearestOverflowAncestor(node){const parentNode=getParentNode(node);if(isLastTraversableNode(parentNode)){return node.ownerDocument?node.ownerDocument.body:node.body}if(isHTMLElement(parentNode)&&isOverflowElement(parentNode)){return parentNode}return getNearestOverflowAncestor(parentNode)}function getOverflowAncestors(node,list,traverseIframes){var _node$ownerDocument2;if(list===void 0){list=[]}if(traverseIframes===void 0){traverseIframes=true}const scrollableAncestor=getNearestOverflowAncestor(node);const isBody=scrollableAncestor===((_node$ownerDocument2=node.ownerDocument)==null?void 0:_node$ownerDocument2.body);const win=getWindow(scrollableAncestor);if(isBody){const frameElement=getFrameElement(win);return list.concat(win,win.visualViewport||[],isOverflowElement(scrollableAncestor)?scrollableAncestor:[],frameElement&&traverseIframes?getOverflowAncestors(frameElement):[])}return list.concat(scrollableAncestor,getOverflowAncestors(scrollableAncestor,[],traverseIframes))}function getFrameElement(win){return win.parent&&Object.getPrototypeOf(win.parent)?win.frameElement:null}function getCssDimensions(element){const css=getComputedStyle(element);let width=parseFloat(css.width)||0;let height=parseFloat(css.height)||0;const hasOffset=isHTMLElement(element);const offsetWidth=hasOffset?element.offsetWidth:width;const offsetHeight=hasOffset?element.offsetHeight:height;const shouldFallback=round(width)!==offsetWidth||round(height)!==offsetHeight;if(shouldFallback){width=offsetWidth;height=offsetHeight}return{width:width,height:height,$:shouldFallback}}function unwrapElement(element){return!isElement(element)?element.contextElement:element}function getScale(element){const domElement=unwrapElement(element);if(!isHTMLElement(domElement)){return createCoords(1)}const rect=domElement.getBoundingClientRect();const{width:width,height:height,$:$}=getCssDimensions(domElement);let x=($?round(rect.width):rect.width)/width;let y=($?round(rect.height):rect.height)/height;if(!x||!Number.isFinite(x)){x=1}if(!y||!Number.isFinite(y)){y=1}return{x:x,y:y}}const noOffsets=createCoords(0);function getVisualOffsets(element){const win=getWindow(element);if(!isWebKit()||!win.visualViewport){return noOffsets}return{x:win.visualViewport.offsetLeft,y:win.visualViewport.offsetTop}}function shouldAddVisualOffsets(element,isFixed,floatingOffsetParent){if(isFixed===void 0){isFixed=false}if(!floatingOffsetParent||isFixed&&floatingOffsetParent!==getWindow(element)){return false}return isFixed}function getBoundingClientRect(element,includeScale,isFixedStrategy,offsetParent){if(includeScale===void 0){includeScale=false}if(isFixedStrategy===void 0){isFixedStrategy=false}const clientRect=element.getBoundingClientRect();const domElement=unwrapElement(element);let scale=createCoords(1);if(includeScale){if(offsetParent){if(isElement(offsetParent)){scale=getScale(offsetParent)}}else{scale=getScale(element)}}const visualOffsets=shouldAddVisualOffsets(domElement,isFixedStrategy,offsetParent)?getVisualOffsets(domElement):createCoords(0);let x=(clientRect.left+visualOffsets.x)/scale.x;let y=(clientRect.top+visualOffsets.y)/scale.y;let width=clientRect.width/scale.x;let height=clientRect.height/scale.y;if(domElement){const win=getWindow(domElement);const offsetWin=offsetParent&&isElement(offsetParent)?getWindow(offsetParent):offsetParent;let currentWin=win;let currentIFrame=getFrameElement(currentWin);while(currentIFrame&&offsetParent&&offsetWin!==currentWin){const iframeScale=getScale(currentIFrame);const iframeRect=currentIFrame.getBoundingClientRect();const css=getComputedStyle(currentIFrame);const left=iframeRect.left+(currentIFrame.clientLeft+parseFloat(css.paddingLeft))*iframeScale.x;const top=iframeRect.top+(currentIFrame.clientTop+parseFloat(css.paddingTop))*iframeScale.y;x*=iframeScale.x;y*=iframeScale.y;width*=iframeScale.x;height*=iframeScale.y;x+=left;y+=top;currentWin=getWindow(currentIFrame);currentIFrame=getFrameElement(currentWin)}}return rectToClientRect({width:width,height:height,x:x,y:y})}function getWindowScrollBarX(element,rect){const leftScroll=getNodeScroll(element).scrollLeft;if(!rect){return getBoundingClientRect(getDocumentElement(element)).left+leftScroll}return rect.left+leftScroll}function getHTMLOffset(documentElement,scroll,ignoreScrollbarX){if(ignoreScrollbarX===void 0){ignoreScrollbarX=false}const htmlRect=documentElement.getBoundingClientRect();const x=htmlRect.left+scroll.scrollLeft-(ignoreScrollbarX?0:getWindowScrollBarX(documentElement,htmlRect));const y=htmlRect.top+scroll.scrollTop;return{x:x,y:y}}function convertOffsetParentRelativeRectToViewportRelativeRect(_ref){let{elements:elements,rect:rect,offsetParent:offsetParent,strategy:strategy}=_ref;const isFixed=strategy==="fixed";const documentElement=getDocumentElement(offsetParent);const topLayer=elements?isTopLayer(elements.floating):false;if(offsetParent===documentElement||topLayer&&isFixed){return rect}let scroll={scrollLeft:0,scrollTop:0};let scale=createCoords(1);const offsets=createCoords(0);const isOffsetParentAnElement=isHTMLElement(offsetParent);if(isOffsetParentAnElement||!isOffsetParentAnElement&&!isFixed){if(getNodeName(offsetParent)!=="body"||isOverflowElement(documentElement)){scroll=getNodeScroll(offsetParent)}if(isHTMLElement(offsetParent)){const offsetRect=getBoundingClientRect(offsetParent);scale=getScale(offsetParent);offsets.x=offsetRect.x+offsetParent.clientLeft;offsets.y=offsetRect.y+offsetParent.clientTop}}const htmlOffset=documentElement&&!isOffsetParentAnElement&&!isFixed?getHTMLOffset(documentElement,scroll,true):createCoords(0);return{width:rect.width*scale.x,height:rect.height*scale.y,x:rect.x*scale.x-scroll.scrollLeft*scale.x+offsets.x+htmlOffset.x,y:rect.y*scale.y-scroll.scrollTop*scale.y+offsets.y+htmlOffset.y}}function getClientRects(element){return Array.from(element.getClientRects())}function getDocumentRect(element){const html=getDocumentElement(element);const scroll=getNodeScroll(element);const body=element.ownerDocument.body;const width=max(html.scrollWidth,html.clientWidth,body.scrollWidth,body.clientWidth);const height=max(html.scrollHeight,html.clientHeight,body.scrollHeight,body.clientHeight);let x=-scroll.scrollLeft+getWindowScrollBarX(element);const y=-scroll.scrollTop;if(getComputedStyle(body).direction==="rtl"){x+=max(html.clientWidth,body.clientWidth)-width}return{width:width,height:height,x:x,y:y}}function getViewportRect(element,strategy){const win=getWindow(element);const html=getDocumentElement(element);const visualViewport=win.visualViewport;let width=html.clientWidth;let height=html.clientHeight;let x=0;let y=0;if(visualViewport){width=visualViewport.width;height=visualViewport.height;const visualViewportBased=isWebKit();if(!visualViewportBased||visualViewportBased&&strategy==="fixed"){x=visualViewport.offsetLeft;y=visualViewport.offsetTop}}return{width:width,height:height,x:x,y:y}}function getInnerBoundingClientRect(element,strategy){const clientRect=getBoundingClientRect(element,true,strategy==="fixed");const top=clientRect.top+element.clientTop;const left=clientRect.left+element.clientLeft;const scale=isHTMLElement(element)?getScale(element):createCoords(1);const width=element.clientWidth*scale.x;const height=element.clientHeight*scale.y;const x=left*scale.x;const y=top*scale.y;return{width:width,height:height,x:x,y:y}}function getClientRectFromClippingAncestor(element,clippingAncestor,strategy){let rect;if(clippingAncestor==="viewport"){rect=getViewportRect(element,strategy)}else if(clippingAncestor==="document"){rect=getDocumentRect(getDocumentElement(element))}else if(isElement(clippingAncestor)){rect=getInnerBoundingClientRect(clippingAncestor,strategy)}else{const visualOffsets=getVisualOffsets(element);rect={x:clippingAncestor.x-visualOffsets.x,y:clippingAncestor.y-visualOffsets.y,width:clippingAncestor.width,height:clippingAncestor.height}}return rectToClientRect(rect)}function hasFixedPositionAncestor(element,stopNode){const parentNode=getParentNode(element);if(parentNode===stopNode||!isElement(parentNode)||isLastTraversableNode(parentNode)){return false}return getComputedStyle(parentNode).position==="fixed"||hasFixedPositionAncestor(parentNode,stopNode)}function getClippingElementAncestors(element,cache){const cachedResult=cache.get(element);if(cachedResult){return cachedResult}let result=getOverflowAncestors(element,[],false).filter(el=>isElement(el)&&getNodeName(el)!=="body");let currentContainingBlockComputedStyle=null;const elementIsFixed=getComputedStyle(element).position==="fixed";let currentNode=elementIsFixed?getParentNode(element):element;while(isElement(currentNode)&&!isLastTraversableNode(currentNode)){const computedStyle=getComputedStyle(currentNode);const currentNodeIsContaining=isContainingBlock(currentNode);if(!currentNodeIsContaining&&computedStyle.position==="fixed"){currentContainingBlockComputedStyle=null}const shouldDropCurrentNode=elementIsFixed?!currentNodeIsContaining&&!currentContainingBlockComputedStyle:!currentNodeIsContaining&&computedStyle.position==="static"&&!!currentContainingBlockComputedStyle&&["absolute","fixed"].includes(currentContainingBlockComputedStyle.position)||isOverflowElement(currentNode)&&!currentNodeIsContaining&&hasFixedPositionAncestor(element,currentNode);if(shouldDropCurrentNode){result=result.filter(ancestor=>ancestor!==currentNode)}else{currentContainingBlockComputedStyle=computedStyle}currentNode=getParentNode(currentNode)}cache.set(element,result);return result}function getClippingRect(_ref){let{element:element,boundary:boundary,rootBoundary:rootBoundary,strategy:strategy}=_ref;const elementClippingAncestors=boundary==="clippingAncestors"?isTopLayer(element)?[]:getClippingElementAncestors(element,this._c):[].concat(boundary);const clippingAncestors=[...elementClippingAncestors,rootBoundary];const firstClippingAncestor=clippingAncestors[0];const clippingRect=clippingAncestors.reduce((accRect,clippingAncestor)=>{const rect=getClientRectFromClippingAncestor(element,clippingAncestor,strategy);accRect.top=max(rect.top,accRect.top);accRect.right=min(rect.right,accRect.right);accRect.bottom=min(rect.bottom,accRect.bottom);accRect.left=max(rect.left,accRect.left);return accRect},getClientRectFromClippingAncestor(element,firstClippingAncestor,strategy));return{width:clippingRect.right-clippingRect.left,height:clippingRect.bottom-clippingRect.top,x:clippingRect.left,y:clippingRect.top}}function getDimensions(element){const{width:width,height:height}=getCssDimensions(element);return{width:width,height:height}}function getRectRelativeToOffsetParent(element,offsetParent,strategy){const isOffsetParentAnElement=isHTMLElement(offsetParent);const documentElement=getDocumentElement(offsetParent);const isFixed=strategy==="fixed";const rect=getBoundingClientRect(element,true,isFixed,offsetParent);let scroll={scrollLeft:0,scrollTop:0};const offsets=createCoords(0);function setLeftRTLScrollbarOffset(){offsets.x=getWindowScrollBarX(documentElement)}if(isOffsetParentAnElement||!isOffsetParentAnElement&&!isFixed){if(getNodeName(offsetParent)!=="body"||isOverflowElement(documentElement)){scroll=getNodeScroll(offsetParent)}if(isOffsetParentAnElement){const offsetRect=getBoundingClientRect(offsetParent,true,isFixed,offsetParent);offsets.x=offsetRect.x+offsetParent.clientLeft;offsets.y=offsetRect.y+offsetParent.clientTop}else if(documentElement){setLeftRTLScrollbarOffset()}}if(isFixed&&!isOffsetParentAnElement&&documentElement){setLeftRTLScrollbarOffset()}const htmlOffset=documentElement&&!isOffsetParentAnElement&&!isFixed?getHTMLOffset(documentElement,scroll):createCoords(0);const x=rect.left+scroll.scrollLeft-offsets.x-htmlOffset.x;const y=rect.top+scroll.scrollTop-offsets.y-htmlOffset.y;return{x:x,y:y,width:rect.width,height:rect.height}}function isStaticPositioned(element){return getComputedStyle(element).position==="static"}function getTrueOffsetParent(element,polyfill){if(!isHTMLElement(element)||getComputedStyle(element).position==="fixed"){return null}if(polyfill){return polyfill(element)}let rawOffsetParent=element.offsetParent;if(getDocumentElement(element)===rawOffsetParent){rawOffsetParent=rawOffsetParent.ownerDocument.body}return rawOffsetParent}function getOffsetParent(element,polyfill){const win=getWindow(element);if(isTopLayer(element)){return win}if(!isHTMLElement(element)){let svgOffsetParent=getParentNode(element);while(svgOffsetParent&&!isLastTraversableNode(svgOffsetParent)){if(isElement(svgOffsetParent)&&!isStaticPositioned(svgOffsetParent)){return svgOffsetParent}svgOffsetParent=getParentNode(svgOffsetParent)}return win}let offsetParent=getTrueOffsetParent(element,polyfill);while(offsetParent&&isTableElement(offsetParent)&&isStaticPositioned(offsetParent)){offsetParent=getTrueOffsetParent(offsetParent,polyfill)}if(offsetParent&&isLastTraversableNode(offsetParent)&&isStaticPositioned(offsetParent)&&!isContainingBlock(offsetParent)){return win}return offsetParent||getContainingBlock(element)||win}const getElementRects=async function(data){const getOffsetParentFn=this.getOffsetParent||getOffsetParent;const getDimensionsFn=this.getDimensions;const floatingDimensions=await getDimensionsFn(data.floating);return{reference:getRectRelativeToOffsetParent(data.reference,await getOffsetParentFn(data.floating),data.strategy),floating:{x:0,y:0,width:floatingDimensions.width,height:floatingDimensions.height}}};function isRTL(element){return getComputedStyle(element).direction==="rtl"}const platform={convertOffsetParentRelativeRectToViewportRelativeRect:convertOffsetParentRelativeRectToViewportRelativeRect,getDocumentElement:getDocumentElement,getClippingRect:getClippingRect,getOffsetParent:getOffsetParent,getElementRects:getElementRects,getClientRects:getClientRects,getDimensions:getDimensions,getScale:getScale,isElement:isElement,isRTL:isRTL};function rectsAreEqual(a,b){return a.x===b.x&&a.y===b.y&&a.width===b.width&&a.height===b.height}function observeMove(element,onMove){let io=null;let timeoutId;const root=getDocumentElement(element);function cleanup(){var _io;clearTimeout(timeoutId);(_io=io)==null||_io.disconnect();io=null}function refresh(skip,threshold){if(skip===void 0){skip=false}if(threshold===void 0){threshold=1}cleanup();const elementRectForRootMargin=element.getBoundingClientRect();const{left:left,top:top,width:width,height:height}=elementRectForRootMargin;if(!skip){onMove()}if(!width||!height){return}const insetTop=floor(top);const insetRight=floor(root.clientWidth-(left+width));const insetBottom=floor(root.clientHeight-(top+height));const insetLeft=floor(left);const rootMargin=-insetTop+"px "+-insetRight+"px "+-insetBottom+"px "+-insetLeft+"px";const options={rootMargin:rootMargin,threshold:max(0,min(1,threshold))||1};let isFirstUpdate=true;function handleObserve(entries){const ratio=entries[0].intersectionRatio;if(ratio!==threshold){if(!isFirstUpdate){return refresh()}if(!ratio){timeoutId=setTimeout(()=>{refresh(false,1e-7)},1e3)}else{refresh(false,ratio)}}if(ratio===1&&!rectsAreEqual(elementRectForRootMargin,element.getBoundingClientRect())){refresh()}isFirstUpdate=false}try{io=new IntersectionObserver(handleObserve,{...options,root:root.ownerDocument})}catch(_e){io=new IntersectionObserver(handleObserve,options)}io.observe(element)}refresh(true);return cleanup}function autoUpdate(reference,floating,update,options){if(options===void 0){options={}}const{ancestorScroll:ancestorScroll=true,ancestorResize:ancestorResize=true,elementResize:elementResize=typeof ResizeObserver==="function",layoutShift:layoutShift=typeof IntersectionObserver==="function",animationFrame:animationFrame=false}=options;const referenceEl=unwrapElement(reference);const ancestors=ancestorScroll||ancestorResize?[...referenceEl?getOverflowAncestors(referenceEl):[],...getOverflowAncestors(floating)]:[];ancestors.forEach(ancestor=>{ancestorScroll&&ancestor.addEventListener("scroll",update,{passive:true});ancestorResize&&ancestor.addEventListener("resize",update)});const cleanupIo=referenceEl&&layoutShift?observeMove(referenceEl,update):null;let reobserveFrame=-1;let resizeObserver=null;if(elementResize){resizeObserver=new ResizeObserver(_ref=>{let[firstEntry]=_ref;if(firstEntry&&firstEntry.target===referenceEl&&resizeObserver){resizeObserver.unobserve(floating);cancelAnimationFrame(reobserveFrame);reobserveFrame=requestAnimationFrame(()=>{var _resizeObserver;(_resizeObserver=resizeObserver)==null||_resizeObserver.observe(floating)})}update()});if(referenceEl&&!animationFrame){resizeObserver.observe(referenceEl)}resizeObserver.observe(floating)}let frameId;let prevRefRect=animationFrame?getBoundingClientRect(reference):null;if(animationFrame){frameLoop()}function frameLoop(){const nextRefRect=getBoundingClientRect(reference);if(prevRefRect&&!rectsAreEqual(prevRefRect,nextRefRect)){update()}prevRefRect=nextRefRect;frameId=requestAnimationFrame(frameLoop)}update();return()=>{var _resizeObserver2;ancestors.forEach(ancestor=>{ancestorScroll&&ancestor.removeEventListener("scroll",update);ancestorResize&&ancestor.removeEventListener("resize",update)});cleanupIo==null||cleanupIo();(_resizeObserver2=resizeObserver)==null||_resizeObserver2.disconnect();resizeObserver=null;if(animationFrame){cancelAnimationFrame(frameId)}}}const offset=offset$1;const shift=shift$1;const flip=flip$1;const size=size$1;const hide=hide$1;const arrow=arrow$1;const limitShift=limitShift$1;const computePosition=(reference,floating,options)=>{const cache=new Map;const mergedOptions={platform:platform,...options};const platformWithCache={...mergedOptions.platform,_c:cache};return computePosition$1(reference,floating,{...mergedOptions,platform:platformWithCache})};export{arrow as a,autoUpdate as b,computePosition as c,size as d,flip as f,hide as h,limitShift as l,offset as o,shift as s};
//# sourceMappingURL=DiBDz6jf.js.map
