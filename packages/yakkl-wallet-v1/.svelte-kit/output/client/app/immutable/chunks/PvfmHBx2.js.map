{"version":3,"file":"PvfmHBx2.js","sources":["../../../../../../../../node_modules/.pnpm/svelte@5.34.3/node_modules/svelte/src/internal/client/validate.js"],"sourcesContent":["import { dev_current_component_function } from './context.js';\nimport { is_array } from '../shared/utils.js';\nimport * as e from './errors.js';\nimport { FILENAME } from '../../constants.js';\nimport { render_effect } from './reactivity/effects.js';\nimport * as w from './warnings.js';\nimport { capture_store_binding } from './reactivity/store.js';\n\n/**\n * @param {() => any} collection\n * @param {(item: any, index: number) => string} key_fn\n * @returns {void}\n */\nexport function validate_each_keys(collection, key_fn) {\n\trender_effect(() => {\n\t\tconst keys = new Map();\n\t\tconst maybe_array = collection();\n\t\tconst array = is_array(maybe_array)\n\t\t\t? maybe_array\n\t\t\t: maybe_array == null\n\t\t\t\t? []\n\t\t\t\t: Array.from(maybe_array);\n\t\tconst length = array.length;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tconst key = key_fn(array[i], i);\n\t\t\tif (keys.has(key)) {\n\t\t\t\tconst a = String(keys.get(key));\n\t\t\t\tconst b = String(i);\n\n\t\t\t\t/** @type {string | null} */\n\t\t\t\tlet k = String(key);\n\t\t\t\tif (k.startsWith('[object ')) k = null;\n\n\t\t\t\te.each_key_duplicate(a, b, k);\n\t\t\t}\n\t\t\tkeys.set(key, i);\n\t\t}\n\t});\n}\n\n/**\n * @param {string} binding\n * @param {() => Record<string, any>} get_object\n * @param {() => string} get_property\n * @param {number} line\n * @param {number} column\n */\nexport function validate_binding(binding, get_object, get_property, line, column) {\n\tvar warned = false;\n\n\tvar filename = dev_current_component_function?.[FILENAME];\n\n\trender_effect(() => {\n\t\tif (warned) return;\n\n\t\tvar [object, is_store_sub] = capture_store_binding(get_object);\n\n\t\tif (is_store_sub) return;\n\n\t\tvar property = get_property();\n\n\t\tvar ran = false;\n\n\t\t// by making the (possibly false, but it would be an extreme edge case) assumption\n\t\t// that a getter has a corresponding setter, we can determine if a property is\n\t\t// reactive by seeing if this effect has dependencies\n\t\tvar effect = render_effect(() => {\n\t\t\tif (ran) return;\n\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-expressions\n\t\t\tobject[property];\n\t\t});\n\n\t\tran = true;\n\n\t\tif (effect.deps === null) {\n\t\t\tvar location = `${filename}:${line}:${column}`;\n\t\t\tw.binding_property_non_reactive(binding, location);\n\n\t\t\twarned = true;\n\t\t}\n\t});\n}\n"],"names":["validate_each_keys","collection","key_fn","render_effect","keys","Map","maybe_array","array","is_array","Array","from","length","i","key","has","a","String","get","b","k","startsWith","each_key_duplicate","set","validate_binding","binding","get_object","get_property","line","column","warned","filename","_a","dev_current_component_function","FILENAME","object","is_store_sub","capture_store_binding","property","ran","effect","deps","location","w.binding_property_non_reactive"],"mappings":"oOAaO,SAASA,mBAAmBC,WAAYC,QAC9CC,cAAc,KACP,MAAAC,SAAWC,IACjB,MAAMC,YAAcL,aACd,MAAAM,MAAQC,SAASF,aACpBA,YACAA,aAAe,KACd,GACAG,MAAMC,KAAKJ,aACf,MAAMK,OAASJ,MAAMI,OACrB,IAAA,IAASC,EAAI,EAAGA,EAAID,OAAQC,IAAK,CAChC,MAAMC,IAAMX,OAAOK,MAAMK,GAAIA,GACzB,GAAAR,KAAKU,IAAID,KAAM,CAClB,MAAME,EAAIC,OAAOZ,KAAKa,IAAIJ,MACpB,MAAAK,EAAIF,OAAOJ,GAGb,IAAAO,EAAIH,OAAOH,KACf,GAAIM,EAAEC,WAAW,YAAiBD,EAAA,KAEbE,mBAAAN,EAAGG,EAAGC,EAC/B,CACQf,KAAAkB,IAAIT,IAAKD,EACjB,GAEA,CASO,SAASW,iBAAiBC,QAASC,WAAYC,aAAcC,KAAMC,eACzE,IAAIC,OAAS,MAEb,IAAIC,UAAWC,GAAiCC,iCAAA,UAAA,EAAAD,GAAAE,UAEhD9B,cAAc,KACb,GAAI0B,OAAQ,OAEZ,IAAKK,OAAQC,cAAgBC,sBAAsBX,YAEnD,GAAIU,aAAc,OAElB,IAAIE,SAAWX,eAEf,IAAIY,IAAM,MAKN,IAAAC,OAASpC,cAAc,KAC1B,GAAImC,IAAK,OAGTJ,OAAOG,YAGFC,IAAA,KAEF,GAAAC,OAAOC,OAAS,KAAM,CACzB,IAAIC,SAAW,GAAGX,YAAYH,QAAQC,SACtCc,8BAAgClB,QAASiB,UAEhCZ,OAAA,IACZ,GAEA","x_google_ignoreList":[0]}