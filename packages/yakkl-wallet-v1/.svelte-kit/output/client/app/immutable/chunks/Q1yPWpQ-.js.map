{"version":3,"file":"Q1yPWpQ-.js","sources":["../../../../../../../../node_modules/.pnpm/svelte@5.34.3/node_modules/svelte/src/internal/client/dom/blocks/if.js"],"sourcesContent":["/** @import { Effect, TemplateNode } from '#client' */\nimport { EFFECT_TRANSPARENT } from '#client/constants';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tread_hydration_instruction,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js';\nimport { HYDRATION_START, HYDRATION_START_ELSE, UNINITIALIZED } from '../../../../constants.js';\n\n/**\n * @param {TemplateNode} node\n * @param {(branch: (fn: (anchor: Node, elseif?: [number,number]) => void, flag?: boolean) => void) => void} fn\n * @param {[number,number]} [elseif]\n * @returns {void}\n */\nexport function if_block(node, fn, [root_index, hydrate_index] = [0, 0]) {\n\tif (hydrating && root_index === 0) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {Effect | null} */\n\tvar consequent_effect = null;\n\n\t/** @type {Effect | null} */\n\tvar alternate_effect = null;\n\n\t/** @type {UNINITIALIZED | boolean | null} */\n\tvar condition = UNINITIALIZED;\n\n\tvar flags = root_index > 0 ? EFFECT_TRANSPARENT : 0;\n\n\tvar has_branch = false;\n\n\tconst set_branch = (\n\t\t/** @type {(anchor: Node, elseif?: [number,number]) => void} */ fn,\n\t\tflag = true\n\t) => {\n\t\thas_branch = true;\n\t\tupdate_branch(flag, fn);\n\t};\n\n\tconst update_branch = (\n\t\t/** @type {boolean | null} */ new_condition,\n\t\t/** @type {null | ((anchor: Node, elseif?: [number,number]) => void)} */ fn\n\t) => {\n\t\tif (condition === (condition = new_condition)) return;\n\n\t\t/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating && hydrate_index !== -1) {\n\t\t\tif (root_index === 0) {\n\t\t\t\tconst data = read_hydration_instruction(anchor);\n\n\t\t\t\tif (data === HYDRATION_START) {\n\t\t\t\t\thydrate_index = 0;\n\t\t\t\t} else if (data === HYDRATION_START_ELSE) {\n\t\t\t\t\thydrate_index = Infinity;\n\t\t\t\t} else {\n\t\t\t\t\thydrate_index = parseInt(data.substring(1));\n\t\t\t\t\tif (hydrate_index !== hydrate_index) {\n\t\t\t\t\t\t// if hydrate_index is NaN\n\t\t\t\t\t\t// we set an invalid index to force mismatch\n\t\t\t\t\t\thydrate_index = condition ? Infinity : -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst is_else = hydrate_index > root_index;\n\n\t\t\tif (!!condition === is_else) {\n\t\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh.\n\t\t\t\t// This could happen with `{#if browser}...{/if}`, for example\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t\thydrate_index = -1; // ignore hydration in next else if\n\t\t\t}\n\t\t}\n\n\t\tif (condition) {\n\t\t\tif (consequent_effect) {\n\t\t\t\tresume_effect(consequent_effect);\n\t\t\t} else if (fn) {\n\t\t\t\tconsequent_effect = branch(() => fn(anchor));\n\t\t\t}\n\n\t\t\tif (alternate_effect) {\n\t\t\t\tpause_effect(alternate_effect, () => {\n\t\t\t\t\talternate_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tif (alternate_effect) {\n\t\t\t\tresume_effect(alternate_effect);\n\t\t\t} else if (fn) {\n\t\t\t\talternate_effect = branch(() => fn(anchor, [root_index + 1, hydrate_index]));\n\t\t\t}\n\n\t\t\tif (consequent_effect) {\n\t\t\t\tpause_effect(consequent_effect, () => {\n\t\t\t\t\tconsequent_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\t};\n\n\tblock(() => {\n\t\thas_branch = false;\n\t\tfn(set_branch);\n\t\tif (!has_branch) {\n\t\t\tupdate_branch(null, null);\n\t\t}\n\t}, flags);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n"],"names":["if_block","node","fn","root_index","hydrate_index","hydrating","hydrate_next","anchor","consequent_effect","alternate_effect","condition","UNINITIALIZED","flags","EFFECT_TRANSPARENT","has_branch","set_branch","flag","update_branch","new_condition","mismatch","data","read_hydration_instruction","HYDRATION_START","HYDRATION_START_ELSE","Infinity","parseInt","substring","is_else","remove_nodes","set_hydrate_node","set_hydrating","resume_effect","branch","pause_effect","block","hydrate_node"],"mappings":"gUAoBO,SAASA,SAASC,KAAMC,IAAKC,WAAYC,eAAiB,CAAC,EAAG,IAChE,GAAAC,WAAaF,aAAe,EAAG,CACpBG,cAChB,CAEC,IAAIC,OAASN,KAGb,IAAIO,kBAAoB,KAGxB,IAAIC,iBAAmB,KAGvB,IAAIC,UAAYC,cAEZ,IAAAC,MAAQT,WAAa,EAAIU,mBAAqB,EAElD,IAAIC,WAAa,MAEjB,MAAMC,WAAa,CAC8Cb,IAChEc,KAAO,QAEMF,WAAA,KACbG,cAAcD,KAAMd,MAGf,MAAAe,cAAgB,CACSC,cAC2ChB,OAErE,GAAAQ,aAAeA,UAAYQ,eAAgB,OAG/C,IAAIC,SAAW,MAEX,GAAAd,WAAaD,iBAAsB,EAAA,CACtC,GAAID,aAAe,EAAG,CACf,MAAAiB,KAAOC,2BAA2Bd,QAExC,GAAIa,OAASE,gBAAiB,CACblB,cAAA,CACrB,MAAA,GAAegB,OAASG,qBAAsB,CACzBnB,cAAAoB,QACrB,KAAW,CACNpB,cAAgBqB,SAASL,KAAKM,UAAU,IACxC,GAAItB,gBAAkBA,cAAe,CAGpCA,cAAgBM,UAAYc,UAAW,CAC7C,CACA,CACA,CACG,MAAMG,QAAUvB,cAAgBD,WAE5B,KAAEO,YAAciB,QAAS,CAG5BpB,OAASqB,eAETC,iBAAiBtB,QACjBuB,cAAc,OACHX,SAAA,KACKf,eAAA,CACpB,CACA,CAEE,GAAIM,UAAW,CACd,GAAIF,kBAAmB,CACtBuB,cAAcvB,kBACd,SAAUN,IAAI,CACdM,kBAAoBwB,OAAO,IAAM9B,IAAGK,QACxC,CAEG,GAAIE,iBAAkB,CACrBwB,aAAaxB,iBAAkB,KACXA,iBAAA,MAExB,CACA,KAAS,CACN,GAAIA,iBAAkB,CACrBsB,cAActB,iBACd,SAAUP,IAAI,CACKO,iBAAAuB,OAAO,IAAM9B,IAAGK,OAAQ,CAACJ,WAAa,EAAGC,gBAChE,CAEG,GAAII,kBAAmB,CACtByB,aAAazB,kBAAmB,KACXA,kBAAA,MAEzB,CACA,CAEE,GAAIW,SAAU,CAEbW,cAAc,KACjB,GAGCI,MAAM,KACQpB,WAAA,MACbZ,GAAGa,YACH,IAAKD,WAAY,CAChBG,cAAc,KAAM,KACvB,GACIL,OAEH,GAAIP,UAAW,CACLE,OAAA4B,YACX,CACA","x_google_ignoreList":[0]}