import{R as encryptData,S as PromoClassificationType,A as AccessSourceType,V as VERSION,x as isEncryptedData,z as decryptData,n as PlanType}from"./Cb2naUpm.js";import{l as log}from"./WDN37msH.js";import"./CgCfpVku.js";import"./BaS8d5lg.js";class EmergencyKitManager{static async createEmergencyKit(accountData,encryptDownload,passwordOrSaltedKey){const createDate=(new Date).toISOString();const updateDate=createDate;const version=VERSION;const id=this.generateId();const encryptedAccounts=await Promise.all(accountData.map(async account=>{const checksum=await this.createHash(JSON.stringify(account));account.hash=checksum;return encryptDownload?await encryptData(account,passwordOrSaltedKey):account}));const dataToEncrypt=JSON.stringify(encryptedAccounts);const encryptedData=encryptDownload?await encryptData(dataToEncrypt,passwordOrSaltedKey):{data:dataToEncrypt,iv:"",salt:""};const overallChecksum=await this.createHash(dataToEncrypt);const meta={id:id,createDate:createDate,updateDate:updateDate,version:version,type:"yakkl",portfolioName:accountData[0].portfolioName,subPortfolioName:accountData[0].subPortfolioName||"",subPortfolioAddress:accountData[0].subPortfolioAddress||"",hash:overallChecksum,files:["YakklAccount"],plan:{type:accountData[0].registered.plan.type,source:AccessSourceType.STANDARD,promo:PromoClassificationType.INFLUENCER,trialEndDate:"",upgradeDate:""}};const emergencyKit={id:id,data:encryptedData,accounts:encryptedAccounts,meta:meta,cs:overallChecksum};return emergencyKit}static async createBulkEmergencyKit(preferences,settings,profile,currentlySelected,contacts,chats,accounts,primaryAccounts,watchList,blockedList,connectedDomains,passwordOrSaltedKey,tokenData,tokenDataCustom,combinedTokenStore,walletProviders,walletBlockchains){var _a;const createDate=(new Date).toISOString();const id=this.generateId();const encryptedData={yakklPreferencesStore:await this.encryptWithChecksum(preferences,passwordOrSaltedKey),yakklSettingsStore:await this.encryptWithChecksum(settings,passwordOrSaltedKey),profileStore:await this.encryptWithChecksum(profile,passwordOrSaltedKey),yakklCurrentlySelectedStore:await this.encryptWithChecksum(currentlySelected,passwordOrSaltedKey),yakklContactsStore:await this.encryptWithChecksum(contacts,passwordOrSaltedKey),yakklChatsStore:await this.encryptWithChecksum(chats,passwordOrSaltedKey),yakklAccountsStore:await this.encryptWithChecksum(accounts,passwordOrSaltedKey),yakklPrimaryAccountsStore:await this.encryptWithChecksum(primaryAccounts,passwordOrSaltedKey),yakklWatchListStore:await this.encryptWithChecksum(watchList,passwordOrSaltedKey),yakklBlockedListStore:await this.encryptWithChecksum(blockedList,passwordOrSaltedKey),yakklConnectedDomainsStore:await this.encryptWithChecksum(connectedDomains,passwordOrSaltedKey),yakklTokenDataStore:await this.encryptWithChecksum(tokenData,passwordOrSaltedKey),yakklTokenDataCustomStore:await this.encryptWithChecksum(tokenDataCustom,passwordOrSaltedKey),yakklCombinedTokenStore:await this.encryptWithChecksum(combinedTokenStore,passwordOrSaltedKey),yakklWalletProvidersStore:await this.encryptWithChecksum(walletProviders,passwordOrSaltedKey),yakklWalletBlockchainsStore:await this.encryptWithChecksum(walletBlockchains,passwordOrSaltedKey)};let profileData=null;if(isEncryptedData(profile.data)){profileData=await decryptData(profile.data,passwordOrSaltedKey)}const meta={id:id,createDate:createDate,updateDate:createDate,version:VERSION,type:"yakkl_bulk",plan:{type:((_a=profileData==null?void 0:profileData.registered)==null?void 0:_a.plan.type)??PlanType.BASIC_MEMBER,source:AccessSourceType.STANDARD,promo:PromoClassificationType.INFLUENCER,trialEndDate:"",upgradeDate:""},hash:await this.createHash(JSON.stringify(encryptedData)),files:["yakklPreferencesStore","yakklSettingsStore","profileStore","yakklCurrentlySelectedStore","yakklContactsStore","yakklChatsStore","yakklAccountsStore","yakklPrimaryAccountsStore","yakklWatchListStore","yakklBlockedListStore","yakklConnectedDomainsStore","yakklTokenDataStore","yakklTokenDataCustomStore","yakklCombinedTokenStore","yakklWalletProvidersStore","yakklWalletBlockchainsStore"]};profileData=null;const bulkEmergencyKit={meta:meta,data:encryptedData,cs:await this.createHash(JSON.stringify(meta)+JSON.stringify(encryptedData))};return bulkEmergencyKit}static async downloadEmergencyKit(emergencyKit,filePath){var _a;if(typeof window!=="undefined"&&window.document){const fileName=`yakkl-emergency-kit-${emergencyKit.id}-${(_a=emergencyKit==null?void 0:emergencyKit.meta)==null?void 0:_a.createDate}.json`;this.downloadObjectAsJson(emergencyKit,fileName);return fileName}else{throw new Error("Download not supported in this environment")}}static async downloadBulkEmergencyKit(bulkEmergencyKit){try{if(typeof window!=="undefined"&&window.document){const fileName=`yakkl-bulk-emergency-kit-${bulkEmergencyKit.meta.id}-${bulkEmergencyKit.meta.createDate}.json`;this.downloadObjectAsJson(bulkEmergencyKit,fileName);return fileName}else{throw new Error("Download not supported in this environment")}}catch(error){console.log("[ERROR]: Error downloading bulk emergency kit:",false,error);throw error}}static async importEmergencyKit(source,passwordOrSaltedKey){let fileContent;if(source instanceof File){fileContent=await source.text()}else{fileContent=this.cloudImport("source")}const emergencyKit=JSON.parse(fileContent);if(isEncryptedData(emergencyKit.data)){emergencyKit.accounts=await decryptData(emergencyKit.data,passwordOrSaltedKey)}return emergencyKit}static async importBulkEmergencyKit(source,passwordOrSaltedKey){try{let fileContent;if(source instanceof File){fileContent=await source.text()}else{throw new Error("Unsupported source type")}const bulkEmergencyKit=JSON.parse(fileContent);const calculatedCS=await this.createHash(JSON.stringify(bulkEmergencyKit.meta)+JSON.stringify(bulkEmergencyKit.data));if(calculatedCS!==bulkEmergencyKit.cs){throw new Error("Data integrity check failed")}const newData={};const existingData={};for(const[key,encryptedValue]of Object.entries(bulkEmergencyKit.data)){const decryptedData=await this.decryptWithChecksumVerification(encryptedValue,passwordOrSaltedKey);const dataExists=await this.checkDataExists(key,decryptedData);if(dataExists){existingData[key]=decryptedData}else{newData[key]=decryptedData}}return{newData:newData,existingData:existingData}}catch(error){log.error("Error importing bulk emergency kit:",false,error);throw error}}static async readEmergencyKitMetadata(source){let fileContent;if(source instanceof File){fileContent=await source.text()}else{throw new Error("Unsupported source type")}const emergencyKit=JSON.parse(fileContent);return emergencyKit.meta}static async readBulkEmergencyKitMetadata(source){try{let fileContent;if(source instanceof File){fileContent=await source.text()}else{throw new Error("Unsupported source type")}const bulkEmergencyKit=JSON.parse(fileContent);return bulkEmergencyKit.meta}catch(error){log.error("Error reading bulk emergency kit metadata:",false,error);throw error}}static async checkDataExists(key,data){return false}static cloudImport(source){return""}static async createHash(data){const encoder=new TextEncoder;const dataBuffer=encoder.encode(data);const hashBuffer=await crypto.subtle.digest("SHA-256",dataBuffer);const hashArray=Array.from(new Uint8Array(hashBuffer));return hashArray.map(byte=>byte.toString(16).padStart(2,"0")).join("")}static async decryptWithChecksumVerification(encryptedData,passwordOrSaltedKey){try{const decryptedData=await decryptData(encryptedData,passwordOrSaltedKey);const calculatedChecksum=await this.createHash(JSON.stringify(decryptedData.data));if(calculatedChecksum!==decryptedData.cs){throw new Error("Data integrity check failed")}return decryptedData.data}catch(error){log.error("Error decrypting data:",false,error);throw error}}static downloadObjectAsJson(exportObj,exportName){try{const dataStr="data:text/json;charset=utf-8,"+encodeURIComponent(JSON.stringify(exportObj));const downloadAnchorNode=document.createElement("a");downloadAnchorNode.setAttribute("href",dataStr);downloadAnchorNode.setAttribute("download",exportName);document.body.appendChild(downloadAnchorNode);downloadAnchorNode.click();downloadAnchorNode.remove()}catch(e){log.error(`Download failed: ${e}`)}}static async encryptWithChecksum(data,passwordOrSaltedKey){try{const jsonString=JSON.stringify(data);const checksum=await this.createHash(jsonString);const encryptedData=await encryptData({cs:checksum,data:data},passwordOrSaltedKey);return encryptedData}catch(error){log.error("Error encrypting data:",false,error);throw error}}static generateId(){return"xxxxxx".replace(/x/g,()=>Math.floor(Math.random()*16).toString(16))}}export{EmergencyKitManager as E};
//# sourceMappingURL=BGfGzDFG.js.map
