{"version":3,"file":"B2gA1VsD.js","sources":["../../../../../../../../node_modules/.pnpm/svelte@5.34.3/node_modules/svelte/src/store/utils.js","../../../../../../../../node_modules/.pnpm/svelte@5.34.3/node_modules/svelte/src/store/shared/index.js"],"sourcesContent":["/** @import { Readable } from './public' */\nimport { untrack } from '../index-client.js';\nimport { noop } from '../internal/shared/utils.js';\n\n/**\n * @template T\n * @param {Readable<T> | null | undefined} store\n * @param {(value: T) => void} run\n * @param {(value: T) => void} [invalidate]\n * @returns {() => void}\n */\nexport function subscribe_to_store(store, run, invalidate) {\n\tif (store == null) {\n\t\t// @ts-expect-error\n\t\trun(undefined);\n\n\t\t// @ts-expect-error\n\t\tif (invalidate) invalidate(undefined);\n\n\t\treturn noop;\n\t}\n\n\t// Svelte store takes a private second argument\n\t// StartStopNotifier could mutate state, and we want to silence the corresponding validation error\n\tconst unsub = untrack(() =>\n\t\tstore.subscribe(\n\t\t\trun,\n\t\t\t// @ts-expect-error\n\t\t\tinvalidate\n\t\t)\n\t);\n\n\t// Also support RxJS\n\t// @ts-expect-error TODO fix this in the types?\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n","/** @import { Readable, StartStopNotifier, Subscriber, Unsubscriber, Updater, Writable } from '../public.js' */\n/** @import { Stores, StoresValues, SubscribeInvalidateTuple } from '../private.js' */\nimport { noop, run_all } from '../../internal/shared/utils.js';\nimport { safe_not_equal } from '../../internal/client/reactivity/equality.js';\nimport { subscribe_to_store } from '../utils.js';\n\n/**\n * @type {Array<SubscribeInvalidateTuple<any> | any>}\n */\nconst subscriber_queue = [];\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n *\n * @template T\n * @param {T} [value] initial value\n * @param {StartStopNotifier<T>} [start]\n * @returns {Readable<T>}\n */\nexport function readable(value, start) {\n\treturn {\n\t\tsubscribe: writable(value, start).subscribe\n\t};\n}\n\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n *\n * @template T\n * @param {T} [value] initial value\n * @param {StartStopNotifier<T>} [start]\n * @returns {Writable<T>}\n */\nexport function writable(value, start = noop) {\n\t/** @type {Unsubscriber | null} */\n\tlet stop = null;\n\n\t/** @type {Set<SubscribeInvalidateTuple<T>>} */\n\tconst subscribers = new Set();\n\n\t/**\n\t * @param {T} new_value\n\t * @returns {void}\n\t */\n\tfunction set(new_value) {\n\t\tif (safe_not_equal(value, new_value)) {\n\t\t\tvalue = new_value;\n\t\t\tif (stop) {\n\t\t\t\t// store is ready\n\t\t\t\tconst run_queue = !subscriber_queue.length;\n\t\t\t\tfor (const subscriber of subscribers) {\n\t\t\t\t\tsubscriber[1]();\n\t\t\t\t\tsubscriber_queue.push(subscriber, value);\n\t\t\t\t}\n\t\t\t\tif (run_queue) {\n\t\t\t\t\tfor (let i = 0; i < subscriber_queue.length; i += 2) {\n\t\t\t\t\t\tsubscriber_queue[i][0](subscriber_queue[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t\tsubscriber_queue.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Updater<T>} fn\n\t * @returns {void}\n\t */\n\tfunction update(fn) {\n\t\tset(fn(/** @type {T} */ (value)));\n\t}\n\n\t/**\n\t * @param {Subscriber<T>} run\n\t * @param {() => void} [invalidate]\n\t * @returns {Unsubscriber}\n\t */\n\tfunction subscribe(run, invalidate = noop) {\n\t\t/** @type {SubscribeInvalidateTuple<T>} */\n\t\tconst subscriber = [run, invalidate];\n\t\tsubscribers.add(subscriber);\n\t\tif (subscribers.size === 1) {\n\t\t\tstop = start(set, update) || noop;\n\t\t}\n\t\trun(/** @type {T} */ (value));\n\t\treturn () => {\n\t\t\tsubscribers.delete(subscriber);\n\t\t\tif (subscribers.size === 0 && stop) {\n\t\t\t\tstop();\n\t\t\t\tstop = null;\n\t\t\t}\n\t\t};\n\t}\n\treturn { set, update, subscribe };\n}\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * @template {Stores} S\n * @template T\n * @overload\n * @param {S} stores\n * @param {(values: StoresValues<S>, set: (value: T) => void, update: (fn: Updater<T>) => void) => Unsubscriber | void} fn\n * @param {T} [initial_value]\n * @returns {Readable<T>}\n */\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * @template {Stores} S\n * @template T\n * @overload\n * @param {S} stores\n * @param {(values: StoresValues<S>) => T} fn\n * @param {T} [initial_value]\n * @returns {Readable<T>}\n */\n/**\n * @template {Stores} S\n * @template T\n * @param {S} stores\n * @param {Function} fn\n * @param {T} [initial_value]\n * @returns {Readable<T>}\n */\nexport function derived(stores, fn, initial_value) {\n\tconst single = !Array.isArray(stores);\n\t/** @type {Array<Readable<any>>} */\n\tconst stores_array = single ? [stores] : stores;\n\tif (!stores_array.every(Boolean)) {\n\t\tthrow new Error('derived() expects stores as input, got a falsy value');\n\t}\n\tconst auto = fn.length < 2;\n\treturn readable(initial_value, (set, update) => {\n\t\tlet started = false;\n\t\t/** @type {T[]} */\n\t\tconst values = [];\n\t\tlet pending = 0;\n\t\tlet cleanup = noop;\n\t\tconst sync = () => {\n\t\t\tif (pending) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcleanup();\n\t\t\tconst result = fn(single ? values[0] : values, set, update);\n\t\t\tif (auto) {\n\t\t\t\tset(result);\n\t\t\t} else {\n\t\t\t\tcleanup = typeof result === 'function' ? result : noop;\n\t\t\t}\n\t\t};\n\t\tconst unsubscribers = stores_array.map((store, i) =>\n\t\t\tsubscribe_to_store(\n\t\t\t\tstore,\n\t\t\t\t(value) => {\n\t\t\t\t\tvalues[i] = value;\n\t\t\t\t\tpending &= ~(1 << i);\n\t\t\t\t\tif (started) {\n\t\t\t\t\t\tsync();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tpending |= 1 << i;\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\t\tstarted = true;\n\t\tsync();\n\t\treturn function stop() {\n\t\t\trun_all(unsubscribers);\n\t\t\tcleanup();\n\t\t\t// We need to set this to false because callbacks can still happen despite having unsubscribed:\n\t\t\t// Callbacks might already be placed in the queue which doesn't know it should no longer\n\t\t\t// invoke this derived store.\n\t\t\tstarted = false;\n\t\t};\n\t});\n}\n\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * @template T\n * @param {Readable<T>} store  - store to make readonly\n * @returns {Readable<T>}\n */\nexport function readonly(store) {\n\treturn {\n\t\t// @ts-expect-error TODO i suspect the bind is unnecessary\n\t\tsubscribe: store.subscribe.bind(store)\n\t};\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * @template T\n * @param {Readable<T>} store\n * @returns {T}\n */\nexport function get(store) {\n\tlet value;\n\tsubscribe_to_store(store, (_) => (value = _))();\n\t// @ts-expect-error\n\treturn value;\n}\n"],"names":["subscribe_to_store","store","run","invalidate","noop","unsub","untrack","subscribe","unsubscribe","subscriber_queue","readable","value","start","writable","stop","subscribers","Set","set","new_value","safe_not_equal","run_queue","length","subscriber","push","i","update","fn","add","size","delete","derived","stores","initial_value","single","Array","isArray","stores_array","every","Boolean","Error","auto","started","values","pending","cleanup","sync","result","unsubscribers","map","run_all","get","_"],"mappings":"sFAWO,SAASA,mBAAmBC,MAAOC,IAAKC,YAC9C,GAAIF,OAAS,KAAM,CAElBC,SAAa,GAGT,GAAAC,2BAAgC,GAE7B,OAAAC,IACT,CAIC,MAAMC,MAAQC,QAAQ,IACrBL,MAAMM,UACLL,IAEAC,aAMF,OAAOE,MAAMG,YAAc,IAAMH,MAAMG,cAAgBH,KACxD,CC1BA,MAAMI,iBAAmB,GAUlB,SAASC,SAASC,MAAOC,OACxB,MAAA,CACNL,UAAWM,SAASF,MAAOC,OAAOL,UAEpC,CAUO,SAASM,SAASF,MAAOC,MAAQR,MAEvC,IAAIU,KAAO,KAGL,MAAAC,gBAAkBC,IAMxB,SAASC,IAAIC,WACR,GAAAC,eAAeR,MAAOO,WAAY,CAC7BP,MAAAO,UACR,GAAIJ,KAAM,CAEH,MAAAM,WAAaX,iBAAiBY,OACpC,IAAA,MAAWC,cAAcP,YAAa,CACrCO,WAAW,KACMb,iBAAAc,KAAKD,WAAYX,MACvC,CACI,GAAIS,UAAW,CACd,IAAA,IAASI,EAAI,EAAGA,EAAIf,iBAAiBY,OAAQG,GAAK,EAAG,CACpDf,iBAAiBe,GAAG,GAAGf,iBAAiBe,EAAI,GAClD,CACKf,iBAAiBY,OAAS,CAC/B,CACA,CACA,CACA,CAMC,SAASI,OAAOC,IACXT,IAAAS,GAAqBf,OAC3B,CAOU,SAAAJ,UAAUL,IAAKC,WAAaC,MAE9B,MAAAkB,WAAa,CAACpB,IAAKC,YACzBY,YAAYY,IAAIL,YACZ,GAAAP,YAAYa,OAAS,EAAG,CACpBd,KAAAF,MAAMK,IAAKQ,SAAWrB,IAChC,CACEF,IAAsBS,OACtB,MAAO,KACNI,YAAYc,OAAOP,YACf,GAAAP,YAAYa,OAAS,GAAKd,KAAM,CAC7BA,OACCA,KAAA,IACX,EAEA,CACQ,MAAA,CAAEG,QAAKQ,cAAQlB,oBACvB,CAkCO,SAASuB,QAAQC,OAAQL,GAAIM,eACnC,MAAMC,QAAUC,MAAMC,QAAQJ,QAE9B,MAAMK,aAAeH,OAAS,CAACF,QAAUA,OACzC,IAAKK,aAAaC,MAAMC,SAAU,CAC3B,MAAA,IAAIC,MAAM,uDAClB,CACO,MAAAC,KAAOd,GAAGL,OAAS,EACzB,OAAOX,SAASsB,cAAe,CAACf,IAAKQ,UACpC,IAAIgB,QAAU,MAEd,MAAMC,OAAS,GACf,IAAIC,QAAU,EACd,IAAIC,QAAUxC,KACd,MAAMyC,KAAO,KACZ,GAAIF,QAAS,CACZ,MACJ,CACYC,UACH,MAAAE,OAASpB,GAAGO,OAASS,OAAO,GAAKA,OAAQzB,IAAKQ,QACpD,GAAIe,KAAM,CACTvB,IAAI6B,OACR,KAAU,CACIF,eAAOE,SAAW,WAAaA,OAAS1C,IACtD,GAEE,MAAM2C,cAAgBX,aAAaY,IAAI,CAAC/C,MAAOuB,IAC9CxB,mBACCC,MACCU,QACA+B,OAAOlB,GAAKb,MACZgC,WAAa,GAAKnB,GAClB,GAAIiB,QAAS,CACNI,MACZ,GAEI,KACCF,SAAW,GAAKnB,KAITiB,QAAA,KACJI,OACN,OAAO,SAAS/B,OACfmC,QAAQF,eACCH,UAICH,QAAA,KACV,GAEH,CAuBO,SAASS,IAAIjD,OACf,IAAAU,MACJX,mBAAmBC,MAAQkD,GAAOxC,MAAQwC,EAA1CnD,GAEO,OAAAW,KACR","x_google_ignoreList":[0,1]}