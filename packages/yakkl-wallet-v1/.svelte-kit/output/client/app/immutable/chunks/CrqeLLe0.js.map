{"version":3,"mappings":"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","names":["createPriceUpdater","priceManager","tokens","writable","subscribe","set","async","fetchPrices","tokensArray","BATCH_SIZE","updatedTokens","length","log","error","i","batch","slice","batchResults","Promise","all","map","token","fetchTokenData","push","pair","symbol","marketPrice","getMarketPrice","price","adjustedBalance","balance","Number","decimals","value","provider","lastUpdated","Date","formattedValue","Intl","NumberFormat","style","currency","format","priceUpdater","fetchingActive","updateTokenPrices","get","info","yakklCombinedTokenStore","warn","update","setYakklCombinedTokenStorage","balanceCacheManager","__vitePreload","import","__VITE_PRELOAD__","url","ethToken","find","isNative","updatePriceForAllEntries","debug","newPrice","timerManager","TimerManager","getInstance","hasTimer","PriceManager","addTimer","TIMER_TOKEN_PRICE_CYCLE_TIME","isRunning","startTimer"],"ignoreList":[],"sources":["../../../../../../src/lib/common/createPriceUpdater.ts","../../../../../../src/lib/common/tokenPriceManager.ts"],"sourcesContent":["import { writable } from 'svelte/store';\nimport type { TokenData } from './interfaces';\nimport type { PriceManager } from '$lib/managers/PriceManager';\nimport { log } from '$lib/managers/Logger';\n\n// Utility for debouncing\nfunction debounce(func: (...args: any[]) => void, delay: number) {\n\tlet timeoutId: ReturnType<typeof setTimeout>;\n\treturn (...args: any[]) => {\n\t\tclearTimeout(timeoutId);\n\t\ttimeoutId = setTimeout(() => func(...args), delay);\n\t};\n}\n\nexport function createPriceUpdater(priceManager: PriceManager) {\n\tconst tokens = writable<TokenData[]>([]);\n\tconst { subscribe, set } = tokens;\n\n\tasync function fetchPrices(tokensArray: TokenData[]): Promise<TokenData[]> {\n\t\tconst BATCH_SIZE = 8; // Adjust batch size for performance\n\t\tconst updatedTokens: TokenData[] = [];\n\n\t\tif (!tokensArray || tokensArray.length === 0) {\n\t\t\tlog.error('fetchPrices - No tokens to process. Exiting early.');\n\t\t\treturn [];\n\t\t}\n\n\t\tfor (let i = 0; i < tokensArray.length; i += BATCH_SIZE) {\n\t\t\tconst batch = tokensArray.slice(i, i + BATCH_SIZE);\n\n\t\t\ttry {\n\t\t\t\tconst batchResults = await Promise.all(\n\t\t\t\t\tbatch.map(async (token) => {\n\t\t\t\t\t\treturn fetchTokenData(token, priceManager);\n\t\t\t\t\t})\n\t\t\t\t);\n\n\t\t\t\tupdatedTokens.push(...batchResults);\n\t\t\t} catch (error) {\n\t\t\t\tlog.error('fetchPrices - Error processing batch:', false, batch, false, error);\n\t\t\t}\n\t\t}\n\t\treturn updatedTokens;\n\t}\n\n\tasync function fetchTokenData(token: TokenData, priceManager: PriceManager): Promise<TokenData> {\n\t\tconst pair = `${token.symbol}-USD`;\n\t\ttry {\n\t\t\tconst marketPrice = await priceManager.getMarketPrice(pair);\n\t\t\tconst price = marketPrice?.price ?? 0;\n\n\t\t\t// Fix for handling decimals in calculations\n\t\t\tconst adjustedBalance = token.balance ? Number(token.balance) / 10 ** token.decimals : 0;\n\t\t\tconst value = adjustedBalance * price;\n\n\t\t\treturn {\n\t\t\t\t...token,\n\t\t\t\tprice: {\n\t\t\t\t\tprice: price,\n\t\t\t\t\tprovider: marketPrice?.provider ?? '',\n\t\t\t\t\tlastUpdated: new Date() // Ensure lastUpdated is present\n\t\t\t\t},\n\t\t\t\tvalue,\n\t\t\t\tformattedValue: new Intl.NumberFormat('en-US', {\n\t\t\t\t\tstyle: 'currency',\n\t\t\t\t\tcurrency: 'USD'\n\t\t\t\t}).format(value)\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tlog.error(`fetchTokenData - Failed to fetch price for ${token.symbol}`, false, error);\n\t\t\treturn {\n\t\t\t\t...token,\n\t\t\t\tprice: { price: 0, provider: '', lastUpdated: new Date() }, // Ensures lastUpdated is present, status removed\n\t\t\t\tvalue: 0\n\t\t\t};\n\t\t}\n\t}\n\n\t// Debounced fetch to reduce frequent updates\n\tconst debouncedFetchPrices = debounce(fetchPrices, 5000);\n\n\treturn { subscribe, fetchPrices };\n}\n","import { writable, get } from 'svelte/store';\nimport { yakklCombinedTokenStore, setYakklCombinedTokenStorage } from '$lib/common/stores';\nimport { log } from '$lib/managers/Logger';\nimport { PriceManager } from '$lib/managers/PriceManager';\nimport { createPriceUpdater } from './createPriceUpdater';\nimport { TimerManager } from '$lib/managers/TimerManager';\nimport type { TokenData } from '$lib/common/interfaces';\nimport { TIMER_TOKEN_PRICE_CYCLE_TIME } from './constants';\n\nlet priceManager: PriceManager | null = null;\nlet priceUpdater: any | null = null;\n\nconst fetchingActive = writable(false); // Prevents duplicate fetches\n\n// NOTE: May want to pass in priceManager as a parameter to allow for different configurations\nexport async function updateTokenPrices() {\n\tif (get(fetchingActive)) return; // Prevent concurrent fetches\n\tfetchingActive.set(true);\n\n\ttry {\n\t\tlog.info('updateTokenPrices: Starting price update');\n\t\tconst tokens: TokenData[] = get(yakklCombinedTokenStore); // Ensure we're working with the correct store\n\t\tif (tokens.length === 0) {\n\t\t\tlog.info('updateTokenPrices: No tokens to update');\n\t\t\treturn;\n\t\t}\n\n\t\tconst updatedTokens: TokenData[] = await priceUpdater.fetchPrices(tokens);\n\t\tif (!updatedTokens || updatedTokens.length === 0) {\n\t\t\tlog.warn('updateTokenPrices: Fetched prices returned empty.');\n\t\t\treturn;\n\t\t}\n\n\t\t// Update the store\n\t\tyakklCombinedTokenStore.update(() => updatedTokens);\n\n\t\t// Persist to localStorage\n\t\tawait setYakklCombinedTokenStorage(updatedTokens);\n\n\t\t// Update cached balances with new token prices\n\t\tconst { balanceCacheManager } = await import('$lib/managers/BalanceCacheManager');\n\t\tconst ethToken = updatedTokens.find((token) => token.isNative && token.symbol === 'ETH');\n\t\tif (ethToken && ethToken.value && ethToken.value > 0) {\n\t\t\tbalanceCacheManager.updatePriceForAllEntries(ethToken.value);\n\t\t\tlog.debug('[updateTokenPrices] Updated cached entries with ETH price:', false, {\n\t\t\t\tnewPrice: ethToken.value\n\t\t\t});\n\t\t}\n\n\t\tlog.info('updateTokenPrices: Successfully updated and persisted token prices');\n\t} catch (error) {\n\t\tlog.error('updateTokenPrices: Failed to update token prices', false, error);\n\t} finally {\n\t\tfetchingActive.set(false);\n\t}\n}\n\n// Get the TimerManager instance\nconst timerManager = TimerManager.getInstance();\n\nif (!timerManager.hasTimer('tokenPriceUpdater')) {\n\tlog.info('Setting up token price updater timer');\n\tif (!priceManager) {\n\t\tpriceManager = new PriceManager();\n\t}\n\tif (!priceUpdater) {\n\t\tpriceUpdater = createPriceUpdater(priceManager);\n\t}\n\t// Setup a timer to call `updateTokenPrices()` every 15s\n\ttimerManager.addTimer(\n\t\t'tokenPriceUpdater',\n\t\tasync () => {\n\t\t\tawait updateTokenPrices();\n\t\t},\n\t\tTIMER_TOKEN_PRICE_CYCLE_TIME\n\t);\n}\n\nif (!timerManager.isRunning('tokenPriceUpdater')) {\n\tlog.info('Starting token price updater timer');\n\ttimerManager.startTimer('tokenPriceUpdater');\n}\n"],"file":"app/immutable/chunks/CrqeLLe0.js"}