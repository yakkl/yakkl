{"version":3,"file":"DNmXX2Qc.js","sources":["../../../../../../src/lib/managers/AccountTokenCacheManager.ts"],"sourcesContent":["import { log } from '$lib/managers/Logger';\nimport type { TokenData } from '$lib/common/interfaces';\nimport type { BigNumberish } from '$lib/common/bignumber';\n\nexport interface CachedTokenData extends TokenData {\n\ttimestamp: number;\n\taccountAddress: string;\n}\n\nexport interface AccountTokenCache {\n\t[accountAddress: string]: {\n\t\ttokens: Map<string, CachedTokenData>;\n\t\tlastUpdated: number;\n\t\tportfolioValue?: number;\n\t\tportfolioValueCurrency?: string;\n\t};\n}\n\nexport class AccountTokenCacheManager {\n\tprivate static instance: AccountTokenCacheManager | null = null;\n\tprivate readonly CACHE_KEY = 'yakkl_account_token_cache';\n\tprivate readonly CACHE_DURATION = 15 * 60 * 1000; // 15 minutes (increased from 5 to reduce API calls)\n\tprivate readonly STALE_DURATION = 10 * 60 * 1000; // 10 minutes (increased from 2 to reduce background refreshes)\n\tprivate readonly PORTFOLIO_CACHE_DURATION = 20 * 60 * 1000; // 20 minutes for portfolio calculations (increased from 10)\n\tprivate cache: AccountTokenCache = {};\n\n\tprivate constructor() {\n\t\tthis.loadFromStorage();\n\t}\n\n\tpublic static getInstance(): AccountTokenCacheManager {\n\t\tif (!AccountTokenCacheManager.instance) {\n\t\t\tAccountTokenCacheManager.instance = new AccountTokenCacheManager();\n\t\t}\n\t\treturn AccountTokenCacheManager.instance;\n\t}\n\n\t/**\n\t * Get cached tokens for a specific account\n\t */\n\tpublic getCachedTokensForAccount(accountAddress: string): TokenData[] | null {\n\t\tconst account = this.cache[accountAddress.toLowerCase()];\n\t\tif (!account) return null;\n\n\t\t// Check if cache is expired\n\t\tconst age = Date.now() - account.lastUpdated;\n\t\tif (age > this.CACHE_DURATION) {\n\t\t\tdelete this.cache[accountAddress.toLowerCase()];\n\t\t\tthis.saveToStorage();\n\t\t\treturn null;\n\t\t}\n\n\t\treturn Array.from(account.tokens.values()).map((token) => {\n\t\t\tconst { timestamp, ...tokenData } = token;\n\t\t\treturn tokenData as TokenData;\n\t\t});\n\t}\n\n\t/**\n\t * Get a specific cached token for an account\n\t */\n\tpublic getCachedToken(accountAddress: string, tokenAddress: string): TokenData | null {\n\t\tconst account = this.cache[accountAddress.toLowerCase()];\n\t\tif (!account) return null;\n\n\t\tconst token = account.tokens.get(tokenAddress.toLowerCase());\n\t\tif (!token) return null;\n\n\t\t// Check if cache is expired\n\t\tconst age = Date.now() - token.timestamp;\n\t\tif (age > this.CACHE_DURATION) {\n\t\t\taccount.tokens.delete(tokenAddress.toLowerCase());\n\t\t\tthis.saveToStorage();\n\t\t\treturn null;\n\t\t}\n\n\t\tconst { timestamp, ...tokenData } = token;\n\t\treturn tokenData as TokenData;\n\t}\n\n\t/**\n\t * Check if cached data is stale for an account\n\t */\n\tpublic isAccountTokensStale(accountAddress: string): boolean {\n\t\tconst account = this.cache[accountAddress.toLowerCase()];\n\t\tif (!account) return false;\n\n\t\tconst age = Date.now() - account.lastUpdated;\n\t\treturn age > this.STALE_DURATION;\n\t}\n\n\t/**\n\t * Check if a specific token is stale for an account\n\t */\n\tpublic isTokenStale(accountAddress: string, tokenAddress: string): boolean {\n\t\tconst account = this.cache[accountAddress.toLowerCase()];\n\t\tif (!account) return false;\n\n\t\tconst token = account.tokens.get(tokenAddress.toLowerCase());\n\t\tif (!token) return false;\n\n\t\tconst age = Date.now() - token.timestamp;\n\t\treturn age > this.STALE_DURATION;\n\t}\n\n\t/**\n\t * Cache tokens for a specific account\n\t */\n\tpublic setCachedTokensForAccount(accountAddress: string, tokens: TokenData[]): void {\n\t\tconst normalizedAddress = accountAddress.toLowerCase();\n\t\tconst timestamp = Date.now();\n\n\t\tif (!this.cache[normalizedAddress]) {\n\t\t\tthis.cache[normalizedAddress] = {\n\t\t\t\ttokens: new Map(),\n\t\t\t\tlastUpdated: timestamp\n\t\t\t};\n\t\t}\n\n\t\t// Clear existing tokens and add new ones\n\t\tthis.cache[normalizedAddress].tokens.clear();\n\t\tthis.cache[normalizedAddress].lastUpdated = timestamp;\n\n\t\ttokens.forEach((token) => {\n\t\t\tif (token.address) {\n\t\t\t\tconst cachedToken: CachedTokenData = {\n\t\t\t\t\t...token,\n\t\t\t\t\ttimestamp,\n\t\t\t\t\taccountAddress: normalizedAddress\n\t\t\t\t};\n\t\t\t\tthis.cache[normalizedAddress].tokens.set(token.address.toLowerCase(), cachedToken);\n\t\t\t}\n\t\t});\n\n\t\tthis.saveToStorage();\n\n\t\tlog.debug('[AccountTokenCacheManager] Cached tokens for account:', false, {\n\t\t\taddress: normalizedAddress,\n\t\t\ttokenCount: tokens.length\n\t\t});\n\t}\n\n\t/**\n\t * Update a specific token for an account\n\t */\n\tpublic updateTokenForAccount(accountAddress: string, token: TokenData): void {\n\t\tconst normalizedAddress = accountAddress.toLowerCase();\n\t\tconst timestamp = Date.now();\n\n\t\tif (!this.cache[normalizedAddress]) {\n\t\t\tthis.cache[normalizedAddress] = {\n\t\t\t\ttokens: new Map(),\n\t\t\t\tlastUpdated: timestamp\n\t\t\t};\n\t\t}\n\n\t\tif (token.address) {\n\t\t\tconst cachedToken: CachedTokenData = {\n\t\t\t\t...token,\n\t\t\t\ttimestamp,\n\t\t\t\taccountAddress: normalizedAddress\n\t\t\t};\n\n\t\t\tthis.cache[normalizedAddress].tokens.set(token.address.toLowerCase(), cachedToken);\n\t\t\tthis.cache[normalizedAddress].lastUpdated = timestamp;\n\t\t\tthis.saveToStorage();\n\n\t\t\tlog.debug('[AccountTokenCacheManager] Updated token for account:', false, {\n\t\t\t\taddress: normalizedAddress,\n\t\t\t\ttokenSymbol: token.symbol,\n\t\t\t\ttokenAddress: token.address\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Cache portfolio value for an account\n\t */\n\tpublic setCachedPortfolioValue(\n\t\taccountAddress: string,\n\t\tvalue: number,\n\t\tcurrency: string = 'USD'\n\t): void {\n\t\tconst normalizedAddress = accountAddress.toLowerCase();\n\n\t\tif (!this.cache[normalizedAddress]) {\n\t\t\tthis.cache[normalizedAddress] = {\n\t\t\t\ttokens: new Map(),\n\t\t\t\tlastUpdated: Date.now()\n\t\t\t};\n\t\t}\n\n\t\tthis.cache[normalizedAddress].portfolioValue = value;\n\t\tthis.cache[normalizedAddress].portfolioValueCurrency = currency;\n\t\tthis.saveToStorage();\n\n\t\tlog.debug('[AccountTokenCacheManager] Cached portfolio value for account:', false, {\n\t\t\taddress: normalizedAddress,\n\t\t\tvalue,\n\t\t\tcurrency\n\t\t});\n\t}\n\n\t/**\n\t * Get cached portfolio value for an account\n\t */\n\tpublic getCachedPortfolioValue(\n\t\taccountAddress: string\n\t): { value: number; currency: string } | null {\n\t\tconst account = this.cache[accountAddress.toLowerCase()];\n\t\tif (!account || account.portfolioValue === undefined) return null;\n\n\t\t// Check if portfolio cache is expired\n\t\tconst age = Date.now() - account.lastUpdated;\n\t\tif (age > this.PORTFOLIO_CACHE_DURATION) {\n\t\t\tif (account.portfolioValue !== undefined) {\n\t\t\t\tdelete account.portfolioValue;\n\t\t\t\tdelete account.portfolioValueCurrency;\n\t\t\t\tthis.saveToStorage();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tvalue: account.portfolioValue,\n\t\t\tcurrency: account.portfolioValueCurrency || 'USD'\n\t\t};\n\t}\n\n\t/**\n\t * Check if portfolio value is stale for an account\n\t */\n\tpublic isPortfolioValueStale(accountAddress: string): boolean {\n\t\tconst account = this.cache[accountAddress.toLowerCase()];\n\t\tif (!account || account.portfolioValue === undefined) return false;\n\n\t\tconst age = Date.now() - account.lastUpdated;\n\t\treturn age > this.STALE_DURATION;\n\t}\n\n\t/**\n\t * Remove a specific token from account cache\n\t */\n\tpublic removeTokenFromAccount(accountAddress: string, tokenAddress: string): void {\n\t\tconst account = this.cache[accountAddress.toLowerCase()];\n\t\tif (!account) return;\n\n\t\taccount.tokens.delete(tokenAddress.toLowerCase());\n\t\taccount.lastUpdated = Date.now();\n\t\tthis.saveToStorage();\n\n\t\tlog.debug('[AccountTokenCacheManager] Removed token from account cache:', false, {\n\t\t\taccountAddress: accountAddress.toLowerCase(),\n\t\t\ttokenAddress: tokenAddress.toLowerCase()\n\t\t});\n\t}\n\n\t/**\n\t * Clear all cached data for a specific account\n\t */\n\tpublic clearAccountCache(accountAddress: string): void {\n\t\tdelete this.cache[accountAddress.toLowerCase()];\n\t\tthis.saveToStorage();\n\t\tlog.info('[AccountTokenCacheManager] Cleared cache for account:', false, {\n\t\t\taddress: accountAddress.toLowerCase()\n\t\t});\n\t}\n\n\t/**\n\t * Clear all cached data\n\t */\n\tpublic clearAllCache(): void {\n\t\tthis.cache = {};\n\t\tlocalStorage.removeItem(this.CACHE_KEY);\n\t\tlog.info('[AccountTokenCacheManager] All cache cleared');\n\t}\n\n\t/**\n\t * Get all cached account addresses\n\t */\n\tpublic getCachedAccountAddresses(): string[] {\n\t\treturn Object.keys(this.cache);\n\t}\n\n\t/**\n\t * Clean up expired entries\n\t */\n\tpublic cleanupExpired(): void {\n\t\tconst now = Date.now();\n\t\tlet cleanedAccounts = 0;\n\t\tlet cleanedTokens = 0;\n\n\t\tfor (const [accountAddress, account] of Object.entries(this.cache)) {\n\t\t\t// Check if entire account cache is expired\n\t\t\tif (now - account.lastUpdated > this.CACHE_DURATION) {\n\t\t\t\tdelete this.cache[accountAddress];\n\t\t\t\tcleanedAccounts++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Clean up individual expired tokens\n\t\t\tfor (const [tokenAddress, token] of account.tokens.entries()) {\n\t\t\t\tif (now - token.timestamp > this.CACHE_DURATION) {\n\t\t\t\t\taccount.tokens.delete(tokenAddress);\n\t\t\t\t\tcleanedTokens++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Clean up expired portfolio values\n\t\t\tif (\n\t\t\t\taccount.portfolioValue !== undefined &&\n\t\t\t\tnow - account.lastUpdated > this.PORTFOLIO_CACHE_DURATION\n\t\t\t) {\n\t\t\t\tdelete account.portfolioValue;\n\t\t\t\tdelete account.portfolioValueCurrency;\n\t\t\t}\n\t\t}\n\n\t\tif (cleanedAccounts > 0 || cleanedTokens > 0) {\n\t\t\tthis.saveToStorage();\n\t\t\tlog.info(\n\t\t\t\t`[AccountTokenCacheManager] Cleaned up ${cleanedAccounts} accounts and ${cleanedTokens} tokens`\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Preload tokens for multiple accounts\n\t */\n\tpublic preloadTokensForAccounts(accountAddresses: string[]): Map<string, TokenData[]> {\n\t\tconst preloaded = new Map<string, TokenData[]>();\n\n\t\tfor (const address of accountAddresses) {\n\t\t\tconst tokens = this.getCachedTokensForAccount(address);\n\t\t\tif (tokens) {\n\t\t\t\tpreloaded.set(address.toLowerCase(), tokens);\n\t\t\t}\n\t\t}\n\n\t\tlog.debug(\n\t\t\t`[AccountTokenCacheManager] Preloaded tokens for ${preloaded.size}/${accountAddresses.length} accounts`\n\t\t);\n\t\treturn preloaded;\n\t}\n\n\t/**\n\t * Update token prices for all cached tokens\n\t */\n\tpublic updateTokenPricesForAllAccounts(\n\t\tpriceUpdates: Map<string, { price: number; change?: any }>\n\t): void {\n\t\tlet updatedCount = 0;\n\n\t\tfor (const [accountAddress, account] of Object.entries(this.cache)) {\n\t\t\tfor (const [tokenAddress, token] of account.tokens.entries()) {\n\t\t\t\tconst priceUpdate = priceUpdates.get(tokenAddress);\n\t\t\t\tif (priceUpdate) {\n\t\t\t\t\ttoken.price = {\n\t\t\t\t\t\tprice: priceUpdate.price,\n\t\t\t\t\t\tprovider: 'cache-update',\n\t\t\t\t\t\tlastUpdated: new Date()\n\t\t\t\t\t};\n\t\t\t\t\tif (priceUpdate.change) {\n\t\t\t\t\t\ttoken.change = priceUpdate.change;\n\t\t\t\t\t}\n\t\t\t\t\ttoken.timestamp = Date.now(); // Refresh timestamp since price changed\n\t\t\t\t\tupdatedCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (updatedCount > 0) {\n\t\t\tthis.saveToStorage();\n\t\t\tlog.info(`[AccountTokenCacheManager] Updated prices for ${updatedCount} cached tokens`);\n\t\t}\n\t}\n\n\t/**\n\t * Get cache statistics\n\t */\n\tpublic getCacheStats(): {\n\t\ttotalAccounts: number;\n\t\ttotalTokens: number;\n\t\tfreshAccounts: number;\n\t\tstaleAccounts: number;\n\t\texpiredAccounts: number;\n\t} {\n\t\tconst now = Date.now();\n\t\tlet totalTokens = 0;\n\t\tlet fresh = 0;\n\t\tlet stale = 0;\n\t\tlet expired = 0;\n\n\t\tfor (const account of Object.values(this.cache)) {\n\t\t\ttotalTokens += account.tokens.size;\n\t\t\tconst age = now - account.lastUpdated;\n\n\t\t\tif (age > this.CACHE_DURATION) {\n\t\t\t\texpired++;\n\t\t\t} else if (age > this.STALE_DURATION) {\n\t\t\t\tstale++;\n\t\t\t} else {\n\t\t\t\tfresh++;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttotalAccounts: Object.keys(this.cache).length,\n\t\t\ttotalTokens,\n\t\t\tfreshAccounts: fresh,\n\t\t\tstaleAccounts: stale,\n\t\t\texpiredAccounts: expired\n\t\t};\n\t}\n\n\t/**\n\t * Load cache from localStorage\n\t */\n\tprivate loadFromStorage(): void {\n\t\ttry {\n\t\t\tconst stored = localStorage.getItem(this.CACHE_KEY);\n\t\t\tif (stored) {\n\t\t\t\tconst parsed = JSON.parse(stored);\n\n\t\t\t\t// Convert the stored data back to the proper structure\n\t\t\t\tthis.cache = {};\n\t\t\t\tfor (const [accountAddress, accountData] of Object.entries(parsed)) {\n\t\t\t\t\tconst typedAccountData = accountData as any;\n\t\t\t\t\tthis.cache[accountAddress] = {\n\t\t\t\t\t\tlastUpdated: typedAccountData.lastUpdated,\n\t\t\t\t\t\tportfolioValue: typedAccountData.portfolioValue,\n\t\t\t\t\t\tportfolioValueCurrency: typedAccountData.portfolioValueCurrency,\n\t\t\t\t\t\ttokens: new Map()\n\t\t\t\t\t};\n\n\t\t\t\t\t// Restore tokens map\n\t\t\t\t\tif (typedAccountData.tokens) {\n\t\t\t\t\t\tfor (const [tokenAddress, tokenData] of Object.entries(typedAccountData.tokens)) {\n\t\t\t\t\t\t\tconst typedTokenData = tokenData as any;\n\t\t\t\t\t\t\t// Convert balance back to BigInt if it exists\n\t\t\t\t\t\t\tif (typedTokenData.balance && typeof typedTokenData.balance === 'string') {\n\t\t\t\t\t\t\t\ttypedTokenData.balance = BigInt(typedTokenData.balance);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.cache[accountAddress].tokens.set(tokenAddress, typedTokenData);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Clean up expired entries on load\n\t\t\t\tthis.cleanupExpired();\n\n\t\t\t\tlog.debug(\n\t\t\t\t\t`[AccountTokenCacheManager] Loaded cache for ${Object.keys(this.cache).length} accounts`\n\t\t\t\t);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlog.warn('[AccountTokenCacheManager] Failed to load cache from storage:', false, error);\n\t\t\tthis.cache = {};\n\t\t}\n\t}\n\n\t/**\n\t * Save cache to localStorage\n\t */\n\tprivate saveToStorage(): void {\n\t\ttry {\n\t\t\t// Convert Maps to objects for JSON serialization\n\t\t\tconst serializable: any = {};\n\n\t\t\tfor (const [accountAddress, account] of Object.entries(this.cache)) {\n\t\t\t\tserializable[accountAddress] = {\n\t\t\t\t\tlastUpdated: account.lastUpdated,\n\t\t\t\t\tportfolioValue: account.portfolioValue,\n\t\t\t\t\tportfolioValueCurrency: account.portfolioValueCurrency,\n\t\t\t\t\ttokens: {}\n\t\t\t\t};\n\n\t\t\t\t// Convert token Map to object and handle BigInt serialization\n\t\t\t\tfor (const [tokenAddress, token] of account.tokens.entries()) {\n\t\t\t\t\tconst serializableToken = { ...token };\n\n\t\t\t\t\t// Convert BigInt to string for JSON serialization\n\t\t\t\t\tif (serializableToken.balance && typeof serializableToken.balance === 'bigint') {\n\t\t\t\t\t\tserializableToken.balance = serializableToken.balance.toString() as any;\n\t\t\t\t\t}\n\n\t\t\t\t\tserializable[accountAddress].tokens[tokenAddress] = serializableToken;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlocalStorage.setItem(this.CACHE_KEY, JSON.stringify(serializable));\n\t\t} catch (error) {\n\t\t\tlog.warn('[AccountTokenCacheManager] Failed to save cache to storage:', false, error);\n\t\t}\n\t}\n}\n\n// Export singleton instance\nexport const accountTokenCacheManager = AccountTokenCacheManager.getInstance();\n"],"names":["_AccountTokenCacheManager","constructor","__publicField","this","loadFromStorage","getInstance","instance","getCachedTokensForAccount","accountAddress","account","cache","toLowerCase","age","Date","now","lastUpdated","CACHE_DURATION","saveToStorage","Array","from","tokens","values","map","token","timestamp","tokenData","getCachedToken","tokenAddress","get","delete","isAccountTokensStale","STALE_DURATION","isTokenStale","setCachedTokensForAccount","normalizedAddress","Map","clear","forEach","address","cachedToken","set","log","debug","tokenCount","length","updateTokenForAccount","tokenSymbol","symbol","setCachedPortfolioValue","value","currency","portfolioValue","portfolioValueCurrency","getCachedPortfolioValue","PORTFOLIO_CACHE_DURATION","isPortfolioValueStale","removeTokenFromAccount","clearAccountCache","info","clearAllCache","localStorage","removeItem","CACHE_KEY","getCachedAccountAddresses","Object","keys","cleanupExpired","cleanedAccounts","cleanedTokens","entries","preloadTokensForAccounts","accountAddresses","preloaded","size","updateTokenPricesForAllAccounts","priceUpdates","updatedCount","priceUpdate","price","provider","change","getCacheStats","totalTokens","fresh","stale","expired","totalAccounts","freshAccounts","staleAccounts","expiredAccounts","stored","getItem","parsed","JSON","parse","accountData","typedAccountData","typedTokenData","balance","BigInt","error","warn","serializable","serializableToken","toString","setItem","stringify","AccountTokenCacheManager","accountTokenCacheManager"],"mappings":"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"}