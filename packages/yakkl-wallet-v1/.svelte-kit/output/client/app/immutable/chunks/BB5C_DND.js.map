{"version":3,"file":"BB5C_DND.js","sources":["../../../../../../../../node_modules/.pnpm/svelte@5.34.3/node_modules/svelte/src/internal/client/dom/blocks/await.js"],"sourcesContent":["/** @import { Effect, Source, TemplateNode } from '#client' */\nimport { DEV } from 'esm-env';\nimport { is_promise } from '../../../shared/utils.js';\nimport { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js';\nimport { internal_set, mutable_source, source } from '../../reactivity/sources.js';\nimport { flushSync, set_active_effect, set_active_reaction } from '../../runtime.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport { queue_micro_task } from '../task.js';\nimport { HYDRATION_START_ELSE, UNINITIALIZED } from '../../../../constants.js';\nimport {\n\tcomponent_context,\n\tis_runes,\n\tset_component_context,\n\tset_dev_current_component_function\n} from '../../context.js';\n\nconst PENDING = 0;\nconst THEN = 1;\nconst CATCH = 2;\n\n/**\n * @template V\n * @param {TemplateNode} node\n * @param {(() => Promise<V>)} get_input\n * @param {null | ((anchor: Node) => void)} pending_fn\n * @param {null | ((anchor: Node, value: Source<V>) => void)} then_fn\n * @param {null | ((anchor: Node, error: unknown) => void)} catch_fn\n * @returns {void}\n */\nexport function await_block(node, get_input, pending_fn, then_fn, catch_fn) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\tvar runes = is_runes();\n\tvar active_component_context = component_context;\n\n\t/** @type {any} */\n\tvar component_function = DEV ? component_context?.function : null;\n\n\t/** @type {V | Promise<V> | typeof UNINITIALIZED} */\n\tvar input = UNINITIALIZED;\n\n\t/** @type {Effect | null} */\n\tvar pending_effect;\n\n\t/** @type {Effect | null} */\n\tvar then_effect;\n\n\t/** @type {Effect | null} */\n\tvar catch_effect;\n\n\tvar input_source = runes\n\t\t? source(/** @type {V} */ (undefined))\n\t\t: mutable_source(/** @type {V} */ (undefined), false, false);\n\tvar error_source = runes ? source(undefined) : mutable_source(undefined, false, false);\n\tvar resolved = false;\n\n\t/**\n\t * @param {PENDING | THEN | CATCH} state\n\t * @param {boolean} restore\n\t */\n\tfunction update(state, restore) {\n\t\tresolved = true;\n\n\t\tif (restore) {\n\t\t\tset_active_effect(effect);\n\t\t\tset_active_reaction(effect); // TODO do we need both?\n\t\t\tset_component_context(active_component_context);\n\t\t\tif (DEV) set_dev_current_component_function(component_function);\n\t\t}\n\n\t\ttry {\n\t\t\tif (state === PENDING && pending_fn) {\n\t\t\t\tif (pending_effect) resume_effect(pending_effect);\n\t\t\t\telse pending_effect = branch(() => pending_fn(anchor));\n\t\t\t}\n\n\t\t\tif (state === THEN && then_fn) {\n\t\t\t\tif (then_effect) resume_effect(then_effect);\n\t\t\t\telse then_effect = branch(() => then_fn(anchor, input_source));\n\t\t\t}\n\n\t\t\tif (state === CATCH && catch_fn) {\n\t\t\t\tif (catch_effect) resume_effect(catch_effect);\n\t\t\t\telse catch_effect = branch(() => catch_fn(anchor, error_source));\n\t\t\t}\n\n\t\t\tif (state !== PENDING && pending_effect) {\n\t\t\t\tpause_effect(pending_effect, () => (pending_effect = null));\n\t\t\t}\n\n\t\t\tif (state !== THEN && then_effect) {\n\t\t\t\tpause_effect(then_effect, () => (then_effect = null));\n\t\t\t}\n\n\t\t\tif (state !== CATCH && catch_effect) {\n\t\t\t\tpause_effect(catch_effect, () => (catch_effect = null));\n\t\t\t}\n\t\t} finally {\n\t\t\tif (restore) {\n\t\t\t\tif (DEV) set_dev_current_component_function(null);\n\t\t\t\tset_component_context(null);\n\t\t\t\tset_active_reaction(null);\n\t\t\t\tset_active_effect(null);\n\n\t\t\t\t// without this, the DOM does not update until two ticks after the promise\n\t\t\t\t// resolves, which is unexpected behaviour (and somewhat irksome to test)\n\t\t\t\tflushSync();\n\t\t\t}\n\t\t}\n\t}\n\n\tvar effect = block(() => {\n\t\tif (input === (input = get_input())) return;\n\n\t\t/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\t// @ts-ignore coercing `anchor` to a `Comment` causes TypeScript and Prettier to fight\n\t\tlet mismatch = hydrating && is_promise(input) === (anchor.data === HYDRATION_START_ELSE);\n\n\t\tif (mismatch) {\n\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh\n\t\t\tanchor = remove_nodes();\n\n\t\t\tset_hydrate_node(anchor);\n\t\t\tset_hydrating(false);\n\t\t\tmismatch = true;\n\t\t}\n\n\t\tif (is_promise(input)) {\n\t\t\tvar promise = input;\n\n\t\t\tresolved = false;\n\n\t\t\tpromise.then(\n\t\t\t\t(value) => {\n\t\t\t\t\tif (promise !== input) return;\n\t\t\t\t\t// we technically could use `set` here since it's on the next microtick\n\t\t\t\t\t// but let's use internal_set for consistency and just to be safe\n\t\t\t\t\tinternal_set(input_source, value);\n\t\t\t\t\tupdate(THEN, true);\n\t\t\t\t},\n\t\t\t\t(error) => {\n\t\t\t\t\tif (promise !== input) return;\n\t\t\t\t\t// we technically could use `set` here since it's on the next microtick\n\t\t\t\t\t// but let's use internal_set for consistency and just to be safe\n\t\t\t\t\tinternal_set(error_source, error);\n\t\t\t\t\tupdate(CATCH, true);\n\t\t\t\t\tif (!catch_fn) {\n\t\t\t\t\t\t// Rethrow the error if no catch block exists\n\t\t\t\t\t\tthrow error_source.v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (hydrating) {\n\t\t\t\tif (pending_fn) {\n\t\t\t\t\tpending_effect = branch(() => pending_fn(anchor));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Wait a microtask before checking if we should show the pending state as\n\t\t\t\t// the promise might have resolved by the next microtask.\n\t\t\t\tqueue_micro_task(() => {\n\t\t\t\t\tif (!resolved) update(PENDING, true);\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tinternal_set(input_source, input);\n\t\t\tupdate(THEN, false);\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\n\t\t// Set the input to something else, in order to disable the promise callbacks\n\t\treturn () => (input = UNINITIALIZED);\n\t});\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n"],"names":["PENDING","THEN","CATCH","await_block","node","get_input","pending_fn","then_fn","catch_fn","hydrating","hydrate_next","anchor","runes","is_runes","active_component_context","component_context","component_function","_a","function","input","UNINITIALIZED","pending_effect","then_effect","catch_effect","input_source","source","mutable_source","error_source","resolved","update","state","restore","set_active_effect","effect","set_active_reaction","set_component_context","set_dev_current_component_function","branch","pause_effect","flushSync","block","mismatch","is_promise","data","HYDRATION_START_ELSE","remove_nodes","set_hydrate_node","set_hydrating","promise","then","value","internal_set","error","v","queue_micro_task","hydrate_node"],"mappings":"4fAuBA,MAAMA,QAAU,EAChB,MAAMC,KAAO,EACb,MAAMC,MAAQ,EAWP,SAASC,YAAYC,KAAMC,UAAWC,WAAYC,QAASC,iBACjE,GAAIC,UAAW,CACAC,cAChB,CAEC,IAAIC,OAASP,KACb,IAAIQ,MAAQC,WACZ,IAAIC,yBAA2BC,kBAG/B,IAAIC,oBAA2BC,GAAmBF,oBAAA,UAAA,EAAAE,GAAAC,SAGlD,IAAIC,MAAQC,cAGR,IAAAC,eAGA,IAAAC,YAGA,IAAAC,aAEJ,IAAIC,aAAeZ,MAChBa,YAAyB,GACzBC,oBAAiC,EAAY,MAAO,OACnD,IAAAC,aAAef,MAAQa,YAAO,GAAaC,oBAAe,EAAW,MAAO,OAChF,IAAIE,SAAW,MAMN,SAAAC,OAAOC,MAAOC,SACXH,SAAA,KAEX,GAAIG,QAAS,CACZC,kBAAkBC,QAClBC,oBAAoBD,QACpBE,sBAAsBrB,0BACbsB,mCAAmCpB,mBAC/C,CAEM,IACC,GAAAc,QAAU9B,SAAWM,WAAY,CAChC,GAAAe,6BAA8BA,qBACZA,eAAAgB,OAAO,IAAM/B,WAAWK,QAClD,CAEO,GAAAmB,QAAU7B,MAAQM,QAAS,CAC1B,GAAAe,0BAA2BA,8BACZe,OAAO,IAAM9B,QAAQI,OAAQa,cACpD,CAEO,GAAAM,QAAU5B,OAASM,UAKnB,GAAAsB,QAAU9B,SAAWqB,eAAgB,CAC3BiB,aAAAjB,eAAgB,IAAOA,eAAiB,KACzD,CAEO,GAAAS,QAAU7B,MAAQqB,YAAa,CACrBgB,aAAAhB,YAAa,IAAOA,YAAc,KACnD,CAEO,GAAAQ,QAAU5B,OAASqB,aAAc,CACvBe,aAAAf,aAAc,IAAOA,aAAe,KACrD,CACA,CAAY,QACT,GAAIQ,QAAS,CACHK,mCAAmC,MAC5CD,sBAAsB,MACtBD,oBAAoB,MACpBF,kBAAkB,MAIPO,WACf,CACA,CACA,CAEK,IAAAN,OAASO,MAAM,KACd,GAAArB,SAAWA,MAAQd,aAAc,OAIrC,IAAIoC,SAAWhC,WAAaiC,WAAWvB,UAAYR,OAAOgC,OAASC,sBAEnE,GAAIH,SAAU,CAEb9B,OAASkC,eAETC,iBAAiBnC,QACjBoC,cAAc,OACHN,SAAA,IACd,CAEM,GAAAC,WAAWvB,OAAQ,CACtB,IAAI6B,QAAU7B,MAEHS,SAAA,MAEHoB,QAAAC,KACNC,QACA,GAAIF,UAAY7B,MAAO,OAGvBgC,aAAa3B,aAAc0B,OAC3BrB,OAAO5B,KAAM,OAEbmD,QACA,GAAIJ,UAAY7B,MAAO,OAGvBgC,aAAaxB,aAAcyB,OAC3BvB,OAAO3B,MAAO,MACC,CAEd,MAAMyB,aAAa0B,CACzB,IAIG,GAAI5C,UAAW,CACd,GAAIH,WAAY,CACfe,eAAiBgB,OAAO,IAAM/B,WAAWK,QAC9C,CACA,KAAU,CAGN2C,iBAAiB,KAChB,IAAK1B,SAAiBC,OAAA7B,QAAS,OAEpC,CACA,KAAS,CACNmD,aAAa3B,aAAcL,OAC3BU,OAAO5B,KAAM,MAChB,CAEE,GAAIwC,SAAU,CAEbM,cAAc,KACjB,CAGE,MAAO,IAAO5B,MAAQC,gBAGvB,GAAIX,UAAW,CACLE,OAAA4C,YACX,CACA","x_google_ignoreList":[0]}