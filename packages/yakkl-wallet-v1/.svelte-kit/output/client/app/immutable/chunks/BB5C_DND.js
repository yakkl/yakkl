import{aD as is_runes,N as component_context,V as block,M as hydrating,z as hydrate_next,aR as is_promise,P as HYDRATION_START_ELSE,Y as remove_nodes,y as set_hydrate_node,x as set_hydrating,a0 as UNINITIALIZED,aI as internal_set,af as source,m as mutable_source,L as branch,a8 as queue_micro_task,A as hydrate_node,aS as set_active_effect,aT as set_active_reaction,aU as set_component_context,a1 as set_dev_current_component_function,Z as resume_effect,_ as pause_effect,aV as flushSync}from"./BaS8d5lg.js";const PENDING=0;const THEN=1;const CATCH=2;function await_block(node,get_input,pending_fn,then_fn,catch_fn){var _a;if(hydrating){hydrate_next()}var anchor=node;var runes=is_runes();var active_component_context=component_context;var component_function=(_a=component_context)==null?void 0:_a.function;var input=UNINITIALIZED;var pending_effect;var then_effect;var catch_effect;var input_source=runes?source(void 0):mutable_source(void 0,false,false);var error_source=runes?source(void 0):mutable_source(void 0,false,false);var resolved=false;function update(state,restore){resolved=true;if(restore){set_active_effect(effect);set_active_reaction(effect);set_component_context(active_component_context);set_dev_current_component_function(component_function)}try{if(state===PENDING&&pending_fn){if(pending_effect)resume_effect(pending_effect);else pending_effect=branch(()=>pending_fn(anchor))}if(state===THEN&&then_fn){if(then_effect)resume_effect(then_effect);else then_effect=branch(()=>then_fn(anchor,input_source))}if(state===CATCH&&catch_fn);if(state!==PENDING&&pending_effect){pause_effect(pending_effect,()=>pending_effect=null)}if(state!==THEN&&then_effect){pause_effect(then_effect,()=>then_effect=null)}if(state!==CATCH&&catch_effect){pause_effect(catch_effect,()=>catch_effect=null)}}finally{if(restore){set_dev_current_component_function(null);set_component_context(null);set_active_reaction(null);set_active_effect(null);flushSync()}}}var effect=block(()=>{if(input===(input=get_input()))return;let mismatch=hydrating&&is_promise(input)===(anchor.data===HYDRATION_START_ELSE);if(mismatch){anchor=remove_nodes();set_hydrate_node(anchor);set_hydrating(false);mismatch=true}if(is_promise(input)){var promise=input;resolved=false;promise.then(value=>{if(promise!==input)return;internal_set(input_source,value);update(THEN,true)},error=>{if(promise!==input)return;internal_set(error_source,error);update(CATCH,true);{throw error_source.v}});if(hydrating){if(pending_fn){pending_effect=branch(()=>pending_fn(anchor))}}else{queue_micro_task(()=>{if(!resolved)update(PENDING,true)})}}else{internal_set(input_source,input);update(THEN,false)}if(mismatch){set_hydrating(true)}return()=>input=UNINITIALIZED});if(hydrating){anchor=hydrate_node}}export{await_block as a};
//# sourceMappingURL=BB5C_DND.js.map
