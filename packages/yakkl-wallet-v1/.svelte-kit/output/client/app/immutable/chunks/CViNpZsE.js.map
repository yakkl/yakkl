{"version":3,"file":"CViNpZsE.js","sources":["../../../../../../../../node_modules/.pnpm/svelte@5.34.3/node_modules/svelte/src/internal/client/reactivity/store.js"],"sourcesContent":["/** @import { StoreReferencesContainer } from '#client' */\n/** @import { Store } from '#shared' */\nimport { subscribe_to_store } from '../../../store/utils.js';\nimport { get as get_store } from '../../../store/shared/index.js';\nimport { define_property, noop } from '../../shared/utils.js';\nimport { get } from '../runtime.js';\nimport { teardown } from './effects.js';\nimport { mutable_source, set } from './sources.js';\n\n/**\n * Whether or not the prop currently being read is a store binding, as in\n * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in\n * runes mode, and skip `binding_property_non_reactive` validation\n */\nlet is_store_binding = false;\n\nlet IS_UNMOUNTED = Symbol();\n\n/**\n * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy\n * signal that will be updated when the store is. The store references container is needed to\n * track reassignments to stores and to track the correct component context.\n * @template V\n * @param {Store<V> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n * @returns {V}\n */\nexport function store_get(store, store_name, stores) {\n\tconst entry = (stores[store_name] ??= {\n\t\tstore: null,\n\t\tsource: mutable_source(undefined),\n\t\tunsubscribe: noop\n\t});\n\n\t// if the component that setup this is already unmounted we don't want to register a subscription\n\tif (entry.store !== store && !(IS_UNMOUNTED in stores)) {\n\t\tentry.unsubscribe();\n\t\tentry.store = store ?? null;\n\n\t\tif (store == null) {\n\t\t\tentry.source.v = undefined; // see synchronous callback comment below\n\t\t\tentry.unsubscribe = noop;\n\t\t} else {\n\t\t\tvar is_synchronous_callback = true;\n\n\t\t\tentry.unsubscribe = subscribe_to_store(store, (v) => {\n\t\t\t\tif (is_synchronous_callback) {\n\t\t\t\t\t// If the first updates to the store value (possibly multiple of them) are synchronously\n\t\t\t\t\t// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value\n\t\t\t\t\tentry.source.v = v;\n\t\t\t\t} else {\n\t\t\t\t\tset(entry.source, v);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tis_synchronous_callback = false;\n\t\t}\n\t}\n\n\t// if the component that setup this stores is already unmounted the source will be out of sync\n\t// so we just use the `get` for the stores, less performant but it avoids to create a memory leak\n\t// and it will keep the value consistent\n\tif (store && IS_UNMOUNTED in stores) {\n\t\treturn get_store(store);\n\t}\n\n\treturn get(entry.source);\n}\n\n/**\n * Unsubscribe from a store if it's not the same as the one in the store references container.\n * We need this in addition to `store_get` because someone could unsubscribe from a store but\n * then never subscribe to the new one (if any), causing the subscription to stay open wrongfully.\n * @param {Store<any> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n */\nexport function store_unsub(store, store_name, stores) {\n\t/** @type {StoreReferencesContainer[''] | undefined} */\n\tlet entry = stores[store_name];\n\n\tif (entry && entry.store !== store) {\n\t\t// Don't reset store yet, so that store_get above can resubscribe to new store if necessary\n\t\tentry.unsubscribe();\n\t\tentry.unsubscribe = noop;\n\t}\n\n\treturn store;\n}\n\n/**\n * Sets the new value of a store and returns that value.\n * @template V\n * @param {Store<V>} store\n * @param {V} value\n * @returns {V}\n */\nexport function store_set(store, value) {\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * @param {StoreReferencesContainer} stores\n * @param {string} store_name\n */\nexport function invalidate_store(stores, store_name) {\n\tvar entry = stores[store_name];\n\tif (entry.store !== null) {\n\t\tstore_set(entry.store, entry.source.v);\n\t}\n}\n\n/**\n * Unsubscribes from all auto-subscribed stores on destroy\n * @returns {[StoreReferencesContainer, ()=>void]}\n */\nexport function setup_stores() {\n\t/** @type {StoreReferencesContainer} */\n\tconst stores = {};\n\n\tfunction cleanup() {\n\t\tteardown(() => {\n\t\t\tfor (var store_name in stores) {\n\t\t\t\tconst ref = stores[store_name];\n\t\t\t\tref.unsubscribe();\n\t\t\t}\n\t\t\tdefine_property(stores, IS_UNMOUNTED, {\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: true\n\t\t\t});\n\t\t});\n\t}\n\n\treturn [stores, cleanup];\n}\n\n/**\n * Updates a store with a new value.\n * @param {Store<V>} store  the store to update\n * @param {any} expression  the expression that mutates the store\n * @param {V} new_value  the new store value\n * @template V\n */\nexport function store_mutate(store, expression, new_value) {\n\tstore.set(new_value);\n\treturn expression;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_store(store, store_value, d = 1) {\n\tstore.set(store_value + d);\n\treturn store_value;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_store(store, store_value, d = 1) {\n\tconst value = store_value + d;\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * Called inside prop getters to communicate that the prop is a store binding\n */\nexport function mark_store_binding() {\n\tis_store_binding = true;\n}\n\n/**\n * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.\n * Used to prevent `binding_property_non_reactive` validation false positives and\n * ensure that these props are treated as mutable even in runes mode\n * @template T\n * @param {() => T} fn\n * @returns {[T, boolean]}\n */\nexport function capture_store_binding(fn) {\n\tvar previous_is_store_binding = is_store_binding;\n\n\ttry {\n\t\tis_store_binding = false;\n\t\treturn [fn(), is_store_binding];\n\t} finally {\n\t\tis_store_binding = previous_is_store_binding;\n\t}\n}\n"],"names":["is_store_binding","IS_UNMOUNTED","Symbol","store_get","store","store_name","stores","entry","source","mutable_source","unsubscribe","noop","v","is_synchronous_callback","subscribe_to_store","set","get_store","get","store_set","value","setup_stores","cleanup","teardown","ref","define_property","enumerable","store_mutate","expression","new_value","mark_store_binding","capture_store_binding","fn","previous_is_store_binding"],"mappings":"8KAcA,IAAIA,iBAAmB,MAEvB,IAAIC,aAAeC,SAYZ,SAASC,UAAUC,MAAOC,WAAYC,QAC5C,MAAMC,MAASD,OAAuBD,cAAAC,OAAAD,YAAA,CACrCD,MAAO,KACPI,OAAQC,oBAAwB,GAChCC,YAAaC,OAId,GAAIJ,MAAMH,QAAUA,SAAWH,gBAAgBK,QAAS,CACvDC,MAAMG,cACNH,MAAMH,MAAQA,OAAS,KAEvB,GAAIA,OAAS,KAAM,CAClBG,MAAMC,OAAOI,OAAI,EACjBL,MAAMG,YAAcC,IACvB,KAAS,CACN,IAAIE,wBAA0B,KAE9BN,MAAMG,YAAcI,mBAAmBV,MAAQQ,IAC9C,GAAIC,wBAAyB,CAG5BN,MAAMC,OAAOI,EAAIA,CACtB,KAAW,CACFG,IAAAR,MAAMC,OAAQI,EACvB,IAG6BC,wBAAA,KAC7B,CACA,CAKK,GAAAT,OAASH,gBAAgBK,OAAQ,CACpC,OAAOU,IAAUZ,MACnB,CAEQa,OAAAA,MAAIV,MAAMC,OAClB,CA8BO,SAASU,UAAUd,MAAOe,OAChCf,MAAMW,IAAII,OACH,OAAAA,KACR,CAiBO,SAASC,eAEf,MAAMd,OAAS,CAAE,EAEjB,SAASe,UACRC,SAAS,KACR,IAAA,IAASjB,cAAcC,OAAQ,CACxB,MAAAiB,IAAMjB,OAAOD,YACnBkB,IAAIb,aACR,CACGc,gBAAgBlB,OAAQL,aAAc,CACrCwB,WAAY,MACZN,MAAO,QAGX,CAEQ,MAAA,CAACb,OAAQe,QACjB,CASO,SAASK,aAAatB,MAAOuB,WAAYC,WAC/CxB,MAAMW,IAAIa,WACH,OAAAD,UACR,CA4BO,SAASE,qBACI7B,iBAAA,IACpB,CAUO,SAAS8B,sBAAsBC,IACrC,IAAIC,0BAA4BhC,iBAE5B,IACgBA,iBAAA,MACZ,MAAA,CAAC+B,KAAM/B,iBAChB,CAAW,QACUA,iBAAAgC,yBACrB,CACA","x_google_ignoreList":[0]}