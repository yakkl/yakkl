/*! For license information please see vendors-node_modules_pnpm_alchemy-sdk_3_5_1_bufferutil_4_0_9_utf-8-validate_5_0_10_node_modul-b1e3f2.js.LICENSE.txt */
(self['webpackChunkyakkl_wallet'] = self['webpackChunkyakkl_wallet'] || []).push([
	[
		'vendors-node_modules_pnpm_alchemy-sdk_3_5_1_bufferutil_4_0_9_utf-8-validate_5_0_10_node_modul-b1e3f2'
	],
	{
		'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js':
			(e, t, s) => {
				'use strict';
				s.r(t);
				s.d(t, { WebSocketProvider: () => WebSocketProvider });
				var n = s(
					'../../node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js'
				);
				var o = s(
					'../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/index.js'
				);
				var r = s(
					'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js'
				);
				var i = s(
					'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/ws.js'
				);
				var l = s(
					'../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js'
				);
				var c = s(
					'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/_version.js'
				);
				var u =
					(undefined && undefined.__awaiter) ||
					function (e, t, s, n) {
						function adopt(e) {
							return e instanceof s
								? e
								: new s(function (t) {
										t(e);
									});
						}
						return new (s || (s = Promise))(function (s, o) {
							function fulfilled(e) {
								try {
									step(n.next(e));
								} catch (e) {
									o(e);
								}
							}
							function rejected(e) {
								try {
									step(n['throw'](e));
								} catch (e) {
									o(e);
								}
							}
							function step(e) {
								e.done ? s(e.value) : adopt(e.value).then(fulfilled, rejected);
							}
							step((n = n.apply(e, t || [])).next());
						});
					};
				const d = new l.Logger(c.version);
				let a = 1;
				class WebSocketProvider extends r.JsonRpcProvider {
					constructor(e, t) {
						if (t === 'any') {
							d.throwError(
								"WebSocketProvider does not support 'any' network yet",
								l.Logger.errors.UNSUPPORTED_OPERATION,
								{ operation: 'network:any' }
							);
						}
						if (typeof e === 'string') {
							super(e, t);
						} else {
							super('_websocket', t);
						}
						this._pollingInterval = -1;
						this._wsReady = false;
						if (typeof e === 'string') {
							(0, o.defineReadOnly)(this, '_websocket', new i.WebSocket(this.connection.url));
						} else {
							(0, o.defineReadOnly)(this, '_websocket', e);
						}
						(0, o.defineReadOnly)(this, '_requests', {});
						(0, o.defineReadOnly)(this, '_subs', {});
						(0, o.defineReadOnly)(this, '_subIds', {});
						(0, o.defineReadOnly)(this, '_detectNetwork', super.detectNetwork());
						this.websocket.onopen = () => {
							this._wsReady = true;
							Object.keys(this._requests).forEach((e) => {
								this.websocket.send(this._requests[e].payload);
							});
						};
						this.websocket.onmessage = (e) => {
							const t = e.data;
							const s = JSON.parse(t);
							if (s.id != null) {
								const e = String(s.id);
								const n = this._requests[e];
								delete this._requests[e];
								if (s.result !== undefined) {
									n.callback(null, s.result);
									this.emit('debug', {
										action: 'response',
										request: JSON.parse(n.payload),
										response: s.result,
										provider: this
									});
								} else {
									let e = null;
									if (s.error) {
										e = new Error(s.error.message || 'unknown error');
										(0, o.defineReadOnly)(e, 'code', s.error.code || null);
										(0, o.defineReadOnly)(e, 'response', t);
									} else {
										e = new Error('unknown error');
									}
									n.callback(e, undefined);
									this.emit('debug', {
										action: 'response',
										error: e,
										request: JSON.parse(n.payload),
										provider: this
									});
								}
							} else if (s.method === 'eth_subscription') {
								const e = this._subs[s.params.subscription];
								if (e) {
									e.processFunc(s.params.result);
								}
							} else {
								console.warn('this should not happen');
							}
						};
						const s = setInterval(() => {
							this.emit('poll');
						}, 1e3);
						if (s.unref) {
							s.unref();
						}
					}
					get websocket() {
						return this._websocket;
					}
					detectNetwork() {
						return this._detectNetwork;
					}
					get pollingInterval() {
						return 0;
					}
					resetEventsBlock(e) {
						d.throwError(
							'cannot reset events block on WebSocketProvider',
							l.Logger.errors.UNSUPPORTED_OPERATION,
							{ operation: 'resetEventBlock' }
						);
					}
					set pollingInterval(e) {
						d.throwError(
							'cannot set polling interval on WebSocketProvider',
							l.Logger.errors.UNSUPPORTED_OPERATION,
							{ operation: 'setPollingInterval' }
						);
					}
					poll() {
						return u(this, void 0, void 0, function* () {
							return null;
						});
					}
					set polling(e) {
						if (!e) {
							return;
						}
						d.throwError(
							'cannot set polling on WebSocketProvider',
							l.Logger.errors.UNSUPPORTED_OPERATION,
							{ operation: 'setPolling' }
						);
					}
					send(e, t) {
						const s = a++;
						return new Promise((n, o) => {
							function callback(e, t) {
								if (e) {
									return o(e);
								}
								return n(t);
							}
							const r = JSON.stringify({ method: e, params: t, id: s, jsonrpc: '2.0' });
							this.emit('debug', { action: 'request', request: JSON.parse(r), provider: this });
							this._requests[String(s)] = { callback, payload: r };
							if (this._wsReady) {
								this.websocket.send(r);
							}
						});
					}
					static defaultUrl() {
						return 'ws://localhost:8546';
					}
					_subscribe(e, t, s) {
						return u(this, void 0, void 0, function* () {
							let n = this._subIds[e];
							if (n == null) {
								n = Promise.all(t).then((e) => this.send('eth_subscribe', e));
								this._subIds[e] = n;
							}
							const o = yield n;
							this._subs[o] = { tag: e, processFunc: s };
						});
					}
					_startEvent(e) {
						switch (e.type) {
							case 'block':
								this._subscribe('block', ['newHeads'], (e) => {
									const t = n.BigNumber.from(e.number).toNumber();
									this._emitted.block = t;
									this.emit('block', t);
								});
								break;
							case 'pending':
								this._subscribe('pending', ['newPendingTransactions'], (e) => {
									this.emit('pending', e);
								});
								break;
							case 'filter':
								this._subscribe(e.tag, ['logs', this._getFilter(e.filter)], (t) => {
									if (t.removed == null) {
										t.removed = false;
									}
									this.emit(e.filter, this.formatter.filterLog(t));
								});
								break;
							case 'tx': {
								const emitReceipt = (e) => {
									const t = e.hash;
									this.getTransactionReceipt(t).then((e) => {
										if (!e) {
											return;
										}
										this.emit(t, e);
									});
								};
								emitReceipt(e);
								this._subscribe('tx', ['newHeads'], (e) => {
									this._events.filter((e) => e.type === 'tx').forEach(emitReceipt);
								});
								break;
							}
							case 'debug':
							case 'poll':
							case 'willPoll':
							case 'didPoll':
							case 'error':
								break;
							default:
								console.log('unhandled:', e);
								break;
						}
					}
					_stopEvent(e) {
						let t = e.tag;
						if (e.type === 'tx') {
							if (this._events.filter((e) => e.type === 'tx').length) {
								return;
							}
							t = 'tx';
						} else if (this.listenerCount(e.event)) {
							return;
						}
						const s = this._subIds[t];
						if (!s) {
							return;
						}
						delete this._subIds[t];
						s.then((e) => {
							if (!this._subs[e]) {
								return;
							}
							delete this._subs[e];
							this.send('eth_unsubscribe', [e]);
						});
					}
					destroy() {
						return u(this, void 0, void 0, function* () {
							if (this.websocket.readyState === i.WebSocket.CONNECTING) {
								yield new Promise((e) => {
									this.websocket.onopen = function () {
										e(true);
									};
									this.websocket.onerror = function () {
										e(false);
									};
								});
							}
							this.websocket.close(1e3);
						});
					}
				}
			},
		'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/ws.js':
			(e, t, s) => {
				'use strict';
				s.r(t);
				s.d(t, { WebSocket: () => r });
				var n = s(
					'../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js'
				);
				var o = s(
					'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/_version.js'
				);
				let r = null;
				try {
					r = WebSocket;
					if (r == null) {
						throw new Error('inject please');
					}
				} catch (e) {
					const t = new n.Logger(o.version);
					r = function () {
						t.throwError(
							'WebSockets not supported in this environment',
							n.Logger.errors.UNSUPPORTED_OPERATION,
							{ operation: 'new WebSocket()' }
						);
					};
				}
			},
		'../../node_modules/.pnpm/alchemy-sdk@3.5.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-948c1ea8.js':
			(e, t, s) => {
				'use strict';
				s.r(t);
				s.d(t, { AlchemyWebSocketProvider: () => AlchemyWebSocketProvider });
				var n = s(
					'../../node_modules/.pnpm/alchemy-sdk@3.5.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/alchemy-sdk/dist/esm/index-1789de96.js'
				);
				var o = s(
					'../../node_modules/.pnpm/sturdy-websocket@0.2.1/node_modules/sturdy-websocket/dist/index.js'
				);
				var r = s(
					'../../node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js'
				);
				var i = s(
					'../../node_modules/.pnpm/@ethersproject+networks@5.7.1/node_modules/@ethersproject/networks/lib.esm/index.js'
				);
				var l = s(
					'../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js'
				);
				var c = s(
					'../../node_modules/.pnpm/alchemy-sdk@3.5.1_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/alchemy-sdk/dist/esm/alchemy-provider-8b0c3e20.js'
				);
				var u = s('../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js');
				const d = 120;
				class WebsocketBackfiller {
					constructor(e) {
						this.provider = e;
						this.maxBackfillBlocks = d;
					}
					getNewHeadsBackfill(e, t, s) {
						return (0, n._)(this, void 0, void 0, function* () {
							throwIfCancelled(e);
							const o = yield this.getBlockNumber();
							throwIfCancelled(e);
							if (t.length === 0) {
								return this.getHeadEventsInRange(
									Math.max(s, o - this.maxBackfillBlocks) + 1,
									o + 1
								);
							}
							const r = (0, n.f)(t[t.length - 1].number);
							const i = o - this.maxBackfillBlocks + 1;
							if (r <= i) {
								return this.getHeadEventsInRange(i, o + 1);
							}
							const l = yield this.getReorgHeads(e, t);
							throwIfCancelled(e);
							const c = yield this.getHeadEventsInRange(r + 1, o + 1);
							throwIfCancelled(e);
							return [...l, ...c];
						});
					}
					getLogsBackfill(e, t, s, o) {
						return (0, n._)(this, void 0, void 0, function* () {
							throwIfCancelled(e);
							const r = yield this.getBlockNumber();
							throwIfCancelled(e);
							if (s.length === 0) {
								return this.getLogsInRange(t, Math.max(o, r - this.maxBackfillBlocks) + 1, r + 1);
							}
							const i = (0, n.f)(s[s.length - 1].blockNumber);
							const l = r - this.maxBackfillBlocks + 1;
							if (i < l) {
								return this.getLogsInRange(t, l, r + 1);
							}
							const c = yield this.getCommonAncestor(e, s);
							throwIfCancelled(e);
							const u = s
								.filter((e) => (0, n.f)(e.blockNumber) > c.blockNumber)
								.map((e) => Object.assign(Object.assign({}, e), { removed: true }));
							const d =
								c.blockNumber === Number.NEGATIVE_INFINITY
									? (0, n.f)(s[0].blockNumber)
									: c.blockNumber;
							let a = yield this.getLogsInRange(t, d, r + 1);
							a = a.filter(
								(e) =>
									e &&
									((0, n.f)(e.blockNumber) > c.blockNumber || (0, n.f)(e.logIndex) > c.logIndex)
							);
							throwIfCancelled(e);
							return [...u, ...a];
						});
					}
					setMaxBackfillBlock(e) {
						this.maxBackfillBlocks = e;
					}
					getBlockNumber() {
						return (0, n._)(this, void 0, void 0, function* () {
							const e = yield this.provider.send('eth_blockNumber');
							return (0, n.f)(e);
						});
					}
					getHeadEventsInRange(e, t) {
						return (0, n._)(this, void 0, void 0, function* () {
							if (e >= t) {
								return [];
							}
							const s = [];
							for (let o = e; o < t; o++) {
								s.push({ method: 'eth_getBlockByNumber', params: [(0, n.t)(o), false] });
							}
							const o = yield this.provider.sendBatch(s);
							return o.map(toNewHeadsEvent);
						});
					}
					getReorgHeads(e, t) {
						return (0, n._)(this, void 0, void 0, function* () {
							const s = [];
							for (let o = t.length - 1; o >= 0; o--) {
								const r = t[o];
								const i = yield this.getBlockByNumber((0, n.f)(r.number));
								throwIfCancelled(e);
								if (r.hash === i.hash) {
									break;
								}
								s.push(toNewHeadsEvent(i));
							}
							return s.reverse();
						});
					}
					getBlockByNumber(e) {
						return (0, n._)(this, void 0, void 0, function* () {
							return this.provider.send('eth_getBlockByNumber', [(0, n.t)(e), false]);
						});
					}
					getCommonAncestor(e, t) {
						return (0, n._)(this, void 0, void 0, function* () {
							let s = yield this.getBlockByNumber((0, n.f)(t[t.length - 1].blockNumber));
							throwIfCancelled(e);
							for (let e = t.length - 1; e >= 0; e--) {
								const o = t[e];
								if (o.blockNumber !== s.number) {
									s = yield this.getBlockByNumber((0, n.f)(o.blockNumber));
								}
								if (o.blockHash === s.hash) {
									return { blockNumber: (0, n.f)(o.blockNumber), logIndex: (0, n.f)(o.logIndex) };
								}
							}
							return { blockNumber: Number.NEGATIVE_INFINITY, logIndex: Number.NEGATIVE_INFINITY };
						});
					}
					getLogsInRange(e, t, s) {
						return (0, n._)(this, void 0, void 0, function* () {
							if (t >= s) {
								return [];
							}
							const o = Object.assign(Object.assign({}, e), {
								fromBlock: (0, n.t)(t),
								toBlock: (0, n.t)(s - 1)
							});
							return this.provider.send('eth_getLogs', [o]);
						});
					}
				}
				function toNewHeadsEvent(e) {
					const t = Object.assign({}, e);
					delete t.totalDifficulty;
					delete t.transactions;
					delete t.uncles;
					return t;
				}
				function dedupeNewHeads(e) {
					return dedupe(e, (e) => e.hash);
				}
				function dedupeLogs(e) {
					return dedupe(e, (e) => `${e.blockHash}/${e.logIndex}`);
				}
				function dedupe(e, t) {
					const s = new Set();
					const n = [];
					e.forEach((e) => {
						const o = t(e);
						if (!s.has(o)) {
							s.add(o);
							n.push(e);
						}
					});
					return n;
				}
				const a = new Error('Cancelled');
				function throwIfCancelled(e) {
					if (e()) {
						throw a;
					}
				}
				const h = 3e4;
				const f = 1e4;
				const p = 6e4;
				const b = 5;
				const m = 10;
				class AlchemyWebSocketProvider extends l.WebSocketProvider {
					constructor(e, t) {
						var s;
						const r = c.AlchemyProvider.getApiKey(e.apiKey);
						const i = c.AlchemyProvider.getAlchemyNetwork(e.network);
						const l = c.AlchemyProvider.getAlchemyConnectionInfo(i, r, 'wss');
						const u = `alchemy-sdk-${n.V}`;
						const d = new o['default']((s = e.url) !== null && s !== void 0 ? s : l.url, u, {
							wsConstructor: t !== null && t !== void 0 ? t : getWebsocketConstructor()
						});
						const a = n.E[i];
						super(d, a);
						this._events = [];
						this.virtualSubscriptionsById = new Map();
						this.virtualIdsByPhysicalId = new Map();
						this.handleMessage = (e) => {
							const t = JSON.parse(e.data);
							if (!isSubscriptionEvent(t)) {
								return;
							}
							const s = t.params.subscription;
							const n = this.virtualIdsByPhysicalId.get(s);
							if (!n) {
								return;
							}
							const o = this.virtualSubscriptionsById.get(n);
							if (o.method !== 'eth_subscribe') {
								return;
							}
							switch (o.params[0]) {
								case 'newHeads': {
									const e = o;
									const r = t;
									const { isBackfilling: i, backfillBuffer: l } = e;
									const { result: c } = r.params;
									if (i) {
										addToNewHeadsEventsBuffer(l, c);
									} else if (s !== n) {
										this.emitAndRememberEvent(n, c, getNewHeadsBlockNumber);
									} else {
										this.rememberEvent(n, c, getNewHeadsBlockNumber);
									}
									break;
								}
								case 'logs': {
									const e = o;
									const r = t;
									const { isBackfilling: i, backfillBuffer: l } = e;
									const { result: c } = r.params;
									if (i) {
										addToLogsEventsBuffer(l, c);
									} else if (n !== s) {
										this.emitAndRememberEvent(n, c, getLogsBlockNumber);
									} else {
										this.rememberEvent(n, c, getLogsBlockNumber);
									}
									break;
								}
								default:
									if (s !== n) {
										const { result: e } = t.params;
										this.emitEvent(n, e);
									}
							}
						};
						this.handleReopen = () => {
							this.virtualIdsByPhysicalId.clear();
							const { cancel: e, isCancelled: t } = makeCancelToken();
							this.cancelBackfill = e;
							for (const e of this.virtualSubscriptionsById.values()) {
								void (() =>
									(0, n._)(this, void 0, void 0, function* () {
										try {
											yield this.resubscribeAndBackfill(t, e);
										} catch (s) {
											if (!t()) {
												console.error(
													`Error while backfilling "${e.params[0]}" subscription. Some events may be missing.`,
													s
												);
											}
										}
									}))();
							}
							this.startHeartbeat();
						};
						this.stopHeartbeatAndBackfill = () => {
							if (this.heartbeatIntervalId != null) {
								clearInterval(this.heartbeatIntervalId);
								this.heartbeatIntervalId = undefined;
							}
							this.cancelBackfill();
						};
						this.apiKey = r;
						this.backfiller = new WebsocketBackfiller(this);
						this.addSocketListeners();
						this.startHeartbeat();
						this.cancelBackfill = n.n;
					}
					static getNetwork(e) {
						if (typeof e === 'string' && e in n.C) {
							return n.C[e];
						}
						return (0, i.getNetwork)(e);
					}
					on(e, t) {
						return this._addEventListener(e, t, false);
					}
					once(e, t) {
						return this._addEventListener(e, t, true);
					}
					off(e, t) {
						if ((0, n.i)(e)) {
							return this._off(e, t);
						} else {
							return super.off(e, t);
						}
					}
					removeAllListeners(e) {
						if (e !== undefined && (0, n.i)(e)) {
							return this._removeAllListeners(e);
						} else {
							return super.removeAllListeners(e);
						}
					}
					listenerCount(e) {
						if (e !== undefined && (0, n.i)(e)) {
							return this._listenerCount(e);
						} else {
							return super.listenerCount(e);
						}
					}
					listeners(e) {
						if (e !== undefined && (0, n.i)(e)) {
							return this._listeners(e);
						} else {
							return super.listeners(e);
						}
					}
					_addEventListener(e, t, s) {
						if ((0, n.i)(e)) {
							(0, n.v)(e);
							const o = new n.c((0, n.e)(e), t, s);
							this._events.push(o);
							this._startEvent(o);
							return this;
						} else {
							return super._addEventListener(e, t, s);
						}
					}
					_startEvent(e) {
						const t = [...n.A, 'block', 'filter'];
						if (t.includes(e.type)) {
							this.customStartEvent(e);
						} else {
							super._startEvent(e);
						}
					}
					_subscribe(e, t, s, o) {
						return (0, n._)(this, void 0, void 0, function* () {
							let n = this._subIds[e];
							const r = yield this.getBlockNumber();
							if (n == null) {
								n = Promise.all(t).then((e) => this.send('eth_subscribe', e));
								this._subIds[e] = n;
							}
							const i = yield n;
							const l = yield Promise.all(t);
							this.virtualSubscriptionsById.set(i, {
								event: o,
								method: 'eth_subscribe',
								params: l,
								startingBlockNumber: r,
								virtualId: i,
								physicalId: i,
								sentEvents: [],
								isBackfilling: false,
								backfillBuffer: []
							});
							this.virtualIdsByPhysicalId.set(i, i);
							this._subs[i] = { tag: e, processFunc: s };
						});
					}
					emit(e, ...t) {
						if ((0, n.i)(e)) {
							let s = false;
							const o = [];
							const r = (0, n.e)(e);
							this._events = this._events.filter((e) => {
								if (e.tag !== r) {
									return true;
								}
								setTimeout(() => {
									e.listener.apply(this, t);
								}, 0);
								s = true;
								if (e.once) {
									o.push(e);
									return false;
								}
								return true;
							});
							o.forEach((e) => {
								this._stopEvent(e);
							});
							return s;
						} else {
							return super.emit(e, ...t);
						}
					}
					sendBatch(e) {
						return (0, n._)(this, void 0, void 0, function* () {
							let t = 0;
							const s = e.map(({ method: e, params: s }) => ({
								method: e,
								params: s,
								jsonrpc: '2.0',
								id: `alchemy-sdk:${t++}`
							}));
							return this.sendBatchConcurrently(s);
						});
					}
					destroy() {
						this.removeSocketListeners();
						this.stopHeartbeatAndBackfill();
						return super.destroy();
					}
					isCommunityResource() {
						return this.apiKey === n.D;
					}
					_stopEvent(e) {
						let t = e.tag;
						if (n.A.includes(e.type)) {
							if (this._events.filter((e) => n.A.includes(e.type)).length) {
								return;
							}
						} else if (e.type === 'tx') {
							if (this._events.filter((e) => e.type === 'tx').length) {
								return;
							}
							t = 'tx';
						} else if (this.listenerCount(e.event)) {
							return;
						}
						const s = this._subIds[t];
						if (!s) {
							return;
						}
						delete this._subIds[t];
						void s.then((e) => {
							if (!this._subs[e]) {
								return;
							}
							delete this._subs[e];
							void this.send('eth_unsubscribe', [e]);
						});
					}
					addSocketListeners() {
						this._websocket.addEventListener('message', this.handleMessage);
						this._websocket.addEventListener('reopen', this.handleReopen);
						this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);
					}
					removeSocketListeners() {
						this._websocket.removeEventListener('message', this.handleMessage);
						this._websocket.removeEventListener('reopen', this.handleReopen);
						this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);
					}
					resubscribeAndBackfill(e, t) {
						return (0, n._)(this, void 0, void 0, function* () {
							const {
								virtualId: s,
								method: n,
								params: o,
								sentEvents: r,
								backfillBuffer: i,
								startingBlockNumber: l
							} = t;
							t.isBackfilling = true;
							i.length = 0;
							try {
								const c = yield this.send(n, o);
								throwIfCancelled(e);
								t.physicalId = c;
								this.virtualIdsByPhysicalId.set(c, s);
								switch (o[0]) {
									case 'newHeads': {
										const t = yield withBackoffRetries(
											() => withTimeout(this.backfiller.getNewHeadsBackfill(e, r, l), p),
											b,
											() => !e()
										);
										throwIfCancelled(e);
										const n = dedupeNewHeads([...t, ...i]);
										n.forEach((e) => this.emitNewHeadsEvent(s, e));
										break;
									}
									case 'logs': {
										const t = o[1] || {};
										const n = yield withBackoffRetries(
											() => withTimeout(this.backfiller.getLogsBackfill(e, t, r, l), p),
											b,
											() => !e()
										);
										throwIfCancelled(e);
										const c = dedupeLogs([...n, ...i]);
										c.forEach((e) => this.emitLogsEvent(s, e));
										break;
									}
									default:
										break;
								}
							} finally {
								t.isBackfilling = false;
								i.length = 0;
							}
						});
					}
					emitNewHeadsEvent(e, t) {
						this.emitAndRememberEvent(e, t, getNewHeadsBlockNumber);
					}
					emitLogsEvent(e, t) {
						this.emitAndRememberEvent(e, t, getLogsBlockNumber);
					}
					emitAndRememberEvent(e, t, s) {
						this.rememberEvent(e, t, s);
						this.emitEvent(e, t);
					}
					emitEvent(e, t) {
						const s = this.virtualSubscriptionsById.get(e);
						if (!s) {
							return;
						}
						this.emitGenericEvent(s, t);
					}
					rememberEvent(e, t, s) {
						const n = this.virtualSubscriptionsById.get(e);
						if (!n) {
							return;
						}
						addToPastEventsBuffer(n.sentEvents, Object.assign({}, t), s);
					}
					emitGenericEvent(e, t) {
						const s = this.emitProcessFn(e.event);
						s(t);
					}
					startHeartbeat() {
						if (this.heartbeatIntervalId != null) {
							return;
						}
						this.heartbeatIntervalId = setInterval(
							() =>
								(0, n._)(this, void 0, void 0, function* () {
									try {
										yield withTimeout(this.send('net_version'), f);
									} catch (e) {
										this._websocket.reconnect();
									}
								}),
							h
						);
					}
					sendBatchConcurrently(e) {
						return (0, n._)(this, void 0, void 0, function* () {
							return Promise.all(e.map((e) => this.send(e.method, e.params)));
						});
					}
					customStartEvent(e) {
						if (e.type === n.h) {
							const { fromAddress: t, toAddress: s, hashesOnly: o } = e;
							void this._subscribe(
								e.tag,
								[n.j.PENDING_TRANSACTIONS, { fromAddress: t, toAddress: s, hashesOnly: o }],
								this.emitProcessFn(e),
								e
							);
						} else if (e.type === n.k) {
							const { addresses: t, includeRemoved: s, hashesOnly: o } = e;
							void this._subscribe(
								e.tag,
								[n.j.MINED_TRANSACTIONS, { addresses: t, includeRemoved: s, hashesOnly: o }],
								this.emitProcessFn(e),
								e
							);
						} else if (e.type === 'block') {
							void this._subscribe('block', ['newHeads'], this.emitProcessFn(e), e);
						} else if (e.type === 'filter') {
							void this._subscribe(
								e.tag,
								['logs', this._getFilter(e.filter)],
								this.emitProcessFn(e),
								e
							);
						}
					}
					emitProcessFn(e) {
						switch (e.type) {
							case n.h:
								return (t) =>
									this.emit(
										{
											method: n.j.PENDING_TRANSACTIONS,
											fromAddress: e.fromAddress,
											toAddress: e.toAddress,
											hashesOnly: e.hashesOnly
										},
										t
									);
							case n.k:
								return (t) =>
									this.emit(
										{
											method: n.j.MINED_TRANSACTIONS,
											addresses: e.addresses,
											includeRemoved: e.includeRemoved,
											hashesOnly: e.hashesOnly
										},
										t
									);
							case 'block':
								return (e) => {
									const t = r.BigNumber.from(e.number).toNumber();
									this._emitted.block = t;
									this.emit('block', t);
								};
							case 'filter':
								return (t) => {
									if (t.removed == null) {
										t.removed = false;
									}
									this.emit(e.filter, this.formatter.filterLog(t));
								};
							default:
								throw new Error('Invalid event type to `emitProcessFn()`');
						}
					}
					_off(e, t) {
						if (t == null) {
							return this.removeAllListeners(e);
						}
						const s = [];
						let o = false;
						const r = (0, n.e)(e);
						this._events = this._events.filter((e) => {
							if (e.tag !== r || e.listener != t) {
								return true;
							}
							if (o) {
								return true;
							}
							o = true;
							s.push(e);
							return false;
						});
						s.forEach((e) => {
							this._stopEvent(e);
						});
						return this;
					}
					_removeAllListeners(e) {
						let t = [];
						if (e == null) {
							t = this._events;
							this._events = [];
						} else {
							const s = (0, n.e)(e);
							this._events = this._events.filter((e) => {
								if (e.tag !== s) {
									return true;
								}
								t.push(e);
								return false;
							});
						}
						t.forEach((e) => {
							this._stopEvent(e);
						});
						return this;
					}
					_listenerCount(e) {
						if (!e) {
							return this._events.length;
						}
						const t = (0, n.e)(e);
						return this._events.filter((e) => e.tag === t).length;
					}
					_listeners(e) {
						if (e == null) {
							return this._events.map((e) => e.listener);
						}
						const t = (0, n.e)(e);
						return this._events.filter((e) => e.tag === t).map((e) => e.listener);
					}
				}
				function getWebsocketConstructor() {
					return isNodeEnvironment()
						? s('../../node_modules/.pnpm/websocket@1.0.35/node_modules/websocket/lib/browser.js')
								.w3cwebsocket
						: WebSocket;
				}
				function isNodeEnvironment() {
					return (
						typeof u !== 'undefined' && u != null && u.versions != null && u.versions.node != null
					);
				}
				function makeCancelToken() {
					let e = false;
					return { cancel: () => (e = true), isCancelled: () => e };
				}
				const v = 1e3;
				const k = 2;
				const y = 3e4;
				function withBackoffRetries(e, t, s = () => true) {
					return (0, n._)(this, void 0, void 0, function* () {
						let n = 0;
						let o = 0;
						while (true) {
							try {
								return yield e();
							} catch (e) {
								o++;
								if (o >= t || !s(e)) {
									throw e;
								}
								yield delay(n);
								if (!s(e)) {
									throw e;
								}
								n = n === 0 ? v : Math.min(y, k * n);
							}
						}
					});
				}
				function delay(e) {
					return new Promise((t) => setTimeout(t, e));
				}
				function withTimeout(e, t) {
					return Promise.race([
						e,
						new Promise((e, s) => setTimeout(() => s(new Error('Timeout')), t))
					]);
				}
				function getNewHeadsBlockNumber(e) {
					return (0, n.f)(e.number);
				}
				function getLogsBlockNumber(e) {
					return (0, n.f)(e.blockNumber);
				}
				function isResponse(e) {
					return Array.isArray(e) || (e.jsonrpc === '2.0' && e.id !== undefined);
				}
				function isSubscriptionEvent(e) {
					return !isResponse(e);
				}
				function addToNewHeadsEventsBuffer(e, t) {
					addToPastEventsBuffer(e, t, getNewHeadsBlockNumber);
				}
				function addToLogsEventsBuffer(e, t) {
					addToPastEventsBuffer(e, t, getLogsBlockNumber);
				}
				function addToPastEventsBuffer(e, t, s) {
					const n = s(t);
					const o = e.findIndex((e) => s(e) > n - m);
					if (o === -1) {
						e.length = 0;
					} else {
						e.splice(0, o);
					}
					e.push(t);
				}
			},
		'../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/global.js': (e) => {
			var naiveFallback = function () {
				if (typeof self === 'object' && self) return self;
				if (typeof window === 'object' && window) return window;
				throw new Error('Unable to resolve global `this`');
			};
			e.exports = (function () {
				if (this) return this;
				if (typeof globalThis === 'object' && globalThis) return globalThis;
				try {
					Object.defineProperty(Object.prototype, '__global__', {
						get: function () {
							return this;
						},
						configurable: true
					});
				} catch (e) {
					return naiveFallback();
				}
				try {
					if (!__global__) return naiveFallback();
					return __global__;
				} finally {
					delete Object.prototype.__global__;
				}
			})();
		},
		'../../node_modules/.pnpm/sturdy-websocket@0.2.1/node_modules/sturdy-websocket/dist/index.js': (
			e,
			t
		) => {
			'use strict';
			Object.defineProperty(t, '__esModule', { value: true });
			var s = 'Provided shouldReconnect() returned false. Closing permanently.';
			var n = 'Provided shouldReconnect() resolved to false. Closing permanently.';
			var o = (function () {
				function SturdyWebSocket(e, t, s) {
					if (s === void 0) {
						s = {};
					}
					this.url = e;
					this.onclose = null;
					this.onerror = null;
					this.onmessage = null;
					this.onopen = null;
					this.ondown = null;
					this.onreopen = null;
					this.CONNECTING = SturdyWebSocket.CONNECTING;
					this.OPEN = SturdyWebSocket.OPEN;
					this.CLOSING = SturdyWebSocket.CLOSING;
					this.CLOSED = SturdyWebSocket.CLOSED;
					this.hasBeenOpened = false;
					this.isClosed = false;
					this.messageBuffer = [];
					this.nextRetryTime = 0;
					this.reconnectCount = 0;
					this.lastKnownExtensions = '';
					this.lastKnownProtocol = '';
					this.listeners = {};
					if (t == null || typeof t === 'string' || Array.isArray(t)) {
						this.protocols = t;
					} else {
						s = t;
					}
					this.options = applyDefaultOptions(s);
					if (!this.options.wsConstructor) {
						if (typeof WebSocket !== 'undefined') {
							this.options.wsConstructor = WebSocket;
						} else {
							throw new Error(
								'WebSocket not present in global scope and no ' +
									'wsConstructor option was provided.'
							);
						}
					}
					this.openNewWebSocket();
				}
				Object.defineProperty(SturdyWebSocket.prototype, 'binaryType', {
					get: function () {
						return this.binaryTypeInternal || 'blob';
					},
					set: function (e) {
						this.binaryTypeInternal = e;
						if (this.ws) {
							this.ws.binaryType = e;
						}
					},
					enumerable: true,
					configurable: true
				});
				Object.defineProperty(SturdyWebSocket.prototype, 'bufferedAmount', {
					get: function () {
						var e = this.ws ? this.ws.bufferedAmount : 0;
						var t = false;
						this.messageBuffer.forEach(function (s) {
							var n = getDataByteLength(s);
							if (n != null) {
								e += n;
							} else {
								t = true;
							}
						});
						if (t) {
							this.debugLog(
								'Some buffered data had unknown length. bufferedAmount()' +
									' return value may be below the correct amount.'
							);
						}
						return e;
					},
					enumerable: true,
					configurable: true
				});
				Object.defineProperty(SturdyWebSocket.prototype, 'extensions', {
					get: function () {
						return this.ws ? this.ws.extensions : this.lastKnownExtensions;
					},
					enumerable: true,
					configurable: true
				});
				Object.defineProperty(SturdyWebSocket.prototype, 'protocol', {
					get: function () {
						return this.ws ? this.ws.protocol : this.lastKnownProtocol;
					},
					enumerable: true,
					configurable: true
				});
				Object.defineProperty(SturdyWebSocket.prototype, 'readyState', {
					get: function () {
						return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;
					},
					enumerable: true,
					configurable: true
				});
				SturdyWebSocket.prototype.close = function (e, t) {
					this.disposeSocket(e, t);
					this.shutdown();
					this.debugLog('WebSocket permanently closed by client.');
				};
				SturdyWebSocket.prototype.send = function (e) {
					if (this.isClosed) {
						throw new Error('WebSocket is already in CLOSING or CLOSED state.');
					} else if (this.ws && this.ws.readyState === this.OPEN) {
						this.ws.send(e);
					} else {
						this.messageBuffer.push(e);
					}
				};
				SturdyWebSocket.prototype.reconnect = function () {
					if (this.isClosed) {
						throw new Error('Cannot call reconnect() on socket which is permanently closed.');
					}
					this.disposeSocket(1e3, 'Client requested reconnect.');
					this.handleClose(undefined);
				};
				SturdyWebSocket.prototype.addEventListener = function (e, t) {
					if (!this.listeners[e]) {
						this.listeners[e] = [];
					}
					this.listeners[e].push(t);
				};
				SturdyWebSocket.prototype.dispatchEvent = function (e) {
					return this.dispatchEventOfType(e.type, e);
				};
				SturdyWebSocket.prototype.removeEventListener = function (e, t) {
					if (this.listeners[e]) {
						this.listeners[e] = this.listeners[e].filter(function (e) {
							return e !== t;
						});
					}
				};
				SturdyWebSocket.prototype.openNewWebSocket = function () {
					var e = this;
					if (this.isClosed) {
						return;
					}
					var t = this.options,
						s = t.connectTimeout,
						n = t.wsConstructor;
					this.debugLog('Opening new WebSocket to ' + this.url + '.');
					var o = new n(this.url, this.protocols);
					o.onclose = function (t) {
						return e.handleClose(t);
					};
					o.onerror = function (t) {
						return e.handleError(t);
					};
					o.onmessage = function (t) {
						return e.handleMessage(t);
					};
					o.onopen = function (t) {
						return e.handleOpen(t);
					};
					this.connectTimeoutId = setTimeout(function () {
						e.clearConnectTimeout();
						e.disposeSocket();
						e.handleClose(undefined);
					}, s);
					this.ws = o;
				};
				SturdyWebSocket.prototype.handleOpen = function (e) {
					var t = this;
					if (!this.ws || this.isClosed) {
						return;
					}
					var s = this.options.allClearResetTime;
					this.debugLog('WebSocket opened.');
					if (this.binaryTypeInternal != null) {
						this.ws.binaryType = this.binaryTypeInternal;
					} else {
						this.binaryTypeInternal = this.ws.binaryType;
					}
					this.clearConnectTimeout();
					if (this.hasBeenOpened) {
						this.dispatchEventOfType('reopen', e);
					} else {
						this.dispatchEventOfType('open', e);
						this.hasBeenOpened = true;
					}
					this.messageBuffer.forEach(function (e) {
						return t.send(e);
					});
					this.messageBuffer = [];
					this.allClearTimeoutId = setTimeout(function () {
						t.clearAllClearTimeout();
						t.nextRetryTime = 0;
						t.reconnectCount = 0;
						var e = (s / 1e3) | 0;
						t.debugLog(
							'WebSocket remained open for ' + e + ' seconds. Resetting' + ' retry time and count.'
						);
					}, s);
				};
				SturdyWebSocket.prototype.handleMessage = function (e) {
					if (this.isClosed) {
						return;
					}
					this.dispatchEventOfType('message', e);
				};
				SturdyWebSocket.prototype.handleClose = function (e) {
					var t = this;
					if (this.isClosed) {
						return;
					}
					var o = this.options,
						r = o.maxReconnectAttempts,
						i = o.shouldReconnect;
					this.clearConnectTimeout();
					this.clearAllClearTimeout();
					if (this.ws) {
						this.lastKnownExtensions = this.ws.extensions;
						this.lastKnownProtocol = this.ws.protocol;
						this.disposeSocket();
					}
					this.dispatchEventOfType('down', e);
					if (this.reconnectCount >= r) {
						this.stopReconnecting(e, this.getTooManyFailedReconnectsMessage());
						return;
					}
					var l = !e || i(e);
					if (typeof l === 'boolean') {
						this.handleWillReconnect(l, e, s);
					} else {
						l.then(function (s) {
							if (t.isClosed) {
								return;
							}
							t.handleWillReconnect(s, e, n);
						});
					}
				};
				SturdyWebSocket.prototype.handleError = function (e) {
					this.dispatchEventOfType('error', e);
					this.debugLog('WebSocket encountered an error.');
				};
				SturdyWebSocket.prototype.handleWillReconnect = function (e, t, s) {
					if (e) {
						this.reestablishConnection();
					} else {
						this.stopReconnecting(t, s);
					}
				};
				SturdyWebSocket.prototype.reestablishConnection = function () {
					var e = this;
					var t = this.options,
						s = t.minReconnectDelay,
						n = t.maxReconnectDelay,
						o = t.reconnectBackoffFactor;
					this.reconnectCount++;
					var r = this.nextRetryTime;
					this.nextRetryTime = Math.max(s, Math.min(this.nextRetryTime * o, n));
					setTimeout(function () {
						return e.openNewWebSocket();
					}, r);
					var i = (r / 1e3) | 0;
					this.debugLog('WebSocket was closed. Re-opening in ' + i + ' seconds.');
				};
				SturdyWebSocket.prototype.stopReconnecting = function (e, t) {
					this.debugLog(t);
					this.shutdown();
					if (e) {
						this.dispatchEventOfType('close', e);
					}
				};
				SturdyWebSocket.prototype.shutdown = function () {
					this.isClosed = true;
					this.clearAllTimeouts();
					this.messageBuffer = [];
					this.disposeSocket();
				};
				SturdyWebSocket.prototype.disposeSocket = function (e, t) {
					if (!this.ws) {
						return;
					}
					this.ws.onerror = noop;
					this.ws.onclose = noop;
					this.ws.onmessage = noop;
					this.ws.onopen = noop;
					this.ws.close(e, t);
					this.ws = undefined;
				};
				SturdyWebSocket.prototype.clearAllTimeouts = function () {
					this.clearConnectTimeout();
					this.clearAllClearTimeout();
				};
				SturdyWebSocket.prototype.clearConnectTimeout = function () {
					if (this.connectTimeoutId != null) {
						clearTimeout(this.connectTimeoutId);
						this.connectTimeoutId = undefined;
					}
				};
				SturdyWebSocket.prototype.clearAllClearTimeout = function () {
					if (this.allClearTimeoutId != null) {
						clearTimeout(this.allClearTimeoutId);
						this.allClearTimeoutId = undefined;
					}
				};
				SturdyWebSocket.prototype.dispatchEventOfType = function (e, t) {
					var s = this;
					switch (e) {
						case 'close':
							if (this.onclose) {
								this.onclose(t);
							}
							break;
						case 'error':
							if (this.onerror) {
								this.onerror(t);
							}
							break;
						case 'message':
							if (this.onmessage) {
								this.onmessage(t);
							}
							break;
						case 'open':
							if (this.onopen) {
								this.onopen(t);
							}
							break;
						case 'down':
							if (this.ondown) {
								this.ondown(t);
							}
							break;
						case 'reopen':
							if (this.onreopen) {
								this.onreopen(t);
							}
							break;
					}
					if (e in this.listeners) {
						this.listeners[e].slice().forEach(function (e) {
							return s.callListener(e, t);
						});
					}
					return !t || !t.defaultPrevented;
				};
				SturdyWebSocket.prototype.callListener = function (e, t) {
					if (typeof e === 'function') {
						e.call(this, t);
					} else {
						e.handleEvent.call(this, t);
					}
				};
				SturdyWebSocket.prototype.debugLog = function (e) {
					if (this.options.debug) {
						console.log(e);
					}
				};
				SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {
					var e = this.options.maxReconnectAttempts;
					return (
						'Failed to reconnect after ' +
						e +
						' ' +
						pluralize('attempt', e) +
						'. Closing permanently.'
					);
				};
				SturdyWebSocket.DEFAULT_OPTIONS = {
					allClearResetTime: 5e3,
					connectTimeout: 5e3,
					debug: false,
					minReconnectDelay: 1e3,
					maxReconnectDelay: 3e4,
					maxReconnectAttempts: Number.POSITIVE_INFINITY,
					reconnectBackoffFactor: 1.5,
					shouldReconnect: function () {
						return true;
					},
					wsConstructor: undefined
				};
				SturdyWebSocket.CONNECTING = 0;
				SturdyWebSocket.OPEN = 1;
				SturdyWebSocket.CLOSING = 2;
				SturdyWebSocket.CLOSED = 3;
				return SturdyWebSocket;
			})();
			t['default'] = o;
			function applyDefaultOptions(e) {
				var t = {};
				Object.keys(o.DEFAULT_OPTIONS).forEach(function (s) {
					var n = e[s];
					t[s] = n === undefined ? o.DEFAULT_OPTIONS[s] : n;
				});
				return t;
			}
			function getDataByteLength(e) {
				if (typeof e === 'string') {
					return 2 * e.length;
				} else if (e instanceof ArrayBuffer) {
					return e.byteLength;
				} else if (e instanceof Blob) {
					return e.size;
				} else {
					return undefined;
				}
			}
			function pluralize(e, t) {
				return t === 1 ? e : e + 's';
			}
			function noop() {}
		},
		'../../node_modules/.pnpm/websocket@1.0.35/node_modules/websocket/lib/browser.js': (
			e,
			t,
			s
		) => {
			var n;
			if (typeof globalThis === 'object') {
				n = globalThis;
			} else {
				try {
					n = s('../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/global.js');
				} catch (e) {
				} finally {
					if (!n && typeof window !== 'undefined') {
						n = window;
					}
					if (!n) {
						throw new Error('Could not determine global this');
					}
				}
			}
			var o = n.WebSocket || n.MozWebSocket;
			var r = s('../../node_modules/.pnpm/websocket@1.0.35/node_modules/websocket/lib/version.js');
			function W3CWebSocket(e, t) {
				var s;
				if (t) {
					s = new o(e, t);
				} else {
					s = new o(e);
				}
				return s;
			}
			if (o) {
				['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function (e) {
					Object.defineProperty(W3CWebSocket, e, {
						get: function () {
							return o[e];
						}
					});
				});
			}
			e.exports = { w3cwebsocket: o ? W3CWebSocket : null, version: r };
		},
		'../../node_modules/.pnpm/websocket@1.0.35/node_modules/websocket/lib/version.js': (
			e,
			t,
			s
		) => {
			e.exports = s(
				'../../node_modules/.pnpm/websocket@1.0.35/node_modules/websocket/package.json'
			).version;
		},
		'../../node_modules/.pnpm/websocket@1.0.35/node_modules/websocket/package.json': (e) => {
			'use strict';
			e.exports = JSON.parse(
				'{"name":"websocket","description":"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.","keywords":["websocket","websockets","socket","networking","comet","push","RFC-6455","realtime","server","client"],"author":"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)","contributors":["Iñaki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"],"version":"1.0.35","repository":{"type":"git","url":"https://github.com/theturtle32/WebSocket-Node.git"},"homepage":"https://github.com/theturtle32/WebSocket-Node","engines":{"node":">=4.0.0"},"dependencies":{"bufferutil":"^4.0.1","debug":"^2.2.0","es5-ext":"^0.10.63","typedarray-to-buffer":"^3.1.5","utf-8-validate":"^5.0.2","yaeti":"^0.0.6"},"devDependencies":{"buffer-equal":"^1.0.0","gulp":"^4.0.2","gulp-jshint":"^2.0.4","jshint-stylish":"^2.2.1","jshint":"^2.0.0","tape":"^4.9.1"},"config":{"verbose":false},"scripts":{"test":"tape test/unit/*.js","gulp":"gulp"},"main":"index","directories":{"lib":"./lib"},"browser":"lib/browser.js","license":"Apache-2.0"}'
			);
		}
	}
]);
