/*! For license information please see 54.js.LICENSE.txt */
(self['webpackChunkwallet'] = self['webpackChunkwallet'] || []).push([
	[54],
	{
		4952: (e, t, r) => {
			'use strict';
			r.d(t, { Rj: () => ForkEvent, Kq: () => Provider });
			var i = r(2834);
			var a = r(1519);
			var o = r(3116);
			var c = r(5982);
			const u = 'abstract-provider/5.7.0';
			var l =
				(undefined && undefined.__awaiter) ||
				function (e, t, r, i) {
					function adopt(e) {
						return e instanceof r
							? e
							: new r(function (t) {
									t(e);
								});
					}
					return new (r || (r = Promise))(function (r, a) {
						function fulfilled(e) {
							try {
								step(i.next(e));
							} catch (e) {
								a(e);
							}
						}
						function rejected(e) {
							try {
								step(i['throw'](e));
							} catch (e) {
								a(e);
							}
						}
						function step(e) {
							e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected);
						}
						step((i = i.apply(e, t || [])).next());
					});
				};
			const d = new c.Vy(u);
			class ForkEvent extends o.VY {
				static isForkEvent(e) {
					return !!(e && e._isForkEvent);
				}
			}
			class BlockForkEvent extends ForkEvent {
				constructor(e, t) {
					if (!(0, a.Lo)(e, 32)) {
						d.throwArgumentError('invalid blockHash', 'blockHash', e);
					}
					super({ _isForkEvent: true, _isBlockForkEvent: true, expiry: t || 0, blockHash: e });
				}
			}
			class TransactionForkEvent extends ForkEvent {
				constructor(e, t) {
					if (!(0, a.Lo)(e, 32)) {
						d.throwArgumentError('invalid transaction hash', 'hash', e);
					}
					super({ _isForkEvent: true, _isTransactionForkEvent: true, expiry: t || 0, hash: e });
				}
			}
			class TransactionOrderForkEvent extends ForkEvent {
				constructor(e, t, r) {
					if (!(0, a.Lo)(e, 32)) {
						d.throwArgumentError('invalid transaction hash', 'beforeHash', e);
					}
					if (!(0, a.Lo)(t, 32)) {
						d.throwArgumentError('invalid transaction hash', 'afterHash', t);
					}
					super({
						_isForkEvent: true,
						_isTransactionOrderForkEvent: true,
						expiry: r || 0,
						beforeHash: e,
						afterHash: t
					});
				}
			}
			class Provider {
				constructor() {
					d.checkAbstract(new.target, Provider);
					(0, o.yY)(this, '_isProvider', true);
				}
				getFeeData() {
					return l(this, void 0, void 0, function* () {
						const { block: e, gasPrice: t } = yield (0, o.k_)({
							block: this.getBlock('latest'),
							gasPrice: this.getGasPrice().catch((e) => null)
						});
						let r = null,
							a = null,
							c = null;
						if (e && e.baseFeePerGas) {
							r = e.baseFeePerGas;
							c = i.gH.from('1500000000');
							a = e.baseFeePerGas.mul(2).add(c);
						}
						return { lastBaseFeePerGas: r, maxFeePerGas: a, maxPriorityFeePerGas: c, gasPrice: t };
					});
				}
				addListener(e, t) {
					return this.on(e, t);
				}
				removeListener(e, t) {
					return this.off(e, t);
				}
				static isProvider(e) {
					return !!(e && e._isProvider);
				}
			}
		},
		5068: (e, t, r) => {
			'use strict';
			r.d(t, { l: () => Signer });
			var i = r(3116);
			var a = r(5982);
			const o = 'abstract-signer/5.7.0';
			var c =
				(undefined && undefined.__awaiter) ||
				function (e, t, r, i) {
					function adopt(e) {
						return e instanceof r
							? e
							: new r(function (t) {
									t(e);
								});
					}
					return new (r || (r = Promise))(function (r, a) {
						function fulfilled(e) {
							try {
								step(i.next(e));
							} catch (e) {
								a(e);
							}
						}
						function rejected(e) {
							try {
								step(i['throw'](e));
							} catch (e) {
								a(e);
							}
						}
						function step(e) {
							e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected);
						}
						step((i = i.apply(e, t || [])).next());
					});
				};
			const u = new a.Vy(o);
			const l = [
				'accessList',
				'ccipReadEnabled',
				'chainId',
				'customData',
				'data',
				'from',
				'gasLimit',
				'gasPrice',
				'maxFeePerGas',
				'maxPriorityFeePerGas',
				'nonce',
				'to',
				'type',
				'value'
			];
			const d = [
				a.Vy.errors.INSUFFICIENT_FUNDS,
				a.Vy.errors.NONCE_EXPIRED,
				a.Vy.errors.REPLACEMENT_UNDERPRICED
			];
			class Signer {
				constructor() {
					u.checkAbstract(new.target, Signer);
					(0, i.yY)(this, '_isSigner', true);
				}
				getBalance(e) {
					return c(this, void 0, void 0, function* () {
						this._checkProvider('getBalance');
						return yield this.provider.getBalance(this.getAddress(), e);
					});
				}
				getTransactionCount(e) {
					return c(this, void 0, void 0, function* () {
						this._checkProvider('getTransactionCount');
						return yield this.provider.getTransactionCount(this.getAddress(), e);
					});
				}
				estimateGas(e) {
					return c(this, void 0, void 0, function* () {
						this._checkProvider('estimateGas');
						const t = yield (0, i.k_)(this.checkTransaction(e));
						return yield this.provider.estimateGas(t);
					});
				}
				call(e, t) {
					return c(this, void 0, void 0, function* () {
						this._checkProvider('call');
						const r = yield (0, i.k_)(this.checkTransaction(e));
						return yield this.provider.call(r, t);
					});
				}
				sendTransaction(e) {
					return c(this, void 0, void 0, function* () {
						this._checkProvider('sendTransaction');
						const t = yield this.populateTransaction(e);
						const r = yield this.signTransaction(t);
						return yield this.provider.sendTransaction(r);
					});
				}
				getChainId() {
					return c(this, void 0, void 0, function* () {
						this._checkProvider('getChainId');
						const e = yield this.provider.getNetwork();
						return e.chainId;
					});
				}
				getGasPrice() {
					return c(this, void 0, void 0, function* () {
						this._checkProvider('getGasPrice');
						return yield this.provider.getGasPrice();
					});
				}
				getFeeData() {
					return c(this, void 0, void 0, function* () {
						this._checkProvider('getFeeData');
						return yield this.provider.getFeeData();
					});
				}
				resolveName(e) {
					return c(this, void 0, void 0, function* () {
						this._checkProvider('resolveName');
						return yield this.provider.resolveName(e);
					});
				}
				checkTransaction(e) {
					for (const t in e) {
						if (l.indexOf(t) === -1) {
							u.throwArgumentError('invalid transaction key: ' + t, 'transaction', e);
						}
					}
					const t = (0, i.Ic)(e);
					if (t.from == null) {
						t.from = this.getAddress();
					} else {
						t.from = Promise.all([Promise.resolve(t.from), this.getAddress()]).then((t) => {
							if (t[0].toLowerCase() !== t[1].toLowerCase()) {
								u.throwArgumentError('from address mismatch', 'transaction', e);
							}
							return t[0];
						});
					}
					return t;
				}
				populateTransaction(e) {
					return c(this, void 0, void 0, function* () {
						const t = yield (0, i.k_)(this.checkTransaction(e));
						if (t.to != null) {
							t.to = Promise.resolve(t.to).then((e) =>
								c(this, void 0, void 0, function* () {
									if (e == null) {
										return null;
									}
									const t = yield this.resolveName(e);
									if (t == null) {
										u.throwArgumentError('provided ENS name resolves to null', 'tx.to', e);
									}
									return t;
								})
							);
							t.to.catch((e) => {});
						}
						const r = t.maxFeePerGas != null || t.maxPriorityFeePerGas != null;
						if (t.gasPrice != null && (t.type === 2 || r)) {
							u.throwArgumentError(
								'eip-1559 transaction do not support gasPrice',
								'transaction',
								e
							);
						} else if ((t.type === 0 || t.type === 1) && r) {
							u.throwArgumentError(
								'pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas',
								'transaction',
								e
							);
						}
						if (
							(t.type === 2 || t.type == null) &&
							t.maxFeePerGas != null &&
							t.maxPriorityFeePerGas != null
						) {
							t.type = 2;
						} else if (t.type === 0 || t.type === 1) {
							if (t.gasPrice == null) {
								t.gasPrice = this.getGasPrice();
							}
						} else {
							const e = yield this.getFeeData();
							if (t.type == null) {
								if (e.maxFeePerGas != null && e.maxPriorityFeePerGas != null) {
									t.type = 2;
									if (t.gasPrice != null) {
										const e = t.gasPrice;
										delete t.gasPrice;
										t.maxFeePerGas = e;
										t.maxPriorityFeePerGas = e;
									} else {
										if (t.maxFeePerGas == null) {
											t.maxFeePerGas = e.maxFeePerGas;
										}
										if (t.maxPriorityFeePerGas == null) {
											t.maxPriorityFeePerGas = e.maxPriorityFeePerGas;
										}
									}
								} else if (e.gasPrice != null) {
									if (r) {
										u.throwError(
											'network does not support EIP-1559',
											a.Vy.errors.UNSUPPORTED_OPERATION,
											{ operation: 'populateTransaction' }
										);
									}
									if (t.gasPrice == null) {
										t.gasPrice = e.gasPrice;
									}
									t.type = 0;
								} else {
									u.throwError(
										'failed to get consistent fee data',
										a.Vy.errors.UNSUPPORTED_OPERATION,
										{ operation: 'signer.getFeeData' }
									);
								}
							} else if (t.type === 2) {
								if (t.maxFeePerGas == null) {
									t.maxFeePerGas = e.maxFeePerGas;
								}
								if (t.maxPriorityFeePerGas == null) {
									t.maxPriorityFeePerGas = e.maxPriorityFeePerGas;
								}
							}
						}
						if (t.nonce == null) {
							t.nonce = this.getTransactionCount('pending');
						}
						if (t.gasLimit == null) {
							t.gasLimit = this.estimateGas(t).catch((e) => {
								if (d.indexOf(e.code) >= 0) {
									throw e;
								}
								return u.throwError(
									'cannot estimate gas; transaction may fail or may require manual gas limit',
									a.Vy.errors.UNPREDICTABLE_GAS_LIMIT,
									{ error: e, tx: t }
								);
							});
						}
						if (t.chainId == null) {
							t.chainId = this.getChainId();
						} else {
							t.chainId = Promise.all([Promise.resolve(t.chainId), this.getChainId()]).then((t) => {
								if (t[1] !== 0 && t[0] !== t[1]) {
									u.throwArgumentError('chainId address mismatch', 'transaction', e);
								}
								return t[0];
							});
						}
						return yield (0, i.k_)(t);
					});
				}
				_checkProvider(e) {
					if (!this.provider) {
						u.throwError('missing provider', a.Vy.errors.UNSUPPORTED_OPERATION, {
							operation: e || '_checkProvider'
						});
					}
				}
				static isSigner(e) {
					return !!(e && e._isSigner);
				}
			}
			class VoidSigner extends Signer {
				constructor(e, t) {
					super();
					(0, i.yY)(this, 'address', e);
					(0, i.yY)(this, 'provider', t || null);
				}
				getAddress() {
					return Promise.resolve(this.address);
				}
				_fail(e, t) {
					return Promise.resolve().then(() => {
						u.throwError(e, a.Vy.errors.UNSUPPORTED_OPERATION, { operation: t });
					});
				}
				signMessage(e) {
					return this._fail('VoidSigner cannot sign messages', 'signMessage');
				}
				signTransaction(e) {
					return this._fail('VoidSigner cannot sign transactions', 'signTransaction');
				}
				_signTypedData(e, t, r) {
					return this._fail('VoidSigner cannot sign typed data', 'signTypedData');
				}
				connect(e) {
					return new VoidSigner(this.address, e);
				}
			}
		},
		716: (e, t, r) => {
			'use strict';
			r.d(t, { bv: () => getAddress, RZ: () => getContractAddress });
			var i = r(1519);
			var a = r(2834);
			var o = r(4781);
			var c = r(8804);
			var u = r(5982);
			const l = 'address/5.7.0';
			const d = new u.Vy(l);
			function getChecksumAddress(e) {
				if (!(0, i.Lo)(e, 20)) {
					d.throwArgumentError('invalid address', 'address', e);
				}
				e = e.toLowerCase();
				const t = e.substring(2).split('');
				const r = new Uint8Array(40);
				for (let e = 0; e < 40; e++) {
					r[e] = t[e].charCodeAt(0);
				}
				const a = (0, i.k9)((0, o.S)(r));
				for (let e = 0; e < 40; e += 2) {
					if (a[e >> 1] >> 4 >= 8) {
						t[e] = t[e].toUpperCase();
					}
					if ((a[e >> 1] & 15) >= 8) {
						t[e + 1] = t[e + 1].toUpperCase();
					}
				}
				return '0x' + t.join('');
			}
			const p = 9007199254740991;
			function log10(e) {
				if (Math.log10) {
					return Math.log10(e);
				}
				return Math.log(e) / Math.LN10;
			}
			const m = {};
			for (let e = 0; e < 10; e++) {
				m[String(e)] = String(e);
			}
			for (let e = 0; e < 26; e++) {
				m[String.fromCharCode(65 + e)] = String(10 + e);
			}
			const g = Math.floor(log10(p));
			function ibanChecksum(e) {
				e = e.toUpperCase();
				e = e.substring(4) + e.substring(0, 2) + '00';
				let t = e
					.split('')
					.map((e) => m[e])
					.join('');
				while (t.length >= g) {
					let e = t.substring(0, g);
					t = (parseInt(e, 10) % 97) + t.substring(e.length);
				}
				let r = String(98 - (parseInt(t, 10) % 97));
				while (r.length < 2) {
					r = '0' + r;
				}
				return r;
			}
			function getAddress(e) {
				let t = null;
				if (typeof e !== 'string') {
					d.throwArgumentError('invalid address', 'address', e);
				}
				if (e.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
					if (e.substring(0, 2) !== '0x') {
						e = '0x' + e;
					}
					t = getChecksumAddress(e);
					if (e.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && t !== e) {
						d.throwArgumentError('bad address checksum', 'address', e);
					}
				} else if (e.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
					if (e.substring(2, 4) !== ibanChecksum(e)) {
						d.throwArgumentError('bad icap checksum', 'address', e);
					}
					t = (0, a.Os)(e.substring(4));
					while (t.length < 40) {
						t = '0' + t;
					}
					t = getChecksumAddress('0x' + t);
				} else {
					d.throwArgumentError('invalid address', 'address', e);
				}
				return t;
			}
			function isAddress(e) {
				try {
					getAddress(e);
					return true;
				} catch (e) {}
				return false;
			}
			function getIcapAddress(e) {
				let t = _base16To36(getAddress(e).substring(2)).toUpperCase();
				while (t.length < 30) {
					t = '0' + t;
				}
				return 'XE' + ibanChecksum('XE00' + t) + t;
			}
			function getContractAddress(e) {
				let t = null;
				try {
					t = getAddress(e.from);
				} catch (t) {
					d.throwArgumentError('missing from address', 'transaction', e);
				}
				const r = (0, i.gr)((0, i.k9)(a.gH.from(e.nonce).toHexString()));
				return getAddress((0, i.Ab)((0, o.S)((0, c.l)([t, r])), 12));
			}
			function getCreate2Address(e, t, r) {
				if (hexDataLength(t) !== 32) {
					d.throwArgumentError('salt must be 32 bytes', 'salt', t);
				}
				if (hexDataLength(r) !== 32) {
					d.throwArgumentError('initCodeHash must be 32 bytes', 'initCodeHash', r);
				}
				return getAddress(hexDataSlice(keccak256(concat(['0xff', getAddress(e), t, r])), 12));
			}
		},
		3162: (e, t, r) => {
			'use strict';
			r.d(t, { D: () => decode, l: () => encode });
			var i = r(1519);
			function decode(e) {
				e = atob(e);
				const t = [];
				for (let r = 0; r < e.length; r++) {
					t.push(e.charCodeAt(r));
				}
				return (0, i.k9)(t);
			}
			function encode(e) {
				e = (0, i.k9)(e);
				let t = '';
				for (let r = 0; r < e.length; r++) {
					t += String.fromCharCode(e[r]);
				}
				return btoa(t);
			}
		},
		797: (e, t, r) => {
			'use strict';
			r.d(t, { zn: () => c });
			var i = r(1519);
			var a = r(3116);
			class BaseX {
				constructor(e) {
					(0, a.yY)(this, 'alphabet', e);
					(0, a.yY)(this, 'base', e.length);
					(0, a.yY)(this, '_alphabetMap', {});
					(0, a.yY)(this, '_leader', e.charAt(0));
					for (let t = 0; t < e.length; t++) {
						this._alphabetMap[e.charAt(t)] = t;
					}
				}
				encode(e) {
					let t = (0, i.k9)(e);
					if (t.length === 0) {
						return '';
					}
					let r = [0];
					for (let e = 0; e < t.length; ++e) {
						let i = t[e];
						for (let e = 0; e < r.length; ++e) {
							i += r[e] << 8;
							r[e] = i % this.base;
							i = (i / this.base) | 0;
						}
						while (i > 0) {
							r.push(i % this.base);
							i = (i / this.base) | 0;
						}
					}
					let a = '';
					for (let e = 0; t[e] === 0 && e < t.length - 1; ++e) {
						a += this._leader;
					}
					for (let e = r.length - 1; e >= 0; --e) {
						a += this.alphabet[r[e]];
					}
					return a;
				}
				decode(e) {
					if (typeof e !== 'string') {
						throw new TypeError('Expected String');
					}
					let t = [];
					if (e.length === 0) {
						return new Uint8Array(t);
					}
					t.push(0);
					for (let r = 0; r < e.length; r++) {
						let i = this._alphabetMap[e[r]];
						if (i === undefined) {
							throw new Error('Non-base' + this.base + ' character');
						}
						let a = i;
						for (let e = 0; e < t.length; ++e) {
							a += t[e] * this.base;
							t[e] = a & 255;
							a >>= 8;
						}
						while (a > 0) {
							t.push(a & 255);
							a >>= 8;
						}
					}
					for (let r = 0; e[r] === this._leader && r < e.length - 1; ++r) {
						t.push(0);
					}
					return (0, i.k9)(new Uint8Array(t.reverse()));
				}
			}
			const o = new BaseX('abcdefghijklmnopqrstuvwxyz234567');
			const c = new BaseX('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
		},
		5902: (e, t, r) => {
			'use strict';
			r.d(t, { r: () => i });
			const i = 'bignumber/5.7.0';
		},
		2834: (e, t, r) => {
			'use strict';
			r.d(t, { Os: () => _base36To16, YR: () => isBigNumberish, gH: () => BigNumber });
			var i = r(3900);
			var a = r.n(i);
			var o = r(1519);
			var c = r(5982);
			var u = r(5902);
			var l = a().BN;
			const d = new c.Vy(u.r);
			const p = {};
			const m = 9007199254740991;
			function isBigNumberish(e) {
				return (
					e != null &&
					(BigNumber.isBigNumber(e) ||
						(typeof e === 'number' && e % 1 === 0) ||
						(typeof e === 'string' && !!e.match(/^-?[0-9]+$/)) ||
						(0, o.Lo)(e) ||
						typeof e === 'bigint' ||
						(0, o.aY)(e))
				);
			}
			let g = false;
			class BigNumber {
				constructor(e, t) {
					if (e !== p) {
						d.throwError(
							'cannot call constructor directly; use BigNumber.from',
							c.Vy.errors.UNSUPPORTED_OPERATION,
							{ operation: 'new (BigNumber)' }
						);
					}
					this._hex = t;
					this._isBigNumber = true;
					Object.freeze(this);
				}
				fromTwos(e) {
					return toBigNumber(toBN(this).fromTwos(e));
				}
				toTwos(e) {
					return toBigNumber(toBN(this).toTwos(e));
				}
				abs() {
					if (this._hex[0] === '-') {
						return BigNumber.from(this._hex.substring(1));
					}
					return this;
				}
				add(e) {
					return toBigNumber(toBN(this).add(toBN(e)));
				}
				sub(e) {
					return toBigNumber(toBN(this).sub(toBN(e)));
				}
				div(e) {
					const t = BigNumber.from(e);
					if (t.isZero()) {
						throwFault('division-by-zero', 'div');
					}
					return toBigNumber(toBN(this).div(toBN(e)));
				}
				mul(e) {
					return toBigNumber(toBN(this).mul(toBN(e)));
				}
				mod(e) {
					const t = toBN(e);
					if (t.isNeg()) {
						throwFault('division-by-zero', 'mod');
					}
					return toBigNumber(toBN(this).umod(t));
				}
				pow(e) {
					const t = toBN(e);
					if (t.isNeg()) {
						throwFault('negative-power', 'pow');
					}
					return toBigNumber(toBN(this).pow(t));
				}
				and(e) {
					const t = toBN(e);
					if (this.isNegative() || t.isNeg()) {
						throwFault('unbound-bitwise-result', 'and');
					}
					return toBigNumber(toBN(this).and(t));
				}
				or(e) {
					const t = toBN(e);
					if (this.isNegative() || t.isNeg()) {
						throwFault('unbound-bitwise-result', 'or');
					}
					return toBigNumber(toBN(this).or(t));
				}
				xor(e) {
					const t = toBN(e);
					if (this.isNegative() || t.isNeg()) {
						throwFault('unbound-bitwise-result', 'xor');
					}
					return toBigNumber(toBN(this).xor(t));
				}
				mask(e) {
					if (this.isNegative() || e < 0) {
						throwFault('negative-width', 'mask');
					}
					return toBigNumber(toBN(this).maskn(e));
				}
				shl(e) {
					if (this.isNegative() || e < 0) {
						throwFault('negative-width', 'shl');
					}
					return toBigNumber(toBN(this).shln(e));
				}
				shr(e) {
					if (this.isNegative() || e < 0) {
						throwFault('negative-width', 'shr');
					}
					return toBigNumber(toBN(this).shrn(e));
				}
				eq(e) {
					return toBN(this).eq(toBN(e));
				}
				lt(e) {
					return toBN(this).lt(toBN(e));
				}
				lte(e) {
					return toBN(this).lte(toBN(e));
				}
				gt(e) {
					return toBN(this).gt(toBN(e));
				}
				gte(e) {
					return toBN(this).gte(toBN(e));
				}
				isNegative() {
					return this._hex[0] === '-';
				}
				isZero() {
					return toBN(this).isZero();
				}
				toNumber() {
					try {
						return toBN(this).toNumber();
					} catch (e) {
						throwFault('overflow', 'toNumber', this.toString());
					}
					return null;
				}
				toBigInt() {
					try {
						return BigInt(this.toString());
					} catch (e) {}
					return d.throwError(
						'this platform does not support BigInt',
						c.Vy.errors.UNSUPPORTED_OPERATION,
						{ value: this.toString() }
					);
				}
				toString() {
					if (arguments.length > 0) {
						if (arguments[0] === 10) {
							if (!g) {
								g = true;
								d.warn('BigNumber.toString does not accept any parameters; base-10 is assumed');
							}
						} else if (arguments[0] === 16) {
							d.throwError(
								'BigNumber.toString does not accept any parameters; use bigNumber.toHexString()',
								c.Vy.errors.UNEXPECTED_ARGUMENT,
								{}
							);
						} else {
							d.throwError(
								'BigNumber.toString does not accept parameters',
								c.Vy.errors.UNEXPECTED_ARGUMENT,
								{}
							);
						}
					}
					return toBN(this).toString(10);
				}
				toHexString() {
					return this._hex;
				}
				toJSON(e) {
					return { type: 'BigNumber', hex: this.toHexString() };
				}
				static from(e) {
					if (e instanceof BigNumber) {
						return e;
					}
					if (typeof e === 'string') {
						if (e.match(/^-?0x[0-9a-f]+$/i)) {
							return new BigNumber(p, toHex(e));
						}
						if (e.match(/^-?[0-9]+$/)) {
							return new BigNumber(p, toHex(new l(e)));
						}
						return d.throwArgumentError('invalid BigNumber string', 'value', e);
					}
					if (typeof e === 'number') {
						if (e % 1) {
							throwFault('underflow', 'BigNumber.from', e);
						}
						if (e >= m || e <= -m) {
							throwFault('overflow', 'BigNumber.from', e);
						}
						return BigNumber.from(String(e));
					}
					const t = e;
					if (typeof t === 'bigint') {
						return BigNumber.from(t.toString());
					}
					if ((0, o.aY)(t)) {
						return BigNumber.from((0, o.c$)(t));
					}
					if (t) {
						if (t.toHexString) {
							const e = t.toHexString();
							if (typeof e === 'string') {
								return BigNumber.from(e);
							}
						} else {
							let e = t._hex;
							if (e == null && t.type === 'BigNumber') {
								e = t.hex;
							}
							if (typeof e === 'string') {
								if ((0, o.Lo)(e) || (e[0] === '-' && (0, o.Lo)(e.substring(1)))) {
									return BigNumber.from(e);
								}
							}
						}
					}
					return d.throwArgumentError('invalid BigNumber value', 'value', e);
				}
				static isBigNumber(e) {
					return !!(e && e._isBigNumber);
				}
			}
			function toHex(e) {
				if (typeof e !== 'string') {
					return toHex(e.toString(16));
				}
				if (e[0] === '-') {
					e = e.substring(1);
					if (e[0] === '-') {
						d.throwArgumentError('invalid hex', 'value', e);
					}
					e = toHex(e);
					if (e === '0x00') {
						return e;
					}
					return '-' + e;
				}
				if (e.substring(0, 2) !== '0x') {
					e = '0x' + e;
				}
				if (e === '0x') {
					return '0x00';
				}
				if (e.length % 2) {
					e = '0x0' + e.substring(2);
				}
				while (e.length > 4 && e.substring(0, 4) === '0x00') {
					e = '0x' + e.substring(4);
				}
				return e;
			}
			function toBigNumber(e) {
				return BigNumber.from(toHex(e));
			}
			function toBN(e) {
				const t = BigNumber.from(e).toHexString();
				if (t[0] === '-') {
					return new l('-' + t.substring(3), 16);
				}
				return new l(t.substring(2), 16);
			}
			function throwFault(e, t, r) {
				const i = { fault: e, operation: t };
				if (r != null) {
					i.value = r;
				}
				return d.throwError(e, c.Vy.errors.NUMERIC_FAULT, i);
			}
			function _base36To16(e) {
				return new l(e, 36).toString(16);
			}
			function _base16To36(e) {
				return new l(e, 16).toString(36);
			}
		},
		1519: (e, t, r) => {
			'use strict';
			r.d(t, {
				k9: () => arrayify,
				xW: () => concat,
				qn: () => hexConcat,
				cm: () => hexDataLength,
				Ab: () => hexDataSlice,
				hP: () => hexStripZeros,
				Fh: () => hexValue,
				bj: () => hexZeroPad,
				c$: () => hexlify,
				aY: () => isBytes,
				f: () => isBytesLike,
				Lo: () => isHexString,
				FU: () => joinSignature,
				Pc: () => splitSignature,
				gr: () => stripZeros
			});
			var i = r(5982);
			const a = 'bytes/5.7.0';
			const o = new i.Vy(a);
			function isHexable(e) {
				return !!e.toHexString;
			}
			function addSlice(e) {
				if (e.slice) {
					return e;
				}
				e.slice = function () {
					const t = Array.prototype.slice.call(arguments);
					return addSlice(new Uint8Array(Array.prototype.slice.apply(e, t)));
				};
				return e;
			}
			function isBytesLike(e) {
				return (isHexString(e) && !(e.length % 2)) || isBytes(e);
			}
			function isInteger(e) {
				return typeof e === 'number' && e == e && e % 1 === 0;
			}
			function isBytes(e) {
				if (e == null) {
					return false;
				}
				if (e.constructor === Uint8Array) {
					return true;
				}
				if (typeof e === 'string') {
					return false;
				}
				if (!isInteger(e.length) || e.length < 0) {
					return false;
				}
				for (let t = 0; t < e.length; t++) {
					const r = e[t];
					if (!isInteger(r) || r < 0 || r >= 256) {
						return false;
					}
				}
				return true;
			}
			function arrayify(e, t) {
				if (!t) {
					t = {};
				}
				if (typeof e === 'number') {
					o.checkSafeUint53(e, 'invalid arrayify value');
					const t = [];
					while (e) {
						t.unshift(e & 255);
						e = parseInt(String(e / 256));
					}
					if (t.length === 0) {
						t.push(0);
					}
					return addSlice(new Uint8Array(t));
				}
				if (t.allowMissingPrefix && typeof e === 'string' && e.substring(0, 2) !== '0x') {
					e = '0x' + e;
				}
				if (isHexable(e)) {
					e = e.toHexString();
				}
				if (isHexString(e)) {
					let r = e.substring(2);
					if (r.length % 2) {
						if (t.hexPad === 'left') {
							r = '0' + r;
						} else if (t.hexPad === 'right') {
							r += '0';
						} else {
							o.throwArgumentError('hex data is odd-length', 'value', e);
						}
					}
					const i = [];
					for (let e = 0; e < r.length; e += 2) {
						i.push(parseInt(r.substring(e, e + 2), 16));
					}
					return addSlice(new Uint8Array(i));
				}
				if (isBytes(e)) {
					return addSlice(new Uint8Array(e));
				}
				return o.throwArgumentError('invalid arrayify value', 'value', e);
			}
			function concat(e) {
				const t = e.map((e) => arrayify(e));
				const r = t.reduce((e, t) => e + t.length, 0);
				const i = new Uint8Array(r);
				t.reduce((e, t) => {
					i.set(t, e);
					return e + t.length;
				}, 0);
				return addSlice(i);
			}
			function stripZeros(e) {
				let t = arrayify(e);
				if (t.length === 0) {
					return t;
				}
				let r = 0;
				while (r < t.length && t[r] === 0) {
					r++;
				}
				if (r) {
					t = t.slice(r);
				}
				return t;
			}
			function zeroPad(e, t) {
				e = arrayify(e);
				if (e.length > t) {
					o.throwArgumentError('value out of range', 'value', arguments[0]);
				}
				const r = new Uint8Array(t);
				r.set(e, t - e.length);
				return addSlice(r);
			}
			function isHexString(e, t) {
				if (typeof e !== 'string' || !e.match(/^0x[0-9A-Fa-f]*$/)) {
					return false;
				}
				if (t && e.length !== 2 + 2 * t) {
					return false;
				}
				return true;
			}
			const c = '0123456789abcdef';
			function hexlify(e, t) {
				if (!t) {
					t = {};
				}
				if (typeof e === 'number') {
					o.checkSafeUint53(e, 'invalid hexlify value');
					let t = '';
					while (e) {
						t = c[e & 15] + t;
						e = Math.floor(e / 16);
					}
					if (t.length) {
						if (t.length % 2) {
							t = '0' + t;
						}
						return '0x' + t;
					}
					return '0x00';
				}
				if (typeof e === 'bigint') {
					e = e.toString(16);
					if (e.length % 2) {
						return '0x0' + e;
					}
					return '0x' + e;
				}
				if (t.allowMissingPrefix && typeof e === 'string' && e.substring(0, 2) !== '0x') {
					e = '0x' + e;
				}
				if (isHexable(e)) {
					return e.toHexString();
				}
				if (isHexString(e)) {
					if (e.length % 2) {
						if (t.hexPad === 'left') {
							e = '0x0' + e.substring(2);
						} else if (t.hexPad === 'right') {
							e += '0';
						} else {
							o.throwArgumentError('hex data is odd-length', 'value', e);
						}
					}
					return e.toLowerCase();
				}
				if (isBytes(e)) {
					let t = '0x';
					for (let r = 0; r < e.length; r++) {
						let i = e[r];
						t += c[(i & 240) >> 4] + c[i & 15];
					}
					return t;
				}
				return o.throwArgumentError('invalid hexlify value', 'value', e);
			}
			function hexDataLength(e) {
				if (typeof e !== 'string') {
					e = hexlify(e);
				} else if (!isHexString(e) || e.length % 2) {
					return null;
				}
				return (e.length - 2) / 2;
			}
			function hexDataSlice(e, t, r) {
				if (typeof e !== 'string') {
					e = hexlify(e);
				} else if (!isHexString(e) || e.length % 2) {
					o.throwArgumentError('invalid hexData', 'value', e);
				}
				t = 2 + 2 * t;
				if (r != null) {
					return '0x' + e.substring(t, 2 + 2 * r);
				}
				return '0x' + e.substring(t);
			}
			function hexConcat(e) {
				let t = '0x';
				e.forEach((e) => {
					t += hexlify(e).substring(2);
				});
				return t;
			}
			function hexValue(e) {
				const t = hexStripZeros(hexlify(e, { hexPad: 'left' }));
				if (t === '0x') {
					return '0x0';
				}
				return t;
			}
			function hexStripZeros(e) {
				if (typeof e !== 'string') {
					e = hexlify(e);
				}
				if (!isHexString(e)) {
					o.throwArgumentError('invalid hex string', 'value', e);
				}
				e = e.substring(2);
				let t = 0;
				while (t < e.length && e[t] === '0') {
					t++;
				}
				return '0x' + e.substring(t);
			}
			function hexZeroPad(e, t) {
				if (typeof e !== 'string') {
					e = hexlify(e);
				} else if (!isHexString(e)) {
					o.throwArgumentError('invalid hex string', 'value', e);
				}
				if (e.length > 2 * t + 2) {
					o.throwArgumentError('value out of range', 'value', arguments[1]);
				}
				while (e.length < 2 * t + 2) {
					e = '0x0' + e.substring(2);
				}
				return e;
			}
			function splitSignature(e) {
				const t = {
					r: '0x',
					s: '0x',
					_vs: '0x',
					recoveryParam: 0,
					v: 0,
					yParityAndS: '0x',
					compact: '0x'
				};
				if (isBytesLike(e)) {
					let r = arrayify(e);
					if (r.length === 64) {
						t.v = 27 + (r[32] >> 7);
						r[32] &= 127;
						t.r = hexlify(r.slice(0, 32));
						t.s = hexlify(r.slice(32, 64));
					} else if (r.length === 65) {
						t.r = hexlify(r.slice(0, 32));
						t.s = hexlify(r.slice(32, 64));
						t.v = r[64];
					} else {
						o.throwArgumentError('invalid signature string', 'signature', e);
					}
					if (t.v < 27) {
						if (t.v === 0 || t.v === 1) {
							t.v += 27;
						} else {
							o.throwArgumentError('signature invalid v byte', 'signature', e);
						}
					}
					t.recoveryParam = 1 - (t.v % 2);
					if (t.recoveryParam) {
						r[32] |= 128;
					}
					t._vs = hexlify(r.slice(32, 64));
				} else {
					t.r = e.r;
					t.s = e.s;
					t.v = e.v;
					t.recoveryParam = e.recoveryParam;
					t._vs = e._vs;
					if (t._vs != null) {
						const r = zeroPad(arrayify(t._vs), 32);
						t._vs = hexlify(r);
						const i = r[0] >= 128 ? 1 : 0;
						if (t.recoveryParam == null) {
							t.recoveryParam = i;
						} else if (t.recoveryParam !== i) {
							o.throwArgumentError('signature recoveryParam mismatch _vs', 'signature', e);
						}
						r[0] &= 127;
						const a = hexlify(r);
						if (t.s == null) {
							t.s = a;
						} else if (t.s !== a) {
							o.throwArgumentError('signature v mismatch _vs', 'signature', e);
						}
					}
					if (t.recoveryParam == null) {
						if (t.v == null) {
							o.throwArgumentError('signature missing v and recoveryParam', 'signature', e);
						} else if (t.v === 0 || t.v === 1) {
							t.recoveryParam = t.v;
						} else {
							t.recoveryParam = 1 - (t.v % 2);
						}
					} else {
						if (t.v == null) {
							t.v = 27 + t.recoveryParam;
						} else {
							const r = t.v === 0 || t.v === 1 ? t.v : 1 - (t.v % 2);
							if (t.recoveryParam !== r) {
								o.throwArgumentError('signature recoveryParam mismatch v', 'signature', e);
							}
						}
					}
					if (t.r == null || !isHexString(t.r)) {
						o.throwArgumentError('signature missing or invalid r', 'signature', e);
					} else {
						t.r = hexZeroPad(t.r, 32);
					}
					if (t.s == null || !isHexString(t.s)) {
						o.throwArgumentError('signature missing or invalid s', 'signature', e);
					} else {
						t.s = hexZeroPad(t.s, 32);
					}
					const r = arrayify(t.s);
					if (r[0] >= 128) {
						o.throwArgumentError('signature s out of range', 'signature', e);
					}
					if (t.recoveryParam) {
						r[0] |= 128;
					}
					const i = hexlify(r);
					if (t._vs) {
						if (!isHexString(t._vs)) {
							o.throwArgumentError('signature invalid _vs', 'signature', e);
						}
						t._vs = hexZeroPad(t._vs, 32);
					}
					if (t._vs == null) {
						t._vs = i;
					} else if (t._vs !== i) {
						o.throwArgumentError('signature _vs mismatch v and s', 'signature', e);
					}
				}
				t.yParityAndS = t._vs;
				t.compact = t.r + t.yParityAndS.substring(2);
				return t;
			}
			function joinSignature(e) {
				e = splitSignature(e);
				return hexlify(concat([e.r, e.s, e.recoveryParam ? '0x1c' : '0x1b']));
			}
		},
		3404: (e, t, r) => {
			'use strict';
			r.d(t, { r: () => i });
			const i = 'hash/5.7.0';
		},
		3518: (e, t, r) => {
			'use strict';
			r.d(t, { id: () => id });
			var i = r(4781);
			var a = r(5250);
			function id(e) {
				return (0, i.S)((0, a.YW)(e));
			}
		},
		1424: (e, t, r) => {
			'use strict';
			r.d(t, { z: () => TypedDataEncoder });
			var i = r(716);
			var a = r(2834);
			var o = r(1519);
			var c = r(4781);
			var u = r(3116);
			var l = r(5982);
			var d = r(3404);
			var p = r(3518);
			var m =
				(undefined && undefined.__awaiter) ||
				function (e, t, r, i) {
					function adopt(e) {
						return e instanceof r
							? e
							: new r(function (t) {
									t(e);
								});
					}
					return new (r || (r = Promise))(function (r, a) {
						function fulfilled(e) {
							try {
								step(i.next(e));
							} catch (e) {
								a(e);
							}
						}
						function rejected(e) {
							try {
								step(i['throw'](e));
							} catch (e) {
								a(e);
							}
						}
						function step(e) {
							e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected);
						}
						step((i = i.apply(e, t || [])).next());
					});
				};
			const g = new l.Vy(d.r);
			const v = new Uint8Array(32);
			v.fill(0);
			const y = a.gH.from(-1);
			const w = a.gH.from(0);
			const _ = a.gH.from(1);
			const A = a.gH.from('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
			function hexPadRight(e) {
				const t = (0, o.k9)(e);
				const r = t.length % 32;
				if (r) {
					return (0, o.qn)([t, v.slice(r)]);
				}
				return (0, o.c$)(t);
			}
			const k = (0, o.bj)(_.toHexString(), 32);
			const N = (0, o.bj)(w.toHexString(), 32);
			const T = {
				name: 'string',
				version: 'string',
				chainId: 'uint256',
				verifyingContract: 'address',
				salt: 'bytes32'
			};
			const x = ['name', 'version', 'chainId', 'verifyingContract', 'salt'];
			function checkString(e) {
				return function (t) {
					if (typeof t !== 'string') {
						g.throwArgumentError(`invalid domain value for ${JSON.stringify(e)}`, `domain.${e}`, t);
					}
					return t;
				};
			}
			const B = {
				name: checkString('name'),
				version: checkString('version'),
				chainId: function (e) {
					try {
						return a.gH.from(e).toString();
					} catch (e) {}
					return g.throwArgumentError(`invalid domain value for "chainId"`, 'domain.chainId', e);
				},
				verifyingContract: function (e) {
					try {
						return (0, i.bv)(e).toLowerCase();
					} catch (e) {}
					return g.throwArgumentError(
						`invalid domain value "verifyingContract"`,
						'domain.verifyingContract',
						e
					);
				},
				salt: function (e) {
					try {
						const t = (0, o.k9)(e);
						if (t.length !== 32) {
							throw new Error('bad length');
						}
						return (0, o.c$)(t);
					} catch (e) {}
					return g.throwArgumentError(`invalid domain value "salt"`, 'domain.salt', e);
				}
			};
			function getBaseEncoder(e) {
				{
					const t = e.match(/^(u?)int(\d*)$/);
					if (t) {
						const r = t[1] === '';
						const i = parseInt(t[2] || '256');
						if (i % 8 !== 0 || i > 256 || (t[2] && t[2] !== String(i))) {
							g.throwArgumentError('invalid numeric width', 'type', e);
						}
						const c = A.mask(r ? i - 1 : i);
						const u = r ? c.add(_).mul(y) : w;
						return function (t) {
							const r = a.gH.from(t);
							if (r.lt(u) || r.gt(c)) {
								g.throwArgumentError(`value out-of-bounds for ${e}`, 'value', t);
							}
							return (0, o.bj)(r.toTwos(256).toHexString(), 32);
						};
					}
				}
				{
					const t = e.match(/^bytes(\d+)$/);
					if (t) {
						const r = parseInt(t[1]);
						if (r === 0 || r > 32 || t[1] !== String(r)) {
							g.throwArgumentError('invalid bytes width', 'type', e);
						}
						return function (t) {
							const i = (0, o.k9)(t);
							if (i.length !== r) {
								g.throwArgumentError(`invalid length for ${e}`, 'value', t);
							}
							return hexPadRight(t);
						};
					}
				}
				switch (e) {
					case 'address':
						return function (e) {
							return (0, o.bj)((0, i.bv)(e), 32);
						};
					case 'bool':
						return function (e) {
							return !e ? N : k;
						};
					case 'bytes':
						return function (e) {
							return (0, c.S)(e);
						};
					case 'string':
						return function (e) {
							return (0, p.id)(e);
						};
				}
				return null;
			}
			function encodeType(e, t) {
				return `${e}(${t.map(({ name: e, type: t }) => t + ' ' + e).join(',')})`;
			}
			class TypedDataEncoder {
				constructor(e) {
					(0, u.yY)(this, 'types', Object.freeze((0, u.A4)(e)));
					(0, u.yY)(this, '_encoderCache', {});
					(0, u.yY)(this, '_types', {});
					const t = {};
					const r = {};
					const i = {};
					Object.keys(e).forEach((e) => {
						t[e] = {};
						r[e] = [];
						i[e] = {};
					});
					for (const i in e) {
						const a = {};
						e[i].forEach((o) => {
							if (a[o.name]) {
								g.throwArgumentError(
									`duplicate variable name ${JSON.stringify(o.name)} in ${JSON.stringify(i)}`,
									'types',
									e
								);
							}
							a[o.name] = true;
							const c = o.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
							if (c === i) {
								g.throwArgumentError(`circular type reference to ${JSON.stringify(c)}`, 'types', e);
							}
							const u = getBaseEncoder(c);
							if (u) {
								return;
							}
							if (!r[c]) {
								g.throwArgumentError(`unknown type ${JSON.stringify(c)}`, 'types', e);
							}
							r[c].push(i);
							t[i][c] = true;
						});
					}
					const a = Object.keys(r).filter((e) => r[e].length === 0);
					if (a.length === 0) {
						g.throwArgumentError('missing primary type', 'types', e);
					} else if (a.length > 1) {
						g.throwArgumentError(
							`ambiguous primary types or unused types: ${a.map((e) => JSON.stringify(e)).join(', ')}`,
							'types',
							e
						);
					}
					(0, u.yY)(this, 'primaryType', a[0]);
					function checkCircular(a, o) {
						if (o[a]) {
							g.throwArgumentError(`circular type reference to ${JSON.stringify(a)}`, 'types', e);
						}
						o[a] = true;
						Object.keys(t[a]).forEach((e) => {
							if (!r[e]) {
								return;
							}
							checkCircular(e, o);
							Object.keys(o).forEach((t) => {
								i[t][e] = true;
							});
						});
						delete o[a];
					}
					checkCircular(this.primaryType, {});
					for (const t in i) {
						const r = Object.keys(i[t]);
						r.sort();
						this._types[t] = encodeType(t, e[t]) + r.map((t) => encodeType(t, e[t])).join('');
					}
				}
				getEncoder(e) {
					let t = this._encoderCache[e];
					if (!t) {
						t = this._encoderCache[e] = this._getEncoder(e);
					}
					return t;
				}
				_getEncoder(e) {
					{
						const t = getBaseEncoder(e);
						if (t) {
							return t;
						}
					}
					const t = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
					if (t) {
						const e = t[1];
						const r = this.getEncoder(e);
						const i = parseInt(t[3]);
						return (t) => {
							if (i >= 0 && t.length !== i) {
								g.throwArgumentError(
									'array length mismatch; expected length ${ arrayLength }',
									'value',
									t
								);
							}
							let a = t.map(r);
							if (this._types[e]) {
								a = a.map(c.S);
							}
							return (0, c.S)((0, o.qn)(a));
						};
					}
					const r = this.types[e];
					if (r) {
						const t = (0, p.id)(this._types[e]);
						return (e) => {
							const i = r.map(({ name: t, type: r }) => {
								const i = this.getEncoder(r)(e[t]);
								if (this._types[r]) {
									return (0, c.S)(i);
								}
								return i;
							});
							i.unshift(t);
							return (0, o.qn)(i);
						};
					}
					return g.throwArgumentError(`unknown type: ${e}`, 'type', e);
				}
				encodeType(e) {
					const t = this._types[e];
					if (!t) {
						g.throwArgumentError(`unknown type: ${JSON.stringify(e)}`, 'name', e);
					}
					return t;
				}
				encodeData(e, t) {
					return this.getEncoder(e)(t);
				}
				hashStruct(e, t) {
					return (0, c.S)(this.encodeData(e, t));
				}
				encode(e) {
					return this.encodeData(this.primaryType, e);
				}
				hash(e) {
					return this.hashStruct(this.primaryType, e);
				}
				_visit(e, t, r) {
					{
						const i = getBaseEncoder(e);
						if (i) {
							return r(e, t);
						}
					}
					const i = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
					if (i) {
						const e = i[1];
						const a = parseInt(i[3]);
						if (a >= 0 && t.length !== a) {
							g.throwArgumentError(
								'array length mismatch; expected length ${ arrayLength }',
								'value',
								t
							);
						}
						return t.map((t) => this._visit(e, t, r));
					}
					const a = this.types[e];
					if (a) {
						return a.reduce((e, { name: i, type: a }) => {
							e[i] = this._visit(a, t[i], r);
							return e;
						}, {});
					}
					return g.throwArgumentError(`unknown type: ${e}`, 'type', e);
				}
				visit(e, t) {
					return this._visit(this.primaryType, e, t);
				}
				static from(e) {
					return new TypedDataEncoder(e);
				}
				static getPrimaryType(e) {
					return TypedDataEncoder.from(e).primaryType;
				}
				static hashStruct(e, t, r) {
					return TypedDataEncoder.from(t).hashStruct(e, r);
				}
				static hashDomain(e) {
					const t = [];
					for (const r in e) {
						const i = T[r];
						if (!i) {
							g.throwArgumentError(
								`invalid typed-data domain key: ${JSON.stringify(r)}`,
								'domain',
								e
							);
						}
						t.push({ name: r, type: i });
					}
					t.sort((e, t) => x.indexOf(e.name) - x.indexOf(t.name));
					return TypedDataEncoder.hashStruct('EIP712Domain', { EIP712Domain: t }, e);
				}
				static encode(e, t, r) {
					return (0, o.qn)([
						'0x1901',
						TypedDataEncoder.hashDomain(e),
						TypedDataEncoder.from(t).hash(r)
					]);
				}
				static hash(e, t, r) {
					return (0, c.S)(TypedDataEncoder.encode(e, t, r));
				}
				static resolveNames(e, t, r, i) {
					return m(this, void 0, void 0, function* () {
						e = (0, u.Ic)(e);
						const a = {};
						if (e.verifyingContract && !(0, o.Lo)(e.verifyingContract, 20)) {
							a[e.verifyingContract] = '0x';
						}
						const c = TypedDataEncoder.from(t);
						c.visit(r, (e, t) => {
							if (e === 'address' && !(0, o.Lo)(t, 20)) {
								a[t] = '0x';
							}
							return t;
						});
						for (const e in a) {
							a[e] = yield i(e);
						}
						if (e.verifyingContract && a[e.verifyingContract]) {
							e.verifyingContract = a[e.verifyingContract];
						}
						r = c.visit(r, (e, t) => {
							if (e === 'address' && a[t]) {
								return a[t];
							}
							return t;
						});
						return { domain: e, value: r };
					});
				}
				static getPayload(e, t, r) {
					TypedDataEncoder.hashDomain(e);
					const i = {};
					const c = [];
					x.forEach((t) => {
						const r = e[t];
						if (r == null) {
							return;
						}
						i[t] = B[t](r);
						c.push({ name: t, type: T[t] });
					});
					const l = TypedDataEncoder.from(t);
					const d = (0, u.Ic)(t);
					if (d.EIP712Domain) {
						g.throwArgumentError(
							'types must not contain EIP712Domain type',
							'types.EIP712Domain',
							t
						);
					} else {
						d.EIP712Domain = c;
					}
					l.encode(r);
					return {
						types: d,
						domain: i,
						primaryType: l.primaryType,
						message: l.visit(r, (e, t) => {
							if (e.match(/^bytes(\d*)/)) {
								return (0, o.c$)((0, o.k9)(t));
							}
							if (e.match(/^u?int/)) {
								return a.gH.from(t).toString();
							}
							switch (e) {
								case 'address':
									return t.toLowerCase();
								case 'bool':
									return !!t;
								case 'string':
									if (typeof t !== 'string') {
										g.throwArgumentError(`invalid string`, 'value', t);
									}
									return t;
							}
							return g.throwArgumentError('unsupported type', 'type', e);
						})
					};
				}
			}
		},
		4781: (e, t, r) => {
			'use strict';
			r.d(t, { S: () => keccak256 });
			var i = r(9162);
			var a = r.n(i);
			var o = r(1519);
			function keccak256(e) {
				return '0x' + a().keccak_256((0, o.k9)(e));
			}
		},
		5982: (e, t, r) => {
			'use strict';
			r.d(t, { Vy: () => Logger });
			const i = 'logger/5.7.0';
			let a = false;
			let o = false;
			const c = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
			let u = c['default'];
			let l = null;
			function _checkNormalize() {
				try {
					const e = [];
					['NFD', 'NFC', 'NFKD', 'NFKC'].forEach((t) => {
						try {
							if ('test'.normalize(t) !== 'test') {
								throw new Error('bad normalize');
							}
						} catch (r) {
							e.push(t);
						}
					});
					if (e.length) {
						throw new Error('missing ' + e.join(', '));
					}
					if (String.fromCharCode(233).normalize('NFD') !== String.fromCharCode(101, 769)) {
						throw new Error('broken implementation');
					}
				} catch (e) {
					return e.message;
				}
				return null;
			}
			const d = _checkNormalize();
			var p;
			(function (e) {
				e['DEBUG'] = 'DEBUG';
				e['INFO'] = 'INFO';
				e['WARNING'] = 'WARNING';
				e['ERROR'] = 'ERROR';
				e['OFF'] = 'OFF';
			})(p || (p = {}));
			var m;
			(function (e) {
				e['UNKNOWN_ERROR'] = 'UNKNOWN_ERROR';
				e['NOT_IMPLEMENTED'] = 'NOT_IMPLEMENTED';
				e['UNSUPPORTED_OPERATION'] = 'UNSUPPORTED_OPERATION';
				e['NETWORK_ERROR'] = 'NETWORK_ERROR';
				e['SERVER_ERROR'] = 'SERVER_ERROR';
				e['TIMEOUT'] = 'TIMEOUT';
				e['BUFFER_OVERRUN'] = 'BUFFER_OVERRUN';
				e['NUMERIC_FAULT'] = 'NUMERIC_FAULT';
				e['MISSING_NEW'] = 'MISSING_NEW';
				e['INVALID_ARGUMENT'] = 'INVALID_ARGUMENT';
				e['MISSING_ARGUMENT'] = 'MISSING_ARGUMENT';
				e['UNEXPECTED_ARGUMENT'] = 'UNEXPECTED_ARGUMENT';
				e['CALL_EXCEPTION'] = 'CALL_EXCEPTION';
				e['INSUFFICIENT_FUNDS'] = 'INSUFFICIENT_FUNDS';
				e['NONCE_EXPIRED'] = 'NONCE_EXPIRED';
				e['REPLACEMENT_UNDERPRICED'] = 'REPLACEMENT_UNDERPRICED';
				e['UNPREDICTABLE_GAS_LIMIT'] = 'UNPREDICTABLE_GAS_LIMIT';
				e['TRANSACTION_REPLACED'] = 'TRANSACTION_REPLACED';
				e['ACTION_REJECTED'] = 'ACTION_REJECTED';
			})(m || (m = {}));
			const g = '0123456789abcdef';
			class Logger {
				constructor(e) {
					Object.defineProperty(this, 'version', { enumerable: true, value: e, writable: false });
				}
				_log(e, t) {
					const r = e.toLowerCase();
					if (c[r] == null) {
						this.throwArgumentError('invalid log level name', 'logLevel', e);
					}
					if (u > c[r]) {
						return;
					}
					console.log.apply(console, t);
				}
				debug(...e) {
					this._log(Logger.levels.DEBUG, e);
				}
				info(...e) {
					this._log(Logger.levels.INFO, e);
				}
				warn(...e) {
					this._log(Logger.levels.WARNING, e);
				}
				makeError(e, t, r) {
					if (o) {
						return this.makeError('censored error', t, {});
					}
					if (!t) {
						t = Logger.errors.UNKNOWN_ERROR;
					}
					if (!r) {
						r = {};
					}
					const i = [];
					Object.keys(r).forEach((e) => {
						const t = r[e];
						try {
							if (t instanceof Uint8Array) {
								let r = '';
								for (let e = 0; e < t.length; e++) {
									r += g[t[e] >> 4];
									r += g[t[e] & 15];
								}
								i.push(e + '=Uint8Array(0x' + r + ')');
							} else {
								i.push(e + '=' + JSON.stringify(t));
							}
						} catch (t) {
							i.push(e + '=' + JSON.stringify(r[e].toString()));
						}
					});
					i.push(`code=${t}`);
					i.push(`version=${this.version}`);
					const a = e;
					let c = '';
					switch (t) {
						case m.NUMERIC_FAULT: {
							c = 'NUMERIC_FAULT';
							const t = e;
							switch (t) {
								case 'overflow':
								case 'underflow':
								case 'division-by-zero':
									c += '-' + t;
									break;
								case 'negative-power':
								case 'negative-width':
									c += '-unsupported';
									break;
								case 'unbound-bitwise-result':
									c += '-unbound-result';
									break;
							}
							break;
						}
						case m.CALL_EXCEPTION:
						case m.INSUFFICIENT_FUNDS:
						case m.MISSING_NEW:
						case m.NONCE_EXPIRED:
						case m.REPLACEMENT_UNDERPRICED:
						case m.TRANSACTION_REPLACED:
						case m.UNPREDICTABLE_GAS_LIMIT:
							c = t;
							break;
					}
					if (c) {
						e += ' [ See: https://links.ethers.org/v5-errors-' + c + ' ]';
					}
					if (i.length) {
						e += ' (' + i.join(', ') + ')';
					}
					const u = new Error(e);
					u.reason = a;
					u.code = t;
					Object.keys(r).forEach(function (e) {
						u[e] = r[e];
					});
					return u;
				}
				throwError(e, t, r) {
					throw this.makeError(e, t, r);
				}
				throwArgumentError(e, t, r) {
					return this.throwError(e, Logger.errors.INVALID_ARGUMENT, { argument: t, value: r });
				}
				assert(e, t, r, i) {
					if (!!e) {
						return;
					}
					this.throwError(t, r, i);
				}
				assertArgument(e, t, r, i) {
					if (!!e) {
						return;
					}
					this.throwArgumentError(t, r, i);
				}
				checkNormalize(e) {
					if (e == null) {
						e = 'platform missing String.prototype.normalize';
					}
					if (d) {
						this.throwError(
							'platform missing String.prototype.normalize',
							Logger.errors.UNSUPPORTED_OPERATION,
							{ operation: 'String.prototype.normalize', form: d }
						);
					}
				}
				checkSafeUint53(e, t) {
					if (typeof e !== 'number') {
						return;
					}
					if (t == null) {
						t = 'value not safe';
					}
					if (e < 0 || e >= 9007199254740991) {
						this.throwError(t, Logger.errors.NUMERIC_FAULT, {
							operation: 'checkSafeInteger',
							fault: 'out-of-safe-range',
							value: e
						});
					}
					if (e % 1) {
						this.throwError(t, Logger.errors.NUMERIC_FAULT, {
							operation: 'checkSafeInteger',
							fault: 'non-integer',
							value: e
						});
					}
				}
				checkArgumentCount(e, t, r) {
					if (r) {
						r = ': ' + r;
					} else {
						r = '';
					}
					if (e < t) {
						this.throwError('missing argument' + r, Logger.errors.MISSING_ARGUMENT, {
							count: e,
							expectedCount: t
						});
					}
					if (e > t) {
						this.throwError('too many arguments' + r, Logger.errors.UNEXPECTED_ARGUMENT, {
							count: e,
							expectedCount: t
						});
					}
				}
				checkNew(e, t) {
					if (e === Object || e == null) {
						this.throwError('missing new', Logger.errors.MISSING_NEW, { name: t.name });
					}
				}
				checkAbstract(e, t) {
					if (e === t) {
						this.throwError(
							'cannot instantiate abstract class ' +
								JSON.stringify(t.name) +
								' directly; use a sub-class',
							Logger.errors.UNSUPPORTED_OPERATION,
							{ name: e.name, operation: 'new' }
						);
					} else if (e === Object || e == null) {
						this.throwError('missing new', Logger.errors.MISSING_NEW, { name: t.name });
					}
				}
				static globalLogger() {
					if (!l) {
						l = new Logger(i);
					}
					return l;
				}
				static setCensorship(e, t) {
					if (!e && t) {
						this.globalLogger().throwError(
							'cannot permanently disable censorship',
							Logger.errors.UNSUPPORTED_OPERATION,
							{ operation: 'setCensorship' }
						);
					}
					if (a) {
						if (!e) {
							return;
						}
						this.globalLogger().throwError(
							'error censorship permanent',
							Logger.errors.UNSUPPORTED_OPERATION,
							{ operation: 'setCensorship' }
						);
					}
					o = !!e;
					a = !!t;
				}
				static setLogLevel(e) {
					const t = c[e.toLowerCase()];
					if (t == null) {
						Logger.globalLogger().warn('invalid log level - ' + e);
						return;
					}
					u = t;
				}
				static from(e) {
					return new Logger(e);
				}
			}
			Logger.errors = m;
			Logger.levels = p;
		},
		3116: (e, t, r) => {
			'use strict';
			r.d(t, {
				VY: () => Description,
				qN: () => checkProperties,
				A4: () => deepCopy,
				yY: () => defineReadOnly,
				$J: () => getStatic,
				k_: () => resolveProperties,
				Ic: () => shallowCopy
			});
			var i = r(5982);
			const a = 'properties/5.7.0';
			var o =
				(undefined && undefined.__awaiter) ||
				function (e, t, r, i) {
					function adopt(e) {
						return e instanceof r
							? e
							: new r(function (t) {
									t(e);
								});
					}
					return new (r || (r = Promise))(function (r, a) {
						function fulfilled(e) {
							try {
								step(i.next(e));
							} catch (e) {
								a(e);
							}
						}
						function rejected(e) {
							try {
								step(i['throw'](e));
							} catch (e) {
								a(e);
							}
						}
						function step(e) {
							e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected);
						}
						step((i = i.apply(e, t || [])).next());
					});
				};
			const c = new i.Vy(a);
			function defineReadOnly(e, t, r) {
				Object.defineProperty(e, t, { enumerable: true, value: r, writable: false });
			}
			function getStatic(e, t) {
				for (let r = 0; r < 32; r++) {
					if (e[t]) {
						return e[t];
					}
					if (!e.prototype || typeof e.prototype !== 'object') {
						break;
					}
					e = Object.getPrototypeOf(e.prototype).constructor;
				}
				return null;
			}
			function resolveProperties(e) {
				return o(this, void 0, void 0, function* () {
					const t = Object.keys(e).map((t) => {
						const r = e[t];
						return Promise.resolve(r).then((e) => ({ key: t, value: e }));
					});
					const r = yield Promise.all(t);
					return r.reduce((e, t) => {
						e[t.key] = t.value;
						return e;
					}, {});
				});
			}
			function checkProperties(e, t) {
				if (!e || typeof e !== 'object') {
					c.throwArgumentError('invalid object', 'object', e);
				}
				Object.keys(e).forEach((r) => {
					if (!t[r]) {
						c.throwArgumentError('invalid object key - ' + r, 'transaction:' + r, e);
					}
				});
			}
			function shallowCopy(e) {
				const t = {};
				for (const r in e) {
					t[r] = e[r];
				}
				return t;
			}
			const u = { bigint: true, boolean: true, function: true, number: true, string: true };
			function _isFrozen(e) {
				if (e === undefined || e === null || u[typeof e]) {
					return true;
				}
				if (Array.isArray(e) || typeof e === 'object') {
					if (!Object.isFrozen(e)) {
						return false;
					}
					const t = Object.keys(e);
					for (let r = 0; r < t.length; r++) {
						let i = null;
						try {
							i = e[t[r]];
						} catch (e) {
							continue;
						}
						if (!_isFrozen(i)) {
							return false;
						}
					}
					return true;
				}
				return c.throwArgumentError(`Cannot deepCopy ${typeof e}`, 'object', e);
			}
			function _deepCopy(e) {
				if (_isFrozen(e)) {
					return e;
				}
				if (Array.isArray(e)) {
					return Object.freeze(e.map((e) => deepCopy(e)));
				}
				if (typeof e === 'object') {
					const t = {};
					for (const r in e) {
						const i = e[r];
						if (i === undefined) {
							continue;
						}
						defineReadOnly(t, r, deepCopy(i));
					}
					return t;
				}
				return c.throwArgumentError(`Cannot deepCopy ${typeof e}`, 'object', e);
			}
			function deepCopy(e) {
				return _deepCopy(e);
			}
			class Description {
				constructor(e) {
					for (const t in e) {
						this[t] = deepCopy(e[t]);
					}
				}
			}
		},
		8804: (e, t, r) => {
			'use strict';
			r.d(t, { D: () => decode, l: () => encode });
			var i = r(1519);
			var a = r(5982);
			const o = 'rlp/5.7.0';
			const c = new a.Vy(o);
			function arrayifyInteger(e) {
				const t = [];
				while (e) {
					t.unshift(e & 255);
					e >>= 8;
				}
				return t;
			}
			function unarrayifyInteger(e, t, r) {
				let i = 0;
				for (let a = 0; a < r; a++) {
					i = i * 256 + e[t + a];
				}
				return i;
			}
			function _encode(e) {
				if (Array.isArray(e)) {
					let t = [];
					e.forEach(function (e) {
						t = t.concat(_encode(e));
					});
					if (t.length <= 55) {
						t.unshift(192 + t.length);
						return t;
					}
					const r = arrayifyInteger(t.length);
					r.unshift(247 + r.length);
					return r.concat(t);
				}
				if (!(0, i.f)(e)) {
					c.throwArgumentError('RLP object must be BytesLike', 'object', e);
				}
				const t = Array.prototype.slice.call((0, i.k9)(e));
				if (t.length === 1 && t[0] <= 127) {
					return t;
				} else if (t.length <= 55) {
					t.unshift(128 + t.length);
					return t;
				}
				const r = arrayifyInteger(t.length);
				r.unshift(183 + r.length);
				return r.concat(t);
			}
			function encode(e) {
				return (0, i.c$)(_encode(e));
			}
			function _decodeChildren(e, t, r, i) {
				const o = [];
				while (r < t + 1 + i) {
					const u = _decode(e, r);
					o.push(u.result);
					r += u.consumed;
					if (r > t + 1 + i) {
						c.throwError('child data too short', a.Vy.errors.BUFFER_OVERRUN, {});
					}
				}
				return { consumed: 1 + i, result: o };
			}
			function _decode(e, t) {
				if (e.length === 0) {
					c.throwError('data too short', a.Vy.errors.BUFFER_OVERRUN, {});
				}
				if (e[t] >= 248) {
					const r = e[t] - 247;
					if (t + 1 + r > e.length) {
						c.throwError('data short segment too short', a.Vy.errors.BUFFER_OVERRUN, {});
					}
					const i = unarrayifyInteger(e, t + 1, r);
					if (t + 1 + r + i > e.length) {
						c.throwError('data long segment too short', a.Vy.errors.BUFFER_OVERRUN, {});
					}
					return _decodeChildren(e, t, t + 1 + r, r + i);
				} else if (e[t] >= 192) {
					const r = e[t] - 192;
					if (t + 1 + r > e.length) {
						c.throwError('data array too short', a.Vy.errors.BUFFER_OVERRUN, {});
					}
					return _decodeChildren(e, t, t + 1, r);
				} else if (e[t] >= 184) {
					const r = e[t] - 183;
					if (t + 1 + r > e.length) {
						c.throwError('data array too short', a.Vy.errors.BUFFER_OVERRUN, {});
					}
					const o = unarrayifyInteger(e, t + 1, r);
					if (t + 1 + r + o > e.length) {
						c.throwError('data array too short', a.Vy.errors.BUFFER_OVERRUN, {});
					}
					const u = (0, i.c$)(e.slice(t + 1 + r, t + 1 + r + o));
					return { consumed: 1 + r + o, result: u };
				} else if (e[t] >= 128) {
					const r = e[t] - 128;
					if (t + 1 + r > e.length) {
						c.throwError('data too short', a.Vy.errors.BUFFER_OVERRUN, {});
					}
					const o = (0, i.c$)(e.slice(t + 1, t + 1 + r));
					return { consumed: 1 + r, result: o };
				}
				return { consumed: 1, result: (0, i.c$)(e[t]) };
			}
			function decode(e) {
				const t = (0, i.k9)(e);
				const r = _decode(t, 0);
				if (r.consumed !== t.length) {
					c.throwArgumentError('invalid rlp data', 'data', e);
				}
				return r.result;
			}
		},
		985: (e, t, r) => {
			'use strict';
			r.d(t, { L5: () => computeHmac, HE: () => ripemd160, sc: () => sha256 });
			var i = r(1631);
			var a = r.n(i);
			var o = r(1519);
			var c = r(1062);
			var u = r(5982);
			const l = 'sha2/5.7.0';
			const d = new u.Vy(l);
			function ripemd160(e) {
				return (
					'0x' +
					a()
						.ripemd160()
						.update((0, o.k9)(e))
						.digest('hex')
				);
			}
			function sha256(e) {
				return (
					'0x' +
					a()
						.sha256()
						.update((0, o.k9)(e))
						.digest('hex')
				);
			}
			function sha512(e) {
				return '0x' + hash.sha512().update(arrayify(e)).digest('hex');
			}
			function computeHmac(e, t, r) {
				if (!c.q[e]) {
					d.throwError('unsupported algorithm ' + e, u.Vy.errors.UNSUPPORTED_OPERATION, {
						operation: 'hmac',
						algorithm: e
					});
				}
				return (
					'0x' +
					a()
						.hmac(a()[e], (0, o.k9)(t))
						.update((0, o.k9)(r))
						.digest('hex')
				);
			}
		},
		1062: (e, t, r) => {
			'use strict';
			r.d(t, { q: () => i });
			var i;
			(function (e) {
				e['sha256'] = 'sha256';
				e['sha512'] = 'sha512';
			})(i || (i = {}));
		},
		3013: (e, t, r) => {
			'use strict';
			r.d(t, { hR: () => SigningKey, uN: () => computePublicKey, jL: () => recoverPublicKey });
			var i = r(3900);
			var a = r.n(i);
			var o = r(1631);
			var c = r.n(o);
			var u =
				typeof globalThis !== 'undefined'
					? globalThis
					: typeof window !== 'undefined'
						? window
						: typeof r.g !== 'undefined'
							? r.g
							: typeof self !== 'undefined'
								? self
								: {};
			function getDefaultExportFromCjs(e) {
				return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default')
					? e['default']
					: e;
			}
			function createCommonjsModule(e, t, r) {
				return (
					(r = {
						path: t,
						exports: {},
						require: function (e, t) {
							return commonjsRequire(e, t === undefined || t === null ? r.path : t);
						}
					}),
					e(r, r.exports),
					r.exports
				);
			}
			function getDefaultExportFromNamespaceIfPresent(e) {
				return e && Object.prototype.hasOwnProperty.call(e, 'default') ? e['default'] : e;
			}
			function getDefaultExportFromNamespaceIfNotNamed(e) {
				return e &&
					Object.prototype.hasOwnProperty.call(e, 'default') &&
					Object.keys(e).length === 1
					? e['default']
					: e;
			}
			function getAugmentedNamespace(e) {
				if (e.__esModule) return e;
				var t = Object.defineProperty({}, '__esModule', { value: true });
				Object.keys(e).forEach(function (r) {
					var i = Object.getOwnPropertyDescriptor(e, r);
					Object.defineProperty(
						t,
						r,
						i.get
							? i
							: {
									enumerable: true,
									get: function () {
										return e[r];
									}
								}
					);
				});
				return t;
			}
			function commonjsRequire() {
				throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
			}
			var l = assert;
			function assert(e, t) {
				if (!e) throw new Error(t || 'Assertion failed');
			}
			assert.equal = function assertEqual(e, t, r) {
				if (e != t) throw new Error(r || 'Assertion failed: ' + e + ' != ' + t);
			};
			var d = createCommonjsModule(function (e, t) {
				'use strict';
				var r = t;
				function toArray(e, t) {
					if (Array.isArray(e)) return e.slice();
					if (!e) return [];
					var r = [];
					if (typeof e !== 'string') {
						for (var i = 0; i < e.length; i++) r[i] = e[i] | 0;
						return r;
					}
					if (t === 'hex') {
						e = e.replace(/[^a-z0-9]+/gi, '');
						if (e.length % 2 !== 0) e = '0' + e;
						for (var i = 0; i < e.length; i += 2) r.push(parseInt(e[i] + e[i + 1], 16));
					} else {
						for (var i = 0; i < e.length; i++) {
							var a = e.charCodeAt(i);
							var o = a >> 8;
							var c = a & 255;
							if (o) r.push(o, c);
							else r.push(c);
						}
					}
					return r;
				}
				r.toArray = toArray;
				function zero2(e) {
					if (e.length === 1) return '0' + e;
					else return e;
				}
				r.zero2 = zero2;
				function toHex(e) {
					var t = '';
					for (var r = 0; r < e.length; r++) t += zero2(e[r].toString(16));
					return t;
				}
				r.toHex = toHex;
				r.encode = function encode(e, t) {
					if (t === 'hex') return toHex(e);
					else return e;
				};
			});
			var p = createCommonjsModule(function (e, t) {
				'use strict';
				var r = t;
				r.assert = l;
				r.toArray = d.toArray;
				r.zero2 = d.zero2;
				r.toHex = d.toHex;
				r.encode = d.encode;
				function getNAF(e, t, r) {
					var i = new Array(Math.max(e.bitLength(), r) + 1);
					i.fill(0);
					var a = 1 << (t + 1);
					var o = e.clone();
					for (var c = 0; c < i.length; c++) {
						var u;
						var l = o.andln(a - 1);
						if (o.isOdd()) {
							if (l > (a >> 1) - 1) u = (a >> 1) - l;
							else u = l;
							o.isubn(u);
						} else {
							u = 0;
						}
						i[c] = u;
						o.iushrn(1);
					}
					return i;
				}
				r.getNAF = getNAF;
				function getJSF(e, t) {
					var r = [[], []];
					e = e.clone();
					t = t.clone();
					var i = 0;
					var a = 0;
					var o;
					while (e.cmpn(-i) > 0 || t.cmpn(-a) > 0) {
						var c = (e.andln(3) + i) & 3;
						var u = (t.andln(3) + a) & 3;
						if (c === 3) c = -1;
						if (u === 3) u = -1;
						var l;
						if ((c & 1) === 0) {
							l = 0;
						} else {
							o = (e.andln(7) + i) & 7;
							if ((o === 3 || o === 5) && u === 2) l = -c;
							else l = c;
						}
						r[0].push(l);
						var d;
						if ((u & 1) === 0) {
							d = 0;
						} else {
							o = (t.andln(7) + a) & 7;
							if ((o === 3 || o === 5) && c === 2) d = -u;
							else d = u;
						}
						r[1].push(d);
						if (2 * i === l + 1) i = 1 - i;
						if (2 * a === d + 1) a = 1 - a;
						e.iushrn(1);
						t.iushrn(1);
					}
					return r;
				}
				r.getJSF = getJSF;
				function cachedProperty(e, t, r) {
					var i = '_' + t;
					e.prototype[t] = function cachedProperty() {
						return this[i] !== undefined ? this[i] : (this[i] = r.call(this));
					};
				}
				r.cachedProperty = cachedProperty;
				function parseBytes(e) {
					return typeof e === 'string' ? r.toArray(e, 'hex') : e;
				}
				r.parseBytes = parseBytes;
				function intFromLE(e) {
					return new (a())(e, 'hex', 'le');
				}
				r.intFromLE = intFromLE;
			});
			('use strict');
			var m = p.getNAF;
			var g = p.getJSF;
			var v = p.assert;
			function BaseCurve(e, t) {
				this.type = e;
				this.p = new (a())(t.p, 16);
				this.red = t.prime ? a().red(t.prime) : a().mont(this.p);
				this.zero = new (a())(0).toRed(this.red);
				this.one = new (a())(1).toRed(this.red);
				this.two = new (a())(2).toRed(this.red);
				this.n = t.n && new (a())(t.n, 16);
				this.g = t.g && this.pointFromJSON(t.g, t.gRed);
				this._wnafT1 = new Array(4);
				this._wnafT2 = new Array(4);
				this._wnafT3 = new Array(4);
				this._wnafT4 = new Array(4);
				this._bitLength = this.n ? this.n.bitLength() : 0;
				var r = this.n && this.p.div(this.n);
				if (!r || r.cmpn(100) > 0) {
					this.redN = null;
				} else {
					this._maxwellTrick = true;
					this.redN = this.n.toRed(this.red);
				}
			}
			var y = BaseCurve;
			BaseCurve.prototype.point = function point() {
				throw new Error('Not implemented');
			};
			BaseCurve.prototype.validate = function validate() {
				throw new Error('Not implemented');
			};
			BaseCurve.prototype._fixedNafMul = function _fixedNafMul(e, t) {
				v(e.precomputed);
				var r = e._getDoubles();
				var i = m(t, 1, this._bitLength);
				var a = (1 << (r.step + 1)) - (r.step % 2 === 0 ? 2 : 1);
				a /= 3;
				var o = [];
				var c;
				var u;
				for (c = 0; c < i.length; c += r.step) {
					u = 0;
					for (var l = c + r.step - 1; l >= c; l--) u = (u << 1) + i[l];
					o.push(u);
				}
				var d = this.jpoint(null, null, null);
				var p = this.jpoint(null, null, null);
				for (var g = a; g > 0; g--) {
					for (c = 0; c < o.length; c++) {
						u = o[c];
						if (u === g) p = p.mixedAdd(r.points[c]);
						else if (u === -g) p = p.mixedAdd(r.points[c].neg());
					}
					d = d.add(p);
				}
				return d.toP();
			};
			BaseCurve.prototype._wnafMul = function _wnafMul(e, t) {
				var r = 4;
				var i = e._getNAFPoints(r);
				r = i.wnd;
				var a = i.points;
				var o = m(t, r, this._bitLength);
				var c = this.jpoint(null, null, null);
				for (var u = o.length - 1; u >= 0; u--) {
					for (var l = 0; u >= 0 && o[u] === 0; u--) l++;
					if (u >= 0) l++;
					c = c.dblp(l);
					if (u < 0) break;
					var d = o[u];
					v(d !== 0);
					if (e.type === 'affine') {
						if (d > 0) c = c.mixedAdd(a[(d - 1) >> 1]);
						else c = c.mixedAdd(a[(-d - 1) >> 1].neg());
					} else {
						if (d > 0) c = c.add(a[(d - 1) >> 1]);
						else c = c.add(a[(-d - 1) >> 1].neg());
					}
				}
				return e.type === 'affine' ? c.toP() : c;
			};
			BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(e, t, r, i, a) {
				var o = this._wnafT1;
				var c = this._wnafT2;
				var u = this._wnafT3;
				var l = 0;
				var d;
				var p;
				var v;
				for (d = 0; d < i; d++) {
					v = t[d];
					var y = v._getNAFPoints(e);
					o[d] = y.wnd;
					c[d] = y.points;
				}
				for (d = i - 1; d >= 1; d -= 2) {
					var w = d - 1;
					var _ = d;
					if (o[w] !== 1 || o[_] !== 1) {
						u[w] = m(r[w], o[w], this._bitLength);
						u[_] = m(r[_], o[_], this._bitLength);
						l = Math.max(u[w].length, l);
						l = Math.max(u[_].length, l);
						continue;
					}
					var A = [t[w], null, null, t[_]];
					if (t[w].y.cmp(t[_].y) === 0) {
						A[1] = t[w].add(t[_]);
						A[2] = t[w].toJ().mixedAdd(t[_].neg());
					} else if (t[w].y.cmp(t[_].y.redNeg()) === 0) {
						A[1] = t[w].toJ().mixedAdd(t[_]);
						A[2] = t[w].add(t[_].neg());
					} else {
						A[1] = t[w].toJ().mixedAdd(t[_]);
						A[2] = t[w].toJ().mixedAdd(t[_].neg());
					}
					var k = [-3, -1, -5, -7, 0, 7, 5, 1, 3];
					var N = g(r[w], r[_]);
					l = Math.max(N[0].length, l);
					u[w] = new Array(l);
					u[_] = new Array(l);
					for (p = 0; p < l; p++) {
						var T = N[0][p] | 0;
						var x = N[1][p] | 0;
						u[w][p] = k[(T + 1) * 3 + (x + 1)];
						u[_][p] = 0;
						c[w] = A;
					}
				}
				var B = this.jpoint(null, null, null);
				var P = this._wnafT4;
				for (d = l; d >= 0; d--) {
					var M = 0;
					while (d >= 0) {
						var C = true;
						for (p = 0; p < i; p++) {
							P[p] = u[p][d] | 0;
							if (P[p] !== 0) C = false;
						}
						if (!C) break;
						M++;
						d--;
					}
					if (d >= 0) M++;
					B = B.dblp(M);
					if (d < 0) break;
					for (p = 0; p < i; p++) {
						var I = P[p];
						v;
						if (I === 0) continue;
						else if (I > 0) v = c[p][(I - 1) >> 1];
						else if (I < 0) v = c[p][(-I - 1) >> 1].neg();
						if (v.type === 'affine') B = B.mixedAdd(v);
						else B = B.add(v);
					}
				}
				for (d = 0; d < i; d++) c[d] = null;
				if (a) return B;
				else return B.toP();
			};
			function BasePoint(e, t) {
				this.curve = e;
				this.type = t;
				this.precomputed = null;
			}
			BaseCurve.BasePoint = BasePoint;
			BasePoint.prototype.eq = function eq() {
				throw new Error('Not implemented');
			};
			BasePoint.prototype.validate = function validate() {
				return this.curve.validate(this);
			};
			BaseCurve.prototype.decodePoint = function decodePoint(e, t) {
				e = p.toArray(e, t);
				var r = this.p.byteLength();
				if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * r) {
					if (e[0] === 6) v(e[e.length - 1] % 2 === 0);
					else if (e[0] === 7) v(e[e.length - 1] % 2 === 1);
					var i = this.point(e.slice(1, 1 + r), e.slice(1 + r, 1 + 2 * r));
					return i;
				} else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === r) {
					return this.pointFromX(e.slice(1, 1 + r), e[0] === 3);
				}
				throw new Error('Unknown point format');
			};
			BasePoint.prototype.encodeCompressed = function encodeCompressed(e) {
				return this.encode(e, true);
			};
			BasePoint.prototype._encode = function _encode(e) {
				var t = this.curve.p.byteLength();
				var r = this.getX().toArray('be', t);
				if (e) return [this.getY().isEven() ? 2 : 3].concat(r);
				return [4].concat(r, this.getY().toArray('be', t));
			};
			BasePoint.prototype.encode = function encode(e, t) {
				return p.encode(this._encode(t), e);
			};
			BasePoint.prototype.precompute = function precompute(e) {
				if (this.precomputed) return this;
				var t = { doubles: null, naf: null, beta: null };
				t.naf = this._getNAFPoints(8);
				t.doubles = this._getDoubles(4, e);
				t.beta = this._getBeta();
				this.precomputed = t;
				return this;
			};
			BasePoint.prototype._hasDoubles = function _hasDoubles(e) {
				if (!this.precomputed) return false;
				var t = this.precomputed.doubles;
				if (!t) return false;
				return t.points.length >= Math.ceil((e.bitLength() + 1) / t.step);
			};
			BasePoint.prototype._getDoubles = function _getDoubles(e, t) {
				if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
				var r = [this];
				var i = this;
				for (var a = 0; a < t; a += e) {
					for (var o = 0; o < e; o++) i = i.dbl();
					r.push(i);
				}
				return { step: e, points: r };
			};
			BasePoint.prototype._getNAFPoints = function _getNAFPoints(e) {
				if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
				var t = [this];
				var r = (1 << e) - 1;
				var i = r === 1 ? null : this.dbl();
				for (var a = 1; a < r; a++) t[a] = t[a - 1].add(i);
				return { wnd: e, points: t };
			};
			BasePoint.prototype._getBeta = function _getBeta() {
				return null;
			};
			BasePoint.prototype.dblp = function dblp(e) {
				var t = this;
				for (var r = 0; r < e; r++) t = t.dbl();
				return t;
			};
			var w = createCommonjsModule(function (e) {
				if (typeof Object.create === 'function') {
					e.exports = function inherits(e, t) {
						if (t) {
							e.super_ = t;
							e.prototype = Object.create(t.prototype, {
								constructor: { value: e, enumerable: false, writable: true, configurable: true }
							});
						}
					};
				} else {
					e.exports = function inherits(e, t) {
						if (t) {
							e.super_ = t;
							var TempCtor = function () {};
							TempCtor.prototype = t.prototype;
							e.prototype = new TempCtor();
							e.prototype.constructor = e;
						}
					};
				}
			});
			('use strict');
			var _ = p.assert;
			function ShortCurve(e) {
				y.call(this, 'short', e);
				this.a = new (a())(e.a, 16).toRed(this.red);
				this.b = new (a())(e.b, 16).toRed(this.red);
				this.tinv = this.two.redInvm();
				this.zeroA = this.a.fromRed().cmpn(0) === 0;
				this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
				this.endo = this._getEndomorphism(e);
				this._endoWnafT1 = new Array(4);
				this._endoWnafT2 = new Array(4);
			}
			w(ShortCurve, y);
			var A = ShortCurve;
			ShortCurve.prototype._getEndomorphism = function _getEndomorphism(e) {
				if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return;
				var t;
				var r;
				if (e.beta) {
					t = new (a())(e.beta, 16).toRed(this.red);
				} else {
					var i = this._getEndoRoots(this.p);
					t = i[0].cmp(i[1]) < 0 ? i[0] : i[1];
					t = t.toRed(this.red);
				}
				if (e.lambda) {
					r = new (a())(e.lambda, 16);
				} else {
					var o = this._getEndoRoots(this.n);
					if (this.g.mul(o[0]).x.cmp(this.g.x.redMul(t)) === 0) {
						r = o[0];
					} else {
						r = o[1];
						_(this.g.mul(r).x.cmp(this.g.x.redMul(t)) === 0);
					}
				}
				var c;
				if (e.basis) {
					c = e.basis.map(function (e) {
						return { a: new (a())(e.a, 16), b: new (a())(e.b, 16) };
					});
				} else {
					c = this._getEndoBasis(r);
				}
				return { beta: t, lambda: r, basis: c };
			};
			ShortCurve.prototype._getEndoRoots = function _getEndoRoots(e) {
				var t = e === this.p ? this.red : a().mont(e);
				var r = new (a())(2).toRed(t).redInvm();
				var i = r.redNeg();
				var o = new (a())(3).toRed(t).redNeg().redSqrt().redMul(r);
				var c = i.redAdd(o).fromRed();
				var u = i.redSub(o).fromRed();
				return [c, u];
			};
			ShortCurve.prototype._getEndoBasis = function _getEndoBasis(e) {
				var t = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
				var r = e;
				var i = this.n.clone();
				var o = new (a())(1);
				var c = new (a())(0);
				var u = new (a())(0);
				var l = new (a())(1);
				var d;
				var p;
				var m;
				var g;
				var v;
				var y;
				var w;
				var _ = 0;
				var A;
				var k;
				while (r.cmpn(0) !== 0) {
					var N = i.div(r);
					A = i.sub(N.mul(r));
					k = u.sub(N.mul(o));
					var T = l.sub(N.mul(c));
					if (!m && A.cmp(t) < 0) {
						d = w.neg();
						p = o;
						m = A.neg();
						g = k;
					} else if (m && ++_ === 2) {
						break;
					}
					w = A;
					i = r;
					r = A;
					u = o;
					o = k;
					l = c;
					c = T;
				}
				v = A.neg();
				y = k;
				var x = m.sqr().add(g.sqr());
				var B = v.sqr().add(y.sqr());
				if (B.cmp(x) >= 0) {
					v = d;
					y = p;
				}
				if (m.negative) {
					m = m.neg();
					g = g.neg();
				}
				if (v.negative) {
					v = v.neg();
					y = y.neg();
				}
				return [
					{ a: m, b: g },
					{ a: v, b: y }
				];
			};
			ShortCurve.prototype._endoSplit = function _endoSplit(e) {
				var t = this.endo.basis;
				var r = t[0];
				var i = t[1];
				var a = i.b.mul(e).divRound(this.n);
				var o = r.b.neg().mul(e).divRound(this.n);
				var c = a.mul(r.a);
				var u = o.mul(i.a);
				var l = a.mul(r.b);
				var d = o.mul(i.b);
				var p = e.sub(c).sub(u);
				var m = l.add(d).neg();
				return { k1: p, k2: m };
			};
			ShortCurve.prototype.pointFromX = function pointFromX(e, t) {
				e = new (a())(e, 16);
				if (!e.red) e = e.toRed(this.red);
				var r = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b);
				var i = r.redSqrt();
				if (i.redSqr().redSub(r).cmp(this.zero) !== 0) throw new Error('invalid point');
				var o = i.fromRed().isOdd();
				if ((t && !o) || (!t && o)) i = i.redNeg();
				return this.point(e, i);
			};
			ShortCurve.prototype.validate = function validate(e) {
				if (e.inf) return true;
				var t = e.x;
				var r = e.y;
				var i = this.a.redMul(t);
				var a = t.redSqr().redMul(t).redIAdd(i).redIAdd(this.b);
				return r.redSqr().redISub(a).cmpn(0) === 0;
			};
			ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(e, t, r) {
				var i = this._endoWnafT1;
				var a = this._endoWnafT2;
				for (var o = 0; o < e.length; o++) {
					var c = this._endoSplit(t[o]);
					var u = e[o];
					var l = u._getBeta();
					if (c.k1.negative) {
						c.k1.ineg();
						u = u.neg(true);
					}
					if (c.k2.negative) {
						c.k2.ineg();
						l = l.neg(true);
					}
					i[o * 2] = u;
					i[o * 2 + 1] = l;
					a[o * 2] = c.k1;
					a[o * 2 + 1] = c.k2;
				}
				var d = this._wnafMulAdd(1, i, a, o * 2, r);
				for (var p = 0; p < o * 2; p++) {
					i[p] = null;
					a[p] = null;
				}
				return d;
			};
			function Point(e, t, r, i) {
				y.BasePoint.call(this, e, 'affine');
				if (t === null && r === null) {
					this.x = null;
					this.y = null;
					this.inf = true;
				} else {
					this.x = new (a())(t, 16);
					this.y = new (a())(r, 16);
					if (i) {
						this.x.forceRed(this.curve.red);
						this.y.forceRed(this.curve.red);
					}
					if (!this.x.red) this.x = this.x.toRed(this.curve.red);
					if (!this.y.red) this.y = this.y.toRed(this.curve.red);
					this.inf = false;
				}
			}
			w(Point, y.BasePoint);
			ShortCurve.prototype.point = function point(e, t, r) {
				return new Point(this, e, t, r);
			};
			ShortCurve.prototype.pointFromJSON = function pointFromJSON(e, t) {
				return Point.fromJSON(this, e, t);
			};
			Point.prototype._getBeta = function _getBeta() {
				if (!this.curve.endo) return;
				var e = this.precomputed;
				if (e && e.beta) return e.beta;
				var t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
				if (e) {
					var r = this.curve;
					var endoMul = function (e) {
						return r.point(e.x.redMul(r.endo.beta), e.y);
					};
					e.beta = t;
					t.precomputed = {
						beta: null,
						naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(endoMul) },
						doubles: e.doubles && { step: e.doubles.step, points: e.doubles.points.map(endoMul) }
					};
				}
				return t;
			};
			Point.prototype.toJSON = function toJSON() {
				if (!this.precomputed) return [this.x, this.y];
				return [
					this.x,
					this.y,
					this.precomputed && {
						doubles: this.precomputed.doubles && {
							step: this.precomputed.doubles.step,
							points: this.precomputed.doubles.points.slice(1)
						},
						naf: this.precomputed.naf && {
							wnd: this.precomputed.naf.wnd,
							points: this.precomputed.naf.points.slice(1)
						}
					}
				];
			};
			Point.fromJSON = function fromJSON(e, t, r) {
				if (typeof t === 'string') t = JSON.parse(t);
				var i = e.point(t[0], t[1], r);
				if (!t[2]) return i;
				function obj2point(t) {
					return e.point(t[0], t[1], r);
				}
				var a = t[2];
				i.precomputed = {
					beta: null,
					doubles: a.doubles && {
						step: a.doubles.step,
						points: [i].concat(a.doubles.points.map(obj2point))
					},
					naf: a.naf && { wnd: a.naf.wnd, points: [i].concat(a.naf.points.map(obj2point)) }
				};
				return i;
			};
			Point.prototype.inspect = function inspect() {
				if (this.isInfinity()) return '<EC Point Infinity>';
				return (
					'<EC Point x: ' +
					this.x.fromRed().toString(16, 2) +
					' y: ' +
					this.y.fromRed().toString(16, 2) +
					'>'
				);
			};
			Point.prototype.isInfinity = function isInfinity() {
				return this.inf;
			};
			Point.prototype.add = function add(e) {
				if (this.inf) return e;
				if (e.inf) return this;
				if (this.eq(e)) return this.dbl();
				if (this.neg().eq(e)) return this.curve.point(null, null);
				if (this.x.cmp(e.x) === 0) return this.curve.point(null, null);
				var t = this.y.redSub(e.y);
				if (t.cmpn(0) !== 0) t = t.redMul(this.x.redSub(e.x).redInvm());
				var r = t.redSqr().redISub(this.x).redISub(e.x);
				var i = t.redMul(this.x.redSub(r)).redISub(this.y);
				return this.curve.point(r, i);
			};
			Point.prototype.dbl = function dbl() {
				if (this.inf) return this;
				var e = this.y.redAdd(this.y);
				if (e.cmpn(0) === 0) return this.curve.point(null, null);
				var t = this.curve.a;
				var r = this.x.redSqr();
				var i = e.redInvm();
				var a = r.redAdd(r).redIAdd(r).redIAdd(t).redMul(i);
				var o = a.redSqr().redISub(this.x.redAdd(this.x));
				var c = a.redMul(this.x.redSub(o)).redISub(this.y);
				return this.curve.point(o, c);
			};
			Point.prototype.getX = function getX() {
				return this.x.fromRed();
			};
			Point.prototype.getY = function getY() {
				return this.y.fromRed();
			};
			Point.prototype.mul = function mul(e) {
				e = new (a())(e, 16);
				if (this.isInfinity()) return this;
				else if (this._hasDoubles(e)) return this.curve._fixedNafMul(this, e);
				else if (this.curve.endo) return this.curve._endoWnafMulAdd([this], [e]);
				else return this.curve._wnafMul(this, e);
			};
			Point.prototype.mulAdd = function mulAdd(e, t, r) {
				var i = [this, t];
				var a = [e, r];
				if (this.curve.endo) return this.curve._endoWnafMulAdd(i, a);
				else return this.curve._wnafMulAdd(1, i, a, 2);
			};
			Point.prototype.jmulAdd = function jmulAdd(e, t, r) {
				var i = [this, t];
				var a = [e, r];
				if (this.curve.endo) return this.curve._endoWnafMulAdd(i, a, true);
				else return this.curve._wnafMulAdd(1, i, a, 2, true);
			};
			Point.prototype.eq = function eq(e) {
				return (
					this === e ||
					(this.inf === e.inf && (this.inf || (this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0)))
				);
			};
			Point.prototype.neg = function neg(e) {
				if (this.inf) return this;
				var t = this.curve.point(this.x, this.y.redNeg());
				if (e && this.precomputed) {
					var r = this.precomputed;
					var negate = function (e) {
						return e.neg();
					};
					t.precomputed = {
						naf: r.naf && { wnd: r.naf.wnd, points: r.naf.points.map(negate) },
						doubles: r.doubles && { step: r.doubles.step, points: r.doubles.points.map(negate) }
					};
				}
				return t;
			};
			Point.prototype.toJ = function toJ() {
				if (this.inf) return this.curve.jpoint(null, null, null);
				var e = this.curve.jpoint(this.x, this.y, this.curve.one);
				return e;
			};
			function JPoint(e, t, r, i) {
				y.BasePoint.call(this, e, 'jacobian');
				if (t === null && r === null && i === null) {
					this.x = this.curve.one;
					this.y = this.curve.one;
					this.z = new (a())(0);
				} else {
					this.x = new (a())(t, 16);
					this.y = new (a())(r, 16);
					this.z = new (a())(i, 16);
				}
				if (!this.x.red) this.x = this.x.toRed(this.curve.red);
				if (!this.y.red) this.y = this.y.toRed(this.curve.red);
				if (!this.z.red) this.z = this.z.toRed(this.curve.red);
				this.zOne = this.z === this.curve.one;
			}
			w(JPoint, y.BasePoint);
			ShortCurve.prototype.jpoint = function jpoint(e, t, r) {
				return new JPoint(this, e, t, r);
			};
			JPoint.prototype.toP = function toP() {
				if (this.isInfinity()) return this.curve.point(null, null);
				var e = this.z.redInvm();
				var t = e.redSqr();
				var r = this.x.redMul(t);
				var i = this.y.redMul(t).redMul(e);
				return this.curve.point(r, i);
			};
			JPoint.prototype.neg = function neg() {
				return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
			};
			JPoint.prototype.add = function add(e) {
				if (this.isInfinity()) return e;
				if (e.isInfinity()) return this;
				var t = e.z.redSqr();
				var r = this.z.redSqr();
				var i = this.x.redMul(t);
				var a = e.x.redMul(r);
				var o = this.y.redMul(t.redMul(e.z));
				var c = e.y.redMul(r.redMul(this.z));
				var u = i.redSub(a);
				var l = o.redSub(c);
				if (u.cmpn(0) === 0) {
					if (l.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
					else return this.dbl();
				}
				var d = u.redSqr();
				var p = d.redMul(u);
				var m = i.redMul(d);
				var g = l.redSqr().redIAdd(p).redISub(m).redISub(m);
				var v = l.redMul(m.redISub(g)).redISub(o.redMul(p));
				var y = this.z.redMul(e.z).redMul(u);
				return this.curve.jpoint(g, v, y);
			};
			JPoint.prototype.mixedAdd = function mixedAdd(e) {
				if (this.isInfinity()) return e.toJ();
				if (e.isInfinity()) return this;
				var t = this.z.redSqr();
				var r = this.x;
				var i = e.x.redMul(t);
				var a = this.y;
				var o = e.y.redMul(t).redMul(this.z);
				var c = r.redSub(i);
				var u = a.redSub(o);
				if (c.cmpn(0) === 0) {
					if (u.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
					else return this.dbl();
				}
				var l = c.redSqr();
				var d = l.redMul(c);
				var p = r.redMul(l);
				var m = u.redSqr().redIAdd(d).redISub(p).redISub(p);
				var g = u.redMul(p.redISub(m)).redISub(a.redMul(d));
				var v = this.z.redMul(c);
				return this.curve.jpoint(m, g, v);
			};
			JPoint.prototype.dblp = function dblp(e) {
				if (e === 0) return this;
				if (this.isInfinity()) return this;
				if (!e) return this.dbl();
				var t;
				if (this.curve.zeroA || this.curve.threeA) {
					var r = this;
					for (t = 0; t < e; t++) r = r.dbl();
					return r;
				}
				var i = this.curve.a;
				var a = this.curve.tinv;
				var o = this.x;
				var c = this.y;
				var u = this.z;
				var l = u.redSqr().redSqr();
				var d = c.redAdd(c);
				for (t = 0; t < e; t++) {
					var p = o.redSqr();
					var m = d.redSqr();
					var g = m.redSqr();
					var v = p.redAdd(p).redIAdd(p).redIAdd(i.redMul(l));
					var y = o.redMul(m);
					var w = v.redSqr().redISub(y.redAdd(y));
					var _ = y.redISub(w);
					var A = v.redMul(_);
					A = A.redIAdd(A).redISub(g);
					var k = d.redMul(u);
					if (t + 1 < e) l = l.redMul(g);
					o = w;
					u = k;
					d = A;
				}
				return this.curve.jpoint(o, d.redMul(a), u);
			};
			JPoint.prototype.dbl = function dbl() {
				if (this.isInfinity()) return this;
				if (this.curve.zeroA) return this._zeroDbl();
				else if (this.curve.threeA) return this._threeDbl();
				else return this._dbl();
			};
			JPoint.prototype._zeroDbl = function _zeroDbl() {
				var e;
				var t;
				var r;
				if (this.zOne) {
					var i = this.x.redSqr();
					var a = this.y.redSqr();
					var o = a.redSqr();
					var c = this.x.redAdd(a).redSqr().redISub(i).redISub(o);
					c = c.redIAdd(c);
					var u = i.redAdd(i).redIAdd(i);
					var l = u.redSqr().redISub(c).redISub(c);
					var d = o.redIAdd(o);
					d = d.redIAdd(d);
					d = d.redIAdd(d);
					e = l;
					t = u.redMul(c.redISub(l)).redISub(d);
					r = this.y.redAdd(this.y);
				} else {
					var p = this.x.redSqr();
					var m = this.y.redSqr();
					var g = m.redSqr();
					var v = this.x.redAdd(m).redSqr().redISub(p).redISub(g);
					v = v.redIAdd(v);
					var y = p.redAdd(p).redIAdd(p);
					var w = y.redSqr();
					var _ = g.redIAdd(g);
					_ = _.redIAdd(_);
					_ = _.redIAdd(_);
					e = w.redISub(v).redISub(v);
					t = y.redMul(v.redISub(e)).redISub(_);
					r = this.y.redMul(this.z);
					r = r.redIAdd(r);
				}
				return this.curve.jpoint(e, t, r);
			};
			JPoint.prototype._threeDbl = function _threeDbl() {
				var e;
				var t;
				var r;
				if (this.zOne) {
					var i = this.x.redSqr();
					var a = this.y.redSqr();
					var o = a.redSqr();
					var c = this.x.redAdd(a).redSqr().redISub(i).redISub(o);
					c = c.redIAdd(c);
					var u = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a);
					var l = u.redSqr().redISub(c).redISub(c);
					e = l;
					var d = o.redIAdd(o);
					d = d.redIAdd(d);
					d = d.redIAdd(d);
					t = u.redMul(c.redISub(l)).redISub(d);
					r = this.y.redAdd(this.y);
				} else {
					var p = this.z.redSqr();
					var m = this.y.redSqr();
					var g = this.x.redMul(m);
					var v = this.x.redSub(p).redMul(this.x.redAdd(p));
					v = v.redAdd(v).redIAdd(v);
					var y = g.redIAdd(g);
					y = y.redIAdd(y);
					var w = y.redAdd(y);
					e = v.redSqr().redISub(w);
					r = this.y.redAdd(this.z).redSqr().redISub(m).redISub(p);
					var _ = m.redSqr();
					_ = _.redIAdd(_);
					_ = _.redIAdd(_);
					_ = _.redIAdd(_);
					t = v.redMul(y.redISub(e)).redISub(_);
				}
				return this.curve.jpoint(e, t, r);
			};
			JPoint.prototype._dbl = function _dbl() {
				var e = this.curve.a;
				var t = this.x;
				var r = this.y;
				var i = this.z;
				var a = i.redSqr().redSqr();
				var o = t.redSqr();
				var c = r.redSqr();
				var u = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(a));
				var l = t.redAdd(t);
				l = l.redIAdd(l);
				var d = l.redMul(c);
				var p = u.redSqr().redISub(d.redAdd(d));
				var m = d.redISub(p);
				var g = c.redSqr();
				g = g.redIAdd(g);
				g = g.redIAdd(g);
				g = g.redIAdd(g);
				var v = u.redMul(m).redISub(g);
				var y = r.redAdd(r).redMul(i);
				return this.curve.jpoint(p, v, y);
			};
			JPoint.prototype.trpl = function trpl() {
				if (!this.curve.zeroA) return this.dbl().add(this);
				var e = this.x.redSqr();
				var t = this.y.redSqr();
				var r = this.z.redSqr();
				var i = t.redSqr();
				var a = e.redAdd(e).redIAdd(e);
				var o = a.redSqr();
				var c = this.x.redAdd(t).redSqr().redISub(e).redISub(i);
				c = c.redIAdd(c);
				c = c.redAdd(c).redIAdd(c);
				c = c.redISub(o);
				var u = c.redSqr();
				var l = i.redIAdd(i);
				l = l.redIAdd(l);
				l = l.redIAdd(l);
				l = l.redIAdd(l);
				var d = a.redIAdd(c).redSqr().redISub(o).redISub(u).redISub(l);
				var p = t.redMul(d);
				p = p.redIAdd(p);
				p = p.redIAdd(p);
				var m = this.x.redMul(u).redISub(p);
				m = m.redIAdd(m);
				m = m.redIAdd(m);
				var g = this.y.redMul(d.redMul(l.redISub(d)).redISub(c.redMul(u)));
				g = g.redIAdd(g);
				g = g.redIAdd(g);
				g = g.redIAdd(g);
				var v = this.z.redAdd(c).redSqr().redISub(r).redISub(u);
				return this.curve.jpoint(m, g, v);
			};
			JPoint.prototype.mul = function mul(e, t) {
				e = new (a())(e, t);
				return this.curve._wnafMul(this, e);
			};
			JPoint.prototype.eq = function eq(e) {
				if (e.type === 'affine') return this.eq(e.toJ());
				if (this === e) return true;
				var t = this.z.redSqr();
				var r = e.z.redSqr();
				if (this.x.redMul(r).redISub(e.x.redMul(t)).cmpn(0) !== 0) return false;
				var i = t.redMul(this.z);
				var a = r.redMul(e.z);
				return this.y.redMul(a).redISub(e.y.redMul(i)).cmpn(0) === 0;
			};
			JPoint.prototype.eqXToP = function eqXToP(e) {
				var t = this.z.redSqr();
				var r = e.toRed(this.curve.red).redMul(t);
				if (this.x.cmp(r) === 0) return true;
				var i = e.clone();
				var a = this.curve.redN.redMul(t);
				for (;;) {
					i.iadd(this.curve.n);
					if (i.cmp(this.curve.p) >= 0) return false;
					r.redIAdd(a);
					if (this.x.cmp(r) === 0) return true;
				}
			};
			JPoint.prototype.inspect = function inspect() {
				if (this.isInfinity()) return '<EC JPoint Infinity>';
				return (
					'<EC JPoint x: ' +
					this.x.toString(16, 2) +
					' y: ' +
					this.y.toString(16, 2) +
					' z: ' +
					this.z.toString(16, 2) +
					'>'
				);
			};
			JPoint.prototype.isInfinity = function isInfinity() {
				return this.z.cmpn(0) === 0;
			};
			var k = createCommonjsModule(function (e, t) {
				'use strict';
				var r = t;
				r.base = y;
				r.short = A;
				r.mont = null;
				r.edwards = null;
			});
			var N = createCommonjsModule(function (e, t) {
				'use strict';
				var r = t;
				var i = p.assert;
				function PresetCurve(e) {
					if (e.type === 'short') this.curve = new k.short(e);
					else if (e.type === 'edwards') this.curve = new k.edwards(e);
					else this.curve = new k.mont(e);
					this.g = this.curve.g;
					this.n = this.curve.n;
					this.hash = e.hash;
					i(this.g.validate(), 'Invalid curve');
					i(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
				}
				r.PresetCurve = PresetCurve;
				function defineCurve(e, t) {
					Object.defineProperty(r, e, {
						configurable: true,
						enumerable: true,
						get: function () {
							var i = new PresetCurve(t);
							Object.defineProperty(r, e, { configurable: true, enumerable: true, value: i });
							return i;
						}
					});
				}
				defineCurve('p192', {
					type: 'short',
					prime: 'p192',
					p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
					a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
					b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
					n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
					hash: c().sha256,
					gRed: false,
					g: [
						'188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
						'07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
					]
				});
				defineCurve('p224', {
					type: 'short',
					prime: 'p224',
					p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
					a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
					b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
					n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
					hash: c().sha256,
					gRed: false,
					g: [
						'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
						'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
					]
				});
				defineCurve('p256', {
					type: 'short',
					prime: null,
					p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
					a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
					b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
					n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
					hash: c().sha256,
					gRed: false,
					g: [
						'6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
						'4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
					]
				});
				defineCurve('p384', {
					type: 'short',
					prime: null,
					p:
						'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
						'fffffffe ffffffff 00000000 00000000 ffffffff',
					a:
						'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
						'fffffffe ffffffff 00000000 00000000 fffffffc',
					b:
						'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
						'5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
					n:
						'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
						'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
					hash: c().sha384,
					gRed: false,
					g: [
						'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
							'5502f25d bf55296c 3a545e38 72760ab7',
						'3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
							'0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
					]
				});
				defineCurve('p521', {
					type: 'short',
					prime: null,
					p:
						'000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
						'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
						'ffffffff ffffffff ffffffff ffffffff ffffffff',
					a:
						'000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
						'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
						'ffffffff ffffffff ffffffff ffffffff fffffffc',
					b:
						'00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
						'99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
						'3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
					n:
						'000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
						'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
						'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
					hash: c().sha512,
					gRed: false,
					g: [
						'000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
							'053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
							'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
						'00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
							'579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
							'3fad0761 353c7086 a272c240 88be9476 9fd16650'
					]
				});
				defineCurve('curve25519', {
					type: 'mont',
					prime: 'p25519',
					p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
					a: '76d06',
					b: '1',
					n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
					hash: c().sha256,
					gRed: false,
					g: ['9']
				});
				defineCurve('ed25519', {
					type: 'edwards',
					prime: 'p25519',
					p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
					a: '-1',
					c: '1',
					d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
					n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
					hash: c().sha256,
					gRed: false,
					g: [
						'216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',
						'6666666666666666666666666666666666666666666666666666666666666658'
					]
				});
				var a;
				try {
					a = null.crash();
				} catch (e) {
					a = undefined;
				}
				defineCurve('secp256k1', {
					type: 'short',
					prime: 'k256',
					p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
					a: '0',
					b: '7',
					n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
					h: '1',
					hash: c().sha256,
					beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
					lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
					basis: [
						{ a: '3086d221a7d46bcde86c90e49284eb15', b: '-e4437ed6010e88286f547fa90abfe4c3' },
						{ a: '114ca50f7a8e2f3f657c1108d9d44cfd8', b: '3086d221a7d46bcde86c90e49284eb15' }
					],
					gRed: false,
					g: [
						'79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
						'483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
						a
					]
				});
			});
			('use strict');
			function HmacDRBG(e) {
				if (!(this instanceof HmacDRBG)) return new HmacDRBG(e);
				this.hash = e.hash;
				this.predResist = !!e.predResist;
				this.outLen = this.hash.outSize;
				this.minEntropy = e.minEntropy || this.hash.hmacStrength;
				this._reseed = null;
				this.reseedInterval = null;
				this.K = null;
				this.V = null;
				var t = d.toArray(e.entropy, e.entropyEnc || 'hex');
				var r = d.toArray(e.nonce, e.nonceEnc || 'hex');
				var i = d.toArray(e.pers, e.persEnc || 'hex');
				l(
					t.length >= this.minEntropy / 8,
					'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'
				);
				this._init(t, r, i);
			}
			var T = HmacDRBG;
			HmacDRBG.prototype._init = function init(e, t, r) {
				var i = e.concat(t).concat(r);
				this.K = new Array(this.outLen / 8);
				this.V = new Array(this.outLen / 8);
				for (var a = 0; a < this.V.length; a++) {
					this.K[a] = 0;
					this.V[a] = 1;
				}
				this._update(i);
				this._reseed = 1;
				this.reseedInterval = 281474976710656;
			};
			HmacDRBG.prototype._hmac = function hmac() {
				return new (c().hmac)(this.hash, this.K);
			};
			HmacDRBG.prototype._update = function update(e) {
				var t = this._hmac().update(this.V).update([0]);
				if (e) t = t.update(e);
				this.K = t.digest();
				this.V = this._hmac().update(this.V).digest();
				if (!e) return;
				this.K = this._hmac().update(this.V).update([1]).update(e).digest();
				this.V = this._hmac().update(this.V).digest();
			};
			HmacDRBG.prototype.reseed = function reseed(e, t, r, i) {
				if (typeof t !== 'string') {
					i = r;
					r = t;
					t = null;
				}
				e = d.toArray(e, t);
				r = d.toArray(r, i);
				l(
					e.length >= this.minEntropy / 8,
					'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'
				);
				this._update(e.concat(r || []));
				this._reseed = 1;
			};
			HmacDRBG.prototype.generate = function generate(e, t, r, i) {
				if (this._reseed > this.reseedInterval) throw new Error('Reseed is required');
				if (typeof t !== 'string') {
					i = r;
					r = t;
					t = null;
				}
				if (r) {
					r = d.toArray(r, i || 'hex');
					this._update(r);
				}
				var a = [];
				while (a.length < e) {
					this.V = this._hmac().update(this.V).digest();
					a = a.concat(this.V);
				}
				var o = a.slice(0, e);
				this._update(r);
				this._reseed++;
				return d.encode(o, t);
			};
			('use strict');
			var x = p.assert;
			function KeyPair(e, t) {
				this.ec = e;
				this.priv = null;
				this.pub = null;
				if (t.priv) this._importPrivate(t.priv, t.privEnc);
				if (t.pub) this._importPublic(t.pub, t.pubEnc);
			}
			var B = KeyPair;
			KeyPair.fromPublic = function fromPublic(e, t, r) {
				if (t instanceof KeyPair) return t;
				return new KeyPair(e, { pub: t, pubEnc: r });
			};
			KeyPair.fromPrivate = function fromPrivate(e, t, r) {
				if (t instanceof KeyPair) return t;
				return new KeyPair(e, { priv: t, privEnc: r });
			};
			KeyPair.prototype.validate = function validate() {
				var e = this.getPublic();
				if (e.isInfinity()) return { result: false, reason: 'Invalid public key' };
				if (!e.validate()) return { result: false, reason: 'Public key is not a point' };
				if (!e.mul(this.ec.curve.n).isInfinity())
					return { result: false, reason: 'Public key * N != O' };
				return { result: true, reason: null };
			};
			KeyPair.prototype.getPublic = function getPublic(e, t) {
				if (typeof e === 'string') {
					t = e;
					e = null;
				}
				if (!this.pub) this.pub = this.ec.g.mul(this.priv);
				if (!t) return this.pub;
				return this.pub.encode(t, e);
			};
			KeyPair.prototype.getPrivate = function getPrivate(e) {
				if (e === 'hex') return this.priv.toString(16, 2);
				else return this.priv;
			};
			KeyPair.prototype._importPrivate = function _importPrivate(e, t) {
				this.priv = new (a())(e, t || 16);
				this.priv = this.priv.umod(this.ec.curve.n);
			};
			KeyPair.prototype._importPublic = function _importPublic(e, t) {
				if (e.x || e.y) {
					if (this.ec.curve.type === 'mont') {
						x(e.x, 'Need x coordinate');
					} else if (this.ec.curve.type === 'short' || this.ec.curve.type === 'edwards') {
						x(e.x && e.y, 'Need both x and y coordinate');
					}
					this.pub = this.ec.curve.point(e.x, e.y);
					return;
				}
				this.pub = this.ec.curve.decodePoint(e, t);
			};
			KeyPair.prototype.derive = function derive(e) {
				if (!e.validate()) {
					x(e.validate(), 'public point not validated');
				}
				return e.mul(this.priv).getX();
			};
			KeyPair.prototype.sign = function sign(e, t, r) {
				return this.ec.sign(e, this, t, r);
			};
			KeyPair.prototype.verify = function verify(e, t) {
				return this.ec.verify(e, t, this);
			};
			KeyPair.prototype.inspect = function inspect() {
				return (
					'<Key priv: ' +
					(this.priv && this.priv.toString(16, 2)) +
					' pub: ' +
					(this.pub && this.pub.inspect()) +
					' >'
				);
			};
			('use strict');
			var P = p.assert;
			function Signature(e, t) {
				if (e instanceof Signature) return e;
				if (this._importDER(e, t)) return;
				P(e.r && e.s, 'Signature without r or s');
				this.r = new (a())(e.r, 16);
				this.s = new (a())(e.s, 16);
				if (e.recoveryParam === undefined) this.recoveryParam = null;
				else this.recoveryParam = e.recoveryParam;
			}
			var M = Signature;
			function Position() {
				this.place = 0;
			}
			function getLength(e, t) {
				var r = e[t.place++];
				if (!(r & 128)) {
					return r;
				}
				var i = r & 15;
				if (i === 0 || i > 4) {
					return false;
				}
				var a = 0;
				for (var o = 0, c = t.place; o < i; o++, c++) {
					a <<= 8;
					a |= e[c];
					a >>>= 0;
				}
				if (a <= 127) {
					return false;
				}
				t.place = c;
				return a;
			}
			function rmPadding(e) {
				var t = 0;
				var r = e.length - 1;
				while (!e[t] && !(e[t + 1] & 128) && t < r) {
					t++;
				}
				if (t === 0) {
					return e;
				}
				return e.slice(t);
			}
			Signature.prototype._importDER = function _importDER(e, t) {
				e = p.toArray(e, t);
				var r = new Position();
				if (e[r.place++] !== 48) {
					return false;
				}
				var i = getLength(e, r);
				if (i === false) {
					return false;
				}
				if (i + r.place !== e.length) {
					return false;
				}
				if (e[r.place++] !== 2) {
					return false;
				}
				var o = getLength(e, r);
				if (o === false) {
					return false;
				}
				var c = e.slice(r.place, o + r.place);
				r.place += o;
				if (e[r.place++] !== 2) {
					return false;
				}
				var u = getLength(e, r);
				if (u === false) {
					return false;
				}
				if (e.length !== u + r.place) {
					return false;
				}
				var l = e.slice(r.place, u + r.place);
				if (c[0] === 0) {
					if (c[1] & 128) {
						c = c.slice(1);
					} else {
						return false;
					}
				}
				if (l[0] === 0) {
					if (l[1] & 128) {
						l = l.slice(1);
					} else {
						return false;
					}
				}
				this.r = new (a())(c);
				this.s = new (a())(l);
				this.recoveryParam = null;
				return true;
			};
			function constructLength(e, t) {
				if (t < 128) {
					e.push(t);
					return;
				}
				var r = 1 + ((Math.log(t) / Math.LN2) >>> 3);
				e.push(r | 128);
				while (--r) {
					e.push((t >>> (r << 3)) & 255);
				}
				e.push(t);
			}
			Signature.prototype.toDER = function toDER(e) {
				var t = this.r.toArray();
				var r = this.s.toArray();
				if (t[0] & 128) t = [0].concat(t);
				if (r[0] & 128) r = [0].concat(r);
				t = rmPadding(t);
				r = rmPadding(r);
				while (!r[0] && !(r[1] & 128)) {
					r = r.slice(1);
				}
				var i = [2];
				constructLength(i, t.length);
				i = i.concat(t);
				i.push(2);
				constructLength(i, r.length);
				var a = i.concat(r);
				var o = [48];
				constructLength(o, a.length);
				o = o.concat(a);
				return p.encode(o, e);
			};
			('use strict');
			var rand = function () {
				throw new Error('unsupported');
			};
			var C = p.assert;
			function EC(e) {
				if (!(this instanceof EC)) return new EC(e);
				if (typeof e === 'string') {
					C(Object.prototype.hasOwnProperty.call(N, e), 'Unknown curve ' + e);
					e = N[e];
				}
				if (e instanceof N.PresetCurve) e = { curve: e };
				this.curve = e.curve.curve;
				this.n = this.curve.n;
				this.nh = this.n.ushrn(1);
				this.g = this.curve.g;
				this.g = e.curve.g;
				this.g.precompute(e.curve.n.bitLength() + 1);
				this.hash = e.hash || e.curve.hash;
			}
			var I = EC;
			EC.prototype.keyPair = function keyPair(e) {
				return new B(this, e);
			};
			EC.prototype.keyFromPrivate = function keyFromPrivate(e, t) {
				return B.fromPrivate(this, e, t);
			};
			EC.prototype.keyFromPublic = function keyFromPublic(e, t) {
				return B.fromPublic(this, e, t);
			};
			EC.prototype.genKeyPair = function genKeyPair(e) {
				if (!e) e = {};
				var t = new T({
					hash: this.hash,
					pers: e.pers,
					persEnc: e.persEnc || 'utf8',
					entropy: e.entropy || rand(this.hash.hmacStrength),
					entropyEnc: (e.entropy && e.entropyEnc) || 'utf8',
					nonce: this.n.toArray()
				});
				var r = this.n.byteLength();
				var i = this.n.sub(new (a())(2));
				for (;;) {
					var o = new (a())(t.generate(r));
					if (o.cmp(i) > 0) continue;
					o.iaddn(1);
					return this.keyFromPrivate(o);
				}
			};
			EC.prototype._truncateToN = function _truncateToN(e, t) {
				var r = e.byteLength() * 8 - this.n.bitLength();
				if (r > 0) e = e.ushrn(r);
				if (!t && e.cmp(this.n) >= 0) return e.sub(this.n);
				else return e;
			};
			EC.prototype.sign = function sign(e, t, r, i) {
				if (typeof r === 'object') {
					i = r;
					r = null;
				}
				if (!i) i = {};
				t = this.keyFromPrivate(t, r);
				e = this._truncateToN(new (a())(e, 16));
				var o = this.n.byteLength();
				var c = t.getPrivate().toArray('be', o);
				var u = e.toArray('be', o);
				var l = new T({
					hash: this.hash,
					entropy: c,
					nonce: u,
					pers: i.pers,
					persEnc: i.persEnc || 'utf8'
				});
				var d = this.n.sub(new (a())(1));
				for (var p = 0; ; p++) {
					var m = i.k ? i.k(p) : new (a())(l.generate(this.n.byteLength()));
					m = this._truncateToN(m, true);
					if (m.cmpn(1) <= 0 || m.cmp(d) >= 0) continue;
					var g = this.g.mul(m);
					if (g.isInfinity()) continue;
					var v = g.getX();
					var y = v.umod(this.n);
					if (y.cmpn(0) === 0) continue;
					var w = m.invm(this.n).mul(y.mul(t.getPrivate()).iadd(e));
					w = w.umod(this.n);
					if (w.cmpn(0) === 0) continue;
					var _ = (g.getY().isOdd() ? 1 : 0) | (v.cmp(y) !== 0 ? 2 : 0);
					if (i.canonical && w.cmp(this.nh) > 0) {
						w = this.n.sub(w);
						_ ^= 1;
					}
					return new M({ r: y, s: w, recoveryParam: _ });
				}
			};
			EC.prototype.verify = function verify(e, t, r, i) {
				e = this._truncateToN(new (a())(e, 16));
				r = this.keyFromPublic(r, i);
				t = new M(t, 'hex');
				var o = t.r;
				var c = t.s;
				if (o.cmpn(1) < 0 || o.cmp(this.n) >= 0) return false;
				if (c.cmpn(1) < 0 || c.cmp(this.n) >= 0) return false;
				var u = c.invm(this.n);
				var l = u.mul(e).umod(this.n);
				var d = u.mul(o).umod(this.n);
				var p;
				if (!this.curve._maxwellTrick) {
					p = this.g.mulAdd(l, r.getPublic(), d);
					if (p.isInfinity()) return false;
					return p.getX().umod(this.n).cmp(o) === 0;
				}
				p = this.g.jmulAdd(l, r.getPublic(), d);
				if (p.isInfinity()) return false;
				return p.eqXToP(o);
			};
			EC.prototype.recoverPubKey = function (e, t, r, i) {
				C((3 & r) === r, 'The recovery param is more than two bits');
				t = new M(t, i);
				var o = this.n;
				var c = new (a())(e);
				var u = t.r;
				var l = t.s;
				var d = r & 1;
				var p = r >> 1;
				if (u.cmp(this.curve.p.umod(this.curve.n)) >= 0 && p)
					throw new Error('Unable to find sencond key candinate');
				if (p) u = this.curve.pointFromX(u.add(this.curve.n), d);
				else u = this.curve.pointFromX(u, d);
				var m = t.r.invm(o);
				var g = o.sub(c).mul(m).umod(o);
				var v = l.mul(m).umod(o);
				return this.g.mulAdd(g, u, v);
			};
			EC.prototype.getKeyRecoveryParam = function (e, t, r, i) {
				t = new M(t, i);
				if (t.recoveryParam !== null) return t.recoveryParam;
				for (var a = 0; a < 4; a++) {
					var o;
					try {
						o = this.recoverPubKey(e, t, a);
					} catch (e) {
						continue;
					}
					if (o.eq(r)) return a;
				}
				throw new Error('Unable to find valid recovery factor');
			};
			var O = createCommonjsModule(function (e, t) {
				'use strict';
				var r = t;
				r.version = { version: '6.5.4' }.version;
				r.utils = p;
				r.rand = function () {
					throw new Error('unsupported');
				};
				r.curve = k;
				r.curves = N;
				r.ec = I;
				r.eddsa = null;
			});
			var F = O.ec;
			var D = r(1519);
			var L = r(3116);
			var U = r(5982);
			const j = 'signing-key/5.7.0';
			const H = new U.Vy(j);
			let z = null;
			function getCurve() {
				if (!z) {
					z = new F('secp256k1');
				}
				return z;
			}
			class SigningKey {
				constructor(e) {
					(0, L.yY)(this, 'curve', 'secp256k1');
					(0, L.yY)(this, 'privateKey', (0, D.c$)(e));
					if ((0, D.cm)(this.privateKey) !== 32) {
						H.throwArgumentError('invalid private key', 'privateKey', '[[ REDACTED ]]');
					}
					const t = getCurve().keyFromPrivate((0, D.k9)(this.privateKey));
					(0, L.yY)(this, 'publicKey', '0x' + t.getPublic(false, 'hex'));
					(0, L.yY)(this, 'compressedPublicKey', '0x' + t.getPublic(true, 'hex'));
					(0, L.yY)(this, '_isSigningKey', true);
				}
				_addPoint(e) {
					const t = getCurve().keyFromPublic((0, D.k9)(this.publicKey));
					const r = getCurve().keyFromPublic((0, D.k9)(e));
					return '0x' + t.pub.add(r.pub).encodeCompressed('hex');
				}
				signDigest(e) {
					const t = getCurve().keyFromPrivate((0, D.k9)(this.privateKey));
					const r = (0, D.k9)(e);
					if (r.length !== 32) {
						H.throwArgumentError('bad digest length', 'digest', e);
					}
					const i = t.sign(r, { canonical: true });
					return (0, D.Pc)({
						recoveryParam: i.recoveryParam,
						r: (0, D.bj)('0x' + i.r.toString(16), 32),
						s: (0, D.bj)('0x' + i.s.toString(16), 32)
					});
				}
				computeSharedSecret(e) {
					const t = getCurve().keyFromPrivate((0, D.k9)(this.privateKey));
					const r = getCurve().keyFromPublic((0, D.k9)(computePublicKey(e)));
					return (0, D.bj)('0x' + t.derive(r.getPublic()).toString(16), 32);
				}
				static isSigningKey(e) {
					return !!(e && e._isSigningKey);
				}
			}
			function recoverPublicKey(e, t) {
				const r = (0, D.Pc)(t);
				const i = { r: (0, D.k9)(r.r), s: (0, D.k9)(r.s) };
				return (
					'0x' +
					getCurve()
						.recoverPubKey((0, D.k9)(e), i, r.recoveryParam)
						.encode('hex', false)
				);
			}
			function computePublicKey(e, t) {
				const r = (0, D.k9)(e);
				if (r.length === 32) {
					const e = new SigningKey(r);
					if (t) {
						return '0x' + getCurve().keyFromPrivate(r).getPublic(true, 'hex');
					}
					return e.publicKey;
				} else if (r.length === 33) {
					if (t) {
						return (0, D.c$)(r);
					}
					return '0x' + getCurve().keyFromPublic(r).getPublic(false, 'hex');
				} else if (r.length === 65) {
					if (!t) {
						return (0, D.c$)(r);
					}
					return '0x' + getCurve().keyFromPublic(r).getPublic(true, 'hex');
				}
				return H.throwArgumentError('invalid public or private key', 'key', '[REDACTED]');
			}
		},
		5250: (e, t, r) => {
			'use strict';
			r.d(t, {
				dz: () => u,
				YW: () => toUtf8Bytes,
				dg: () => toUtf8CodePoints,
				_v: () => toUtf8String
			});
			var i = r(1519);
			var a = r(5982);
			const o = 'strings/5.7.0';
			const c = new a.Vy(o);
			var u;
			(function (e) {
				e['current'] = '';
				e['NFC'] = 'NFC';
				e['NFD'] = 'NFD';
				e['NFKC'] = 'NFKC';
				e['NFKD'] = 'NFKD';
			})(u || (u = {}));
			var l;
			(function (e) {
				e['UNEXPECTED_CONTINUE'] = 'unexpected continuation byte';
				e['BAD_PREFIX'] = 'bad codepoint prefix';
				e['OVERRUN'] = 'string overrun';
				e['MISSING_CONTINUE'] = 'missing continuation byte';
				e['OUT_OF_RANGE'] = 'out of UTF-8 range';
				e['UTF16_SURROGATE'] = 'UTF-16 surrogate';
				e['OVERLONG'] = 'overlong representation';
			})(l || (l = {}));
			function errorFunc(e, t, r, i, a) {
				return c.throwArgumentError(`invalid codepoint at offset ${t}; ${e}`, 'bytes', r);
			}
			function ignoreFunc(e, t, r, i, a) {
				if (e === l.BAD_PREFIX || e === l.UNEXPECTED_CONTINUE) {
					let e = 0;
					for (let i = t + 1; i < r.length; i++) {
						if (r[i] >> 6 !== 2) {
							break;
						}
						e++;
					}
					return e;
				}
				if (e === l.OVERRUN) {
					return r.length - t - 1;
				}
				return 0;
			}
			function replaceFunc(e, t, r, i, a) {
				if (e === l.OVERLONG) {
					i.push(a);
					return 0;
				}
				i.push(65533);
				return ignoreFunc(e, t, r, i, a);
			}
			const d = Object.freeze({ error: errorFunc, ignore: ignoreFunc, replace: replaceFunc });
			function getUtf8CodePoints(e, t) {
				if (t == null) {
					t = d.error;
				}
				e = (0, i.k9)(e);
				const r = [];
				let a = 0;
				while (a < e.length) {
					const i = e[a++];
					if (i >> 7 === 0) {
						r.push(i);
						continue;
					}
					let o = null;
					let c = null;
					if ((i & 224) === 192) {
						o = 1;
						c = 127;
					} else if ((i & 240) === 224) {
						o = 2;
						c = 2047;
					} else if ((i & 248) === 240) {
						o = 3;
						c = 65535;
					} else {
						if ((i & 192) === 128) {
							a += t(l.UNEXPECTED_CONTINUE, a - 1, e, r);
						} else {
							a += t(l.BAD_PREFIX, a - 1, e, r);
						}
						continue;
					}
					if (a - 1 + o >= e.length) {
						a += t(l.OVERRUN, a - 1, e, r);
						continue;
					}
					let u = i & ((1 << (8 - o - 1)) - 1);
					for (let i = 0; i < o; i++) {
						let i = e[a];
						if ((i & 192) != 128) {
							a += t(l.MISSING_CONTINUE, a, e, r);
							u = null;
							break;
						}
						u = (u << 6) | (i & 63);
						a++;
					}
					if (u === null) {
						continue;
					}
					if (u > 1114111) {
						a += t(l.OUT_OF_RANGE, a - 1 - o, e, r, u);
						continue;
					}
					if (u >= 55296 && u <= 57343) {
						a += t(l.UTF16_SURROGATE, a - 1 - o, e, r, u);
						continue;
					}
					if (u <= c) {
						a += t(l.OVERLONG, a - 1 - o, e, r, u);
						continue;
					}
					r.push(u);
				}
				return r;
			}
			function toUtf8Bytes(e, t = u.current) {
				if (t != u.current) {
					c.checkNormalize();
					e = e.normalize(t);
				}
				let r = [];
				for (let t = 0; t < e.length; t++) {
					const i = e.charCodeAt(t);
					if (i < 128) {
						r.push(i);
					} else if (i < 2048) {
						r.push((i >> 6) | 192);
						r.push((i & 63) | 128);
					} else if ((i & 64512) == 55296) {
						t++;
						const a = e.charCodeAt(t);
						if (t >= e.length || (a & 64512) !== 56320) {
							throw new Error('invalid utf-8 string');
						}
						const o = 65536 + ((i & 1023) << 10) + (a & 1023);
						r.push((o >> 18) | 240);
						r.push(((o >> 12) & 63) | 128);
						r.push(((o >> 6) & 63) | 128);
						r.push((o & 63) | 128);
					} else {
						r.push((i >> 12) | 224);
						r.push(((i >> 6) & 63) | 128);
						r.push((i & 63) | 128);
					}
				}
				return (0, i.k9)(r);
			}
			function escapeChar(e) {
				const t = '0000' + e.toString(16);
				return '\\u' + t.substring(t.length - 4);
			}
			function _toEscapedUtf8String(e, t) {
				return (
					'"' +
					getUtf8CodePoints(e, t)
						.map((e) => {
							if (e < 256) {
								switch (e) {
									case 8:
										return '\\b';
									case 9:
										return '\\t';
									case 10:
										return '\\n';
									case 13:
										return '\\r';
									case 34:
										return '\\"';
									case 92:
										return '\\\\';
								}
								if (e >= 32 && e < 127) {
									return String.fromCharCode(e);
								}
							}
							if (e <= 65535) {
								return escapeChar(e);
							}
							e -= 65536;
							return escapeChar(((e >> 10) & 1023) + 55296) + escapeChar((e & 1023) + 56320);
						})
						.join('') +
					'"'
				);
			}
			function _toUtf8String(e) {
				return e
					.map((e) => {
						if (e <= 65535) {
							return String.fromCharCode(e);
						}
						e -= 65536;
						return String.fromCharCode(((e >> 10) & 1023) + 55296, (e & 1023) + 56320);
					})
					.join('');
			}
			function toUtf8String(e, t) {
				return _toUtf8String(getUtf8CodePoints(e, t));
			}
			function toUtf8CodePoints(e, t = u.current) {
				return getUtf8CodePoints(toUtf8Bytes(e, t));
			}
		},
		3231: (e, t, r) => {
			'use strict';
			r.d(t, {
				$2: () => accessListify,
				Kt: () => computeAddress,
				qg: () => parse,
				lK: () => serialize
			});
			var i = r(716);
			var a = r(2834);
			var o = r(1519);
			const c = null && BigNumber.from(-1);
			const u = a.gH.from(0);
			const l = null && BigNumber.from(1);
			const d = null && BigNumber.from(2);
			const p = null && BigNumber.from('1000000000000000000');
			const m =
				null &&
				BigNumber.from('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
			const g =
				null &&
				BigNumber.from('-0x8000000000000000000000000000000000000000000000000000000000000000');
			const v =
				null &&
				BigNumber.from('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
			var y = r(4781);
			var w = r(3116);
			var _ = r(8804);
			var A = r(3013);
			var k = r(5982);
			const N = 'transactions/5.7.0';
			const T = new k.Vy(N);
			var x;
			(function (e) {
				e[(e['legacy'] = 0)] = 'legacy';
				e[(e['eip2930'] = 1)] = 'eip2930';
				e[(e['eip1559'] = 2)] = 'eip1559';
			})(x || (x = {}));
			function handleAddress(e) {
				if (e === '0x') {
					return null;
				}
				return (0, i.bv)(e);
			}
			function handleNumber(e) {
				if (e === '0x') {
					return u;
				}
				return a.gH.from(e);
			}
			const B = [
				{ name: 'nonce', maxLength: 32, numeric: true },
				{ name: 'gasPrice', maxLength: 32, numeric: true },
				{ name: 'gasLimit', maxLength: 32, numeric: true },
				{ name: 'to', length: 20 },
				{ name: 'value', maxLength: 32, numeric: true },
				{ name: 'data' }
			];
			const P = {
				chainId: true,
				data: true,
				gasLimit: true,
				gasPrice: true,
				nonce: true,
				to: true,
				type: true,
				value: true
			};
			function computeAddress(e) {
				const t = (0, A.uN)(e);
				return (0, i.bv)((0, o.Ab)((0, y.S)((0, o.Ab)(t, 1)), 12));
			}
			function recoverAddress(e, t) {
				return computeAddress((0, A.jL)((0, o.k9)(e), t));
			}
			function formatNumber(e, t) {
				const r = (0, o.gr)(a.gH.from(e).toHexString());
				if (r.length > 32) {
					T.throwArgumentError('invalid length for ' + t, 'transaction:' + t, e);
				}
				return r;
			}
			function accessSetify(e, t) {
				return {
					address: (0, i.bv)(e),
					storageKeys: (t || []).map((t, r) => {
						if ((0, o.cm)(t) !== 32) {
							T.throwArgumentError('invalid access list storageKey', `accessList[${e}:${r}]`, t);
						}
						return t.toLowerCase();
					})
				};
			}
			function accessListify(e) {
				if (Array.isArray(e)) {
					return e.map((e, t) => {
						if (Array.isArray(e)) {
							if (e.length > 2) {
								T.throwArgumentError(
									'access list expected to be [ address, storageKeys[] ]',
									`value[${t}]`,
									e
								);
							}
							return accessSetify(e[0], e[1]);
						}
						return accessSetify(e.address, e.storageKeys);
					});
				}
				const t = Object.keys(e).map((t) => {
					const r = e[t].reduce((e, t) => {
						e[t] = true;
						return e;
					}, {});
					return accessSetify(t, Object.keys(r).sort());
				});
				t.sort((e, t) => e.address.localeCompare(t.address));
				return t;
			}
			function formatAccessList(e) {
				return accessListify(e).map((e) => [e.address, e.storageKeys]);
			}
			function _serializeEip1559(e, t) {
				if (e.gasPrice != null) {
					const t = a.gH.from(e.gasPrice);
					const r = a.gH.from(e.maxFeePerGas || 0);
					if (!t.eq(r)) {
						T.throwArgumentError('mismatch EIP-1559 gasPrice != maxFeePerGas', 'tx', {
							gasPrice: t,
							maxFeePerGas: r
						});
					}
				}
				const r = [
					formatNumber(e.chainId || 0, 'chainId'),
					formatNumber(e.nonce || 0, 'nonce'),
					formatNumber(e.maxPriorityFeePerGas || 0, 'maxPriorityFeePerGas'),
					formatNumber(e.maxFeePerGas || 0, 'maxFeePerGas'),
					formatNumber(e.gasLimit || 0, 'gasLimit'),
					e.to != null ? (0, i.bv)(e.to) : '0x',
					formatNumber(e.value || 0, 'value'),
					e.data || '0x',
					formatAccessList(e.accessList || [])
				];
				if (t) {
					const e = (0, o.Pc)(t);
					r.push(formatNumber(e.recoveryParam, 'recoveryParam'));
					r.push((0, o.gr)(e.r));
					r.push((0, o.gr)(e.s));
				}
				return (0, o.qn)(['0x02', _.l(r)]);
			}
			function _serializeEip2930(e, t) {
				const r = [
					formatNumber(e.chainId || 0, 'chainId'),
					formatNumber(e.nonce || 0, 'nonce'),
					formatNumber(e.gasPrice || 0, 'gasPrice'),
					formatNumber(e.gasLimit || 0, 'gasLimit'),
					e.to != null ? (0, i.bv)(e.to) : '0x',
					formatNumber(e.value || 0, 'value'),
					e.data || '0x',
					formatAccessList(e.accessList || [])
				];
				if (t) {
					const e = (0, o.Pc)(t);
					r.push(formatNumber(e.recoveryParam, 'recoveryParam'));
					r.push((0, o.gr)(e.r));
					r.push((0, o.gr)(e.s));
				}
				return (0, o.qn)(['0x01', _.l(r)]);
			}
			function _serialize(e, t) {
				(0, w.qN)(e, P);
				const r = [];
				B.forEach(function (t) {
					let i = e[t.name] || [];
					const a = {};
					if (t.numeric) {
						a.hexPad = 'left';
					}
					i = (0, o.k9)((0, o.c$)(i, a));
					if (t.length && i.length !== t.length && i.length > 0) {
						T.throwArgumentError('invalid length for ' + t.name, 'transaction:' + t.name, i);
					}
					if (t.maxLength) {
						i = (0, o.gr)(i);
						if (i.length > t.maxLength) {
							T.throwArgumentError('invalid length for ' + t.name, 'transaction:' + t.name, i);
						}
					}
					r.push((0, o.c$)(i));
				});
				let i = 0;
				if (e.chainId != null) {
					i = e.chainId;
					if (typeof i !== 'number') {
						T.throwArgumentError('invalid transaction.chainId', 'transaction', e);
					}
				} else if (t && !(0, o.f)(t) && t.v > 28) {
					i = Math.floor((t.v - 35) / 2);
				}
				if (i !== 0) {
					r.push((0, o.c$)(i));
					r.push('0x');
					r.push('0x');
				}
				if (!t) {
					return _.l(r);
				}
				const a = (0, o.Pc)(t);
				let c = 27 + a.recoveryParam;
				if (i !== 0) {
					r.pop();
					r.pop();
					r.pop();
					c += i * 2 + 8;
					if (a.v > 28 && a.v !== c) {
						T.throwArgumentError('transaction.chainId/signature.v mismatch', 'signature', t);
					}
				} else if (a.v !== c) {
					T.throwArgumentError('transaction.chainId/signature.v mismatch', 'signature', t);
				}
				r.push((0, o.c$)(c));
				r.push((0, o.gr)((0, o.k9)(a.r)));
				r.push((0, o.gr)((0, o.k9)(a.s)));
				return _.l(r);
			}
			function serialize(e, t) {
				if (e.type == null || e.type === 0) {
					if (e.accessList != null) {
						T.throwArgumentError(
							'untyped transactions do not support accessList; include type: 1',
							'transaction',
							e
						);
					}
					return _serialize(e, t);
				}
				switch (e.type) {
					case 1:
						return _serializeEip2930(e, t);
					case 2:
						return _serializeEip1559(e, t);
					default:
						break;
				}
				return T.throwError(
					`unsupported transaction type: ${e.type}`,
					k.Vy.errors.UNSUPPORTED_OPERATION,
					{ operation: 'serializeTransaction', transactionType: e.type }
				);
			}
			function _parseEipSignature(e, t, r) {
				try {
					const r = handleNumber(t[0]).toNumber();
					if (r !== 0 && r !== 1) {
						throw new Error('bad recid');
					}
					e.v = r;
				} catch (e) {
					T.throwArgumentError('invalid v for transaction type: 1', 'v', t[0]);
				}
				e.r = (0, o.bj)(t[1], 32);
				e.s = (0, o.bj)(t[2], 32);
				try {
					const t = (0, y.S)(r(e));
					e.from = recoverAddress(t, { r: e.r, s: e.s, recoveryParam: e.v });
				} catch (e) {}
			}
			function _parseEip1559(e) {
				const t = _.D(e.slice(1));
				if (t.length !== 9 && t.length !== 12) {
					T.throwArgumentError(
						'invalid component count for transaction type: 2',
						'payload',
						(0, o.c$)(e)
					);
				}
				const r = handleNumber(t[2]);
				const i = handleNumber(t[3]);
				const a = {
					type: 2,
					chainId: handleNumber(t[0]).toNumber(),
					nonce: handleNumber(t[1]).toNumber(),
					maxPriorityFeePerGas: r,
					maxFeePerGas: i,
					gasPrice: null,
					gasLimit: handleNumber(t[4]),
					to: handleAddress(t[5]),
					value: handleNumber(t[6]),
					data: t[7],
					accessList: accessListify(t[8])
				};
				if (t.length === 9) {
					return a;
				}
				a.hash = (0, y.S)(e);
				_parseEipSignature(a, t.slice(9), _serializeEip1559);
				return a;
			}
			function _parseEip2930(e) {
				const t = _.D(e.slice(1));
				if (t.length !== 8 && t.length !== 11) {
					T.throwArgumentError(
						'invalid component count for transaction type: 1',
						'payload',
						(0, o.c$)(e)
					);
				}
				const r = {
					type: 1,
					chainId: handleNumber(t[0]).toNumber(),
					nonce: handleNumber(t[1]).toNumber(),
					gasPrice: handleNumber(t[2]),
					gasLimit: handleNumber(t[3]),
					to: handleAddress(t[4]),
					value: handleNumber(t[5]),
					data: t[6],
					accessList: accessListify(t[7])
				};
				if (t.length === 8) {
					return r;
				}
				r.hash = (0, y.S)(e);
				_parseEipSignature(r, t.slice(8), _serializeEip2930);
				return r;
			}
			function _parse(e) {
				const t = _.D(e);
				if (t.length !== 9 && t.length !== 6) {
					T.throwArgumentError('invalid raw transaction', 'rawTransaction', e);
				}
				const r = {
					nonce: handleNumber(t[0]).toNumber(),
					gasPrice: handleNumber(t[1]),
					gasLimit: handleNumber(t[2]),
					to: handleAddress(t[3]),
					value: handleNumber(t[4]),
					data: t[5],
					chainId: 0
				};
				if (t.length === 6) {
					return r;
				}
				try {
					r.v = a.gH.from(t[6]).toNumber();
				} catch (e) {
					return r;
				}
				r.r = (0, o.bj)(t[7], 32);
				r.s = (0, o.bj)(t[8], 32);
				if (a.gH.from(r.r).isZero() && a.gH.from(r.s).isZero()) {
					r.chainId = r.v;
					r.v = 0;
				} else {
					r.chainId = Math.floor((r.v - 35) / 2);
					if (r.chainId < 0) {
						r.chainId = 0;
					}
					let i = r.v - 27;
					const a = t.slice(0, 6);
					if (r.chainId !== 0) {
						a.push((0, o.c$)(r.chainId));
						a.push('0x');
						a.push('0x');
						i -= r.chainId * 2 + 8;
					}
					const c = (0, y.S)(_.l(a));
					try {
						r.from = recoverAddress(c, { r: (0, o.c$)(r.r), s: (0, o.c$)(r.s), recoveryParam: i });
					} catch (e) {}
					r.hash = (0, y.S)(e);
				}
				r.type = null;
				return r;
			}
			function parse(e) {
				const t = (0, o.k9)(e);
				if (t[0] > 127) {
					return _parse(t);
				}
				switch (t[0]) {
					case 1:
						return _parseEip2930(t);
					case 2:
						return _parseEip1559(t);
					default:
						break;
				}
				return T.throwError(
					`unsupported transaction type: ${t[0]}`,
					k.Vy.errors.UNSUPPORTED_OPERATION,
					{ operation: 'parseTransaction', transactionType: t[0] }
				);
			}
		},
		8628: (e, t, r) => {
			'use strict';
			r.d(t, { x6: () => fetchJson, wt: () => poll });
			var i = r(3162);
			var a = r(1519);
			var o = r(3116);
			var c = r(5250);
			var u = r(5982);
			const l = 'web/5.7.1';
			var d =
				(undefined && undefined.__awaiter) ||
				function (e, t, r, i) {
					function adopt(e) {
						return e instanceof r
							? e
							: new r(function (t) {
									t(e);
								});
					}
					return new (r || (r = Promise))(function (r, a) {
						function fulfilled(e) {
							try {
								step(i.next(e));
							} catch (e) {
								a(e);
							}
						}
						function rejected(e) {
							try {
								step(i['throw'](e));
							} catch (e) {
								a(e);
							}
						}
						function step(e) {
							e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected);
						}
						step((i = i.apply(e, t || [])).next());
					});
				};
			function getUrl(e, t) {
				return d(this, void 0, void 0, function* () {
					if (t == null) {
						t = {};
					}
					const r = {
						method: t.method || 'GET',
						headers: t.headers || {},
						body: t.body || undefined
					};
					if (t.skipFetchSetup !== true) {
						r.mode = 'cors';
						r.cache = 'no-cache';
						r.credentials = 'same-origin';
						r.redirect = 'follow';
						r.referrer = 'client';
					}
					if (t.fetchOptions != null) {
						const e = t.fetchOptions;
						if (e.mode) {
							r.mode = e.mode;
						}
						if (e.cache) {
							r.cache = e.cache;
						}
						if (e.credentials) {
							r.credentials = e.credentials;
						}
						if (e.redirect) {
							r.redirect = e.redirect;
						}
						if (e.referrer) {
							r.referrer = e.referrer;
						}
					}
					const i = yield fetch(e, r);
					const o = yield i.arrayBuffer();
					const c = {};
					if (i.headers.forEach) {
						i.headers.forEach((e, t) => {
							c[t.toLowerCase()] = e;
						});
					} else {
						i.headers.keys().forEach((e) => {
							c[e.toLowerCase()] = i.headers.get(e);
						});
					}
					return {
						headers: c,
						statusCode: i.status,
						statusMessage: i.statusText,
						body: (0, a.k9)(new Uint8Array(o))
					};
				});
			}
			var p =
				(undefined && undefined.__awaiter) ||
				function (e, t, r, i) {
					function adopt(e) {
						return e instanceof r
							? e
							: new r(function (t) {
									t(e);
								});
					}
					return new (r || (r = Promise))(function (r, a) {
						function fulfilled(e) {
							try {
								step(i.next(e));
							} catch (e) {
								a(e);
							}
						}
						function rejected(e) {
							try {
								step(i['throw'](e));
							} catch (e) {
								a(e);
							}
						}
						function step(e) {
							e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected);
						}
						step((i = i.apply(e, t || [])).next());
					});
				};
			const m = new u.Vy(l);
			function staller(e) {
				return new Promise((t) => {
					setTimeout(t, e);
				});
			}
			function bodyify(e, t) {
				if (e == null) {
					return null;
				}
				if (typeof e === 'string') {
					return e;
				}
				if ((0, a.f)(e)) {
					if (t && (t.split('/')[0] === 'text' || t.split(';')[0].trim() === 'application/json')) {
						try {
							return (0, c._v)(e);
						} catch (e) {}
					}
					return (0, a.c$)(e);
				}
				return e;
			}
			function unpercent(e) {
				return (0, c.YW)(
					e.replace(/%([0-9a-f][0-9a-f])/gi, (e, t) => String.fromCharCode(parseInt(t, 16)))
				);
			}
			function _fetchData(e, t, r) {
				const a = typeof e === 'object' && e.throttleLimit != null ? e.throttleLimit : 12;
				m.assertArgument(
					a > 0 && a % 1 === 0,
					'invalid connection throttle limit',
					'connection.throttleLimit',
					a
				);
				const l = typeof e === 'object' ? e.throttleCallback : null;
				const d =
					typeof e === 'object' && typeof e.throttleSlotInterval === 'number'
						? e.throttleSlotInterval
						: 100;
				m.assertArgument(
					d > 0 && d % 1 === 0,
					'invalid connection throttle slot interval',
					'connection.throttleSlotInterval',
					d
				);
				const g = typeof e === 'object' ? !!e.errorPassThrough : false;
				const v = {};
				let y = null;
				const w = { method: 'GET' };
				let _ = false;
				let A = 2 * 60 * 1e3;
				if (typeof e === 'string') {
					y = e;
				} else if (typeof e === 'object') {
					if (e == null || e.url == null) {
						m.throwArgumentError('missing URL', 'connection.url', e);
					}
					y = e.url;
					if (typeof e.timeout === 'number' && e.timeout > 0) {
						A = e.timeout;
					}
					if (e.headers) {
						for (const t in e.headers) {
							v[t.toLowerCase()] = { key: t, value: String(e.headers[t]) };
							if (['if-none-match', 'if-modified-since'].indexOf(t.toLowerCase()) >= 0) {
								_ = true;
							}
						}
					}
					w.allowGzip = !!e.allowGzip;
					if (e.user != null && e.password != null) {
						if (y.substring(0, 6) !== 'https:' && e.allowInsecureAuthentication !== true) {
							m.throwError(
								'basic authentication requires a secure https url',
								u.Vy.errors.INVALID_ARGUMENT,
								{ argument: 'url', url: y, user: e.user, password: '[REDACTED]' }
							);
						}
						const t = e.user + ':' + e.password;
						v['authorization'] = { key: 'Authorization', value: 'Basic ' + (0, i.l)((0, c.YW)(t)) };
					}
					if (e.skipFetchSetup != null) {
						w.skipFetchSetup = !!e.skipFetchSetup;
					}
					if (e.fetchOptions != null) {
						w.fetchOptions = (0, o.Ic)(e.fetchOptions);
					}
				}
				const k = new RegExp('^data:([^;:]*)?(;base64)?,(.*)$', 'i');
				const N = y ? y.match(k) : null;
				if (N) {
					try {
						const e = {
							statusCode: 200,
							statusMessage: 'OK',
							headers: { 'content-type': N[1] || 'text/plain' },
							body: N[2] ? (0, i.D)(N[3]) : unpercent(N[3])
						};
						let t = e.body;
						if (r) {
							t = r(e.body, e);
						}
						return Promise.resolve(t);
					} catch (e) {
						m.throwError('processing response error', u.Vy.errors.SERVER_ERROR, {
							body: bodyify(N[1], N[2]),
							error: e,
							requestBody: null,
							requestMethod: 'GET',
							url: y
						});
					}
				}
				if (t) {
					w.method = 'POST';
					w.body = t;
					if (v['content-type'] == null) {
						v['content-type'] = { key: 'Content-Type', value: 'application/octet-stream' };
					}
					if (v['content-length'] == null) {
						v['content-length'] = { key: 'Content-Length', value: String(t.length) };
					}
				}
				const T = {};
				Object.keys(v).forEach((e) => {
					const t = v[e];
					T[t.key] = t.value;
				});
				w.headers = T;
				const x = (function () {
					let e = null;
					const t = new Promise(function (t, r) {
						if (A) {
							e = setTimeout(() => {
								if (e == null) {
									return;
								}
								e = null;
								r(
									m.makeError('timeout', u.Vy.errors.TIMEOUT, {
										requestBody: bodyify(w.body, T['content-type']),
										requestMethod: w.method,
										timeout: A,
										url: y
									})
								);
							}, A);
						}
					});
					const cancel = function () {
						if (e == null) {
							return;
						}
						clearTimeout(e);
						e = null;
					};
					return { promise: t, cancel };
				})();
				const B = (function () {
					return p(this, void 0, void 0, function* () {
						for (let e = 0; e < a; e++) {
							let t = null;
							try {
								t = yield getUrl(y, w);
								if (e < a) {
									if (t.statusCode === 301 || t.statusCode === 302) {
										const e = t.headers.location || '';
										if (w.method === 'GET' && e.match(/^https:/)) {
											y = t.headers.location;
											continue;
										}
									} else if (t.statusCode === 429) {
										let r = true;
										if (l) {
											r = yield l(e, y);
										}
										if (r) {
											let r = 0;
											const i = t.headers['retry-after'];
											if (typeof i === 'string' && i.match(/^[1-9][0-9]*$/)) {
												r = parseInt(i) * 1e3;
											} else {
												r = d * parseInt(String(Math.random() * Math.pow(2, e)));
											}
											yield staller(r);
											continue;
										}
									}
								}
							} catch (e) {
								t = e.response;
								if (t == null) {
									x.cancel();
									m.throwError('missing response', u.Vy.errors.SERVER_ERROR, {
										requestBody: bodyify(w.body, T['content-type']),
										requestMethod: w.method,
										serverError: e,
										url: y
									});
								}
							}
							let i = t.body;
							if (_ && t.statusCode === 304) {
								i = null;
							} else if (!g && (t.statusCode < 200 || t.statusCode >= 300)) {
								x.cancel();
								m.throwError('bad response', u.Vy.errors.SERVER_ERROR, {
									status: t.statusCode,
									headers: t.headers,
									body: bodyify(i, t.headers ? t.headers['content-type'] : null),
									requestBody: bodyify(w.body, T['content-type']),
									requestMethod: w.method,
									url: y
								});
							}
							if (r) {
								try {
									const e = yield r(i, t);
									x.cancel();
									return e;
								} catch (r) {
									if (r.throttleRetry && e < a) {
										let t = true;
										if (l) {
											t = yield l(e, y);
										}
										if (t) {
											const t = d * parseInt(String(Math.random() * Math.pow(2, e)));
											yield staller(t);
											continue;
										}
									}
									x.cancel();
									m.throwError('processing response error', u.Vy.errors.SERVER_ERROR, {
										body: bodyify(i, t.headers ? t.headers['content-type'] : null),
										error: r,
										requestBody: bodyify(w.body, T['content-type']),
										requestMethod: w.method,
										url: y
									});
								}
							}
							x.cancel();
							return i;
						}
						return m.throwError('failed response', u.Vy.errors.SERVER_ERROR, {
							requestBody: bodyify(w.body, T['content-type']),
							requestMethod: w.method,
							url: y
						});
					});
				})();
				return Promise.race([x.promise, B]);
			}
			function fetchJson(e, t, r) {
				let processJsonFunc = (e, t) => {
					let i = null;
					if (e != null) {
						try {
							i = JSON.parse((0, c._v)(e));
						} catch (t) {
							m.throwError('invalid JSON', u.Vy.errors.SERVER_ERROR, { body: e, error: t });
						}
					}
					if (r) {
						i = r(i, t);
					}
					return i;
				};
				let i = null;
				if (t != null) {
					i = (0, c.YW)(t);
					const r = typeof e === 'string' ? { url: e } : (0, o.Ic)(e);
					if (r.headers) {
						const e =
							Object.keys(r.headers).filter((e) => e.toLowerCase() === 'content-type').length !== 0;
						if (!e) {
							r.headers = (0, o.Ic)(r.headers);
							r.headers['content-type'] = 'application/json';
						}
					} else {
						r.headers = { 'content-type': 'application/json' };
					}
					e = r;
				}
				return _fetchData(e, i, processJsonFunc);
			}
			function poll(e, t) {
				if (!t) {
					t = {};
				}
				t = (0, o.Ic)(t);
				if (t.floor == null) {
					t.floor = 0;
				}
				if (t.ceiling == null) {
					t.ceiling = 1e4;
				}
				if (t.interval == null) {
					t.interval = 250;
				}
				return new Promise(function (r, i) {
					let a = null;
					let o = false;
					const cancel = () => {
						if (o) {
							return false;
						}
						o = true;
						if (a) {
							clearTimeout(a);
						}
						return true;
					};
					if (t.timeout) {
						a = setTimeout(() => {
							if (cancel()) {
								i(new Error('timeout'));
							}
						}, t.timeout);
					}
					const c = t.retryLimit;
					let u = 0;
					function check() {
						return e().then(
							function (e) {
								if (e !== undefined) {
									if (cancel()) {
										r(e);
									}
								} else if (t.oncePoll) {
									t.oncePoll.once('poll', check);
								} else if (t.onceBlock) {
									t.onceBlock.once('block', check);
								} else if (!o) {
									u++;
									if (u > c) {
										if (cancel()) {
											i(new Error('retry limit reached'));
										}
										return;
									}
									let e = t.interval * parseInt(String(Math.random() * Math.pow(2, u)));
									if (e < t.floor) {
										e = t.floor;
									}
									if (e > t.ceiling) {
										e = t.ceiling;
									}
									setTimeout(check, e);
								}
								return null;
							},
							function (e) {
								if (cancel()) {
									i(e);
								}
							}
						);
					}
					check();
				});
			}
		},
		6139: function (e) {
			'use strict';
			(function (t) {
				function checkInt(e) {
					return parseInt(e) === e;
				}
				function checkInts(e) {
					if (!checkInt(e.length)) {
						return false;
					}
					for (var t = 0; t < e.length; t++) {
						if (!checkInt(e[t]) || e[t] < 0 || e[t] > 255) {
							return false;
						}
					}
					return true;
				}
				function coerceArray(e, t) {
					if (e.buffer && ArrayBuffer.isView(e) && e.name === 'Uint8Array') {
						if (t) {
							if (e.slice) {
								e = e.slice();
							} else {
								e = Array.prototype.slice.call(e);
							}
						}
						return e;
					}
					if (Array.isArray(e)) {
						if (!checkInts(e)) {
							throw new Error('Array contains invalid value: ' + e);
						}
						return new Uint8Array(e);
					}
					if (checkInt(e.length) && checkInts(e)) {
						return new Uint8Array(e);
					}
					throw new Error('unsupported array-like object');
				}
				function createArray(e) {
					return new Uint8Array(e);
				}
				function copyArray(e, t, r, i, a) {
					if (i != null || a != null) {
						if (e.slice) {
							e = e.slice(i, a);
						} else {
							e = Array.prototype.slice.call(e, i, a);
						}
					}
					t.set(e, r);
				}
				var r = (function () {
					function toBytes(e) {
						var t = [],
							r = 0;
						e = encodeURI(e);
						while (r < e.length) {
							var i = e.charCodeAt(r++);
							if (i === 37) {
								t.push(parseInt(e.substr(r, 2), 16));
								r += 2;
							} else {
								t.push(i);
							}
						}
						return coerceArray(t);
					}
					function fromBytes(e) {
						var t = [],
							r = 0;
						while (r < e.length) {
							var i = e[r];
							if (i < 128) {
								t.push(String.fromCharCode(i));
								r++;
							} else if (i > 191 && i < 224) {
								t.push(String.fromCharCode(((i & 31) << 6) | (e[r + 1] & 63)));
								r += 2;
							} else {
								t.push(
									String.fromCharCode(((i & 15) << 12) | ((e[r + 1] & 63) << 6) | (e[r + 2] & 63))
								);
								r += 3;
							}
						}
						return t.join('');
					}
					return { toBytes, fromBytes };
				})();
				var i = (function () {
					function toBytes(e) {
						var t = [];
						for (var r = 0; r < e.length; r += 2) {
							t.push(parseInt(e.substr(r, 2), 16));
						}
						return t;
					}
					var e = '0123456789abcdef';
					function fromBytes(t) {
						var r = [];
						for (var i = 0; i < t.length; i++) {
							var a = t[i];
							r.push(e[(a & 240) >> 4] + e[a & 15]);
						}
						return r.join('');
					}
					return { toBytes, fromBytes };
				})();
				var a = { 16: 10, 24: 12, 32: 14 };
				var o = [
					1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151,
					53, 106, 212, 179, 125, 250, 239, 197, 145
				];
				var c = [
					99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201,
					125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63,
					247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18,
					128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227,
					47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239,
					170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157,
					56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196,
					167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222,
					94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231,
					200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46,
					28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246,
					14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30,
					135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176,
					84, 187, 22
				];
				var u = [
					82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57,
					130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194,
					35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91,
					162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93,
					101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132,
					144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143,
					202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234,
					151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249,
					55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24,
					190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31,
					221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25,
					181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176,
					200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99,
					85, 33, 12, 125
				];
				var l = [
					3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041,
					2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474,
					1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645,
					2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738,
					597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774,
					1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420,
					3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908,
					2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577,
					605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367,
					302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398,
					1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582,
					1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647,
					2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798,
					2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006,
					2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454,
					4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438,
					2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503,
					2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685,
					2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436,
					773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063,
					840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718,
					1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540,
					2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070,
					336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046,
					1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010,
					2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840,
					3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377,
					268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505,
					1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021,
					1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018,
					2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737,
					1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195,
					731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754,
					361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671,
					1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480,
					2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862,
					739644986
				];
				var d = [
					2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751,
					1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439,
					3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890,
					3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503,
					3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059,
					1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525,
					886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908,
					1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866,
					151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098,
					2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638,
					4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057,
					1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264,
					535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953,
					3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498,
					384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337,
					100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137,
					4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005,
					3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083,
					1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207,
					3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052,
					3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340,
					1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216,
					1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026,
					1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170,
					1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833,
					852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022,
					3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810,
					3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988,
					4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327,
					3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421,
					2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407,
					3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800,
					3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267,
					574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103,
					2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482,
					3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068,
					3597515707, 975967766
				];
				var p = [
					1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791,
					3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519,
					2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690,
					1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063,
					2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779,
					644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325,
					3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348,
					3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927,
					305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517,
					152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178,
					2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067,
					795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412,
					2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938,
					1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931,
					1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674,
					2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323,
					1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668,
					3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890,
					3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916,
					389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613,
					422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458,
					712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740,
					3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090,
					169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131,
					2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455,
					3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425,
					1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822,
					135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470,
					3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131,
					3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478,
					1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887,
					3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160,
					2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707,
					505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023,
					2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242,
					1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308,
					3151392187, 372911126
				];
				var m = [
					1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006,
					3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949,
					2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615,
					1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573,
					2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149,
					640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625,
					3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088,
					3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582,
					303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922,
					151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788,
					2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797,
					791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667,
					2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628,
					1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621,
					1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044,
					2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693,
					1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563,
					3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015,
					3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496,
					387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258,
					421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748,
					707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440,
					3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700,
					168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021,
					2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725,
					3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505,
					1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567,
					134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615,
					3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126,
					3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428,
					1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342,
					3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595,
					2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197,
					505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093,
					2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452,
					1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848,
					3149649517, 370555436
				];
				var g = [
					1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851,
					1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247,
					641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266,
					2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138,
					3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195,
					666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074,
					2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496,
					2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410,
					3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356,
					2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135,
					3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634,
					1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621,
					1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127,
					2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0,
					159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415,
					168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058,
					463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213,
					1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501,
					2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500,
					2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808,
					2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459,
					226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396,
					2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334,
					2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195,
					1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924,
					1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377,
					1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502,
					3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144,
					899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591,
					2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715,
					1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798,
					3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414,
					3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575,
					404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769,
					3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257,
					967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108,
					3501741890
				];
				var v = [
					1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216,
					2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987,
					2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101,
					310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033,
					768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710,
					3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529,
					1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576,
					428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675,
					129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122,
					1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694,
					533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980,
					2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461,
					3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947,
					2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703,
					3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720,
					507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535,
					3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114,
					3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769,
					2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171,
					878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309,
					1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239,
					4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148,
					3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778,
					915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554,
					2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200,
					2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243,
					164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751,
					3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259,
					818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336,
					4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780,
					3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516,
					788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060,
					2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823,
					1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891,
					2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897,
					1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342,
					1950903388, 1120974935
				];
				var y = [
					2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946,
					59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562,
					1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311,
					4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298,
					2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3,
					1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914,
					861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376,
					4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645,
					671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107,
					2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749,
					1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475,
					4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286,
					2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952,
					2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938,
					516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165,
					3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202,
					3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594,
					3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150,
					2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354,
					1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881,
					2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934,
					821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233,
					2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178,
					188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104,
					3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285,
					2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443,
					2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636,
					3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639,
					2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196,
					3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910,
					3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831,
					1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225,
					344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018,
					1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916,
					4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572,
					2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922,
					1551124588, 1463996600
				];
				var w = [
					4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116,
					3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702,
					1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793,
					1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988,
					1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143,
					3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559,
					1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055,
					3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170,
					3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866,
					2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668,
					4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261,
					562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348,
					1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919,
					425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802,
					292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162,
					1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675,
					3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620,
					454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655,
					2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795,
					600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204,
					1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325,
					3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424,
					2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222,
					2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908,
					2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503,
					621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662,
					2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714,
					1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869,
					1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871,
					2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780,
					740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011,
					3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571,
					2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736,
					3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577,
					607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809,
					213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480
				];
				var _ = [
					0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849,
					1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698,
					1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327,
					3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396,
					2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702,
					3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029,
					3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584,
					666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064,
					1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766,
					2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455,
					3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228,
					4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265,
					1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065,
					429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145,
					1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864,
					1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971,
					2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182,
					4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591,
					1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150,
					832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190,
					2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733,
					2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648,
					4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160,
					2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201,
					3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410,
					1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463,
					371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234,
					4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433,
					2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960,
					202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152,
					2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843,
					1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808,
					496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277,
					1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502,
					3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495,
					2673705150, 2438237621, 2203032232, 2370213795
				];
				var A = [
					0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259,
					1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518,
					1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937,
					2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036,
					3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132,
					1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569,
					1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113,
					3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734,
					2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181,
					4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110,
					2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523,
					2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980,
					2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980,
					605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690,
					2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769,
					4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276,
					545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516,
					2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615,
					3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226,
					2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425,
					1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268,
					1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900,
					788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216,
					3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061,
					4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590,
					272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035,
					2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114,
					401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242,
					1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327,
					3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652,
					3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473,
					3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517,
					1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917,
					409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392,
					3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155,
					3198115200, 3046200461, 2827177882, 2743944855
				];
				var k = [
					0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639,
					1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278,
					1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237,
					4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556,
					2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312,
					2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769,
					3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674,
					1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867,
					244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806,
					1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145,
					95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665,
					3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304,
					2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475,
					4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185,
					4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854,
					2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631,
					287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892,
					1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356,
					3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515,
					2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082,
					2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898,
					695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833,
					1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835,
					1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051,
					821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260,
					2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885,
					3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539,
					2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018,
					3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005,
					1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572,
					1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868,
					752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663,
					793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892,
					1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597,
					3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290,
					2159976285, 2377486676, 2594734927, 2544078150
				];
				var N = [
					0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954,
					1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908,
					2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582,
					2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816,
					4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417,
					529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577,
					1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143,
					2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029,
					4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061,
					2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655,
					1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535,
					3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569,
					3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395,
					2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110,
					1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902,
					679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204,
					4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026,
					2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295,
					4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681,
					2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675,
					2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413,
					1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885,
					188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116,
					3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786,
					2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400,
					1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990,
					349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232,
					2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002,
					3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692,
					57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068,
					1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966,
					2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243,
					2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577,
					3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689,
					133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495,
					1418573201, 1335535747, 1184342925
				];
				function convertToInt32(e) {
					var t = [];
					for (var r = 0; r < e.length; r += 4) {
						t.push((e[r] << 24) | (e[r + 1] << 16) | (e[r + 2] << 8) | e[r + 3]);
					}
					return t;
				}
				var AES = function (e) {
					if (!(this instanceof AES)) {
						throw Error('AES must be instanitated with `new`');
					}
					Object.defineProperty(this, 'key', { value: coerceArray(e, true) });
					this._prepare();
				};
				AES.prototype._prepare = function () {
					var e = a[this.key.length];
					if (e == null) {
						throw new Error('invalid key size (must be 16, 24 or 32 bytes)');
					}
					this._Ke = [];
					this._Kd = [];
					for (var t = 0; t <= e; t++) {
						this._Ke.push([0, 0, 0, 0]);
						this._Kd.push([0, 0, 0, 0]);
					}
					var r = (e + 1) * 4;
					var i = this.key.length / 4;
					var u = convertToInt32(this.key);
					var l;
					for (var t = 0; t < i; t++) {
						l = t >> 2;
						this._Ke[l][t % 4] = u[t];
						this._Kd[e - l][t % 4] = u[t];
					}
					var d = 0;
					var p = i,
						m;
					while (p < r) {
						m = u[i - 1];
						u[0] ^=
							(c[(m >> 16) & 255] << 24) ^
							(c[(m >> 8) & 255] << 16) ^
							(c[m & 255] << 8) ^
							c[(m >> 24) & 255] ^
							(o[d] << 24);
						d += 1;
						if (i != 8) {
							for (var t = 1; t < i; t++) {
								u[t] ^= u[t - 1];
							}
						} else {
							for (var t = 1; t < i / 2; t++) {
								u[t] ^= u[t - 1];
							}
							m = u[i / 2 - 1];
							u[i / 2] ^=
								c[m & 255] ^
								(c[(m >> 8) & 255] << 8) ^
								(c[(m >> 16) & 255] << 16) ^
								(c[(m >> 24) & 255] << 24);
							for (var t = i / 2 + 1; t < i; t++) {
								u[t] ^= u[t - 1];
							}
						}
						var t = 0,
							g,
							v;
						while (t < i && p < r) {
							g = p >> 2;
							v = p % 4;
							this._Ke[g][v] = u[t];
							this._Kd[e - g][v] = u[t++];
							p++;
						}
					}
					for (var g = 1; g < e; g++) {
						for (var v = 0; v < 4; v++) {
							m = this._Kd[g][v];
							this._Kd[g][v] =
								_[(m >> 24) & 255] ^ A[(m >> 16) & 255] ^ k[(m >> 8) & 255] ^ N[m & 255];
						}
					}
				};
				AES.prototype.encrypt = function (e) {
					if (e.length != 16) {
						throw new Error('invalid plaintext size (must be 16 bytes)');
					}
					var t = this._Ke.length - 1;
					var r = [0, 0, 0, 0];
					var i = convertToInt32(e);
					for (var a = 0; a < 4; a++) {
						i[a] ^= this._Ke[0][a];
					}
					for (var o = 1; o < t; o++) {
						for (var a = 0; a < 4; a++) {
							r[a] =
								l[(i[a] >> 24) & 255] ^
								d[(i[(a + 1) % 4] >> 16) & 255] ^
								p[(i[(a + 2) % 4] >> 8) & 255] ^
								m[i[(a + 3) % 4] & 255] ^
								this._Ke[o][a];
						}
						i = r.slice();
					}
					var u = createArray(16),
						g;
					for (var a = 0; a < 4; a++) {
						g = this._Ke[t][a];
						u[4 * a] = (c[(i[a] >> 24) & 255] ^ (g >> 24)) & 255;
						u[4 * a + 1] = (c[(i[(a + 1) % 4] >> 16) & 255] ^ (g >> 16)) & 255;
						u[4 * a + 2] = (c[(i[(a + 2) % 4] >> 8) & 255] ^ (g >> 8)) & 255;
						u[4 * a + 3] = (c[i[(a + 3) % 4] & 255] ^ g) & 255;
					}
					return u;
				};
				AES.prototype.decrypt = function (e) {
					if (e.length != 16) {
						throw new Error('invalid ciphertext size (must be 16 bytes)');
					}
					var t = this._Kd.length - 1;
					var r = [0, 0, 0, 0];
					var i = convertToInt32(e);
					for (var a = 0; a < 4; a++) {
						i[a] ^= this._Kd[0][a];
					}
					for (var o = 1; o < t; o++) {
						for (var a = 0; a < 4; a++) {
							r[a] =
								g[(i[a] >> 24) & 255] ^
								v[(i[(a + 3) % 4] >> 16) & 255] ^
								y[(i[(a + 2) % 4] >> 8) & 255] ^
								w[i[(a + 1) % 4] & 255] ^
								this._Kd[o][a];
						}
						i = r.slice();
					}
					var c = createArray(16),
						l;
					for (var a = 0; a < 4; a++) {
						l = this._Kd[t][a];
						c[4 * a] = (u[(i[a] >> 24) & 255] ^ (l >> 24)) & 255;
						c[4 * a + 1] = (u[(i[(a + 3) % 4] >> 16) & 255] ^ (l >> 16)) & 255;
						c[4 * a + 2] = (u[(i[(a + 2) % 4] >> 8) & 255] ^ (l >> 8)) & 255;
						c[4 * a + 3] = (u[i[(a + 1) % 4] & 255] ^ l) & 255;
					}
					return c;
				};
				var ModeOfOperationECB = function (e) {
					if (!(this instanceof ModeOfOperationECB)) {
						throw Error('AES must be instanitated with `new`');
					}
					this.description = 'Electronic Code Block';
					this.name = 'ecb';
					this._aes = new AES(e);
				};
				ModeOfOperationECB.prototype.encrypt = function (e) {
					e = coerceArray(e);
					if (e.length % 16 !== 0) {
						throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
					}
					var t = createArray(e.length);
					var r = createArray(16);
					for (var i = 0; i < e.length; i += 16) {
						copyArray(e, r, 0, i, i + 16);
						r = this._aes.encrypt(r);
						copyArray(r, t, i);
					}
					return t;
				};
				ModeOfOperationECB.prototype.decrypt = function (e) {
					e = coerceArray(e);
					if (e.length % 16 !== 0) {
						throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
					}
					var t = createArray(e.length);
					var r = createArray(16);
					for (var i = 0; i < e.length; i += 16) {
						copyArray(e, r, 0, i, i + 16);
						r = this._aes.decrypt(r);
						copyArray(r, t, i);
					}
					return t;
				};
				var ModeOfOperationCBC = function (e, t) {
					if (!(this instanceof ModeOfOperationCBC)) {
						throw Error('AES must be instanitated with `new`');
					}
					this.description = 'Cipher Block Chaining';
					this.name = 'cbc';
					if (!t) {
						t = createArray(16);
					} else if (t.length != 16) {
						throw new Error('invalid initialation vector size (must be 16 bytes)');
					}
					this._lastCipherblock = coerceArray(t, true);
					this._aes = new AES(e);
				};
				ModeOfOperationCBC.prototype.encrypt = function (e) {
					e = coerceArray(e);
					if (e.length % 16 !== 0) {
						throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
					}
					var t = createArray(e.length);
					var r = createArray(16);
					for (var i = 0; i < e.length; i += 16) {
						copyArray(e, r, 0, i, i + 16);
						for (var a = 0; a < 16; a++) {
							r[a] ^= this._lastCipherblock[a];
						}
						this._lastCipherblock = this._aes.encrypt(r);
						copyArray(this._lastCipherblock, t, i);
					}
					return t;
				};
				ModeOfOperationCBC.prototype.decrypt = function (e) {
					e = coerceArray(e);
					if (e.length % 16 !== 0) {
						throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
					}
					var t = createArray(e.length);
					var r = createArray(16);
					for (var i = 0; i < e.length; i += 16) {
						copyArray(e, r, 0, i, i + 16);
						r = this._aes.decrypt(r);
						for (var a = 0; a < 16; a++) {
							t[i + a] = r[a] ^ this._lastCipherblock[a];
						}
						copyArray(e, this._lastCipherblock, 0, i, i + 16);
					}
					return t;
				};
				var ModeOfOperationCFB = function (e, t, r) {
					if (!(this instanceof ModeOfOperationCFB)) {
						throw Error('AES must be instanitated with `new`');
					}
					this.description = 'Cipher Feedback';
					this.name = 'cfb';
					if (!t) {
						t = createArray(16);
					} else if (t.length != 16) {
						throw new Error('invalid initialation vector size (must be 16 size)');
					}
					if (!r) {
						r = 1;
					}
					this.segmentSize = r;
					this._shiftRegister = coerceArray(t, true);
					this._aes = new AES(e);
				};
				ModeOfOperationCFB.prototype.encrypt = function (e) {
					if (e.length % this.segmentSize != 0) {
						throw new Error('invalid plaintext size (must be segmentSize bytes)');
					}
					var t = coerceArray(e, true);
					var r;
					for (var i = 0; i < t.length; i += this.segmentSize) {
						r = this._aes.encrypt(this._shiftRegister);
						for (var a = 0; a < this.segmentSize; a++) {
							t[i + a] ^= r[a];
						}
						copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
						copyArray(t, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
					}
					return t;
				};
				ModeOfOperationCFB.prototype.decrypt = function (e) {
					if (e.length % this.segmentSize != 0) {
						throw new Error('invalid ciphertext size (must be segmentSize bytes)');
					}
					var t = coerceArray(e, true);
					var r;
					for (var i = 0; i < t.length; i += this.segmentSize) {
						r = this._aes.encrypt(this._shiftRegister);
						for (var a = 0; a < this.segmentSize; a++) {
							t[i + a] ^= r[a];
						}
						copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
						copyArray(e, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
					}
					return t;
				};
				var ModeOfOperationOFB = function (e, t) {
					if (!(this instanceof ModeOfOperationOFB)) {
						throw Error('AES must be instanitated with `new`');
					}
					this.description = 'Output Feedback';
					this.name = 'ofb';
					if (!t) {
						t = createArray(16);
					} else if (t.length != 16) {
						throw new Error('invalid initialation vector size (must be 16 bytes)');
					}
					this._lastPrecipher = coerceArray(t, true);
					this._lastPrecipherIndex = 16;
					this._aes = new AES(e);
				};
				ModeOfOperationOFB.prototype.encrypt = function (e) {
					var t = coerceArray(e, true);
					for (var r = 0; r < t.length; r++) {
						if (this._lastPrecipherIndex === 16) {
							this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
							this._lastPrecipherIndex = 0;
						}
						t[r] ^= this._lastPrecipher[this._lastPrecipherIndex++];
					}
					return t;
				};
				ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
				var Counter = function (e) {
					if (!(this instanceof Counter)) {
						throw Error('Counter must be instanitated with `new`');
					}
					if (e !== 0 && !e) {
						e = 1;
					}
					if (typeof e === 'number') {
						this._counter = createArray(16);
						this.setValue(e);
					} else {
						this.setBytes(e);
					}
				};
				Counter.prototype.setValue = function (e) {
					if (typeof e !== 'number' || parseInt(e) != e) {
						throw new Error('invalid counter value (must be an integer)');
					}
					for (var t = 15; t >= 0; --t) {
						this._counter[t] = e % 256;
						e = e >> 8;
					}
				};
				Counter.prototype.setBytes = function (e) {
					e = coerceArray(e, true);
					if (e.length != 16) {
						throw new Error('invalid counter bytes size (must be 16 bytes)');
					}
					this._counter = e;
				};
				Counter.prototype.increment = function () {
					for (var e = 15; e >= 0; e--) {
						if (this._counter[e] === 255) {
							this._counter[e] = 0;
						} else {
							this._counter[e]++;
							break;
						}
					}
				};
				var ModeOfOperationCTR = function (e, t) {
					if (!(this instanceof ModeOfOperationCTR)) {
						throw Error('AES must be instanitated with `new`');
					}
					this.description = 'Counter';
					this.name = 'ctr';
					if (!(t instanceof Counter)) {
						t = new Counter(t);
					}
					this._counter = t;
					this._remainingCounter = null;
					this._remainingCounterIndex = 16;
					this._aes = new AES(e);
				};
				ModeOfOperationCTR.prototype.encrypt = function (e) {
					var t = coerceArray(e, true);
					for (var r = 0; r < t.length; r++) {
						if (this._remainingCounterIndex === 16) {
							this._remainingCounter = this._aes.encrypt(this._counter._counter);
							this._remainingCounterIndex = 0;
							this._counter.increment();
						}
						t[r] ^= this._remainingCounter[this._remainingCounterIndex++];
					}
					return t;
				};
				ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
				function pkcs7pad(e) {
					e = coerceArray(e, true);
					var t = 16 - (e.length % 16);
					var r = createArray(e.length + t);
					copyArray(e, r);
					for (var i = e.length; i < r.length; i++) {
						r[i] = t;
					}
					return r;
				}
				function pkcs7strip(e) {
					e = coerceArray(e, true);
					if (e.length < 16) {
						throw new Error('PKCS#7 invalid length');
					}
					var t = e[e.length - 1];
					if (t > 16) {
						throw new Error('PKCS#7 padding byte out of range');
					}
					var r = e.length - t;
					for (var i = 0; i < t; i++) {
						if (e[r + i] !== t) {
							throw new Error('PKCS#7 invalid padding byte');
						}
					}
					var a = createArray(r);
					copyArray(e, a, 0, 0, r);
					return a;
				}
				var T = {
					AES,
					Counter,
					ModeOfOperation: {
						ecb: ModeOfOperationECB,
						cbc: ModeOfOperationCBC,
						cfb: ModeOfOperationCFB,
						ofb: ModeOfOperationOFB,
						ctr: ModeOfOperationCTR
					},
					utils: { hex: i, utf8: r },
					padding: { pkcs7: { pad: pkcs7pad, strip: pkcs7strip } },
					_arrayTest: { coerceArray, createArray, copyArray }
				};
				if (true) {
					e.exports = T;
				} else {
				}
			})(this);
		},
		8440: (e, t, r) => {
			'use strict';
			r.d(t, {
				A: () => pn,
				C: () => Mr,
				D: () => Nr,
				E: () => Pr,
				I: () => Jr,
				N: () => er,
				V: () => tn,
				_: () => __awaiter$1,
				a: () => Tr,
				b: () => getAlchemyWsUrl,
				c: () => EthersEvent,
				d: () => deepCopy,
				e: () => getAlchemyEventTag,
				f: () => fromHex,
				g: () => getAlchemyHttpUrl,
				h: () => dn,
				i: () => isAlchemyEvent,
				j: () => ar,
				k: () => hn,
				l: () => logWarn,
				m: () => Alchemy,
				n: () => index_1789de96_noop,
				t: () => toHex,
				v: () => verifyAlchemyEventName
			});
			var i = {};
			r.r(i);
			r.d(i, {
				hasBrowserEnv: () => _e,
				hasStandardBrowserEnv: () => Ee,
				hasStandardBrowserWebWorkerEnv: () => Se,
				navigator: () => Ae,
				origin: () => ke
			});
			var a = r(1519);
			var o = r(5982);
			var c = r(5902);
			var u = r(2834);
			const l = new o.Vy(c.r);
			const d = {};
			const p = u.gH.from(0);
			const m = u.gH.from(-1);
			function throwFault(e, t, r, i) {
				const a = { fault: t, operation: r };
				if (i !== undefined) {
					a.value = i;
				}
				return l.throwError(e, o.Vy.errors.NUMERIC_FAULT, a);
			}
			let g = '0';
			while (g.length < 256) {
				g += g;
			}
			function getMultiplier(e) {
				if (typeof e !== 'number') {
					try {
						e = u.gH.from(e).toNumber();
					} catch (e) {}
				}
				if (typeof e === 'number' && e >= 0 && e <= 256 && !(e % 1)) {
					return '1' + g.substring(0, e);
				}
				return l.throwArgumentError('invalid decimal size', 'decimals', e);
			}
			function formatFixed(e, t) {
				if (t == null) {
					t = 0;
				}
				const r = getMultiplier(t);
				e = u.gH.from(e);
				const i = e.lt(p);
				if (i) {
					e = e.mul(m);
				}
				let a = e.mod(r).toString();
				while (a.length < r.length - 1) {
					a = '0' + a;
				}
				a = a.match(/^([0-9]*[1-9]|0)(0*)/)[1];
				const o = e.div(r).toString();
				if (r.length === 1) {
					e = o;
				} else {
					e = o + '.' + a;
				}
				if (i) {
					e = '-' + e;
				}
				return e;
			}
			function fixednumber_parseFixed(e, t) {
				if (t == null) {
					t = 0;
				}
				const r = getMultiplier(t);
				if (typeof e !== 'string' || !e.match(/^-?[0-9.]+$/)) {
					l.throwArgumentError('invalid decimal value', 'value', e);
				}
				const i = e.substring(0, 1) === '-';
				if (i) {
					e = e.substring(1);
				}
				if (e === '.') {
					l.throwArgumentError('missing value', 'value', e);
				}
				const a = e.split('.');
				if (a.length > 2) {
					l.throwArgumentError('too many decimal points', 'value', e);
				}
				let o = a[0],
					c = a[1];
				if (!o) {
					o = '0';
				}
				if (!c) {
					c = '0';
				}
				while (c[c.length - 1] === '0') {
					c = c.substring(0, c.length - 1);
				}
				if (c.length > r.length - 1) {
					throwFault('fractional component exceeds decimals', 'underflow', 'parseFixed');
				}
				if (c === '') {
					c = '0';
				}
				while (c.length < r.length - 1) {
					c += '0';
				}
				const d = u.gH.from(o);
				const p = u.gH.from(c);
				let g = d.mul(r).add(p);
				if (i) {
					g = g.mul(m);
				}
				return g;
			}
			class FixedFormat {
				constructor(e, t, r, i) {
					if (e !== d) {
						l.throwError(
							'cannot use FixedFormat constructor; use FixedFormat.from',
							o.Vy.errors.UNSUPPORTED_OPERATION,
							{ operation: 'new FixedFormat' }
						);
					}
					this.signed = t;
					this.width = r;
					this.decimals = i;
					this.name = (t ? '' : 'u') + 'fixed' + String(r) + 'x' + String(i);
					this._multiplier = getMultiplier(i);
					Object.freeze(this);
				}
				static from(e) {
					if (e instanceof FixedFormat) {
						return e;
					}
					if (typeof e === 'number') {
						e = `fixed128x${e}`;
					}
					let t = true;
					let r = 128;
					let i = 18;
					if (typeof e === 'string') {
						if (e === 'fixed') {
						} else if (e === 'ufixed') {
							t = false;
						} else {
							const a = e.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
							if (!a) {
								l.throwArgumentError('invalid fixed format', 'format', e);
							}
							t = a[1] !== 'u';
							r = parseInt(a[2]);
							i = parseInt(a[3]);
						}
					} else if (e) {
						const check = (t, r, i) => {
							if (e[t] == null) {
								return i;
							}
							if (typeof e[t] !== r) {
								l.throwArgumentError(
									'invalid fixed format (' + t + ' not ' + r + ')',
									'format.' + t,
									e[t]
								);
							}
							return e[t];
						};
						t = check('signed', 'boolean', t);
						r = check('width', 'number', r);
						i = check('decimals', 'number', i);
					}
					if (r % 8) {
						l.throwArgumentError(
							'invalid fixed format width (not byte aligned)',
							'format.width',
							r
						);
					}
					if (i > 80) {
						l.throwArgumentError('invalid fixed format (decimals too large)', 'format.decimals', i);
					}
					return new FixedFormat(d, t, r, i);
				}
			}
			class FixedNumber {
				constructor(e, t, r, i) {
					if (e !== d) {
						l.throwError(
							'cannot use FixedNumber constructor; use FixedNumber.from',
							o.Vy.errors.UNSUPPORTED_OPERATION,
							{ operation: 'new FixedFormat' }
						);
					}
					this.format = i;
					this._hex = t;
					this._value = r;
					this._isFixedNumber = true;
					Object.freeze(this);
				}
				_checkFormat(e) {
					if (this.format.name !== e.format.name) {
						l.throwArgumentError('incompatible format; use fixedNumber.toFormat', 'other', e);
					}
				}
				addUnsafe(e) {
					this._checkFormat(e);
					const t = fixednumber_parseFixed(this._value, this.format.decimals);
					const r = fixednumber_parseFixed(e._value, e.format.decimals);
					return FixedNumber.fromValue(t.add(r), this.format.decimals, this.format);
				}
				subUnsafe(e) {
					this._checkFormat(e);
					const t = fixednumber_parseFixed(this._value, this.format.decimals);
					const r = fixednumber_parseFixed(e._value, e.format.decimals);
					return FixedNumber.fromValue(t.sub(r), this.format.decimals, this.format);
				}
				mulUnsafe(e) {
					this._checkFormat(e);
					const t = fixednumber_parseFixed(this._value, this.format.decimals);
					const r = fixednumber_parseFixed(e._value, e.format.decimals);
					return FixedNumber.fromValue(
						t.mul(r).div(this.format._multiplier),
						this.format.decimals,
						this.format
					);
				}
				divUnsafe(e) {
					this._checkFormat(e);
					const t = fixednumber_parseFixed(this._value, this.format.decimals);
					const r = fixednumber_parseFixed(e._value, e.format.decimals);
					return FixedNumber.fromValue(
						t.mul(this.format._multiplier).div(r),
						this.format.decimals,
						this.format
					);
				}
				floor() {
					const e = this.toString().split('.');
					if (e.length === 1) {
						e.push('0');
					}
					let t = FixedNumber.from(e[0], this.format);
					const r = !e[1].match(/^(0*)$/);
					if (this.isNegative() && r) {
						t = t.subUnsafe(v.toFormat(t.format));
					}
					return t;
				}
				ceiling() {
					const e = this.toString().split('.');
					if (e.length === 1) {
						e.push('0');
					}
					let t = FixedNumber.from(e[0], this.format);
					const r = !e[1].match(/^(0*)$/);
					if (!this.isNegative() && r) {
						t = t.addUnsafe(v.toFormat(t.format));
					}
					return t;
				}
				round(e) {
					if (e == null) {
						e = 0;
					}
					const t = this.toString().split('.');
					if (t.length === 1) {
						t.push('0');
					}
					if (e < 0 || e > 80 || e % 1) {
						l.throwArgumentError('invalid decimal count', 'decimals', e);
					}
					if (t[1].length <= e) {
						return this;
					}
					const r = FixedNumber.from('1' + g.substring(0, e), this.format);
					const i = y.toFormat(this.format);
					return this.mulUnsafe(r).addUnsafe(i).floor().divUnsafe(r);
				}
				isZero() {
					return this._value === '0.0' || this._value === '0';
				}
				isNegative() {
					return this._value[0] === '-';
				}
				toString() {
					return this._value;
				}
				toHexString(e) {
					if (e == null) {
						return this._hex;
					}
					if (e % 8) {
						l.throwArgumentError('invalid byte width', 'width', e);
					}
					const t = u.gH.from(this._hex).fromTwos(this.format.width).toTwos(e).toHexString();
					return (0, a.bj)(t, e / 8);
				}
				toUnsafeFloat() {
					return parseFloat(this.toString());
				}
				toFormat(e) {
					return FixedNumber.fromString(this._value, e);
				}
				static fromValue(e, t, r) {
					if (r == null && t != null && !(0, u.YR)(t)) {
						r = t;
						t = null;
					}
					if (t == null) {
						t = 0;
					}
					if (r == null) {
						r = 'fixed';
					}
					return FixedNumber.fromString(formatFixed(e, t), FixedFormat.from(r));
				}
				static fromString(e, t) {
					if (t == null) {
						t = 'fixed';
					}
					const r = FixedFormat.from(t);
					const i = fixednumber_parseFixed(e, r.decimals);
					if (!r.signed && i.lt(p)) {
						throwFault('unsigned value cannot be negative', 'overflow', 'value', e);
					}
					let o = null;
					if (r.signed) {
						o = i.toTwos(r.width).toHexString();
					} else {
						o = i.toHexString();
						o = (0, a.bj)(o, r.width / 8);
					}
					const c = formatFixed(i, r.decimals);
					return new FixedNumber(d, o, c, r);
				}
				static fromBytes(e, t) {
					if (t == null) {
						t = 'fixed';
					}
					const r = FixedFormat.from(t);
					if ((0, a.k9)(e).length > r.width / 8) {
						throw new Error('overflow');
					}
					let i = u.gH.from(e);
					if (r.signed) {
						i = i.fromTwos(r.width);
					}
					const o = i.toTwos((r.signed ? 0 : 1) + r.width).toHexString();
					const c = formatFixed(i, r.decimals);
					return new FixedNumber(d, o, c, r);
				}
				static from(e, t) {
					if (typeof e === 'string') {
						return FixedNumber.fromString(e, t);
					}
					if ((0, a.aY)(e)) {
						return FixedNumber.fromBytes(e, t);
					}
					try {
						return FixedNumber.fromValue(e, 0, t);
					} catch (e) {
						if (e.code !== o.Vy.errors.INVALID_ARGUMENT) {
							throw e;
						}
					}
					return l.throwArgumentError('invalid FixedNumber value', 'value', e);
				}
				static isFixedNumber(e) {
					return !!(e && e._isFixedNumber);
				}
			}
			const v = FixedNumber.from(1);
			const y = FixedNumber.from('0.5');
			const w = 'units/5.7.0';
			const _ = new o.Vy(w);
			const A = ['wei', 'kwei', 'mwei', 'gwei', 'szabo', 'finney', 'ether'];
			function commify(e) {
				const t = String(e).split('.');
				if (
					t.length > 2 ||
					!t[0].match(/^-?[0-9]*$/) ||
					(t[1] && !t[1].match(/^[0-9]*$/)) ||
					e === '.' ||
					e === '-.'
				) {
					_.throwArgumentError('invalid value', 'value', e);
				}
				let r = t[0];
				let i = '';
				if (r.substring(0, 1) === '-') {
					i = '-';
					r = r.substring(1);
				}
				while (r.substring(0, 1) === '0') {
					r = r.substring(1);
				}
				if (r === '') {
					r = '0';
				}
				let a = '';
				if (t.length === 2) {
					a = '.' + (t[1] || '0');
				}
				while (a.length > 2 && a[a.length - 1] === '0') {
					a = a.substring(0, a.length - 1);
				}
				const o = [];
				while (r.length) {
					if (r.length <= 3) {
						o.unshift(r);
						break;
					} else {
						const e = r.length - 3;
						o.unshift(r.substring(e));
						r = r.substring(0, e);
					}
				}
				return i + o.join(',') + a;
			}
			function formatUnits(e, t) {
				if (typeof t === 'string') {
					const e = A.indexOf(t);
					if (e !== -1) {
						t = 3 * e;
					}
				}
				return formatFixed(e, t != null ? t : 18);
			}
			function parseUnits(e, t) {
				if (typeof e !== 'string') {
					_.throwArgumentError('value must be a string', 'value', e);
				}
				if (typeof t === 'string') {
					const e = A.indexOf(t);
					if (e !== -1) {
						t = 3 * e;
					}
				}
				return parseFixed(e, t != null ? t : 18);
			}
			function formatEther(e) {
				return formatUnits(e, 18);
			}
			function parseEther(e) {
				return parseUnits(e, 18);
			}
			function bind(e, t) {
				return function wrap() {
					return e.apply(t, arguments);
				};
			}
			var k = r(5409);
			const { toString: N } = Object.prototype;
			const { getPrototypeOf: T } = Object;
			const x = ((e) => (t) => {
				const r = N.call(t);
				return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
			})(Object.create(null));
			const kindOfTest = (e) => {
				e = e.toLowerCase();
				return (t) => x(t) === e;
			};
			const typeOfTest = (e) => (t) => typeof t === e;
			const { isArray: B } = Array;
			const P = typeOfTest('undefined');
			function isBuffer(e) {
				return (
					e !== null &&
					!P(e) &&
					e.constructor !== null &&
					!P(e.constructor) &&
					I(e.constructor.isBuffer) &&
					e.constructor.isBuffer(e)
				);
			}
			const M = kindOfTest('ArrayBuffer');
			function isArrayBufferView(e) {
				let t;
				if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
					t = ArrayBuffer.isView(e);
				} else {
					t = e && e.buffer && M(e.buffer);
				}
				return t;
			}
			const C = typeOfTest('string');
			const I = typeOfTest('function');
			const O = typeOfTest('number');
			const isObject = (e) => e !== null && typeof e === 'object';
			const isBoolean = (e) => e === true || e === false;
			const isPlainObject = (e) => {
				if (x(e) !== 'object') {
					return false;
				}
				const t = T(e);
				return (
					(t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) &&
					!(Symbol.toStringTag in e) &&
					!(Symbol.iterator in e)
				);
			};
			const F = kindOfTest('Date');
			const D = kindOfTest('File');
			const L = kindOfTest('Blob');
			const U = kindOfTest('FileList');
			const isStream = (e) => isObject(e) && I(e.pipe);
			const isFormData = (e) => {
				let t;
				return (
					e &&
					((typeof FormData === 'function' && e instanceof FormData) ||
						(I(e.append) &&
							((t = x(e)) === 'formdata' ||
								(t === 'object' && I(e.toString) && e.toString() === '[object FormData]'))))
				);
			};
			const j = kindOfTest('URLSearchParams');
			const [H, z, $, G] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);
			const trim = (e) => (e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ''));
			function forEach(e, t, { allOwnKeys: r = false } = {}) {
				if (e === null || typeof e === 'undefined') {
					return;
				}
				let i;
				let a;
				if (typeof e !== 'object') {
					e = [e];
				}
				if (B(e)) {
					for (i = 0, a = e.length; i < a; i++) {
						t.call(null, e[i], i, e);
					}
				} else {
					const a = r ? Object.getOwnPropertyNames(e) : Object.keys(e);
					const o = a.length;
					let c;
					for (i = 0; i < o; i++) {
						c = a[i];
						t.call(null, e[c], c, e);
					}
				}
			}
			function findKey(e, t) {
				t = t.toLowerCase();
				const r = Object.keys(e);
				let i = r.length;
				let a;
				while (i-- > 0) {
					a = r[i];
					if (t === a.toLowerCase()) {
						return a;
					}
				}
				return null;
			}
			const q = (() => {
				if (typeof globalThis !== 'undefined') return globalThis;
				return typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : global;
			})();
			const isContextDefined = (e) => !P(e) && e !== q;
			function merge() {
				const { caseless: e } = (isContextDefined(this) && this) || {};
				const t = {};
				const assignValue = (r, i) => {
					const a = (e && findKey(t, i)) || i;
					if (isPlainObject(t[a]) && isPlainObject(r)) {
						t[a] = merge(t[a], r);
					} else if (isPlainObject(r)) {
						t[a] = merge({}, r);
					} else if (B(r)) {
						t[a] = r.slice();
					} else {
						t[a] = r;
					}
				};
				for (let e = 0, t = arguments.length; e < t; e++) {
					arguments[e] && forEach(arguments[e], assignValue);
				}
				return t;
			}
			const extend = (e, t, r, { allOwnKeys: i } = {}) => {
				forEach(
					t,
					(t, i) => {
						if (r && I(t)) {
							e[i] = bind(t, r);
						} else {
							e[i] = t;
						}
					},
					{ allOwnKeys: i }
				);
				return e;
			};
			const stripBOM = (e) => {
				if (e.charCodeAt(0) === 65279) {
					e = e.slice(1);
				}
				return e;
			};
			const inherits = (e, t, r, i) => {
				e.prototype = Object.create(t.prototype, i);
				e.prototype.constructor = e;
				Object.defineProperty(e, 'super', { value: t.prototype });
				r && Object.assign(e.prototype, r);
			};
			const toFlatObject = (e, t, r, i) => {
				let a;
				let o;
				let c;
				const u = {};
				t = t || {};
				if (e == null) return t;
				do {
					a = Object.getOwnPropertyNames(e);
					o = a.length;
					while (o-- > 0) {
						c = a[o];
						if ((!i || i(c, e, t)) && !u[c]) {
							t[c] = e[c];
							u[c] = true;
						}
					}
					e = r !== false && T(e);
				} while (e && (!r || r(e, t)) && e !== Object.prototype);
				return t;
			};
			const endsWith = (e, t, r) => {
				e = String(e);
				if (r === undefined || r > e.length) {
					r = e.length;
				}
				r -= t.length;
				const i = e.indexOf(t, r);
				return i !== -1 && i === r;
			};
			const toArray = (e) => {
				if (!e) return null;
				if (B(e)) return e;
				let t = e.length;
				if (!O(t)) return null;
				const r = new Array(t);
				while (t-- > 0) {
					r[t] = e[t];
				}
				return r;
			};
			const V = (
				(e) => (t) =>
					e && t instanceof e
			)(typeof Uint8Array !== 'undefined' && T(Uint8Array));
			const forEachEntry = (e, t) => {
				const r = e && e[Symbol.iterator];
				const i = r.call(e);
				let a;
				while ((a = i.next()) && !a.done) {
					const r = a.value;
					t.call(e, r[0], r[1]);
				}
			};
			const matchAll = (e, t) => {
				let r;
				const i = [];
				while ((r = e.exec(t)) !== null) {
					i.push(r);
				}
				return i;
			};
			const W = kindOfTest('HTMLFormElement');
			const toCamelCase = (e) =>
				e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(e, t, r) {
					return t.toUpperCase() + r;
				});
			const J = (
				({ hasOwnProperty: e }) =>
				(t, r) =>
					e.call(t, r)
			)(Object.prototype);
			const Z = kindOfTest('RegExp');
			const reduceDescriptors = (e, t) => {
				const r = Object.getOwnPropertyDescriptors(e);
				const i = {};
				forEach(r, (r, a) => {
					let o;
					if ((o = t(r, a, e)) !== false) {
						i[a] = o || r;
					}
				});
				Object.defineProperties(e, i);
			};
			const freezeMethods = (e) => {
				reduceDescriptors(e, (t, r) => {
					if (I(e) && ['arguments', 'caller', 'callee'].indexOf(r) !== -1) {
						return false;
					}
					const i = e[r];
					if (!I(i)) return;
					t.enumerable = false;
					if ('writable' in t) {
						t.writable = false;
						return;
					}
					if (!t.set) {
						t.set = () => {
							throw Error("Can not rewrite read-only method '" + r + "'");
						};
					}
				});
			};
			const toObjectSet = (e, t) => {
				const r = {};
				const define = (e) => {
					e.forEach((e) => {
						r[e] = true;
					});
				};
				B(e) ? define(e) : define(String(e).split(t));
				return r;
			};
			const noop = () => {};
			const toFiniteNumber = (e, t) => (e != null && Number.isFinite((e = +e)) ? e : t);
			const Q = 'abcdefghijklmnopqrstuvwxyz';
			const Y = '0123456789';
			const X = { DIGIT: Y, ALPHA: Q, ALPHA_DIGIT: Q + Q.toUpperCase() + Y };
			const generateString = (e = 16, t = X.ALPHA_DIGIT) => {
				let r = '';
				const { length: i } = t;
				while (e--) {
					r += t[(Math.random() * i) | 0];
				}
				return r;
			};
			function isSpecCompliantForm(e) {
				return !!(e && I(e.append) && e[Symbol.toStringTag] === 'FormData' && e[Symbol.iterator]);
			}
			const toJSONObject = (e) => {
				const t = new Array(10);
				const visit = (e, r) => {
					if (isObject(e)) {
						if (t.indexOf(e) >= 0) {
							return;
						}
						if (!('toJSON' in e)) {
							t[r] = e;
							const i = B(e) ? [] : {};
							forEach(e, (e, t) => {
								const a = visit(e, r + 1);
								!P(a) && (i[t] = a);
							});
							t[r] = undefined;
							return i;
						}
					}
					return e;
				};
				return visit(e, 0);
			};
			const ee = kindOfTest('AsyncFunction');
			const isThenable = (e) => e && (isObject(e) || I(e)) && I(e.then) && I(e.catch);
			const te = ((e, t) => {
				if (e) {
					return setImmediate;
				}
				return t
					? ((e, t) => {
							q.addEventListener(
								'message',
								({ source: r, data: i }) => {
									if (r === q && i === e) {
										t.length && t.shift()();
									}
								},
								false
							);
							return (r) => {
								t.push(r);
								q.postMessage(e, '*');
							};
						})(`axios@${Math.random()}`, [])
					: (e) => setTimeout(e);
			})(typeof setImmediate === 'function', I(q.postMessage));
			const re =
				typeof queueMicrotask !== 'undefined'
					? queueMicrotask.bind(q)
					: (typeof k !== 'undefined' && k.nextTick) || te;
			const ne = {
				isArray: B,
				isArrayBuffer: M,
				isBuffer,
				isFormData,
				isArrayBufferView,
				isString: C,
				isNumber: O,
				isBoolean,
				isObject,
				isPlainObject,
				isReadableStream: H,
				isRequest: z,
				isResponse: $,
				isHeaders: G,
				isUndefined: P,
				isDate: F,
				isFile: D,
				isBlob: L,
				isRegExp: Z,
				isFunction: I,
				isStream,
				isURLSearchParams: j,
				isTypedArray: V,
				isFileList: U,
				forEach,
				merge,
				extend,
				trim,
				stripBOM,
				inherits,
				toFlatObject,
				kindOf: x,
				kindOfTest,
				endsWith,
				toArray,
				forEachEntry,
				matchAll,
				isHTMLForm: W,
				hasOwnProperty: J,
				hasOwnProp: J,
				reduceDescriptors,
				freezeMethods,
				toObjectSet,
				toCamelCase,
				noop,
				toFiniteNumber,
				findKey,
				global: q,
				isContextDefined,
				ALPHABET: X,
				generateString,
				isSpecCompliantForm,
				toJSONObject,
				isAsyncFn: ee,
				isThenable,
				setImmediate: te,
				asap: re
			};
			function AxiosError(e, t, r, i, a) {
				Error.call(this);
				if (Error.captureStackTrace) {
					Error.captureStackTrace(this, this.constructor);
				} else {
					this.stack = new Error().stack;
				}
				this.message = e;
				this.name = 'AxiosError';
				t && (this.code = t);
				r && (this.config = r);
				i && (this.request = i);
				if (a) {
					this.response = a;
					this.status = a.status ? a.status : null;
				}
			}
			ne.inherits(AxiosError, Error, {
				toJSON: function toJSON() {
					return {
						message: this.message,
						name: this.name,
						description: this.description,
						number: this.number,
						fileName: this.fileName,
						lineNumber: this.lineNumber,
						columnNumber: this.columnNumber,
						stack: this.stack,
						config: ne.toJSONObject(this.config),
						code: this.code,
						status: this.status
					};
				}
			});
			const ie = AxiosError.prototype;
			const se = {};
			[
				'ERR_BAD_OPTION_VALUE',
				'ERR_BAD_OPTION',
				'ECONNABORTED',
				'ETIMEDOUT',
				'ERR_NETWORK',
				'ERR_FR_TOO_MANY_REDIRECTS',
				'ERR_DEPRECATED',
				'ERR_BAD_RESPONSE',
				'ERR_BAD_REQUEST',
				'ERR_CANCELED',
				'ERR_NOT_SUPPORT',
				'ERR_INVALID_URL'
			].forEach((e) => {
				se[e] = { value: e };
			});
			Object.defineProperties(AxiosError, se);
			Object.defineProperty(ie, 'isAxiosError', { value: true });
			AxiosError.from = (e, t, r, i, a, o) => {
				const c = Object.create(ie);
				ne.toFlatObject(
					e,
					c,
					function filter(e) {
						return e !== Error.prototype;
					},
					(e) => e !== 'isAxiosError'
				);
				AxiosError.call(c, e.message, t, r, i, a);
				c.cause = e;
				c.name = e.name;
				o && Object.assign(c, o);
				return c;
			};
			const ae = AxiosError;
			const oe = null;
			var ce = r(6533)['Buffer'];
			function isVisitable(e) {
				return ne.isPlainObject(e) || ne.isArray(e);
			}
			function removeBrackets(e) {
				return ne.endsWith(e, '[]') ? e.slice(0, -2) : e;
			}
			function renderKey(e, t, r) {
				if (!e) return t;
				return e
					.concat(t)
					.map(function each(e, t) {
						e = removeBrackets(e);
						return !r && t ? '[' + e + ']' : e;
					})
					.join(r ? '.' : '');
			}
			function isFlatArray(e) {
				return ne.isArray(e) && !e.some(isVisitable);
			}
			const ue = ne.toFlatObject(ne, {}, null, function filter(e) {
				return /^is[A-Z]/.test(e);
			});
			function toFormData(e, t, r) {
				if (!ne.isObject(e)) {
					throw new TypeError('target must be an object');
				}
				t = t || new (oe || FormData)();
				r = ne.toFlatObject(
					r,
					{ metaTokens: true, dots: false, indexes: false },
					false,
					function defined(e, t) {
						return !ne.isUndefined(t[e]);
					}
				);
				const i = r.metaTokens;
				const a = r.visitor || defaultVisitor;
				const o = r.dots;
				const c = r.indexes;
				const u = r.Blob || (typeof Blob !== 'undefined' && Blob);
				const l = u && ne.isSpecCompliantForm(t);
				if (!ne.isFunction(a)) {
					throw new TypeError('visitor must be a function');
				}
				function convertValue(e) {
					if (e === null) return '';
					if (ne.isDate(e)) {
						return e.toISOString();
					}
					if (!l && ne.isBlob(e)) {
						throw new ae('Blob is not supported. Use a Buffer instead.');
					}
					if (ne.isArrayBuffer(e) || ne.isTypedArray(e)) {
						return l && typeof Blob === 'function' ? new Blob([e]) : ce.from(e);
					}
					return e;
				}
				function defaultVisitor(e, r, a) {
					let u = e;
					if (e && !a && typeof e === 'object') {
						if (ne.endsWith(r, '{}')) {
							r = i ? r : r.slice(0, -2);
							e = JSON.stringify(e);
						} else if (
							(ne.isArray(e) && isFlatArray(e)) ||
							((ne.isFileList(e) || ne.endsWith(r, '[]')) && (u = ne.toArray(e)))
						) {
							r = removeBrackets(r);
							u.forEach(function each(e, i) {
								!(ne.isUndefined(e) || e === null) &&
									t.append(
										c === true ? renderKey([r], i, o) : c === null ? r : r + '[]',
										convertValue(e)
									);
							});
							return false;
						}
					}
					if (isVisitable(e)) {
						return true;
					}
					t.append(renderKey(a, r, o), convertValue(e));
					return false;
				}
				const d = [];
				const p = Object.assign(ue, { defaultVisitor, convertValue, isVisitable });
				function build(e, r) {
					if (ne.isUndefined(e)) return;
					if (d.indexOf(e) !== -1) {
						throw Error('Circular reference detected in ' + r.join('.'));
					}
					d.push(e);
					ne.forEach(e, function each(e, i) {
						const o =
							!(ne.isUndefined(e) || e === null) &&
							a.call(t, e, ne.isString(i) ? i.trim() : i, r, p);
						if (o === true) {
							build(e, r ? r.concat(i) : [i]);
						}
					});
					d.pop();
				}
				if (!ne.isObject(e)) {
					throw new TypeError('data must be an object');
				}
				build(e);
				return t;
			}
			const le = toFormData;
			function encode(e) {
				const t = {
					'!': '%21',
					"'": '%27',
					'(': '%28',
					')': '%29',
					'~': '%7E',
					'%20': '+',
					'%00': '\0'
				};
				return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function replacer(e) {
					return t[e];
				});
			}
			function AxiosURLSearchParams(e, t) {
				this._pairs = [];
				e && le(e, this, t);
			}
			const de = AxiosURLSearchParams.prototype;
			de.append = function append(e, t) {
				this._pairs.push([e, t]);
			};
			de.toString = function toString(e) {
				const t = e
					? function (t) {
							return e.call(this, t, encode);
						}
					: encode;
				return this._pairs
					.map(function each(e) {
						return t(e[0]) + '=' + t(e[1]);
					}, '')
					.join('&');
			};
			const he = AxiosURLSearchParams;
			function buildURL_encode(e) {
				return encodeURIComponent(e)
					.replace(/%3A/gi, ':')
					.replace(/%24/g, '$')
					.replace(/%2C/gi, ',')
					.replace(/%20/g, '+')
					.replace(/%5B/gi, '[')
					.replace(/%5D/gi, ']');
			}
			function buildURL(e, t, r) {
				if (!t) {
					return e;
				}
				const i = (r && r.encode) || buildURL_encode;
				if (ne.isFunction(r)) {
					r = { serialize: r };
				}
				const a = r && r.serialize;
				let o;
				if (a) {
					o = a(t, r);
				} else {
					o = ne.isURLSearchParams(t) ? t.toString() : new he(t, r).toString(i);
				}
				if (o) {
					const t = e.indexOf('#');
					if (t !== -1) {
						e = e.slice(0, t);
					}
					e += (e.indexOf('?') === -1 ? '?' : '&') + o;
				}
				return e;
			}
			class InterceptorManager {
				constructor() {
					this.handlers = [];
				}
				use(e, t, r) {
					this.handlers.push({
						fulfilled: e,
						rejected: t,
						synchronous: r ? r.synchronous : false,
						runWhen: r ? r.runWhen : null
					});
					return this.handlers.length - 1;
				}
				eject(e) {
					if (this.handlers[e]) {
						this.handlers[e] = null;
					}
				}
				clear() {
					if (this.handlers) {
						this.handlers = [];
					}
				}
				forEach(e) {
					ne.forEach(this.handlers, function forEachHandler(t) {
						if (t !== null) {
							e(t);
						}
					});
				}
			}
			const pe = InterceptorManager;
			const me = { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false };
			const ve = typeof URLSearchParams !== 'undefined' ? URLSearchParams : he;
			const ye = typeof FormData !== 'undefined' ? FormData : null;
			const be = typeof Blob !== 'undefined' ? Blob : null;
			const we = {
				isBrowser: true,
				classes: { URLSearchParams: ve, FormData: ye, Blob: be },
				protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
			};
			const _e = typeof window !== 'undefined' && typeof document !== 'undefined';
			const Ae = (typeof navigator === 'object' && navigator) || undefined;
			const Ee = _e && (!Ae || ['ReactNative', 'NativeScript', 'NS'].indexOf(Ae.product) < 0);
			const Se = (() =>
				typeof WorkerGlobalScope !== 'undefined' &&
				self instanceof WorkerGlobalScope &&
				typeof self.importScripts === 'function')();
			const ke = (_e && window.location.href) || 'http://localhost';
			const Ne = { ...i, ...we };
			function toURLEncodedForm(e, t) {
				return le(
					e,
					new Ne.classes.URLSearchParams(),
					Object.assign(
						{
							visitor: function (e, t, r, i) {
								if (Ne.isNode && ne.isBuffer(e)) {
									this.append(t, e.toString('base64'));
									return false;
								}
								return i.defaultVisitor.apply(this, arguments);
							}
						},
						t
					)
				);
			}
			function parsePropPath(e) {
				return ne.matchAll(/\w+|\[(\w*)]/g, e).map((e) => (e[0] === '[]' ? '' : e[1] || e[0]));
			}
			function arrayToObject(e) {
				const t = {};
				const r = Object.keys(e);
				let i;
				const a = r.length;
				let o;
				for (i = 0; i < a; i++) {
					o = r[i];
					t[o] = e[o];
				}
				return t;
			}
			function formDataToJSON(e) {
				function buildPath(e, t, r, i) {
					let a = e[i++];
					if (a === '__proto__') return true;
					const o = Number.isFinite(+a);
					const c = i >= e.length;
					a = !a && ne.isArray(r) ? r.length : a;
					if (c) {
						if (ne.hasOwnProp(r, a)) {
							r[a] = [r[a], t];
						} else {
							r[a] = t;
						}
						return !o;
					}
					if (!r[a] || !ne.isObject(r[a])) {
						r[a] = [];
					}
					const u = buildPath(e, t, r[a], i);
					if (u && ne.isArray(r[a])) {
						r[a] = arrayToObject(r[a]);
					}
					return !o;
				}
				if (ne.isFormData(e) && ne.isFunction(e.entries)) {
					const t = {};
					ne.forEachEntry(e, (e, r) => {
						buildPath(parsePropPath(e), r, t, 0);
					});
					return t;
				}
				return null;
			}
			const Te = formDataToJSON;
			function stringifySafely(e, t, r) {
				if (ne.isString(e)) {
					try {
						(t || JSON.parse)(e);
						return ne.trim(e);
					} catch (e) {
						if (e.name !== 'SyntaxError') {
							throw e;
						}
					}
				}
				return (r || JSON.stringify)(e);
			}
			const xe = {
				transitional: me,
				adapter: ['xhr', 'http', 'fetch'],
				transformRequest: [
					function transformRequest(e, t) {
						const r = t.getContentType() || '';
						const i = r.indexOf('application/json') > -1;
						const a = ne.isObject(e);
						if (a && ne.isHTMLForm(e)) {
							e = new FormData(e);
						}
						const o = ne.isFormData(e);
						if (o) {
							return i ? JSON.stringify(Te(e)) : e;
						}
						if (
							ne.isArrayBuffer(e) ||
							ne.isBuffer(e) ||
							ne.isStream(e) ||
							ne.isFile(e) ||
							ne.isBlob(e) ||
							ne.isReadableStream(e)
						) {
							return e;
						}
						if (ne.isArrayBufferView(e)) {
							return e.buffer;
						}
						if (ne.isURLSearchParams(e)) {
							t.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
							return e.toString();
						}
						let c;
						if (a) {
							if (r.indexOf('application/x-www-form-urlencoded') > -1) {
								return toURLEncodedForm(e, this.formSerializer).toString();
							}
							if ((c = ne.isFileList(e)) || r.indexOf('multipart/form-data') > -1) {
								const t = this.env && this.env.FormData;
								return le(c ? { 'files[]': e } : e, t && new t(), this.formSerializer);
							}
						}
						if (a || i) {
							t.setContentType('application/json', false);
							return stringifySafely(e);
						}
						return e;
					}
				],
				transformResponse: [
					function transformResponse(e) {
						const t = this.transitional || xe.transitional;
						const r = t && t.forcedJSONParsing;
						const i = this.responseType === 'json';
						if (ne.isResponse(e) || ne.isReadableStream(e)) {
							return e;
						}
						if (e && ne.isString(e) && ((r && !this.responseType) || i)) {
							const r = t && t.silentJSONParsing;
							const a = !r && i;
							try {
								return JSON.parse(e);
							} catch (e) {
								if (a) {
									if (e.name === 'SyntaxError') {
										throw ae.from(e, ae.ERR_BAD_RESPONSE, this, null, this.response);
									}
									throw e;
								}
							}
						}
						return e;
					}
				],
				timeout: 0,
				xsrfCookieName: 'XSRF-TOKEN',
				xsrfHeaderName: 'X-XSRF-TOKEN',
				maxContentLength: -1,
				maxBodyLength: -1,
				env: { FormData: Ne.classes.FormData, Blob: Ne.classes.Blob },
				validateStatus: function validateStatus(e) {
					return e >= 200 && e < 300;
				},
				headers: {
					common: { Accept: 'application/json, text/plain, */*', 'Content-Type': undefined }
				}
			};
			ne.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (e) => {
				xe.headers[e] = {};
			});
			const Be = xe;
			const Re = ne.toObjectSet([
				'age',
				'authorization',
				'content-length',
				'content-type',
				'etag',
				'expires',
				'from',
				'host',
				'if-modified-since',
				'if-unmodified-since',
				'last-modified',
				'location',
				'max-forwards',
				'proxy-authorization',
				'referer',
				'retry-after',
				'user-agent'
			]);
			const parseHeaders = (e) => {
				const t = {};
				let r;
				let i;
				let a;
				e &&
					e.split('\n').forEach(function parser(e) {
						a = e.indexOf(':');
						r = e.substring(0, a).trim().toLowerCase();
						i = e.substring(a + 1).trim();
						if (!r || (t[r] && Re[r])) {
							return;
						}
						if (r === 'set-cookie') {
							if (t[r]) {
								t[r].push(i);
							} else {
								t[r] = [i];
							}
						} else {
							t[r] = t[r] ? t[r] + ', ' + i : i;
						}
					});
				return t;
			};
			const Pe = Symbol('internals');
			function normalizeHeader(e) {
				return e && String(e).trim().toLowerCase();
			}
			function normalizeValue(e) {
				if (e === false || e == null) {
					return e;
				}
				return ne.isArray(e) ? e.map(normalizeValue) : String(e);
			}
			function parseTokens(e) {
				const t = Object.create(null);
				const r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
				let i;
				while ((i = r.exec(e))) {
					t[i[1]] = i[2];
				}
				return t;
			}
			const isValidHeaderName = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
			function matchHeaderValue(e, t, r, i, a) {
				if (ne.isFunction(i)) {
					return i.call(this, t, r);
				}
				if (a) {
					t = r;
				}
				if (!ne.isString(t)) return;
				if (ne.isString(i)) {
					return t.indexOf(i) !== -1;
				}
				if (ne.isRegExp(i)) {
					return i.test(t);
				}
			}
			function formatHeader(e) {
				return e
					.trim()
					.toLowerCase()
					.replace(/([a-z\d])(\w*)/g, (e, t, r) => t.toUpperCase() + r);
			}
			function buildAccessors(e, t) {
				const r = ne.toCamelCase(' ' + t);
				['get', 'set', 'has'].forEach((i) => {
					Object.defineProperty(e, i + r, {
						value: function (e, r, a) {
							return this[i].call(this, t, e, r, a);
						},
						configurable: true
					});
				});
			}
			class AxiosHeaders {
				constructor(e) {
					e && this.set(e);
				}
				set(e, t, r) {
					const i = this;
					function setHeader(e, t, r) {
						const a = normalizeHeader(t);
						if (!a) {
							throw new Error('header name must be a non-empty string');
						}
						const o = ne.findKey(i, a);
						if (!o || i[o] === undefined || r === true || (r === undefined && i[o] !== false)) {
							i[o || t] = normalizeValue(e);
						}
					}
					const setHeaders = (e, t) => ne.forEach(e, (e, r) => setHeader(e, r, t));
					if (ne.isPlainObject(e) || e instanceof this.constructor) {
						setHeaders(e, t);
					} else if (ne.isString(e) && (e = e.trim()) && !isValidHeaderName(e)) {
						setHeaders(parseHeaders(e), t);
					} else if (ne.isHeaders(e)) {
						for (const [t, i] of e.entries()) {
							setHeader(i, t, r);
						}
					} else {
						e != null && setHeader(t, e, r);
					}
					return this;
				}
				get(e, t) {
					e = normalizeHeader(e);
					if (e) {
						const r = ne.findKey(this, e);
						if (r) {
							const e = this[r];
							if (!t) {
								return e;
							}
							if (t === true) {
								return parseTokens(e);
							}
							if (ne.isFunction(t)) {
								return t.call(this, e, r);
							}
							if (ne.isRegExp(t)) {
								return t.exec(e);
							}
							throw new TypeError('parser must be boolean|regexp|function');
						}
					}
				}
				has(e, t) {
					e = normalizeHeader(e);
					if (e) {
						const r = ne.findKey(this, e);
						return !!(r && this[r] !== undefined && (!t || matchHeaderValue(this, this[r], r, t)));
					}
					return false;
				}
				delete(e, t) {
					const r = this;
					let i = false;
					function deleteHeader(e) {
						e = normalizeHeader(e);
						if (e) {
							const a = ne.findKey(r, e);
							if (a && (!t || matchHeaderValue(r, r[a], a, t))) {
								delete r[a];
								i = true;
							}
						}
					}
					if (ne.isArray(e)) {
						e.forEach(deleteHeader);
					} else {
						deleteHeader(e);
					}
					return i;
				}
				clear(e) {
					const t = Object.keys(this);
					let r = t.length;
					let i = false;
					while (r--) {
						const a = t[r];
						if (!e || matchHeaderValue(this, this[a], a, e, true)) {
							delete this[a];
							i = true;
						}
					}
					return i;
				}
				normalize(e) {
					const t = this;
					const r = {};
					ne.forEach(this, (i, a) => {
						const o = ne.findKey(r, a);
						if (o) {
							t[o] = normalizeValue(i);
							delete t[a];
							return;
						}
						const c = e ? formatHeader(a) : String(a).trim();
						if (c !== a) {
							delete t[a];
						}
						t[c] = normalizeValue(i);
						r[c] = true;
					});
					return this;
				}
				concat(...e) {
					return this.constructor.concat(this, ...e);
				}
				toJSON(e) {
					const t = Object.create(null);
					ne.forEach(this, (r, i) => {
						r != null && r !== false && (t[i] = e && ne.isArray(r) ? r.join(', ') : r);
					});
					return t;
				}
				[Symbol.iterator]() {
					return Object.entries(this.toJSON())[Symbol.iterator]();
				}
				toString() {
					return Object.entries(this.toJSON())
						.map(([e, t]) => e + ': ' + t)
						.join('\n');
				}
				get [Symbol.toStringTag]() {
					return 'AxiosHeaders';
				}
				static from(e) {
					return e instanceof this ? e : new this(e);
				}
				static concat(e, ...t) {
					const r = new this(e);
					t.forEach((e) => r.set(e));
					return r;
				}
				static accessor(e) {
					const t = (this[Pe] = this[Pe] = { accessors: {} });
					const r = t.accessors;
					const i = this.prototype;
					function defineAccessor(e) {
						const t = normalizeHeader(e);
						if (!r[t]) {
							buildAccessors(i, e);
							r[t] = true;
						}
					}
					ne.isArray(e) ? e.forEach(defineAccessor) : defineAccessor(e);
					return this;
				}
			}
			AxiosHeaders.accessor([
				'Content-Type',
				'Content-Length',
				'Accept',
				'Accept-Encoding',
				'User-Agent',
				'Authorization'
			]);
			ne.reduceDescriptors(AxiosHeaders.prototype, ({ value: e }, t) => {
				let r = t[0].toUpperCase() + t.slice(1);
				return {
					get: () => e,
					set(e) {
						this[r] = e;
					}
				};
			});
			ne.freezeMethods(AxiosHeaders);
			const Me = AxiosHeaders;
			function transformData(e, t) {
				const r = this || Be;
				const i = t || r;
				const a = Me.from(i.headers);
				let o = i.data;
				ne.forEach(e, function transform(e) {
					o = e.call(r, o, a.normalize(), t ? t.status : undefined);
				});
				a.normalize();
				return o;
			}
			function isCancel(e) {
				return !!(e && e.__CANCEL__);
			}
			function CanceledError(e, t, r) {
				ae.call(this, e == null ? 'canceled' : e, ae.ERR_CANCELED, t, r);
				this.name = 'CanceledError';
			}
			ne.inherits(CanceledError, ae, { __CANCEL__: true });
			const Ce = CanceledError;
			function settle(e, t, r) {
				const i = r.config.validateStatus;
				if (!r.status || !i || i(r.status)) {
					e(r);
				} else {
					t(
						new ae(
							'Request failed with status code ' + r.status,
							[ae.ERR_BAD_REQUEST, ae.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
							r.config,
							r.request,
							r
						)
					);
				}
			}
			function parseProtocol(e) {
				const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
				return (t && t[1]) || '';
			}
			function speedometer(e, t) {
				e = e || 10;
				const r = new Array(e);
				const i = new Array(e);
				let a = 0;
				let o = 0;
				let c;
				t = t !== undefined ? t : 1e3;
				return function push(u) {
					const l = Date.now();
					const d = i[o];
					if (!c) {
						c = l;
					}
					r[a] = u;
					i[a] = l;
					let p = o;
					let m = 0;
					while (p !== a) {
						m += r[p++];
						p = p % e;
					}
					a = (a + 1) % e;
					if (a === o) {
						o = (o + 1) % e;
					}
					if (l - c < t) {
						return;
					}
					const g = d && l - d;
					return g ? Math.round((m * 1e3) / g) : undefined;
				};
			}
			const Ie = speedometer;
			function throttle(e, t) {
				let r = 0;
				let i = 1e3 / t;
				let a;
				let o;
				const invoke = (t, i = Date.now()) => {
					r = i;
					a = null;
					if (o) {
						clearTimeout(o);
						o = null;
					}
					e.apply(null, t);
				};
				const throttled = (...e) => {
					const t = Date.now();
					const c = t - r;
					if (c >= i) {
						invoke(e, t);
					} else {
						a = e;
						if (!o) {
							o = setTimeout(() => {
								o = null;
								invoke(a);
							}, i - c);
						}
					}
				};
				const flush = () => a && invoke(a);
				return [throttled, flush];
			}
			const Oe = throttle;
			const progressEventReducer = (e, t, r = 3) => {
				let i = 0;
				const a = Ie(50, 250);
				return Oe((r) => {
					const o = r.loaded;
					const c = r.lengthComputable ? r.total : undefined;
					const u = o - i;
					const l = a(u);
					const d = o <= c;
					i = o;
					const p = {
						loaded: o,
						total: c,
						progress: c ? o / c : undefined,
						bytes: u,
						rate: l ? l : undefined,
						estimated: l && c && d ? (c - o) / l : undefined,
						event: r,
						lengthComputable: c != null,
						[t ? 'download' : 'upload']: true
					};
					e(p);
				}, r);
			};
			const progressEventDecorator = (e, t) => {
				const r = e != null;
				return [(i) => t[0]({ lengthComputable: r, total: e, loaded: i }), t[1]];
			};
			const asyncDecorator =
				(e) =>
				(...t) =>
					ne.asap(() => e(...t));
			const Fe = Ne.hasStandardBrowserEnv
				? ((e, t) => (r) => {
						r = new URL(r, Ne.origin);
						return e.protocol === r.protocol && e.host === r.host && (t || e.port === r.port);
					})(new URL(Ne.origin), Ne.navigator && /(msie|trident)/i.test(Ne.navigator.userAgent))
				: () => true;
			const De = Ne.hasStandardBrowserEnv
				? {
						write(e, t, r, i, a, o) {
							const c = [e + '=' + encodeURIComponent(t)];
							ne.isNumber(r) && c.push('expires=' + new Date(r).toGMTString());
							ne.isString(i) && c.push('path=' + i);
							ne.isString(a) && c.push('domain=' + a);
							o === true && c.push('secure');
							document.cookie = c.join('; ');
						},
						read(e) {
							const t = document.cookie.match(new RegExp('(^|;\\s*)(' + e + ')=([^;]*)'));
							return t ? decodeURIComponent(t[3]) : null;
						},
						remove(e) {
							this.write(e, '', Date.now() - 864e5);
						}
					}
				: {
						write() {},
						read() {
							return null;
						},
						remove() {}
					};
			function isAbsoluteURL(e) {
				return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
			}
			function combineURLs(e, t) {
				return t ? e.replace(/\/?\/$/, '') + '/' + t.replace(/^\/+/, '') : e;
			}
			function buildFullPath(e, t) {
				if (e && !isAbsoluteURL(t)) {
					return combineURLs(e, t);
				}
				return t;
			}
			const headersToObject = (e) => (e instanceof Me ? { ...e } : e);
			function mergeConfig(e, t) {
				t = t || {};
				const r = {};
				function getMergedValue(e, t, r, i) {
					if (ne.isPlainObject(e) && ne.isPlainObject(t)) {
						return ne.merge.call({ caseless: i }, e, t);
					} else if (ne.isPlainObject(t)) {
						return ne.merge({}, t);
					} else if (ne.isArray(t)) {
						return t.slice();
					}
					return t;
				}
				function mergeDeepProperties(e, t, r, i) {
					if (!ne.isUndefined(t)) {
						return getMergedValue(e, t, r, i);
					} else if (!ne.isUndefined(e)) {
						return getMergedValue(undefined, e, r, i);
					}
				}
				function valueFromConfig2(e, t) {
					if (!ne.isUndefined(t)) {
						return getMergedValue(undefined, t);
					}
				}
				function defaultToConfig2(e, t) {
					if (!ne.isUndefined(t)) {
						return getMergedValue(undefined, t);
					} else if (!ne.isUndefined(e)) {
						return getMergedValue(undefined, e);
					}
				}
				function mergeDirectKeys(r, i, a) {
					if (a in t) {
						return getMergedValue(r, i);
					} else if (a in e) {
						return getMergedValue(undefined, r);
					}
				}
				const i = {
					url: valueFromConfig2,
					method: valueFromConfig2,
					data: valueFromConfig2,
					baseURL: defaultToConfig2,
					transformRequest: defaultToConfig2,
					transformResponse: defaultToConfig2,
					paramsSerializer: defaultToConfig2,
					timeout: defaultToConfig2,
					timeoutMessage: defaultToConfig2,
					withCredentials: defaultToConfig2,
					withXSRFToken: defaultToConfig2,
					adapter: defaultToConfig2,
					responseType: defaultToConfig2,
					xsrfCookieName: defaultToConfig2,
					xsrfHeaderName: defaultToConfig2,
					onUploadProgress: defaultToConfig2,
					onDownloadProgress: defaultToConfig2,
					decompress: defaultToConfig2,
					maxContentLength: defaultToConfig2,
					maxBodyLength: defaultToConfig2,
					beforeRedirect: defaultToConfig2,
					transport: defaultToConfig2,
					httpAgent: defaultToConfig2,
					httpsAgent: defaultToConfig2,
					cancelToken: defaultToConfig2,
					socketPath: defaultToConfig2,
					responseEncoding: defaultToConfig2,
					validateStatus: mergeDirectKeys,
					headers: (e, t, r) => mergeDeepProperties(headersToObject(e), headersToObject(t), r, true)
				};
				ne.forEach(Object.keys(Object.assign({}, e, t)), function computeConfigValue(a) {
					const o = i[a] || mergeDeepProperties;
					const c = o(e[a], t[a], a);
					(ne.isUndefined(c) && o !== mergeDirectKeys) || (r[a] = c);
				});
				return r;
			}
			const resolveConfig = (e) => {
				const t = mergeConfig({}, e);
				let {
					data: r,
					withXSRFToken: i,
					xsrfHeaderName: a,
					xsrfCookieName: o,
					headers: c,
					auth: u
				} = t;
				t.headers = c = Me.from(c);
				t.url = buildURL(buildFullPath(t.baseURL, t.url), e.params, e.paramsSerializer);
				if (u) {
					c.set(
						'Authorization',
						'Basic ' +
							btoa(
								(u.username || '') +
									':' +
									(u.password ? unescape(encodeURIComponent(u.password)) : '')
							)
					);
				}
				let l;
				if (ne.isFormData(r)) {
					if (Ne.hasStandardBrowserEnv || Ne.hasStandardBrowserWebWorkerEnv) {
						c.setContentType(undefined);
					} else if ((l = c.getContentType()) !== false) {
						const [e, ...t] = l
							? l
									.split(';')
									.map((e) => e.trim())
									.filter(Boolean)
							: [];
						c.setContentType([e || 'multipart/form-data', ...t].join('; '));
					}
				}
				if (Ne.hasStandardBrowserEnv) {
					i && ne.isFunction(i) && (i = i(t));
					if (i || (i !== false && Fe(t.url))) {
						const e = a && o && De.read(o);
						if (e) {
							c.set(a, e);
						}
					}
				}
				return t;
			};
			const Le = typeof XMLHttpRequest !== 'undefined';
			const Ue =
				Le &&
				function (e) {
					return new Promise(function dispatchXhrRequest(t, r) {
						const i = resolveConfig(e);
						let a = i.data;
						const o = Me.from(i.headers).normalize();
						let { responseType: c, onUploadProgress: u, onDownloadProgress: l } = i;
						let d;
						let p, m;
						let g, v;
						function done() {
							g && g();
							v && v();
							i.cancelToken && i.cancelToken.unsubscribe(d);
							i.signal && i.signal.removeEventListener('abort', d);
						}
						let y = new XMLHttpRequest();
						y.open(i.method.toUpperCase(), i.url, true);
						y.timeout = i.timeout;
						function onloadend() {
							if (!y) {
								return;
							}
							const i = Me.from('getAllResponseHeaders' in y && y.getAllResponseHeaders());
							const a = !c || c === 'text' || c === 'json' ? y.responseText : y.response;
							const o = {
								data: a,
								status: y.status,
								statusText: y.statusText,
								headers: i,
								config: e,
								request: y
							};
							settle(
								function _resolve(e) {
									t(e);
									done();
								},
								function _reject(e) {
									r(e);
									done();
								},
								o
							);
							y = null;
						}
						if ('onloadend' in y) {
							y.onloadend = onloadend;
						} else {
							y.onreadystatechange = function handleLoad() {
								if (!y || y.readyState !== 4) {
									return;
								}
								if (y.status === 0 && !(y.responseURL && y.responseURL.indexOf('file:') === 0)) {
									return;
								}
								setTimeout(onloadend);
							};
						}
						y.onabort = function handleAbort() {
							if (!y) {
								return;
							}
							r(new ae('Request aborted', ae.ECONNABORTED, e, y));
							y = null;
						};
						y.onerror = function handleError() {
							r(new ae('Network Error', ae.ERR_NETWORK, e, y));
							y = null;
						};
						y.ontimeout = function handleTimeout() {
							let t = i.timeout ? 'timeout of ' + i.timeout + 'ms exceeded' : 'timeout exceeded';
							const a = i.transitional || me;
							if (i.timeoutErrorMessage) {
								t = i.timeoutErrorMessage;
							}
							r(new ae(t, a.clarifyTimeoutError ? ae.ETIMEDOUT : ae.ECONNABORTED, e, y));
							y = null;
						};
						a === undefined && o.setContentType(null);
						if ('setRequestHeader' in y) {
							ne.forEach(o.toJSON(), function setRequestHeader(e, t) {
								y.setRequestHeader(t, e);
							});
						}
						if (!ne.isUndefined(i.withCredentials)) {
							y.withCredentials = !!i.withCredentials;
						}
						if (c && c !== 'json') {
							y.responseType = i.responseType;
						}
						if (l) {
							[m, v] = progressEventReducer(l, true);
							y.addEventListener('progress', m);
						}
						if (u && y.upload) {
							[p, g] = progressEventReducer(u);
							y.upload.addEventListener('progress', p);
							y.upload.addEventListener('loadend', g);
						}
						if (i.cancelToken || i.signal) {
							d = (t) => {
								if (!y) {
									return;
								}
								r(!t || t.type ? new Ce(null, e, y) : t);
								y.abort();
								y = null;
							};
							i.cancelToken && i.cancelToken.subscribe(d);
							if (i.signal) {
								i.signal.aborted ? d() : i.signal.addEventListener('abort', d);
							}
						}
						const w = parseProtocol(i.url);
						if (w && Ne.protocols.indexOf(w) === -1) {
							r(new ae('Unsupported protocol ' + w + ':', ae.ERR_BAD_REQUEST, e));
							return;
						}
						y.send(a || null);
					});
				};
			const composeSignals = (e, t) => {
				const { length: r } = (e = e ? e.filter(Boolean) : []);
				if (t || r) {
					let r = new AbortController();
					let i;
					const onabort = function (e) {
						if (!i) {
							i = true;
							unsubscribe();
							const t = e instanceof Error ? e : this.reason;
							r.abort(t instanceof ae ? t : new Ce(t instanceof Error ? t.message : t));
						}
					};
					let a =
						t &&
						setTimeout(() => {
							a = null;
							onabort(new ae(`timeout ${t} of ms exceeded`, ae.ETIMEDOUT));
						}, t);
					const unsubscribe = () => {
						if (e) {
							a && clearTimeout(a);
							a = null;
							e.forEach((e) => {
								e.unsubscribe ? e.unsubscribe(onabort) : e.removeEventListener('abort', onabort);
							});
							e = null;
						}
					};
					e.forEach((e) => e.addEventListener('abort', onabort));
					const { signal: o } = r;
					o.unsubscribe = () => ne.asap(unsubscribe);
					return o;
				}
			};
			const je = composeSignals;
			const streamChunk = function* (e, t) {
				let r = e.byteLength;
				if (!t || r < t) {
					yield e;
					return;
				}
				let i = 0;
				let a;
				while (i < r) {
					a = i + t;
					yield e.slice(i, a);
					i = a;
				}
			};
			const readBytes = async function* (e, t) {
				for await (const r of readStream(e)) {
					yield* streamChunk(r, t);
				}
			};
			const readStream = async function* (e) {
				if (e[Symbol.asyncIterator]) {
					yield* e;
					return;
				}
				const t = e.getReader();
				try {
					for (;;) {
						const { done: e, value: r } = await t.read();
						if (e) {
							break;
						}
						yield r;
					}
				} finally {
					await t.cancel();
				}
			};
			const trackStream = (e, t, r, i) => {
				const a = readBytes(e, t);
				let o = 0;
				let c;
				let _onFinish = (e) => {
					if (!c) {
						c = true;
						i && i(e);
					}
				};
				return new ReadableStream(
					{
						async pull(e) {
							try {
								const { done: t, value: i } = await a.next();
								if (t) {
									_onFinish();
									e.close();
									return;
								}
								let c = i.byteLength;
								if (r) {
									let e = (o += c);
									r(e);
								}
								e.enqueue(new Uint8Array(i));
							} catch (e) {
								_onFinish(e);
								throw e;
							}
						},
						cancel(e) {
							_onFinish(e);
							return a.return();
						}
					},
					{ highWaterMark: 2 }
				);
			};
			const He =
				typeof fetch === 'function' &&
				typeof Request === 'function' &&
				typeof Response === 'function';
			const ze = He && typeof ReadableStream === 'function';
			const $e =
				He &&
				(typeof TextEncoder === 'function'
					? (
							(e) => (t) =>
								e.encode(t)
						)(new TextEncoder())
					: async (e) => new Uint8Array(await new Response(e).arrayBuffer()));
			const test = (e, ...t) => {
				try {
					return !!e(...t);
				} catch (e) {
					return false;
				}
			};
			const Ge =
				ze &&
				test(() => {
					let e = false;
					const t = new Request(Ne.origin, {
						body: new ReadableStream(),
						method: 'POST',
						get duplex() {
							e = true;
							return 'half';
						}
					}).headers.has('Content-Type');
					return e && !t;
				});
			const qe = 64 * 1024;
			const Ve = ze && test(() => ne.isReadableStream(new Response('').body));
			const Ke = { stream: Ve && ((e) => e.body) };
			He &&
				((e) => {
					['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach((t) => {
						!Ke[t] &&
							(Ke[t] = ne.isFunction(e[t])
								? (e) => e[t]()
								: (e, r) => {
										throw new ae(`Response type '${t}' is not supported`, ae.ERR_NOT_SUPPORT, r);
									});
					});
				})(new Response());
			const getBodyLength = async (e) => {
				if (e == null) {
					return 0;
				}
				if (ne.isBlob(e)) {
					return e.size;
				}
				if (ne.isSpecCompliantForm(e)) {
					const t = new Request(Ne.origin, { method: 'POST', body: e });
					return (await t.arrayBuffer()).byteLength;
				}
				if (ne.isArrayBufferView(e) || ne.isArrayBuffer(e)) {
					return e.byteLength;
				}
				if (ne.isURLSearchParams(e)) {
					e = e + '';
				}
				if (ne.isString(e)) {
					return (await $e(e)).byteLength;
				}
			};
			const resolveBodyLength = async (e, t) => {
				const r = ne.toFiniteNumber(e.getContentLength());
				return r == null ? getBodyLength(t) : r;
			};
			const We =
				He &&
				(async (e) => {
					let {
						url: t,
						method: r,
						data: i,
						signal: a,
						cancelToken: o,
						timeout: c,
						onDownloadProgress: u,
						onUploadProgress: l,
						responseType: d,
						headers: p,
						withCredentials: m = 'same-origin',
						fetchOptions: g
					} = resolveConfig(e);
					d = d ? (d + '').toLowerCase() : 'text';
					let v = je([a, o && o.toAbortSignal()], c);
					let y;
					const w =
						v &&
						v.unsubscribe &&
						(() => {
							v.unsubscribe();
						});
					let _;
					try {
						if (
							l &&
							Ge &&
							r !== 'get' &&
							r !== 'head' &&
							(_ = await resolveBodyLength(p, i)) !== 0
						) {
							let e = new Request(t, { method: 'POST', body: i, duplex: 'half' });
							let r;
							if (ne.isFormData(i) && (r = e.headers.get('content-type'))) {
								p.setContentType(r);
							}
							if (e.body) {
								const [t, r] = progressEventDecorator(_, progressEventReducer(asyncDecorator(l)));
								i = trackStream(e.body, qe, t, r);
							}
						}
						if (!ne.isString(m)) {
							m = m ? 'include' : 'omit';
						}
						const a = 'credentials' in Request.prototype;
						y = new Request(t, {
							...g,
							signal: v,
							method: r.toUpperCase(),
							headers: p.normalize().toJSON(),
							body: i,
							duplex: 'half',
							credentials: a ? m : undefined
						});
						let o = await fetch(y);
						const c = Ve && (d === 'stream' || d === 'response');
						if (Ve && (u || (c && w))) {
							const e = {};
							['status', 'statusText', 'headers'].forEach((t) => {
								e[t] = o[t];
							});
							const t = ne.toFiniteNumber(o.headers.get('content-length'));
							const [r, i] =
								(u && progressEventDecorator(t, progressEventReducer(asyncDecorator(u), true))) ||
								[];
							o = new Response(
								trackStream(o.body, qe, r, () => {
									i && i();
									w && w();
								}),
								e
							);
						}
						d = d || 'text';
						let A = await Ke[ne.findKey(Ke, d) || 'text'](o, e);
						!c && w && w();
						return await new Promise((t, r) => {
							settle(t, r, {
								data: A,
								headers: Me.from(o.headers),
								status: o.status,
								statusText: o.statusText,
								config: e,
								request: y
							});
						});
					} catch (t) {
						w && w();
						if (t && t.name === 'TypeError' && /fetch/i.test(t.message)) {
							throw Object.assign(new ae('Network Error', ae.ERR_NETWORK, e, y), {
								cause: t.cause || t
							});
						}
						throw ae.from(t, t && t.code, e, y);
					}
				});
			const Je = { http: oe, xhr: Ue, fetch: We };
			ne.forEach(Je, (e, t) => {
				if (e) {
					try {
						Object.defineProperty(e, 'name', { value: t });
					} catch (e) {}
					Object.defineProperty(e, 'adapterName', { value: t });
				}
			});
			const renderReason = (e) => `- ${e}`;
			const isResolvedHandle = (e) => ne.isFunction(e) || e === null || e === false;
			const Ze = {
				getAdapter: (e) => {
					e = ne.isArray(e) ? e : [e];
					const { length: t } = e;
					let r;
					let i;
					const a = {};
					for (let o = 0; o < t; o++) {
						r = e[o];
						let t;
						i = r;
						if (!isResolvedHandle(r)) {
							i = Je[(t = String(r)).toLowerCase()];
							if (i === undefined) {
								throw new ae(`Unknown adapter '${t}'`);
							}
						}
						if (i) {
							break;
						}
						a[t || '#' + o] = i;
					}
					if (!i) {
						const e = Object.entries(a).map(
							([e, t]) =>
								`adapter ${e} ` +
								(t === false
									? 'is not supported by the environment'
									: 'is not available in the build')
						);
						let r = t
							? e.length > 1
								? 'since :\n' + e.map(renderReason).join('\n')
								: ' ' + renderReason(e[0])
							: 'as no adapter specified';
						throw new ae(
							`There is no suitable adapter to dispatch the request ` + r,
							'ERR_NOT_SUPPORT'
						);
					}
					return i;
				},
				adapters: Je
			};
			function throwIfCancellationRequested(e) {
				if (e.cancelToken) {
					e.cancelToken.throwIfRequested();
				}
				if (e.signal && e.signal.aborted) {
					throw new Ce(null, e);
				}
			}
			function dispatchRequest(e) {
				throwIfCancellationRequested(e);
				e.headers = Me.from(e.headers);
				e.data = transformData.call(e, e.transformRequest);
				if (['post', 'put', 'patch'].indexOf(e.method) !== -1) {
					e.headers.setContentType('application/x-www-form-urlencoded', false);
				}
				const t = Ze.getAdapter(e.adapter || Be.adapter);
				return t(e).then(
					function onAdapterResolution(t) {
						throwIfCancellationRequested(e);
						t.data = transformData.call(e, e.transformResponse, t);
						t.headers = Me.from(t.headers);
						return t;
					},
					function onAdapterRejection(t) {
						if (!isCancel(t)) {
							throwIfCancellationRequested(e);
							if (t && t.response) {
								t.response.data = transformData.call(e, e.transformResponse, t.response);
								t.response.headers = Me.from(t.response.headers);
							}
						}
						return Promise.reject(t);
					}
				);
			}
			const Qe = '1.7.9';
			const Ye = {};
			['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((e, t) => {
				Ye[e] = function validator(r) {
					return typeof r === e || 'a' + (t < 1 ? 'n ' : ' ') + e;
				};
			});
			const Xe = {};
			Ye.transitional = function transitional(e, t, r) {
				function formatMessage(e, t) {
					return '[Axios v' + Qe + "] Transitional option '" + e + "'" + t + (r ? '. ' + r : '');
				}
				return (r, i, a) => {
					if (e === false) {
						throw new ae(
							formatMessage(i, ' has been removed' + (t ? ' in ' + t : '')),
							ae.ERR_DEPRECATED
						);
					}
					if (t && !Xe[i]) {
						Xe[i] = true;
						console.warn(
							formatMessage(
								i,
								' has been deprecated since v' + t + ' and will be removed in the near future'
							)
						);
					}
					return e ? e(r, i, a) : true;
				};
			};
			Ye.spelling = function spelling(e) {
				return (t, r) => {
					console.warn(`${r} is likely a misspelling of ${e}`);
					return true;
				};
			};
			function assertOptions(e, t, r) {
				if (typeof e !== 'object') {
					throw new ae('options must be an object', ae.ERR_BAD_OPTION_VALUE);
				}
				const i = Object.keys(e);
				let a = i.length;
				while (a-- > 0) {
					const o = i[a];
					const c = t[o];
					if (c) {
						const t = e[o];
						const r = t === undefined || c(t, o, e);
						if (r !== true) {
							throw new ae('option ' + o + ' must be ' + r, ae.ERR_BAD_OPTION_VALUE);
						}
						continue;
					}
					if (r !== true) {
						throw new ae('Unknown option ' + o, ae.ERR_BAD_OPTION);
					}
				}
			}
			const et = { assertOptions, validators: Ye };
			const tt = et.validators;
			class Axios {
				constructor(e) {
					this.defaults = e;
					this.interceptors = { request: new pe(), response: new pe() };
				}
				async request(e, t) {
					try {
						return await this._request(e, t);
					} catch (e) {
						if (e instanceof Error) {
							let t = {};
							Error.captureStackTrace ? Error.captureStackTrace(t) : (t = new Error());
							const r = t.stack ? t.stack.replace(/^.+\n/, '') : '';
							try {
								if (!e.stack) {
									e.stack = r;
								} else if (r && !String(e.stack).endsWith(r.replace(/^.+\n.+\n/, ''))) {
									e.stack += '\n' + r;
								}
							} catch (e) {}
						}
						throw e;
					}
				}
				_request(e, t) {
					if (typeof e === 'string') {
						t = t || {};
						t.url = e;
					} else {
						t = e || {};
					}
					t = mergeConfig(this.defaults, t);
					const { transitional: r, paramsSerializer: i, headers: a } = t;
					if (r !== undefined) {
						et.assertOptions(
							r,
							{
								silentJSONParsing: tt.transitional(tt.boolean),
								forcedJSONParsing: tt.transitional(tt.boolean),
								clarifyTimeoutError: tt.transitional(tt.boolean)
							},
							false
						);
					}
					if (i != null) {
						if (ne.isFunction(i)) {
							t.paramsSerializer = { serialize: i };
						} else {
							et.assertOptions(i, { encode: tt.function, serialize: tt.function }, true);
						}
					}
					et.assertOptions(
						t,
						{ baseUrl: tt.spelling('baseURL'), withXsrfToken: tt.spelling('withXSRFToken') },
						true
					);
					t.method = (t.method || this.defaults.method || 'get').toLowerCase();
					let o = a && ne.merge(a.common, a[t.method]);
					a &&
						ne.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], (e) => {
							delete a[e];
						});
					t.headers = Me.concat(o, a);
					const c = [];
					let u = true;
					this.interceptors.request.forEach(function unshiftRequestInterceptors(e) {
						if (typeof e.runWhen === 'function' && e.runWhen(t) === false) {
							return;
						}
						u = u && e.synchronous;
						c.unshift(e.fulfilled, e.rejected);
					});
					const l = [];
					this.interceptors.response.forEach(function pushResponseInterceptors(e) {
						l.push(e.fulfilled, e.rejected);
					});
					let d;
					let p = 0;
					let m;
					if (!u) {
						const e = [dispatchRequest.bind(this), undefined];
						e.unshift.apply(e, c);
						e.push.apply(e, l);
						m = e.length;
						d = Promise.resolve(t);
						while (p < m) {
							d = d.then(e[p++], e[p++]);
						}
						return d;
					}
					m = c.length;
					let g = t;
					p = 0;
					while (p < m) {
						const e = c[p++];
						const t = c[p++];
						try {
							g = e(g);
						} catch (e) {
							t.call(this, e);
							break;
						}
					}
					try {
						d = dispatchRequest.call(this, g);
					} catch (e) {
						return Promise.reject(e);
					}
					p = 0;
					m = l.length;
					while (p < m) {
						d = d.then(l[p++], l[p++]);
					}
					return d;
				}
				getUri(e) {
					e = mergeConfig(this.defaults, e);
					const t = buildFullPath(e.baseURL, e.url);
					return buildURL(t, e.params, e.paramsSerializer);
				}
			}
			ne.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(e) {
				Axios.prototype[e] = function (t, r) {
					return this.request(mergeConfig(r || {}, { method: e, url: t, data: (r || {}).data }));
				};
			});
			ne.forEach(['post', 'put', 'patch'], function forEachMethodWithData(e) {
				function generateHTTPMethod(t) {
					return function httpMethod(r, i, a) {
						return this.request(
							mergeConfig(a || {}, {
								method: e,
								headers: t ? { 'Content-Type': 'multipart/form-data' } : {},
								url: r,
								data: i
							})
						);
					};
				}
				Axios.prototype[e] = generateHTTPMethod();
				Axios.prototype[e + 'Form'] = generateHTTPMethod(true);
			});
			const rt = Axios;
			class CancelToken {
				constructor(e) {
					if (typeof e !== 'function') {
						throw new TypeError('executor must be a function.');
					}
					let t;
					this.promise = new Promise(function promiseExecutor(e) {
						t = e;
					});
					const r = this;
					this.promise.then((e) => {
						if (!r._listeners) return;
						let t = r._listeners.length;
						while (t-- > 0) {
							r._listeners[t](e);
						}
						r._listeners = null;
					});
					this.promise.then = (e) => {
						let t;
						const i = new Promise((e) => {
							r.subscribe(e);
							t = e;
						}).then(e);
						i.cancel = function reject() {
							r.unsubscribe(t);
						};
						return i;
					};
					e(function cancel(e, i, a) {
						if (r.reason) {
							return;
						}
						r.reason = new Ce(e, i, a);
						t(r.reason);
					});
				}
				throwIfRequested() {
					if (this.reason) {
						throw this.reason;
					}
				}
				subscribe(e) {
					if (this.reason) {
						e(this.reason);
						return;
					}
					if (this._listeners) {
						this._listeners.push(e);
					} else {
						this._listeners = [e];
					}
				}
				unsubscribe(e) {
					if (!this._listeners) {
						return;
					}
					const t = this._listeners.indexOf(e);
					if (t !== -1) {
						this._listeners.splice(t, 1);
					}
				}
				toAbortSignal() {
					const e = new AbortController();
					const abort = (t) => {
						e.abort(t);
					};
					this.subscribe(abort);
					e.signal.unsubscribe = () => this.unsubscribe(abort);
					return e.signal;
				}
				static source() {
					let e;
					const t = new CancelToken(function executor(t) {
						e = t;
					});
					return { token: t, cancel: e };
				}
			}
			const nt = CancelToken;
			function spread(e) {
				return function wrap(t) {
					return e.apply(null, t);
				};
			}
			function isAxiosError(e) {
				return ne.isObject(e) && e.isAxiosError === true;
			}
			const it = {
				Continue: 100,
				SwitchingProtocols: 101,
				Processing: 102,
				EarlyHints: 103,
				Ok: 200,
				Created: 201,
				Accepted: 202,
				NonAuthoritativeInformation: 203,
				NoContent: 204,
				ResetContent: 205,
				PartialContent: 206,
				MultiStatus: 207,
				AlreadyReported: 208,
				ImUsed: 226,
				MultipleChoices: 300,
				MovedPermanently: 301,
				Found: 302,
				SeeOther: 303,
				NotModified: 304,
				UseProxy: 305,
				Unused: 306,
				TemporaryRedirect: 307,
				PermanentRedirect: 308,
				BadRequest: 400,
				Unauthorized: 401,
				PaymentRequired: 402,
				Forbidden: 403,
				NotFound: 404,
				MethodNotAllowed: 405,
				NotAcceptable: 406,
				ProxyAuthenticationRequired: 407,
				RequestTimeout: 408,
				Conflict: 409,
				Gone: 410,
				LengthRequired: 411,
				PreconditionFailed: 412,
				PayloadTooLarge: 413,
				UriTooLong: 414,
				UnsupportedMediaType: 415,
				RangeNotSatisfiable: 416,
				ExpectationFailed: 417,
				ImATeapot: 418,
				MisdirectedRequest: 421,
				UnprocessableEntity: 422,
				Locked: 423,
				FailedDependency: 424,
				TooEarly: 425,
				UpgradeRequired: 426,
				PreconditionRequired: 428,
				TooManyRequests: 429,
				RequestHeaderFieldsTooLarge: 431,
				UnavailableForLegalReasons: 451,
				InternalServerError: 500,
				NotImplemented: 501,
				BadGateway: 502,
				ServiceUnavailable: 503,
				GatewayTimeout: 504,
				HttpVersionNotSupported: 505,
				VariantAlsoNegotiates: 506,
				InsufficientStorage: 507,
				LoopDetected: 508,
				NotExtended: 510,
				NetworkAuthenticationRequired: 511
			};
			Object.entries(it).forEach(([e, t]) => {
				it[t] = e;
			});
			const st = it;
			function createInstance(e) {
				const t = new rt(e);
				const r = bind(rt.prototype.request, t);
				ne.extend(r, rt.prototype, t, { allOwnKeys: true });
				ne.extend(r, t, null, { allOwnKeys: true });
				r.create = function create(t) {
					return createInstance(mergeConfig(e, t));
				};
				return r;
			}
			const at = createInstance(Be);
			at.Axios = rt;
			at.CanceledError = Ce;
			at.CancelToken = nt;
			at.isCancel = isCancel;
			at.VERSION = Qe;
			at.toFormData = le;
			at.AxiosError = ae;
			at.Cancel = at.CanceledError;
			at.all = function all(e) {
				return Promise.all(e);
			};
			at.spread = spread;
			at.isAxiosError = isAxiosError;
			at.mergeConfig = mergeConfig;
			at.AxiosHeaders = Me;
			at.formToJSON = (e) => Te(ne.isHTMLForm(e) ? new FormData(e) : e);
			at.getAdapter = Ze.getAdapter;
			at.HttpStatusCode = st;
			at.default = at;
			const ot = at;
			var ct = r(4952);
			var ut = r(716);
			var dt = r(5068);
			var ht = r(4781);
			var pt = r(5250);
			const mt = 'Ethereum Signed Message:\n';
			function message_hashMessage(e) {
				if (typeof e === 'string') {
					e = (0, pt.YW)(e);
				}
				return (0, ht.S)((0, a.xW)([(0, pt.YW)(mt), (0, pt.YW)(String(e.length)), e]));
			}
			var vt = r(1424);
			var yt = r(797);
			var bt = r(985);
			function pbkdf2(e, t, r, i, o) {
				e = (0, a.k9)(e);
				t = (0, a.k9)(t);
				let c;
				let u = 1;
				const l = new Uint8Array(i);
				const d = new Uint8Array(t.length + 4);
				d.set(t);
				let p;
				let m;
				for (let g = 1; g <= u; g++) {
					d[t.length] = (g >> 24) & 255;
					d[t.length + 1] = (g >> 16) & 255;
					d[t.length + 2] = (g >> 8) & 255;
					d[t.length + 3] = g & 255;
					let v = (0, a.k9)((0, bt.L5)(o, e, d));
					if (!c) {
						c = v.length;
						m = new Uint8Array(c);
						u = Math.ceil(i / c);
						p = i - (u - 1) * c;
					}
					m.set(v);
					for (let t = 1; t < r; t++) {
						v = (0, a.k9)((0, bt.L5)(o, e, v));
						for (let e = 0; e < c; e++) m[e] ^= v[e];
					}
					const y = (g - 1) * c;
					const w = g === u ? p : c;
					l.set((0, a.k9)(m).slice(0, w), y);
				}
				return (0, a.c$)(l);
			}
			var wt = r(3116);
			var _t = r(3013);
			var At = r(1062);
			var Et = r(3231);
			var St = r(3518);
			const kt = 'wordlists/5.7.0';
			const Nt = false;
			const Tt = new o.Vy(kt);
			class Wordlist {
				constructor(e) {
					Tt.checkAbstract(new.target, Wordlist);
					(0, wt.yY)(this, 'locale', e);
				}
				split(e) {
					return e.toLowerCase().split(/ +/g);
				}
				join(e) {
					return e.join(' ');
				}
				static check(e) {
					const t = [];
					for (let r = 0; r < 2048; r++) {
						const i = e.getWord(r);
						if (r !== e.getWordIndex(i)) {
							return '0x';
						}
						t.push(i);
					}
					return (0, St.id)(t.join('\n') + '\n');
				}
				static register(e, t) {
					if (!t) {
						t = e.locale;
					}
					if (Nt) {
						try {
							const r = window;
							if (r._ethers && r._ethers.wordlists) {
								if (!r._ethers.wordlists[t]) {
									(0, wt.yY)(r._ethers.wordlists, t, e);
								}
							}
						} catch (e) {}
					}
				}
			}
			const xt =
				'AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo';
			let Bt = null;
			function loadWords(e) {
				if (Bt != null) {
					return;
				}
				Bt = xt
					.replace(/([A-Z])/g, ' $1')
					.toLowerCase()
					.substring(1)
					.split(' ');
				if (
					Wordlist.check(e) !== '0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60'
				) {
					Bt = null;
					throw new Error('BIP39 Wordlist for en (English) FAILED');
				}
			}
			class LangEn extends Wordlist {
				constructor() {
					super('en');
				}
				getWord(e) {
					loadWords(this);
					return Bt[e];
				}
				getWordIndex(e) {
					loadWords(this);
					return Bt.indexOf(e);
				}
			}
			const Rt = new LangEn();
			Wordlist.register(Rt);
			const Pt = { en: Rt };
			const Mt = 'hdnode/5.7.0';
			const Ct = new o.Vy(Mt);
			const It = u.gH.from('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
			const Ot = (0, pt.YW)('Bitcoin seed');
			const Ft = 2147483648;
			function getUpperMask(e) {
				return ((1 << e) - 1) << (8 - e);
			}
			function getLowerMask(e) {
				return (1 << e) - 1;
			}
			function bytes32(e) {
				return (0, a.bj)((0, a.c$)(e), 32);
			}
			function base58check(e) {
				return yt.zn.encode((0, a.xW)([e, (0, a.Ab)((0, bt.sc)((0, bt.sc)(e)), 0, 4)]));
			}
			function getWordlist(e) {
				if (e == null) {
					return Pt['en'];
				}
				if (typeof e === 'string') {
					const t = Pt[e];
					if (t == null) {
						Ct.throwArgumentError('unknown locale', 'wordlist', e);
					}
					return t;
				}
				return e;
			}
			const Dt = {};
			const Lt = "m/44'/60'/0'/0/0";
			class HDNode {
				constructor(e, t, r, i, o, c, u, l) {
					if (e !== Dt) {
						throw new Error('HDNode constructor cannot be called directly');
					}
					if (t) {
						const e = new _t.hR(t);
						(0, wt.yY)(this, 'privateKey', e.privateKey);
						(0, wt.yY)(this, 'publicKey', e.compressedPublicKey);
					} else {
						(0, wt.yY)(this, 'privateKey', null);
						(0, wt.yY)(this, 'publicKey', (0, a.c$)(r));
					}
					(0, wt.yY)(this, 'parentFingerprint', i);
					(0, wt.yY)(this, 'fingerprint', (0, a.Ab)((0, bt.HE)((0, bt.sc)(this.publicKey)), 0, 4));
					(0, wt.yY)(this, 'address', (0, Et.Kt)(this.publicKey));
					(0, wt.yY)(this, 'chainCode', o);
					(0, wt.yY)(this, 'index', c);
					(0, wt.yY)(this, 'depth', u);
					if (l == null) {
						(0, wt.yY)(this, 'mnemonic', null);
						(0, wt.yY)(this, 'path', null);
					} else if (typeof l === 'string') {
						(0, wt.yY)(this, 'mnemonic', null);
						(0, wt.yY)(this, 'path', l);
					} else {
						(0, wt.yY)(this, 'mnemonic', l);
						(0, wt.yY)(this, 'path', l.path);
					}
				}
				get extendedKey() {
					if (this.depth >= 256) {
						throw new Error('Depth too large!');
					}
					return base58check(
						(0, a.xW)([
							this.privateKey != null ? '0x0488ADE4' : '0x0488B21E',
							(0, a.c$)(this.depth),
							this.parentFingerprint,
							(0, a.bj)((0, a.c$)(this.index), 4),
							this.chainCode,
							this.privateKey != null ? (0, a.xW)(['0x00', this.privateKey]) : this.publicKey
						])
					);
				}
				neuter() {
					return new HDNode(
						Dt,
						null,
						this.publicKey,
						this.parentFingerprint,
						this.chainCode,
						this.index,
						this.depth,
						this.path
					);
				}
				_derive(e) {
					if (e > 4294967295) {
						throw new Error('invalid index - ' + String(e));
					}
					let t = this.path;
					if (t) {
						t += '/' + (e & ~Ft);
					}
					const r = new Uint8Array(37);
					if (e & Ft) {
						if (!this.privateKey) {
							throw new Error('cannot derive child of neutered node');
						}
						r.set((0, a.k9)(this.privateKey), 1);
						if (t) {
							t += "'";
						}
					} else {
						r.set((0, a.k9)(this.publicKey));
					}
					for (let t = 24; t >= 0; t -= 8) {
						r[33 + (t >> 3)] = (e >> (24 - t)) & 255;
					}
					const i = (0, a.k9)((0, bt.L5)(At.q.sha512, this.chainCode, r));
					const o = i.slice(0, 32);
					const c = i.slice(32);
					let l = null;
					let d = null;
					if (this.privateKey) {
						l = bytes32(u.gH.from(o).add(this.privateKey).mod(It));
					} else {
						const e = new _t.hR((0, a.c$)(o));
						d = e._addPoint(this.publicKey);
					}
					let p = t;
					const m = this.mnemonic;
					if (m) {
						p = Object.freeze({ phrase: m.phrase, path: t, locale: m.locale || 'en' });
					}
					return new HDNode(Dt, l, d, this.fingerprint, bytes32(c), e, this.depth + 1, p);
				}
				derivePath(e) {
					const t = e.split('/');
					if (t.length === 0 || (t[0] === 'm' && this.depth !== 0)) {
						throw new Error('invalid path - ' + e);
					}
					if (t[0] === 'm') {
						t.shift();
					}
					let r = this;
					for (let e = 0; e < t.length; e++) {
						const i = t[e];
						if (i.match(/^[0-9]+'$/)) {
							const e = parseInt(i.substring(0, i.length - 1));
							if (e >= Ft) {
								throw new Error('invalid path index - ' + i);
							}
							r = r._derive(Ft + e);
						} else if (i.match(/^[0-9]+$/)) {
							const e = parseInt(i);
							if (e >= Ft) {
								throw new Error('invalid path index - ' + i);
							}
							r = r._derive(e);
						} else {
							throw new Error('invalid path component - ' + i);
						}
					}
					return r;
				}
				static _fromSeed(e, t) {
					const r = (0, a.k9)(e);
					if (r.length < 16 || r.length > 64) {
						throw new Error('invalid seed');
					}
					const i = (0, a.k9)((0, bt.L5)(At.q.sha512, Ot, r));
					return new HDNode(
						Dt,
						bytes32(i.slice(0, 32)),
						null,
						'0x00000000',
						bytes32(i.slice(32)),
						0,
						0,
						t
					);
				}
				static fromMnemonic(e, t, r) {
					r = getWordlist(r);
					e = entropyToMnemonic(mnemonicToEntropy(e, r), r);
					return HDNode._fromSeed(mnemonicToSeed(e, t), { phrase: e, path: 'm', locale: r.locale });
				}
				static fromSeed(e) {
					return HDNode._fromSeed(e, null);
				}
				static fromExtendedKey(e) {
					const t = yt.zn.decode(e);
					if (t.length !== 82 || base58check(t.slice(0, 78)) !== e) {
						Ct.throwArgumentError('invalid extended key', 'extendedKey', '[REDACTED]');
					}
					const r = t[4];
					const i = (0, a.c$)(t.slice(5, 9));
					const o = parseInt((0, a.c$)(t.slice(9, 13)).substring(2), 16);
					const c = (0, a.c$)(t.slice(13, 45));
					const u = t.slice(45, 78);
					switch ((0, a.c$)(t.slice(0, 4))) {
						case '0x0488b21e':
						case '0x043587cf':
							return new HDNode(Dt, null, (0, a.c$)(u), i, c, o, r, null);
						case '0x0488ade4':
						case '0x04358394 ':
							if (u[0] !== 0) {
								break;
							}
							return new HDNode(Dt, (0, a.c$)(u.slice(1)), null, i, c, o, r, null);
					}
					return Ct.throwArgumentError('invalid extended key', 'extendedKey', '[REDACTED]');
				}
			}
			function mnemonicToSeed(e, t) {
				if (!t) {
					t = '';
				}
				const r = (0, pt.YW)('mnemonic' + t, pt.dz.NFKD);
				return pbkdf2((0, pt.YW)(e, pt.dz.NFKD), r, 2048, 64, 'sha512');
			}
			function mnemonicToEntropy(e, t) {
				t = getWordlist(t);
				Ct.checkNormalize();
				const r = t.split(e);
				if (r.length % 3 !== 0) {
					throw new Error('invalid mnemonic');
				}
				const i = (0, a.k9)(new Uint8Array(Math.ceil((11 * r.length) / 8)));
				let o = 0;
				for (let e = 0; e < r.length; e++) {
					let a = t.getWordIndex(r[e].normalize('NFKD'));
					if (a === -1) {
						throw new Error('invalid mnemonic');
					}
					for (let e = 0; e < 11; e++) {
						if (a & (1 << (10 - e))) {
							i[o >> 3] |= 1 << (7 - (o % 8));
						}
						o++;
					}
				}
				const c = (32 * r.length) / 3;
				const u = r.length / 3;
				const l = getUpperMask(u);
				const d = (0, a.k9)((0, bt.sc)(i.slice(0, c / 8)))[0] & l;
				if (d !== (i[i.length - 1] & l)) {
					throw new Error('invalid checksum');
				}
				return (0, a.c$)(i.slice(0, c / 8));
			}
			function entropyToMnemonic(e, t) {
				t = getWordlist(t);
				e = (0, a.k9)(e);
				if (e.length % 4 !== 0 || e.length < 16 || e.length > 32) {
					throw new Error('invalid entropy');
				}
				const r = [0];
				let i = 11;
				for (let t = 0; t < e.length; t++) {
					if (i > 8) {
						r[r.length - 1] <<= 8;
						r[r.length - 1] |= e[t];
						i -= 8;
					} else {
						r[r.length - 1] <<= i;
						r[r.length - 1] |= e[t] >> (8 - i);
						r.push(e[t] & getLowerMask(8 - i));
						i += 3;
					}
				}
				const o = e.length / 4;
				const c = (0, a.k9)((0, bt.sc)(e))[0] & getUpperMask(o);
				r[r.length - 1] <<= o;
				r[r.length - 1] |= c >> (8 - o);
				return t.join(r.map((e) => t.getWord(e)));
			}
			function isValidMnemonic(e, t) {
				try {
					mnemonicToEntropy(e, t);
					return true;
				} catch (e) {}
				return false;
			}
			function getAccountPath(e) {
				if (typeof e !== 'number' || e < 0 || e >= Ft || e % 1) {
					Ct.throwArgumentError('invalid account index', 'index', e);
				}
				return `m/44'/60'/${e}'/0/0`;
			}
			const Ut = 'random/5.7.0';
			const jt = new o.Vy(Ut);
			function getGlobal() {
				if (typeof self !== 'undefined') {
					return self;
				}
				if (typeof window !== 'undefined') {
					return window;
				}
				if (typeof r.g !== 'undefined') {
					return r.g;
				}
				throw new Error('unable to locate global object');
			}
			const Ht = getGlobal();
			let zt = Ht.crypto || Ht.msCrypto;
			if (!zt || !zt.getRandomValues) {
				jt.warn('WARNING: Missing strong random number source');
				zt = {
					getRandomValues: function (e) {
						return jt.throwError(
							'no secure random source avaialble',
							o.Vy.errors.UNSUPPORTED_OPERATION,
							{ operation: 'crypto.getRandomValues' }
						);
					}
				};
			}
			function randomBytes(e) {
				if (e <= 0 || e > 1024 || e % 1 || e != e) {
					jt.throwArgumentError('invalid length', 'length', e);
				}
				const t = new Uint8Array(e);
				zt.getRandomValues(t);
				return (0, a.k9)(t);
			}
			var $t = r(6139);
			var Gt = r.n($t);
			var qt = r(4923);
			var Vt = r.n(qt);
			function looseArrayify(e) {
				if (typeof e === 'string' && e.substring(0, 2) !== '0x') {
					e = '0x' + e;
				}
				return (0, a.k9)(e);
			}
			function zpad(e, t) {
				e = String(e);
				while (e.length < t) {
					e = '0' + e;
				}
				return e;
			}
			function getPassword(e) {
				if (typeof e === 'string') {
					return (0, pt.YW)(e, pt.dz.NFKC);
				}
				return (0, a.k9)(e);
			}
			function searchPath(e, t) {
				let r = e;
				const i = t.toLowerCase().split('/');
				for (let e = 0; e < i.length; e++) {
					let t = null;
					for (const a in r) {
						if (a.toLowerCase() === i[e]) {
							t = r[a];
							break;
						}
					}
					if (t === null) {
						return null;
					}
					r = t;
				}
				return r;
			}
			function uuidV4(e) {
				const t = (0, a.k9)(e);
				t[6] = (t[6] & 15) | 64;
				t[8] = (t[8] & 63) | 128;
				const r = (0, a.c$)(t);
				return [
					r.substring(2, 10),
					r.substring(10, 14),
					r.substring(14, 18),
					r.substring(18, 22),
					r.substring(22, 34)
				].join('-');
			}
			const Kt = 'json-wallets/5.7.0';
			var Wt =
				(undefined && undefined.__awaiter) ||
				function (e, t, r, i) {
					function adopt(e) {
						return e instanceof r
							? e
							: new r(function (t) {
									t(e);
								});
					}
					return new (r || (r = Promise))(function (r, a) {
						function fulfilled(e) {
							try {
								step(i.next(e));
							} catch (e) {
								a(e);
							}
						}
						function rejected(e) {
							try {
								step(i['throw'](e));
							} catch (e) {
								a(e);
							}
						}
						function step(e) {
							e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected);
						}
						step((i = i.apply(e, t || [])).next());
					});
				};
			const Jt = new o.Vy(Kt);
			function hasMnemonic(e) {
				return e != null && e.mnemonic && e.mnemonic.phrase;
			}
			class KeystoreAccount extends wt.VY {
				isKeystoreAccount(e) {
					return !!(e && e._isKeystoreAccount);
				}
			}
			function _decrypt(e, t, r) {
				const i = searchPath(e, 'crypto/cipher');
				if (i === 'aes-128-ctr') {
					const i = looseArrayify(searchPath(e, 'crypto/cipherparams/iv'));
					const o = new (Gt().Counter)(i);
					const c = new (Gt().ModeOfOperation.ctr)(t, o);
					return (0, a.k9)(c.decrypt(r));
				}
				return null;
			}
			function _getAccount(e, t) {
				const r = looseArrayify(searchPath(e, 'crypto/ciphertext'));
				const i = (0, a.c$)((0, ht.S)((0, a.xW)([t.slice(16, 32), r]))).substring(2);
				if (i !== searchPath(e, 'crypto/mac').toLowerCase()) {
					throw new Error('invalid password');
				}
				const c = _decrypt(e, t.slice(0, 16), r);
				if (!c) {
					Jt.throwError('unsupported cipher', o.Vy.errors.UNSUPPORTED_OPERATION, {
						operation: 'decrypt'
					});
				}
				const u = t.slice(32, 64);
				const l = (0, Et.Kt)(c);
				if (e.address) {
					let t = e.address.toLowerCase();
					if (t.substring(0, 2) !== '0x') {
						t = '0x' + t;
					}
					if ((0, ut.bv)(t) !== l) {
						throw new Error('address mismatch');
					}
				}
				const d = { _isKeystoreAccount: true, address: l, privateKey: (0, a.c$)(c) };
				if (searchPath(e, 'x-ethers/version') === '0.1') {
					const t = looseArrayify(searchPath(e, 'x-ethers/mnemonicCiphertext'));
					const r = looseArrayify(searchPath(e, 'x-ethers/mnemonicCounter'));
					const i = new (Gt().Counter)(r);
					const c = new (Gt().ModeOfOperation.ctr)(u, i);
					const l = searchPath(e, 'x-ethers/path') || Lt;
					const p = searchPath(e, 'x-ethers/locale') || 'en';
					const m = (0, a.k9)(c.decrypt(t));
					try {
						const e = entropyToMnemonic(m, p);
						const t = HDNode.fromMnemonic(e, null, p).derivePath(l);
						if (t.privateKey != d.privateKey) {
							throw new Error('mnemonic mismatch');
						}
						d.mnemonic = t.mnemonic;
					} catch (e) {
						if (e.code !== o.Vy.errors.INVALID_ARGUMENT || e.argument !== 'wordlist') {
							throw e;
						}
					}
				}
				return new KeystoreAccount(d);
			}
			function pbkdf2Sync(e, t, r, i, o) {
				return (0, a.k9)(pbkdf2(e, t, r, i, o));
			}
			function keystore_pbkdf2(e, t, r, i, a) {
				return Promise.resolve(pbkdf2Sync(e, t, r, i, a));
			}
			function _computeKdfKey(e, t, r, i, a) {
				const o = getPassword(t);
				const c = searchPath(e, 'crypto/kdf');
				if (c && typeof c === 'string') {
					const throwError = function (e, t) {
						return Jt.throwArgumentError('invalid key-derivation function parameters', e, t);
					};
					if (c.toLowerCase() === 'scrypt') {
						const t = looseArrayify(searchPath(e, 'crypto/kdfparams/salt'));
						const r = parseInt(searchPath(e, 'crypto/kdfparams/n'));
						const u = parseInt(searchPath(e, 'crypto/kdfparams/r'));
						const l = parseInt(searchPath(e, 'crypto/kdfparams/p'));
						if (!r || !u || !l) {
							throwError('kdf', c);
						}
						if ((r & (r - 1)) !== 0) {
							throwError('N', r);
						}
						const d = parseInt(searchPath(e, 'crypto/kdfparams/dklen'));
						if (d !== 32) {
							throwError('dklen', d);
						}
						return i(o, t, r, u, l, 64, a);
					} else if (c.toLowerCase() === 'pbkdf2') {
						const t = looseArrayify(searchPath(e, 'crypto/kdfparams/salt'));
						let i = null;
						const a = searchPath(e, 'crypto/kdfparams/prf');
						if (a === 'hmac-sha256') {
							i = 'sha256';
						} else if (a === 'hmac-sha512') {
							i = 'sha512';
						} else {
							throwError('prf', a);
						}
						const c = parseInt(searchPath(e, 'crypto/kdfparams/c'));
						const u = parseInt(searchPath(e, 'crypto/kdfparams/dklen'));
						if (u !== 32) {
							throwError('dklen', u);
						}
						return r(o, t, c, u, i);
					}
				}
				return Jt.throwArgumentError('unsupported key-derivation function', 'kdf', c);
			}
			function decryptSync(e, t) {
				const r = JSON.parse(e);
				const i = _computeKdfKey(r, t, pbkdf2Sync, Vt().syncScrypt);
				return _getAccount(r, i);
			}
			function decrypt(e, t, r) {
				return Wt(this, void 0, void 0, function* () {
					const i = JSON.parse(e);
					const a = yield _computeKdfKey(i, t, keystore_pbkdf2, Vt().scrypt, r);
					return _getAccount(i, a);
				});
			}
			function encrypt(e, t, r, i) {
				try {
					if ((0, ut.bv)(e.address) !== (0, Et.Kt)(e.privateKey)) {
						throw new Error('address/privateKey mismatch');
					}
					if (hasMnemonic(e)) {
						const t = e.mnemonic;
						const r = HDNode.fromMnemonic(t.phrase, null, t.locale).derivePath(t.path || Lt);
						if (r.privateKey != e.privateKey) {
							throw new Error('mnemonic mismatch');
						}
					}
				} catch (e) {
					return Promise.reject(e);
				}
				if (typeof r === 'function' && !i) {
					i = r;
					r = {};
				}
				if (!r) {
					r = {};
				}
				const o = (0, a.k9)(e.privateKey);
				const c = getPassword(t);
				let u = null;
				let l = null;
				let d = null;
				if (hasMnemonic(e)) {
					const t = e.mnemonic;
					u = (0, a.k9)(mnemonicToEntropy(t.phrase, t.locale || 'en'));
					l = t.path || Lt;
					d = t.locale || 'en';
				}
				let p = r.client;
				if (!p) {
					p = 'ethers.js';
				}
				let m = null;
				if (r.salt) {
					m = (0, a.k9)(r.salt);
				} else {
					m = randomBytes(32);
				}
				let g = null;
				if (r.iv) {
					g = (0, a.k9)(r.iv);
					if (g.length !== 16) {
						throw new Error('invalid iv');
					}
				} else {
					g = randomBytes(16);
				}
				let v = null;
				if (r.uuid) {
					v = (0, a.k9)(r.uuid);
					if (v.length !== 16) {
						throw new Error('invalid uuid');
					}
				} else {
					v = randomBytes(16);
				}
				let y = 1 << 17,
					w = 8,
					_ = 1;
				if (r.scrypt) {
					if (r.scrypt.N) {
						y = r.scrypt.N;
					}
					if (r.scrypt.r) {
						w = r.scrypt.r;
					}
					if (r.scrypt.p) {
						_ = r.scrypt.p;
					}
				}
				return Vt()
					.scrypt(c, m, y, w, _, 64, i)
					.then((t) => {
						t = (0, a.k9)(t);
						const r = t.slice(0, 16);
						const i = t.slice(16, 32);
						const c = t.slice(32, 64);
						const A = new (Gt().Counter)(g);
						const k = new (Gt().ModeOfOperation.ctr)(r, A);
						const N = (0, a.k9)(k.encrypt(o));
						const T = (0, ht.S)((0, a.xW)([i, N]));
						const x = {
							address: e.address.substring(2).toLowerCase(),
							id: uuidV4(v),
							version: 3,
							crypto: {
								cipher: 'aes-128-ctr',
								cipherparams: { iv: (0, a.c$)(g).substring(2) },
								ciphertext: (0, a.c$)(N).substring(2),
								kdf: 'scrypt',
								kdfparams: { salt: (0, a.c$)(m).substring(2), n: y, dklen: 32, p: _, r: w },
								mac: T.substring(2)
							}
						};
						if (u) {
							const e = randomBytes(16);
							const t = new (Gt().Counter)(e);
							const r = new (Gt().ModeOfOperation.ctr)(c, t);
							const i = (0, a.k9)(r.encrypt(u));
							const o = new Date();
							const m =
								o.getUTCFullYear() +
								'-' +
								zpad(o.getUTCMonth() + 1, 2) +
								'-' +
								zpad(o.getUTCDate(), 2) +
								'T' +
								zpad(o.getUTCHours(), 2) +
								'-' +
								zpad(o.getUTCMinutes(), 2) +
								'-' +
								zpad(o.getUTCSeconds(), 2) +
								'.0Z';
							x['x-ethers'] = {
								client: p,
								gethFilename: 'UTC--' + m + '--' + x.address,
								mnemonicCounter: (0, a.c$)(e).substring(2),
								mnemonicCiphertext: (0, a.c$)(i).substring(2),
								path: l,
								locale: d,
								version: '0.1'
							};
						}
						return JSON.stringify(x);
					});
			}
			const Zt = new o.Vy(Kt);
			class CrowdsaleAccount extends wt.VY {
				isCrowdsaleAccount(e) {
					return !!(e && e._isCrowdsaleAccount);
				}
			}
			function crowdsale_decrypt(e, t) {
				const r = JSON.parse(e);
				t = getPassword(t);
				const i = (0, ut.bv)(searchPath(r, 'ethaddr'));
				const o = looseArrayify(searchPath(r, 'encseed'));
				if (!o || o.length % 16 !== 0) {
					Zt.throwArgumentError('invalid encseed', 'json', e);
				}
				const c = (0, a.k9)(pbkdf2(t, t, 2e3, 32, 'sha256')).slice(0, 16);
				const u = o.slice(0, 16);
				const l = o.slice(16);
				const d = new (Gt().ModeOfOperation.cbc)(c, u);
				const p = Gt().padding.pkcs7.strip((0, a.k9)(d.decrypt(l)));
				let m = '';
				for (let e = 0; e < p.length; e++) {
					m += String.fromCharCode(p[e]);
				}
				const g = (0, pt.YW)(m);
				const v = (0, ht.S)(g);
				return new CrowdsaleAccount({ _isCrowdsaleAccount: true, address: i, privateKey: v });
			}
			function isCrowdsaleWallet(e) {
				let t = null;
				try {
					t = JSON.parse(e);
				} catch (e) {
					return false;
				}
				return t.encseed && t.ethaddr;
			}
			function isKeystoreWallet(e) {
				let t = null;
				try {
					t = JSON.parse(e);
				} catch (e) {
					return false;
				}
				if (!t.version || parseInt(t.version) !== t.version || parseInt(t.version) !== 3) {
					return false;
				}
				return true;
			}
			function getJsonWalletAddress(e) {
				if (isCrowdsaleWallet(e)) {
					try {
						return getAddress(JSON.parse(e).ethaddr);
					} catch (e) {
						return null;
					}
				}
				if (isKeystoreWallet(e)) {
					try {
						return getAddress(JSON.parse(e).address);
					} catch (e) {
						return null;
					}
				}
				return null;
			}
			function decryptJsonWallet(e, t, r) {
				if (isCrowdsaleWallet(e)) {
					if (r) {
						r(0);
					}
					const i = crowdsale_decrypt(e, t);
					if (r) {
						r(1);
					}
					return Promise.resolve(i);
				}
				if (isKeystoreWallet(e)) {
					return decrypt(e, t, r);
				}
				return Promise.reject(new Error('invalid JSON wallet'));
			}
			function decryptJsonWalletSync(e, t) {
				if (isCrowdsaleWallet(e)) {
					return crowdsale_decrypt(e, t);
				}
				if (isKeystoreWallet(e)) {
					return decryptSync(e, t);
				}
				throw new Error('invalid JSON wallet');
			}
			const Qt = 'wallet/5.7.0';
			var Yt =
				(undefined && undefined.__awaiter) ||
				function (e, t, r, i) {
					function adopt(e) {
						return e instanceof r
							? e
							: new r(function (t) {
									t(e);
								});
					}
					return new (r || (r = Promise))(function (r, a) {
						function fulfilled(e) {
							try {
								step(i.next(e));
							} catch (e) {
								a(e);
							}
						}
						function rejected(e) {
							try {
								step(i['throw'](e));
							} catch (e) {
								a(e);
							}
						}
						function step(e) {
							e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected);
						}
						step((i = i.apply(e, t || [])).next());
					});
				};
			const Xt = new o.Vy(Qt);
			function isAccount(e) {
				return e != null && (0, a.Lo)(e.privateKey, 32) && e.address != null;
			}
			function lib_esm_hasMnemonic(e) {
				const t = e.mnemonic;
				return t && t.phrase;
			}
			class lib_esm_Wallet extends dt.l {
				constructor(e, t) {
					super();
					if (isAccount(e)) {
						const t = new _t.hR(e.privateKey);
						(0, wt.yY)(this, '_signingKey', () => t);
						(0, wt.yY)(this, 'address', (0, Et.Kt)(this.publicKey));
						if (this.address !== (0, ut.bv)(e.address)) {
							Xt.throwArgumentError('privateKey/address mismatch', 'privateKey', '[REDACTED]');
						}
						if (lib_esm_hasMnemonic(e)) {
							const t = e.mnemonic;
							(0, wt.yY)(this, '_mnemonic', () => ({
								phrase: t.phrase,
								path: t.path || Lt,
								locale: t.locale || 'en'
							}));
							const r = this.mnemonic;
							const i = HDNode.fromMnemonic(r.phrase, null, r.locale).derivePath(r.path);
							if ((0, Et.Kt)(i.privateKey) !== this.address) {
								Xt.throwArgumentError('mnemonic/address mismatch', 'privateKey', '[REDACTED]');
							}
						} else {
							(0, wt.yY)(this, '_mnemonic', () => null);
						}
					} else {
						if (_t.hR.isSigningKey(e)) {
							if (e.curve !== 'secp256k1') {
								Xt.throwArgumentError(
									'unsupported curve; must be secp256k1',
									'privateKey',
									'[REDACTED]'
								);
							}
							(0, wt.yY)(this, '_signingKey', () => e);
						} else {
							if (typeof e === 'string') {
								if (e.match(/^[0-9a-f]*$/i) && e.length === 64) {
									e = '0x' + e;
								}
							}
							const t = new _t.hR(e);
							(0, wt.yY)(this, '_signingKey', () => t);
						}
						(0, wt.yY)(this, '_mnemonic', () => null);
						(0, wt.yY)(this, 'address', (0, Et.Kt)(this.publicKey));
					}
					if (t && !ct.Kq.isProvider(t)) {
						Xt.throwArgumentError('invalid provider', 'provider', t);
					}
					(0, wt.yY)(this, 'provider', t || null);
				}
				get mnemonic() {
					return this._mnemonic();
				}
				get privateKey() {
					return this._signingKey().privateKey;
				}
				get publicKey() {
					return this._signingKey().publicKey;
				}
				getAddress() {
					return Promise.resolve(this.address);
				}
				connect(e) {
					return new lib_esm_Wallet(this, e);
				}
				signTransaction(e) {
					return (0, wt.k_)(e).then((t) => {
						if (t.from != null) {
							if ((0, ut.bv)(t.from) !== this.address) {
								Xt.throwArgumentError(
									'transaction from address mismatch',
									'transaction.from',
									e.from
								);
							}
							delete t.from;
						}
						const r = this._signingKey().signDigest((0, ht.S)((0, Et.lK)(t)));
						return (0, Et.lK)(t, r);
					});
				}
				signMessage(e) {
					return Yt(this, void 0, void 0, function* () {
						return (0, a.FU)(this._signingKey().signDigest(message_hashMessage(e)));
					});
				}
				_signTypedData(e, t, r) {
					return Yt(this, void 0, void 0, function* () {
						const i = yield vt.z.resolveNames(e, t, r, (e) => {
							if (this.provider == null) {
								Xt.throwError(
									'cannot resolve ENS names without a provider',
									o.Vy.errors.UNSUPPORTED_OPERATION,
									{ operation: 'resolveName', value: e }
								);
							}
							return this.provider.resolveName(e);
						});
						return (0, a.FU)(this._signingKey().signDigest(vt.z.hash(i.domain, t, i.value)));
					});
				}
				encrypt(e, t, r) {
					if (typeof t === 'function' && !r) {
						r = t;
						t = {};
					}
					if (r && typeof r !== 'function') {
						throw new Error('invalid callback');
					}
					if (!t) {
						t = {};
					}
					return encrypt(this, e, t, r);
				}
				static createRandom(e) {
					let t = randomBytes(16);
					if (!e) {
						e = {};
					}
					if (e.extraEntropy) {
						t = (0, a.k9)((0, a.Ab)((0, ht.S)((0, a.xW)([t, e.extraEntropy])), 0, 16));
					}
					const r = entropyToMnemonic(t, e.locale);
					return lib_esm_Wallet.fromMnemonic(r, e.path, e.locale);
				}
				static fromEncryptedJson(e, t, r) {
					return decryptJsonWallet(e, t, r).then((e) => new lib_esm_Wallet(e));
				}
				static fromEncryptedJsonSync(e, t) {
					return new lib_esm_Wallet(decryptJsonWalletSync(e, t));
				}
				static fromMnemonic(e, t, r) {
					if (!t) {
						t = Lt;
					}
					return new lib_esm_Wallet(HDNode.fromMnemonic(e, null, r).derivePath(t));
				}
			}
			function verifyMessage(e, t) {
				return recoverAddress(hashMessage(e), t);
			}
			function verifyTypedData(e, t, r, i) {
				return recoverAddress(_TypedDataEncoder.hash(e, t, r), i);
			}
			var er;
			(function (e) {
				e['ETH_MAINNET'] = 'eth-mainnet';
				e['ETH_GOERLI'] = 'eth-goerli';
				e['ETH_SEPOLIA'] = 'eth-sepolia';
				e['ETH_HOLESKY'] = 'eth-holesky';
				e['OPT_MAINNET'] = 'opt-mainnet';
				e['OPT_GOERLI'] = 'opt-goerli';
				e['OPT_SEPOLIA'] = 'opt-sepolia';
				e['ARB_MAINNET'] = 'arb-mainnet';
				e['ARB_GOERLI'] = 'arb-goerli';
				e['ARB_SEPOLIA'] = 'arb-sepolia';
				e['MATIC_MAINNET'] = 'polygon-mainnet';
				e['MATIC_MUMBAI'] = 'polygon-mumbai';
				e['MATIC_AMOY'] = 'polygon-amoy';
				e['ASTAR_MAINNET'] = 'astar-mainnet';
				e['POLYGONZKEVM_MAINNET'] = 'polygonzkevm-mainnet';
				e['POLYGONZKEVM_TESTNET'] = 'polygonzkevm-testnet';
				e['POLYGONZKEVM_CARDONA'] = 'polygonzkevm-cardona';
				e['BASE_MAINNET'] = 'base-mainnet';
				e['BASE_GOERLI'] = 'base-goerli';
				e['BASE_SEPOLIA'] = 'base-sepolia';
				e['ZKSYNC_MAINNET'] = 'zksync-mainnet';
				e['ZKSYNC_SEPOLIA'] = 'zksync-sepolia';
				e['SHAPE_MAINNET'] = 'shape-mainnet';
				e['SHAPE_SEPOLIA'] = 'shape-sepolia';
				e['LINEA_MAINNET'] = 'linea-mainnet';
				e['LINEA_SEPOLIA'] = 'linea-sepolia';
				e['FANTOM_MAINNET'] = 'fantom-mainnet';
				e['FANTOM_TESTNET'] = 'fantom-testnet';
				e['ZETACHAIN_MAINNET'] = 'zetachain-mainnet';
				e['ZETACHAIN_TESTNET'] = 'zetachain-testnet';
				e['ARBNOVA_MAINNET'] = 'arbnova-mainnet';
				e['BLAST_MAINNET'] = 'blast-mainnet';
				e['BLAST_SEPOLIA'] = 'blast-sepolia';
				e['MANTLE_MAINNET'] = 'mantle-mainnet';
				e['MANTLE_SEPOLIA'] = 'mantle-sepolia';
				e['SCROLL_MAINNET'] = 'scroll-mainnet';
				e['SCROLL_SEPOLIA'] = 'scroll-sepolia';
				e['GNOSIS_MAINNET'] = 'gnosis-mainnet';
				e['GNOSIS_CHIADO'] = 'gnosis-chiado';
				e['BNB_MAINNET'] = 'bnb-mainnet';
				e['BNB_TESTNET'] = 'bnb-testnet';
				e['AVAX_MAINNET'] = 'avax-mainnet';
				e['AVAX_FUJI'] = 'avax-fuji';
				e['CELO_MAINNET'] = 'celo-mainnet';
				e['CELO_ALFAJORES'] = 'celo-alfajores';
				e['METIS_MAINNET'] = 'metis-mainnet';
				e['OPBNB_MAINNET'] = 'opbnb-mainnet';
				e['OPBNB_TESTNET'] = 'opbnb-testnet';
				e['BERACHAIN_BARTIO'] = 'berachain-bartio';
				e['SONEIUM_MAINNET'] = 'soneium-mainnet';
				e['SONEIUM_MINATO'] = 'soneium-minato';
				e['WORLDCHAIN_MAINNET'] = 'worldchain-mainnet';
				e['WORLDCHAIN_SEPOLIA'] = 'worldchain-sepolia';
				e['ROOTSTOCK_MAINNET'] = 'rootstock-mainnet';
				e['ROOTSTOCK_TESTNET'] = 'rootstock-testnet';
				e['FLOW_MAINNET'] = 'flow-mainnet';
				e['FLOW_TESTNET'] = 'flow-testnet';
				e['ZORA_MAINNET'] = 'zora-mainnet';
				e['ZORA_SEPOLIA'] = 'zora-sepolia';
				e['FRAX_MAINNET'] = 'frax-mainnet';
				e['FRAX_SEPOLIA'] = 'frax-sepolia';
				e['POLYNOMIAL_MAINNET'] = 'polynomial-mainnet';
				e['POLYNOMIAL_SEPOLIA'] = 'polynomial-sepolia';
				e['CROSSFI_MAINNET'] = 'crossfi-mainnet';
				e['CROSSFI_TESTNET'] = 'crossfi-testnet';
				e['APECHAIN_MAINNET'] = 'apechain-mainnet';
				e['APECHAIN_CURTIS'] = 'apechain-curtis';
				e['LENS_SEPOLIA'] = 'lens-sepolia';
				e['GEIST_MAINNET'] = 'geist-mainnet';
				e['GEIST_POLTER'] = 'geist-polter';
				e['LUMIA_PRISM'] = 'lumia-prism';
				e['LUMIA_TESTNET'] = 'lumia-testnet';
				e['UNICHAIN_SEPOLIA'] = 'unichain-sepolia';
				e['SONIC_MAINNET'] = 'sonic-mainnet';
				e['SONIC_BLAZE'] = 'sonic-blaze';
				e['XMTP_TESTNET'] = 'xmtp-testnet';
				e['ABSTRACT_TESTNET'] = 'abstract-testnet';
				e['DEGEN_MAINNET'] = 'degen-mainnet';
				e['INK_MAINNET'] = 'ink-mainnet';
				e['INK_SEPOLIA'] = 'ink-sepolia';
			})(er || (er = {}));
			var tr;
			(function (e) {
				e['DEFAULT_TOKENS'] = 'DEFAULT_TOKENS';
				e['ERC20'] = 'erc20';
			})(tr || (tr = {}));
			var rr;
			(function (e) {
				e['EXTERNAL'] = 'external';
				e['INTERNAL'] = 'internal';
				e['ERC20'] = 'erc20';
				e['ERC721'] = 'erc721';
				e['ERC1155'] = 'erc1155';
				e['SPECIALNFT'] = 'specialnft';
			})(rr || (rr = {}));
			var nr;
			(function (e) {
				e['TO'] = 'TO';
				e['FROM'] = 'FROM';
			})(nr || (nr = {}));
			var ir;
			(function (e) {
				e['ASCENDING'] = 'asc';
				e['DESCENDING'] = 'desc';
			})(ir || (ir = {}));
			var sr;
			(function (e) {
				e['VERIFIED'] = 'verified';
				e['APPROVED'] = 'approved';
				e['REQUESTED'] = 'requested';
				e['NOT_REQUESTED'] = 'not_requested';
			})(sr || (sr = {}));
			var ar;
			(function (e) {
				e['PENDING_TRANSACTIONS'] = 'alchemy_pendingTransactions';
				e['MINED_TRANSACTIONS'] = 'alchemy_minedTransactions';
			})(ar || (ar = {}));
			var cr;
			(function (e) {
				e['NATIVE'] = 'NATIVE';
				e['ERC20'] = 'ERC20';
				e['ERC721'] = 'ERC721';
				e['ERC1155'] = 'ERC1155';
				e['SPECIAL_NFT'] = 'SPECIAL_NFT';
			})(cr || (cr = {}));
			var fr;
			(function (e) {
				e['APPROVE'] = 'APPROVE';
				e['TRANSFER'] = 'TRANSFER';
			})(fr || (fr = {}));
			var ur;
			(function (e) {
				e['ETHERSCAN'] = 'ETHERSCAN';
			})(ur || (ur = {}));
			var lr;
			(function (e) {
				e['CREATE'] = 'CREATE';
				e['CALL'] = 'CALL';
				e['STATICCALL'] = 'STATICCALL';
				e['DELEGATECALL'] = 'DELEGATECALL';
			})(lr || (lr = {}));
			var dr;
			(function (e) {
				e['UNSPECIFIED'] = 'TRANSACTION_JOB_STATUS_UNSPECIFIED';
				e['IN_PROGRESS'] = 'IN_PROGRESS';
				e['COMPLETE'] = 'COMPLETE';
				e['ABANDONED'] = 'ABANDONED';
			})(dr || (dr = {}));
			var hr;
			(function (e) {
				e['V1'] = 'V1';
				e['V2'] = 'V2';
			})(hr || (hr = {}));
			var pr;
			(function (e) {
				e['MINED_TRANSACTION'] = 'MINED_TRANSACTION';
				e['DROPPED_TRANSACTION'] = 'DROPPED_TRANSACTION';
				e['ADDRESS_ACTIVITY'] = 'ADDRESS_ACTIVITY';
				e['NFT_ACTIVITY'] = 'NFT_ACTIVITY';
				e['NFT_METADATA_UPDATE'] = 'NFT_METADATA_UPDATE';
				e['GRAPHQL'] = 'GRAPHQL';
			})(pr || (pr = {}));
			var mr;
			(function (e) {
				e['PENDING'] = 'pending';
				e['LATEST'] = 'latest';
				e['SAFE'] = 'safe';
				e['FINALIZED'] = 'finalized';
				e['EARLIEST'] = 'earliest';
			})(mr || (mr = {}));
			var gr;
			(function (e) {
				e['CALL_TRACER'] = 'callTracer';
				e['PRESTATE_TRACER'] = 'prestateTracer';
			})(gr || (gr = {}));
			var vr;
			(function (e) {
				e['ERC721'] = 'ERC721';
				e['ERC1155'] = 'ERC1155';
				e['NO_SUPPORTED_NFT_STANDARD'] = 'NO_SUPPORTED_NFT_STANDARD';
				e['NOT_A_CONTRACT'] = 'NOT_A_CONTRACT';
				e['UNKNOWN'] = 'UNKNOWN';
			})(vr || (vr = {}));
			var yr;
			(function (e) {
				e['Erc721TooManyOwners'] = 'Erc721TooManyOwners';
				e['Erc721TooManyTokens'] = 'Erc721TooManyTokens';
				e['Erc721DishonestTotalSupply'] = 'Erc721DishonestTotalSupply';
				e['MostlyHoneyPotOwners'] = 'MostlyHoneyPotOwners';
				e['OwnedByMostHoneyPots'] = 'OwnedByMostHoneyPots';
				e['LowDistinctOwnersPercent'] = 'LowDistinctOwnersPercent';
				e['HighHoneyPotOwnerPercent'] = 'HighHoneyPotOwnerPercent';
				e['HighHoneyPotPercent'] = 'HighHoneyPotPercent';
				e['HoneyPotsOwnMultipleTokens'] = 'HoneyPotsOwnMultipleTokens';
				e['NoSalesActivity'] = 'NoSalesActivity';
				e['HighAirdropPercent'] = 'HighAirdropPercent';
				e['Unknown'] = 'Unknown';
			})(yr || (yr = {}));
			var br;
			(function (e) {
				e['SPAM'] = 'SPAM';
				e['AIRDROPS'] = 'AIRDROPS';
			})(br || (br = {}));
			var wr;
			(function (e) {
				e['TRANSFERTIME'] = 'TRANSFERTIME';
			})(wr || (wr = {}));
			var _r;
			(function (e) {
				e['SEAPORT'] = 'seaport';
				e['LOOKSRARE'] = 'looksrare';
				e['X2Y2'] = 'x2y2';
				e['WYVERN'] = 'wyvern';
				e['CRYPTOPUNKS'] = 'cryptopunks';
				e['BLUR'] = 'blur';
				e['UNKNOWN'] = 'unknown';
			})(_r || (_r = {}));
			var Ar;
			(function (e) {
				e['BUYER'] = 'buyer';
				e['SELLER'] = 'seller';
			})(Ar || (Ar = {}));
			var Er;
			(function (e) {
				e['DOES_NOT_EXIST'] = 'does_not_exist';
				e['ALREADY_QUEUED'] = 'already_queued';
				e['IN_PROGRESS'] = 'in_progress';
				e['FINISHED'] = 'finished';
				e['QUEUED'] = 'queued';
				e['QUEUE_FAILED'] = 'queue_failed';
			})(Er || (Er = {}));
			var Sr;
			(function (e) {
				e['OPENSEA'] = 'OpenSea';
			})(Sr || (Sr = {}));
			var kr;
			(function (e) {
				e['FIVE_MINUTE'] = '5m';
				e['ONE_HOUR'] = '1h';
				e['ONE_DAY'] = '1d';
			})(kr || (kr = {}));
			function __awaiter$1(e, t, r, i) {
				function adopt(e) {
					return e instanceof r
						? e
						: new r(function (t) {
								t(e);
							});
				}
				return new (r || (r = Promise))(function (r, a) {
					function fulfilled(e) {
						try {
							step(i.next(e));
						} catch (e) {
							a(e);
						}
					}
					function rejected(e) {
						try {
							step(i['throw'](e));
						} catch (e) {
							a(e);
						}
					}
					function step(e) {
						e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected);
					}
					step((i = i.apply(e, t || [])).next());
				});
			}
			function __values(e) {
				var t = typeof Symbol === 'function' && Symbol.iterator,
					r = t && e[t],
					i = 0;
				if (r) return r.call(e);
				if (e && typeof e.length === 'number')
					return {
						next: function () {
							if (e && i >= e.length) e = void 0;
							return { value: e && e[i++], done: !e };
						}
					};
				throw new TypeError(t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
			}
			function __await(e) {
				return this instanceof __await ? ((this.v = e), this) : new __await(e);
			}
			function __asyncGenerator(e, t, r) {
				if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.');
				var i = r.apply(e, t || []),
					a,
					o = [];
				return (
					(a = {}),
					verb('next'),
					verb('throw'),
					verb('return'),
					(a[Symbol.asyncIterator] = function () {
						return this;
					}),
					a
				);
				function verb(e) {
					if (i[e])
						a[e] = function (t) {
							return new Promise(function (r, i) {
								o.push([e, t, r, i]) > 1 || resume(e, t);
							});
						};
				}
				function resume(e, t) {
					try {
						step(i[e](t));
					} catch (e) {
						settle(o[0][3], e);
					}
				}
				function step(e) {
					e.value instanceof __await
						? Promise.resolve(e.value.v).then(fulfill, reject)
						: settle(o[0][2], e);
				}
				function fulfill(e) {
					resume('next', e);
				}
				function reject(e) {
					resume('throw', e);
				}
				function settle(e, t) {
					if ((e(t), o.shift(), o.length)) resume(o[0][0], o[0][1]);
				}
			}
			function __asyncValues(e) {
				if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.');
				var t = e[Symbol.asyncIterator],
					r;
				return t
					? t.call(e)
					: ((e = typeof __values === 'function' ? __values(e) : e[Symbol.iterator]()),
						(r = {}),
						verb('next'),
						verb('throw'),
						verb('return'),
						(r[Symbol.asyncIterator] = function () {
							return this;
						}),
						r);
				function verb(t) {
					r[t] =
						e[t] &&
						function (r) {
							return new Promise(function (i, a) {
								(r = e[t](r)), settle(i, a, r.done, r.value);
							});
						};
				}
				function settle(e, t, r, i) {
					Promise.resolve(i).then(function (t) {
						e({ value: t, done: r });
					}, t);
				}
			}
			const Nr = 'demo';
			const Tr = er.ETH_MAINNET;
			const xr = 5;
			const Br = 0;
			function getAlchemyHttpUrl(e, t) {
				return `https://${e}.g.alchemy.com/v2/${t}`;
			}
			function getAlchemyNftHttpUrl(e, t) {
				return `https://${e}.g.alchemy.com/nft/v3/${t}`;
			}
			function getAlchemyWsUrl(e, t) {
				return `wss://${e}.g.alchemy.com/v2/${t}`;
			}
			function getAlchemyWebhookHttpUrl() {
				return 'https://dashboard.alchemy.com/api';
			}
			function getPricesBaseUrl(e) {
				return `https://api.g.alchemy.com/prices/v1/${e}`;
			}
			var Rr;
			(function (e) {
				e[(e['BASE'] = 0)] = 'BASE';
				e[(e['NFT'] = 1)] = 'NFT';
				e[(e['WEBHOOK'] = 2)] = 'WEBHOOK';
				e[(e['PRICES'] = 3)] = 'PRICES';
			})(Rr || (Rr = {}));
			const Pr = {
				[er.ETH_MAINNET]: 'mainnet',
				[er.ETH_GOERLI]: 'goerli',
				[er.ETH_SEPOLIA]: 'sepolia',
				[er.ETH_HOLESKY]: 'holesky',
				[er.OPT_MAINNET]: 'optimism',
				[er.OPT_GOERLI]: 'optimism-goerli',
				[er.OPT_SEPOLIA]: 'optimism-sepolia',
				[er.ARB_MAINNET]: 'arbitrum',
				[er.ARB_GOERLI]: 'arbitrum-goerli',
				[er.ARB_SEPOLIA]: 'arbitrum-sepolia',
				[er.MATIC_MAINNET]: 'matic',
				[er.MATIC_MUMBAI]: 'maticmum',
				[er.MATIC_AMOY]: 'maticamoy',
				[er.ASTAR_MAINNET]: 'astar-mainnet',
				[er.POLYGONZKEVM_MAINNET]: 'polygonzkevm-mainnet',
				[er.POLYGONZKEVM_TESTNET]: 'polygonzkevm-testnet',
				[er.POLYGONZKEVM_CARDONA]: 'polygonzkevm-cardona',
				[er.BASE_MAINNET]: 'base-mainnet',
				[er.BASE_GOERLI]: 'base-goerli',
				[er.BASE_SEPOLIA]: 'base-sepolia',
				[er.ZKSYNC_MAINNET]: 'zksync-mainnet',
				[er.ZKSYNC_SEPOLIA]: 'zksync-sepolia',
				[er.SHAPE_MAINNET]: 'shape-mainnet',
				[er.SHAPE_SEPOLIA]: 'shape-sepolia',
				[er.LINEA_MAINNET]: 'linea-mainnet',
				[er.LINEA_SEPOLIA]: 'linea-sepolia',
				[er.FANTOM_MAINNET]: 'fantom-mainnet',
				[er.FANTOM_TESTNET]: 'fantom-testnet',
				[er.ZETACHAIN_MAINNET]: 'zetachain-mainnet',
				[er.ZETACHAIN_TESTNET]: 'zetachain-testnet',
				[er.ARBNOVA_MAINNET]: 'arbnova-mainnet',
				[er.BLAST_MAINNET]: 'blast-mainnet',
				[er.BLAST_SEPOLIA]: 'blast-sepolia',
				[er.MANTLE_MAINNET]: 'mantle-mainnet',
				[er.MANTLE_SEPOLIA]: 'mantle-sepolia',
				[er.SCROLL_MAINNET]: 'scroll-mainnet',
				[er.SCROLL_SEPOLIA]: 'scroll-sepolia',
				[er.GNOSIS_MAINNET]: 'gnosis-mainnet',
				[er.GNOSIS_CHIADO]: 'gnosis-chiado',
				[er.BNB_MAINNET]: 'bnb-mainnet',
				[er.BNB_TESTNET]: 'bnb-testnet',
				[er.AVAX_MAINNET]: 'avax-mainnet',
				[er.AVAX_FUJI]: 'avax-fuji',
				[er.CELO_MAINNET]: 'celo-mainnet',
				[er.CELO_ALFAJORES]: 'celo-alfajores',
				[er.METIS_MAINNET]: 'metis-mainnet',
				[er.OPBNB_MAINNET]: 'opbnb-mainnet',
				[er.OPBNB_TESTNET]: 'opbnb-testnet',
				[er.BERACHAIN_BARTIO]: 'berachain-bartio',
				[er.SONEIUM_MAINNET]: 'soneium-mainnet',
				[er.SONEIUM_MINATO]: 'soneium-minato',
				[er.WORLDCHAIN_MAINNET]: 'worldchain-mainnet',
				[er.WORLDCHAIN_SEPOLIA]: 'worldchain-sepolia',
				[er.ROOTSTOCK_MAINNET]: 'rootstock-mainnet',
				[er.ROOTSTOCK_TESTNET]: 'rootstock-testnet',
				[er.FLOW_MAINNET]: 'flow-mainnet',
				[er.FLOW_TESTNET]: 'flow-testnet',
				[er.ZORA_MAINNET]: 'zora-mainnet',
				[er.ZORA_SEPOLIA]: 'zora-sepolia',
				[er.FRAX_MAINNET]: 'frax-mainnet',
				[er.FRAX_SEPOLIA]: 'frax-sepolia',
				[er.POLYNOMIAL_MAINNET]: 'polynomial-mainnet',
				[er.POLYNOMIAL_SEPOLIA]: 'polynomial-sepolia',
				[er.CROSSFI_MAINNET]: 'crossfi-mainnet',
				[er.CROSSFI_TESTNET]: 'crossfi-testnet',
				[er.APECHAIN_MAINNET]: 'apechain-mainnet',
				[er.APECHAIN_CURTIS]: 'apechain-curtis',
				[er.LENS_SEPOLIA]: 'lens-sepolia',
				[er.GEIST_MAINNET]: 'geist-mainnet',
				[er.GEIST_POLTER]: 'geist-polter',
				[er.LUMIA_PRISM]: 'lumia-prism',
				[er.LUMIA_TESTNET]: 'lumia-testnet',
				[er.UNICHAIN_SEPOLIA]: 'unichain-sepolia',
				[er.SONIC_MAINNET]: 'sonic-mainnet',
				[er.SONIC_BLAZE]: 'sonic-blaze',
				[er.XMTP_TESTNET]: 'xmtp-testnet',
				[er.ABSTRACT_TESTNET]: 'abstract-testnet',
				[er.DEGEN_MAINNET]: 'degen-mainnet',
				[er.INK_MAINNET]: 'ink-mainnet',
				[er.INK_SEPOLIA]: 'ink-sepolia'
			};
			const Mr = {
				'arbitrum-goerli': { chainId: 421613, name: 'arbitrum-goerli' },
				'arbitrum-sepolia': { chainId: 421614, name: 'arbitrum-sepolia' },
				'astar-mainnet': { chainId: 592, name: 'astar-mainnet' },
				sepolia: { chainId: 11155111, name: 'sepolia' },
				holesky: { chainId: 17e3, name: 'holesky' },
				'optimism-sepolia': { chainId: 11155420, name: 'optimism-sepolia' },
				'polygonzkevm-mainnet': { chainId: 1101, name: 'polygonzkevm-mainnet' },
				'polygonzkevm-testnet': { chainId: 1442, name: 'polygonzkevm-testnet' },
				'polygonzkevm-cardona': { chainId: 2442, name: 'polygonzkevm-cardona' },
				'base-mainnet': { chainId: 8453, name: 'base-mainnet' },
				'base-goerli': { chainId: 84531, name: 'base-goerli' },
				'base-sepolia': { chainId: 84532, name: 'base-sepolia' },
				maticamoy: { chainId: 80002, name: 'maticamoy' },
				'zksync-mainnet': { chainId: 324, name: 'zksync-mainnet' },
				'zksync-sepolia': { chainId: 300, name: 'zksync-sepolia' },
				'shape-mainnet': { chainId: 360, name: 'shape-mainnet' },
				'shape-sepolia': { chainId: 11011, name: 'shape-sepolia' },
				'linea-mainnet': { chainId: 59144, name: 'linea-mainnet' },
				'linea-sepolia': { chainId: 59141, name: 'linea-sepolia' },
				'fantom-mainnet': { chainId: 250, name: 'fantom-mainnet' },
				'fantom-testnet': { chainId: 4002, name: 'fantom-testnet' },
				'zetachain-mainnet': { chainId: 7e3, name: 'zetachain-mainnet' },
				'zetachain-testnet': { chainId: 7001, name: 'zetachain-testnet' },
				'arbnova-mainnet': { chainId: 42170, name: 'arbnova-mainnet' },
				'blast-mainnet': { chainId: 81457, name: 'blast-mainnet' },
				'blast-sepolia': { chainId: 168587773, name: 'blast-sepolia' },
				'mantle-mainnet': { chainId: 5e3, name: 'mantle-mainnet' },
				'mantle-sepolia': { chainId: 5003, name: 'mantle-sepolia' },
				'scroll-mainnet': { chainId: 534352, name: 'scroll-mainnet' },
				'scroll-sepolia': { chainId: 534351, name: 'scroll-sepolia' },
				'gnosis-mainnet': { chainId: 100, name: 'gnosis-mainnet' },
				'gnosis-chiado': { chainId: 10200, name: 'gnosis-chiado' },
				'bnb-mainnet': { chainId: 56, name: 'bnb-mainnet' },
				'bnb-testnet': { chainId: 97, name: 'bnb-testnet' },
				'avax-mainnet': { chainId: 43114, name: 'avax-mainnet' },
				'avax-fuji': { chainId: 43113, name: 'avax-fuji' },
				'celo-mainnet': { chainId: 42220, name: 'celo-mainnet' },
				'celo-alfajores': { chainId: 44787, name: 'celo-alfajores' },
				'metis-mainnet': { chainId: 1088, name: 'metis-mainnet' },
				'opbnb-mainnet': { chainId: 204, name: 'opbnb-mainnet' },
				'opbnb-testnet': { chainId: 5611, name: 'opbnb-testnet' },
				'berachain-bartio': { chainId: 80084, name: 'berachain-bartio' },
				'soneium-mainnet': { chainId: 1868, name: 'soneium-mainnet' },
				'soneium-minato': { chainId: 1946, name: 'soneium-minato' },
				'worldchain-mainnet': { chainId: 480, name: 'worldchain-mainnet' },
				'worldchain-sepolia': { chainId: 4801, name: 'worldchain-sepolia' },
				'rootstock-mainnet': { chainId: 30, name: 'rootstock-mainnet' },
				'rootstock-testnet': { chainId: 31, name: 'rootstock-testnet' },
				'flow-mainnet': { chainId: 747, name: 'flow-mainnet' },
				'flow-testnet': { chainId: 545, name: 'flow-testnet' },
				'zora-mainnet': { chainId: 7777777, name: 'zora-mainnet' },
				'zora-sepolia': { chainId: 999999999, name: 'zora-sepolia' },
				'frax-mainnet': { chainId: 252, name: 'frax-mainnet' },
				'frax-sepolia': { chainId: 2522, name: 'frax-sepolia' },
				'polynomial-mainnet': { chainId: 8008, name: 'polynomial-mainnet' },
				'polynomial-sepolia': { chainId: 8009, name: 'polynomial-sepolia' },
				'crossfi-mainnet': { chainId: 4158, name: 'crossfi-mainnet' },
				'crossfi-testnet': { chainId: 4157, name: 'crossfi-testnet' },
				'apechain-mainnet': { chainId: 33139, name: 'apechain-mainnet' },
				'apechain-curtis': { chainId: 33111, name: 'apechain-curtis' },
				'lens-sepolia': { chainId: 37111, name: 'lens-sepolia' },
				'geist-mainnet': { chainId: 63157, name: 'geist-mainnet' },
				'geist-polter': { chainId: 631571, name: 'geist-polter' },
				'lumia-prism': { chainId: 994873017, name: 'lumia-prism' },
				'lumia-testnet': { chainId: 1952959480, name: 'lumia-testnet' },
				'unichain-sepolia': { chainId: 1301, name: 'unichain-sepolia' },
				'sonic-mainnet': { chainId: 146, name: 'sonic-mainnet' },
				'sonic-blaze': { chainId: 57054, name: 'sonic-blaze' },
				'xmtp-testnet': { chainId: 241320161, name: 'xmtp-testnet' },
				'abstract-testnet': { chainId: 11124, name: 'abstract-testnet' },
				'degen-mainnet': { chainId: 666666666, name: 'degen-mainnet' },
				'ink-mainnet': { chainId: 57073, name: 'ink-mainnet' },
				'ink-sepolia': { chainId: 763373, name: 'ink-sepolia' }
			};
			function index_1789de96_noop() {}
			const Cr = '0x';
			const Ir = '0x0000000000000000000000000000000000000000';
			class AlchemyConfig {
				constructor(e) {
					this.apiKey = (e === null || e === void 0 ? void 0 : e.apiKey) || Nr;
					this.network = (e === null || e === void 0 ? void 0 : e.network) || Tr;
					this.maxRetries = (e === null || e === void 0 ? void 0 : e.maxRetries) || xr;
					this.url = e === null || e === void 0 ? void 0 : e.url;
					this.authToken = e === null || e === void 0 ? void 0 : e.authToken;
					this.batchRequests = (e === null || e === void 0 ? void 0 : e.batchRequests) || false;
					this.requestTimeout = (e === null || e === void 0 ? void 0 : e.requestTimeout) || Br;
					this.connectionInfoOverrides =
						e === null || e === void 0 ? void 0 : e.connectionInfoOverrides;
				}
				_getRequestUrl(e) {
					if (this.url !== undefined) {
						return this.url;
					} else if (e === Rr.NFT) {
						return getAlchemyNftHttpUrl(this.network, this.apiKey);
					} else if (e === Rr.WEBHOOK) {
						return getAlchemyWebhookHttpUrl();
					} else if (e === Rr.PRICES) {
						return getPricesBaseUrl(this.apiKey);
					} else {
						return getAlchemyHttpUrl(this.network, this.apiKey);
					}
				}
				getProvider() {
					if (!this._baseAlchemyProvider) {
						this._baseAlchemyProvider = (() =>
							__awaiter$1(this, void 0, void 0, function* () {
								const { AlchemyProvider: e } = yield r.e(399).then(r.bind(r, 399));
								return new e(this);
							}))();
					}
					return this._baseAlchemyProvider;
				}
				getWebSocketProvider() {
					if (!this._baseAlchemyWssProvider) {
						this._baseAlchemyWssProvider = (() =>
							__awaiter$1(this, void 0, void 0, function* () {
								const { AlchemyWebSocketProvider: e } = yield Promise.all([
									r.e(399),
									r.e(257)
								]).then(r.bind(r, 3257));
								return new e(this);
							}))();
					}
					return this._baseAlchemyWssProvider;
				}
			}
			const Or = 'logger/5.7.0';
			let Fr = false;
			let Dr = false;
			const Lr = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
			let Ur = Lr['default'];
			let jr = null;
			function _checkNormalize() {
				try {
					const e = [];
					['NFD', 'NFC', 'NFKD', 'NFKC'].forEach((t) => {
						try {
							if ('test'.normalize(t) !== 'test') {
								throw new Error('bad normalize');
							}
						} catch (r) {
							e.push(t);
						}
					});
					if (e.length) {
						throw new Error('missing ' + e.join(', '));
					}
					if (String.fromCharCode(233).normalize('NFD') !== String.fromCharCode(101, 769)) {
						throw new Error('broken implementation');
					}
				} catch (e) {
					return e.message;
				}
				return null;
			}
			const Hr = _checkNormalize();
			var zr;
			(function (e) {
				e['DEBUG'] = 'DEBUG';
				e['INFO'] = 'INFO';
				e['WARNING'] = 'WARNING';
				e['ERROR'] = 'ERROR';
				e['OFF'] = 'OFF';
			})(zr || (zr = {}));
			var $r;
			(function (e) {
				e['UNKNOWN_ERROR'] = 'UNKNOWN_ERROR';
				e['NOT_IMPLEMENTED'] = 'NOT_IMPLEMENTED';
				e['UNSUPPORTED_OPERATION'] = 'UNSUPPORTED_OPERATION';
				e['NETWORK_ERROR'] = 'NETWORK_ERROR';
				e['SERVER_ERROR'] = 'SERVER_ERROR';
				e['TIMEOUT'] = 'TIMEOUT';
				e['BUFFER_OVERRUN'] = 'BUFFER_OVERRUN';
				e['NUMERIC_FAULT'] = 'NUMERIC_FAULT';
				e['MISSING_NEW'] = 'MISSING_NEW';
				e['INVALID_ARGUMENT'] = 'INVALID_ARGUMENT';
				e['MISSING_ARGUMENT'] = 'MISSING_ARGUMENT';
				e['UNEXPECTED_ARGUMENT'] = 'UNEXPECTED_ARGUMENT';
				e['CALL_EXCEPTION'] = 'CALL_EXCEPTION';
				e['INSUFFICIENT_FUNDS'] = 'INSUFFICIENT_FUNDS';
				e['NONCE_EXPIRED'] = 'NONCE_EXPIRED';
				e['REPLACEMENT_UNDERPRICED'] = 'REPLACEMENT_UNDERPRICED';
				e['UNPREDICTABLE_GAS_LIMIT'] = 'UNPREDICTABLE_GAS_LIMIT';
				e['TRANSACTION_REPLACED'] = 'TRANSACTION_REPLACED';
				e['ACTION_REJECTED'] = 'ACTION_REJECTED';
			})($r || ($r = {}));
			const Gr = '0123456789abcdef';
			class Logger$1 {
				constructor(e) {
					Object.defineProperty(this, 'version', { enumerable: true, value: e, writable: false });
				}
				_log(e, t) {
					const r = e.toLowerCase();
					if (Lr[r] == null) {
						this.throwArgumentError('invalid log level name', 'logLevel', e);
					}
					if (Ur > Lr[r]) {
						return;
					}
					console.log.apply(console, t);
				}
				debug(...e) {
					this._log(Logger$1.levels.DEBUG, e);
				}
				info(...e) {
					this._log(Logger$1.levels.INFO, e);
				}
				warn(...e) {
					this._log(Logger$1.levels.WARNING, e);
				}
				makeError(e, t, r) {
					if (Dr) {
						return this.makeError('censored error', t, {});
					}
					if (!t) {
						t = Logger$1.errors.UNKNOWN_ERROR;
					}
					if (!r) {
						r = {};
					}
					const i = [];
					Object.keys(r).forEach((e) => {
						const t = r[e];
						try {
							if (t instanceof Uint8Array) {
								let r = '';
								for (let e = 0; e < t.length; e++) {
									r += Gr[t[e] >> 4];
									r += Gr[t[e] & 15];
								}
								i.push(e + '=Uint8Array(0x' + r + ')');
							} else {
								i.push(e + '=' + JSON.stringify(t));
							}
						} catch (t) {
							i.push(e + '=' + JSON.stringify(r[e].toString()));
						}
					});
					i.push(`code=${t}`);
					i.push(`version=${this.version}`);
					const a = e;
					let o = '';
					switch (t) {
						case $r.NUMERIC_FAULT: {
							o = 'NUMERIC_FAULT';
							const t = e;
							switch (t) {
								case 'overflow':
								case 'underflow':
								case 'division-by-zero':
									o += '-' + t;
									break;
								case 'negative-power':
								case 'negative-width':
									o += '-unsupported';
									break;
								case 'unbound-bitwise-result':
									o += '-unbound-result';
									break;
							}
							break;
						}
						case $r.CALL_EXCEPTION:
						case $r.INSUFFICIENT_FUNDS:
						case $r.MISSING_NEW:
						case $r.NONCE_EXPIRED:
						case $r.REPLACEMENT_UNDERPRICED:
						case $r.TRANSACTION_REPLACED:
						case $r.UNPREDICTABLE_GAS_LIMIT:
							o = t;
							break;
					}
					if (o) {
						e += ' [ See: https://links.ethers.org/v5-errors-' + o + ' ]';
					}
					if (i.length) {
						e += ' (' + i.join(', ') + ')';
					}
					const c = new Error(e);
					c.reason = a;
					c.code = t;
					Object.keys(r).forEach(function (e) {
						c[e] = r[e];
					});
					return c;
				}
				throwError(e, t, r) {
					throw this.makeError(e, t, r);
				}
				throwArgumentError(e, t, r) {
					return this.throwError(e, Logger$1.errors.INVALID_ARGUMENT, { argument: t, value: r });
				}
				assert(e, t, r, i) {
					if (!!e) {
						return;
					}
					this.throwError(t, r, i);
				}
				assertArgument(e, t, r, i) {
					if (!!e) {
						return;
					}
					this.throwArgumentError(t, r, i);
				}
				checkNormalize(e) {
					if (Hr) {
						this.throwError(
							'platform missing String.prototype.normalize',
							Logger$1.errors.UNSUPPORTED_OPERATION,
							{ operation: 'String.prototype.normalize', form: Hr }
						);
					}
				}
				checkSafeUint53(e, t) {
					if (typeof e !== 'number') {
						return;
					}
					if (t == null) {
						t = 'value not safe';
					}
					if (e < 0 || e >= 9007199254740991) {
						this.throwError(t, Logger$1.errors.NUMERIC_FAULT, {
							operation: 'checkSafeInteger',
							fault: 'out-of-safe-range',
							value: e
						});
					}
					if (e % 1) {
						this.throwError(t, Logger$1.errors.NUMERIC_FAULT, {
							operation: 'checkSafeInteger',
							fault: 'non-integer',
							value: e
						});
					}
				}
				checkArgumentCount(e, t, r) {
					if (r) {
						r = ': ' + r;
					} else {
						r = '';
					}
					if (e < t) {
						this.throwError('missing argument' + r, Logger$1.errors.MISSING_ARGUMENT, {
							count: e,
							expectedCount: t
						});
					}
					if (e > t) {
						this.throwError('too many arguments' + r, Logger$1.errors.UNEXPECTED_ARGUMENT, {
							count: e,
							expectedCount: t
						});
					}
				}
				checkNew(e, t) {
					if (e === Object || e == null) {
						this.throwError('missing new', Logger$1.errors.MISSING_NEW, { name: t.name });
					}
				}
				checkAbstract(e, t) {
					if (e === t) {
						this.throwError(
							'cannot instantiate abstract class ' +
								JSON.stringify(t.name) +
								' directly; use a sub-class',
							Logger$1.errors.UNSUPPORTED_OPERATION,
							{ name: e.name, operation: 'new' }
						);
					} else if (e === Object || e == null) {
						this.throwError('missing new', Logger$1.errors.MISSING_NEW, { name: t.name });
					}
				}
				static globalLogger() {
					if (!jr) {
						jr = new Logger$1(Or);
					}
					return jr;
				}
				static setCensorship(e, t) {
					if (!e && t) {
						this.globalLogger().throwError(
							'cannot permanently disable censorship',
							Logger$1.errors.UNSUPPORTED_OPERATION,
							{ operation: 'setCensorship' }
						);
					}
					if (Fr) {
						if (!e) {
							return;
						}
						this.globalLogger().throwError(
							'error censorship permanent',
							Logger$1.errors.UNSUPPORTED_OPERATION,
							{ operation: 'setCensorship' }
						);
					}
					Dr = !!e;
					Fr = !!t;
				}
				static setLogLevel(e) {
					const t = Lr[e.toLowerCase()];
					if (t == null) {
						Logger$1.globalLogger().warn('invalid log level - ' + e);
						return;
					}
					Ur = t;
				}
				static from(e) {
					return new Logger$1(e);
				}
			}
			Logger$1.errors = $r;
			Logger$1.levels = zr;
			const qr = 'properties/5.7.0';
			var Vr =
				false ||
				function (e, t, r, i) {
					function adopt(e) {
						return e instanceof r
							? e
							: new r(function (t) {
									t(e);
								});
					}
					return new (r || (r = Promise))(function (r, a) {
						function fulfilled(e) {
							try {
								step(i.next(e));
							} catch (e) {
								a(e);
							}
						}
						function rejected(e) {
							try {
								step(i['throw'](e));
							} catch (e) {
								a(e);
							}
						}
						function step(e) {
							e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected);
						}
						step((i = i.apply(e, t || [])).next());
					});
				};
			const Kr = new Logger$1(qr);
			function defineReadOnly(e, t, r) {
				Object.defineProperty(e, t, { enumerable: true, value: r, writable: false });
			}
			function resolveProperties(e) {
				return Vr(this, void 0, void 0, function* () {
					const t = Object.keys(e).map((t) => {
						const r = e[t];
						return Promise.resolve(r).then((e) => ({ key: t, value: e }));
					});
					const r = yield Promise.all(t);
					return r.reduce((e, t) => {
						e[t.key] = t.value;
						return e;
					}, {});
				});
			}
			const Wr = { bigint: true, boolean: true, function: true, number: true, string: true };
			function _isFrozen(e) {
				if (e === undefined || e === null || Wr[typeof e]) {
					return true;
				}
				if (Array.isArray(e) || typeof e === 'object') {
					if (!Object.isFrozen(e)) {
						return false;
					}
					const t = Object.keys(e);
					for (let r = 0; r < t.length; r++) {
						let i = null;
						try {
							i = e[t[r]];
						} catch (e) {
							continue;
						}
						if (!_isFrozen(i)) {
							return false;
						}
					}
					return true;
				}
				return Kr.throwArgumentError(`Cannot deepCopy ${typeof e}`, 'object', e);
			}
			function _deepCopy(e) {
				if (_isFrozen(e)) {
					return e;
				}
				if (Array.isArray(e)) {
					return Object.freeze(e.map((e) => deepCopy(e)));
				}
				if (typeof e === 'object') {
					const t = {};
					for (const r in e) {
						const i = e[r];
						if (i === undefined) {
							continue;
						}
						defineReadOnly(t, r, deepCopy(i));
					}
					return t;
				}
				return Kr.throwArgumentError(`Cannot deepCopy ${typeof e}`, 'object', e);
			}
			function deepCopy(e) {
				return _deepCopy(e);
			}
			function fromHex(e) {
				return u.gH.from(e).toNumber();
			}
			function toHex(e) {
				return u.gH.from(e).toHexString();
			}
			function isHex(e) {
				return /^0x[0-9a-fA-F]+$/.test(e);
			}
			function formatBlock(e) {
				if (typeof e === 'string') {
					return e;
				} else if (Number.isInteger(e)) {
					return toHex(e);
				}
				return e.toString();
			}
			function stringToEnum(e, t) {
				return Object.values(t).includes(e) ? e : null;
			}
			function getNftContractForNftFromRaw(e) {
				return nullsToUndefined(
					Object.assign(Object.assign({}, getNftContractFromRaw(e)), {
						spamClassifications: e.spamClassifications.map(parseNftSpamClassification)
					})
				);
			}
			function getNftContractsForOwnerFromRaw(e) {
				return nullsToUndefined(
					Object.assign(Object.assign({}, getNftContractFromRaw(e)), {
						displayNft: e.displayNft,
						image: e.image,
						totalBalance: e.totalBalance,
						numDistinctTokensOwned: e.numDistinctTokensOwned,
						isSpam: e.isSpam
					})
				);
			}
			function getNftContractFromRaw(e) {
				var t;
				return nullsToUndefined(
					Object.assign(Object.assign({}, e), {
						tokenType: parseNftTokenType(e.tokenType),
						openSeaMetadata: Object.assign(Object.assign({}, e.openSeaMetadata), {
							safelistRequestStatus: (
								(t = e.openSeaMetadata) === null || t === void 0 ? void 0 : t.safelistRequestStatus
							)
								? stringToEnum(e.openSeaMetadata.safelistRequestStatus, sr)
								: null
						})
					})
				);
			}
			function getNftCollectionFromRaw(e) {
				return nullsToUndefined(
					Object.assign(Object.assign({}, e), {
						floorPrice: Object.assign(Object.assign({}, e.floorPrice), {
							marketplace: parseNftCollectionMarketplace(e.floorPrice.marketplace)
						})
					})
				);
			}
			function getBaseNftFromRaw(e, t) {
				return { contractAddress: t ? t : e.contractAddress, tokenId: e.tokenId };
			}
			function getNftFromRaw(e) {
				return nullsToUndefined(
					Object.assign(Object.assign({}, e), {
						contract: getNftContractForNftFromRaw(e.contract),
						tokenType: parseNftTokenType(e.tokenType),
						acquiredAt: e.acquiredAt,
						collection: e.collection,
						mint: e.mint
					})
				);
			}
			function getNftSalesFromRaw(e) {
				return nullsToUndefined({
					nftSales: e.nftSales.map((e) =>
						Object.assign(Object.assign({}, e), {
							marketplace: parseNftSaleMarketplace(e.marketplace),
							taker: parseNftTaker(e.taker)
						})
					),
					validAt: e.validAt,
					pageKey: e.pageKey
				});
			}
			function parseNftSaleMarketplace(e) {
				switch (e) {
					case 'looksrare':
						return _r.LOOKSRARE;
					case 'seaport':
						return _r.SEAPORT;
					case 'x2y2':
						return _r.X2Y2;
					case 'wyvern':
						return _r.WYVERN;
					case 'cryptopunks':
						return _r.CRYPTOPUNKS;
					case 'blur':
						return _r.BLUR;
					default:
						return _r.UNKNOWN;
				}
			}
			function parseNftCollectionMarketplace(e) {
				switch (e) {
					case 'OpenSea':
						return Sr.OPENSEA;
					default:
						return undefined;
				}
			}
			function parseNftTaker(e) {
				switch (e.toLowerCase()) {
					case 'buyer':
						return Ar.BUYER;
					case 'seller':
						return Ar.SELLER;
					default:
						throw new Error(`Unsupported NftSaleTakerType ${e}`);
				}
			}
			function parseNftSpamClassification(e) {
				const t = stringToEnum(e, yr);
				if (t == null) {
					return yr.Unknown;
				}
				return t;
			}
			function parseNftTokenType(e) {
				switch (e) {
					case 'erc721':
					case 'ERC721':
						return vr.ERC721;
					case 'erc1155':
					case 'ERC1155':
						return vr.ERC1155;
					case 'no_supported_nft_standard':
					case 'NO_SUPPORTED_NFT_STANDARD':
						return vr.NO_SUPPORTED_NFT_STANDARD;
					case 'not_a_contract':
					case 'NOT_A_CONTRACT':
						return vr.NOT_A_CONTRACT;
					default:
						return vr.UNKNOWN;
				}
			}
			const Jr = typeof window !== 'undefined' && window !== null;
			function nullsToUndefined(e) {
				if (e === null || e === undefined) {
					return undefined;
				}
				if (e.constructor.name === 'Object' || Array.isArray(e)) {
					for (const t in e) {
						e[t] = nullsToUndefined(e[t]);
					}
				}
				return e;
			}
			function getAssetTransfers(e, t, r = 'getAssetTransfers') {
				return __awaiter$1(this, void 0, void 0, function* () {
					const i = yield e.getProvider();
					if (t.fromAddress) {
						t.fromAddress = yield i._getAddress(t.fromAddress);
					}
					if (t.toAddress) {
						t.toAddress = yield i._getAddress(t.toAddress);
					}
					return i._send(
						'alchemy_getAssetTransfers',
						[
							Object.assign(Object.assign({}, t), {
								fromBlock: t.fromBlock != null ? formatBlock(t.fromBlock) : undefined,
								toBlock: t.toBlock != null ? formatBlock(t.toBlock) : undefined,
								maxCount: t.maxCount != null ? toHex(t.maxCount) : undefined
							})
						],
						r
					);
				});
			}
			function getTransactionReceipts(e, t, r = 'getTransactionReceipts') {
				return __awaiter$1(this, void 0, void 0, function* () {
					const i = yield e.getProvider();
					return i._send('alchemy_getTransactionReceipts', [t], r);
				});
			}
			function getLogs(e, t) {
				return __awaiter$1(this, void 0, void 0, function* () {
					const r = yield e.getProvider();
					yield r.getNetwork();
					const i = yield resolveProperties({ filter: getFilter(e, t) });
					const a = yield r.send('eth_getLogs', [i.filter]);
					a.forEach((e) => {
						if (e.removed == null) {
							e.removed = false;
						}
					});
					return arrayOf(r.formatter.filterLog.bind(r.formatter))(a);
				});
			}
			function getFilter(e, t) {
				return __awaiter$1(this, void 0, void 0, function* () {
					const r = yield e.getProvider();
					const i = yield t;
					let a = {};
					['blockHash', 'topics'].forEach((e) => {
						if (i[e] == null) {
							return;
						}
						a[e] = i[e];
					});
					['fromBlock', 'toBlock'].forEach((e) => {
						if (i[e] == null) {
							return;
						}
						a[e] = r._getBlockTag(i[e]);
					});
					a = r.formatter.filter(yield resolveProperties(a));
					if (Array.isArray(i.address)) {
						a.address = yield Promise.all(
							i.address.map((e) =>
								__awaiter$1(this, void 0, void 0, function* () {
									return r._getAddress(e);
								})
							)
						);
					} else if (i.address != null) {
						a.address = yield r._getAddress(i.address);
					}
					return a;
				});
			}
			function arrayOf(e) {
				return function (t) {
					if (!Array.isArray(t)) {
						throw new Error('not an array');
					}
					const r = [];
					t.forEach((t) => {
						r.push(e(t));
					});
					return r;
				};
			}
			class CoreNamespace {
				constructor(e) {
					this.config = e;
				}
				getBalance(e, t) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const r = yield this.config.getProvider();
						return r.getBalance(e, t);
					});
				}
				isContractAddress(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const t = yield this.config.getProvider();
						const r = yield t.getCode(e);
						return r !== '0x';
					});
				}
				getCode(e, t) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const r = yield this.config.getProvider();
						return r.getCode(e, t);
					});
				}
				getStorageAt(e, t, r) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const i = yield this.config.getProvider();
						return i.getStorageAt(e, t, r);
					});
				}
				getTransactionCount(e, t) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const r = yield this.config.getProvider();
						return r.getTransactionCount(e, t);
					});
				}
				getBlock(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const t = yield this.config.getProvider();
						return t.getBlock(e);
					});
				}
				getBlockWithTransactions(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const t = yield this.config.getProvider();
						return t.getBlockWithTransactions(e);
					});
				}
				getNetwork() {
					return __awaiter$1(this, void 0, void 0, function* () {
						const e = yield this.config.getProvider();
						return e.getNetwork();
					});
				}
				getBlockNumber() {
					return __awaiter$1(this, void 0, void 0, function* () {
						const e = yield this.config.getProvider();
						return e.getBlockNumber();
					});
				}
				getGasPrice() {
					return __awaiter$1(this, void 0, void 0, function* () {
						const e = yield this.config.getProvider();
						return e.getGasPrice();
					});
				}
				getFeeData() {
					return __awaiter$1(this, void 0, void 0, function* () {
						const e = yield this.config.getProvider();
						return e.getFeeData();
					});
				}
				ready() {
					return __awaiter$1(this, void 0, void 0, function* () {
						const e = yield this.config.getProvider();
						return e.ready;
					});
				}
				call(e, t) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const r = yield this.config.getProvider();
						return r.call(e, t);
					});
				}
				estimateGas(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const t = yield this.config.getProvider();
						return t.estimateGas(e);
					});
				}
				getTransaction(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const t = yield this.config.getProvider();
						return t.getTransaction(e);
					});
				}
				getTransactionReceipt(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const t = yield this.config.getProvider();
						return t.getTransactionReceipt(e);
					});
				}
				sendTransaction(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const t = yield this.config.getProvider();
						return t.sendTransaction(e);
					});
				}
				waitForTransaction(e, t, r) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const i = yield this.config.getProvider();
						return i.waitForTransaction(e, t, r);
					});
				}
				getLogs(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						return getLogs(this.config, e);
					});
				}
				send(e, t) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const r = yield this.config.getProvider();
						return r.send(e, t);
					});
				}
				findContractDeployer(e) {
					var t;
					return __awaiter$1(this, void 0, void 0, function* () {
						const r = yield this.config.getProvider();
						const i = yield r.getBlockNumber();
						if ((yield r.getCode(e, i)) === Cr) {
							throw new Error(`Contract '${e}' does not exist`);
						}
						const a = yield binarySearchFirstBlock(0, i + 1, e, this.config);
						const o = yield getTransactionReceipts(
							this.config,
							{ blockNumber: toHex(a) },
							'findContractDeployer'
						);
						const c =
							(t = o.receipts) === null || t === void 0
								? void 0
								: t.find((t) => t.contractAddress === e.toLowerCase());
						return {
							deployerAddress: c === null || c === void 0 ? void 0 : c.from,
							blockNumber: a
						};
					});
				}
				getTokenBalances(e, t) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const r = yield this.config.getProvider();
						const i = yield r._getAddress(e);
						if (Array.isArray(t)) {
							if (t.length > 1500) {
								throw new Error(
									'You cannot pass in more than 1500 contract addresses to getTokenBalances()'
								);
							}
							if (t.length === 0) {
								throw new Error(
									'getTokenBalances() requires at least one contractAddress when using an array'
								);
							}
							return r._send('alchemy_getTokenBalances', [i, t], 'getTokenBalances');
						} else {
							const e = t === undefined ? tr.ERC20 : t.type;
							const a = [i, e];
							if ((t === null || t === void 0 ? void 0 : t.type) === tr.ERC20 && t.pageKey) {
								a.push({ pageKey: t.pageKey });
							}
							return r._send('alchemy_getTokenBalances', a, 'getTokenBalances');
						}
					});
				}
				getTokensForOwner(e, t) {
					var r;
					return __awaiter$1(this, void 0, void 0, function* () {
						const i = yield this.config.getProvider();
						const a = yield i._getAddress(e);
						const o = [
							a,
							(r = t === null || t === void 0 ? void 0 : t.contractAddresses) !== null &&
							r !== void 0
								? r
								: tr.ERC20
						];
						if (t === null || t === void 0 ? void 0 : t.pageKey) {
							o.push({ pageKey: t.pageKey });
						}
						const c = yield i._send('alchemy_getTokenBalances', o, 'getTokensForOwner');
						const l = c.tokenBalances.map((e) => ({
							contractAddress: e.contractAddress,
							rawBalance: u.gH.from(e.tokenBalance).toString()
						}));
						const d = yield Promise.allSettled(
							c.tokenBalances.map((e) =>
								i._send('alchemy_getTokenMetadata', [e.contractAddress], 'getTokensForOwner', true)
							)
						);
						const p = d.map((e) =>
							e.status === 'fulfilled'
								? e.value
								: { name: null, symbol: null, decimals: null, logo: null }
						);
						const m = l.map((e, t) =>
							Object.assign(Object.assign(Object.assign({}, e), p[t]), {
								balance:
									p[t].decimals !== null ? formatUnits(e.rawBalance, p[t].decimals) : undefined
							})
						);
						return { tokens: m.map((e) => nullsToUndefined(e)), pageKey: c.pageKey };
					});
				}
				getTokenMetadata(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const t = yield this.config.getProvider();
						return t._send('alchemy_getTokenMetadata', [e], 'getTokenMetadata');
					});
				}
				getAssetTransfers(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						return getAssetTransfers(this.config, e);
					});
				}
				getTransactionReceipts(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						return getTransactionReceipts(this.config, e);
					});
				}
				resolveName(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const t = yield this.config.getProvider();
						return t.resolveName(e);
					});
				}
				lookupAddress(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const t = yield this.config.getProvider();
						return t.lookupAddress(e);
					});
				}
			}
			function binarySearchFirstBlock(e, t, r, i) {
				return __awaiter$1(this, void 0, void 0, function* () {
					if (e >= t) {
						return t;
					}
					const a = Math.floor((e + t) / 2);
					const o = yield i.getProvider();
					const c = yield o.getCode(r, a);
					if (c === Cr) {
						return binarySearchFirstBlock(a + 1, t, r, i);
					}
					return binarySearchFirstBlock(e, a, r, i);
				});
			}
			class DebugNamespace {
				constructor(e) {
					this.config = e;
				}
				traceCall(e, t, r) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const i = yield this.config.getProvider();
						const a = [e, t, parseTracerParams(r)];
						return i._send('debug_traceCall', a, 'traceCall');
					});
				}
				traceTransaction(e, t, r) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const i = yield this.config.getProvider();
						const a = [e, parseTracerParams(t, r)];
						return i._send('debug_traceTransaction', a, 'traceTransaction');
					});
				}
				traceBlock(e, t) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const r = yield this.config.getProvider();
						let i;
						let o;
						if ((0, a.Lo)(e, 32)) {
							i = 'debug_traceBlockByHash';
							o = [e, parseTracerParams(t)];
						} else {
							i = 'debug_traceBlockByNumber';
							const r = typeof e === 'number' ? (0, a.hP)((0, a.Fh)(e)) : e;
							o = [r, parseTracerParams(t)];
						}
						return r._send(i, o, 'traceBlock');
					});
				}
			}
			function parseTracerParams(e, t) {
				return Object.assign(
					{ tracer: e.type },
					e.onlyTopCall !== undefined && {
						tracerConfig: { onlyTopCall: e.onlyTopCall, timeout: t }
					}
				);
			}
			function sanitizeTokenType(e) {
				if (e === vr.ERC1155 || e === vr.ERC721) {
					return e;
				}
				return undefined;
			}
			var Zr;
			(function (e) {
				e[(e['DEBUG'] = 0)] = 'DEBUG';
				e[(e['INFO'] = 1)] = 'INFO';
				e[(e['WARN'] = 2)] = 'WARN';
				e[(e['ERROR'] = 3)] = 'ERROR';
				e[(e['SILENT'] = 4)] = 'SILENT';
			})(Zr || (Zr = {}));
			const Qr = {
				debug: Zr.DEBUG,
				info: Zr.INFO,
				warn: Zr.WARN,
				error: Zr.ERROR,
				silent: Zr.SILENT
			};
			const Yr = { [Zr.DEBUG]: 'log', [Zr.INFO]: 'info', [Zr.WARN]: 'warn', [Zr.ERROR]: 'error' };
			const Xr = Zr.INFO;
			function setLogLevel(e) {
				en.logLevel = Qr[e];
			}
			function logDebug(e, ...t) {
				en.debug(e, t);
			}
			function logInfo(e, ...t) {
				en.info(e, t);
			}
			function logWarn(e, ...t) {
				en.warn(e, t);
			}
			class Logger {
				constructor() {
					this._logLevel = Xr;
				}
				get logLevel() {
					return this._logLevel;
				}
				set logLevel(e) {
					if (!(e in Zr)) {
						throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
					}
					this._logLevel = e;
				}
				debug(...e) {
					this._log(Zr.DEBUG, ...e);
				}
				info(...e) {
					this._log(Zr.INFO, ...e);
				}
				warn(...e) {
					this._log(Zr.WARN, ...e);
				}
				error(...e) {
					this._log(Zr.ERROR, ...e);
				}
				_log(e, ...t) {
					if (e < this._logLevel) {
						return;
					}
					const r = new Date().toISOString();
					const i = Yr[e];
					if (i) {
						console[i](`[${r}] Alchemy:`, ...t.map(stringify));
					} else {
						throw new Error(`Logger received an invalid logLevel (value: ${e})`);
					}
				}
			}
			function stringify(e) {
				if (typeof e === 'string') {
					return e;
				} else {
					try {
						return JSON.stringify(e);
					} catch (t) {
						return e;
					}
				}
			}
			const en = new Logger();
			const tn = '3.5.1';
			function sendAxiosRequest(e, t, r, i, a) {
				var o;
				const c = e + '/' + t;
				const u = Object.assign(Object.assign({}, a), {
					headers: Object.assign(
						Object.assign(
							Object.assign({}, a === null || a === void 0 ? void 0 : a.headers),
							!Jr && { 'Accept-Encoding': 'gzip' }
						),
						{ 'Alchemy-Ethers-Sdk-Version': tn, 'Alchemy-Ethers-Sdk-Method': r }
					),
					method:
						(o = a === null || a === void 0 ? void 0 : a.method) !== null && o !== void 0
							? o
							: 'GET',
					url: c,
					params: i
				});
				return ot(u);
			}
			const rn = 1e3;
			const nn = 1.5;
			const sn = 30 * 1e3;
			const an = 5;
			class ExponentialBackoff {
				constructor(e = an) {
					this.maxAttempts = e;
					this.initialDelayMs = rn;
					this.backoffMultiplier = nn;
					this.maxDelayMs = sn;
					this.numAttempts = 0;
					this.currentDelayMs = 0;
					this.isInBackoff = false;
				}
				backoff() {
					if (this.numAttempts >= this.maxAttempts) {
						return Promise.reject(
							new Error(`Exceeded maximum number of attempts: ${this.maxAttempts}`)
						);
					}
					if (this.isInBackoff) {
						return Promise.reject(new Error('A backoff operation is already in progress'));
					}
					const e = this.withJitterMs(this.currentDelayMs);
					if (e > 0) {
						logDebug('ExponentialBackoff.backoff', `Backing off for ${e}ms`);
					}
					this.currentDelayMs *= this.backoffMultiplier;
					this.currentDelayMs = Math.max(this.currentDelayMs, this.initialDelayMs);
					this.currentDelayMs = Math.min(this.currentDelayMs, this.maxDelayMs);
					this.numAttempts += 1;
					return new Promise((t) => {
						this.isInBackoff = true;
						setTimeout(() => {
							this.isInBackoff = false;
							t();
						}, e);
					});
				}
				withJitterMs(e) {
					return Math.min(e + (Math.random() - 0.5) * e, this.maxDelayMs);
				}
			}
			function requestHttpWithBackoff(e, t, r, i, a, o) {
				return __awaiter$1(this, void 0, void 0, function* () {
					let c = undefined;
					const u = new ExponentialBackoff(e.maxRetries);
					for (let l = 0; l < e.maxRetries + 1; l++) {
						try {
							if (c !== undefined) {
								logInfo('requestHttp', `Retrying after error: ${c.message}`);
							}
							try {
								yield u.backoff();
							} catch (e) {
								break;
							}
							const l = yield sendAxiosRequest(
								e._getRequestUrl(t),
								r,
								i,
								a,
								Object.assign(Object.assign({}, o), { timeout: e.requestTimeout })
							);
							if (l.status === 200) {
								logDebug(r, `Successful request: ${r}`);
								return l.data;
							} else {
								logInfo(r, `Request failed: ${r}, ${l.status}, ${l.data}`);
								c = new Error(l.status + ': ' + l.data);
							}
						} catch (e) {
							if (!ot.isAxiosError(e) || e.response === undefined) {
								throw e;
							}
							c = new Error(e.response.status + ': ' + JSON.stringify(e.response.data));
							if (!isRetryableHttpError(e, t)) {
								break;
							}
						}
					}
					return Promise.reject(c);
				});
			}
			function isRetryableHttpError(e, t) {
				const r = t === Rr.WEBHOOK ? [429, 500] : [429];
				return e.response !== undefined && r.includes(e.response.status);
			}
			function paginateEndpoint(e, t, r, i, a, o, c) {
				return __asyncGenerator(this, arguments, function* paginateEndpoint_1() {
					let u = true;
					const l = Object.assign({}, c);
					while (u) {
						const c = yield __await(requestHttpWithBackoff(e, t, r, i, l));
						yield yield __await(c);
						if (c[o] !== null) {
							l[a] = c[o];
						} else {
							u = false;
						}
					}
				});
			}
			function getNftMetadata(e, t, r, i, a = 'getNftMetadata') {
				return __awaiter$1(this, void 0, void 0, function* () {
					const o = yield requestHttpWithBackoff(e, Rr.NFT, 'getNFTMetadata', a, {
						contractAddress: t,
						tokenId: u.gH.from(r).toString(),
						tokenType: sanitizeTokenType(i === null || i === void 0 ? void 0 : i.tokenType),
						tokenUriTimeoutInMs: i === null || i === void 0 ? void 0 : i.tokenUriTimeoutInMs,
						refreshCache: i === null || i === void 0 ? void 0 : i.refreshCache
					});
					return getNftFromRaw(o);
				});
			}
			function getNftMetadataBatch(e, t, r) {
				return __awaiter$1(this, void 0, void 0, function* () {
					const i = {
						tokens: t,
						tokenUriTimeoutInMs: r === null || r === void 0 ? void 0 : r.tokenUriTimeoutInMs,
						refreshCache: r === null || r === void 0 ? void 0 : r.refreshCache
					};
					const a = yield requestHttpWithBackoff(
						e,
						Rr.NFT,
						'getNFTMetadataBatch',
						'getNftMetadataBatch',
						{},
						{ method: 'POST', data: i }
					);
					return { nfts: a.nfts.map((e) => getNftFromRaw(e)) };
				});
			}
			function getContractMetadata(e, t, r = 'getContractMetadata') {
				return __awaiter$1(this, void 0, void 0, function* () {
					const i = yield requestHttpWithBackoff(e, Rr.NFT, 'getContractMetadata', r, {
						contractAddress: t
					});
					return getNftContractFromRaw(i);
				});
			}
			function getContractMetadataBatch(e, t) {
				return __awaiter$1(this, void 0, void 0, function* () {
					const r = yield requestHttpWithBackoff(
						e,
						Rr.NFT,
						'getContractMetadataBatch',
						'getContractMetadataBatch',
						{},
						{ method: 'POST', data: { contractAddresses: t } }
					);
					return { contracts: r.contracts.map(getNftContractFromRaw) };
				});
			}
			function getCollectionMetadata(e, t, r = 'getCollectionMetadata') {
				return __awaiter$1(this, void 0, void 0, function* () {
					const i = yield requestHttpWithBackoff(e, Rr.NFT, 'getCollectionMetadata', r, {
						collectionSlug: t
					});
					return getNftCollectionFromRaw(i);
				});
			}
			function getNftsForOwnerIterator(e, t, r, i = 'getNftsForOwnerIterator') {
				return __asyncGenerator(this, arguments, function* getNftsForOwnerIterator_1() {
					var a, o;
					const c = omitMetadataToWithMetadata(
						r === null || r === void 0 ? void 0 : r.omitMetadata
					);
					try {
						for (
							var u = __asyncValues(
									paginateEndpoint(e, Rr.NFT, 'getNFTsForOwner', i, 'pageKey', 'pageKey', {
										contractAddresses: r === null || r === void 0 ? void 0 : r.contractAddresses,
										pageKey: r === null || r === void 0 ? void 0 : r.pageKey,
										excludeFilters: r === null || r === void 0 ? void 0 : r.excludeFilters,
										includeFilters: r === null || r === void 0 ? void 0 : r.includeFilters,
										owner: t,
										withMetadata: c,
										tokenUriTimeoutInMs:
											r === null || r === void 0 ? void 0 : r.tokenUriTimeoutInMs,
										orderBy: r === null || r === void 0 ? void 0 : r.orderBy
									})
								),
								l;
							(l = yield __await(u.next())), !l.done;

						) {
							const e = l.value;
							for (const t of e.ownedNfts) {
								yield yield __await(
									Object.assign(Object.assign({}, nftFromGetNftResponse(t)), { balance: t.balance })
								);
							}
						}
					} catch (e) {
						a = { error: e };
					} finally {
						try {
							if (l && !l.done && (o = u.return)) yield __await(o.call(u));
						} finally {
							if (a) throw a.error;
						}
					}
				});
			}
			function getNftsForOwner(e, t, r, i = 'getNftsForOwner') {
				return __awaiter$1(this, void 0, void 0, function* () {
					const a = omitMetadataToWithMetadata(
						r === null || r === void 0 ? void 0 : r.omitMetadata
					);
					const o = yield requestHttpWithBackoff(e, Rr.NFT, 'getNFTsForOwner', i, {
						contractAddresses: r === null || r === void 0 ? void 0 : r.contractAddresses,
						pageKey: r === null || r === void 0 ? void 0 : r.pageKey,
						excludeFilters: r === null || r === void 0 ? void 0 : r.excludeFilters,
						includeFilters: r === null || r === void 0 ? void 0 : r.includeFilters,
						owner: t,
						pageSize: r === null || r === void 0 ? void 0 : r.pageSize,
						withMetadata: a,
						tokenUriTimeoutInMs: r === null || r === void 0 ? void 0 : r.tokenUriTimeoutInMs,
						orderBy: r === null || r === void 0 ? void 0 : r.orderBy
					});
					if (a) {
						return nullsToUndefined({
							ownedNfts: o.ownedNfts.map((e) =>
								Object.assign(Object.assign({}, getNftFromRaw(e)), { balance: e.balance })
							),
							pageKey: o.pageKey,
							totalCount: o.totalCount,
							validAt: o.validAt
						});
					}
					return nullsToUndefined({
						ownedNfts: o.ownedNfts.map((e) =>
							Object.assign(Object.assign({}, getBaseNftFromRaw(e)), { balance: e.balance })
						),
						pageKey: o.pageKey,
						totalCount: o.totalCount,
						validAt: o.validAt
					});
				});
			}
			function getNftsForContract(e, t, r, i = 'getNftsForContract') {
				var a;
				return __awaiter$1(this, void 0, void 0, function* () {
					const o = omitMetadataToWithMetadata(
						r === null || r === void 0 ? void 0 : r.omitMetadata
					);
					const c = yield requestHttpWithBackoff(e, Rr.NFT, 'getNFTsForContract', i, {
						contractAddress: t,
						pageKey: r === null || r === void 0 ? void 0 : r.pageKey,
						withMetadata: o,
						limit:
							(a = r === null || r === void 0 ? void 0 : r.pageSize) !== null && a !== void 0
								? a
								: undefined,
						tokenUriTimeoutInMs: r === null || r === void 0 ? void 0 : r.tokenUriTimeoutInMs
					});
					if (o) {
						return nullsToUndefined({
							nfts: c.nfts.map((e) => getNftFromRaw(e)),
							pageKey: c.pageKey
						});
					}
					return nullsToUndefined({
						nfts: c.nfts.map((e) => getBaseNftFromRaw(e, t)),
						pageKey: c.pageKey
					});
				});
			}
			function getNftsForContractIterator(e, t, r, i = 'getNftsForContractIterator') {
				return __asyncGenerator(this, arguments, function* getNftsForContractIterator_1() {
					var a, o;
					const c = omitMetadataToWithMetadata(
						r === null || r === void 0 ? void 0 : r.omitMetadata
					);
					try {
						for (
							var u = __asyncValues(
									paginateEndpoint(e, Rr.NFT, 'getNFTsForContract', i, 'pageKey', 'pageKey', {
										contractAddress: t,
										pageKey: r === null || r === void 0 ? void 0 : r.pageKey,
										withMetadata: c
									})
								),
								l;
							(l = yield __await(u.next())), !l.done;

						) {
							const e = l.value;
							for (const r of e.nfts) {
								yield yield __await(nftFromGetNftContractResponse(r, t));
							}
						}
					} catch (e) {
						a = { error: e };
					} finally {
						try {
							if (l && !l.done && (o = u.return)) yield __await(o.call(u));
						} finally {
							if (a) throw a.error;
						}
					}
				});
			}
			function getOwnersForContract(e, t, r, i = 'getOwnersForContract') {
				return __awaiter$1(this, void 0, void 0, function* () {
					const a = yield requestHttpWithBackoff(
						e,
						Rr.NFT,
						'getOwnersForContract',
						i,
						Object.assign(Object.assign({}, r), { contractAddress: t })
					);
					if (r === null || r === void 0 ? void 0 : r.withTokenBalances) {
						return nullsToUndefined({ owners: a.owners, pageKey: a.pageKey });
					}
					return nullsToUndefined({ owners: a.owners, pageKey: a.pageKey });
				});
			}
			function getContractsForOwner(e, t, r, i = 'getContractsForOwner') {
				return __awaiter$1(this, void 0, void 0, function* () {
					const a = yield requestHttpWithBackoff(e, Rr.NFT, 'getContractsForOwner', i, {
						owner: t,
						excludeFilters: r === null || r === void 0 ? void 0 : r.excludeFilters,
						includeFilters: r === null || r === void 0 ? void 0 : r.includeFilters,
						pageKey: r === null || r === void 0 ? void 0 : r.pageKey,
						pageSize: r === null || r === void 0 ? void 0 : r.pageSize,
						orderBy: r === null || r === void 0 ? void 0 : r.orderBy
					});
					return nullsToUndefined({
						contracts: a.contracts.map(getNftContractsForOwnerFromRaw),
						pageKey: a.pageKey,
						totalCount: a.totalCount
					});
				});
			}
			function getOwnersForNft(e, t, r, i, a = 'getOwnersForNft') {
				return __awaiter$1(this, void 0, void 0, function* () {
					return requestHttpWithBackoff(
						e,
						Rr.NFT,
						'getOwnersForNFT',
						a,
						Object.assign({ contractAddress: t, tokenId: u.gH.from(r).toString() }, i)
					);
				});
			}
			function getMintedNfts(e, t, r) {
				return __awaiter$1(this, void 0, void 0, function* () {
					const i = yield e.getProvider();
					const a = yield i._getAddress(t);
					const o = nftTokenTypeToCategory(r === null || r === void 0 ? void 0 : r.tokenType);
					const c = {
						fromBlock: '0x0',
						fromAddress: Ir,
						toAddress: a,
						excludeZeroValue: true,
						contractAddresses: r === null || r === void 0 ? void 0 : r.contractAddresses,
						category: o,
						maxCount: 100,
						pageKey: r === null || r === void 0 ? void 0 : r.pageKey
					};
					const u = yield getAssetTransfers(e, c, 'getMintedNfts');
					return getNftsForTransfers(e, u);
				});
			}
			function getTransfersForOwner(e, t, r, i) {
				return __awaiter$1(this, void 0, void 0, function* () {
					const a = yield e.getProvider();
					const o = yield a._getAddress(t);
					const c = nftTokenTypeToCategory(i === null || i === void 0 ? void 0 : i.tokenType);
					const u = {
						fromBlock: '0x0',
						excludeZeroValue: true,
						contractAddresses: i === null || i === void 0 ? void 0 : i.contractAddresses,
						category: c,
						maxCount: 100,
						pageKey: i === null || i === void 0 ? void 0 : i.pageKey
					};
					if (r === nr.TO) {
						u.toAddress = o;
					} else {
						u.fromAddress = o;
					}
					const l = yield getAssetTransfers(e, u, 'getTransfersForOwner');
					return getNftsForTransfers(e, l);
				});
			}
			function getTransfersForContract(e, t, r) {
				return __awaiter$1(this, void 0, void 0, function* () {
					const i = [rr.ERC721, rr.ERC1155, rr.SPECIALNFT];
					const a = yield e.getProvider();
					const o = (r === null || r === void 0 ? void 0 : r.fromBlock)
						? a.formatter.blockTag(yield a._getBlockTag(r.fromBlock))
						: '0x0';
					const c = (r === null || r === void 0 ? void 0 : r.toBlock)
						? a.formatter.blockTag(yield a._getBlockTag(r.toBlock))
						: undefined;
					const u = {
						fromBlock: o,
						toBlock: c,
						excludeZeroValue: true,
						contractAddresses: [t],
						order: r === null || r === void 0 ? void 0 : r.order,
						category: i,
						maxCount: 100,
						pageKey: r === null || r === void 0 ? void 0 : r.pageKey
					};
					const l = yield getAssetTransfers(e, u, 'getTransfersForContract');
					return getNftsForTransfers(e, l);
				});
			}
			function nftTokenTypeToCategory(e) {
				switch (e) {
					case vr.ERC721:
						return [rr.ERC721];
					case vr.ERC1155:
						return [rr.ERC1155];
					default:
						return [rr.ERC721, rr.ERC1155, rr.SPECIALNFT];
				}
			}
			function parse1155Transfer(e) {
				return e.erc1155Metadata.map((t) => ({
					contractAddress: e.rawContract.address,
					tokenId: t.tokenId,
					tokenType: vr.ERC1155
				}));
			}
			function verifyNftOwnership(e, t, r, i = 'verifyNftOwnership') {
				return __awaiter$1(this, void 0, void 0, function* () {
					if (typeof r === 'string') {
						const a = yield getNftsForOwner(
							e,
							t,
							{ contractAddresses: [r], omitMetadata: true },
							i
						);
						return a.ownedNfts.length > 0;
					} else {
						if (r.length === 0) {
							throw new Error('Must provide at least one contract address');
						}
						const a = yield getNftsForOwner(e, t, { contractAddresses: r, omitMetadata: true }, i);
						const o = r.reduce((e, t) => {
							e[t] = false;
							return e;
						}, {});
						for (const e of a.ownedNfts) {
							o[e.contractAddress] = true;
						}
						return o;
					}
				});
			}
			function isSpamContract(e, t, r = 'isSpamContract') {
				return __awaiter$1(this, void 0, void 0, function* () {
					return requestHttpWithBackoff(e, Rr.NFT, 'isSpamContract', r, { contractAddress: t });
				});
			}
			function getSpamContracts(e, t = 'getSpamContracts') {
				return __awaiter$1(this, void 0, void 0, function* () {
					return requestHttpWithBackoff(e, Rr.NFT, 'getSpamContracts', t, undefined);
				});
			}
			function reportSpam(e, t, r = 'reportSpam') {
				return __awaiter$1(this, void 0, void 0, function* () {
					void requestHttpWithBackoff(e, Rr.NFT, 'reportSpam', r, { contractAddress: t });
				});
			}
			function isAirdropNft(e, t, r, i = 'isAirdropNft') {
				return __awaiter$1(this, void 0, void 0, function* () {
					return requestHttpWithBackoff(e, Rr.NFT, 'isAirdropNFT', i, {
						contractAddress: t,
						tokenId: r
					});
				});
			}
			function getFloorPrice(e, t, r = 'getFloorPrice') {
				return __awaiter$1(this, void 0, void 0, function* () {
					const i = yield requestHttpWithBackoff(e, Rr.NFT, 'getFloorPrice', r, {
						contractAddress: t
					});
					return nullsToUndefined(i);
				});
			}
			function getNftSales(e, t = {}, r = 'getNftSales') {
				return __awaiter$1(this, void 0, void 0, function* () {
					const i = Object.assign({}, t);
					const a = yield requestHttpWithBackoff(e, Rr.NFT, 'getNFTSales', r, {
						fromBlock: i === null || i === void 0 ? void 0 : i.fromBlock,
						toBlock: i === null || i === void 0 ? void 0 : i.toBlock,
						order: i === null || i === void 0 ? void 0 : i.order,
						marketplace: i === null || i === void 0 ? void 0 : i.marketplace,
						contractAddress: i === null || i === void 0 ? void 0 : i.contractAddress,
						tokenId: (i === null || i === void 0 ? void 0 : i.tokenId)
							? u.gH.from(i === null || i === void 0 ? void 0 : i.tokenId).toString()
							: undefined,
						sellerAddress: i === null || i === void 0 ? void 0 : i.sellerAddress,
						buyerAddress: i === null || i === void 0 ? void 0 : i.buyerAddress,
						taker: i === null || i === void 0 ? void 0 : i.taker,
						limit: i === null || i === void 0 ? void 0 : i.limit,
						pageKey: i === null || i === void 0 ? void 0 : i.pageKey
					});
					return getNftSalesFromRaw(a);
				});
			}
			function computeRarity(e, t, r, i = 'computeRarity') {
				return __awaiter$1(this, void 0, void 0, function* () {
					const a = yield requestHttpWithBackoff(e, Rr.NFT, 'computeRarity', i, {
						contractAddress: t,
						tokenId: u.gH.from(r).toString()
					});
					return nullsToUndefined(a);
				});
			}
			function searchContractMetadata(e, t, r = 'searchContractMetadata') {
				return __awaiter$1(this, void 0, void 0, function* () {
					const i = yield requestHttpWithBackoff(e, Rr.NFT, 'searchContractMetadata', r, {
						query: t
					});
					return { contracts: i.contracts.map(getNftContractFromRaw) };
				});
			}
			function summarizeNftAttributes(e, t, r = 'summarizeNftAttributes') {
				return __awaiter$1(this, void 0, void 0, function* () {
					return requestHttpWithBackoff(e, Rr.NFT, 'summarizeNFTAttributes', r, {
						contractAddress: t
					});
				});
			}
			function refreshNftMetadata(e, t, r, i = 'refreshNftMetadata') {
				return __awaiter$1(this, void 0, void 0, function* () {
					const a = u.gH.from(r).toString();
					const o = yield getNftMetadata(e, t, a, undefined, i);
					const c = yield refresh(e, t, a, i);
					return o.timeLastUpdated !== c.timeLastUpdated;
				});
			}
			function refreshContract(e, t, r = 'refreshContract') {
				return __awaiter$1(this, void 0, void 0, function* () {
					const i = yield requestHttpWithBackoff(e, Rr.NFT, 'reingestContract', r, {
						contractAddress: t
					});
					return {
						contractAddress: i.contractAddress,
						refreshState: parseReingestionState(i.reingestionState),
						progress: i.progress
					};
				});
			}
			function refresh(e, t, r, i) {
				return __awaiter$1(this, void 0, void 0, function* () {
					const a = yield requestHttpWithBackoff(e, Rr.NFT, 'getNFTMetadata', i, {
						contractAddress: t,
						tokenId: u.gH.from(r).toString(),
						refreshCache: true
					});
					return getNftFromRaw(a);
				});
			}
			function nftFromGetNftResponse(e) {
				if (isNftWithMetadata(e)) {
					return getNftFromRaw(e);
				} else {
					return getBaseNftFromRaw(e);
				}
			}
			function nftFromGetNftContractResponse(e, t) {
				if (isNftWithMetadata(e)) {
					return getNftFromRaw(e);
				} else {
					return getBaseNftFromRaw(e, t);
				}
			}
			function isNftWithMetadata(e) {
				return e.name !== undefined;
			}
			function getNftsForTransfers(e, t) {
				return __awaiter$1(this, void 0, void 0, function* () {
					const r = t.transfers
						.filter((e) => e.rawContract.address !== null)
						.flatMap((e) => {
							var t;
							const r = getTokensFromTransfer(e);
							const i = {
								from: e.from,
								to: (t = e.to) !== null && t !== void 0 ? t : undefined,
								transactionHash: e.hash,
								blockNumber: e.blockNum
							};
							return r.map((e) => ({ metadata: i, token: e }));
						});
					if (r.length === 0) {
						return { nfts: [] };
					}
					const i = 100;
					const a = [];
					for (let e = 0; e < r.length; e += i) {
						a.push(r.slice(e, e + i));
					}
					const o = yield Promise.all(
						a.map((t) =>
							getNftMetadataBatch(
								e,
								t.map((e) => e.token)
							)
						)
					);
					const c = o.map((e) => e.nfts).flat();
					const l = new Map();
					c.forEach((e) => {
						const t = `${e.contract.address.toLowerCase()}-${u.gH.from(e.tokenId).toString()}`;
						l.set(t, e);
					});
					const d = r.map((e) => {
						const t = `${e.token.contractAddress.toLowerCase()}-${u.gH.from(e.token.tokenId).toString()}`;
						return Object.assign(Object.assign({}, l.get(t)), e.metadata);
					});
					return { nfts: d, pageKey: t.pageKey };
				});
			}
			function getTokensFromTransfer(e) {
				if (e.category === rr.ERC1155) {
					return parse1155Transfer(e);
				} else {
					return [
						{
							contractAddress: e.rawContract.address,
							tokenId: e.tokenId,
							tokenType: e.category === rr.ERC721 ? vr.ERC721 : undefined
						}
					];
				}
			}
			function omitMetadataToWithMetadata(e) {
				return e === undefined ? true : !e;
			}
			function parseReingestionState(e) {
				switch (e) {
					case 'does_not_exist':
						return Er.DOES_NOT_EXIST;
					case 'already_queued':
						return Er.ALREADY_QUEUED;
					case 'in_progress':
						return Er.IN_PROGRESS;
					case 'finished':
						return Er.FINISHED;
					case 'queued':
						return Er.QUEUED;
					case 'queue_failed':
						return Er.QUEUE_FAILED;
					default:
						throw new Error('Unknown reingestion state: ' + e);
				}
			}
			class NftNamespace {
				constructor(e) {
					this.config = e;
				}
				getNftMetadata(e, t, r, i) {
					let a;
					if (typeof r === 'object') {
						a = {
							tokenType: r.tokenType,
							tokenUriTimeoutInMs: r.tokenUriTimeoutInMs,
							refreshCache: r.refreshCache
						};
					} else {
						a = { tokenType: r, tokenUriTimeoutInMs: i };
					}
					return getNftMetadata(this.config, e, t, a);
				}
				getNftMetadataBatch(e, t) {
					return getNftMetadataBatch(this.config, e, t);
				}
				getContractMetadata(e) {
					return getContractMetadata(this.config, e);
				}
				getContractMetadataBatch(e) {
					return getContractMetadataBatch(this.config, e);
				}
				getCollectionMetadata(e) {
					return getCollectionMetadata(this.config, e);
				}
				getNftsForOwnerIterator(e, t) {
					return getNftsForOwnerIterator(this.config, e, t);
				}
				getNftsForOwner(e, t) {
					return getNftsForOwner(this.config, e, t);
				}
				getNftsForContract(e, t) {
					return getNftsForContract(this.config, e, t);
				}
				getNftsForContractIterator(e, t) {
					return getNftsForContractIterator(this.config, e, t);
				}
				getOwnersForContract(e, t) {
					return getOwnersForContract(this.config, e, t);
				}
				getOwnersForNft(e, t, r) {
					return getOwnersForNft(this.config, e, t, r);
				}
				getContractsForOwner(e, t) {
					return getContractsForOwner(this.config, e, t);
				}
				getTransfersForOwner(e, t, r) {
					return getTransfersForOwner(this.config, e, t, r);
				}
				getTransfersForContract(e, t) {
					return getTransfersForContract(this.config, e, t);
				}
				getMintedNfts(e, t) {
					return __awaiter$1(this, void 0, void 0, function* () {
						return getMintedNfts(this.config, e, t);
					});
				}
				verifyNftOwnership(e, t) {
					return verifyNftOwnership(this.config, e, t);
				}
				isSpamContract(e) {
					return isSpamContract(this.config, e);
				}
				getSpamContracts() {
					return getSpamContracts(this.config);
				}
				reportSpam(e) {
					return reportSpam(this.config, e);
				}
				isAirdropNft(e, t) {
					return isAirdropNft(this.config, e, t);
				}
				getFloorPrice(e) {
					return getFloorPrice(this.config, e);
				}
				getNftSales(e) {
					return getNftSales(this.config, e);
				}
				computeRarity(e, t) {
					return computeRarity(this.config, e, t);
				}
				searchContractMetadata(e) {
					return searchContractMetadata(this.config, e);
				}
				summarizeNftAttributes(e) {
					return summarizeNftAttributes(this.config, e);
				}
				refreshNftMetadata(e, t) {
					return refreshNftMetadata(this.config, e, t);
				}
				refreshContract(e) {
					return refreshContract(this.config, e);
				}
			}
			class NotifyNamespace {
				constructor(e) {
					this.config = e;
				}
				getAllWebhooks() {
					return __awaiter$1(this, void 0, void 0, function* () {
						this.verifyConfig();
						const e = yield this.sendWebhookRequest('team-webhooks', 'getAllWebhooks', {});
						return { webhooks: parseRawWebhookResponse(e), totalCount: e.data.length };
					});
				}
				getAddresses(e, t) {
					return __awaiter$1(this, void 0, void 0, function* () {
						this.verifyConfig();
						const r = typeof e === 'string' ? e : e.id;
						const i = yield this.sendWebhookRequest('webhook-addresses', 'getAddresses', {
							webhook_id: r,
							limit: t === null || t === void 0 ? void 0 : t.limit,
							after: t === null || t === void 0 ? void 0 : t.pageKey
						});
						return parseRawAddressActivityResponse(i);
					});
				}
				getGraphqlQuery(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						this.verifyConfig();
						const t = typeof e === 'string' ? e : e.id;
						const r = yield this.sendWebhookRequest(
							'dashboard-webhook-graphql-query',
							'getGraphqlQuery',
							{ webhook_id: t }
						);
						return parseRawCustomGraphqlWebhookResponse(r);
					});
				}
				getNftFilters(e, t) {
					return __awaiter$1(this, void 0, void 0, function* () {
						this.verifyConfig();
						const r = typeof e === 'string' ? e : e.id;
						const i = yield this.sendWebhookRequest('webhook-nft-filters', 'getNftFilters', {
							webhook_id: r,
							limit: t === null || t === void 0 ? void 0 : t.limit,
							after: t === null || t === void 0 ? void 0 : t.pageKey
						});
						return parseRawNftFiltersResponse(i);
					});
				}
				updateWebhook(e, t) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const r = typeof e === 'string' ? e : e.id;
						let i;
						let a;
						let o;
						let c;
						if ('isActive' in t) {
							i = 'update-webhook';
							a = 'updateWebhook';
							o = 'PUT';
							c = { webhook_id: r, is_active: t.isActive };
						} else if ('addFilters' in t || 'removeFilters' in t) {
							i = 'update-webhook-nft-filters';
							a = 'updateWebhookNftFilters';
							o = 'PATCH';
							c = {
								webhook_id: r,
								nft_filters_to_add: t.addFilters ? t.addFilters.map(nftFilterToParam) : [],
								nft_filters_to_remove: t.removeFilters ? t.removeFilters.map(nftFilterToParam) : []
							};
						} else if ('addMetadataFilters' in t || 'removeMetadataFilters' in t) {
							i = 'update-webhook-nft-metadata-filters';
							a = 'updateWebhookNftMetadataFilters';
							o = 'PATCH';
							c = {
								webhook_id: r,
								nft_metadata_filters_to_add: t.addMetadataFilters
									? t.addMetadataFilters.map(nftFilterToParam)
									: [],
								nft_metadata_filters_to_remove: t.removeMetadataFilters
									? t.removeMetadataFilters.map(nftFilterToParam)
									: []
							};
						} else if ('addAddresses' in t || 'removeAddresses' in t) {
							i = 'update-webhook-addresses';
							a = 'webhook:updateWebhookAddresses';
							o = 'PATCH';
							c = {
								webhook_id: r,
								addresses_to_add: yield this.resolveAddresses(t.addAddresses),
								addresses_to_remove: yield this.resolveAddresses(t.removeAddresses)
							};
						} else if ('newAddresses' in t) {
							i = 'update-webhook-addresses';
							a = 'webhook:updateWebhookAddress';
							o = 'PUT';
							c = { webhook_id: r, addresses: yield this.resolveAddresses(t.newAddresses) };
						} else {
							throw new Error('Invalid `update` param passed into `updateWebhook`');
						}
						yield this.sendWebhookRequest(i, a, {}, { method: o, data: c });
					});
				}
				createWebhook(e, t, r) {
					return __awaiter$1(this, void 0, void 0, function* () {
						let i;
						if (t === pr.MINED_TRANSACTION || t === pr.DROPPED_TRANSACTION || t === pr.GRAPHQL) {
							if (!('appId' in r)) {
								throw new Error('Transaction and GraphQL Webhooks require an app id.');
							}
							i = r.appId;
						}
						let a = fn.get(this.config.network);
						let o;
						let c;
						let l;
						let d;
						if (t === pr.NFT_ACTIVITY || t === pr.NFT_METADATA_UPDATE) {
							if (!('filters' in r) || r.filters.length === 0) {
								throw new Error('Nft Activity Webhooks require a non-empty array input.');
							}
							a = r.network ? fn.get(r.network) : a;
							const e = r.filters.map((e) =>
								e.tokenId
									? {
											contract_address: e.contractAddress,
											token_id: u.gH.from(e.tokenId).toString()
										}
									: { contract_address: e.contractAddress }
							);
							o = t === pr.NFT_ACTIVITY ? { nft_filters: e } : { nft_metadata_filters: e };
						} else if (t === pr.ADDRESS_ACTIVITY) {
							if (r === undefined || !('addresses' in r) || r.addresses.length === 0) {
								throw new Error('Address Activity Webhooks require a non-empty array input.');
							}
							a = r.network ? fn.get(r.network) : a;
							c = yield this.resolveAddresses(r.addresses);
						} else if (t == pr.GRAPHQL) {
							if (r === undefined || !('graphqlQuery' in r) || r.graphqlQuery.length === 0) {
								throw new Error('Custom Webhooks require a non-empty graphql query.');
							}
							a = r.network ? fn.get(r.network) : a;
							l = r.graphqlQuery;
							d = r.skipEmptyMessages;
						}
						const p = Object.assign(
							Object.assign(
								Object.assign(
									Object.assign(
										{ network: a, webhook_type: t, webhook_url: e },
										i && { app_id: i }
									),
									o
								),
								c && { addresses: c }
							),
							l && { graphql_query: { query: l, skip_empty_messages: !!d } }
						);
						const m = yield this.sendWebhookRequest(
							'create-webhook',
							'createWebhook',
							{},
							{ method: 'POST', data: p }
						);
						return parseRawWebhook(m.data);
					});
				}
				deleteWebhook(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						this.verifyConfig();
						const t = typeof e === 'string' ? e : e.id;
						const r = yield this.sendWebhookRequest(
							'delete-webhook',
							'deleteWebhook',
							{ webhook_id: t },
							{ method: 'DELETE' }
						);
						if ('message' in r) {
							throw new Error(`Webhook not found. Failed to delete webhook: ${t}`);
						}
					});
				}
				verifyConfig() {
					if (this.config.authToken === undefined) {
						throw new Error(
							'Using the Notify API requires setting the Alchemy Auth Token in ' +
								'the settings object when initializing Alchemy.'
						);
					}
				}
				sendWebhookRequest(e, t, r, i) {
					return requestHttpWithBackoff(
						this.config,
						Rr.WEBHOOK,
						e,
						t,
						r,
						Object.assign(Object.assign({}, i), {
							headers: Object.assign(
								{ 'X-Alchemy-Token': this.config.authToken },
								i === null || i === void 0 ? void 0 : i.headers
							)
						})
					);
				}
				resolveAddresses(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						if (e === undefined) {
							return [];
						}
						const t = [];
						const r = yield this.config.getProvider();
						for (const i of e) {
							const e = yield r.resolveName(i);
							if (e === null) {
								throw new Error(`Unable to resolve the ENS address: ${i}`);
							}
							t.push(e);
						}
						return t;
					});
				}
			}
			const cn = Object.fromEntries(Object.entries(er));
			const fn = Object.keys(er).reduce((e, t) => {
				if (t in cn) {
					e.set(cn[t], t);
				}
				return e;
			}, new Map());
			function parseRawWebhookResponse(e) {
				return e.data.map(parseRawWebhook);
			}
			function parseRawWebhook(e) {
				return Object.assign(
					{
						id: e.id,
						network: cn[e.network],
						type: e.webhook_type,
						url: e.webhook_url,
						isActive: e.is_active,
						timeCreated: new Date(e.time_created).toISOString(),
						signingKey: e.signing_key,
						version: e.version
					},
					e.app_id !== undefined && { appId: e.app_id }
				);
			}
			function parseRawAddressActivityResponse(e) {
				return {
					addresses: e.data,
					totalCount: e.pagination.total_count,
					pageKey: e.pagination.cursors.after
				};
			}
			function parseRawCustomGraphqlWebhookResponse(e) {
				return { graphqlQuery: e.data.graphql_query };
			}
			function parseRawNftFiltersResponse(e) {
				return {
					filters: e.data.map((e) =>
						e.token_id
							? { contractAddress: e.contract_address, tokenId: u.gH.from(e.token_id).toString() }
							: { contractAddress: e.contract_address }
					),
					totalCount: e.pagination.total_count,
					pageKey: e.pagination.cursors.after
				};
			}
			function nftFilterToParam(e) {
				return e.tokenId
					? { contract_address: e.contractAddress, token_id: u.gH.from(e.tokenId).toString() }
					: { contract_address: e.contractAddress };
			}
			const un = 'https://api.g.alchemy.com/prices/v1/alch-demo';
			function getTokenPriceByAddress(e, t, r = 'getTokenPriceByAddress') {
				return __awaiter$1(this, void 0, void 0, function* () {
					const i = yield requestHttpWithBackoff(
						e,
						Rr.PRICES,
						'tokens/by-address',
						r,
						{},
						{ method: 'POST', data: { addresses: t }, baseURL: un }
					);
					return nullsToUndefined(i);
				});
			}
			function getTokenPriceBySymbol(e, t, r = 'getTokenPriceBySymbol') {
				return __awaiter$1(this, void 0, void 0, function* () {
					const i = yield requestHttpWithBackoff(
						e,
						Rr.PRICES,
						'tokens/by-symbol',
						r,
						{ symbols: t },
						{
							paramsSerializer: (e) => {
								const t = new URLSearchParams();
								Object.entries(e).forEach(([e, r]) => {
									r.forEach((r) => t.append(e, r));
								});
								return t.toString();
							}
						}
					);
					return nullsToUndefined(i);
				});
			}
			function getHistoricalPriceBySymbol(e, t, r, i, a, o = 'getHistoricalPriceBySymbol') {
				return __awaiter$1(this, void 0, void 0, function* () {
					const c = yield requestHttpWithBackoff(
						e,
						Rr.PRICES,
						'tokens/historical',
						o,
						{},
						{
							method: 'POST',
							data: { symbol: t, startTime: r, endTime: i, interval: a },
							baseURL: un
						}
					);
					return nullsToUndefined(c);
				});
			}
			function getHistoricalPriceByAddress(e, t, r, i, a, o, c = 'getHistoricalPriceByAddress') {
				return __awaiter$1(this, void 0, void 0, function* () {
					const u = yield requestHttpWithBackoff(
						e,
						Rr.PRICES,
						'tokens/historical',
						c,
						{},
						{
							method: 'POST',
							data: { network: t, address: r, startTime: i, endTime: a, interval: o },
							baseURL: un
						}
					);
					return nullsToUndefined(u);
				});
			}
			class PricesNamespace {
				constructor(e) {
					this.config = e;
				}
				getTokenPriceByAddress(e) {
					return getTokenPriceByAddress(this.config, e);
				}
				getTokenPriceBySymbol(e) {
					return getTokenPriceBySymbol(this.config, e);
				}
				getHistoricalPriceBySymbol(e, t, r, i) {
					return getHistoricalPriceBySymbol(this.config, e, t, r, i);
				}
				getHistoricalPriceByAddress(e, t, r, i, a) {
					return getHistoricalPriceByAddress(this.config, e, t, r, i, a);
				}
			}
			const ln = [0.9, 1, 1.1, 1.2, 1.3];
			class TransactNamespace {
				constructor(e) {
					this.config = e;
				}
				sendPrivateTransaction(e, t, r) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const i = yield this.config.getProvider();
						const a = t ? toHex(t) : undefined;
						return i._send(
							'eth_sendPrivateTransaction',
							[{ tx: e, maxBlockNumber: a, preferences: r }],
							'sendPrivateTransaction'
						);
					});
				}
				cancelPrivateTransaction(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const t = yield this.config.getProvider();
						return t._send(
							'eth_cancelPrivateTransaction',
							[{ txHash: e }],
							'cancelPrivateTransaction'
						);
					});
				}
				simulateAssetChangesBundle(e, t) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const r = yield this.config.getProvider();
						const i = t !== undefined ? [e, t] : [e];
						const a = yield r._send(
							'alchemy_simulateAssetChangesBundle',
							i,
							'simulateAssetChangesBundle'
						);
						return nullsToUndefined(a);
					});
				}
				simulateAssetChanges(e, t) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const r = yield this.config.getProvider();
						const i = t !== undefined ? [e, t] : [e];
						const a = yield r._send('alchemy_simulateAssetChanges', i, 'simulateAssetChanges');
						return nullsToUndefined(a);
					});
				}
				simulateExecutionBundle(e, t) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const r = yield this.config.getProvider();
						const i = t !== undefined ? [e, t] : [e];
						const a = r._send('alchemy_simulateExecutionBundle', i, 'simulateExecutionBundle');
						return nullsToUndefined(a);
					});
				}
				simulateExecution(e, t) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const r = yield this.config.getProvider();
						const i = t !== undefined ? [e, t] : [e];
						const a = r._send('alchemy_simulateExecution', i, 'simulateExecution');
						return nullsToUndefined(a);
					});
				}
				getTransaction(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const t = yield this.config.getProvider();
						return t.getTransaction(e);
					});
				}
				sendTransaction(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const t = yield this.config.getProvider();
						return t.sendTransaction(e);
					});
				}
				estimateGas(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const t = yield this.config.getProvider();
						return t.estimateGas(e);
					});
				}
				getMaxPriorityFeePerGas() {
					return __awaiter$1(this, void 0, void 0, function* () {
						const e = yield this.config.getProvider();
						const t = yield e._send('eth_maxPriorityFeePerGas', [], 'getMaxPriorityFeePerGas');
						return fromHex(t);
					});
				}
				waitForTransaction(e, t, r) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const i = yield this.config.getProvider();
						return i.waitForTransaction(e, t, r);
					});
				}
				sendGasOptimizedTransaction(e, t) {
					return __awaiter$1(this, void 0, void 0, function* () {
						if (Array.isArray(e)) {
							return this._sendGasOptimizedTransaction(e, 'sendGasOptimizedTransactionPreSigned');
						}
						let r;
						let i;
						let a;
						const o = yield this.config.getProvider();
						try {
							r = yield this.estimateGas(e);
							i = yield this.getMaxPriorityFeePerGas();
							const t = yield o.getBlock('latest');
							a = t.baseFeePerGas.toNumber();
						} catch (e) {
							throw new Error(`Failed to estimate gas for transaction: ${e}`);
						}
						const c = generateGasSpreadTransactions(e, r.toNumber(), a, i);
						const u = yield Promise.all(c.map((e) => t.signTransaction(e)));
						return this._sendGasOptimizedTransaction(u, 'sendGasOptimizedTransactionGenerated');
					});
				}
				getGasOptimizedTransactionStatus(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const t = yield this.config.getProvider();
						return t._send(
							'alchemy_getGasOptimizedTransactionStatus',
							[e],
							'getGasOptimizedTransactionStatus'
						);
					});
				}
				_sendGasOptimizedTransaction(e, t) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const r = yield this.config.getProvider();
						return r._send('alchemy_sendGasOptimizedTransaction', [{ rawTransactions: e }], t);
					});
				}
			}
			function generateGasSpreadTransactions(e, t, r, i) {
				return ln.map((a) =>
					Object.assign(Object.assign({}, e), {
						gasLimit: t,
						maxFeePerGas: Math.round(r * a + i * a),
						maxPriorityFeePerGas: Math.round(a * i)
					})
				);
			}
			const dn = 'alchemy-pending-transactions';
			const hn = 'alchemy-mined-transactions';
			const pn = [dn, hn];
			class Event {
				constructor(e, t, r) {
					this.listener = t;
					this.tag = e;
					this.once = r;
					this._lastBlockNumber = -2;
					this._inflight = false;
				}
				get event() {
					switch (this.type) {
						case 'tx':
							return this.hash;
						case 'filter':
							return this.filter;
						default:
							return this.tag;
					}
				}
				get type() {
					return this.tag.split(':')[0];
				}
				get hash() {
					const e = this.tag.split(':');
					if (e[0] !== 'tx') {
						throw new Error('Not a transaction event');
					}
					return e[1];
				}
				get filter() {
					const e = this.tag.split(':');
					if (e[0] !== 'filter') {
						throw new Error('Not a transaction event');
					}
					const t = e[1];
					const r = deserializeTopics(e[2]);
					const i = {};
					if (r.length > 0) {
						i.topics = r;
					}
					if (t && t !== '*') {
						i.address = t;
					}
					return i;
				}
				pollable() {
					const e = ['block', 'network', 'pending', 'poll'];
					return this.tag.indexOf(':') >= 0 || e.indexOf(this.tag) >= 0;
				}
			}
			class EthersEvent extends Event {
				get fromAddress() {
					const e = this.tag.split(':');
					if (e[0] !== dn) {
						return undefined;
					}
					if (e[1] && e[1] !== '*') {
						return deserializeAddressField(e[1]);
					} else {
						return undefined;
					}
				}
				get toAddress() {
					const e = this.tag.split(':');
					if (e[0] !== dn) {
						return undefined;
					}
					if (e[2] && e[2] !== '*') {
						return deserializeAddressField(e[2]);
					} else {
						return undefined;
					}
				}
				get hashesOnly() {
					const e = this.tag.split(':');
					if (!pn.includes(e[0])) {
						return undefined;
					}
					if (e[3] && e[3] !== '*') {
						return e[3] === 'true';
					} else {
						return undefined;
					}
				}
				get includeRemoved() {
					const e = this.tag.split(':');
					if (e[0] !== hn) {
						return undefined;
					}
					if (e[2] && e[2] !== '*') {
						return e[2] === 'true';
					} else {
						return undefined;
					}
				}
				get addresses() {
					const e = this.tag.split(':');
					if (e[0] !== hn) {
						return undefined;
					}
					if (e[1] && e[1] !== '*') {
						return deserializeAddressesField(e[1]);
					} else {
						return undefined;
					}
				}
			}
			function isAlchemyEvent(e) {
				return typeof e === 'object' && 'method' in e;
			}
			function getAlchemyEventTag(e) {
				if (!isAlchemyEvent(e)) {
					throw new Error('Event tag requires AlchemyEventType');
				}
				if (e.method === ar.PENDING_TRANSACTIONS) {
					return serializePendingTransactionsEvent(e);
				} else if (e.method === ar.MINED_TRANSACTIONS) {
					return serializeMinedTransactionsEvent(e);
				} else {
					throw new Error(`Unrecognized AlchemyFilterEvent: ${e}`);
				}
			}
			function verifyAlchemyEventName(e) {
				if (!Object.values(ar).includes(e.method)) {
					throw new Error(
						`Invalid method name ${e.method}. Accepted method names: ${Object.values(ar)}`
					);
				}
			}
			function serializePendingTransactionsEvent(e) {
				const t = serializeAddressField(e.fromAddress);
				const r = serializeAddressField(e.toAddress);
				const i = serializeBooleanField(e.hashesOnly);
				return dn + ':' + t + ':' + r + ':' + i;
			}
			function serializeMinedTransactionsEvent(e) {
				const t = serializeAddressesField(e.addresses);
				const r = serializeBooleanField(e.includeRemoved);
				const i = serializeBooleanField(e.hashesOnly);
				return hn + ':' + t + ':' + r + ':' + i;
			}
			function serializeAddressesField(e) {
				if (e === undefined) {
					return '*';
				}
				return e
					.map((e) => serializeAddressField(e.to) + ',' + serializeAddressField(e.from))
					.join('|');
			}
			function serializeAddressField(e) {
				if (e === undefined) {
					return '*';
				} else if (Array.isArray(e)) {
					return e.join('|');
				} else {
					return e;
				}
			}
			function serializeBooleanField(e) {
				if (e === undefined) {
					return '*';
				} else {
					return e.toString();
				}
			}
			function deserializeTopics(e) {
				if (e === '') {
					return [];
				}
				return e.split(/&/g).map((e) => {
					if (e === '') {
						return [];
					}
					const t = e.split('|').map((e) => (e === 'null' ? null : e));
					return t.length === 1 ? t[0] : t;
				});
			}
			function deserializeAddressField(e) {
				if (e === '') {
					return undefined;
				}
				const t = e.split('|');
				return t.length === 1 ? t[0] : t;
			}
			function deserializeAddressesField(e) {
				if (e === '') {
					return undefined;
				}
				return e
					.split('|')
					.map((e) => e.split(','))
					.map((e) =>
						Object.assign(
							Object.assign({}, e[0] !== '*' && { to: e[0] }),
							e[1] !== '*' && { from: e[1] }
						)
					);
			}
			class WebSocketNamespace {
				constructor(e) {
					this.config = e;
				}
				on(e, t) {
					void (() =>
						__awaiter$1(this, void 0, void 0, function* () {
							const r = yield this.config.getWebSocketProvider();
							const i = yield this._resolveEnsAlchemyEvent(e);
							r.on(i, t);
						}))();
					return this;
				}
				once(e, t) {
					void (() =>
						__awaiter$1(this, void 0, void 0, function* () {
							const r = yield this.config.getWebSocketProvider();
							const i = yield this._resolveEnsAlchemyEvent(e);
							r.once(i, t);
						}))();
					return this;
				}
				off(e, t) {
					void (() =>
						__awaiter$1(this, void 0, void 0, function* () {
							const r = yield this.config.getWebSocketProvider();
							const i = yield this._resolveEnsAlchemyEvent(e);
							return r.off(i, t);
						}))();
					return this;
				}
				removeAllListeners(e) {
					void (() =>
						__awaiter$1(this, void 0, void 0, function* () {
							const t = yield this.config.getWebSocketProvider();
							const r = e ? yield this._resolveEnsAlchemyEvent(e) : undefined;
							t.removeAllListeners(r);
						}))();
					return this;
				}
				listenerCount(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const t = yield this.config.getWebSocketProvider();
						const r = e ? yield this._resolveEnsAlchemyEvent(e) : undefined;
						return t.listenerCount(r);
					});
				}
				listeners(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const t = yield this.config.getWebSocketProvider();
						const r = e ? yield this._resolveEnsAlchemyEvent(e) : undefined;
						return t.listeners(r);
					});
				}
				_resolveEnsAlchemyEvent(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						if (!isAlchemyEvent(e)) {
							return e;
						}
						if (e.method === ar.MINED_TRANSACTIONS && e.addresses) {
							const t = [];
							for (const r of e.addresses) {
								if (r.to) {
									r.to = yield this._resolveNameOrError(r.to);
								}
								if (r.from) {
									r.from = yield this._resolveNameOrError(r.from);
								}
								t.push(r);
							}
							e.addresses = t;
						} else if (e.method === ar.PENDING_TRANSACTIONS) {
							if (e.fromAddress) {
								if (typeof e.fromAddress === 'string') {
									e.fromAddress = yield this._resolveNameOrError(e.fromAddress);
								} else {
									e.fromAddress = yield Promise.all(
										e.fromAddress.map((e) => this._resolveNameOrError(e))
									);
								}
							}
							if (e.toAddress) {
								if (typeof e.toAddress === 'string') {
									e.toAddress = yield this._resolveNameOrError(e.toAddress);
								} else {
									e.toAddress = yield Promise.all(
										e.toAddress.map((e) => this._resolveNameOrError(e))
									);
								}
							}
						}
						return e;
					});
				}
				_resolveNameOrError(e) {
					return __awaiter$1(this, void 0, void 0, function* () {
						const t = yield this.config.getProvider();
						const r = yield t.resolveName(e);
						if (r === null) {
							throw new Error(`Unable to resolve the ENS address: ${e}`);
						}
						return r;
					});
				}
			}
			class Alchemy {
				constructor(e) {
					this.config = new AlchemyConfig(e);
					this.core = new CoreNamespace(this.config);
					this.nft = new NftNamespace(this.config);
					this.ws = new WebSocketNamespace(this.config);
					this.transact = new TransactNamespace(this.config);
					this.notify = new NotifyNamespace(this.config);
					this.debug = new DebugNamespace(this.config);
					this.prices = new PricesNamespace(this.config);
				}
			}
			class Wallet extends lib_esm_Wallet {
				constructor(e, t) {
					let r;
					if (t && ct.Kq.isProvider(t)) {
						r = t;
					}
					super(e, r);
					if (t && !ct.Kq.isProvider(t)) {
						this.alchemyProviderPromise = t.config.getProvider();
					}
				}
				getBalance(e) {
					return this.getWallet().then((t) => t.getBalance(e));
				}
				getTransactionCount(e) {
					return this.getWallet().then((t) => t.getTransactionCount(e));
				}
				estimateGas(e) {
					return this.getWallet().then((t) => t.estimateGas(e));
				}
				call(e, t) {
					return this.getWallet().then((r) => r.call(e, t));
				}
				populateTransaction(e) {
					return this.getWallet().then((t) => t.populateTransaction(e));
				}
				sendTransaction(e) {
					return this.getWallet().then((t) => t.sendTransaction(e));
				}
				getChainId() {
					return this.getWallet().then((e) => e.getChainId());
				}
				getGasPrice() {
					return this.getWallet().then((e) => e.getGasPrice());
				}
				getFeeData() {
					return this.getWallet().then((e) => e.getFeeData());
				}
				resolveName(e) {
					return this.getWallet().then((t) => t.resolveName(e));
				}
				getWallet() {
					return __awaiter$1(this, void 0, void 0, function* () {
						if (!this.alchemyProviderPromise) {
							return this.connect(this.provider);
						}
						return this.connect(yield this.alchemyProviderPromise);
					});
				}
			}
			class Contract extends (null && Contract$1) {}
			class ContractFactory extends (null && ContractFactory$1) {}
		},
		8071: (e, t, r) => {
			var i = t;
			i.bignum = r(3364);
			i.define = r(2300).define;
			i.base = r(3160);
			i.constants = r(6622);
			i.decoders = r(1300);
			i.encoders = r(6028);
		},
		2300: (e, t, r) => {
			var i = r(8071);
			var a = r(1193);
			var o = t;
			o.define = function define(e, t) {
				return new Entity(e, t);
			};
			function Entity(e, t) {
				this.name = e;
				this.body = t;
				this.decoders = {};
				this.encoders = {};
			}
			Entity.prototype._createNamed = function createNamed(e) {
				var t;
				try {
					t = r(168).runInThisContext(
						'(function ' + this.name + '(entity) {\n' + '  this._initNamed(entity);\n' + '})'
					);
				} catch (e) {
					t = function (e) {
						this._initNamed(e);
					};
				}
				a(t, e);
				t.prototype._initNamed = function initnamed(t) {
					e.call(this, t);
				};
				return new t(this);
			};
			Entity.prototype._getDecoder = function _getDecoder(e) {
				e = e || 'der';
				if (!this.decoders.hasOwnProperty(e)) this.decoders[e] = this._createNamed(i.decoders[e]);
				return this.decoders[e];
			};
			Entity.prototype.decode = function decode(e, t, r) {
				return this._getDecoder(t).decode(e, r);
			};
			Entity.prototype._getEncoder = function _getEncoder(e) {
				e = e || 'der';
				if (!this.encoders.hasOwnProperty(e)) this.encoders[e] = this._createNamed(i.encoders[e]);
				return this.encoders[e];
			};
			Entity.prototype.encode = function encode(e, t, r) {
				return this._getEncoder(t).encode(e, r);
			};
		},
		6216: (e, t, r) => {
			var i = r(1193);
			var a = r(3160).Reporter;
			var o = r(6533).Buffer;
			function DecoderBuffer(e, t) {
				a.call(this, t);
				if (!o.isBuffer(e)) {
					this.error('Input not Buffer');
					return;
				}
				this.base = e;
				this.offset = 0;
				this.length = e.length;
			}
			i(DecoderBuffer, a);
			t.t = DecoderBuffer;
			DecoderBuffer.prototype.save = function save() {
				return { offset: this.offset, reporter: a.prototype.save.call(this) };
			};
			DecoderBuffer.prototype.restore = function restore(e) {
				var t = new DecoderBuffer(this.base);
				t.offset = e.offset;
				t.length = this.offset;
				this.offset = e.offset;
				a.prototype.restore.call(this, e.reporter);
				return t;
			};
			DecoderBuffer.prototype.isEmpty = function isEmpty() {
				return this.offset === this.length;
			};
			DecoderBuffer.prototype.readUInt8 = function readUInt8(e) {
				if (this.offset + 1 <= this.length) return this.base.readUInt8(this.offset++, true);
				else return this.error(e || 'DecoderBuffer overrun');
			};
			DecoderBuffer.prototype.skip = function skip(e, t) {
				if (!(this.offset + e <= this.length)) return this.error(t || 'DecoderBuffer overrun');
				var r = new DecoderBuffer(this.base);
				r._reporterState = this._reporterState;
				r.offset = this.offset;
				r.length = this.offset + e;
				this.offset += e;
				return r;
			};
			DecoderBuffer.prototype.raw = function raw(e) {
				return this.base.slice(e ? e.offset : this.offset, this.length);
			};
			function EncoderBuffer(e, t) {
				if (Array.isArray(e)) {
					this.length = 0;
					this.value = e.map(function (e) {
						if (!(e instanceof EncoderBuffer)) e = new EncoderBuffer(e, t);
						this.length += e.length;
						return e;
					}, this);
				} else if (typeof e === 'number') {
					if (!(0 <= e && e <= 255)) return t.error('non-byte EncoderBuffer value');
					this.value = e;
					this.length = 1;
				} else if (typeof e === 'string') {
					this.value = e;
					this.length = o.byteLength(e);
				} else if (o.isBuffer(e)) {
					this.value = e;
					this.length = e.length;
				} else {
					return t.error('Unsupported type: ' + typeof e);
				}
			}
			t.d = EncoderBuffer;
			EncoderBuffer.prototype.join = function join(e, t) {
				if (!e) e = new o(this.length);
				if (!t) t = 0;
				if (this.length === 0) return e;
				if (Array.isArray(this.value)) {
					this.value.forEach(function (r) {
						r.join(e, t);
						t += r.length;
					});
				} else {
					if (typeof this.value === 'number') e[t] = this.value;
					else if (typeof this.value === 'string') e.write(this.value, t);
					else if (o.isBuffer(this.value)) this.value.copy(e, t);
					t += this.length;
				}
				return e;
			};
		},
		3160: (e, t, r) => {
			var i = t;
			i.Reporter = r(8031).a;
			i.DecoderBuffer = r(6216).t;
			i.EncoderBuffer = r(6216).d;
			i.Node = r(3558);
		},
		3558: (e, t, r) => {
			var i = r(3160).Reporter;
			var a = r(3160).EncoderBuffer;
			var o = r(3160).DecoderBuffer;
			var c = r(5578);
			var u = [
				'seq',
				'seqof',
				'set',
				'setof',
				'objid',
				'bool',
				'gentime',
				'utctime',
				'null_',
				'enum',
				'int',
				'objDesc',
				'bitstr',
				'bmpstr',
				'charstr',
				'genstr',
				'graphstr',
				'ia5str',
				'iso646str',
				'numstr',
				'octstr',
				'printstr',
				't61str',
				'unistr',
				'utf8str',
				'videostr'
			];
			var l = [
				'key',
				'obj',
				'use',
				'optional',
				'explicit',
				'implicit',
				'def',
				'choice',
				'any',
				'contains'
			].concat(u);
			var d = [
				'_peekTag',
				'_decodeTag',
				'_use',
				'_decodeStr',
				'_decodeObjid',
				'_decodeTime',
				'_decodeNull',
				'_decodeInt',
				'_decodeBool',
				'_decodeList',
				'_encodeComposite',
				'_encodeStr',
				'_encodeObjid',
				'_encodeTime',
				'_encodeNull',
				'_encodeInt',
				'_encodeBool'
			];
			function Node(e, t) {
				var r = {};
				this._baseState = r;
				r.enc = e;
				r.parent = t || null;
				r.children = null;
				r.tag = null;
				r.args = null;
				r.reverseArgs = null;
				r.choice = null;
				r.optional = false;
				r.any = false;
				r.obj = false;
				r.use = null;
				r.useDecoder = null;
				r.key = null;
				r['default'] = null;
				r.explicit = null;
				r.implicit = null;
				r.contains = null;
				if (!r.parent) {
					r.children = [];
					this._wrap();
				}
			}
			e.exports = Node;
			var p = [
				'enc',
				'parent',
				'children',
				'tag',
				'args',
				'reverseArgs',
				'choice',
				'optional',
				'any',
				'obj',
				'use',
				'alteredUse',
				'key',
				'default',
				'explicit',
				'implicit',
				'contains'
			];
			Node.prototype.clone = function clone() {
				var e = this._baseState;
				var t = {};
				p.forEach(function (r) {
					t[r] = e[r];
				});
				var r = new this.constructor(t.parent);
				r._baseState = t;
				return r;
			};
			Node.prototype._wrap = function wrap() {
				var e = this._baseState;
				l.forEach(function (t) {
					this[t] = function _wrappedMethod() {
						var r = new this.constructor(this);
						e.children.push(r);
						return r[t].apply(r, arguments);
					};
				}, this);
			};
			Node.prototype._init = function init(e) {
				var t = this._baseState;
				c(t.parent === null);
				e.call(this);
				t.children = t.children.filter(function (e) {
					return e._baseState.parent === this;
				}, this);
				c.equal(t.children.length, 1, 'Root node can have only one child');
			};
			Node.prototype._useArgs = function useArgs(e) {
				var t = this._baseState;
				var r = e.filter(function (e) {
					return e instanceof this.constructor;
				}, this);
				e = e.filter(function (e) {
					return !(e instanceof this.constructor);
				}, this);
				if (r.length !== 0) {
					c(t.children === null);
					t.children = r;
					r.forEach(function (e) {
						e._baseState.parent = this;
					}, this);
				}
				if (e.length !== 0) {
					c(t.args === null);
					t.args = e;
					t.reverseArgs = e.map(function (e) {
						if (typeof e !== 'object' || e.constructor !== Object) return e;
						var t = {};
						Object.keys(e).forEach(function (r) {
							if (r == (r | 0)) r |= 0;
							var i = e[r];
							t[i] = r;
						});
						return t;
					});
				}
			};
			d.forEach(function (e) {
				Node.prototype[e] = function _overrided() {
					var t = this._baseState;
					throw new Error(e + ' not implemented for encoding: ' + t.enc);
				};
			});
			u.forEach(function (e) {
				Node.prototype[e] = function _tagMethod() {
					var t = this._baseState;
					var r = Array.prototype.slice.call(arguments);
					c(t.tag === null);
					t.tag = e;
					this._useArgs(r);
					return this;
				};
			});
			Node.prototype.use = function use(e) {
				c(e);
				var t = this._baseState;
				c(t.use === null);
				t.use = e;
				return this;
			};
			Node.prototype.optional = function optional() {
				var e = this._baseState;
				e.optional = true;
				return this;
			};
			Node.prototype.def = function def(e) {
				var t = this._baseState;
				c(t['default'] === null);
				t['default'] = e;
				t.optional = true;
				return this;
			};
			Node.prototype.explicit = function explicit(e) {
				var t = this._baseState;
				c(t.explicit === null && t.implicit === null);
				t.explicit = e;
				return this;
			};
			Node.prototype.implicit = function implicit(e) {
				var t = this._baseState;
				c(t.explicit === null && t.implicit === null);
				t.implicit = e;
				return this;
			};
			Node.prototype.obj = function obj() {
				var e = this._baseState;
				var t = Array.prototype.slice.call(arguments);
				e.obj = true;
				if (t.length !== 0) this._useArgs(t);
				return this;
			};
			Node.prototype.key = function key(e) {
				var t = this._baseState;
				c(t.key === null);
				t.key = e;
				return this;
			};
			Node.prototype.any = function any() {
				var e = this._baseState;
				e.any = true;
				return this;
			};
			Node.prototype.choice = function choice(e) {
				var t = this._baseState;
				c(t.choice === null);
				t.choice = e;
				this._useArgs(
					Object.keys(e).map(function (t) {
						return e[t];
					})
				);
				return this;
			};
			Node.prototype.contains = function contains(e) {
				var t = this._baseState;
				c(t.use === null);
				t.contains = e;
				return this;
			};
			Node.prototype._decode = function decode(e, t) {
				var r = this._baseState;
				if (r.parent === null) return e.wrapResult(r.children[0]._decode(e, t));
				var i = r['default'];
				var a = true;
				var c = null;
				if (r.key !== null) c = e.enterKey(r.key);
				if (r.optional) {
					var u = null;
					if (r.explicit !== null) u = r.explicit;
					else if (r.implicit !== null) u = r.implicit;
					else if (r.tag !== null) u = r.tag;
					if (u === null && !r.any) {
						var l = e.save();
						try {
							if (r.choice === null) this._decodeGeneric(r.tag, e, t);
							else this._decodeChoice(e, t);
							a = true;
						} catch (e) {
							a = false;
						}
						e.restore(l);
					} else {
						a = this._peekTag(e, u, r.any);
						if (e.isError(a)) return a;
					}
				}
				var d;
				if (r.obj && a) d = e.enterObject();
				if (a) {
					if (r.explicit !== null) {
						var p = this._decodeTag(e, r.explicit);
						if (e.isError(p)) return p;
						e = p;
					}
					var m = e.offset;
					if (r.use === null && r.choice === null) {
						if (r.any) var l = e.save();
						var g = this._decodeTag(e, r.implicit !== null ? r.implicit : r.tag, r.any);
						if (e.isError(g)) return g;
						if (r.any) i = e.raw(l);
						else e = g;
					}
					if (t && t.track && r.tag !== null) t.track(e.path(), m, e.length, 'tagged');
					if (t && t.track && r.tag !== null) t.track(e.path(), e.offset, e.length, 'content');
					if (r.any) i = i;
					else if (r.choice === null) i = this._decodeGeneric(r.tag, e, t);
					else i = this._decodeChoice(e, t);
					if (e.isError(i)) return i;
					if (!r.any && r.choice === null && r.children !== null) {
						r.children.forEach(function decodeChildren(r) {
							r._decode(e, t);
						});
					}
					if (r.contains && (r.tag === 'octstr' || r.tag === 'bitstr')) {
						var v = new o(i);
						i = this._getUse(r.contains, e._reporterState.obj)._decode(v, t);
					}
				}
				if (r.obj && a) i = e.leaveObject(d);
				if (r.key !== null && (i !== null || a === true)) e.leaveKey(c, r.key, i);
				else if (c !== null) e.exitKey(c);
				return i;
			};
			Node.prototype._decodeGeneric = function decodeGeneric(e, t, r) {
				var i = this._baseState;
				if (e === 'seq' || e === 'set') return null;
				if (e === 'seqof' || e === 'setof') return this._decodeList(t, e, i.args[0], r);
				else if (/str$/.test(e)) return this._decodeStr(t, e, r);
				else if (e === 'objid' && i.args) return this._decodeObjid(t, i.args[0], i.args[1], r);
				else if (e === 'objid') return this._decodeObjid(t, null, null, r);
				else if (e === 'gentime' || e === 'utctime') return this._decodeTime(t, e, r);
				else if (e === 'null_') return this._decodeNull(t, r);
				else if (e === 'bool') return this._decodeBool(t, r);
				else if (e === 'objDesc') return this._decodeStr(t, e, r);
				else if (e === 'int' || e === 'enum') return this._decodeInt(t, i.args && i.args[0], r);
				if (i.use !== null) {
					return this._getUse(i.use, t._reporterState.obj)._decode(t, r);
				} else {
					return t.error('unknown tag: ' + e);
				}
			};
			Node.prototype._getUse = function _getUse(e, t) {
				var r = this._baseState;
				r.useDecoder = this._use(e, t);
				c(r.useDecoder._baseState.parent === null);
				r.useDecoder = r.useDecoder._baseState.children[0];
				if (r.implicit !== r.useDecoder._baseState.implicit) {
					r.useDecoder = r.useDecoder.clone();
					r.useDecoder._baseState.implicit = r.implicit;
				}
				return r.useDecoder;
			};
			Node.prototype._decodeChoice = function decodeChoice(e, t) {
				var r = this._baseState;
				var i = null;
				var a = false;
				Object.keys(r.choice).some(function (o) {
					var c = e.save();
					var u = r.choice[o];
					try {
						var l = u._decode(e, t);
						if (e.isError(l)) return false;
						i = { type: o, value: l };
						a = true;
					} catch (t) {
						e.restore(c);
						return false;
					}
					return true;
				}, this);
				if (!a) return e.error('Choice not matched');
				return i;
			};
			Node.prototype._createEncoderBuffer = function createEncoderBuffer(e) {
				return new a(e, this.reporter);
			};
			Node.prototype._encode = function encode(e, t, r) {
				var i = this._baseState;
				if (i['default'] !== null && i['default'] === e) return;
				var a = this._encodeValue(e, t, r);
				if (a === undefined) return;
				if (this._skipDefault(a, t, r)) return;
				return a;
			};
			Node.prototype._encodeValue = function encode(e, t, r) {
				var a = this._baseState;
				if (a.parent === null) return a.children[0]._encode(e, t || new i());
				var o = null;
				this.reporter = t;
				if (a.optional && e === undefined) {
					if (a['default'] !== null) e = a['default'];
					else return;
				}
				var c = null;
				var u = false;
				if (a.any) {
					o = this._createEncoderBuffer(e);
				} else if (a.choice) {
					o = this._encodeChoice(e, t);
				} else if (a.contains) {
					c = this._getUse(a.contains, r)._encode(e, t);
					u = true;
				} else if (a.children) {
					c = a.children
						.map(function (r) {
							if (r._baseState.tag === 'null_') return r._encode(null, t, e);
							if (r._baseState.key === null) return t.error('Child should have a key');
							var i = t.enterKey(r._baseState.key);
							if (typeof e !== 'object') return t.error('Child expected, but input is not object');
							var a = r._encode(e[r._baseState.key], t, e);
							t.leaveKey(i);
							return a;
						}, this)
						.filter(function (e) {
							return e;
						});
					c = this._createEncoderBuffer(c);
				} else {
					if (a.tag === 'seqof' || a.tag === 'setof') {
						if (!(a.args && a.args.length === 1)) return t.error('Too many args for : ' + a.tag);
						if (!Array.isArray(e)) return t.error('seqof/setof, but data is not Array');
						var l = this.clone();
						l._baseState.implicit = null;
						c = this._createEncoderBuffer(
							e.map(function (r) {
								var i = this._baseState;
								return this._getUse(i.args[0], e)._encode(r, t);
							}, l)
						);
					} else if (a.use !== null) {
						o = this._getUse(a.use, r)._encode(e, t);
					} else {
						c = this._encodePrimitive(a.tag, e);
						u = true;
					}
				}
				var o;
				if (!a.any && a.choice === null) {
					var d = a.implicit !== null ? a.implicit : a.tag;
					var p = a.implicit === null ? 'universal' : 'context';
					if (d === null) {
						if (a.use === null) t.error('Tag could be omitted only for .use()');
					} else {
						if (a.use === null) o = this._encodeComposite(d, u, p, c);
					}
				}
				if (a.explicit !== null) o = this._encodeComposite(a.explicit, false, 'context', o);
				return o;
			};
			Node.prototype._encodeChoice = function encodeChoice(e, t) {
				var r = this._baseState;
				var i = r.choice[e.type];
				if (!i) {
					c(false, e.type + ' not found in ' + JSON.stringify(Object.keys(r.choice)));
				}
				return i._encode(e.value, t);
			};
			Node.prototype._encodePrimitive = function encodePrimitive(e, t) {
				var r = this._baseState;
				if (/str$/.test(e)) return this._encodeStr(t, e);
				else if (e === 'objid' && r.args) return this._encodeObjid(t, r.reverseArgs[0], r.args[1]);
				else if (e === 'objid') return this._encodeObjid(t, null, null);
				else if (e === 'gentime' || e === 'utctime') return this._encodeTime(t, e);
				else if (e === 'null_') return this._encodeNull();
				else if (e === 'int' || e === 'enum') return this._encodeInt(t, r.args && r.reverseArgs[0]);
				else if (e === 'bool') return this._encodeBool(t);
				else if (e === 'objDesc') return this._encodeStr(t, e);
				else throw new Error('Unsupported tag: ' + e);
			};
			Node.prototype._isNumstr = function isNumstr(e) {
				return /^[0-9 ]*$/.test(e);
			};
			Node.prototype._isPrintstr = function isPrintstr(e) {
				return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(e);
			};
		},
		8031: (e, t, r) => {
			var i = r(1193);
			function Reporter(e) {
				this._reporterState = { obj: null, path: [], options: e || {}, errors: [] };
			}
			t.a = Reporter;
			Reporter.prototype.isError = function isError(e) {
				return e instanceof ReporterError;
			};
			Reporter.prototype.save = function save() {
				var e = this._reporterState;
				return { obj: e.obj, pathLen: e.path.length };
			};
			Reporter.prototype.restore = function restore(e) {
				var t = this._reporterState;
				t.obj = e.obj;
				t.path = t.path.slice(0, e.pathLen);
			};
			Reporter.prototype.enterKey = function enterKey(e) {
				return this._reporterState.path.push(e);
			};
			Reporter.prototype.exitKey = function exitKey(e) {
				var t = this._reporterState;
				t.path = t.path.slice(0, e - 1);
			};
			Reporter.prototype.leaveKey = function leaveKey(e, t, r) {
				var i = this._reporterState;
				this.exitKey(e);
				if (i.obj !== null) i.obj[t] = r;
			};
			Reporter.prototype.path = function path() {
				return this._reporterState.path.join('/');
			};
			Reporter.prototype.enterObject = function enterObject() {
				var e = this._reporterState;
				var t = e.obj;
				e.obj = {};
				return t;
			};
			Reporter.prototype.leaveObject = function leaveObject(e) {
				var t = this._reporterState;
				var r = t.obj;
				t.obj = e;
				return r;
			};
			Reporter.prototype.error = function error(e) {
				var t;
				var r = this._reporterState;
				var i = e instanceof ReporterError;
				if (i) {
					t = e;
				} else {
					t = new ReporterError(
						r.path
							.map(function (e) {
								return '[' + JSON.stringify(e) + ']';
							})
							.join(''),
						e.message || e,
						e.stack
					);
				}
				if (!r.options.partial) throw t;
				if (!i) r.errors.push(t);
				return t;
			};
			Reporter.prototype.wrapResult = function wrapResult(e) {
				var t = this._reporterState;
				if (!t.options.partial) return e;
				return { result: this.isError(e) ? null : e, errors: t.errors };
			};
			function ReporterError(e, t) {
				this.path = e;
				this.rethrow(t);
			}
			i(ReporterError, Error);
			ReporterError.prototype.rethrow = function rethrow(e) {
				this.message = e + ' at: ' + (this.path || '(shallow)');
				if (Error.captureStackTrace) Error.captureStackTrace(this, ReporterError);
				if (!this.stack) {
					try {
						throw new Error(this.message);
					} catch (e) {
						this.stack = e.stack;
					}
				}
				return this;
			};
		},
		4029: (e, t, r) => {
			var i = r(6622);
			t.tagClass = { 0: 'universal', 1: 'application', 2: 'context', 3: 'private' };
			t.tagClassByName = i._reverse(t.tagClass);
			t.tag = {
				0: 'end',
				1: 'bool',
				2: 'int',
				3: 'bitstr',
				4: 'octstr',
				5: 'null_',
				6: 'objid',
				7: 'objDesc',
				8: 'external',
				9: 'real',
				10: 'enum',
				11: 'embed',
				12: 'utf8str',
				13: 'relativeOid',
				16: 'seq',
				17: 'set',
				18: 'numstr',
				19: 'printstr',
				20: 't61str',
				21: 'videostr',
				22: 'ia5str',
				23: 'utctime',
				24: 'gentime',
				25: 'graphstr',
				26: 'iso646str',
				27: 'genstr',
				28: 'unistr',
				29: 'charstr',
				30: 'bmpstr'
			};
			t.tagByName = i._reverse(t.tag);
		},
		6622: (e, t, r) => {
			var i = t;
			i._reverse = function reverse(e) {
				var t = {};
				Object.keys(e).forEach(function (r) {
					if ((r | 0) == r) r = r | 0;
					var i = e[r];
					t[i] = r;
				});
				return t;
			};
			i.der = r(4029);
		},
		7779: (e, t, r) => {
			var i = r(1193);
			var a = r(8071);
			var o = a.base;
			var c = a.bignum;
			var u = a.constants.der;
			function DERDecoder(e) {
				this.enc = 'der';
				this.name = e.name;
				this.entity = e;
				this.tree = new DERNode();
				this.tree._init(e.body);
			}
			e.exports = DERDecoder;
			DERDecoder.prototype.decode = function decode(e, t) {
				if (!(e instanceof o.DecoderBuffer)) e = new o.DecoderBuffer(e, t);
				return this.tree._decode(e, t);
			};
			function DERNode(e) {
				o.Node.call(this, 'der', e);
			}
			i(DERNode, o.Node);
			DERNode.prototype._peekTag = function peekTag(e, t, r) {
				if (e.isEmpty()) return false;
				var i = e.save();
				var a = derDecodeTag(e, 'Failed to peek tag: "' + t + '"');
				if (e.isError(a)) return a;
				e.restore(i);
				return a.tag === t || a.tagStr === t || a.tagStr + 'of' === t || r;
			};
			DERNode.prototype._decodeTag = function decodeTag(e, t, r) {
				var i = derDecodeTag(e, 'Failed to decode tag of "' + t + '"');
				if (e.isError(i)) return i;
				var a = derDecodeLen(e, i.primitive, 'Failed to get length of "' + t + '"');
				if (e.isError(a)) return a;
				if (!r && i.tag !== t && i.tagStr !== t && i.tagStr + 'of' !== t) {
					return e.error('Failed to match tag: "' + t + '"');
				}
				if (i.primitive || a !== null) return e.skip(a, 'Failed to match body of: "' + t + '"');
				var o = e.save();
				var c = this._skipUntilEnd(e, 'Failed to skip indefinite length body: "' + this.tag + '"');
				if (e.isError(c)) return c;
				a = e.offset - o.offset;
				e.restore(o);
				return e.skip(a, 'Failed to match body of: "' + t + '"');
			};
			DERNode.prototype._skipUntilEnd = function skipUntilEnd(e, t) {
				while (true) {
					var r = derDecodeTag(e, t);
					if (e.isError(r)) return r;
					var i = derDecodeLen(e, r.primitive, t);
					if (e.isError(i)) return i;
					var a;
					if (r.primitive || i !== null) a = e.skip(i);
					else a = this._skipUntilEnd(e, t);
					if (e.isError(a)) return a;
					if (r.tagStr === 'end') break;
				}
			};
			DERNode.prototype._decodeList = function decodeList(e, t, r, i) {
				var a = [];
				while (!e.isEmpty()) {
					var o = this._peekTag(e, 'end');
					if (e.isError(o)) return o;
					var c = r.decode(e, 'der', i);
					if (e.isError(c) && o) break;
					a.push(c);
				}
				return a;
			};
			DERNode.prototype._decodeStr = function decodeStr(e, t) {
				if (t === 'bitstr') {
					var r = e.readUInt8();
					if (e.isError(r)) return r;
					return { unused: r, data: e.raw() };
				} else if (t === 'bmpstr') {
					var i = e.raw();
					if (i.length % 2 === 1) return e.error('Decoding of string type: bmpstr length mismatch');
					var a = '';
					for (var o = 0; o < i.length / 2; o++) {
						a += String.fromCharCode(i.readUInt16BE(o * 2));
					}
					return a;
				} else if (t === 'numstr') {
					var c = e.raw().toString('ascii');
					if (!this._isNumstr(c)) {
						return e.error('Decoding of string type: ' + 'numstr unsupported characters');
					}
					return c;
				} else if (t === 'octstr') {
					return e.raw();
				} else if (t === 'objDesc') {
					return e.raw();
				} else if (t === 'printstr') {
					var u = e.raw().toString('ascii');
					if (!this._isPrintstr(u)) {
						return e.error('Decoding of string type: ' + 'printstr unsupported characters');
					}
					return u;
				} else if (/str$/.test(t)) {
					return e.raw().toString();
				} else {
					return e.error('Decoding of string type: ' + t + ' unsupported');
				}
			};
			DERNode.prototype._decodeObjid = function decodeObjid(e, t, r) {
				var i;
				var a = [];
				var o = 0;
				while (!e.isEmpty()) {
					var c = e.readUInt8();
					o <<= 7;
					o |= c & 127;
					if ((c & 128) === 0) {
						a.push(o);
						o = 0;
					}
				}
				if (c & 128) a.push(o);
				var u = (a[0] / 40) | 0;
				var l = a[0] % 40;
				if (r) i = a;
				else i = [u, l].concat(a.slice(1));
				if (t) {
					var d = t[i.join(' ')];
					if (d === undefined) d = t[i.join('.')];
					if (d !== undefined) i = d;
				}
				return i;
			};
			DERNode.prototype._decodeTime = function decodeTime(e, t) {
				var r = e.raw().toString();
				if (t === 'gentime') {
					var i = r.slice(0, 4) | 0;
					var a = r.slice(4, 6) | 0;
					var o = r.slice(6, 8) | 0;
					var c = r.slice(8, 10) | 0;
					var u = r.slice(10, 12) | 0;
					var l = r.slice(12, 14) | 0;
				} else if (t === 'utctime') {
					var i = r.slice(0, 2) | 0;
					var a = r.slice(2, 4) | 0;
					var o = r.slice(4, 6) | 0;
					var c = r.slice(6, 8) | 0;
					var u = r.slice(8, 10) | 0;
					var l = r.slice(10, 12) | 0;
					if (i < 70) i = 2e3 + i;
					else i = 1900 + i;
				} else {
					return e.error('Decoding ' + t + ' time is not supported yet');
				}
				return Date.UTC(i, a - 1, o, c, u, l, 0);
			};
			DERNode.prototype._decodeNull = function decodeNull(e) {
				return null;
			};
			DERNode.prototype._decodeBool = function decodeBool(e) {
				var t = e.readUInt8();
				if (e.isError(t)) return t;
				else return t !== 0;
			};
			DERNode.prototype._decodeInt = function decodeInt(e, t) {
				var r = e.raw();
				var i = new c(r);
				if (t) i = t[i.toString(10)] || i;
				return i;
			};
			DERNode.prototype._use = function use(e, t) {
				if (typeof e === 'function') e = e(t);
				return e._getDecoder('der').tree;
			};
			function derDecodeTag(e, t) {
				var r = e.readUInt8(t);
				if (e.isError(r)) return r;
				var i = u.tagClass[r >> 6];
				var a = (r & 32) === 0;
				if ((r & 31) === 31) {
					var o = r;
					r = 0;
					while ((o & 128) === 128) {
						o = e.readUInt8(t);
						if (e.isError(o)) return o;
						r <<= 7;
						r |= o & 127;
					}
				} else {
					r &= 31;
				}
				var c = u.tag[r];
				return { cls: i, primitive: a, tag: r, tagStr: c };
			}
			function derDecodeLen(e, t, r) {
				var i = e.readUInt8(r);
				if (e.isError(i)) return i;
				if (!t && i === 128) return null;
				if ((i & 128) === 0) {
					return i;
				}
				var a = i & 127;
				if (a > 4) return e.error('length octect is too long');
				i = 0;
				for (var o = 0; o < a; o++) {
					i <<= 8;
					var c = e.readUInt8(r);
					if (e.isError(c)) return c;
					i |= c;
				}
				return i;
			}
		},
		1300: (e, t, r) => {
			var i = t;
			i.der = r(7779);
			i.pem = r(1222);
		},
		1222: (e, t, r) => {
			var i = r(1193);
			var a = r(6533).Buffer;
			var o = r(7779);
			function PEMDecoder(e) {
				o.call(this, e);
				this.enc = 'pem';
			}
			i(PEMDecoder, o);
			e.exports = PEMDecoder;
			PEMDecoder.prototype.decode = function decode(e, t) {
				var r = e.toString().split(/[\r\n]+/g);
				var i = t.label.toUpperCase();
				var c = /^-----(BEGIN|END) ([^-]+)-----$/;
				var u = -1;
				var l = -1;
				for (var d = 0; d < r.length; d++) {
					var p = r[d].match(c);
					if (p === null) continue;
					if (p[2] !== i) continue;
					if (u === -1) {
						if (p[1] !== 'BEGIN') break;
						u = d;
					} else {
						if (p[1] !== 'END') break;
						l = d;
						break;
					}
				}
				if (u === -1 || l === -1) throw new Error('PEM section not found for: ' + i);
				var m = r.slice(u + 1, l).join('');
				m.replace(/[^a-z0-9\+\/=]+/gi, '');
				var g = new a(m, 'base64');
				return o.prototype.decode.call(this, g, t);
			};
		},
		9291: (e, t, r) => {
			var i = r(1193);
			var a = r(6533).Buffer;
			var o = r(8071);
			var c = o.base;
			var u = o.constants.der;
			function DEREncoder(e) {
				this.enc = 'der';
				this.name = e.name;
				this.entity = e;
				this.tree = new DERNode();
				this.tree._init(e.body);
			}
			e.exports = DEREncoder;
			DEREncoder.prototype.encode = function encode(e, t) {
				return this.tree._encode(e, t).join();
			};
			function DERNode(e) {
				c.Node.call(this, 'der', e);
			}
			i(DERNode, c.Node);
			DERNode.prototype._encodeComposite = function encodeComposite(e, t, r, i) {
				var o = encodeTag(e, t, r, this.reporter);
				if (i.length < 128) {
					var c = new a(2);
					c[0] = o;
					c[1] = i.length;
					return this._createEncoderBuffer([c, i]);
				}
				var u = 1;
				for (var l = i.length; l >= 256; l >>= 8) u++;
				var c = new a(1 + 1 + u);
				c[0] = o;
				c[1] = 128 | u;
				for (var l = 1 + u, d = i.length; d > 0; l--, d >>= 8) c[l] = d & 255;
				return this._createEncoderBuffer([c, i]);
			};
			DERNode.prototype._encodeStr = function encodeStr(e, t) {
				if (t === 'bitstr') {
					return this._createEncoderBuffer([e.unused | 0, e.data]);
				} else if (t === 'bmpstr') {
					var r = new a(e.length * 2);
					for (var i = 0; i < e.length; i++) {
						r.writeUInt16BE(e.charCodeAt(i), i * 2);
					}
					return this._createEncoderBuffer(r);
				} else if (t === 'numstr') {
					if (!this._isNumstr(e)) {
						return this.reporter.error(
							'Encoding of string type: numstr supports ' + 'only digits and space'
						);
					}
					return this._createEncoderBuffer(e);
				} else if (t === 'printstr') {
					if (!this._isPrintstr(e)) {
						return this.reporter.error(
							'Encoding of string type: printstr supports ' +
								'only latin upper and lower case letters, ' +
								'digits, space, apostrophe, left and rigth ' +
								'parenthesis, plus sign, comma, hyphen, ' +
								'dot, slash, colon, equal sign, ' +
								'question mark'
						);
					}
					return this._createEncoderBuffer(e);
				} else if (/str$/.test(t)) {
					return this._createEncoderBuffer(e);
				} else if (t === 'objDesc') {
					return this._createEncoderBuffer(e);
				} else {
					return this.reporter.error('Encoding of string type: ' + t + ' unsupported');
				}
			};
			DERNode.prototype._encodeObjid = function encodeObjid(e, t, r) {
				if (typeof e === 'string') {
					if (!t) return this.reporter.error('string objid given, but no values map found');
					if (!t.hasOwnProperty(e)) return this.reporter.error('objid not found in values map');
					e = t[e].split(/[\s\.]+/g);
					for (var i = 0; i < e.length; i++) e[i] |= 0;
				} else if (Array.isArray(e)) {
					e = e.slice();
					for (var i = 0; i < e.length; i++) e[i] |= 0;
				}
				if (!Array.isArray(e)) {
					return this.reporter.error(
						'objid() should be either array or string, ' + 'got: ' + JSON.stringify(e)
					);
				}
				if (!r) {
					if (e[1] >= 40) return this.reporter.error('Second objid identifier OOB');
					e.splice(0, 2, e[0] * 40 + e[1]);
				}
				var o = 0;
				for (var i = 0; i < e.length; i++) {
					var c = e[i];
					for (o++; c >= 128; c >>= 7) o++;
				}
				var u = new a(o);
				var l = u.length - 1;
				for (var i = e.length - 1; i >= 0; i--) {
					var c = e[i];
					u[l--] = c & 127;
					while ((c >>= 7) > 0) u[l--] = 128 | (c & 127);
				}
				return this._createEncoderBuffer(u);
			};
			function two(e) {
				if (e < 10) return '0' + e;
				else return e;
			}
			DERNode.prototype._encodeTime = function encodeTime(e, t) {
				var r;
				var i = new Date(e);
				if (t === 'gentime') {
					r = [
						two(i.getFullYear()),
						two(i.getUTCMonth() + 1),
						two(i.getUTCDate()),
						two(i.getUTCHours()),
						two(i.getUTCMinutes()),
						two(i.getUTCSeconds()),
						'Z'
					].join('');
				} else if (t === 'utctime') {
					r = [
						two(i.getFullYear() % 100),
						two(i.getUTCMonth() + 1),
						two(i.getUTCDate()),
						two(i.getUTCHours()),
						two(i.getUTCMinutes()),
						two(i.getUTCSeconds()),
						'Z'
					].join('');
				} else {
					this.reporter.error('Encoding ' + t + ' time is not supported yet');
				}
				return this._encodeStr(r, 'octstr');
			};
			DERNode.prototype._encodeNull = function encodeNull() {
				return this._createEncoderBuffer('');
			};
			DERNode.prototype._encodeInt = function encodeInt(e, t) {
				if (typeof e === 'string') {
					if (!t) return this.reporter.error('String int or enum given, but no values map');
					if (!t.hasOwnProperty(e)) {
						return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
					}
					e = t[e];
				}
				if (typeof e !== 'number' && !a.isBuffer(e)) {
					var r = e.toArray();
					if (!e.sign && r[0] & 128) {
						r.unshift(0);
					}
					e = new a(r);
				}
				if (a.isBuffer(e)) {
					var i = e.length;
					if (e.length === 0) i++;
					var o = new a(i);
					e.copy(o);
					if (e.length === 0) o[0] = 0;
					return this._createEncoderBuffer(o);
				}
				if (e < 128) return this._createEncoderBuffer(e);
				if (e < 256) return this._createEncoderBuffer([0, e]);
				var i = 1;
				for (var c = e; c >= 256; c >>= 8) i++;
				var o = new Array(i);
				for (var c = o.length - 1; c >= 0; c--) {
					o[c] = e & 255;
					e >>= 8;
				}
				if (o[0] & 128) {
					o.unshift(0);
				}
				return this._createEncoderBuffer(new a(o));
			};
			DERNode.prototype._encodeBool = function encodeBool(e) {
				return this._createEncoderBuffer(e ? 255 : 0);
			};
			DERNode.prototype._use = function use(e, t) {
				if (typeof e === 'function') e = e(t);
				return e._getEncoder('der').tree;
			};
			DERNode.prototype._skipDefault = function skipDefault(e, t, r) {
				var i = this._baseState;
				var a;
				if (i['default'] === null) return false;
				var o = e.join();
				if (i.defaultBuffer === undefined)
					i.defaultBuffer = this._encodeValue(i['default'], t, r).join();
				if (o.length !== i.defaultBuffer.length) return false;
				for (a = 0; a < o.length; a++) if (o[a] !== i.defaultBuffer[a]) return false;
				return true;
			};
			function encodeTag(e, t, r, i) {
				var a;
				if (e === 'seqof') e = 'seq';
				else if (e === 'setof') e = 'set';
				if (u.tagByName.hasOwnProperty(e)) a = u.tagByName[e];
				else if (typeof e === 'number' && (e | 0) === e) a = e;
				else return i.error('Unknown tag: ' + e);
				if (a >= 31) return i.error('Multi-octet tag encoding unsupported');
				if (!t) a |= 32;
				a |= u.tagClassByName[r || 'universal'] << 6;
				return a;
			}
		},
		6028: (e, t, r) => {
			var i = t;
			i.der = r(9291);
			i.pem = r(9678);
		},
		9678: (e, t, r) => {
			var i = r(1193);
			var a = r(9291);
			function PEMEncoder(e) {
				a.call(this, e);
				this.enc = 'pem';
			}
			i(PEMEncoder, a);
			e.exports = PEMEncoder;
			PEMEncoder.prototype.encode = function encode(e, t) {
				var r = a.prototype.encode.call(this, e);
				var i = r.toString('base64');
				var o = ['-----BEGIN ' + t.label + '-----'];
				for (var c = 0; c < i.length; c += 64) o.push(i.slice(c, c + 64));
				o.push('-----END ' + t.label + '-----');
				return o.join('\n');
			};
		},
		4933: (e, t) => {
			'use strict';
			t.byteLength = byteLength;
			t.toByteArray = toByteArray;
			t.fromByteArray = fromByteArray;
			var r = [];
			var i = [];
			var a = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
			var o = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
			for (var c = 0, u = o.length; c < u; ++c) {
				r[c] = o[c];
				i[o.charCodeAt(c)] = c;
			}
			i['-'.charCodeAt(0)] = 62;
			i['_'.charCodeAt(0)] = 63;
			function getLens(e) {
				var t = e.length;
				if (t % 4 > 0) {
					throw new Error('Invalid string. Length must be a multiple of 4');
				}
				var r = e.indexOf('=');
				if (r === -1) r = t;
				var i = r === t ? 0 : 4 - (r % 4);
				return [r, i];
			}
			function byteLength(e) {
				var t = getLens(e);
				var r = t[0];
				var i = t[1];
				return ((r + i) * 3) / 4 - i;
			}
			function _byteLength(e, t, r) {
				return ((t + r) * 3) / 4 - r;
			}
			function toByteArray(e) {
				var t;
				var r = getLens(e);
				var o = r[0];
				var c = r[1];
				var u = new a(_byteLength(e, o, c));
				var l = 0;
				var d = c > 0 ? o - 4 : o;
				var p;
				for (p = 0; p < d; p += 4) {
					t =
						(i[e.charCodeAt(p)] << 18) |
						(i[e.charCodeAt(p + 1)] << 12) |
						(i[e.charCodeAt(p + 2)] << 6) |
						i[e.charCodeAt(p + 3)];
					u[l++] = (t >> 16) & 255;
					u[l++] = (t >> 8) & 255;
					u[l++] = t & 255;
				}
				if (c === 2) {
					t = (i[e.charCodeAt(p)] << 2) | (i[e.charCodeAt(p + 1)] >> 4);
					u[l++] = t & 255;
				}
				if (c === 1) {
					t =
						(i[e.charCodeAt(p)] << 10) |
						(i[e.charCodeAt(p + 1)] << 4) |
						(i[e.charCodeAt(p + 2)] >> 2);
					u[l++] = (t >> 8) & 255;
					u[l++] = t & 255;
				}
				return u;
			}
			function tripletToBase64(e) {
				return r[(e >> 18) & 63] + r[(e >> 12) & 63] + r[(e >> 6) & 63] + r[e & 63];
			}
			function encodeChunk(e, t, r) {
				var i;
				var a = [];
				for (var o = t; o < r; o += 3) {
					i = ((e[o] << 16) & 16711680) + ((e[o + 1] << 8) & 65280) + (e[o + 2] & 255);
					a.push(tripletToBase64(i));
				}
				return a.join('');
			}
			function fromByteArray(e) {
				var t;
				var i = e.length;
				var a = i % 3;
				var o = [];
				var c = 16383;
				for (var u = 0, l = i - a; u < l; u += c) {
					o.push(encodeChunk(e, u, u + c > l ? l : u + c));
				}
				if (a === 1) {
					t = e[i - 1];
					o.push(r[t >> 2] + r[(t << 4) & 63] + '==');
				} else if (a === 2) {
					t = (e[i - 2] << 8) + e[i - 1];
					o.push(r[t >> 10] + r[(t >> 4) & 63] + r[(t << 2) & 63] + '=');
				}
				return o.join('');
			}
		},
		3364: function (e, t, r) {
			e = r.nmd(e);
			(function (e, t) {
				'use strict';
				function assert(e, t) {
					if (!e) throw new Error(t || 'Assertion failed');
				}
				function inherits(e, t) {
					e.super_ = t;
					var TempCtor = function () {};
					TempCtor.prototype = t.prototype;
					e.prototype = new TempCtor();
					e.prototype.constructor = e;
				}
				function BN(e, t, r) {
					if (BN.isBN(e)) {
						return e;
					}
					this.negative = 0;
					this.words = null;
					this.length = 0;
					this.red = null;
					if (e !== null) {
						if (t === 'le' || t === 'be') {
							r = t;
							t = 10;
						}
						this._init(e || 0, t || 10, r || 'be');
					}
				}
				if (typeof e === 'object') {
					e.exports = BN;
				} else {
					t.BN = BN;
				}
				BN.BN = BN;
				BN.wordSize = 26;
				var i;
				try {
					if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
						i = window.Buffer;
					} else {
						i = r(1798).Buffer;
					}
				} catch (e) {}
				BN.isBN = function isBN(e) {
					if (e instanceof BN) {
						return true;
					}
					return (
						e !== null &&
						typeof e === 'object' &&
						e.constructor.wordSize === BN.wordSize &&
						Array.isArray(e.words)
					);
				};
				BN.max = function max(e, t) {
					if (e.cmp(t) > 0) return e;
					return t;
				};
				BN.min = function min(e, t) {
					if (e.cmp(t) < 0) return e;
					return t;
				};
				BN.prototype._init = function init(e, t, r) {
					if (typeof e === 'number') {
						return this._initNumber(e, t, r);
					}
					if (typeof e === 'object') {
						return this._initArray(e, t, r);
					}
					if (t === 'hex') {
						t = 16;
					}
					assert(t === (t | 0) && t >= 2 && t <= 36);
					e = e.toString().replace(/\s+/g, '');
					var i = 0;
					if (e[0] === '-') {
						i++;
						this.negative = 1;
					}
					if (i < e.length) {
						if (t === 16) {
							this._parseHex(e, i, r);
						} else {
							this._parseBase(e, t, i);
							if (r === 'le') {
								this._initArray(this.toArray(), t, r);
							}
						}
					}
				};
				BN.prototype._initNumber = function _initNumber(e, t, r) {
					if (e < 0) {
						this.negative = 1;
						e = -e;
					}
					if (e < 67108864) {
						this.words = [e & 67108863];
						this.length = 1;
					} else if (e < 4503599627370496) {
						this.words = [e & 67108863, (e / 67108864) & 67108863];
						this.length = 2;
					} else {
						assert(e < 9007199254740992);
						this.words = [e & 67108863, (e / 67108864) & 67108863, 1];
						this.length = 3;
					}
					if (r !== 'le') return;
					this._initArray(this.toArray(), t, r);
				};
				BN.prototype._initArray = function _initArray(e, t, r) {
					assert(typeof e.length === 'number');
					if (e.length <= 0) {
						this.words = [0];
						this.length = 1;
						return this;
					}
					this.length = Math.ceil(e.length / 3);
					this.words = new Array(this.length);
					for (var i = 0; i < this.length; i++) {
						this.words[i] = 0;
					}
					var a, o;
					var c = 0;
					if (r === 'be') {
						for (i = e.length - 1, a = 0; i >= 0; i -= 3) {
							o = e[i] | (e[i - 1] << 8) | (e[i - 2] << 16);
							this.words[a] |= (o << c) & 67108863;
							this.words[a + 1] = (o >>> (26 - c)) & 67108863;
							c += 24;
							if (c >= 26) {
								c -= 26;
								a++;
							}
						}
					} else if (r === 'le') {
						for (i = 0, a = 0; i < e.length; i += 3) {
							o = e[i] | (e[i + 1] << 8) | (e[i + 2] << 16);
							this.words[a] |= (o << c) & 67108863;
							this.words[a + 1] = (o >>> (26 - c)) & 67108863;
							c += 24;
							if (c >= 26) {
								c -= 26;
								a++;
							}
						}
					}
					return this.strip();
				};
				function parseHex4Bits(e, t) {
					var r = e.charCodeAt(t);
					if (r >= 65 && r <= 70) {
						return r - 55;
					} else if (r >= 97 && r <= 102) {
						return r - 87;
					} else {
						return (r - 48) & 15;
					}
				}
				function parseHexByte(e, t, r) {
					var i = parseHex4Bits(e, r);
					if (r - 1 >= t) {
						i |= parseHex4Bits(e, r - 1) << 4;
					}
					return i;
				}
				BN.prototype._parseHex = function _parseHex(e, t, r) {
					this.length = Math.ceil((e.length - t) / 6);
					this.words = new Array(this.length);
					for (var i = 0; i < this.length; i++) {
						this.words[i] = 0;
					}
					var a = 0;
					var o = 0;
					var c;
					if (r === 'be') {
						for (i = e.length - 1; i >= t; i -= 2) {
							c = parseHexByte(e, t, i) << a;
							this.words[o] |= c & 67108863;
							if (a >= 18) {
								a -= 18;
								o += 1;
								this.words[o] |= c >>> 26;
							} else {
								a += 8;
							}
						}
					} else {
						var u = e.length - t;
						for (i = u % 2 === 0 ? t + 1 : t; i < e.length; i += 2) {
							c = parseHexByte(e, t, i) << a;
							this.words[o] |= c & 67108863;
							if (a >= 18) {
								a -= 18;
								o += 1;
								this.words[o] |= c >>> 26;
							} else {
								a += 8;
							}
						}
					}
					this.strip();
				};
				function parseBase(e, t, r, i) {
					var a = 0;
					var o = Math.min(e.length, r);
					for (var c = t; c < o; c++) {
						var u = e.charCodeAt(c) - 48;
						a *= i;
						if (u >= 49) {
							a += u - 49 + 10;
						} else if (u >= 17) {
							a += u - 17 + 10;
						} else {
							a += u;
						}
					}
					return a;
				}
				BN.prototype._parseBase = function _parseBase(e, t, r) {
					this.words = [0];
					this.length = 1;
					for (var i = 0, a = 1; a <= 67108863; a *= t) {
						i++;
					}
					i--;
					a = (a / t) | 0;
					var o = e.length - r;
					var c = o % i;
					var u = Math.min(o, o - c) + r;
					var l = 0;
					for (var d = r; d < u; d += i) {
						l = parseBase(e, d, d + i, t);
						this.imuln(a);
						if (this.words[0] + l < 67108864) {
							this.words[0] += l;
						} else {
							this._iaddn(l);
						}
					}
					if (c !== 0) {
						var p = 1;
						l = parseBase(e, d, e.length, t);
						for (d = 0; d < c; d++) {
							p *= t;
						}
						this.imuln(p);
						if (this.words[0] + l < 67108864) {
							this.words[0] += l;
						} else {
							this._iaddn(l);
						}
					}
					this.strip();
				};
				BN.prototype.copy = function copy(e) {
					e.words = new Array(this.length);
					for (var t = 0; t < this.length; t++) {
						e.words[t] = this.words[t];
					}
					e.length = this.length;
					e.negative = this.negative;
					e.red = this.red;
				};
				BN.prototype.clone = function clone() {
					var e = new BN(null);
					this.copy(e);
					return e;
				};
				BN.prototype._expand = function _expand(e) {
					while (this.length < e) {
						this.words[this.length++] = 0;
					}
					return this;
				};
				BN.prototype.strip = function strip() {
					while (this.length > 1 && this.words[this.length - 1] === 0) {
						this.length--;
					}
					return this._normSign();
				};
				BN.prototype._normSign = function _normSign() {
					if (this.length === 1 && this.words[0] === 0) {
						this.negative = 0;
					}
					return this;
				};
				BN.prototype.inspect = function inspect() {
					return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
				};
				var a = [
					'',
					'0',
					'00',
					'000',
					'0000',
					'00000',
					'000000',
					'0000000',
					'00000000',
					'000000000',
					'0000000000',
					'00000000000',
					'000000000000',
					'0000000000000',
					'00000000000000',
					'000000000000000',
					'0000000000000000',
					'00000000000000000',
					'000000000000000000',
					'0000000000000000000',
					'00000000000000000000',
					'000000000000000000000',
					'0000000000000000000000',
					'00000000000000000000000',
					'000000000000000000000000',
					'0000000000000000000000000'
				];
				var o = [
					0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5,
					5, 5, 5, 5, 5, 5, 5, 5, 5
				];
				var c = [
					0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7,
					19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881,
					64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
					243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
				];
				BN.prototype.toString = function toString(e, t) {
					e = e || 10;
					t = t | 0 || 1;
					var r;
					if (e === 16 || e === 'hex') {
						r = '';
						var i = 0;
						var u = 0;
						for (var l = 0; l < this.length; l++) {
							var d = this.words[l];
							var p = (((d << i) | u) & 16777215).toString(16);
							u = (d >>> (24 - i)) & 16777215;
							i += 2;
							if (i >= 26) {
								i -= 26;
								l--;
							}
							if (u !== 0 || l !== this.length - 1) {
								r = a[6 - p.length] + p + r;
							} else {
								r = p + r;
							}
						}
						if (u !== 0) {
							r = u.toString(16) + r;
						}
						while (r.length % t !== 0) {
							r = '0' + r;
						}
						if (this.negative !== 0) {
							r = '-' + r;
						}
						return r;
					}
					if (e === (e | 0) && e >= 2 && e <= 36) {
						var m = o[e];
						var g = c[e];
						r = '';
						var v = this.clone();
						v.negative = 0;
						while (!v.isZero()) {
							var y = v.modn(g).toString(e);
							v = v.idivn(g);
							if (!v.isZero()) {
								r = a[m - y.length] + y + r;
							} else {
								r = y + r;
							}
						}
						if (this.isZero()) {
							r = '0' + r;
						}
						while (r.length % t !== 0) {
							r = '0' + r;
						}
						if (this.negative !== 0) {
							r = '-' + r;
						}
						return r;
					}
					assert(false, 'Base should be between 2 and 36');
				};
				BN.prototype.toNumber = function toNumber() {
					var e = this.words[0];
					if (this.length === 2) {
						e += this.words[1] * 67108864;
					} else if (this.length === 3 && this.words[2] === 1) {
						e += 4503599627370496 + this.words[1] * 67108864;
					} else if (this.length > 2) {
						assert(false, 'Number can only safely store up to 53 bits');
					}
					return this.negative !== 0 ? -e : e;
				};
				BN.prototype.toJSON = function toJSON() {
					return this.toString(16);
				};
				BN.prototype.toBuffer = function toBuffer(e, t) {
					assert(typeof i !== 'undefined');
					return this.toArrayLike(i, e, t);
				};
				BN.prototype.toArray = function toArray(e, t) {
					return this.toArrayLike(Array, e, t);
				};
				BN.prototype.toArrayLike = function toArrayLike(e, t, r) {
					var i = this.byteLength();
					var a = r || Math.max(1, i);
					assert(i <= a, 'byte array longer than desired length');
					assert(a > 0, 'Requested array length <= 0');
					this.strip();
					var o = t === 'le';
					var c = new e(a);
					var u, l;
					var d = this.clone();
					if (!o) {
						for (l = 0; l < a - i; l++) {
							c[l] = 0;
						}
						for (l = 0; !d.isZero(); l++) {
							u = d.andln(255);
							d.iushrn(8);
							c[a - l - 1] = u;
						}
					} else {
						for (l = 0; !d.isZero(); l++) {
							u = d.andln(255);
							d.iushrn(8);
							c[l] = u;
						}
						for (; l < a; l++) {
							c[l] = 0;
						}
					}
					return c;
				};
				if (Math.clz32) {
					BN.prototype._countBits = function _countBits(e) {
						return 32 - Math.clz32(e);
					};
				} else {
					BN.prototype._countBits = function _countBits(e) {
						var t = e;
						var r = 0;
						if (t >= 4096) {
							r += 13;
							t >>>= 13;
						}
						if (t >= 64) {
							r += 7;
							t >>>= 7;
						}
						if (t >= 8) {
							r += 4;
							t >>>= 4;
						}
						if (t >= 2) {
							r += 2;
							t >>>= 2;
						}
						return r + t;
					};
				}
				BN.prototype._zeroBits = function _zeroBits(e) {
					if (e === 0) return 26;
					var t = e;
					var r = 0;
					if ((t & 8191) === 0) {
						r += 13;
						t >>>= 13;
					}
					if ((t & 127) === 0) {
						r += 7;
						t >>>= 7;
					}
					if ((t & 15) === 0) {
						r += 4;
						t >>>= 4;
					}
					if ((t & 3) === 0) {
						r += 2;
						t >>>= 2;
					}
					if ((t & 1) === 0) {
						r++;
					}
					return r;
				};
				BN.prototype.bitLength = function bitLength() {
					var e = this.words[this.length - 1];
					var t = this._countBits(e);
					return (this.length - 1) * 26 + t;
				};
				function toBitArray(e) {
					var t = new Array(e.bitLength());
					for (var r = 0; r < t.length; r++) {
						var i = (r / 26) | 0;
						var a = r % 26;
						t[r] = (e.words[i] & (1 << a)) >>> a;
					}
					return t;
				}
				BN.prototype.zeroBits = function zeroBits() {
					if (this.isZero()) return 0;
					var e = 0;
					for (var t = 0; t < this.length; t++) {
						var r = this._zeroBits(this.words[t]);
						e += r;
						if (r !== 26) break;
					}
					return e;
				};
				BN.prototype.byteLength = function byteLength() {
					return Math.ceil(this.bitLength() / 8);
				};
				BN.prototype.toTwos = function toTwos(e) {
					if (this.negative !== 0) {
						return this.abs().inotn(e).iaddn(1);
					}
					return this.clone();
				};
				BN.prototype.fromTwos = function fromTwos(e) {
					if (this.testn(e - 1)) {
						return this.notn(e).iaddn(1).ineg();
					}
					return this.clone();
				};
				BN.prototype.isNeg = function isNeg() {
					return this.negative !== 0;
				};
				BN.prototype.neg = function neg() {
					return this.clone().ineg();
				};
				BN.prototype.ineg = function ineg() {
					if (!this.isZero()) {
						this.negative ^= 1;
					}
					return this;
				};
				BN.prototype.iuor = function iuor(e) {
					while (this.length < e.length) {
						this.words[this.length++] = 0;
					}
					for (var t = 0; t < e.length; t++) {
						this.words[t] = this.words[t] | e.words[t];
					}
					return this.strip();
				};
				BN.prototype.ior = function ior(e) {
					assert((this.negative | e.negative) === 0);
					return this.iuor(e);
				};
				BN.prototype.or = function or(e) {
					if (this.length > e.length) return this.clone().ior(e);
					return e.clone().ior(this);
				};
				BN.prototype.uor = function uor(e) {
					if (this.length > e.length) return this.clone().iuor(e);
					return e.clone().iuor(this);
				};
				BN.prototype.iuand = function iuand(e) {
					var t;
					if (this.length > e.length) {
						t = e;
					} else {
						t = this;
					}
					for (var r = 0; r < t.length; r++) {
						this.words[r] = this.words[r] & e.words[r];
					}
					this.length = t.length;
					return this.strip();
				};
				BN.prototype.iand = function iand(e) {
					assert((this.negative | e.negative) === 0);
					return this.iuand(e);
				};
				BN.prototype.and = function and(e) {
					if (this.length > e.length) return this.clone().iand(e);
					return e.clone().iand(this);
				};
				BN.prototype.uand = function uand(e) {
					if (this.length > e.length) return this.clone().iuand(e);
					return e.clone().iuand(this);
				};
				BN.prototype.iuxor = function iuxor(e) {
					var t;
					var r;
					if (this.length > e.length) {
						t = this;
						r = e;
					} else {
						t = e;
						r = this;
					}
					for (var i = 0; i < r.length; i++) {
						this.words[i] = t.words[i] ^ r.words[i];
					}
					if (this !== t) {
						for (; i < t.length; i++) {
							this.words[i] = t.words[i];
						}
					}
					this.length = t.length;
					return this.strip();
				};
				BN.prototype.ixor = function ixor(e) {
					assert((this.negative | e.negative) === 0);
					return this.iuxor(e);
				};
				BN.prototype.xor = function xor(e) {
					if (this.length > e.length) return this.clone().ixor(e);
					return e.clone().ixor(this);
				};
				BN.prototype.uxor = function uxor(e) {
					if (this.length > e.length) return this.clone().iuxor(e);
					return e.clone().iuxor(this);
				};
				BN.prototype.inotn = function inotn(e) {
					assert(typeof e === 'number' && e >= 0);
					var t = Math.ceil(e / 26) | 0;
					var r = e % 26;
					this._expand(t);
					if (r > 0) {
						t--;
					}
					for (var i = 0; i < t; i++) {
						this.words[i] = ~this.words[i] & 67108863;
					}
					if (r > 0) {
						this.words[i] = ~this.words[i] & (67108863 >> (26 - r));
					}
					return this.strip();
				};
				BN.prototype.notn = function notn(e) {
					return this.clone().inotn(e);
				};
				BN.prototype.setn = function setn(e, t) {
					assert(typeof e === 'number' && e >= 0);
					var r = (e / 26) | 0;
					var i = e % 26;
					this._expand(r + 1);
					if (t) {
						this.words[r] = this.words[r] | (1 << i);
					} else {
						this.words[r] = this.words[r] & ~(1 << i);
					}
					return this.strip();
				};
				BN.prototype.iadd = function iadd(e) {
					var t;
					if (this.negative !== 0 && e.negative === 0) {
						this.negative = 0;
						t = this.isub(e);
						this.negative ^= 1;
						return this._normSign();
					} else if (this.negative === 0 && e.negative !== 0) {
						e.negative = 0;
						t = this.isub(e);
						e.negative = 1;
						return t._normSign();
					}
					var r, i;
					if (this.length > e.length) {
						r = this;
						i = e;
					} else {
						r = e;
						i = this;
					}
					var a = 0;
					for (var o = 0; o < i.length; o++) {
						t = (r.words[o] | 0) + (i.words[o] | 0) + a;
						this.words[o] = t & 67108863;
						a = t >>> 26;
					}
					for (; a !== 0 && o < r.length; o++) {
						t = (r.words[o] | 0) + a;
						this.words[o] = t & 67108863;
						a = t >>> 26;
					}
					this.length = r.length;
					if (a !== 0) {
						this.words[this.length] = a;
						this.length++;
					} else if (r !== this) {
						for (; o < r.length; o++) {
							this.words[o] = r.words[o];
						}
					}
					return this;
				};
				BN.prototype.add = function add(e) {
					var t;
					if (e.negative !== 0 && this.negative === 0) {
						e.negative = 0;
						t = this.sub(e);
						e.negative ^= 1;
						return t;
					} else if (e.negative === 0 && this.negative !== 0) {
						this.negative = 0;
						t = e.sub(this);
						this.negative = 1;
						return t;
					}
					if (this.length > e.length) return this.clone().iadd(e);
					return e.clone().iadd(this);
				};
				BN.prototype.isub = function isub(e) {
					if (e.negative !== 0) {
						e.negative = 0;
						var t = this.iadd(e);
						e.negative = 1;
						return t._normSign();
					} else if (this.negative !== 0) {
						this.negative = 0;
						this.iadd(e);
						this.negative = 1;
						return this._normSign();
					}
					var r = this.cmp(e);
					if (r === 0) {
						this.negative = 0;
						this.length = 1;
						this.words[0] = 0;
						return this;
					}
					var i, a;
					if (r > 0) {
						i = this;
						a = e;
					} else {
						i = e;
						a = this;
					}
					var o = 0;
					for (var c = 0; c < a.length; c++) {
						t = (i.words[c] | 0) - (a.words[c] | 0) + o;
						o = t >> 26;
						this.words[c] = t & 67108863;
					}
					for (; o !== 0 && c < i.length; c++) {
						t = (i.words[c] | 0) + o;
						o = t >> 26;
						this.words[c] = t & 67108863;
					}
					if (o === 0 && c < i.length && i !== this) {
						for (; c < i.length; c++) {
							this.words[c] = i.words[c];
						}
					}
					this.length = Math.max(this.length, c);
					if (i !== this) {
						this.negative = 1;
					}
					return this.strip();
				};
				BN.prototype.sub = function sub(e) {
					return this.clone().isub(e);
				};
				function smallMulTo(e, t, r) {
					r.negative = t.negative ^ e.negative;
					var i = (e.length + t.length) | 0;
					r.length = i;
					i = (i - 1) | 0;
					var a = e.words[0] | 0;
					var o = t.words[0] | 0;
					var c = a * o;
					var u = c & 67108863;
					var l = (c / 67108864) | 0;
					r.words[0] = u;
					for (var d = 1; d < i; d++) {
						var p = l >>> 26;
						var m = l & 67108863;
						var g = Math.min(d, t.length - 1);
						for (var v = Math.max(0, d - e.length + 1); v <= g; v++) {
							var y = (d - v) | 0;
							a = e.words[y] | 0;
							o = t.words[v] | 0;
							c = a * o + m;
							p += (c / 67108864) | 0;
							m = c & 67108863;
						}
						r.words[d] = m | 0;
						l = p | 0;
					}
					if (l !== 0) {
						r.words[d] = l | 0;
					} else {
						r.length--;
					}
					return r.strip();
				}
				var u = function comb10MulTo(e, t, r) {
					var i = e.words;
					var a = t.words;
					var o = r.words;
					var c = 0;
					var u;
					var l;
					var d;
					var p = i[0] | 0;
					var m = p & 8191;
					var g = p >>> 13;
					var v = i[1] | 0;
					var y = v & 8191;
					var w = v >>> 13;
					var _ = i[2] | 0;
					var A = _ & 8191;
					var k = _ >>> 13;
					var N = i[3] | 0;
					var T = N & 8191;
					var x = N >>> 13;
					var B = i[4] | 0;
					var P = B & 8191;
					var M = B >>> 13;
					var C = i[5] | 0;
					var I = C & 8191;
					var O = C >>> 13;
					var F = i[6] | 0;
					var D = F & 8191;
					var L = F >>> 13;
					var U = i[7] | 0;
					var j = U & 8191;
					var H = U >>> 13;
					var z = i[8] | 0;
					var $ = z & 8191;
					var G = z >>> 13;
					var q = i[9] | 0;
					var V = q & 8191;
					var W = q >>> 13;
					var J = a[0] | 0;
					var Z = J & 8191;
					var Q = J >>> 13;
					var Y = a[1] | 0;
					var X = Y & 8191;
					var ee = Y >>> 13;
					var te = a[2] | 0;
					var re = te & 8191;
					var ne = te >>> 13;
					var ie = a[3] | 0;
					var se = ie & 8191;
					var ae = ie >>> 13;
					var oe = a[4] | 0;
					var ce = oe & 8191;
					var ue = oe >>> 13;
					var le = a[5] | 0;
					var de = le & 8191;
					var he = le >>> 13;
					var pe = a[6] | 0;
					var me = pe & 8191;
					var ve = pe >>> 13;
					var ye = a[7] | 0;
					var be = ye & 8191;
					var we = ye >>> 13;
					var _e = a[8] | 0;
					var Ae = _e & 8191;
					var Ee = _e >>> 13;
					var Se = a[9] | 0;
					var ke = Se & 8191;
					var Ne = Se >>> 13;
					r.negative = e.negative ^ t.negative;
					r.length = 19;
					u = Math.imul(m, Z);
					l = Math.imul(m, Q);
					l = (l + Math.imul(g, Z)) | 0;
					d = Math.imul(g, Q);
					var Te = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Te >>> 26)) | 0;
					Te &= 67108863;
					u = Math.imul(y, Z);
					l = Math.imul(y, Q);
					l = (l + Math.imul(w, Z)) | 0;
					d = Math.imul(w, Q);
					u = (u + Math.imul(m, X)) | 0;
					l = (l + Math.imul(m, ee)) | 0;
					l = (l + Math.imul(g, X)) | 0;
					d = (d + Math.imul(g, ee)) | 0;
					var xe = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (xe >>> 26)) | 0;
					xe &= 67108863;
					u = Math.imul(A, Z);
					l = Math.imul(A, Q);
					l = (l + Math.imul(k, Z)) | 0;
					d = Math.imul(k, Q);
					u = (u + Math.imul(y, X)) | 0;
					l = (l + Math.imul(y, ee)) | 0;
					l = (l + Math.imul(w, X)) | 0;
					d = (d + Math.imul(w, ee)) | 0;
					u = (u + Math.imul(m, re)) | 0;
					l = (l + Math.imul(m, ne)) | 0;
					l = (l + Math.imul(g, re)) | 0;
					d = (d + Math.imul(g, ne)) | 0;
					var Be = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Be >>> 26)) | 0;
					Be &= 67108863;
					u = Math.imul(T, Z);
					l = Math.imul(T, Q);
					l = (l + Math.imul(x, Z)) | 0;
					d = Math.imul(x, Q);
					u = (u + Math.imul(A, X)) | 0;
					l = (l + Math.imul(A, ee)) | 0;
					l = (l + Math.imul(k, X)) | 0;
					d = (d + Math.imul(k, ee)) | 0;
					u = (u + Math.imul(y, re)) | 0;
					l = (l + Math.imul(y, ne)) | 0;
					l = (l + Math.imul(w, re)) | 0;
					d = (d + Math.imul(w, ne)) | 0;
					u = (u + Math.imul(m, se)) | 0;
					l = (l + Math.imul(m, ae)) | 0;
					l = (l + Math.imul(g, se)) | 0;
					d = (d + Math.imul(g, ae)) | 0;
					var Re = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Re >>> 26)) | 0;
					Re &= 67108863;
					u = Math.imul(P, Z);
					l = Math.imul(P, Q);
					l = (l + Math.imul(M, Z)) | 0;
					d = Math.imul(M, Q);
					u = (u + Math.imul(T, X)) | 0;
					l = (l + Math.imul(T, ee)) | 0;
					l = (l + Math.imul(x, X)) | 0;
					d = (d + Math.imul(x, ee)) | 0;
					u = (u + Math.imul(A, re)) | 0;
					l = (l + Math.imul(A, ne)) | 0;
					l = (l + Math.imul(k, re)) | 0;
					d = (d + Math.imul(k, ne)) | 0;
					u = (u + Math.imul(y, se)) | 0;
					l = (l + Math.imul(y, ae)) | 0;
					l = (l + Math.imul(w, se)) | 0;
					d = (d + Math.imul(w, ae)) | 0;
					u = (u + Math.imul(m, ce)) | 0;
					l = (l + Math.imul(m, ue)) | 0;
					l = (l + Math.imul(g, ce)) | 0;
					d = (d + Math.imul(g, ue)) | 0;
					var Pe = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Pe >>> 26)) | 0;
					Pe &= 67108863;
					u = Math.imul(I, Z);
					l = Math.imul(I, Q);
					l = (l + Math.imul(O, Z)) | 0;
					d = Math.imul(O, Q);
					u = (u + Math.imul(P, X)) | 0;
					l = (l + Math.imul(P, ee)) | 0;
					l = (l + Math.imul(M, X)) | 0;
					d = (d + Math.imul(M, ee)) | 0;
					u = (u + Math.imul(T, re)) | 0;
					l = (l + Math.imul(T, ne)) | 0;
					l = (l + Math.imul(x, re)) | 0;
					d = (d + Math.imul(x, ne)) | 0;
					u = (u + Math.imul(A, se)) | 0;
					l = (l + Math.imul(A, ae)) | 0;
					l = (l + Math.imul(k, se)) | 0;
					d = (d + Math.imul(k, ae)) | 0;
					u = (u + Math.imul(y, ce)) | 0;
					l = (l + Math.imul(y, ue)) | 0;
					l = (l + Math.imul(w, ce)) | 0;
					d = (d + Math.imul(w, ue)) | 0;
					u = (u + Math.imul(m, de)) | 0;
					l = (l + Math.imul(m, he)) | 0;
					l = (l + Math.imul(g, de)) | 0;
					d = (d + Math.imul(g, he)) | 0;
					var Me = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Me >>> 26)) | 0;
					Me &= 67108863;
					u = Math.imul(D, Z);
					l = Math.imul(D, Q);
					l = (l + Math.imul(L, Z)) | 0;
					d = Math.imul(L, Q);
					u = (u + Math.imul(I, X)) | 0;
					l = (l + Math.imul(I, ee)) | 0;
					l = (l + Math.imul(O, X)) | 0;
					d = (d + Math.imul(O, ee)) | 0;
					u = (u + Math.imul(P, re)) | 0;
					l = (l + Math.imul(P, ne)) | 0;
					l = (l + Math.imul(M, re)) | 0;
					d = (d + Math.imul(M, ne)) | 0;
					u = (u + Math.imul(T, se)) | 0;
					l = (l + Math.imul(T, ae)) | 0;
					l = (l + Math.imul(x, se)) | 0;
					d = (d + Math.imul(x, ae)) | 0;
					u = (u + Math.imul(A, ce)) | 0;
					l = (l + Math.imul(A, ue)) | 0;
					l = (l + Math.imul(k, ce)) | 0;
					d = (d + Math.imul(k, ue)) | 0;
					u = (u + Math.imul(y, de)) | 0;
					l = (l + Math.imul(y, he)) | 0;
					l = (l + Math.imul(w, de)) | 0;
					d = (d + Math.imul(w, he)) | 0;
					u = (u + Math.imul(m, me)) | 0;
					l = (l + Math.imul(m, ve)) | 0;
					l = (l + Math.imul(g, me)) | 0;
					d = (d + Math.imul(g, ve)) | 0;
					var Ce = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Ce >>> 26)) | 0;
					Ce &= 67108863;
					u = Math.imul(j, Z);
					l = Math.imul(j, Q);
					l = (l + Math.imul(H, Z)) | 0;
					d = Math.imul(H, Q);
					u = (u + Math.imul(D, X)) | 0;
					l = (l + Math.imul(D, ee)) | 0;
					l = (l + Math.imul(L, X)) | 0;
					d = (d + Math.imul(L, ee)) | 0;
					u = (u + Math.imul(I, re)) | 0;
					l = (l + Math.imul(I, ne)) | 0;
					l = (l + Math.imul(O, re)) | 0;
					d = (d + Math.imul(O, ne)) | 0;
					u = (u + Math.imul(P, se)) | 0;
					l = (l + Math.imul(P, ae)) | 0;
					l = (l + Math.imul(M, se)) | 0;
					d = (d + Math.imul(M, ae)) | 0;
					u = (u + Math.imul(T, ce)) | 0;
					l = (l + Math.imul(T, ue)) | 0;
					l = (l + Math.imul(x, ce)) | 0;
					d = (d + Math.imul(x, ue)) | 0;
					u = (u + Math.imul(A, de)) | 0;
					l = (l + Math.imul(A, he)) | 0;
					l = (l + Math.imul(k, de)) | 0;
					d = (d + Math.imul(k, he)) | 0;
					u = (u + Math.imul(y, me)) | 0;
					l = (l + Math.imul(y, ve)) | 0;
					l = (l + Math.imul(w, me)) | 0;
					d = (d + Math.imul(w, ve)) | 0;
					u = (u + Math.imul(m, be)) | 0;
					l = (l + Math.imul(m, we)) | 0;
					l = (l + Math.imul(g, be)) | 0;
					d = (d + Math.imul(g, we)) | 0;
					var Ie = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Ie >>> 26)) | 0;
					Ie &= 67108863;
					u = Math.imul($, Z);
					l = Math.imul($, Q);
					l = (l + Math.imul(G, Z)) | 0;
					d = Math.imul(G, Q);
					u = (u + Math.imul(j, X)) | 0;
					l = (l + Math.imul(j, ee)) | 0;
					l = (l + Math.imul(H, X)) | 0;
					d = (d + Math.imul(H, ee)) | 0;
					u = (u + Math.imul(D, re)) | 0;
					l = (l + Math.imul(D, ne)) | 0;
					l = (l + Math.imul(L, re)) | 0;
					d = (d + Math.imul(L, ne)) | 0;
					u = (u + Math.imul(I, se)) | 0;
					l = (l + Math.imul(I, ae)) | 0;
					l = (l + Math.imul(O, se)) | 0;
					d = (d + Math.imul(O, ae)) | 0;
					u = (u + Math.imul(P, ce)) | 0;
					l = (l + Math.imul(P, ue)) | 0;
					l = (l + Math.imul(M, ce)) | 0;
					d = (d + Math.imul(M, ue)) | 0;
					u = (u + Math.imul(T, de)) | 0;
					l = (l + Math.imul(T, he)) | 0;
					l = (l + Math.imul(x, de)) | 0;
					d = (d + Math.imul(x, he)) | 0;
					u = (u + Math.imul(A, me)) | 0;
					l = (l + Math.imul(A, ve)) | 0;
					l = (l + Math.imul(k, me)) | 0;
					d = (d + Math.imul(k, ve)) | 0;
					u = (u + Math.imul(y, be)) | 0;
					l = (l + Math.imul(y, we)) | 0;
					l = (l + Math.imul(w, be)) | 0;
					d = (d + Math.imul(w, we)) | 0;
					u = (u + Math.imul(m, Ae)) | 0;
					l = (l + Math.imul(m, Ee)) | 0;
					l = (l + Math.imul(g, Ae)) | 0;
					d = (d + Math.imul(g, Ee)) | 0;
					var Oe = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Oe >>> 26)) | 0;
					Oe &= 67108863;
					u = Math.imul(V, Z);
					l = Math.imul(V, Q);
					l = (l + Math.imul(W, Z)) | 0;
					d = Math.imul(W, Q);
					u = (u + Math.imul($, X)) | 0;
					l = (l + Math.imul($, ee)) | 0;
					l = (l + Math.imul(G, X)) | 0;
					d = (d + Math.imul(G, ee)) | 0;
					u = (u + Math.imul(j, re)) | 0;
					l = (l + Math.imul(j, ne)) | 0;
					l = (l + Math.imul(H, re)) | 0;
					d = (d + Math.imul(H, ne)) | 0;
					u = (u + Math.imul(D, se)) | 0;
					l = (l + Math.imul(D, ae)) | 0;
					l = (l + Math.imul(L, se)) | 0;
					d = (d + Math.imul(L, ae)) | 0;
					u = (u + Math.imul(I, ce)) | 0;
					l = (l + Math.imul(I, ue)) | 0;
					l = (l + Math.imul(O, ce)) | 0;
					d = (d + Math.imul(O, ue)) | 0;
					u = (u + Math.imul(P, de)) | 0;
					l = (l + Math.imul(P, he)) | 0;
					l = (l + Math.imul(M, de)) | 0;
					d = (d + Math.imul(M, he)) | 0;
					u = (u + Math.imul(T, me)) | 0;
					l = (l + Math.imul(T, ve)) | 0;
					l = (l + Math.imul(x, me)) | 0;
					d = (d + Math.imul(x, ve)) | 0;
					u = (u + Math.imul(A, be)) | 0;
					l = (l + Math.imul(A, we)) | 0;
					l = (l + Math.imul(k, be)) | 0;
					d = (d + Math.imul(k, we)) | 0;
					u = (u + Math.imul(y, Ae)) | 0;
					l = (l + Math.imul(y, Ee)) | 0;
					l = (l + Math.imul(w, Ae)) | 0;
					d = (d + Math.imul(w, Ee)) | 0;
					u = (u + Math.imul(m, ke)) | 0;
					l = (l + Math.imul(m, Ne)) | 0;
					l = (l + Math.imul(g, ke)) | 0;
					d = (d + Math.imul(g, Ne)) | 0;
					var Fe = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Fe >>> 26)) | 0;
					Fe &= 67108863;
					u = Math.imul(V, X);
					l = Math.imul(V, ee);
					l = (l + Math.imul(W, X)) | 0;
					d = Math.imul(W, ee);
					u = (u + Math.imul($, re)) | 0;
					l = (l + Math.imul($, ne)) | 0;
					l = (l + Math.imul(G, re)) | 0;
					d = (d + Math.imul(G, ne)) | 0;
					u = (u + Math.imul(j, se)) | 0;
					l = (l + Math.imul(j, ae)) | 0;
					l = (l + Math.imul(H, se)) | 0;
					d = (d + Math.imul(H, ae)) | 0;
					u = (u + Math.imul(D, ce)) | 0;
					l = (l + Math.imul(D, ue)) | 0;
					l = (l + Math.imul(L, ce)) | 0;
					d = (d + Math.imul(L, ue)) | 0;
					u = (u + Math.imul(I, de)) | 0;
					l = (l + Math.imul(I, he)) | 0;
					l = (l + Math.imul(O, de)) | 0;
					d = (d + Math.imul(O, he)) | 0;
					u = (u + Math.imul(P, me)) | 0;
					l = (l + Math.imul(P, ve)) | 0;
					l = (l + Math.imul(M, me)) | 0;
					d = (d + Math.imul(M, ve)) | 0;
					u = (u + Math.imul(T, be)) | 0;
					l = (l + Math.imul(T, we)) | 0;
					l = (l + Math.imul(x, be)) | 0;
					d = (d + Math.imul(x, we)) | 0;
					u = (u + Math.imul(A, Ae)) | 0;
					l = (l + Math.imul(A, Ee)) | 0;
					l = (l + Math.imul(k, Ae)) | 0;
					d = (d + Math.imul(k, Ee)) | 0;
					u = (u + Math.imul(y, ke)) | 0;
					l = (l + Math.imul(y, Ne)) | 0;
					l = (l + Math.imul(w, ke)) | 0;
					d = (d + Math.imul(w, Ne)) | 0;
					var De = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (De >>> 26)) | 0;
					De &= 67108863;
					u = Math.imul(V, re);
					l = Math.imul(V, ne);
					l = (l + Math.imul(W, re)) | 0;
					d = Math.imul(W, ne);
					u = (u + Math.imul($, se)) | 0;
					l = (l + Math.imul($, ae)) | 0;
					l = (l + Math.imul(G, se)) | 0;
					d = (d + Math.imul(G, ae)) | 0;
					u = (u + Math.imul(j, ce)) | 0;
					l = (l + Math.imul(j, ue)) | 0;
					l = (l + Math.imul(H, ce)) | 0;
					d = (d + Math.imul(H, ue)) | 0;
					u = (u + Math.imul(D, de)) | 0;
					l = (l + Math.imul(D, he)) | 0;
					l = (l + Math.imul(L, de)) | 0;
					d = (d + Math.imul(L, he)) | 0;
					u = (u + Math.imul(I, me)) | 0;
					l = (l + Math.imul(I, ve)) | 0;
					l = (l + Math.imul(O, me)) | 0;
					d = (d + Math.imul(O, ve)) | 0;
					u = (u + Math.imul(P, be)) | 0;
					l = (l + Math.imul(P, we)) | 0;
					l = (l + Math.imul(M, be)) | 0;
					d = (d + Math.imul(M, we)) | 0;
					u = (u + Math.imul(T, Ae)) | 0;
					l = (l + Math.imul(T, Ee)) | 0;
					l = (l + Math.imul(x, Ae)) | 0;
					d = (d + Math.imul(x, Ee)) | 0;
					u = (u + Math.imul(A, ke)) | 0;
					l = (l + Math.imul(A, Ne)) | 0;
					l = (l + Math.imul(k, ke)) | 0;
					d = (d + Math.imul(k, Ne)) | 0;
					var Le = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Le >>> 26)) | 0;
					Le &= 67108863;
					u = Math.imul(V, se);
					l = Math.imul(V, ae);
					l = (l + Math.imul(W, se)) | 0;
					d = Math.imul(W, ae);
					u = (u + Math.imul($, ce)) | 0;
					l = (l + Math.imul($, ue)) | 0;
					l = (l + Math.imul(G, ce)) | 0;
					d = (d + Math.imul(G, ue)) | 0;
					u = (u + Math.imul(j, de)) | 0;
					l = (l + Math.imul(j, he)) | 0;
					l = (l + Math.imul(H, de)) | 0;
					d = (d + Math.imul(H, he)) | 0;
					u = (u + Math.imul(D, me)) | 0;
					l = (l + Math.imul(D, ve)) | 0;
					l = (l + Math.imul(L, me)) | 0;
					d = (d + Math.imul(L, ve)) | 0;
					u = (u + Math.imul(I, be)) | 0;
					l = (l + Math.imul(I, we)) | 0;
					l = (l + Math.imul(O, be)) | 0;
					d = (d + Math.imul(O, we)) | 0;
					u = (u + Math.imul(P, Ae)) | 0;
					l = (l + Math.imul(P, Ee)) | 0;
					l = (l + Math.imul(M, Ae)) | 0;
					d = (d + Math.imul(M, Ee)) | 0;
					u = (u + Math.imul(T, ke)) | 0;
					l = (l + Math.imul(T, Ne)) | 0;
					l = (l + Math.imul(x, ke)) | 0;
					d = (d + Math.imul(x, Ne)) | 0;
					var Ue = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Ue >>> 26)) | 0;
					Ue &= 67108863;
					u = Math.imul(V, ce);
					l = Math.imul(V, ue);
					l = (l + Math.imul(W, ce)) | 0;
					d = Math.imul(W, ue);
					u = (u + Math.imul($, de)) | 0;
					l = (l + Math.imul($, he)) | 0;
					l = (l + Math.imul(G, de)) | 0;
					d = (d + Math.imul(G, he)) | 0;
					u = (u + Math.imul(j, me)) | 0;
					l = (l + Math.imul(j, ve)) | 0;
					l = (l + Math.imul(H, me)) | 0;
					d = (d + Math.imul(H, ve)) | 0;
					u = (u + Math.imul(D, be)) | 0;
					l = (l + Math.imul(D, we)) | 0;
					l = (l + Math.imul(L, be)) | 0;
					d = (d + Math.imul(L, we)) | 0;
					u = (u + Math.imul(I, Ae)) | 0;
					l = (l + Math.imul(I, Ee)) | 0;
					l = (l + Math.imul(O, Ae)) | 0;
					d = (d + Math.imul(O, Ee)) | 0;
					u = (u + Math.imul(P, ke)) | 0;
					l = (l + Math.imul(P, Ne)) | 0;
					l = (l + Math.imul(M, ke)) | 0;
					d = (d + Math.imul(M, Ne)) | 0;
					var je = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (je >>> 26)) | 0;
					je &= 67108863;
					u = Math.imul(V, de);
					l = Math.imul(V, he);
					l = (l + Math.imul(W, de)) | 0;
					d = Math.imul(W, he);
					u = (u + Math.imul($, me)) | 0;
					l = (l + Math.imul($, ve)) | 0;
					l = (l + Math.imul(G, me)) | 0;
					d = (d + Math.imul(G, ve)) | 0;
					u = (u + Math.imul(j, be)) | 0;
					l = (l + Math.imul(j, we)) | 0;
					l = (l + Math.imul(H, be)) | 0;
					d = (d + Math.imul(H, we)) | 0;
					u = (u + Math.imul(D, Ae)) | 0;
					l = (l + Math.imul(D, Ee)) | 0;
					l = (l + Math.imul(L, Ae)) | 0;
					d = (d + Math.imul(L, Ee)) | 0;
					u = (u + Math.imul(I, ke)) | 0;
					l = (l + Math.imul(I, Ne)) | 0;
					l = (l + Math.imul(O, ke)) | 0;
					d = (d + Math.imul(O, Ne)) | 0;
					var He = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (He >>> 26)) | 0;
					He &= 67108863;
					u = Math.imul(V, me);
					l = Math.imul(V, ve);
					l = (l + Math.imul(W, me)) | 0;
					d = Math.imul(W, ve);
					u = (u + Math.imul($, be)) | 0;
					l = (l + Math.imul($, we)) | 0;
					l = (l + Math.imul(G, be)) | 0;
					d = (d + Math.imul(G, we)) | 0;
					u = (u + Math.imul(j, Ae)) | 0;
					l = (l + Math.imul(j, Ee)) | 0;
					l = (l + Math.imul(H, Ae)) | 0;
					d = (d + Math.imul(H, Ee)) | 0;
					u = (u + Math.imul(D, ke)) | 0;
					l = (l + Math.imul(D, Ne)) | 0;
					l = (l + Math.imul(L, ke)) | 0;
					d = (d + Math.imul(L, Ne)) | 0;
					var ze = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (ze >>> 26)) | 0;
					ze &= 67108863;
					u = Math.imul(V, be);
					l = Math.imul(V, we);
					l = (l + Math.imul(W, be)) | 0;
					d = Math.imul(W, we);
					u = (u + Math.imul($, Ae)) | 0;
					l = (l + Math.imul($, Ee)) | 0;
					l = (l + Math.imul(G, Ae)) | 0;
					d = (d + Math.imul(G, Ee)) | 0;
					u = (u + Math.imul(j, ke)) | 0;
					l = (l + Math.imul(j, Ne)) | 0;
					l = (l + Math.imul(H, ke)) | 0;
					d = (d + Math.imul(H, Ne)) | 0;
					var $e = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + ($e >>> 26)) | 0;
					$e &= 67108863;
					u = Math.imul(V, Ae);
					l = Math.imul(V, Ee);
					l = (l + Math.imul(W, Ae)) | 0;
					d = Math.imul(W, Ee);
					u = (u + Math.imul($, ke)) | 0;
					l = (l + Math.imul($, Ne)) | 0;
					l = (l + Math.imul(G, ke)) | 0;
					d = (d + Math.imul(G, Ne)) | 0;
					var Ge = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Ge >>> 26)) | 0;
					Ge &= 67108863;
					u = Math.imul(V, ke);
					l = Math.imul(V, Ne);
					l = (l + Math.imul(W, ke)) | 0;
					d = Math.imul(W, Ne);
					var qe = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (qe >>> 26)) | 0;
					qe &= 67108863;
					o[0] = Te;
					o[1] = xe;
					o[2] = Be;
					o[3] = Re;
					o[4] = Pe;
					o[5] = Me;
					o[6] = Ce;
					o[7] = Ie;
					o[8] = Oe;
					o[9] = Fe;
					o[10] = De;
					o[11] = Le;
					o[12] = Ue;
					o[13] = je;
					o[14] = He;
					o[15] = ze;
					o[16] = $e;
					o[17] = Ge;
					o[18] = qe;
					if (c !== 0) {
						o[19] = c;
						r.length++;
					}
					return r;
				};
				if (!Math.imul) {
					u = smallMulTo;
				}
				function bigMulTo(e, t, r) {
					r.negative = t.negative ^ e.negative;
					r.length = e.length + t.length;
					var i = 0;
					var a = 0;
					for (var o = 0; o < r.length - 1; o++) {
						var c = a;
						a = 0;
						var u = i & 67108863;
						var l = Math.min(o, t.length - 1);
						for (var d = Math.max(0, o - e.length + 1); d <= l; d++) {
							var p = o - d;
							var m = e.words[p] | 0;
							var g = t.words[d] | 0;
							var v = m * g;
							var y = v & 67108863;
							c = (c + ((v / 67108864) | 0)) | 0;
							y = (y + u) | 0;
							u = y & 67108863;
							c = (c + (y >>> 26)) | 0;
							a += c >>> 26;
							c &= 67108863;
						}
						r.words[o] = u;
						i = c;
						c = a;
					}
					if (i !== 0) {
						r.words[o] = i;
					} else {
						r.length--;
					}
					return r.strip();
				}
				function jumboMulTo(e, t, r) {
					var i = new FFTM();
					return i.mulp(e, t, r);
				}
				BN.prototype.mulTo = function mulTo(e, t) {
					var r;
					var i = this.length + e.length;
					if (this.length === 10 && e.length === 10) {
						r = u(this, e, t);
					} else if (i < 63) {
						r = smallMulTo(this, e, t);
					} else if (i < 1024) {
						r = bigMulTo(this, e, t);
					} else {
						r = jumboMulTo(this, e, t);
					}
					return r;
				};
				function FFTM(e, t) {
					this.x = e;
					this.y = t;
				}
				FFTM.prototype.makeRBT = function makeRBT(e) {
					var t = new Array(e);
					var r = BN.prototype._countBits(e) - 1;
					for (var i = 0; i < e; i++) {
						t[i] = this.revBin(i, r, e);
					}
					return t;
				};
				FFTM.prototype.revBin = function revBin(e, t, r) {
					if (e === 0 || e === r - 1) return e;
					var i = 0;
					for (var a = 0; a < t; a++) {
						i |= (e & 1) << (t - a - 1);
						e >>= 1;
					}
					return i;
				};
				FFTM.prototype.permute = function permute(e, t, r, i, a, o) {
					for (var c = 0; c < o; c++) {
						i[c] = t[e[c]];
						a[c] = r[e[c]];
					}
				};
				FFTM.prototype.transform = function transform(e, t, r, i, a, o) {
					this.permute(o, e, t, r, i, a);
					for (var c = 1; c < a; c <<= 1) {
						var u = c << 1;
						var l = Math.cos((2 * Math.PI) / u);
						var d = Math.sin((2 * Math.PI) / u);
						for (var p = 0; p < a; p += u) {
							var m = l;
							var g = d;
							for (var v = 0; v < c; v++) {
								var y = r[p + v];
								var w = i[p + v];
								var _ = r[p + v + c];
								var A = i[p + v + c];
								var k = m * _ - g * A;
								A = m * A + g * _;
								_ = k;
								r[p + v] = y + _;
								i[p + v] = w + A;
								r[p + v + c] = y - _;
								i[p + v + c] = w - A;
								if (v !== u) {
									k = l * m - d * g;
									g = l * g + d * m;
									m = k;
								}
							}
						}
					}
				};
				FFTM.prototype.guessLen13b = function guessLen13b(e, t) {
					var r = Math.max(t, e) | 1;
					var i = r & 1;
					var a = 0;
					for (r = (r / 2) | 0; r; r = r >>> 1) {
						a++;
					}
					return 1 << (a + 1 + i);
				};
				FFTM.prototype.conjugate = function conjugate(e, t, r) {
					if (r <= 1) return;
					for (var i = 0; i < r / 2; i++) {
						var a = e[i];
						e[i] = e[r - i - 1];
						e[r - i - 1] = a;
						a = t[i];
						t[i] = -t[r - i - 1];
						t[r - i - 1] = -a;
					}
				};
				FFTM.prototype.normalize13b = function normalize13b(e, t) {
					var r = 0;
					for (var i = 0; i < t / 2; i++) {
						var a = Math.round(e[2 * i + 1] / t) * 8192 + Math.round(e[2 * i] / t) + r;
						e[i] = a & 67108863;
						if (a < 67108864) {
							r = 0;
						} else {
							r = (a / 67108864) | 0;
						}
					}
					return e;
				};
				FFTM.prototype.convert13b = function convert13b(e, t, r, i) {
					var a = 0;
					for (var o = 0; o < t; o++) {
						a = a + (e[o] | 0);
						r[2 * o] = a & 8191;
						a = a >>> 13;
						r[2 * o + 1] = a & 8191;
						a = a >>> 13;
					}
					for (o = 2 * t; o < i; ++o) {
						r[o] = 0;
					}
					assert(a === 0);
					assert((a & ~8191) === 0);
				};
				FFTM.prototype.stub = function stub(e) {
					var t = new Array(e);
					for (var r = 0; r < e; r++) {
						t[r] = 0;
					}
					return t;
				};
				FFTM.prototype.mulp = function mulp(e, t, r) {
					var i = 2 * this.guessLen13b(e.length, t.length);
					var a = this.makeRBT(i);
					var o = this.stub(i);
					var c = new Array(i);
					var u = new Array(i);
					var l = new Array(i);
					var d = new Array(i);
					var p = new Array(i);
					var m = new Array(i);
					var g = r.words;
					g.length = i;
					this.convert13b(e.words, e.length, c, i);
					this.convert13b(t.words, t.length, d, i);
					this.transform(c, o, u, l, i, a);
					this.transform(d, o, p, m, i, a);
					for (var v = 0; v < i; v++) {
						var y = u[v] * p[v] - l[v] * m[v];
						l[v] = u[v] * m[v] + l[v] * p[v];
						u[v] = y;
					}
					this.conjugate(u, l, i);
					this.transform(u, l, g, o, i, a);
					this.conjugate(g, o, i);
					this.normalize13b(g, i);
					r.negative = e.negative ^ t.negative;
					r.length = e.length + t.length;
					return r.strip();
				};
				BN.prototype.mul = function mul(e) {
					var t = new BN(null);
					t.words = new Array(this.length + e.length);
					return this.mulTo(e, t);
				};
				BN.prototype.mulf = function mulf(e) {
					var t = new BN(null);
					t.words = new Array(this.length + e.length);
					return jumboMulTo(this, e, t);
				};
				BN.prototype.imul = function imul(e) {
					return this.clone().mulTo(e, this);
				};
				BN.prototype.imuln = function imuln(e) {
					assert(typeof e === 'number');
					assert(e < 67108864);
					var t = 0;
					for (var r = 0; r < this.length; r++) {
						var i = (this.words[r] | 0) * e;
						var a = (i & 67108863) + (t & 67108863);
						t >>= 26;
						t += (i / 67108864) | 0;
						t += a >>> 26;
						this.words[r] = a & 67108863;
					}
					if (t !== 0) {
						this.words[r] = t;
						this.length++;
					}
					return this;
				};
				BN.prototype.muln = function muln(e) {
					return this.clone().imuln(e);
				};
				BN.prototype.sqr = function sqr() {
					return this.mul(this);
				};
				BN.prototype.isqr = function isqr() {
					return this.imul(this.clone());
				};
				BN.prototype.pow = function pow(e) {
					var t = toBitArray(e);
					if (t.length === 0) return new BN(1);
					var r = this;
					for (var i = 0; i < t.length; i++, r = r.sqr()) {
						if (t[i] !== 0) break;
					}
					if (++i < t.length) {
						for (var a = r.sqr(); i < t.length; i++, a = a.sqr()) {
							if (t[i] === 0) continue;
							r = r.mul(a);
						}
					}
					return r;
				};
				BN.prototype.iushln = function iushln(e) {
					assert(typeof e === 'number' && e >= 0);
					var t = e % 26;
					var r = (e - t) / 26;
					var i = (67108863 >>> (26 - t)) << (26 - t);
					var a;
					if (t !== 0) {
						var o = 0;
						for (a = 0; a < this.length; a++) {
							var c = this.words[a] & i;
							var u = ((this.words[a] | 0) - c) << t;
							this.words[a] = u | o;
							o = c >>> (26 - t);
						}
						if (o) {
							this.words[a] = o;
							this.length++;
						}
					}
					if (r !== 0) {
						for (a = this.length - 1; a >= 0; a--) {
							this.words[a + r] = this.words[a];
						}
						for (a = 0; a < r; a++) {
							this.words[a] = 0;
						}
						this.length += r;
					}
					return this.strip();
				};
				BN.prototype.ishln = function ishln(e) {
					assert(this.negative === 0);
					return this.iushln(e);
				};
				BN.prototype.iushrn = function iushrn(e, t, r) {
					assert(typeof e === 'number' && e >= 0);
					var i;
					if (t) {
						i = (t - (t % 26)) / 26;
					} else {
						i = 0;
					}
					var a = e % 26;
					var o = Math.min((e - a) / 26, this.length);
					var c = 67108863 ^ ((67108863 >>> a) << a);
					var u = r;
					i -= o;
					i = Math.max(0, i);
					if (u) {
						for (var l = 0; l < o; l++) {
							u.words[l] = this.words[l];
						}
						u.length = o;
					}
					if (o === 0) {
					} else if (this.length > o) {
						this.length -= o;
						for (l = 0; l < this.length; l++) {
							this.words[l] = this.words[l + o];
						}
					} else {
						this.words[0] = 0;
						this.length = 1;
					}
					var d = 0;
					for (l = this.length - 1; l >= 0 && (d !== 0 || l >= i); l--) {
						var p = this.words[l] | 0;
						this.words[l] = (d << (26 - a)) | (p >>> a);
						d = p & c;
					}
					if (u && d !== 0) {
						u.words[u.length++] = d;
					}
					if (this.length === 0) {
						this.words[0] = 0;
						this.length = 1;
					}
					return this.strip();
				};
				BN.prototype.ishrn = function ishrn(e, t, r) {
					assert(this.negative === 0);
					return this.iushrn(e, t, r);
				};
				BN.prototype.shln = function shln(e) {
					return this.clone().ishln(e);
				};
				BN.prototype.ushln = function ushln(e) {
					return this.clone().iushln(e);
				};
				BN.prototype.shrn = function shrn(e) {
					return this.clone().ishrn(e);
				};
				BN.prototype.ushrn = function ushrn(e) {
					return this.clone().iushrn(e);
				};
				BN.prototype.testn = function testn(e) {
					assert(typeof e === 'number' && e >= 0);
					var t = e % 26;
					var r = (e - t) / 26;
					var i = 1 << t;
					if (this.length <= r) return false;
					var a = this.words[r];
					return !!(a & i);
				};
				BN.prototype.imaskn = function imaskn(e) {
					assert(typeof e === 'number' && e >= 0);
					var t = e % 26;
					var r = (e - t) / 26;
					assert(this.negative === 0, 'imaskn works only with positive numbers');
					if (this.length <= r) {
						return this;
					}
					if (t !== 0) {
						r++;
					}
					this.length = Math.min(r, this.length);
					if (t !== 0) {
						var i = 67108863 ^ ((67108863 >>> t) << t);
						this.words[this.length - 1] &= i;
					}
					return this.strip();
				};
				BN.prototype.maskn = function maskn(e) {
					return this.clone().imaskn(e);
				};
				BN.prototype.iaddn = function iaddn(e) {
					assert(typeof e === 'number');
					assert(e < 67108864);
					if (e < 0) return this.isubn(-e);
					if (this.negative !== 0) {
						if (this.length === 1 && (this.words[0] | 0) < e) {
							this.words[0] = e - (this.words[0] | 0);
							this.negative = 0;
							return this;
						}
						this.negative = 0;
						this.isubn(e);
						this.negative = 1;
						return this;
					}
					return this._iaddn(e);
				};
				BN.prototype._iaddn = function _iaddn(e) {
					this.words[0] += e;
					for (var t = 0; t < this.length && this.words[t] >= 67108864; t++) {
						this.words[t] -= 67108864;
						if (t === this.length - 1) {
							this.words[t + 1] = 1;
						} else {
							this.words[t + 1]++;
						}
					}
					this.length = Math.max(this.length, t + 1);
					return this;
				};
				BN.prototype.isubn = function isubn(e) {
					assert(typeof e === 'number');
					assert(e < 67108864);
					if (e < 0) return this.iaddn(-e);
					if (this.negative !== 0) {
						this.negative = 0;
						this.iaddn(e);
						this.negative = 1;
						return this;
					}
					this.words[0] -= e;
					if (this.length === 1 && this.words[0] < 0) {
						this.words[0] = -this.words[0];
						this.negative = 1;
					} else {
						for (var t = 0; t < this.length && this.words[t] < 0; t++) {
							this.words[t] += 67108864;
							this.words[t + 1] -= 1;
						}
					}
					return this.strip();
				};
				BN.prototype.addn = function addn(e) {
					return this.clone().iaddn(e);
				};
				BN.prototype.subn = function subn(e) {
					return this.clone().isubn(e);
				};
				BN.prototype.iabs = function iabs() {
					this.negative = 0;
					return this;
				};
				BN.prototype.abs = function abs() {
					return this.clone().iabs();
				};
				BN.prototype._ishlnsubmul = function _ishlnsubmul(e, t, r) {
					var i = e.length + r;
					var a;
					this._expand(i);
					var o;
					var c = 0;
					for (a = 0; a < e.length; a++) {
						o = (this.words[a + r] | 0) + c;
						var u = (e.words[a] | 0) * t;
						o -= u & 67108863;
						c = (o >> 26) - ((u / 67108864) | 0);
						this.words[a + r] = o & 67108863;
					}
					for (; a < this.length - r; a++) {
						o = (this.words[a + r] | 0) + c;
						c = o >> 26;
						this.words[a + r] = o & 67108863;
					}
					if (c === 0) return this.strip();
					assert(c === -1);
					c = 0;
					for (a = 0; a < this.length; a++) {
						o = -(this.words[a] | 0) + c;
						c = o >> 26;
						this.words[a] = o & 67108863;
					}
					this.negative = 1;
					return this.strip();
				};
				BN.prototype._wordDiv = function _wordDiv(e, t) {
					var r = this.length - e.length;
					var i = this.clone();
					var a = e;
					var o = a.words[a.length - 1] | 0;
					var c = this._countBits(o);
					r = 26 - c;
					if (r !== 0) {
						a = a.ushln(r);
						i.iushln(r);
						o = a.words[a.length - 1] | 0;
					}
					var u = i.length - a.length;
					var l;
					if (t !== 'mod') {
						l = new BN(null);
						l.length = u + 1;
						l.words = new Array(l.length);
						for (var d = 0; d < l.length; d++) {
							l.words[d] = 0;
						}
					}
					var p = i.clone()._ishlnsubmul(a, 1, u);
					if (p.negative === 0) {
						i = p;
						if (l) {
							l.words[u] = 1;
						}
					}
					for (var m = u - 1; m >= 0; m--) {
						var g = (i.words[a.length + m] | 0) * 67108864 + (i.words[a.length + m - 1] | 0);
						g = Math.min((g / o) | 0, 67108863);
						i._ishlnsubmul(a, g, m);
						while (i.negative !== 0) {
							g--;
							i.negative = 0;
							i._ishlnsubmul(a, 1, m);
							if (!i.isZero()) {
								i.negative ^= 1;
							}
						}
						if (l) {
							l.words[m] = g;
						}
					}
					if (l) {
						l.strip();
					}
					i.strip();
					if (t !== 'div' && r !== 0) {
						i.iushrn(r);
					}
					return { div: l || null, mod: i };
				};
				BN.prototype.divmod = function divmod(e, t, r) {
					assert(!e.isZero());
					if (this.isZero()) {
						return { div: new BN(0), mod: new BN(0) };
					}
					var i, a, o;
					if (this.negative !== 0 && e.negative === 0) {
						o = this.neg().divmod(e, t);
						if (t !== 'mod') {
							i = o.div.neg();
						}
						if (t !== 'div') {
							a = o.mod.neg();
							if (r && a.negative !== 0) {
								a.iadd(e);
							}
						}
						return { div: i, mod: a };
					}
					if (this.negative === 0 && e.negative !== 0) {
						o = this.divmod(e.neg(), t);
						if (t !== 'mod') {
							i = o.div.neg();
						}
						return { div: i, mod: o.mod };
					}
					if ((this.negative & e.negative) !== 0) {
						o = this.neg().divmod(e.neg(), t);
						if (t !== 'div') {
							a = o.mod.neg();
							if (r && a.negative !== 0) {
								a.isub(e);
							}
						}
						return { div: o.div, mod: a };
					}
					if (e.length > this.length || this.cmp(e) < 0) {
						return { div: new BN(0), mod: this };
					}
					if (e.length === 1) {
						if (t === 'div') {
							return { div: this.divn(e.words[0]), mod: null };
						}
						if (t === 'mod') {
							return { div: null, mod: new BN(this.modn(e.words[0])) };
						}
						return { div: this.divn(e.words[0]), mod: new BN(this.modn(e.words[0])) };
					}
					return this._wordDiv(e, t);
				};
				BN.prototype.div = function div(e) {
					return this.divmod(e, 'div', false).div;
				};
				BN.prototype.mod = function mod(e) {
					return this.divmod(e, 'mod', false).mod;
				};
				BN.prototype.umod = function umod(e) {
					return this.divmod(e, 'mod', true).mod;
				};
				BN.prototype.divRound = function divRound(e) {
					var t = this.divmod(e);
					if (t.mod.isZero()) return t.div;
					var r = t.div.negative !== 0 ? t.mod.isub(e) : t.mod;
					var i = e.ushrn(1);
					var a = e.andln(1);
					var o = r.cmp(i);
					if (o < 0 || (a === 1 && o === 0)) return t.div;
					return t.div.negative !== 0 ? t.div.isubn(1) : t.div.iaddn(1);
				};
				BN.prototype.modn = function modn(e) {
					assert(e <= 67108863);
					var t = (1 << 26) % e;
					var r = 0;
					for (var i = this.length - 1; i >= 0; i--) {
						r = (t * r + (this.words[i] | 0)) % e;
					}
					return r;
				};
				BN.prototype.idivn = function idivn(e) {
					assert(e <= 67108863);
					var t = 0;
					for (var r = this.length - 1; r >= 0; r--) {
						var i = (this.words[r] | 0) + t * 67108864;
						this.words[r] = (i / e) | 0;
						t = i % e;
					}
					return this.strip();
				};
				BN.prototype.divn = function divn(e) {
					return this.clone().idivn(e);
				};
				BN.prototype.egcd = function egcd(e) {
					assert(e.negative === 0);
					assert(!e.isZero());
					var t = this;
					var r = e.clone();
					if (t.negative !== 0) {
						t = t.umod(e);
					} else {
						t = t.clone();
					}
					var i = new BN(1);
					var a = new BN(0);
					var o = new BN(0);
					var c = new BN(1);
					var u = 0;
					while (t.isEven() && r.isEven()) {
						t.iushrn(1);
						r.iushrn(1);
						++u;
					}
					var l = r.clone();
					var d = t.clone();
					while (!t.isZero()) {
						for (var p = 0, m = 1; (t.words[0] & m) === 0 && p < 26; ++p, m <<= 1);
						if (p > 0) {
							t.iushrn(p);
							while (p-- > 0) {
								if (i.isOdd() || a.isOdd()) {
									i.iadd(l);
									a.isub(d);
								}
								i.iushrn(1);
								a.iushrn(1);
							}
						}
						for (var g = 0, v = 1; (r.words[0] & v) === 0 && g < 26; ++g, v <<= 1);
						if (g > 0) {
							r.iushrn(g);
							while (g-- > 0) {
								if (o.isOdd() || c.isOdd()) {
									o.iadd(l);
									c.isub(d);
								}
								o.iushrn(1);
								c.iushrn(1);
							}
						}
						if (t.cmp(r) >= 0) {
							t.isub(r);
							i.isub(o);
							a.isub(c);
						} else {
							r.isub(t);
							o.isub(i);
							c.isub(a);
						}
					}
					return { a: o, b: c, gcd: r.iushln(u) };
				};
				BN.prototype._invmp = function _invmp(e) {
					assert(e.negative === 0);
					assert(!e.isZero());
					var t = this;
					var r = e.clone();
					if (t.negative !== 0) {
						t = t.umod(e);
					} else {
						t = t.clone();
					}
					var i = new BN(1);
					var a = new BN(0);
					var o = r.clone();
					while (t.cmpn(1) > 0 && r.cmpn(1) > 0) {
						for (var c = 0, u = 1; (t.words[0] & u) === 0 && c < 26; ++c, u <<= 1);
						if (c > 0) {
							t.iushrn(c);
							while (c-- > 0) {
								if (i.isOdd()) {
									i.iadd(o);
								}
								i.iushrn(1);
							}
						}
						for (var l = 0, d = 1; (r.words[0] & d) === 0 && l < 26; ++l, d <<= 1);
						if (l > 0) {
							r.iushrn(l);
							while (l-- > 0) {
								if (a.isOdd()) {
									a.iadd(o);
								}
								a.iushrn(1);
							}
						}
						if (t.cmp(r) >= 0) {
							t.isub(r);
							i.isub(a);
						} else {
							r.isub(t);
							a.isub(i);
						}
					}
					var p;
					if (t.cmpn(1) === 0) {
						p = i;
					} else {
						p = a;
					}
					if (p.cmpn(0) < 0) {
						p.iadd(e);
					}
					return p;
				};
				BN.prototype.gcd = function gcd(e) {
					if (this.isZero()) return e.abs();
					if (e.isZero()) return this.abs();
					var t = this.clone();
					var r = e.clone();
					t.negative = 0;
					r.negative = 0;
					for (var i = 0; t.isEven() && r.isEven(); i++) {
						t.iushrn(1);
						r.iushrn(1);
					}
					do {
						while (t.isEven()) {
							t.iushrn(1);
						}
						while (r.isEven()) {
							r.iushrn(1);
						}
						var a = t.cmp(r);
						if (a < 0) {
							var o = t;
							t = r;
							r = o;
						} else if (a === 0 || r.cmpn(1) === 0) {
							break;
						}
						t.isub(r);
					} while (true);
					return r.iushln(i);
				};
				BN.prototype.invm = function invm(e) {
					return this.egcd(e).a.umod(e);
				};
				BN.prototype.isEven = function isEven() {
					return (this.words[0] & 1) === 0;
				};
				BN.prototype.isOdd = function isOdd() {
					return (this.words[0] & 1) === 1;
				};
				BN.prototype.andln = function andln(e) {
					return this.words[0] & e;
				};
				BN.prototype.bincn = function bincn(e) {
					assert(typeof e === 'number');
					var t = e % 26;
					var r = (e - t) / 26;
					var i = 1 << t;
					if (this.length <= r) {
						this._expand(r + 1);
						this.words[r] |= i;
						return this;
					}
					var a = i;
					for (var o = r; a !== 0 && o < this.length; o++) {
						var c = this.words[o] | 0;
						c += a;
						a = c >>> 26;
						c &= 67108863;
						this.words[o] = c;
					}
					if (a !== 0) {
						this.words[o] = a;
						this.length++;
					}
					return this;
				};
				BN.prototype.isZero = function isZero() {
					return this.length === 1 && this.words[0] === 0;
				};
				BN.prototype.cmpn = function cmpn(e) {
					var t = e < 0;
					if (this.negative !== 0 && !t) return -1;
					if (this.negative === 0 && t) return 1;
					this.strip();
					var r;
					if (this.length > 1) {
						r = 1;
					} else {
						if (t) {
							e = -e;
						}
						assert(e <= 67108863, 'Number is too big');
						var i = this.words[0] | 0;
						r = i === e ? 0 : i < e ? -1 : 1;
					}
					if (this.negative !== 0) return -r | 0;
					return r;
				};
				BN.prototype.cmp = function cmp(e) {
					if (this.negative !== 0 && e.negative === 0) return -1;
					if (this.negative === 0 && e.negative !== 0) return 1;
					var t = this.ucmp(e);
					if (this.negative !== 0) return -t | 0;
					return t;
				};
				BN.prototype.ucmp = function ucmp(e) {
					if (this.length > e.length) return 1;
					if (this.length < e.length) return -1;
					var t = 0;
					for (var r = this.length - 1; r >= 0; r--) {
						var i = this.words[r] | 0;
						var a = e.words[r] | 0;
						if (i === a) continue;
						if (i < a) {
							t = -1;
						} else if (i > a) {
							t = 1;
						}
						break;
					}
					return t;
				};
				BN.prototype.gtn = function gtn(e) {
					return this.cmpn(e) === 1;
				};
				BN.prototype.gt = function gt(e) {
					return this.cmp(e) === 1;
				};
				BN.prototype.gten = function gten(e) {
					return this.cmpn(e) >= 0;
				};
				BN.prototype.gte = function gte(e) {
					return this.cmp(e) >= 0;
				};
				BN.prototype.ltn = function ltn(e) {
					return this.cmpn(e) === -1;
				};
				BN.prototype.lt = function lt(e) {
					return this.cmp(e) === -1;
				};
				BN.prototype.lten = function lten(e) {
					return this.cmpn(e) <= 0;
				};
				BN.prototype.lte = function lte(e) {
					return this.cmp(e) <= 0;
				};
				BN.prototype.eqn = function eqn(e) {
					return this.cmpn(e) === 0;
				};
				BN.prototype.eq = function eq(e) {
					return this.cmp(e) === 0;
				};
				BN.red = function red(e) {
					return new Red(e);
				};
				BN.prototype.toRed = function toRed(e) {
					assert(!this.red, 'Already a number in reduction context');
					assert(this.negative === 0, 'red works only with positives');
					return e.convertTo(this)._forceRed(e);
				};
				BN.prototype.fromRed = function fromRed() {
					assert(this.red, 'fromRed works only with numbers in reduction context');
					return this.red.convertFrom(this);
				};
				BN.prototype._forceRed = function _forceRed(e) {
					this.red = e;
					return this;
				};
				BN.prototype.forceRed = function forceRed(e) {
					assert(!this.red, 'Already a number in reduction context');
					return this._forceRed(e);
				};
				BN.prototype.redAdd = function redAdd(e) {
					assert(this.red, 'redAdd works only with red numbers');
					return this.red.add(this, e);
				};
				BN.prototype.redIAdd = function redIAdd(e) {
					assert(this.red, 'redIAdd works only with red numbers');
					return this.red.iadd(this, e);
				};
				BN.prototype.redSub = function redSub(e) {
					assert(this.red, 'redSub works only with red numbers');
					return this.red.sub(this, e);
				};
				BN.prototype.redISub = function redISub(e) {
					assert(this.red, 'redISub works only with red numbers');
					return this.red.isub(this, e);
				};
				BN.prototype.redShl = function redShl(e) {
					assert(this.red, 'redShl works only with red numbers');
					return this.red.shl(this, e);
				};
				BN.prototype.redMul = function redMul(e) {
					assert(this.red, 'redMul works only with red numbers');
					this.red._verify2(this, e);
					return this.red.mul(this, e);
				};
				BN.prototype.redIMul = function redIMul(e) {
					assert(this.red, 'redMul works only with red numbers');
					this.red._verify2(this, e);
					return this.red.imul(this, e);
				};
				BN.prototype.redSqr = function redSqr() {
					assert(this.red, 'redSqr works only with red numbers');
					this.red._verify1(this);
					return this.red.sqr(this);
				};
				BN.prototype.redISqr = function redISqr() {
					assert(this.red, 'redISqr works only with red numbers');
					this.red._verify1(this);
					return this.red.isqr(this);
				};
				BN.prototype.redSqrt = function redSqrt() {
					assert(this.red, 'redSqrt works only with red numbers');
					this.red._verify1(this);
					return this.red.sqrt(this);
				};
				BN.prototype.redInvm = function redInvm() {
					assert(this.red, 'redInvm works only with red numbers');
					this.red._verify1(this);
					return this.red.invm(this);
				};
				BN.prototype.redNeg = function redNeg() {
					assert(this.red, 'redNeg works only with red numbers');
					this.red._verify1(this);
					return this.red.neg(this);
				};
				BN.prototype.redPow = function redPow(e) {
					assert(this.red && !e.red, 'redPow(normalNum)');
					this.red._verify1(this);
					return this.red.pow(this, e);
				};
				var l = { k256: null, p224: null, p192: null, p25519: null };
				function MPrime(e, t) {
					this.name = e;
					this.p = new BN(t, 16);
					this.n = this.p.bitLength();
					this.k = new BN(1).iushln(this.n).isub(this.p);
					this.tmp = this._tmp();
				}
				MPrime.prototype._tmp = function _tmp() {
					var e = new BN(null);
					e.words = new Array(Math.ceil(this.n / 13));
					return e;
				};
				MPrime.prototype.ireduce = function ireduce(e) {
					var t = e;
					var r;
					do {
						this.split(t, this.tmp);
						t = this.imulK(t);
						t = t.iadd(this.tmp);
						r = t.bitLength();
					} while (r > this.n);
					var i = r < this.n ? -1 : t.ucmp(this.p);
					if (i === 0) {
						t.words[0] = 0;
						t.length = 1;
					} else if (i > 0) {
						t.isub(this.p);
					} else {
						if (t.strip !== undefined) {
							t.strip();
						} else {
							t._strip();
						}
					}
					return t;
				};
				MPrime.prototype.split = function split(e, t) {
					e.iushrn(this.n, 0, t);
				};
				MPrime.prototype.imulK = function imulK(e) {
					return e.imul(this.k);
				};
				function K256() {
					MPrime.call(
						this,
						'k256',
						'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f'
					);
				}
				inherits(K256, MPrime);
				K256.prototype.split = function split(e, t) {
					var r = 4194303;
					var i = Math.min(e.length, 9);
					for (var a = 0; a < i; a++) {
						t.words[a] = e.words[a];
					}
					t.length = i;
					if (e.length <= 9) {
						e.words[0] = 0;
						e.length = 1;
						return;
					}
					var o = e.words[9];
					t.words[t.length++] = o & r;
					for (a = 10; a < e.length; a++) {
						var c = e.words[a] | 0;
						e.words[a - 10] = ((c & r) << 4) | (o >>> 22);
						o = c;
					}
					o >>>= 22;
					e.words[a - 10] = o;
					if (o === 0 && e.length > 10) {
						e.length -= 10;
					} else {
						e.length -= 9;
					}
				};
				K256.prototype.imulK = function imulK(e) {
					e.words[e.length] = 0;
					e.words[e.length + 1] = 0;
					e.length += 2;
					var t = 0;
					for (var r = 0; r < e.length; r++) {
						var i = e.words[r] | 0;
						t += i * 977;
						e.words[r] = t & 67108863;
						t = i * 64 + ((t / 67108864) | 0);
					}
					if (e.words[e.length - 1] === 0) {
						e.length--;
						if (e.words[e.length - 1] === 0) {
							e.length--;
						}
					}
					return e;
				};
				function P224() {
					MPrime.call(
						this,
						'p224',
						'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001'
					);
				}
				inherits(P224, MPrime);
				function P192() {
					MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
				}
				inherits(P192, MPrime);
				function P25519() {
					MPrime.call(
						this,
						'25519',
						'7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed'
					);
				}
				inherits(P25519, MPrime);
				P25519.prototype.imulK = function imulK(e) {
					var t = 0;
					for (var r = 0; r < e.length; r++) {
						var i = (e.words[r] | 0) * 19 + t;
						var a = i & 67108863;
						i >>>= 26;
						e.words[r] = a;
						t = i;
					}
					if (t !== 0) {
						e.words[e.length++] = t;
					}
					return e;
				};
				BN._prime = function prime(e) {
					if (l[e]) return l[e];
					var prime;
					if (e === 'k256') {
						prime = new K256();
					} else if (e === 'p224') {
						prime = new P224();
					} else if (e === 'p192') {
						prime = new P192();
					} else if (e === 'p25519') {
						prime = new P25519();
					} else {
						throw new Error('Unknown prime ' + e);
					}
					l[e] = prime;
					return prime;
				};
				function Red(e) {
					if (typeof e === 'string') {
						var t = BN._prime(e);
						this.m = t.p;
						this.prime = t;
					} else {
						assert(e.gtn(1), 'modulus must be greater than 1');
						this.m = e;
						this.prime = null;
					}
				}
				Red.prototype._verify1 = function _verify1(e) {
					assert(e.negative === 0, 'red works only with positives');
					assert(e.red, 'red works only with red numbers');
				};
				Red.prototype._verify2 = function _verify2(e, t) {
					assert((e.negative | t.negative) === 0, 'red works only with positives');
					assert(e.red && e.red === t.red, 'red works only with red numbers');
				};
				Red.prototype.imod = function imod(e) {
					if (this.prime) return this.prime.ireduce(e)._forceRed(this);
					return e.umod(this.m)._forceRed(this);
				};
				Red.prototype.neg = function neg(e) {
					if (e.isZero()) {
						return e.clone();
					}
					return this.m.sub(e)._forceRed(this);
				};
				Red.prototype.add = function add(e, t) {
					this._verify2(e, t);
					var r = e.add(t);
					if (r.cmp(this.m) >= 0) {
						r.isub(this.m);
					}
					return r._forceRed(this);
				};
				Red.prototype.iadd = function iadd(e, t) {
					this._verify2(e, t);
					var r = e.iadd(t);
					if (r.cmp(this.m) >= 0) {
						r.isub(this.m);
					}
					return r;
				};
				Red.prototype.sub = function sub(e, t) {
					this._verify2(e, t);
					var r = e.sub(t);
					if (r.cmpn(0) < 0) {
						r.iadd(this.m);
					}
					return r._forceRed(this);
				};
				Red.prototype.isub = function isub(e, t) {
					this._verify2(e, t);
					var r = e.isub(t);
					if (r.cmpn(0) < 0) {
						r.iadd(this.m);
					}
					return r;
				};
				Red.prototype.shl = function shl(e, t) {
					this._verify1(e);
					return this.imod(e.ushln(t));
				};
				Red.prototype.imul = function imul(e, t) {
					this._verify2(e, t);
					return this.imod(e.imul(t));
				};
				Red.prototype.mul = function mul(e, t) {
					this._verify2(e, t);
					return this.imod(e.mul(t));
				};
				Red.prototype.isqr = function isqr(e) {
					return this.imul(e, e.clone());
				};
				Red.prototype.sqr = function sqr(e) {
					return this.mul(e, e);
				};
				Red.prototype.sqrt = function sqrt(e) {
					if (e.isZero()) return e.clone();
					var t = this.m.andln(3);
					assert(t % 2 === 1);
					if (t === 3) {
						var r = this.m.add(new BN(1)).iushrn(2);
						return this.pow(e, r);
					}
					var i = this.m.subn(1);
					var a = 0;
					while (!i.isZero() && i.andln(1) === 0) {
						a++;
						i.iushrn(1);
					}
					assert(!i.isZero());
					var o = new BN(1).toRed(this);
					var c = o.redNeg();
					var u = this.m.subn(1).iushrn(1);
					var l = this.m.bitLength();
					l = new BN(2 * l * l).toRed(this);
					while (this.pow(l, u).cmp(c) !== 0) {
						l.redIAdd(c);
					}
					var d = this.pow(l, i);
					var p = this.pow(e, i.addn(1).iushrn(1));
					var m = this.pow(e, i);
					var g = a;
					while (m.cmp(o) !== 0) {
						var v = m;
						for (var y = 0; v.cmp(o) !== 0; y++) {
							v = v.redSqr();
						}
						assert(y < g);
						var w = this.pow(d, new BN(1).iushln(g - y - 1));
						p = p.redMul(w);
						d = w.redSqr();
						m = m.redMul(d);
						g = y;
					}
					return p;
				};
				Red.prototype.invm = function invm(e) {
					var t = e._invmp(this.m);
					if (t.negative !== 0) {
						t.negative = 0;
						return this.imod(t).redNeg();
					} else {
						return this.imod(t);
					}
				};
				Red.prototype.pow = function pow(e, t) {
					if (t.isZero()) return new BN(1).toRed(this);
					if (t.cmpn(1) === 0) return e.clone();
					var r = 4;
					var i = new Array(1 << r);
					i[0] = new BN(1).toRed(this);
					i[1] = e;
					for (var a = 2; a < i.length; a++) {
						i[a] = this.mul(i[a - 1], e);
					}
					var o = i[0];
					var c = 0;
					var u = 0;
					var l = t.bitLength() % 26;
					if (l === 0) {
						l = 26;
					}
					for (a = t.length - 1; a >= 0; a--) {
						var d = t.words[a];
						for (var p = l - 1; p >= 0; p--) {
							var m = (d >> p) & 1;
							if (o !== i[0]) {
								o = this.sqr(o);
							}
							if (m === 0 && c === 0) {
								u = 0;
								continue;
							}
							c <<= 1;
							c |= m;
							u++;
							if (u !== r && (a !== 0 || p !== 0)) continue;
							o = this.mul(o, i[c]);
							u = 0;
							c = 0;
						}
						l = 26;
					}
					return o;
				};
				Red.prototype.convertTo = function convertTo(e) {
					var t = e.umod(this.m);
					return t === e ? t.clone() : t;
				};
				Red.prototype.convertFrom = function convertFrom(e) {
					var t = e.clone();
					t.red = null;
					return t;
				};
				BN.mont = function mont(e) {
					return new Mont(e);
				};
				function Mont(e) {
					Red.call(this, e);
					this.shift = this.m.bitLength();
					if (this.shift % 26 !== 0) {
						this.shift += 26 - (this.shift % 26);
					}
					this.r = new BN(1).iushln(this.shift);
					this.r2 = this.imod(this.r.sqr());
					this.rinv = this.r._invmp(this.m);
					this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
					this.minv = this.minv.umod(this.r);
					this.minv = this.r.sub(this.minv);
				}
				inherits(Mont, Red);
				Mont.prototype.convertTo = function convertTo(e) {
					return this.imod(e.ushln(this.shift));
				};
				Mont.prototype.convertFrom = function convertFrom(e) {
					var t = this.imod(e.mul(this.rinv));
					t.red = null;
					return t;
				};
				Mont.prototype.imul = function imul(e, t) {
					if (e.isZero() || t.isZero()) {
						e.words[0] = 0;
						e.length = 1;
						return e;
					}
					var r = e.imul(t);
					var i = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
					var a = r.isub(i).iushrn(this.shift);
					var o = a;
					if (a.cmp(this.m) >= 0) {
						o = a.isub(this.m);
					} else if (a.cmpn(0) < 0) {
						o = a.iadd(this.m);
					}
					return o._forceRed(this);
				};
				Mont.prototype.mul = function mul(e, t) {
					if (e.isZero() || t.isZero()) return new BN(0)._forceRed(this);
					var r = e.mul(t);
					var i = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
					var a = r.isub(i).iushrn(this.shift);
					var o = a;
					if (a.cmp(this.m) >= 0) {
						o = a.isub(this.m);
					} else if (a.cmpn(0) < 0) {
						o = a.iadd(this.m);
					}
					return o._forceRed(this);
				};
				Mont.prototype.invm = function invm(e) {
					var t = this.imod(e._invmp(this.m).mul(this.r2));
					return t._forceRed(this);
				};
			})(false || e, this);
		},
		3900: function (e, t, r) {
			e = r.nmd(e);
			(function (e, t) {
				'use strict';
				function assert(e, t) {
					if (!e) throw new Error(t || 'Assertion failed');
				}
				function inherits(e, t) {
					e.super_ = t;
					var TempCtor = function () {};
					TempCtor.prototype = t.prototype;
					e.prototype = new TempCtor();
					e.prototype.constructor = e;
				}
				function BN(e, t, r) {
					if (BN.isBN(e)) {
						return e;
					}
					this.negative = 0;
					this.words = null;
					this.length = 0;
					this.red = null;
					if (e !== null) {
						if (t === 'le' || t === 'be') {
							r = t;
							t = 10;
						}
						this._init(e || 0, t || 10, r || 'be');
					}
				}
				if (typeof e === 'object') {
					e.exports = BN;
				} else {
					t.BN = BN;
				}
				BN.BN = BN;
				BN.wordSize = 26;
				var i;
				try {
					if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
						i = window.Buffer;
					} else {
						i = r(9322).Buffer;
					}
				} catch (e) {}
				BN.isBN = function isBN(e) {
					if (e instanceof BN) {
						return true;
					}
					return (
						e !== null &&
						typeof e === 'object' &&
						e.constructor.wordSize === BN.wordSize &&
						Array.isArray(e.words)
					);
				};
				BN.max = function max(e, t) {
					if (e.cmp(t) > 0) return e;
					return t;
				};
				BN.min = function min(e, t) {
					if (e.cmp(t) < 0) return e;
					return t;
				};
				BN.prototype._init = function init(e, t, r) {
					if (typeof e === 'number') {
						return this._initNumber(e, t, r);
					}
					if (typeof e === 'object') {
						return this._initArray(e, t, r);
					}
					if (t === 'hex') {
						t = 16;
					}
					assert(t === (t | 0) && t >= 2 && t <= 36);
					e = e.toString().replace(/\s+/g, '');
					var i = 0;
					if (e[0] === '-') {
						i++;
						this.negative = 1;
					}
					if (i < e.length) {
						if (t === 16) {
							this._parseHex(e, i, r);
						} else {
							this._parseBase(e, t, i);
							if (r === 'le') {
								this._initArray(this.toArray(), t, r);
							}
						}
					}
				};
				BN.prototype._initNumber = function _initNumber(e, t, r) {
					if (e < 0) {
						this.negative = 1;
						e = -e;
					}
					if (e < 67108864) {
						this.words = [e & 67108863];
						this.length = 1;
					} else if (e < 4503599627370496) {
						this.words = [e & 67108863, (e / 67108864) & 67108863];
						this.length = 2;
					} else {
						assert(e < 9007199254740992);
						this.words = [e & 67108863, (e / 67108864) & 67108863, 1];
						this.length = 3;
					}
					if (r !== 'le') return;
					this._initArray(this.toArray(), t, r);
				};
				BN.prototype._initArray = function _initArray(e, t, r) {
					assert(typeof e.length === 'number');
					if (e.length <= 0) {
						this.words = [0];
						this.length = 1;
						return this;
					}
					this.length = Math.ceil(e.length / 3);
					this.words = new Array(this.length);
					for (var i = 0; i < this.length; i++) {
						this.words[i] = 0;
					}
					var a, o;
					var c = 0;
					if (r === 'be') {
						for (i = e.length - 1, a = 0; i >= 0; i -= 3) {
							o = e[i] | (e[i - 1] << 8) | (e[i - 2] << 16);
							this.words[a] |= (o << c) & 67108863;
							this.words[a + 1] = (o >>> (26 - c)) & 67108863;
							c += 24;
							if (c >= 26) {
								c -= 26;
								a++;
							}
						}
					} else if (r === 'le') {
						for (i = 0, a = 0; i < e.length; i += 3) {
							o = e[i] | (e[i + 1] << 8) | (e[i + 2] << 16);
							this.words[a] |= (o << c) & 67108863;
							this.words[a + 1] = (o >>> (26 - c)) & 67108863;
							c += 24;
							if (c >= 26) {
								c -= 26;
								a++;
							}
						}
					}
					return this._strip();
				};
				function parseHex4Bits(e, t) {
					var r = e.charCodeAt(t);
					if (r >= 48 && r <= 57) {
						return r - 48;
					} else if (r >= 65 && r <= 70) {
						return r - 55;
					} else if (r >= 97 && r <= 102) {
						return r - 87;
					} else {
						assert(false, 'Invalid character in ' + e);
					}
				}
				function parseHexByte(e, t, r) {
					var i = parseHex4Bits(e, r);
					if (r - 1 >= t) {
						i |= parseHex4Bits(e, r - 1) << 4;
					}
					return i;
				}
				BN.prototype._parseHex = function _parseHex(e, t, r) {
					this.length = Math.ceil((e.length - t) / 6);
					this.words = new Array(this.length);
					for (var i = 0; i < this.length; i++) {
						this.words[i] = 0;
					}
					var a = 0;
					var o = 0;
					var c;
					if (r === 'be') {
						for (i = e.length - 1; i >= t; i -= 2) {
							c = parseHexByte(e, t, i) << a;
							this.words[o] |= c & 67108863;
							if (a >= 18) {
								a -= 18;
								o += 1;
								this.words[o] |= c >>> 26;
							} else {
								a += 8;
							}
						}
					} else {
						var u = e.length - t;
						for (i = u % 2 === 0 ? t + 1 : t; i < e.length; i += 2) {
							c = parseHexByte(e, t, i) << a;
							this.words[o] |= c & 67108863;
							if (a >= 18) {
								a -= 18;
								o += 1;
								this.words[o] |= c >>> 26;
							} else {
								a += 8;
							}
						}
					}
					this._strip();
				};
				function parseBase(e, t, r, i) {
					var a = 0;
					var o = 0;
					var c = Math.min(e.length, r);
					for (var u = t; u < c; u++) {
						var l = e.charCodeAt(u) - 48;
						a *= i;
						if (l >= 49) {
							o = l - 49 + 10;
						} else if (l >= 17) {
							o = l - 17 + 10;
						} else {
							o = l;
						}
						assert(l >= 0 && o < i, 'Invalid character');
						a += o;
					}
					return a;
				}
				BN.prototype._parseBase = function _parseBase(e, t, r) {
					this.words = [0];
					this.length = 1;
					for (var i = 0, a = 1; a <= 67108863; a *= t) {
						i++;
					}
					i--;
					a = (a / t) | 0;
					var o = e.length - r;
					var c = o % i;
					var u = Math.min(o, o - c) + r;
					var l = 0;
					for (var d = r; d < u; d += i) {
						l = parseBase(e, d, d + i, t);
						this.imuln(a);
						if (this.words[0] + l < 67108864) {
							this.words[0] += l;
						} else {
							this._iaddn(l);
						}
					}
					if (c !== 0) {
						var p = 1;
						l = parseBase(e, d, e.length, t);
						for (d = 0; d < c; d++) {
							p *= t;
						}
						this.imuln(p);
						if (this.words[0] + l < 67108864) {
							this.words[0] += l;
						} else {
							this._iaddn(l);
						}
					}
					this._strip();
				};
				BN.prototype.copy = function copy(e) {
					e.words = new Array(this.length);
					for (var t = 0; t < this.length; t++) {
						e.words[t] = this.words[t];
					}
					e.length = this.length;
					e.negative = this.negative;
					e.red = this.red;
				};
				function move(e, t) {
					e.words = t.words;
					e.length = t.length;
					e.negative = t.negative;
					e.red = t.red;
				}
				BN.prototype._move = function _move(e) {
					move(e, this);
				};
				BN.prototype.clone = function clone() {
					var e = new BN(null);
					this.copy(e);
					return e;
				};
				BN.prototype._expand = function _expand(e) {
					while (this.length < e) {
						this.words[this.length++] = 0;
					}
					return this;
				};
				BN.prototype._strip = function strip() {
					while (this.length > 1 && this.words[this.length - 1] === 0) {
						this.length--;
					}
					return this._normSign();
				};
				BN.prototype._normSign = function _normSign() {
					if (this.length === 1 && this.words[0] === 0) {
						this.negative = 0;
					}
					return this;
				};
				if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
					try {
						BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
					} catch (e) {
						BN.prototype.inspect = inspect;
					}
				} else {
					BN.prototype.inspect = inspect;
				}
				function inspect() {
					return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
				}
				var a = [
					'',
					'0',
					'00',
					'000',
					'0000',
					'00000',
					'000000',
					'0000000',
					'00000000',
					'000000000',
					'0000000000',
					'00000000000',
					'000000000000',
					'0000000000000',
					'00000000000000',
					'000000000000000',
					'0000000000000000',
					'00000000000000000',
					'000000000000000000',
					'0000000000000000000',
					'00000000000000000000',
					'000000000000000000000',
					'0000000000000000000000',
					'00000000000000000000000',
					'000000000000000000000000',
					'0000000000000000000000000'
				];
				var o = [
					0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5,
					5, 5, 5, 5, 5, 5, 5, 5, 5
				];
				var c = [
					0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7,
					19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881,
					64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
					243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
				];
				BN.prototype.toString = function toString(e, t) {
					e = e || 10;
					t = t | 0 || 1;
					var r;
					if (e === 16 || e === 'hex') {
						r = '';
						var i = 0;
						var u = 0;
						for (var l = 0; l < this.length; l++) {
							var d = this.words[l];
							var p = (((d << i) | u) & 16777215).toString(16);
							u = (d >>> (24 - i)) & 16777215;
							i += 2;
							if (i >= 26) {
								i -= 26;
								l--;
							}
							if (u !== 0 || l !== this.length - 1) {
								r = a[6 - p.length] + p + r;
							} else {
								r = p + r;
							}
						}
						if (u !== 0) {
							r = u.toString(16) + r;
						}
						while (r.length % t !== 0) {
							r = '0' + r;
						}
						if (this.negative !== 0) {
							r = '-' + r;
						}
						return r;
					}
					if (e === (e | 0) && e >= 2 && e <= 36) {
						var m = o[e];
						var g = c[e];
						r = '';
						var v = this.clone();
						v.negative = 0;
						while (!v.isZero()) {
							var y = v.modrn(g).toString(e);
							v = v.idivn(g);
							if (!v.isZero()) {
								r = a[m - y.length] + y + r;
							} else {
								r = y + r;
							}
						}
						if (this.isZero()) {
							r = '0' + r;
						}
						while (r.length % t !== 0) {
							r = '0' + r;
						}
						if (this.negative !== 0) {
							r = '-' + r;
						}
						return r;
					}
					assert(false, 'Base should be between 2 and 36');
				};
				BN.prototype.toNumber = function toNumber() {
					var e = this.words[0];
					if (this.length === 2) {
						e += this.words[1] * 67108864;
					} else if (this.length === 3 && this.words[2] === 1) {
						e += 4503599627370496 + this.words[1] * 67108864;
					} else if (this.length > 2) {
						assert(false, 'Number can only safely store up to 53 bits');
					}
					return this.negative !== 0 ? -e : e;
				};
				BN.prototype.toJSON = function toJSON() {
					return this.toString(16, 2);
				};
				if (i) {
					BN.prototype.toBuffer = function toBuffer(e, t) {
						return this.toArrayLike(i, e, t);
					};
				}
				BN.prototype.toArray = function toArray(e, t) {
					return this.toArrayLike(Array, e, t);
				};
				var u = function allocate(e, t) {
					if (e.allocUnsafe) {
						return e.allocUnsafe(t);
					}
					return new e(t);
				};
				BN.prototype.toArrayLike = function toArrayLike(e, t, r) {
					this._strip();
					var i = this.byteLength();
					var a = r || Math.max(1, i);
					assert(i <= a, 'byte array longer than desired length');
					assert(a > 0, 'Requested array length <= 0');
					var o = u(e, a);
					var c = t === 'le' ? 'LE' : 'BE';
					this['_toArrayLike' + c](o, i);
					return o;
				};
				BN.prototype._toArrayLikeLE = function _toArrayLikeLE(e, t) {
					var r = 0;
					var i = 0;
					for (var a = 0, o = 0; a < this.length; a++) {
						var c = (this.words[a] << o) | i;
						e[r++] = c & 255;
						if (r < e.length) {
							e[r++] = (c >> 8) & 255;
						}
						if (r < e.length) {
							e[r++] = (c >> 16) & 255;
						}
						if (o === 6) {
							if (r < e.length) {
								e[r++] = (c >> 24) & 255;
							}
							i = 0;
							o = 0;
						} else {
							i = c >>> 24;
							o += 2;
						}
					}
					if (r < e.length) {
						e[r++] = i;
						while (r < e.length) {
							e[r++] = 0;
						}
					}
				};
				BN.prototype._toArrayLikeBE = function _toArrayLikeBE(e, t) {
					var r = e.length - 1;
					var i = 0;
					for (var a = 0, o = 0; a < this.length; a++) {
						var c = (this.words[a] << o) | i;
						e[r--] = c & 255;
						if (r >= 0) {
							e[r--] = (c >> 8) & 255;
						}
						if (r >= 0) {
							e[r--] = (c >> 16) & 255;
						}
						if (o === 6) {
							if (r >= 0) {
								e[r--] = (c >> 24) & 255;
							}
							i = 0;
							o = 0;
						} else {
							i = c >>> 24;
							o += 2;
						}
					}
					if (r >= 0) {
						e[r--] = i;
						while (r >= 0) {
							e[r--] = 0;
						}
					}
				};
				if (Math.clz32) {
					BN.prototype._countBits = function _countBits(e) {
						return 32 - Math.clz32(e);
					};
				} else {
					BN.prototype._countBits = function _countBits(e) {
						var t = e;
						var r = 0;
						if (t >= 4096) {
							r += 13;
							t >>>= 13;
						}
						if (t >= 64) {
							r += 7;
							t >>>= 7;
						}
						if (t >= 8) {
							r += 4;
							t >>>= 4;
						}
						if (t >= 2) {
							r += 2;
							t >>>= 2;
						}
						return r + t;
					};
				}
				BN.prototype._zeroBits = function _zeroBits(e) {
					if (e === 0) return 26;
					var t = e;
					var r = 0;
					if ((t & 8191) === 0) {
						r += 13;
						t >>>= 13;
					}
					if ((t & 127) === 0) {
						r += 7;
						t >>>= 7;
					}
					if ((t & 15) === 0) {
						r += 4;
						t >>>= 4;
					}
					if ((t & 3) === 0) {
						r += 2;
						t >>>= 2;
					}
					if ((t & 1) === 0) {
						r++;
					}
					return r;
				};
				BN.prototype.bitLength = function bitLength() {
					var e = this.words[this.length - 1];
					var t = this._countBits(e);
					return (this.length - 1) * 26 + t;
				};
				function toBitArray(e) {
					var t = new Array(e.bitLength());
					for (var r = 0; r < t.length; r++) {
						var i = (r / 26) | 0;
						var a = r % 26;
						t[r] = (e.words[i] >>> a) & 1;
					}
					return t;
				}
				BN.prototype.zeroBits = function zeroBits() {
					if (this.isZero()) return 0;
					var e = 0;
					for (var t = 0; t < this.length; t++) {
						var r = this._zeroBits(this.words[t]);
						e += r;
						if (r !== 26) break;
					}
					return e;
				};
				BN.prototype.byteLength = function byteLength() {
					return Math.ceil(this.bitLength() / 8);
				};
				BN.prototype.toTwos = function toTwos(e) {
					if (this.negative !== 0) {
						return this.abs().inotn(e).iaddn(1);
					}
					return this.clone();
				};
				BN.prototype.fromTwos = function fromTwos(e) {
					if (this.testn(e - 1)) {
						return this.notn(e).iaddn(1).ineg();
					}
					return this.clone();
				};
				BN.prototype.isNeg = function isNeg() {
					return this.negative !== 0;
				};
				BN.prototype.neg = function neg() {
					return this.clone().ineg();
				};
				BN.prototype.ineg = function ineg() {
					if (!this.isZero()) {
						this.negative ^= 1;
					}
					return this;
				};
				BN.prototype.iuor = function iuor(e) {
					while (this.length < e.length) {
						this.words[this.length++] = 0;
					}
					for (var t = 0; t < e.length; t++) {
						this.words[t] = this.words[t] | e.words[t];
					}
					return this._strip();
				};
				BN.prototype.ior = function ior(e) {
					assert((this.negative | e.negative) === 0);
					return this.iuor(e);
				};
				BN.prototype.or = function or(e) {
					if (this.length > e.length) return this.clone().ior(e);
					return e.clone().ior(this);
				};
				BN.prototype.uor = function uor(e) {
					if (this.length > e.length) return this.clone().iuor(e);
					return e.clone().iuor(this);
				};
				BN.prototype.iuand = function iuand(e) {
					var t;
					if (this.length > e.length) {
						t = e;
					} else {
						t = this;
					}
					for (var r = 0; r < t.length; r++) {
						this.words[r] = this.words[r] & e.words[r];
					}
					this.length = t.length;
					return this._strip();
				};
				BN.prototype.iand = function iand(e) {
					assert((this.negative | e.negative) === 0);
					return this.iuand(e);
				};
				BN.prototype.and = function and(e) {
					if (this.length > e.length) return this.clone().iand(e);
					return e.clone().iand(this);
				};
				BN.prototype.uand = function uand(e) {
					if (this.length > e.length) return this.clone().iuand(e);
					return e.clone().iuand(this);
				};
				BN.prototype.iuxor = function iuxor(e) {
					var t;
					var r;
					if (this.length > e.length) {
						t = this;
						r = e;
					} else {
						t = e;
						r = this;
					}
					for (var i = 0; i < r.length; i++) {
						this.words[i] = t.words[i] ^ r.words[i];
					}
					if (this !== t) {
						for (; i < t.length; i++) {
							this.words[i] = t.words[i];
						}
					}
					this.length = t.length;
					return this._strip();
				};
				BN.prototype.ixor = function ixor(e) {
					assert((this.negative | e.negative) === 0);
					return this.iuxor(e);
				};
				BN.prototype.xor = function xor(e) {
					if (this.length > e.length) return this.clone().ixor(e);
					return e.clone().ixor(this);
				};
				BN.prototype.uxor = function uxor(e) {
					if (this.length > e.length) return this.clone().iuxor(e);
					return e.clone().iuxor(this);
				};
				BN.prototype.inotn = function inotn(e) {
					assert(typeof e === 'number' && e >= 0);
					var t = Math.ceil(e / 26) | 0;
					var r = e % 26;
					this._expand(t);
					if (r > 0) {
						t--;
					}
					for (var i = 0; i < t; i++) {
						this.words[i] = ~this.words[i] & 67108863;
					}
					if (r > 0) {
						this.words[i] = ~this.words[i] & (67108863 >> (26 - r));
					}
					return this._strip();
				};
				BN.prototype.notn = function notn(e) {
					return this.clone().inotn(e);
				};
				BN.prototype.setn = function setn(e, t) {
					assert(typeof e === 'number' && e >= 0);
					var r = (e / 26) | 0;
					var i = e % 26;
					this._expand(r + 1);
					if (t) {
						this.words[r] = this.words[r] | (1 << i);
					} else {
						this.words[r] = this.words[r] & ~(1 << i);
					}
					return this._strip();
				};
				BN.prototype.iadd = function iadd(e) {
					var t;
					if (this.negative !== 0 && e.negative === 0) {
						this.negative = 0;
						t = this.isub(e);
						this.negative ^= 1;
						return this._normSign();
					} else if (this.negative === 0 && e.negative !== 0) {
						e.negative = 0;
						t = this.isub(e);
						e.negative = 1;
						return t._normSign();
					}
					var r, i;
					if (this.length > e.length) {
						r = this;
						i = e;
					} else {
						r = e;
						i = this;
					}
					var a = 0;
					for (var o = 0; o < i.length; o++) {
						t = (r.words[o] | 0) + (i.words[o] | 0) + a;
						this.words[o] = t & 67108863;
						a = t >>> 26;
					}
					for (; a !== 0 && o < r.length; o++) {
						t = (r.words[o] | 0) + a;
						this.words[o] = t & 67108863;
						a = t >>> 26;
					}
					this.length = r.length;
					if (a !== 0) {
						this.words[this.length] = a;
						this.length++;
					} else if (r !== this) {
						for (; o < r.length; o++) {
							this.words[o] = r.words[o];
						}
					}
					return this;
				};
				BN.prototype.add = function add(e) {
					var t;
					if (e.negative !== 0 && this.negative === 0) {
						e.negative = 0;
						t = this.sub(e);
						e.negative ^= 1;
						return t;
					} else if (e.negative === 0 && this.negative !== 0) {
						this.negative = 0;
						t = e.sub(this);
						this.negative = 1;
						return t;
					}
					if (this.length > e.length) return this.clone().iadd(e);
					return e.clone().iadd(this);
				};
				BN.prototype.isub = function isub(e) {
					if (e.negative !== 0) {
						e.negative = 0;
						var t = this.iadd(e);
						e.negative = 1;
						return t._normSign();
					} else if (this.negative !== 0) {
						this.negative = 0;
						this.iadd(e);
						this.negative = 1;
						return this._normSign();
					}
					var r = this.cmp(e);
					if (r === 0) {
						this.negative = 0;
						this.length = 1;
						this.words[0] = 0;
						return this;
					}
					var i, a;
					if (r > 0) {
						i = this;
						a = e;
					} else {
						i = e;
						a = this;
					}
					var o = 0;
					for (var c = 0; c < a.length; c++) {
						t = (i.words[c] | 0) - (a.words[c] | 0) + o;
						o = t >> 26;
						this.words[c] = t & 67108863;
					}
					for (; o !== 0 && c < i.length; c++) {
						t = (i.words[c] | 0) + o;
						o = t >> 26;
						this.words[c] = t & 67108863;
					}
					if (o === 0 && c < i.length && i !== this) {
						for (; c < i.length; c++) {
							this.words[c] = i.words[c];
						}
					}
					this.length = Math.max(this.length, c);
					if (i !== this) {
						this.negative = 1;
					}
					return this._strip();
				};
				BN.prototype.sub = function sub(e) {
					return this.clone().isub(e);
				};
				function smallMulTo(e, t, r) {
					r.negative = t.negative ^ e.negative;
					var i = (e.length + t.length) | 0;
					r.length = i;
					i = (i - 1) | 0;
					var a = e.words[0] | 0;
					var o = t.words[0] | 0;
					var c = a * o;
					var u = c & 67108863;
					var l = (c / 67108864) | 0;
					r.words[0] = u;
					for (var d = 1; d < i; d++) {
						var p = l >>> 26;
						var m = l & 67108863;
						var g = Math.min(d, t.length - 1);
						for (var v = Math.max(0, d - e.length + 1); v <= g; v++) {
							var y = (d - v) | 0;
							a = e.words[y] | 0;
							o = t.words[v] | 0;
							c = a * o + m;
							p += (c / 67108864) | 0;
							m = c & 67108863;
						}
						r.words[d] = m | 0;
						l = p | 0;
					}
					if (l !== 0) {
						r.words[d] = l | 0;
					} else {
						r.length--;
					}
					return r._strip();
				}
				var l = function comb10MulTo(e, t, r) {
					var i = e.words;
					var a = t.words;
					var o = r.words;
					var c = 0;
					var u;
					var l;
					var d;
					var p = i[0] | 0;
					var m = p & 8191;
					var g = p >>> 13;
					var v = i[1] | 0;
					var y = v & 8191;
					var w = v >>> 13;
					var _ = i[2] | 0;
					var A = _ & 8191;
					var k = _ >>> 13;
					var N = i[3] | 0;
					var T = N & 8191;
					var x = N >>> 13;
					var B = i[4] | 0;
					var P = B & 8191;
					var M = B >>> 13;
					var C = i[5] | 0;
					var I = C & 8191;
					var O = C >>> 13;
					var F = i[6] | 0;
					var D = F & 8191;
					var L = F >>> 13;
					var U = i[7] | 0;
					var j = U & 8191;
					var H = U >>> 13;
					var z = i[8] | 0;
					var $ = z & 8191;
					var G = z >>> 13;
					var q = i[9] | 0;
					var V = q & 8191;
					var W = q >>> 13;
					var J = a[0] | 0;
					var Z = J & 8191;
					var Q = J >>> 13;
					var Y = a[1] | 0;
					var X = Y & 8191;
					var ee = Y >>> 13;
					var te = a[2] | 0;
					var re = te & 8191;
					var ne = te >>> 13;
					var ie = a[3] | 0;
					var se = ie & 8191;
					var ae = ie >>> 13;
					var oe = a[4] | 0;
					var ce = oe & 8191;
					var ue = oe >>> 13;
					var le = a[5] | 0;
					var de = le & 8191;
					var he = le >>> 13;
					var pe = a[6] | 0;
					var me = pe & 8191;
					var ve = pe >>> 13;
					var ye = a[7] | 0;
					var be = ye & 8191;
					var we = ye >>> 13;
					var _e = a[8] | 0;
					var Ae = _e & 8191;
					var Ee = _e >>> 13;
					var Se = a[9] | 0;
					var ke = Se & 8191;
					var Ne = Se >>> 13;
					r.negative = e.negative ^ t.negative;
					r.length = 19;
					u = Math.imul(m, Z);
					l = Math.imul(m, Q);
					l = (l + Math.imul(g, Z)) | 0;
					d = Math.imul(g, Q);
					var Te = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Te >>> 26)) | 0;
					Te &= 67108863;
					u = Math.imul(y, Z);
					l = Math.imul(y, Q);
					l = (l + Math.imul(w, Z)) | 0;
					d = Math.imul(w, Q);
					u = (u + Math.imul(m, X)) | 0;
					l = (l + Math.imul(m, ee)) | 0;
					l = (l + Math.imul(g, X)) | 0;
					d = (d + Math.imul(g, ee)) | 0;
					var xe = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (xe >>> 26)) | 0;
					xe &= 67108863;
					u = Math.imul(A, Z);
					l = Math.imul(A, Q);
					l = (l + Math.imul(k, Z)) | 0;
					d = Math.imul(k, Q);
					u = (u + Math.imul(y, X)) | 0;
					l = (l + Math.imul(y, ee)) | 0;
					l = (l + Math.imul(w, X)) | 0;
					d = (d + Math.imul(w, ee)) | 0;
					u = (u + Math.imul(m, re)) | 0;
					l = (l + Math.imul(m, ne)) | 0;
					l = (l + Math.imul(g, re)) | 0;
					d = (d + Math.imul(g, ne)) | 0;
					var Be = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Be >>> 26)) | 0;
					Be &= 67108863;
					u = Math.imul(T, Z);
					l = Math.imul(T, Q);
					l = (l + Math.imul(x, Z)) | 0;
					d = Math.imul(x, Q);
					u = (u + Math.imul(A, X)) | 0;
					l = (l + Math.imul(A, ee)) | 0;
					l = (l + Math.imul(k, X)) | 0;
					d = (d + Math.imul(k, ee)) | 0;
					u = (u + Math.imul(y, re)) | 0;
					l = (l + Math.imul(y, ne)) | 0;
					l = (l + Math.imul(w, re)) | 0;
					d = (d + Math.imul(w, ne)) | 0;
					u = (u + Math.imul(m, se)) | 0;
					l = (l + Math.imul(m, ae)) | 0;
					l = (l + Math.imul(g, se)) | 0;
					d = (d + Math.imul(g, ae)) | 0;
					var Re = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Re >>> 26)) | 0;
					Re &= 67108863;
					u = Math.imul(P, Z);
					l = Math.imul(P, Q);
					l = (l + Math.imul(M, Z)) | 0;
					d = Math.imul(M, Q);
					u = (u + Math.imul(T, X)) | 0;
					l = (l + Math.imul(T, ee)) | 0;
					l = (l + Math.imul(x, X)) | 0;
					d = (d + Math.imul(x, ee)) | 0;
					u = (u + Math.imul(A, re)) | 0;
					l = (l + Math.imul(A, ne)) | 0;
					l = (l + Math.imul(k, re)) | 0;
					d = (d + Math.imul(k, ne)) | 0;
					u = (u + Math.imul(y, se)) | 0;
					l = (l + Math.imul(y, ae)) | 0;
					l = (l + Math.imul(w, se)) | 0;
					d = (d + Math.imul(w, ae)) | 0;
					u = (u + Math.imul(m, ce)) | 0;
					l = (l + Math.imul(m, ue)) | 0;
					l = (l + Math.imul(g, ce)) | 0;
					d = (d + Math.imul(g, ue)) | 0;
					var Pe = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Pe >>> 26)) | 0;
					Pe &= 67108863;
					u = Math.imul(I, Z);
					l = Math.imul(I, Q);
					l = (l + Math.imul(O, Z)) | 0;
					d = Math.imul(O, Q);
					u = (u + Math.imul(P, X)) | 0;
					l = (l + Math.imul(P, ee)) | 0;
					l = (l + Math.imul(M, X)) | 0;
					d = (d + Math.imul(M, ee)) | 0;
					u = (u + Math.imul(T, re)) | 0;
					l = (l + Math.imul(T, ne)) | 0;
					l = (l + Math.imul(x, re)) | 0;
					d = (d + Math.imul(x, ne)) | 0;
					u = (u + Math.imul(A, se)) | 0;
					l = (l + Math.imul(A, ae)) | 0;
					l = (l + Math.imul(k, se)) | 0;
					d = (d + Math.imul(k, ae)) | 0;
					u = (u + Math.imul(y, ce)) | 0;
					l = (l + Math.imul(y, ue)) | 0;
					l = (l + Math.imul(w, ce)) | 0;
					d = (d + Math.imul(w, ue)) | 0;
					u = (u + Math.imul(m, de)) | 0;
					l = (l + Math.imul(m, he)) | 0;
					l = (l + Math.imul(g, de)) | 0;
					d = (d + Math.imul(g, he)) | 0;
					var Me = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Me >>> 26)) | 0;
					Me &= 67108863;
					u = Math.imul(D, Z);
					l = Math.imul(D, Q);
					l = (l + Math.imul(L, Z)) | 0;
					d = Math.imul(L, Q);
					u = (u + Math.imul(I, X)) | 0;
					l = (l + Math.imul(I, ee)) | 0;
					l = (l + Math.imul(O, X)) | 0;
					d = (d + Math.imul(O, ee)) | 0;
					u = (u + Math.imul(P, re)) | 0;
					l = (l + Math.imul(P, ne)) | 0;
					l = (l + Math.imul(M, re)) | 0;
					d = (d + Math.imul(M, ne)) | 0;
					u = (u + Math.imul(T, se)) | 0;
					l = (l + Math.imul(T, ae)) | 0;
					l = (l + Math.imul(x, se)) | 0;
					d = (d + Math.imul(x, ae)) | 0;
					u = (u + Math.imul(A, ce)) | 0;
					l = (l + Math.imul(A, ue)) | 0;
					l = (l + Math.imul(k, ce)) | 0;
					d = (d + Math.imul(k, ue)) | 0;
					u = (u + Math.imul(y, de)) | 0;
					l = (l + Math.imul(y, he)) | 0;
					l = (l + Math.imul(w, de)) | 0;
					d = (d + Math.imul(w, he)) | 0;
					u = (u + Math.imul(m, me)) | 0;
					l = (l + Math.imul(m, ve)) | 0;
					l = (l + Math.imul(g, me)) | 0;
					d = (d + Math.imul(g, ve)) | 0;
					var Ce = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Ce >>> 26)) | 0;
					Ce &= 67108863;
					u = Math.imul(j, Z);
					l = Math.imul(j, Q);
					l = (l + Math.imul(H, Z)) | 0;
					d = Math.imul(H, Q);
					u = (u + Math.imul(D, X)) | 0;
					l = (l + Math.imul(D, ee)) | 0;
					l = (l + Math.imul(L, X)) | 0;
					d = (d + Math.imul(L, ee)) | 0;
					u = (u + Math.imul(I, re)) | 0;
					l = (l + Math.imul(I, ne)) | 0;
					l = (l + Math.imul(O, re)) | 0;
					d = (d + Math.imul(O, ne)) | 0;
					u = (u + Math.imul(P, se)) | 0;
					l = (l + Math.imul(P, ae)) | 0;
					l = (l + Math.imul(M, se)) | 0;
					d = (d + Math.imul(M, ae)) | 0;
					u = (u + Math.imul(T, ce)) | 0;
					l = (l + Math.imul(T, ue)) | 0;
					l = (l + Math.imul(x, ce)) | 0;
					d = (d + Math.imul(x, ue)) | 0;
					u = (u + Math.imul(A, de)) | 0;
					l = (l + Math.imul(A, he)) | 0;
					l = (l + Math.imul(k, de)) | 0;
					d = (d + Math.imul(k, he)) | 0;
					u = (u + Math.imul(y, me)) | 0;
					l = (l + Math.imul(y, ve)) | 0;
					l = (l + Math.imul(w, me)) | 0;
					d = (d + Math.imul(w, ve)) | 0;
					u = (u + Math.imul(m, be)) | 0;
					l = (l + Math.imul(m, we)) | 0;
					l = (l + Math.imul(g, be)) | 0;
					d = (d + Math.imul(g, we)) | 0;
					var Ie = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Ie >>> 26)) | 0;
					Ie &= 67108863;
					u = Math.imul($, Z);
					l = Math.imul($, Q);
					l = (l + Math.imul(G, Z)) | 0;
					d = Math.imul(G, Q);
					u = (u + Math.imul(j, X)) | 0;
					l = (l + Math.imul(j, ee)) | 0;
					l = (l + Math.imul(H, X)) | 0;
					d = (d + Math.imul(H, ee)) | 0;
					u = (u + Math.imul(D, re)) | 0;
					l = (l + Math.imul(D, ne)) | 0;
					l = (l + Math.imul(L, re)) | 0;
					d = (d + Math.imul(L, ne)) | 0;
					u = (u + Math.imul(I, se)) | 0;
					l = (l + Math.imul(I, ae)) | 0;
					l = (l + Math.imul(O, se)) | 0;
					d = (d + Math.imul(O, ae)) | 0;
					u = (u + Math.imul(P, ce)) | 0;
					l = (l + Math.imul(P, ue)) | 0;
					l = (l + Math.imul(M, ce)) | 0;
					d = (d + Math.imul(M, ue)) | 0;
					u = (u + Math.imul(T, de)) | 0;
					l = (l + Math.imul(T, he)) | 0;
					l = (l + Math.imul(x, de)) | 0;
					d = (d + Math.imul(x, he)) | 0;
					u = (u + Math.imul(A, me)) | 0;
					l = (l + Math.imul(A, ve)) | 0;
					l = (l + Math.imul(k, me)) | 0;
					d = (d + Math.imul(k, ve)) | 0;
					u = (u + Math.imul(y, be)) | 0;
					l = (l + Math.imul(y, we)) | 0;
					l = (l + Math.imul(w, be)) | 0;
					d = (d + Math.imul(w, we)) | 0;
					u = (u + Math.imul(m, Ae)) | 0;
					l = (l + Math.imul(m, Ee)) | 0;
					l = (l + Math.imul(g, Ae)) | 0;
					d = (d + Math.imul(g, Ee)) | 0;
					var Oe = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Oe >>> 26)) | 0;
					Oe &= 67108863;
					u = Math.imul(V, Z);
					l = Math.imul(V, Q);
					l = (l + Math.imul(W, Z)) | 0;
					d = Math.imul(W, Q);
					u = (u + Math.imul($, X)) | 0;
					l = (l + Math.imul($, ee)) | 0;
					l = (l + Math.imul(G, X)) | 0;
					d = (d + Math.imul(G, ee)) | 0;
					u = (u + Math.imul(j, re)) | 0;
					l = (l + Math.imul(j, ne)) | 0;
					l = (l + Math.imul(H, re)) | 0;
					d = (d + Math.imul(H, ne)) | 0;
					u = (u + Math.imul(D, se)) | 0;
					l = (l + Math.imul(D, ae)) | 0;
					l = (l + Math.imul(L, se)) | 0;
					d = (d + Math.imul(L, ae)) | 0;
					u = (u + Math.imul(I, ce)) | 0;
					l = (l + Math.imul(I, ue)) | 0;
					l = (l + Math.imul(O, ce)) | 0;
					d = (d + Math.imul(O, ue)) | 0;
					u = (u + Math.imul(P, de)) | 0;
					l = (l + Math.imul(P, he)) | 0;
					l = (l + Math.imul(M, de)) | 0;
					d = (d + Math.imul(M, he)) | 0;
					u = (u + Math.imul(T, me)) | 0;
					l = (l + Math.imul(T, ve)) | 0;
					l = (l + Math.imul(x, me)) | 0;
					d = (d + Math.imul(x, ve)) | 0;
					u = (u + Math.imul(A, be)) | 0;
					l = (l + Math.imul(A, we)) | 0;
					l = (l + Math.imul(k, be)) | 0;
					d = (d + Math.imul(k, we)) | 0;
					u = (u + Math.imul(y, Ae)) | 0;
					l = (l + Math.imul(y, Ee)) | 0;
					l = (l + Math.imul(w, Ae)) | 0;
					d = (d + Math.imul(w, Ee)) | 0;
					u = (u + Math.imul(m, ke)) | 0;
					l = (l + Math.imul(m, Ne)) | 0;
					l = (l + Math.imul(g, ke)) | 0;
					d = (d + Math.imul(g, Ne)) | 0;
					var Fe = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Fe >>> 26)) | 0;
					Fe &= 67108863;
					u = Math.imul(V, X);
					l = Math.imul(V, ee);
					l = (l + Math.imul(W, X)) | 0;
					d = Math.imul(W, ee);
					u = (u + Math.imul($, re)) | 0;
					l = (l + Math.imul($, ne)) | 0;
					l = (l + Math.imul(G, re)) | 0;
					d = (d + Math.imul(G, ne)) | 0;
					u = (u + Math.imul(j, se)) | 0;
					l = (l + Math.imul(j, ae)) | 0;
					l = (l + Math.imul(H, se)) | 0;
					d = (d + Math.imul(H, ae)) | 0;
					u = (u + Math.imul(D, ce)) | 0;
					l = (l + Math.imul(D, ue)) | 0;
					l = (l + Math.imul(L, ce)) | 0;
					d = (d + Math.imul(L, ue)) | 0;
					u = (u + Math.imul(I, de)) | 0;
					l = (l + Math.imul(I, he)) | 0;
					l = (l + Math.imul(O, de)) | 0;
					d = (d + Math.imul(O, he)) | 0;
					u = (u + Math.imul(P, me)) | 0;
					l = (l + Math.imul(P, ve)) | 0;
					l = (l + Math.imul(M, me)) | 0;
					d = (d + Math.imul(M, ve)) | 0;
					u = (u + Math.imul(T, be)) | 0;
					l = (l + Math.imul(T, we)) | 0;
					l = (l + Math.imul(x, be)) | 0;
					d = (d + Math.imul(x, we)) | 0;
					u = (u + Math.imul(A, Ae)) | 0;
					l = (l + Math.imul(A, Ee)) | 0;
					l = (l + Math.imul(k, Ae)) | 0;
					d = (d + Math.imul(k, Ee)) | 0;
					u = (u + Math.imul(y, ke)) | 0;
					l = (l + Math.imul(y, Ne)) | 0;
					l = (l + Math.imul(w, ke)) | 0;
					d = (d + Math.imul(w, Ne)) | 0;
					var De = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (De >>> 26)) | 0;
					De &= 67108863;
					u = Math.imul(V, re);
					l = Math.imul(V, ne);
					l = (l + Math.imul(W, re)) | 0;
					d = Math.imul(W, ne);
					u = (u + Math.imul($, se)) | 0;
					l = (l + Math.imul($, ae)) | 0;
					l = (l + Math.imul(G, se)) | 0;
					d = (d + Math.imul(G, ae)) | 0;
					u = (u + Math.imul(j, ce)) | 0;
					l = (l + Math.imul(j, ue)) | 0;
					l = (l + Math.imul(H, ce)) | 0;
					d = (d + Math.imul(H, ue)) | 0;
					u = (u + Math.imul(D, de)) | 0;
					l = (l + Math.imul(D, he)) | 0;
					l = (l + Math.imul(L, de)) | 0;
					d = (d + Math.imul(L, he)) | 0;
					u = (u + Math.imul(I, me)) | 0;
					l = (l + Math.imul(I, ve)) | 0;
					l = (l + Math.imul(O, me)) | 0;
					d = (d + Math.imul(O, ve)) | 0;
					u = (u + Math.imul(P, be)) | 0;
					l = (l + Math.imul(P, we)) | 0;
					l = (l + Math.imul(M, be)) | 0;
					d = (d + Math.imul(M, we)) | 0;
					u = (u + Math.imul(T, Ae)) | 0;
					l = (l + Math.imul(T, Ee)) | 0;
					l = (l + Math.imul(x, Ae)) | 0;
					d = (d + Math.imul(x, Ee)) | 0;
					u = (u + Math.imul(A, ke)) | 0;
					l = (l + Math.imul(A, Ne)) | 0;
					l = (l + Math.imul(k, ke)) | 0;
					d = (d + Math.imul(k, Ne)) | 0;
					var Le = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Le >>> 26)) | 0;
					Le &= 67108863;
					u = Math.imul(V, se);
					l = Math.imul(V, ae);
					l = (l + Math.imul(W, se)) | 0;
					d = Math.imul(W, ae);
					u = (u + Math.imul($, ce)) | 0;
					l = (l + Math.imul($, ue)) | 0;
					l = (l + Math.imul(G, ce)) | 0;
					d = (d + Math.imul(G, ue)) | 0;
					u = (u + Math.imul(j, de)) | 0;
					l = (l + Math.imul(j, he)) | 0;
					l = (l + Math.imul(H, de)) | 0;
					d = (d + Math.imul(H, he)) | 0;
					u = (u + Math.imul(D, me)) | 0;
					l = (l + Math.imul(D, ve)) | 0;
					l = (l + Math.imul(L, me)) | 0;
					d = (d + Math.imul(L, ve)) | 0;
					u = (u + Math.imul(I, be)) | 0;
					l = (l + Math.imul(I, we)) | 0;
					l = (l + Math.imul(O, be)) | 0;
					d = (d + Math.imul(O, we)) | 0;
					u = (u + Math.imul(P, Ae)) | 0;
					l = (l + Math.imul(P, Ee)) | 0;
					l = (l + Math.imul(M, Ae)) | 0;
					d = (d + Math.imul(M, Ee)) | 0;
					u = (u + Math.imul(T, ke)) | 0;
					l = (l + Math.imul(T, Ne)) | 0;
					l = (l + Math.imul(x, ke)) | 0;
					d = (d + Math.imul(x, Ne)) | 0;
					var Ue = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Ue >>> 26)) | 0;
					Ue &= 67108863;
					u = Math.imul(V, ce);
					l = Math.imul(V, ue);
					l = (l + Math.imul(W, ce)) | 0;
					d = Math.imul(W, ue);
					u = (u + Math.imul($, de)) | 0;
					l = (l + Math.imul($, he)) | 0;
					l = (l + Math.imul(G, de)) | 0;
					d = (d + Math.imul(G, he)) | 0;
					u = (u + Math.imul(j, me)) | 0;
					l = (l + Math.imul(j, ve)) | 0;
					l = (l + Math.imul(H, me)) | 0;
					d = (d + Math.imul(H, ve)) | 0;
					u = (u + Math.imul(D, be)) | 0;
					l = (l + Math.imul(D, we)) | 0;
					l = (l + Math.imul(L, be)) | 0;
					d = (d + Math.imul(L, we)) | 0;
					u = (u + Math.imul(I, Ae)) | 0;
					l = (l + Math.imul(I, Ee)) | 0;
					l = (l + Math.imul(O, Ae)) | 0;
					d = (d + Math.imul(O, Ee)) | 0;
					u = (u + Math.imul(P, ke)) | 0;
					l = (l + Math.imul(P, Ne)) | 0;
					l = (l + Math.imul(M, ke)) | 0;
					d = (d + Math.imul(M, Ne)) | 0;
					var je = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (je >>> 26)) | 0;
					je &= 67108863;
					u = Math.imul(V, de);
					l = Math.imul(V, he);
					l = (l + Math.imul(W, de)) | 0;
					d = Math.imul(W, he);
					u = (u + Math.imul($, me)) | 0;
					l = (l + Math.imul($, ve)) | 0;
					l = (l + Math.imul(G, me)) | 0;
					d = (d + Math.imul(G, ve)) | 0;
					u = (u + Math.imul(j, be)) | 0;
					l = (l + Math.imul(j, we)) | 0;
					l = (l + Math.imul(H, be)) | 0;
					d = (d + Math.imul(H, we)) | 0;
					u = (u + Math.imul(D, Ae)) | 0;
					l = (l + Math.imul(D, Ee)) | 0;
					l = (l + Math.imul(L, Ae)) | 0;
					d = (d + Math.imul(L, Ee)) | 0;
					u = (u + Math.imul(I, ke)) | 0;
					l = (l + Math.imul(I, Ne)) | 0;
					l = (l + Math.imul(O, ke)) | 0;
					d = (d + Math.imul(O, Ne)) | 0;
					var He = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (He >>> 26)) | 0;
					He &= 67108863;
					u = Math.imul(V, me);
					l = Math.imul(V, ve);
					l = (l + Math.imul(W, me)) | 0;
					d = Math.imul(W, ve);
					u = (u + Math.imul($, be)) | 0;
					l = (l + Math.imul($, we)) | 0;
					l = (l + Math.imul(G, be)) | 0;
					d = (d + Math.imul(G, we)) | 0;
					u = (u + Math.imul(j, Ae)) | 0;
					l = (l + Math.imul(j, Ee)) | 0;
					l = (l + Math.imul(H, Ae)) | 0;
					d = (d + Math.imul(H, Ee)) | 0;
					u = (u + Math.imul(D, ke)) | 0;
					l = (l + Math.imul(D, Ne)) | 0;
					l = (l + Math.imul(L, ke)) | 0;
					d = (d + Math.imul(L, Ne)) | 0;
					var ze = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (ze >>> 26)) | 0;
					ze &= 67108863;
					u = Math.imul(V, be);
					l = Math.imul(V, we);
					l = (l + Math.imul(W, be)) | 0;
					d = Math.imul(W, we);
					u = (u + Math.imul($, Ae)) | 0;
					l = (l + Math.imul($, Ee)) | 0;
					l = (l + Math.imul(G, Ae)) | 0;
					d = (d + Math.imul(G, Ee)) | 0;
					u = (u + Math.imul(j, ke)) | 0;
					l = (l + Math.imul(j, Ne)) | 0;
					l = (l + Math.imul(H, ke)) | 0;
					d = (d + Math.imul(H, Ne)) | 0;
					var $e = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + ($e >>> 26)) | 0;
					$e &= 67108863;
					u = Math.imul(V, Ae);
					l = Math.imul(V, Ee);
					l = (l + Math.imul(W, Ae)) | 0;
					d = Math.imul(W, Ee);
					u = (u + Math.imul($, ke)) | 0;
					l = (l + Math.imul($, Ne)) | 0;
					l = (l + Math.imul(G, ke)) | 0;
					d = (d + Math.imul(G, Ne)) | 0;
					var Ge = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (Ge >>> 26)) | 0;
					Ge &= 67108863;
					u = Math.imul(V, ke);
					l = Math.imul(V, Ne);
					l = (l + Math.imul(W, ke)) | 0;
					d = Math.imul(W, Ne);
					var qe = (((c + u) | 0) + ((l & 8191) << 13)) | 0;
					c = (((d + (l >>> 13)) | 0) + (qe >>> 26)) | 0;
					qe &= 67108863;
					o[0] = Te;
					o[1] = xe;
					o[2] = Be;
					o[3] = Re;
					o[4] = Pe;
					o[5] = Me;
					o[6] = Ce;
					o[7] = Ie;
					o[8] = Oe;
					o[9] = Fe;
					o[10] = De;
					o[11] = Le;
					o[12] = Ue;
					o[13] = je;
					o[14] = He;
					o[15] = ze;
					o[16] = $e;
					o[17] = Ge;
					o[18] = qe;
					if (c !== 0) {
						o[19] = c;
						r.length++;
					}
					return r;
				};
				if (!Math.imul) {
					l = smallMulTo;
				}
				function bigMulTo(e, t, r) {
					r.negative = t.negative ^ e.negative;
					r.length = e.length + t.length;
					var i = 0;
					var a = 0;
					for (var o = 0; o < r.length - 1; o++) {
						var c = a;
						a = 0;
						var u = i & 67108863;
						var l = Math.min(o, t.length - 1);
						for (var d = Math.max(0, o - e.length + 1); d <= l; d++) {
							var p = o - d;
							var m = e.words[p] | 0;
							var g = t.words[d] | 0;
							var v = m * g;
							var y = v & 67108863;
							c = (c + ((v / 67108864) | 0)) | 0;
							y = (y + u) | 0;
							u = y & 67108863;
							c = (c + (y >>> 26)) | 0;
							a += c >>> 26;
							c &= 67108863;
						}
						r.words[o] = u;
						i = c;
						c = a;
					}
					if (i !== 0) {
						r.words[o] = i;
					} else {
						r.length--;
					}
					return r._strip();
				}
				function jumboMulTo(e, t, r) {
					return bigMulTo(e, t, r);
				}
				BN.prototype.mulTo = function mulTo(e, t) {
					var r;
					var i = this.length + e.length;
					if (this.length === 10 && e.length === 10) {
						r = l(this, e, t);
					} else if (i < 63) {
						r = smallMulTo(this, e, t);
					} else if (i < 1024) {
						r = bigMulTo(this, e, t);
					} else {
						r = jumboMulTo(this, e, t);
					}
					return r;
				};
				function FFTM(e, t) {
					this.x = e;
					this.y = t;
				}
				FFTM.prototype.makeRBT = function makeRBT(e) {
					var t = new Array(e);
					var r = BN.prototype._countBits(e) - 1;
					for (var i = 0; i < e; i++) {
						t[i] = this.revBin(i, r, e);
					}
					return t;
				};
				FFTM.prototype.revBin = function revBin(e, t, r) {
					if (e === 0 || e === r - 1) return e;
					var i = 0;
					for (var a = 0; a < t; a++) {
						i |= (e & 1) << (t - a - 1);
						e >>= 1;
					}
					return i;
				};
				FFTM.prototype.permute = function permute(e, t, r, i, a, o) {
					for (var c = 0; c < o; c++) {
						i[c] = t[e[c]];
						a[c] = r[e[c]];
					}
				};
				FFTM.prototype.transform = function transform(e, t, r, i, a, o) {
					this.permute(o, e, t, r, i, a);
					for (var c = 1; c < a; c <<= 1) {
						var u = c << 1;
						var l = Math.cos((2 * Math.PI) / u);
						var d = Math.sin((2 * Math.PI) / u);
						for (var p = 0; p < a; p += u) {
							var m = l;
							var g = d;
							for (var v = 0; v < c; v++) {
								var y = r[p + v];
								var w = i[p + v];
								var _ = r[p + v + c];
								var A = i[p + v + c];
								var k = m * _ - g * A;
								A = m * A + g * _;
								_ = k;
								r[p + v] = y + _;
								i[p + v] = w + A;
								r[p + v + c] = y - _;
								i[p + v + c] = w - A;
								if (v !== u) {
									k = l * m - d * g;
									g = l * g + d * m;
									m = k;
								}
							}
						}
					}
				};
				FFTM.prototype.guessLen13b = function guessLen13b(e, t) {
					var r = Math.max(t, e) | 1;
					var i = r & 1;
					var a = 0;
					for (r = (r / 2) | 0; r; r = r >>> 1) {
						a++;
					}
					return 1 << (a + 1 + i);
				};
				FFTM.prototype.conjugate = function conjugate(e, t, r) {
					if (r <= 1) return;
					for (var i = 0; i < r / 2; i++) {
						var a = e[i];
						e[i] = e[r - i - 1];
						e[r - i - 1] = a;
						a = t[i];
						t[i] = -t[r - i - 1];
						t[r - i - 1] = -a;
					}
				};
				FFTM.prototype.normalize13b = function normalize13b(e, t) {
					var r = 0;
					for (var i = 0; i < t / 2; i++) {
						var a = Math.round(e[2 * i + 1] / t) * 8192 + Math.round(e[2 * i] / t) + r;
						e[i] = a & 67108863;
						if (a < 67108864) {
							r = 0;
						} else {
							r = (a / 67108864) | 0;
						}
					}
					return e;
				};
				FFTM.prototype.convert13b = function convert13b(e, t, r, i) {
					var a = 0;
					for (var o = 0; o < t; o++) {
						a = a + (e[o] | 0);
						r[2 * o] = a & 8191;
						a = a >>> 13;
						r[2 * o + 1] = a & 8191;
						a = a >>> 13;
					}
					for (o = 2 * t; o < i; ++o) {
						r[o] = 0;
					}
					assert(a === 0);
					assert((a & ~8191) === 0);
				};
				FFTM.prototype.stub = function stub(e) {
					var t = new Array(e);
					for (var r = 0; r < e; r++) {
						t[r] = 0;
					}
					return t;
				};
				FFTM.prototype.mulp = function mulp(e, t, r) {
					var i = 2 * this.guessLen13b(e.length, t.length);
					var a = this.makeRBT(i);
					var o = this.stub(i);
					var c = new Array(i);
					var u = new Array(i);
					var l = new Array(i);
					var d = new Array(i);
					var p = new Array(i);
					var m = new Array(i);
					var g = r.words;
					g.length = i;
					this.convert13b(e.words, e.length, c, i);
					this.convert13b(t.words, t.length, d, i);
					this.transform(c, o, u, l, i, a);
					this.transform(d, o, p, m, i, a);
					for (var v = 0; v < i; v++) {
						var y = u[v] * p[v] - l[v] * m[v];
						l[v] = u[v] * m[v] + l[v] * p[v];
						u[v] = y;
					}
					this.conjugate(u, l, i);
					this.transform(u, l, g, o, i, a);
					this.conjugate(g, o, i);
					this.normalize13b(g, i);
					r.negative = e.negative ^ t.negative;
					r.length = e.length + t.length;
					return r._strip();
				};
				BN.prototype.mul = function mul(e) {
					var t = new BN(null);
					t.words = new Array(this.length + e.length);
					return this.mulTo(e, t);
				};
				BN.prototype.mulf = function mulf(e) {
					var t = new BN(null);
					t.words = new Array(this.length + e.length);
					return jumboMulTo(this, e, t);
				};
				BN.prototype.imul = function imul(e) {
					return this.clone().mulTo(e, this);
				};
				BN.prototype.imuln = function imuln(e) {
					var t = e < 0;
					if (t) e = -e;
					assert(typeof e === 'number');
					assert(e < 67108864);
					var r = 0;
					for (var i = 0; i < this.length; i++) {
						var a = (this.words[i] | 0) * e;
						var o = (a & 67108863) + (r & 67108863);
						r >>= 26;
						r += (a / 67108864) | 0;
						r += o >>> 26;
						this.words[i] = o & 67108863;
					}
					if (r !== 0) {
						this.words[i] = r;
						this.length++;
					}
					return t ? this.ineg() : this;
				};
				BN.prototype.muln = function muln(e) {
					return this.clone().imuln(e);
				};
				BN.prototype.sqr = function sqr() {
					return this.mul(this);
				};
				BN.prototype.isqr = function isqr() {
					return this.imul(this.clone());
				};
				BN.prototype.pow = function pow(e) {
					var t = toBitArray(e);
					if (t.length === 0) return new BN(1);
					var r = this;
					for (var i = 0; i < t.length; i++, r = r.sqr()) {
						if (t[i] !== 0) break;
					}
					if (++i < t.length) {
						for (var a = r.sqr(); i < t.length; i++, a = a.sqr()) {
							if (t[i] === 0) continue;
							r = r.mul(a);
						}
					}
					return r;
				};
				BN.prototype.iushln = function iushln(e) {
					assert(typeof e === 'number' && e >= 0);
					var t = e % 26;
					var r = (e - t) / 26;
					var i = (67108863 >>> (26 - t)) << (26 - t);
					var a;
					if (t !== 0) {
						var o = 0;
						for (a = 0; a < this.length; a++) {
							var c = this.words[a] & i;
							var u = ((this.words[a] | 0) - c) << t;
							this.words[a] = u | o;
							o = c >>> (26 - t);
						}
						if (o) {
							this.words[a] = o;
							this.length++;
						}
					}
					if (r !== 0) {
						for (a = this.length - 1; a >= 0; a--) {
							this.words[a + r] = this.words[a];
						}
						for (a = 0; a < r; a++) {
							this.words[a] = 0;
						}
						this.length += r;
					}
					return this._strip();
				};
				BN.prototype.ishln = function ishln(e) {
					assert(this.negative === 0);
					return this.iushln(e);
				};
				BN.prototype.iushrn = function iushrn(e, t, r) {
					assert(typeof e === 'number' && e >= 0);
					var i;
					if (t) {
						i = (t - (t % 26)) / 26;
					} else {
						i = 0;
					}
					var a = e % 26;
					var o = Math.min((e - a) / 26, this.length);
					var c = 67108863 ^ ((67108863 >>> a) << a);
					var u = r;
					i -= o;
					i = Math.max(0, i);
					if (u) {
						for (var l = 0; l < o; l++) {
							u.words[l] = this.words[l];
						}
						u.length = o;
					}
					if (o === 0) {
					} else if (this.length > o) {
						this.length -= o;
						for (l = 0; l < this.length; l++) {
							this.words[l] = this.words[l + o];
						}
					} else {
						this.words[0] = 0;
						this.length = 1;
					}
					var d = 0;
					for (l = this.length - 1; l >= 0 && (d !== 0 || l >= i); l--) {
						var p = this.words[l] | 0;
						this.words[l] = (d << (26 - a)) | (p >>> a);
						d = p & c;
					}
					if (u && d !== 0) {
						u.words[u.length++] = d;
					}
					if (this.length === 0) {
						this.words[0] = 0;
						this.length = 1;
					}
					return this._strip();
				};
				BN.prototype.ishrn = function ishrn(e, t, r) {
					assert(this.negative === 0);
					return this.iushrn(e, t, r);
				};
				BN.prototype.shln = function shln(e) {
					return this.clone().ishln(e);
				};
				BN.prototype.ushln = function ushln(e) {
					return this.clone().iushln(e);
				};
				BN.prototype.shrn = function shrn(e) {
					return this.clone().ishrn(e);
				};
				BN.prototype.ushrn = function ushrn(e) {
					return this.clone().iushrn(e);
				};
				BN.prototype.testn = function testn(e) {
					assert(typeof e === 'number' && e >= 0);
					var t = e % 26;
					var r = (e - t) / 26;
					var i = 1 << t;
					if (this.length <= r) return false;
					var a = this.words[r];
					return !!(a & i);
				};
				BN.prototype.imaskn = function imaskn(e) {
					assert(typeof e === 'number' && e >= 0);
					var t = e % 26;
					var r = (e - t) / 26;
					assert(this.negative === 0, 'imaskn works only with positive numbers');
					if (this.length <= r) {
						return this;
					}
					if (t !== 0) {
						r++;
					}
					this.length = Math.min(r, this.length);
					if (t !== 0) {
						var i = 67108863 ^ ((67108863 >>> t) << t);
						this.words[this.length - 1] &= i;
					}
					return this._strip();
				};
				BN.prototype.maskn = function maskn(e) {
					return this.clone().imaskn(e);
				};
				BN.prototype.iaddn = function iaddn(e) {
					assert(typeof e === 'number');
					assert(e < 67108864);
					if (e < 0) return this.isubn(-e);
					if (this.negative !== 0) {
						if (this.length === 1 && (this.words[0] | 0) <= e) {
							this.words[0] = e - (this.words[0] | 0);
							this.negative = 0;
							return this;
						}
						this.negative = 0;
						this.isubn(e);
						this.negative = 1;
						return this;
					}
					return this._iaddn(e);
				};
				BN.prototype._iaddn = function _iaddn(e) {
					this.words[0] += e;
					for (var t = 0; t < this.length && this.words[t] >= 67108864; t++) {
						this.words[t] -= 67108864;
						if (t === this.length - 1) {
							this.words[t + 1] = 1;
						} else {
							this.words[t + 1]++;
						}
					}
					this.length = Math.max(this.length, t + 1);
					return this;
				};
				BN.prototype.isubn = function isubn(e) {
					assert(typeof e === 'number');
					assert(e < 67108864);
					if (e < 0) return this.iaddn(-e);
					if (this.negative !== 0) {
						this.negative = 0;
						this.iaddn(e);
						this.negative = 1;
						return this;
					}
					this.words[0] -= e;
					if (this.length === 1 && this.words[0] < 0) {
						this.words[0] = -this.words[0];
						this.negative = 1;
					} else {
						for (var t = 0; t < this.length && this.words[t] < 0; t++) {
							this.words[t] += 67108864;
							this.words[t + 1] -= 1;
						}
					}
					return this._strip();
				};
				BN.prototype.addn = function addn(e) {
					return this.clone().iaddn(e);
				};
				BN.prototype.subn = function subn(e) {
					return this.clone().isubn(e);
				};
				BN.prototype.iabs = function iabs() {
					this.negative = 0;
					return this;
				};
				BN.prototype.abs = function abs() {
					return this.clone().iabs();
				};
				BN.prototype._ishlnsubmul = function _ishlnsubmul(e, t, r) {
					var i = e.length + r;
					var a;
					this._expand(i);
					var o;
					var c = 0;
					for (a = 0; a < e.length; a++) {
						o = (this.words[a + r] | 0) + c;
						var u = (e.words[a] | 0) * t;
						o -= u & 67108863;
						c = (o >> 26) - ((u / 67108864) | 0);
						this.words[a + r] = o & 67108863;
					}
					for (; a < this.length - r; a++) {
						o = (this.words[a + r] | 0) + c;
						c = o >> 26;
						this.words[a + r] = o & 67108863;
					}
					if (c === 0) return this._strip();
					assert(c === -1);
					c = 0;
					for (a = 0; a < this.length; a++) {
						o = -(this.words[a] | 0) + c;
						c = o >> 26;
						this.words[a] = o & 67108863;
					}
					this.negative = 1;
					return this._strip();
				};
				BN.prototype._wordDiv = function _wordDiv(e, t) {
					var r = this.length - e.length;
					var i = this.clone();
					var a = e;
					var o = a.words[a.length - 1] | 0;
					var c = this._countBits(o);
					r = 26 - c;
					if (r !== 0) {
						a = a.ushln(r);
						i.iushln(r);
						o = a.words[a.length - 1] | 0;
					}
					var u = i.length - a.length;
					var l;
					if (t !== 'mod') {
						l = new BN(null);
						l.length = u + 1;
						l.words = new Array(l.length);
						for (var d = 0; d < l.length; d++) {
							l.words[d] = 0;
						}
					}
					var p = i.clone()._ishlnsubmul(a, 1, u);
					if (p.negative === 0) {
						i = p;
						if (l) {
							l.words[u] = 1;
						}
					}
					for (var m = u - 1; m >= 0; m--) {
						var g = (i.words[a.length + m] | 0) * 67108864 + (i.words[a.length + m - 1] | 0);
						g = Math.min((g / o) | 0, 67108863);
						i._ishlnsubmul(a, g, m);
						while (i.negative !== 0) {
							g--;
							i.negative = 0;
							i._ishlnsubmul(a, 1, m);
							if (!i.isZero()) {
								i.negative ^= 1;
							}
						}
						if (l) {
							l.words[m] = g;
						}
					}
					if (l) {
						l._strip();
					}
					i._strip();
					if (t !== 'div' && r !== 0) {
						i.iushrn(r);
					}
					return { div: l || null, mod: i };
				};
				BN.prototype.divmod = function divmod(e, t, r) {
					assert(!e.isZero());
					if (this.isZero()) {
						return { div: new BN(0), mod: new BN(0) };
					}
					var i, a, o;
					if (this.negative !== 0 && e.negative === 0) {
						o = this.neg().divmod(e, t);
						if (t !== 'mod') {
							i = o.div.neg();
						}
						if (t !== 'div') {
							a = o.mod.neg();
							if (r && a.negative !== 0) {
								a.iadd(e);
							}
						}
						return { div: i, mod: a };
					}
					if (this.negative === 0 && e.negative !== 0) {
						o = this.divmod(e.neg(), t);
						if (t !== 'mod') {
							i = o.div.neg();
						}
						return { div: i, mod: o.mod };
					}
					if ((this.negative & e.negative) !== 0) {
						o = this.neg().divmod(e.neg(), t);
						if (t !== 'div') {
							a = o.mod.neg();
							if (r && a.negative !== 0) {
								a.isub(e);
							}
						}
						return { div: o.div, mod: a };
					}
					if (e.length > this.length || this.cmp(e) < 0) {
						return { div: new BN(0), mod: this };
					}
					if (e.length === 1) {
						if (t === 'div') {
							return { div: this.divn(e.words[0]), mod: null };
						}
						if (t === 'mod') {
							return { div: null, mod: new BN(this.modrn(e.words[0])) };
						}
						return { div: this.divn(e.words[0]), mod: new BN(this.modrn(e.words[0])) };
					}
					return this._wordDiv(e, t);
				};
				BN.prototype.div = function div(e) {
					return this.divmod(e, 'div', false).div;
				};
				BN.prototype.mod = function mod(e) {
					return this.divmod(e, 'mod', false).mod;
				};
				BN.prototype.umod = function umod(e) {
					return this.divmod(e, 'mod', true).mod;
				};
				BN.prototype.divRound = function divRound(e) {
					var t = this.divmod(e);
					if (t.mod.isZero()) return t.div;
					var r = t.div.negative !== 0 ? t.mod.isub(e) : t.mod;
					var i = e.ushrn(1);
					var a = e.andln(1);
					var o = r.cmp(i);
					if (o < 0 || (a === 1 && o === 0)) return t.div;
					return t.div.negative !== 0 ? t.div.isubn(1) : t.div.iaddn(1);
				};
				BN.prototype.modrn = function modrn(e) {
					var t = e < 0;
					if (t) e = -e;
					assert(e <= 67108863);
					var r = (1 << 26) % e;
					var i = 0;
					for (var a = this.length - 1; a >= 0; a--) {
						i = (r * i + (this.words[a] | 0)) % e;
					}
					return t ? -i : i;
				};
				BN.prototype.modn = function modn(e) {
					return this.modrn(e);
				};
				BN.prototype.idivn = function idivn(e) {
					var t = e < 0;
					if (t) e = -e;
					assert(e <= 67108863);
					var r = 0;
					for (var i = this.length - 1; i >= 0; i--) {
						var a = (this.words[i] | 0) + r * 67108864;
						this.words[i] = (a / e) | 0;
						r = a % e;
					}
					this._strip();
					return t ? this.ineg() : this;
				};
				BN.prototype.divn = function divn(e) {
					return this.clone().idivn(e);
				};
				BN.prototype.egcd = function egcd(e) {
					assert(e.negative === 0);
					assert(!e.isZero());
					var t = this;
					var r = e.clone();
					if (t.negative !== 0) {
						t = t.umod(e);
					} else {
						t = t.clone();
					}
					var i = new BN(1);
					var a = new BN(0);
					var o = new BN(0);
					var c = new BN(1);
					var u = 0;
					while (t.isEven() && r.isEven()) {
						t.iushrn(1);
						r.iushrn(1);
						++u;
					}
					var l = r.clone();
					var d = t.clone();
					while (!t.isZero()) {
						for (var p = 0, m = 1; (t.words[0] & m) === 0 && p < 26; ++p, m <<= 1);
						if (p > 0) {
							t.iushrn(p);
							while (p-- > 0) {
								if (i.isOdd() || a.isOdd()) {
									i.iadd(l);
									a.isub(d);
								}
								i.iushrn(1);
								a.iushrn(1);
							}
						}
						for (var g = 0, v = 1; (r.words[0] & v) === 0 && g < 26; ++g, v <<= 1);
						if (g > 0) {
							r.iushrn(g);
							while (g-- > 0) {
								if (o.isOdd() || c.isOdd()) {
									o.iadd(l);
									c.isub(d);
								}
								o.iushrn(1);
								c.iushrn(1);
							}
						}
						if (t.cmp(r) >= 0) {
							t.isub(r);
							i.isub(o);
							a.isub(c);
						} else {
							r.isub(t);
							o.isub(i);
							c.isub(a);
						}
					}
					return { a: o, b: c, gcd: r.iushln(u) };
				};
				BN.prototype._invmp = function _invmp(e) {
					assert(e.negative === 0);
					assert(!e.isZero());
					var t = this;
					var r = e.clone();
					if (t.negative !== 0) {
						t = t.umod(e);
					} else {
						t = t.clone();
					}
					var i = new BN(1);
					var a = new BN(0);
					var o = r.clone();
					while (t.cmpn(1) > 0 && r.cmpn(1) > 0) {
						for (var c = 0, u = 1; (t.words[0] & u) === 0 && c < 26; ++c, u <<= 1);
						if (c > 0) {
							t.iushrn(c);
							while (c-- > 0) {
								if (i.isOdd()) {
									i.iadd(o);
								}
								i.iushrn(1);
							}
						}
						for (var l = 0, d = 1; (r.words[0] & d) === 0 && l < 26; ++l, d <<= 1);
						if (l > 0) {
							r.iushrn(l);
							while (l-- > 0) {
								if (a.isOdd()) {
									a.iadd(o);
								}
								a.iushrn(1);
							}
						}
						if (t.cmp(r) >= 0) {
							t.isub(r);
							i.isub(a);
						} else {
							r.isub(t);
							a.isub(i);
						}
					}
					var p;
					if (t.cmpn(1) === 0) {
						p = i;
					} else {
						p = a;
					}
					if (p.cmpn(0) < 0) {
						p.iadd(e);
					}
					return p;
				};
				BN.prototype.gcd = function gcd(e) {
					if (this.isZero()) return e.abs();
					if (e.isZero()) return this.abs();
					var t = this.clone();
					var r = e.clone();
					t.negative = 0;
					r.negative = 0;
					for (var i = 0; t.isEven() && r.isEven(); i++) {
						t.iushrn(1);
						r.iushrn(1);
					}
					do {
						while (t.isEven()) {
							t.iushrn(1);
						}
						while (r.isEven()) {
							r.iushrn(1);
						}
						var a = t.cmp(r);
						if (a < 0) {
							var o = t;
							t = r;
							r = o;
						} else if (a === 0 || r.cmpn(1) === 0) {
							break;
						}
						t.isub(r);
					} while (true);
					return r.iushln(i);
				};
				BN.prototype.invm = function invm(e) {
					return this.egcd(e).a.umod(e);
				};
				BN.prototype.isEven = function isEven() {
					return (this.words[0] & 1) === 0;
				};
				BN.prototype.isOdd = function isOdd() {
					return (this.words[0] & 1) === 1;
				};
				BN.prototype.andln = function andln(e) {
					return this.words[0] & e;
				};
				BN.prototype.bincn = function bincn(e) {
					assert(typeof e === 'number');
					var t = e % 26;
					var r = (e - t) / 26;
					var i = 1 << t;
					if (this.length <= r) {
						this._expand(r + 1);
						this.words[r] |= i;
						return this;
					}
					var a = i;
					for (var o = r; a !== 0 && o < this.length; o++) {
						var c = this.words[o] | 0;
						c += a;
						a = c >>> 26;
						c &= 67108863;
						this.words[o] = c;
					}
					if (a !== 0) {
						this.words[o] = a;
						this.length++;
					}
					return this;
				};
				BN.prototype.isZero = function isZero() {
					return this.length === 1 && this.words[0] === 0;
				};
				BN.prototype.cmpn = function cmpn(e) {
					var t = e < 0;
					if (this.negative !== 0 && !t) return -1;
					if (this.negative === 0 && t) return 1;
					this._strip();
					var r;
					if (this.length > 1) {
						r = 1;
					} else {
						if (t) {
							e = -e;
						}
						assert(e <= 67108863, 'Number is too big');
						var i = this.words[0] | 0;
						r = i === e ? 0 : i < e ? -1 : 1;
					}
					if (this.negative !== 0) return -r | 0;
					return r;
				};
				BN.prototype.cmp = function cmp(e) {
					if (this.negative !== 0 && e.negative === 0) return -1;
					if (this.negative === 0 && e.negative !== 0) return 1;
					var t = this.ucmp(e);
					if (this.negative !== 0) return -t | 0;
					return t;
				};
				BN.prototype.ucmp = function ucmp(e) {
					if (this.length > e.length) return 1;
					if (this.length < e.length) return -1;
					var t = 0;
					for (var r = this.length - 1; r >= 0; r--) {
						var i = this.words[r] | 0;
						var a = e.words[r] | 0;
						if (i === a) continue;
						if (i < a) {
							t = -1;
						} else if (i > a) {
							t = 1;
						}
						break;
					}
					return t;
				};
				BN.prototype.gtn = function gtn(e) {
					return this.cmpn(e) === 1;
				};
				BN.prototype.gt = function gt(e) {
					return this.cmp(e) === 1;
				};
				BN.prototype.gten = function gten(e) {
					return this.cmpn(e) >= 0;
				};
				BN.prototype.gte = function gte(e) {
					return this.cmp(e) >= 0;
				};
				BN.prototype.ltn = function ltn(e) {
					return this.cmpn(e) === -1;
				};
				BN.prototype.lt = function lt(e) {
					return this.cmp(e) === -1;
				};
				BN.prototype.lten = function lten(e) {
					return this.cmpn(e) <= 0;
				};
				BN.prototype.lte = function lte(e) {
					return this.cmp(e) <= 0;
				};
				BN.prototype.eqn = function eqn(e) {
					return this.cmpn(e) === 0;
				};
				BN.prototype.eq = function eq(e) {
					return this.cmp(e) === 0;
				};
				BN.red = function red(e) {
					return new Red(e);
				};
				BN.prototype.toRed = function toRed(e) {
					assert(!this.red, 'Already a number in reduction context');
					assert(this.negative === 0, 'red works only with positives');
					return e.convertTo(this)._forceRed(e);
				};
				BN.prototype.fromRed = function fromRed() {
					assert(this.red, 'fromRed works only with numbers in reduction context');
					return this.red.convertFrom(this);
				};
				BN.prototype._forceRed = function _forceRed(e) {
					this.red = e;
					return this;
				};
				BN.prototype.forceRed = function forceRed(e) {
					assert(!this.red, 'Already a number in reduction context');
					return this._forceRed(e);
				};
				BN.prototype.redAdd = function redAdd(e) {
					assert(this.red, 'redAdd works only with red numbers');
					return this.red.add(this, e);
				};
				BN.prototype.redIAdd = function redIAdd(e) {
					assert(this.red, 'redIAdd works only with red numbers');
					return this.red.iadd(this, e);
				};
				BN.prototype.redSub = function redSub(e) {
					assert(this.red, 'redSub works only with red numbers');
					return this.red.sub(this, e);
				};
				BN.prototype.redISub = function redISub(e) {
					assert(this.red, 'redISub works only with red numbers');
					return this.red.isub(this, e);
				};
				BN.prototype.redShl = function redShl(e) {
					assert(this.red, 'redShl works only with red numbers');
					return this.red.shl(this, e);
				};
				BN.prototype.redMul = function redMul(e) {
					assert(this.red, 'redMul works only with red numbers');
					this.red._verify2(this, e);
					return this.red.mul(this, e);
				};
				BN.prototype.redIMul = function redIMul(e) {
					assert(this.red, 'redMul works only with red numbers');
					this.red._verify2(this, e);
					return this.red.imul(this, e);
				};
				BN.prototype.redSqr = function redSqr() {
					assert(this.red, 'redSqr works only with red numbers');
					this.red._verify1(this);
					return this.red.sqr(this);
				};
				BN.prototype.redISqr = function redISqr() {
					assert(this.red, 'redISqr works only with red numbers');
					this.red._verify1(this);
					return this.red.isqr(this);
				};
				BN.prototype.redSqrt = function redSqrt() {
					assert(this.red, 'redSqrt works only with red numbers');
					this.red._verify1(this);
					return this.red.sqrt(this);
				};
				BN.prototype.redInvm = function redInvm() {
					assert(this.red, 'redInvm works only with red numbers');
					this.red._verify1(this);
					return this.red.invm(this);
				};
				BN.prototype.redNeg = function redNeg() {
					assert(this.red, 'redNeg works only with red numbers');
					this.red._verify1(this);
					return this.red.neg(this);
				};
				BN.prototype.redPow = function redPow(e) {
					assert(this.red && !e.red, 'redPow(normalNum)');
					this.red._verify1(this);
					return this.red.pow(this, e);
				};
				var d = { k256: null, p224: null, p192: null, p25519: null };
				function MPrime(e, t) {
					this.name = e;
					this.p = new BN(t, 16);
					this.n = this.p.bitLength();
					this.k = new BN(1).iushln(this.n).isub(this.p);
					this.tmp = this._tmp();
				}
				MPrime.prototype._tmp = function _tmp() {
					var e = new BN(null);
					e.words = new Array(Math.ceil(this.n / 13));
					return e;
				};
				MPrime.prototype.ireduce = function ireduce(e) {
					var t = e;
					var r;
					do {
						this.split(t, this.tmp);
						t = this.imulK(t);
						t = t.iadd(this.tmp);
						r = t.bitLength();
					} while (r > this.n);
					var i = r < this.n ? -1 : t.ucmp(this.p);
					if (i === 0) {
						t.words[0] = 0;
						t.length = 1;
					} else if (i > 0) {
						t.isub(this.p);
					} else {
						if (t.strip !== undefined) {
							t.strip();
						} else {
							t._strip();
						}
					}
					return t;
				};
				MPrime.prototype.split = function split(e, t) {
					e.iushrn(this.n, 0, t);
				};
				MPrime.prototype.imulK = function imulK(e) {
					return e.imul(this.k);
				};
				function K256() {
					MPrime.call(
						this,
						'k256',
						'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f'
					);
				}
				inherits(K256, MPrime);
				K256.prototype.split = function split(e, t) {
					var r = 4194303;
					var i = Math.min(e.length, 9);
					for (var a = 0; a < i; a++) {
						t.words[a] = e.words[a];
					}
					t.length = i;
					if (e.length <= 9) {
						e.words[0] = 0;
						e.length = 1;
						return;
					}
					var o = e.words[9];
					t.words[t.length++] = o & r;
					for (a = 10; a < e.length; a++) {
						var c = e.words[a] | 0;
						e.words[a - 10] = ((c & r) << 4) | (o >>> 22);
						o = c;
					}
					o >>>= 22;
					e.words[a - 10] = o;
					if (o === 0 && e.length > 10) {
						e.length -= 10;
					} else {
						e.length -= 9;
					}
				};
				K256.prototype.imulK = function imulK(e) {
					e.words[e.length] = 0;
					e.words[e.length + 1] = 0;
					e.length += 2;
					var t = 0;
					for (var r = 0; r < e.length; r++) {
						var i = e.words[r] | 0;
						t += i * 977;
						e.words[r] = t & 67108863;
						t = i * 64 + ((t / 67108864) | 0);
					}
					if (e.words[e.length - 1] === 0) {
						e.length--;
						if (e.words[e.length - 1] === 0) {
							e.length--;
						}
					}
					return e;
				};
				function P224() {
					MPrime.call(
						this,
						'p224',
						'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001'
					);
				}
				inherits(P224, MPrime);
				function P192() {
					MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
				}
				inherits(P192, MPrime);
				function P25519() {
					MPrime.call(
						this,
						'25519',
						'7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed'
					);
				}
				inherits(P25519, MPrime);
				P25519.prototype.imulK = function imulK(e) {
					var t = 0;
					for (var r = 0; r < e.length; r++) {
						var i = (e.words[r] | 0) * 19 + t;
						var a = i & 67108863;
						i >>>= 26;
						e.words[r] = a;
						t = i;
					}
					if (t !== 0) {
						e.words[e.length++] = t;
					}
					return e;
				};
				BN._prime = function prime(e) {
					if (d[e]) return d[e];
					var prime;
					if (e === 'k256') {
						prime = new K256();
					} else if (e === 'p224') {
						prime = new P224();
					} else if (e === 'p192') {
						prime = new P192();
					} else if (e === 'p25519') {
						prime = new P25519();
					} else {
						throw new Error('Unknown prime ' + e);
					}
					d[e] = prime;
					return prime;
				};
				function Red(e) {
					if (typeof e === 'string') {
						var t = BN._prime(e);
						this.m = t.p;
						this.prime = t;
					} else {
						assert(e.gtn(1), 'modulus must be greater than 1');
						this.m = e;
						this.prime = null;
					}
				}
				Red.prototype._verify1 = function _verify1(e) {
					assert(e.negative === 0, 'red works only with positives');
					assert(e.red, 'red works only with red numbers');
				};
				Red.prototype._verify2 = function _verify2(e, t) {
					assert((e.negative | t.negative) === 0, 'red works only with positives');
					assert(e.red && e.red === t.red, 'red works only with red numbers');
				};
				Red.prototype.imod = function imod(e) {
					if (this.prime) return this.prime.ireduce(e)._forceRed(this);
					move(e, e.umod(this.m)._forceRed(this));
					return e;
				};
				Red.prototype.neg = function neg(e) {
					if (e.isZero()) {
						return e.clone();
					}
					return this.m.sub(e)._forceRed(this);
				};
				Red.prototype.add = function add(e, t) {
					this._verify2(e, t);
					var r = e.add(t);
					if (r.cmp(this.m) >= 0) {
						r.isub(this.m);
					}
					return r._forceRed(this);
				};
				Red.prototype.iadd = function iadd(e, t) {
					this._verify2(e, t);
					var r = e.iadd(t);
					if (r.cmp(this.m) >= 0) {
						r.isub(this.m);
					}
					return r;
				};
				Red.prototype.sub = function sub(e, t) {
					this._verify2(e, t);
					var r = e.sub(t);
					if (r.cmpn(0) < 0) {
						r.iadd(this.m);
					}
					return r._forceRed(this);
				};
				Red.prototype.isub = function isub(e, t) {
					this._verify2(e, t);
					var r = e.isub(t);
					if (r.cmpn(0) < 0) {
						r.iadd(this.m);
					}
					return r;
				};
				Red.prototype.shl = function shl(e, t) {
					this._verify1(e);
					return this.imod(e.ushln(t));
				};
				Red.prototype.imul = function imul(e, t) {
					this._verify2(e, t);
					return this.imod(e.imul(t));
				};
				Red.prototype.mul = function mul(e, t) {
					this._verify2(e, t);
					return this.imod(e.mul(t));
				};
				Red.prototype.isqr = function isqr(e) {
					return this.imul(e, e.clone());
				};
				Red.prototype.sqr = function sqr(e) {
					return this.mul(e, e);
				};
				Red.prototype.sqrt = function sqrt(e) {
					if (e.isZero()) return e.clone();
					var t = this.m.andln(3);
					assert(t % 2 === 1);
					if (t === 3) {
						var r = this.m.add(new BN(1)).iushrn(2);
						return this.pow(e, r);
					}
					var i = this.m.subn(1);
					var a = 0;
					while (!i.isZero() && i.andln(1) === 0) {
						a++;
						i.iushrn(1);
					}
					assert(!i.isZero());
					var o = new BN(1).toRed(this);
					var c = o.redNeg();
					var u = this.m.subn(1).iushrn(1);
					var l = this.m.bitLength();
					l = new BN(2 * l * l).toRed(this);
					while (this.pow(l, u).cmp(c) !== 0) {
						l.redIAdd(c);
					}
					var d = this.pow(l, i);
					var p = this.pow(e, i.addn(1).iushrn(1));
					var m = this.pow(e, i);
					var g = a;
					while (m.cmp(o) !== 0) {
						var v = m;
						for (var y = 0; v.cmp(o) !== 0; y++) {
							v = v.redSqr();
						}
						assert(y < g);
						var w = this.pow(d, new BN(1).iushln(g - y - 1));
						p = p.redMul(w);
						d = w.redSqr();
						m = m.redMul(d);
						g = y;
					}
					return p;
				};
				Red.prototype.invm = function invm(e) {
					var t = e._invmp(this.m);
					if (t.negative !== 0) {
						t.negative = 0;
						return this.imod(t).redNeg();
					} else {
						return this.imod(t);
					}
				};
				Red.prototype.pow = function pow(e, t) {
					if (t.isZero()) return new BN(1).toRed(this);
					if (t.cmpn(1) === 0) return e.clone();
					var r = 4;
					var i = new Array(1 << r);
					i[0] = new BN(1).toRed(this);
					i[1] = e;
					for (var a = 2; a < i.length; a++) {
						i[a] = this.mul(i[a - 1], e);
					}
					var o = i[0];
					var c = 0;
					var u = 0;
					var l = t.bitLength() % 26;
					if (l === 0) {
						l = 26;
					}
					for (a = t.length - 1; a >= 0; a--) {
						var d = t.words[a];
						for (var p = l - 1; p >= 0; p--) {
							var m = (d >> p) & 1;
							if (o !== i[0]) {
								o = this.sqr(o);
							}
							if (m === 0 && c === 0) {
								u = 0;
								continue;
							}
							c <<= 1;
							c |= m;
							u++;
							if (u !== r && (a !== 0 || p !== 0)) continue;
							o = this.mul(o, i[c]);
							u = 0;
							c = 0;
						}
						l = 26;
					}
					return o;
				};
				Red.prototype.convertTo = function convertTo(e) {
					var t = e.umod(this.m);
					return t === e ? t.clone() : t;
				};
				Red.prototype.convertFrom = function convertFrom(e) {
					var t = e.clone();
					t.red = null;
					return t;
				};
				BN.mont = function mont(e) {
					return new Mont(e);
				};
				function Mont(e) {
					Red.call(this, e);
					this.shift = this.m.bitLength();
					if (this.shift % 26 !== 0) {
						this.shift += 26 - (this.shift % 26);
					}
					this.r = new BN(1).iushln(this.shift);
					this.r2 = this.imod(this.r.sqr());
					this.rinv = this.r._invmp(this.m);
					this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
					this.minv = this.minv.umod(this.r);
					this.minv = this.r.sub(this.minv);
				}
				inherits(Mont, Red);
				Mont.prototype.convertTo = function convertTo(e) {
					return this.imod(e.ushln(this.shift));
				};
				Mont.prototype.convertFrom = function convertFrom(e) {
					var t = this.imod(e.mul(this.rinv));
					t.red = null;
					return t;
				};
				Mont.prototype.imul = function imul(e, t) {
					if (e.isZero() || t.isZero()) {
						e.words[0] = 0;
						e.length = 1;
						return e;
					}
					var r = e.imul(t);
					var i = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
					var a = r.isub(i).iushrn(this.shift);
					var o = a;
					if (a.cmp(this.m) >= 0) {
						o = a.isub(this.m);
					} else if (a.cmpn(0) < 0) {
						o = a.iadd(this.m);
					}
					return o._forceRed(this);
				};
				Mont.prototype.mul = function mul(e, t) {
					if (e.isZero() || t.isZero()) return new BN(0)._forceRed(this);
					var r = e.mul(t);
					var i = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
					var a = r.isub(i).iushrn(this.shift);
					var o = a;
					if (a.cmp(this.m) >= 0) {
						o = a.isub(this.m);
					} else if (a.cmpn(0) < 0) {
						o = a.iadd(this.m);
					}
					return o._forceRed(this);
				};
				Mont.prototype.invm = function invm(e) {
					var t = this.imod(e._invmp(this.m).mul(this.r2));
					return t._forceRed(this);
				};
			})(false || e, this);
		},
		5442: (e, t, r) => {
			var i;
			e.exports = function rand(e) {
				if (!i) i = new Rand(null);
				return i.generate(e);
			};
			function Rand(e) {
				this.rand = e;
			}
			e.exports.Rand = Rand;
			Rand.prototype.generate = function generate(e) {
				return this._rand(e);
			};
			Rand.prototype._rand = function _rand(e) {
				if (this.rand.getBytes) return this.rand.getBytes(e);
				var t = new Uint8Array(e);
				for (var r = 0; r < t.length; r++) t[r] = this.rand.getByte();
				return t;
			};
			if (typeof self === 'object') {
				if (self.crypto && self.crypto.getRandomValues) {
					Rand.prototype._rand = function _rand(e) {
						var t = new Uint8Array(e);
						self.crypto.getRandomValues(t);
						return t;
					};
				} else if (self.msCrypto && self.msCrypto.getRandomValues) {
					Rand.prototype._rand = function _rand(e) {
						var t = new Uint8Array(e);
						self.msCrypto.getRandomValues(t);
						return t;
					};
				} else if (typeof window === 'object') {
					Rand.prototype._rand = function () {
						throw new Error('Not implemented yet');
					};
				}
			} else {
				try {
					var a = r(4507);
					if (typeof a.randomBytes !== 'function') throw new Error('Not supported');
					Rand.prototype._rand = function _rand(e) {
						return a.randomBytes(e);
					};
				} catch (e) {}
			}
		},
		7088: (e, t, r) => {
			var i = r(6608).Buffer;
			function asUInt32Array(e) {
				if (!i.isBuffer(e)) e = i.from(e);
				var t = (e.length / 4) | 0;
				var r = new Array(t);
				for (var a = 0; a < t; a++) {
					r[a] = e.readUInt32BE(a * 4);
				}
				return r;
			}
			function scrubVec(e) {
				for (var t = 0; t < e.length; e++) {
					e[t] = 0;
				}
			}
			function cryptBlock(e, t, r, i, a) {
				var o = r[0];
				var c = r[1];
				var u = r[2];
				var l = r[3];
				var d = e[0] ^ t[0];
				var p = e[1] ^ t[1];
				var m = e[2] ^ t[2];
				var g = e[3] ^ t[3];
				var v, y, w, _;
				var A = 4;
				for (var k = 1; k < a; k++) {
					v = o[d >>> 24] ^ c[(p >>> 16) & 255] ^ u[(m >>> 8) & 255] ^ l[g & 255] ^ t[A++];
					y = o[p >>> 24] ^ c[(m >>> 16) & 255] ^ u[(g >>> 8) & 255] ^ l[d & 255] ^ t[A++];
					w = o[m >>> 24] ^ c[(g >>> 16) & 255] ^ u[(d >>> 8) & 255] ^ l[p & 255] ^ t[A++];
					_ = o[g >>> 24] ^ c[(d >>> 16) & 255] ^ u[(p >>> 8) & 255] ^ l[m & 255] ^ t[A++];
					d = v;
					p = y;
					m = w;
					g = _;
				}
				v =
					((i[d >>> 24] << 24) |
						(i[(p >>> 16) & 255] << 16) |
						(i[(m >>> 8) & 255] << 8) |
						i[g & 255]) ^
					t[A++];
				y =
					((i[p >>> 24] << 24) |
						(i[(m >>> 16) & 255] << 16) |
						(i[(g >>> 8) & 255] << 8) |
						i[d & 255]) ^
					t[A++];
				w =
					((i[m >>> 24] << 24) |
						(i[(g >>> 16) & 255] << 16) |
						(i[(d >>> 8) & 255] << 8) |
						i[p & 255]) ^
					t[A++];
				_ =
					((i[g >>> 24] << 24) |
						(i[(d >>> 16) & 255] << 16) |
						(i[(p >>> 8) & 255] << 8) |
						i[m & 255]) ^
					t[A++];
				v = v >>> 0;
				y = y >>> 0;
				w = w >>> 0;
				_ = _ >>> 0;
				return [v, y, w, _];
			}
			var a = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
			var o = (function () {
				var e = new Array(256);
				for (var t = 0; t < 256; t++) {
					if (t < 128) {
						e[t] = t << 1;
					} else {
						e[t] = (t << 1) ^ 283;
					}
				}
				var r = [];
				var i = [];
				var a = [[], [], [], []];
				var o = [[], [], [], []];
				var c = 0;
				var u = 0;
				for (var l = 0; l < 256; ++l) {
					var d = u ^ (u << 1) ^ (u << 2) ^ (u << 3) ^ (u << 4);
					d = (d >>> 8) ^ (d & 255) ^ 99;
					r[c] = d;
					i[d] = c;
					var p = e[c];
					var m = e[p];
					var g = e[m];
					var v = (e[d] * 257) ^ (d * 16843008);
					a[0][c] = (v << 24) | (v >>> 8);
					a[1][c] = (v << 16) | (v >>> 16);
					a[2][c] = (v << 8) | (v >>> 24);
					a[3][c] = v;
					v = (g * 16843009) ^ (m * 65537) ^ (p * 257) ^ (c * 16843008);
					o[0][d] = (v << 24) | (v >>> 8);
					o[1][d] = (v << 16) | (v >>> 16);
					o[2][d] = (v << 8) | (v >>> 24);
					o[3][d] = v;
					if (c === 0) {
						c = u = 1;
					} else {
						c = p ^ e[e[e[g ^ p]]];
						u ^= e[e[u]];
					}
				}
				return { SBOX: r, INV_SBOX: i, SUB_MIX: a, INV_SUB_MIX: o };
			})();
			function AES(e) {
				this._key = asUInt32Array(e);
				this._reset();
			}
			AES.blockSize = 4 * 4;
			AES.keySize = 256 / 8;
			AES.prototype.blockSize = AES.blockSize;
			AES.prototype.keySize = AES.keySize;
			AES.prototype._reset = function () {
				var e = this._key;
				var t = e.length;
				var r = t + 6;
				var i = (r + 1) * 4;
				var c = [];
				for (var u = 0; u < t; u++) {
					c[u] = e[u];
				}
				for (u = t; u < i; u++) {
					var l = c[u - 1];
					if (u % t === 0) {
						l = (l << 8) | (l >>> 24);
						l =
							(o.SBOX[l >>> 24] << 24) |
							(o.SBOX[(l >>> 16) & 255] << 16) |
							(o.SBOX[(l >>> 8) & 255] << 8) |
							o.SBOX[l & 255];
						l ^= a[(u / t) | 0] << 24;
					} else if (t > 6 && u % t === 4) {
						l =
							(o.SBOX[l >>> 24] << 24) |
							(o.SBOX[(l >>> 16) & 255] << 16) |
							(o.SBOX[(l >>> 8) & 255] << 8) |
							o.SBOX[l & 255];
					}
					c[u] = c[u - t] ^ l;
				}
				var d = [];
				for (var p = 0; p < i; p++) {
					var m = i - p;
					var g = c[m - (p % 4 ? 0 : 4)];
					if (p < 4 || m <= 4) {
						d[p] = g;
					} else {
						d[p] =
							o.INV_SUB_MIX[0][o.SBOX[g >>> 24]] ^
							o.INV_SUB_MIX[1][o.SBOX[(g >>> 16) & 255]] ^
							o.INV_SUB_MIX[2][o.SBOX[(g >>> 8) & 255]] ^
							o.INV_SUB_MIX[3][o.SBOX[g & 255]];
					}
				}
				this._nRounds = r;
				this._keySchedule = c;
				this._invKeySchedule = d;
			};
			AES.prototype.encryptBlockRaw = function (e) {
				e = asUInt32Array(e);
				return cryptBlock(e, this._keySchedule, o.SUB_MIX, o.SBOX, this._nRounds);
			};
			AES.prototype.encryptBlock = function (e) {
				var t = this.encryptBlockRaw(e);
				var r = i.allocUnsafe(16);
				r.writeUInt32BE(t[0], 0);
				r.writeUInt32BE(t[1], 4);
				r.writeUInt32BE(t[2], 8);
				r.writeUInt32BE(t[3], 12);
				return r;
			};
			AES.prototype.decryptBlock = function (e) {
				e = asUInt32Array(e);
				var t = e[1];
				e[1] = e[3];
				e[3] = t;
				var r = cryptBlock(e, this._invKeySchedule, o.INV_SUB_MIX, o.INV_SBOX, this._nRounds);
				var a = i.allocUnsafe(16);
				a.writeUInt32BE(r[0], 0);
				a.writeUInt32BE(r[3], 4);
				a.writeUInt32BE(r[2], 8);
				a.writeUInt32BE(r[1], 12);
				return a;
			};
			AES.prototype.scrub = function () {
				scrubVec(this._keySchedule);
				scrubVec(this._invKeySchedule);
				scrubVec(this._key);
			};
			e.exports.AES = AES;
		},
		8182: (e, t, r) => {
			var i = r(7088);
			var a = r(6608).Buffer;
			var o = r(8639);
			var c = r(1193);
			var u = r(50);
			var l = r(460);
			var d = r(6696);
			function xorTest(e, t) {
				var r = 0;
				if (e.length !== t.length) r++;
				var i = Math.min(e.length, t.length);
				for (var a = 0; a < i; ++a) {
					r += e[a] ^ t[a];
				}
				return r;
			}
			function calcIv(e, t, r) {
				if (t.length === 12) {
					e._finID = a.concat([t, a.from([0, 0, 0, 1])]);
					return a.concat([t, a.from([0, 0, 0, 2])]);
				}
				var i = new u(r);
				var o = t.length;
				var c = o % 16;
				i.update(t);
				if (c) {
					c = 16 - c;
					i.update(a.alloc(c, 0));
				}
				i.update(a.alloc(8, 0));
				var l = o * 8;
				var p = a.alloc(8);
				p.writeUIntBE(l, 0, 8);
				i.update(p);
				e._finID = i.state;
				var m = a.from(e._finID);
				d(m);
				return m;
			}
			function StreamCipher(e, t, r, c) {
				o.call(this);
				var l = a.alloc(4, 0);
				this._cipher = new i.AES(t);
				var d = this._cipher.encryptBlock(l);
				this._ghash = new u(d);
				r = calcIv(this, r, d);
				this._prev = a.from(r);
				this._cache = a.allocUnsafe(0);
				this._secCache = a.allocUnsafe(0);
				this._decrypt = c;
				this._alen = 0;
				this._len = 0;
				this._mode = e;
				this._authTag = null;
				this._called = false;
			}
			c(StreamCipher, o);
			StreamCipher.prototype._update = function (e) {
				if (!this._called && this._alen) {
					var t = 16 - (this._alen % 16);
					if (t < 16) {
						t = a.alloc(t, 0);
						this._ghash.update(t);
					}
				}
				this._called = true;
				var r = this._mode.encrypt(this, e);
				if (this._decrypt) {
					this._ghash.update(e);
				} else {
					this._ghash.update(r);
				}
				this._len += e.length;
				return r;
			};
			StreamCipher.prototype._final = function () {
				if (this._decrypt && !this._authTag)
					throw new Error('Unsupported state or unable to authenticate data');
				var e = l(
					this._ghash.final(this._alen * 8, this._len * 8),
					this._cipher.encryptBlock(this._finID)
				);
				if (this._decrypt && xorTest(e, this._authTag))
					throw new Error('Unsupported state or unable to authenticate data');
				this._authTag = e;
				this._cipher.scrub();
			};
			StreamCipher.prototype.getAuthTag = function getAuthTag() {
				if (this._decrypt || !a.isBuffer(this._authTag))
					throw new Error('Attempting to get auth tag in unsupported state');
				return this._authTag;
			};
			StreamCipher.prototype.setAuthTag = function setAuthTag(e) {
				if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state');
				this._authTag = e;
			};
			StreamCipher.prototype.setAAD = function setAAD(e) {
				if (this._called) throw new Error('Attempting to set AAD in unsupported state');
				this._ghash.update(e);
				this._alen += e.length;
			};
			e.exports = StreamCipher;
		},
		5007: (e, t, r) => {
			var i = r(5173);
			var a = r(8733);
			var o = r(3349);
			function getCiphers() {
				return Object.keys(o);
			}
			t.createCipher = t.Cipher = i.createCipher;
			t.createCipheriv = t.Cipheriv = i.createCipheriv;
			t.createDecipher = t.Decipher = a.createDecipher;
			t.createDecipheriv = t.Decipheriv = a.createDecipheriv;
			t.listCiphers = t.getCiphers = getCiphers;
		},
		8733: (e, t, r) => {
			var i = r(8182);
			var a = r(6608).Buffer;
			var o = r(6200);
			var c = r(8116);
			var u = r(8639);
			var l = r(7088);
			var d = r(1804);
			var p = r(1193);
			function Decipher(e, t, r) {
				u.call(this);
				this._cache = new Splitter();
				this._last = void 0;
				this._cipher = new l.AES(t);
				this._prev = a.from(r);
				this._mode = e;
				this._autopadding = true;
			}
			p(Decipher, u);
			Decipher.prototype._update = function (e) {
				this._cache.add(e);
				var t;
				var r;
				var i = [];
				while ((t = this._cache.get(this._autopadding))) {
					r = this._mode.decrypt(this, t);
					i.push(r);
				}
				return a.concat(i);
			};
			Decipher.prototype._final = function () {
				var e = this._cache.flush();
				if (this._autopadding) {
					return unpad(this._mode.decrypt(this, e));
				} else if (e) {
					throw new Error('data not multiple of block length');
				}
			};
			Decipher.prototype.setAutoPadding = function (e) {
				this._autopadding = !!e;
				return this;
			};
			function Splitter() {
				this.cache = a.allocUnsafe(0);
			}
			Splitter.prototype.add = function (e) {
				this.cache = a.concat([this.cache, e]);
			};
			Splitter.prototype.get = function (e) {
				var t;
				if (e) {
					if (this.cache.length > 16) {
						t = this.cache.slice(0, 16);
						this.cache = this.cache.slice(16);
						return t;
					}
				} else {
					if (this.cache.length >= 16) {
						t = this.cache.slice(0, 16);
						this.cache = this.cache.slice(16);
						return t;
					}
				}
				return null;
			};
			Splitter.prototype.flush = function () {
				if (this.cache.length) return this.cache;
			};
			function unpad(e) {
				var t = e[15];
				if (t < 1 || t > 16) {
					throw new Error('unable to decrypt data');
				}
				var r = -1;
				while (++r < t) {
					if (e[r + (16 - t)] !== t) {
						throw new Error('unable to decrypt data');
					}
				}
				if (t === 16) return;
				return e.slice(0, 16 - t);
			}
			function createDecipheriv(e, t, r) {
				var u = o[e.toLowerCase()];
				if (!u) throw new TypeError('invalid suite type');
				if (typeof r === 'string') r = a.from(r);
				if (u.mode !== 'GCM' && r.length !== u.iv)
					throw new TypeError('invalid iv length ' + r.length);
				if (typeof t === 'string') t = a.from(t);
				if (t.length !== u.key / 8) throw new TypeError('invalid key length ' + t.length);
				if (u.type === 'stream') {
					return new c(u.module, t, r, true);
				} else if (u.type === 'auth') {
					return new i(u.module, t, r, true);
				}
				return new Decipher(u.module, t, r);
			}
			function createDecipher(e, t) {
				var r = o[e.toLowerCase()];
				if (!r) throw new TypeError('invalid suite type');
				var i = d(t, false, r.key, r.iv);
				return createDecipheriv(e, i.key, i.iv);
			}
			t.createDecipher = createDecipher;
			t.createDecipheriv = createDecipheriv;
		},
		5173: (e, t, r) => {
			var i = r(6200);
			var a = r(8182);
			var o = r(6608).Buffer;
			var c = r(8116);
			var u = r(8639);
			var l = r(7088);
			var d = r(1804);
			var p = r(1193);
			function Cipher(e, t, r) {
				u.call(this);
				this._cache = new Splitter();
				this._cipher = new l.AES(t);
				this._prev = o.from(r);
				this._mode = e;
				this._autopadding = true;
			}
			p(Cipher, u);
			Cipher.prototype._update = function (e) {
				this._cache.add(e);
				var t;
				var r;
				var i = [];
				while ((t = this._cache.get())) {
					r = this._mode.encrypt(this, t);
					i.push(r);
				}
				return o.concat(i);
			};
			var m = o.alloc(16, 16);
			Cipher.prototype._final = function () {
				var e = this._cache.flush();
				if (this._autopadding) {
					e = this._mode.encrypt(this, e);
					this._cipher.scrub();
					return e;
				}
				if (!e.equals(m)) {
					this._cipher.scrub();
					throw new Error('data not multiple of block length');
				}
			};
			Cipher.prototype.setAutoPadding = function (e) {
				this._autopadding = !!e;
				return this;
			};
			function Splitter() {
				this.cache = o.allocUnsafe(0);
			}
			Splitter.prototype.add = function (e) {
				this.cache = o.concat([this.cache, e]);
			};
			Splitter.prototype.get = function () {
				if (this.cache.length > 15) {
					var e = this.cache.slice(0, 16);
					this.cache = this.cache.slice(16);
					return e;
				}
				return null;
			};
			Splitter.prototype.flush = function () {
				var e = 16 - this.cache.length;
				var t = o.allocUnsafe(e);
				var r = -1;
				while (++r < e) {
					t.writeUInt8(e, r);
				}
				return o.concat([this.cache, t]);
			};
			function createCipheriv(e, t, r) {
				var u = i[e.toLowerCase()];
				if (!u) throw new TypeError('invalid suite type');
				if (typeof t === 'string') t = o.from(t);
				if (t.length !== u.key / 8) throw new TypeError('invalid key length ' + t.length);
				if (typeof r === 'string') r = o.from(r);
				if (u.mode !== 'GCM' && r.length !== u.iv)
					throw new TypeError('invalid iv length ' + r.length);
				if (u.type === 'stream') {
					return new c(u.module, t, r);
				} else if (u.type === 'auth') {
					return new a(u.module, t, r);
				}
				return new Cipher(u.module, t, r);
			}
			function createCipher(e, t) {
				var r = i[e.toLowerCase()];
				if (!r) throw new TypeError('invalid suite type');
				var a = d(t, false, r.key, r.iv);
				return createCipheriv(e, a.key, a.iv);
			}
			t.createCipheriv = createCipheriv;
			t.createCipher = createCipher;
		},
		50: (e, t, r) => {
			var i = r(6608).Buffer;
			var a = i.alloc(16, 0);
			function toArray(e) {
				return [e.readUInt32BE(0), e.readUInt32BE(4), e.readUInt32BE(8), e.readUInt32BE(12)];
			}
			function fromArray(e) {
				var t = i.allocUnsafe(16);
				t.writeUInt32BE(e[0] >>> 0, 0);
				t.writeUInt32BE(e[1] >>> 0, 4);
				t.writeUInt32BE(e[2] >>> 0, 8);
				t.writeUInt32BE(e[3] >>> 0, 12);
				return t;
			}
			function GHASH(e) {
				this.h = e;
				this.state = i.alloc(16, 0);
				this.cache = i.allocUnsafe(0);
			}
			GHASH.prototype.ghash = function (e) {
				var t = -1;
				while (++t < e.length) {
					this.state[t] ^= e[t];
				}
				this._multiply();
			};
			GHASH.prototype._multiply = function () {
				var e = toArray(this.h);
				var t = [0, 0, 0, 0];
				var r, i, a;
				var o = -1;
				while (++o < 128) {
					i = (this.state[~~(o / 8)] & (1 << (7 - (o % 8)))) !== 0;
					if (i) {
						t[0] ^= e[0];
						t[1] ^= e[1];
						t[2] ^= e[2];
						t[3] ^= e[3];
					}
					a = (e[3] & 1) !== 0;
					for (r = 3; r > 0; r--) {
						e[r] = (e[r] >>> 1) | ((e[r - 1] & 1) << 31);
					}
					e[0] = e[0] >>> 1;
					if (a) {
						e[0] = e[0] ^ (225 << 24);
					}
				}
				this.state = fromArray(t);
			};
			GHASH.prototype.update = function (e) {
				this.cache = i.concat([this.cache, e]);
				var t;
				while (this.cache.length >= 16) {
					t = this.cache.slice(0, 16);
					this.cache = this.cache.slice(16);
					this.ghash(t);
				}
			};
			GHASH.prototype.final = function (e, t) {
				if (this.cache.length) {
					this.ghash(i.concat([this.cache, a], 16));
				}
				this.ghash(fromArray([0, e, 0, t]));
				return this.state;
			};
			e.exports = GHASH;
		},
		6696: (e) => {
			function incr32(e) {
				var t = e.length;
				var r;
				while (t--) {
					r = e.readUInt8(t);
					if (r === 255) {
						e.writeUInt8(0, t);
					} else {
						r++;
						e.writeUInt8(r, t);
						break;
					}
				}
			}
			e.exports = incr32;
		},
		3506: (e, t, r) => {
			var i = r(460);
			t.encrypt = function (e, t) {
				var r = i(t, e._prev);
				e._prev = e._cipher.encryptBlock(r);
				return e._prev;
			};
			t.decrypt = function (e, t) {
				var r = e._prev;
				e._prev = t;
				var a = e._cipher.decryptBlock(t);
				return i(a, r);
			};
		},
		6149: (e, t, r) => {
			var i = r(6608).Buffer;
			var a = r(460);
			function encryptStart(e, t, r) {
				var o = t.length;
				var c = a(t, e._cache);
				e._cache = e._cache.slice(o);
				e._prev = i.concat([e._prev, r ? t : c]);
				return c;
			}
			t.encrypt = function (e, t, r) {
				var a = i.allocUnsafe(0);
				var o;
				while (t.length) {
					if (e._cache.length === 0) {
						e._cache = e._cipher.encryptBlock(e._prev);
						e._prev = i.allocUnsafe(0);
					}
					if (e._cache.length <= t.length) {
						o = e._cache.length;
						a = i.concat([a, encryptStart(e, t.slice(0, o), r)]);
						t = t.slice(o);
					} else {
						a = i.concat([a, encryptStart(e, t, r)]);
						break;
					}
				}
				return a;
			};
		},
		8394: (e, t, r) => {
			var i = r(6608).Buffer;
			function encryptByte(e, t, r) {
				var i;
				var a = -1;
				var o = 8;
				var c = 0;
				var u, l;
				while (++a < o) {
					i = e._cipher.encryptBlock(e._prev);
					u = t & (1 << (7 - a)) ? 128 : 0;
					l = i[0] ^ u;
					c += (l & 128) >> a % 8;
					e._prev = shiftIn(e._prev, r ? u : l);
				}
				return c;
			}
			function shiftIn(e, t) {
				var r = e.length;
				var a = -1;
				var o = i.allocUnsafe(e.length);
				e = i.concat([e, i.from([t])]);
				while (++a < r) {
					o[a] = (e[a] << 1) | (e[a + 1] >> 7);
				}
				return o;
			}
			t.encrypt = function (e, t, r) {
				var a = t.length;
				var o = i.allocUnsafe(a);
				var c = -1;
				while (++c < a) {
					o[c] = encryptByte(e, t[c], r);
				}
				return o;
			};
		},
		193: (e, t, r) => {
			var i = r(6608).Buffer;
			function encryptByte(e, t, r) {
				var a = e._cipher.encryptBlock(e._prev);
				var o = a[0] ^ t;
				e._prev = i.concat([e._prev.slice(1), i.from([r ? t : o])]);
				return o;
			}
			t.encrypt = function (e, t, r) {
				var a = t.length;
				var o = i.allocUnsafe(a);
				var c = -1;
				while (++c < a) {
					o[c] = encryptByte(e, t[c], r);
				}
				return o;
			};
		},
		5527: (e, t, r) => {
			var i = r(460);
			var a = r(6608).Buffer;
			var o = r(6696);
			function getBlock(e) {
				var t = e._cipher.encryptBlockRaw(e._prev);
				o(e._prev);
				return t;
			}
			var c = 16;
			t.encrypt = function (e, t) {
				var r = Math.ceil(t.length / c);
				var o = e._cache.length;
				e._cache = a.concat([e._cache, a.allocUnsafe(r * c)]);
				for (var u = 0; u < r; u++) {
					var l = getBlock(e);
					var d = o + u * c;
					e._cache.writeUInt32BE(l[0], d + 0);
					e._cache.writeUInt32BE(l[1], d + 4);
					e._cache.writeUInt32BE(l[2], d + 8);
					e._cache.writeUInt32BE(l[3], d + 12);
				}
				var p = e._cache.slice(0, t.length);
				e._cache = e._cache.slice(t.length);
				return i(t, p);
			};
		},
		882: (e, t) => {
			t.encrypt = function (e, t) {
				return e._cipher.encryptBlock(t);
			};
			t.decrypt = function (e, t) {
				return e._cipher.decryptBlock(t);
			};
		},
		6200: (e, t, r) => {
			var i = {
				ECB: r(882),
				CBC: r(3506),
				CFB: r(6149),
				CFB8: r(193),
				CFB1: r(8394),
				OFB: r(7481),
				CTR: r(5527),
				GCM: r(5527)
			};
			var a = r(3349);
			for (var o in a) {
				a[o].module = i[a[o].mode];
			}
			e.exports = a;
		},
		7481: (e, t, r) => {
			var i = r(6533)['Buffer'];
			var a = r(460);
			function getBlock(e) {
				e._prev = e._cipher.encryptBlock(e._prev);
				return e._prev;
			}
			t.encrypt = function (e, t) {
				while (e._cache.length < t.length) {
					e._cache = i.concat([e._cache, getBlock(e)]);
				}
				var r = e._cache.slice(0, t.length);
				e._cache = e._cache.slice(t.length);
				return a(t, r);
			};
		},
		8116: (e, t, r) => {
			var i = r(7088);
			var a = r(6608).Buffer;
			var o = r(8639);
			var c = r(1193);
			function StreamCipher(e, t, r, c) {
				o.call(this);
				this._cipher = new i.AES(t);
				this._prev = a.from(r);
				this._cache = a.allocUnsafe(0);
				this._secCache = a.allocUnsafe(0);
				this._decrypt = c;
				this._mode = e;
			}
			c(StreamCipher, o);
			StreamCipher.prototype._update = function (e) {
				return this._mode.encrypt(this, e, this._decrypt);
			};
			StreamCipher.prototype._final = function () {
				this._cipher.scrub();
			};
			e.exports = StreamCipher;
		},
		8350: (e, t, r) => {
			var i = r(4487);
			var a = r(5007);
			var o = r(6200);
			var c = r(3811);
			var u = r(1804);
			function createCipher(e, t) {
				e = e.toLowerCase();
				var r, i;
				if (o[e]) {
					r = o[e].key;
					i = o[e].iv;
				} else if (c[e]) {
					r = c[e].key * 8;
					i = c[e].iv;
				} else {
					throw new TypeError('invalid suite type');
				}
				var a = u(t, false, r, i);
				return createCipheriv(e, a.key, a.iv);
			}
			function createDecipher(e, t) {
				e = e.toLowerCase();
				var r, i;
				if (o[e]) {
					r = o[e].key;
					i = o[e].iv;
				} else if (c[e]) {
					r = c[e].key * 8;
					i = c[e].iv;
				} else {
					throw new TypeError('invalid suite type');
				}
				var a = u(t, false, r, i);
				return createDecipheriv(e, a.key, a.iv);
			}
			function createCipheriv(e, t, r) {
				e = e.toLowerCase();
				if (o[e]) return a.createCipheriv(e, t, r);
				if (c[e]) return new i({ key: t, iv: r, mode: e });
				throw new TypeError('invalid suite type');
			}
			function createDecipheriv(e, t, r) {
				e = e.toLowerCase();
				if (o[e]) return a.createDecipheriv(e, t, r);
				if (c[e]) return new i({ key: t, iv: r, mode: e, decrypt: true });
				throw new TypeError('invalid suite type');
			}
			function getCiphers() {
				return Object.keys(c).concat(a.getCiphers());
			}
			t.createCipher = t.Cipher = createCipher;
			t.createCipheriv = t.Cipheriv = createCipheriv;
			t.createDecipher = t.Decipher = createDecipher;
			t.createDecipheriv = t.Decipheriv = createDecipheriv;
			t.listCiphers = t.getCiphers = getCiphers;
		},
		4487: (e, t, r) => {
			var i = r(8639);
			var a = r(8754);
			var o = r(1193);
			var c = r(6608).Buffer;
			var u = {
				'des-ede3-cbc': a.CBC.instantiate(a.EDE),
				'des-ede3': a.EDE,
				'des-ede-cbc': a.CBC.instantiate(a.EDE),
				'des-ede': a.EDE,
				'des-cbc': a.CBC.instantiate(a.DES),
				'des-ecb': a.DES
			};
			u.des = u['des-cbc'];
			u.des3 = u['des-ede3-cbc'];
			e.exports = DES;
			o(DES, i);
			function DES(e) {
				i.call(this);
				var t = e.mode.toLowerCase();
				var r = u[t];
				var a;
				if (e.decrypt) {
					a = 'decrypt';
				} else {
					a = 'encrypt';
				}
				var o = e.key;
				if (!c.isBuffer(o)) {
					o = c.from(o);
				}
				if (t === 'des-ede' || t === 'des-ede-cbc') {
					o = c.concat([o, o.slice(0, 8)]);
				}
				var l = e.iv;
				if (!c.isBuffer(l)) {
					l = c.from(l);
				}
				this._des = r.create({ key: o, iv: l, type: a });
			}
			DES.prototype._update = function (e) {
				return c.from(this._des.update(e));
			};
			DES.prototype._final = function () {
				return c.from(this._des.final());
			};
		},
		3811: (e, t) => {
			t['des-ecb'] = { key: 8, iv: 0 };
			t['des-cbc'] = t.des = { key: 8, iv: 8 };
			t['des-ede3-cbc'] = t.des3 = { key: 24, iv: 8 };
			t['des-ede3'] = { key: 24, iv: 0 };
			t['des-ede-cbc'] = { key: 16, iv: 8 };
			t['des-ede'] = { key: 16, iv: 0 };
		},
		8538: (e, t, r) => {
			'use strict';
			var i = r(3900);
			var a = r(2869);
			var o = r(6608).Buffer;
			function getr(e) {
				var t = e.modulus.byteLength();
				var r;
				do {
					r = new i(a(t));
				} while (r.cmp(e.modulus) >= 0 || !r.umod(e.prime1) || !r.umod(e.prime2));
				return r;
			}
			function blind(e) {
				var t = getr(e);
				var r = t.toRed(i.mont(e.modulus)).redPow(new i(e.publicExponent)).fromRed();
				return { blinder: r, unblinder: t.invm(e.modulus) };
			}
			function crt(e, t) {
				var r = blind(t);
				var a = t.modulus.byteLength();
				var c = new i(e).mul(r.blinder).umod(t.modulus);
				var u = c.toRed(i.mont(t.prime1));
				var l = c.toRed(i.mont(t.prime2));
				var d = t.coefficient;
				var p = t.prime1;
				var m = t.prime2;
				var g = u.redPow(t.exponent1).fromRed();
				var v = l.redPow(t.exponent2).fromRed();
				var y = g.isub(v).imul(d).umod(p).imul(m);
				return v.iadd(y).imul(r.unblinder).umod(t.modulus).toArrayLike(o, 'be', a);
			}
			crt.getr = getr;
			e.exports = crt;
		},
		9823: (e, t, r) => {
			'use strict';
			e.exports = r(7595);
		},
		4368: (e, t, r) => {
			'use strict';
			var i = r(6608).Buffer;
			var a = r(8955);
			var o = r(9464);
			var c = r(1193);
			var u = r(4299);
			var l = r(7603);
			var d = r(7595);
			Object.keys(d).forEach(function (e) {
				d[e].id = i.from(d[e].id, 'hex');
				d[e.toLowerCase()] = d[e];
			});
			function Sign(e) {
				o.Writable.call(this);
				var t = d[e];
				if (!t) {
					throw new Error('Unknown message digest');
				}
				this._hashType = t.hash;
				this._hash = a(t.hash);
				this._tag = t.id;
				this._signType = t.sign;
			}
			c(Sign, o.Writable);
			Sign.prototype._write = function _write(e, t, r) {
				this._hash.update(e);
				r();
			};
			Sign.prototype.update = function update(e, t) {
				this._hash.update(typeof e === 'string' ? i.from(e, t) : e);
				return this;
			};
			Sign.prototype.sign = function signMethod(e, t) {
				this.end();
				var r = this._hash.digest();
				var i = u(r, e, this._hashType, this._signType, this._tag);
				return t ? i.toString(t) : i;
			};
			function Verify(e) {
				o.Writable.call(this);
				var t = d[e];
				if (!t) {
					throw new Error('Unknown message digest');
				}
				this._hash = a(t.hash);
				this._tag = t.id;
				this._signType = t.sign;
			}
			c(Verify, o.Writable);
			Verify.prototype._write = function _write(e, t, r) {
				this._hash.update(e);
				r();
			};
			Verify.prototype.update = function update(e, t) {
				this._hash.update(typeof e === 'string' ? i.from(e, t) : e);
				return this;
			};
			Verify.prototype.verify = function verifyMethod(e, t, r) {
				var a = typeof t === 'string' ? i.from(t, r) : t;
				this.end();
				var o = this._hash.digest();
				return l(a, o, e, this._signType, this._tag);
			};
			function createSign(e) {
				return new Sign(e);
			}
			function createVerify(e) {
				return new Verify(e);
			}
			e.exports = { Sign: createSign, Verify: createVerify, createSign, createVerify };
		},
		4299: (e, t, r) => {
			'use strict';
			var i = r(6608).Buffer;
			var a = r(3053);
			var o = r(8538);
			var c = r(3071).ec;
			var u = r(3900);
			var l = r(9979);
			var d = r(9729);
			var p = 1;
			function sign(e, t, r, a, c) {
				var u = l(t);
				if (u.curve) {
					if (a !== 'ecdsa' && a !== 'ecdsa/rsa') {
						throw new Error('wrong private key type');
					}
					return ecSign(e, u);
				} else if (u.type === 'dsa') {
					if (a !== 'dsa') {
						throw new Error('wrong private key type');
					}
					return dsaSign(e, u, r);
				}
				if (a !== 'rsa' && a !== 'ecdsa/rsa') {
					throw new Error('wrong private key type');
				}
				if (t.padding !== undefined && t.padding !== p) {
					throw new Error('illegal or unsupported padding mode');
				}
				e = i.concat([c, e]);
				var d = u.modulus.byteLength();
				var m = [0, 1];
				while (e.length + m.length + 1 < d) {
					m.push(255);
				}
				m.push(0);
				var g = -1;
				while (++g < e.length) {
					m.push(e[g]);
				}
				var v = o(m, u);
				return v;
			}
			function ecSign(e, t) {
				var r = d[t.curve.join('.')];
				if (!r) {
					throw new Error('unknown curve ' + t.curve.join('.'));
				}
				var a = new c(r);
				var o = a.keyFromPrivate(t.privateKey);
				var u = o.sign(e);
				return i.from(u.toDER());
			}
			function dsaSign(e, t, r) {
				var i = t.params.priv_key;
				var a = t.params.p;
				var o = t.params.q;
				var c = t.params.g;
				var l = new u(0);
				var d;
				var p = bits2int(e, o).mod(o);
				var m = false;
				var g = getKey(i, o, e, r);
				while (m === false) {
					d = makeKey(o, g, r);
					l = makeR(c, d, a, o);
					m = d
						.invm(o)
						.imul(p.add(i.mul(l)))
						.mod(o);
					if (m.cmpn(0) === 0) {
						m = false;
						l = new u(0);
					}
				}
				return toDER(l, m);
			}
			function toDER(e, t) {
				e = e.toArray();
				t = t.toArray();
				if (e[0] & 128) {
					e = [0].concat(e);
				}
				if (t[0] & 128) {
					t = [0].concat(t);
				}
				var r = e.length + t.length + 4;
				var a = [48, r, 2, e.length];
				a = a.concat(e, [2, t.length], t);
				return i.from(a);
			}
			function getKey(e, t, r, o) {
				e = i.from(e.toArray());
				if (e.length < t.byteLength()) {
					var c = i.alloc(t.byteLength() - e.length);
					e = i.concat([c, e]);
				}
				var u = r.length;
				var l = bits2octets(r, t);
				var d = i.alloc(u);
				d.fill(1);
				var p = i.alloc(u);
				p = a(o, p)
					.update(d)
					.update(i.from([0]))
					.update(e)
					.update(l)
					.digest();
				d = a(o, p).update(d).digest();
				p = a(o, p)
					.update(d)
					.update(i.from([1]))
					.update(e)
					.update(l)
					.digest();
				d = a(o, p).update(d).digest();
				return { k: p, v: d };
			}
			function bits2int(e, t) {
				var r = new u(e);
				var i = (e.length << 3) - t.bitLength();
				if (i > 0) {
					r.ishrn(i);
				}
				return r;
			}
			function bits2octets(e, t) {
				e = bits2int(e, t);
				e = e.mod(t);
				var r = i.from(e.toArray());
				if (r.length < t.byteLength()) {
					var a = i.alloc(t.byteLength() - r.length);
					r = i.concat([a, r]);
				}
				return r;
			}
			function makeKey(e, t, r) {
				var o;
				var c;
				do {
					o = i.alloc(0);
					while (o.length * 8 < e.bitLength()) {
						t.v = a(r, t.k).update(t.v).digest();
						o = i.concat([o, t.v]);
					}
					c = bits2int(o, e);
					t.k = a(r, t.k)
						.update(t.v)
						.update(i.from([0]))
						.digest();
					t.v = a(r, t.k).update(t.v).digest();
				} while (c.cmp(e) !== -1);
				return c;
			}
			function makeR(e, t, r, i) {
				return e.toRed(u.mont(r)).redPow(t).fromRed().mod(i);
			}
			e.exports = sign;
			e.exports.getKey = getKey;
			e.exports.makeKey = makeKey;
		},
		7603: (e, t, r) => {
			'use strict';
			var i = r(6608).Buffer;
			var a = r(3900);
			var o = r(3071).ec;
			var c = r(9979);
			var u = r(9729);
			function verify(e, t, r, o, u) {
				var l = c(r);
				if (l.type === 'ec') {
					if (o !== 'ecdsa' && o !== 'ecdsa/rsa') {
						throw new Error('wrong public key type');
					}
					return ecVerify(e, t, l);
				} else if (l.type === 'dsa') {
					if (o !== 'dsa') {
						throw new Error('wrong public key type');
					}
					return dsaVerify(e, t, l);
				}
				if (o !== 'rsa' && o !== 'ecdsa/rsa') {
					throw new Error('wrong public key type');
				}
				t = i.concat([u, t]);
				var d = l.modulus.byteLength();
				var p = [1];
				var m = 0;
				while (t.length + p.length + 2 < d) {
					p.push(255);
					m += 1;
				}
				p.push(0);
				var g = -1;
				while (++g < t.length) {
					p.push(t[g]);
				}
				p = i.from(p);
				var v = a.mont(l.modulus);
				e = new a(e).toRed(v);
				e = e.redPow(new a(l.publicExponent));
				e = i.from(e.fromRed().toArray());
				var y = m < 8 ? 1 : 0;
				d = Math.min(e.length, p.length);
				if (e.length !== p.length) {
					y = 1;
				}
				g = -1;
				while (++g < d) {
					y |= e[g] ^ p[g];
				}
				return y === 0;
			}
			function ecVerify(e, t, r) {
				var i = u[r.data.algorithm.curve.join('.')];
				if (!i) {
					throw new Error('unknown curve ' + r.data.algorithm.curve.join('.'));
				}
				var a = new o(i);
				var c = r.data.subjectPrivateKey.data;
				return a.verify(t, e, c);
			}
			function dsaVerify(e, t, r) {
				var i = r.data.p;
				var o = r.data.q;
				var u = r.data.g;
				var l = r.data.pub_key;
				var d = c.signature.decode(e, 'der');
				var p = d.s;
				var m = d.r;
				checkValue(p, o);
				checkValue(m, o);
				var g = a.mont(i);
				var v = p.invm(o);
				var y = u
					.toRed(g)
					.redPow(new a(t).mul(v).mod(o))
					.fromRed()
					.mul(l.toRed(g).redPow(m.mul(v).mod(o)).fromRed())
					.mod(i)
					.mod(o);
				return y.cmp(m) === 0;
			}
			function checkValue(e, t) {
				if (e.cmpn(0) <= 0) {
					throw new Error('invalid sig');
				}
				if (e.cmp(t) >= 0) {
					throw new Error('invalid sig');
				}
			}
			e.exports = verify;
		},
		460: (e, t, r) => {
			var i = r(6533)['Buffer'];
			e.exports = function xor(e, t) {
				var r = Math.min(e.length, t.length);
				var a = new i(r);
				for (var o = 0; o < r; ++o) {
					a[o] = e[o] ^ t[o];
				}
				return a;
			};
		},
		6533: (e, t, r) => {
			'use strict';
			const i = r(4933);
			const a = r(3328);
			const o =
				typeof Symbol === 'function' && typeof Symbol['for'] === 'function'
					? Symbol['for']('nodejs.util.inspect.custom')
					: null;
			t.Buffer = Buffer;
			t.SlowBuffer = SlowBuffer;
			t.INSPECT_MAX_BYTES = 50;
			const c = 2147483647;
			t.kMaxLength = c;
			Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
			if (
				!Buffer.TYPED_ARRAY_SUPPORT &&
				typeof console !== 'undefined' &&
				typeof console.error === 'function'
			) {
				console.error(
					'This browser lacks typed array (Uint8Array) support which is required by ' +
						'`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
				);
			}
			function typedArraySupport() {
				try {
					const e = new Uint8Array(1);
					const t = {
						foo: function () {
							return 42;
						}
					};
					Object.setPrototypeOf(t, Uint8Array.prototype);
					Object.setPrototypeOf(e, t);
					return e.foo() === 42;
				} catch (e) {
					return false;
				}
			}
			Object.defineProperty(Buffer.prototype, 'parent', {
				enumerable: true,
				get: function () {
					if (!Buffer.isBuffer(this)) return undefined;
					return this.buffer;
				}
			});
			Object.defineProperty(Buffer.prototype, 'offset', {
				enumerable: true,
				get: function () {
					if (!Buffer.isBuffer(this)) return undefined;
					return this.byteOffset;
				}
			});
			function createBuffer(e) {
				if (e > c) {
					throw new RangeError('The value "' + e + '" is invalid for option "size"');
				}
				const t = new Uint8Array(e);
				Object.setPrototypeOf(t, Buffer.prototype);
				return t;
			}
			function Buffer(e, t, r) {
				if (typeof e === 'number') {
					if (typeof t === 'string') {
						throw new TypeError(
							'The "string" argument must be of type string. Received type number'
						);
					}
					return allocUnsafe(e);
				}
				return from(e, t, r);
			}
			Buffer.poolSize = 8192;
			function from(e, t, r) {
				if (typeof e === 'string') {
					return fromString(e, t);
				}
				if (ArrayBuffer.isView(e)) {
					return fromArrayView(e);
				}
				if (e == null) {
					throw new TypeError(
						'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
							'or Array-like Object. Received type ' +
							typeof e
					);
				}
				if (isInstance(e, ArrayBuffer) || (e && isInstance(e.buffer, ArrayBuffer))) {
					return fromArrayBuffer(e, t, r);
				}
				if (
					typeof SharedArrayBuffer !== 'undefined' &&
					(isInstance(e, SharedArrayBuffer) || (e && isInstance(e.buffer, SharedArrayBuffer)))
				) {
					return fromArrayBuffer(e, t, r);
				}
				if (typeof e === 'number') {
					throw new TypeError(
						'The "value" argument must not be of type number. Received type number'
					);
				}
				const i = e.valueOf && e.valueOf();
				if (i != null && i !== e) {
					return Buffer.from(i, t, r);
				}
				const a = fromObject(e);
				if (a) return a;
				if (
					typeof Symbol !== 'undefined' &&
					Symbol.toPrimitive != null &&
					typeof e[Symbol.toPrimitive] === 'function'
				) {
					return Buffer.from(e[Symbol.toPrimitive]('string'), t, r);
				}
				throw new TypeError(
					'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
						'or Array-like Object. Received type ' +
						typeof e
				);
			}
			Buffer.from = function (e, t, r) {
				return from(e, t, r);
			};
			Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
			Object.setPrototypeOf(Buffer, Uint8Array);
			function assertSize(e) {
				if (typeof e !== 'number') {
					throw new TypeError('"size" argument must be of type number');
				} else if (e < 0) {
					throw new RangeError('The value "' + e + '" is invalid for option "size"');
				}
			}
			function alloc(e, t, r) {
				assertSize(e);
				if (e <= 0) {
					return createBuffer(e);
				}
				if (t !== undefined) {
					return typeof r === 'string' ? createBuffer(e).fill(t, r) : createBuffer(e).fill(t);
				}
				return createBuffer(e);
			}
			Buffer.alloc = function (e, t, r) {
				return alloc(e, t, r);
			};
			function allocUnsafe(e) {
				assertSize(e);
				return createBuffer(e < 0 ? 0 : checked(e) | 0);
			}
			Buffer.allocUnsafe = function (e) {
				return allocUnsafe(e);
			};
			Buffer.allocUnsafeSlow = function (e) {
				return allocUnsafe(e);
			};
			function fromString(e, t) {
				if (typeof t !== 'string' || t === '') {
					t = 'utf8';
				}
				if (!Buffer.isEncoding(t)) {
					throw new TypeError('Unknown encoding: ' + t);
				}
				const r = byteLength(e, t) | 0;
				let i = createBuffer(r);
				const a = i.write(e, t);
				if (a !== r) {
					i = i.slice(0, a);
				}
				return i;
			}
			function fromArrayLike(e) {
				const t = e.length < 0 ? 0 : checked(e.length) | 0;
				const r = createBuffer(t);
				for (let i = 0; i < t; i += 1) {
					r[i] = e[i] & 255;
				}
				return r;
			}
			function fromArrayView(e) {
				if (isInstance(e, Uint8Array)) {
					const t = new Uint8Array(e);
					return fromArrayBuffer(t.buffer, t.byteOffset, t.byteLength);
				}
				return fromArrayLike(e);
			}
			function fromArrayBuffer(e, t, r) {
				if (t < 0 || e.byteLength < t) {
					throw new RangeError('"offset" is outside of buffer bounds');
				}
				if (e.byteLength < t + (r || 0)) {
					throw new RangeError('"length" is outside of buffer bounds');
				}
				let i;
				if (t === undefined && r === undefined) {
					i = new Uint8Array(e);
				} else if (r === undefined) {
					i = new Uint8Array(e, t);
				} else {
					i = new Uint8Array(e, t, r);
				}
				Object.setPrototypeOf(i, Buffer.prototype);
				return i;
			}
			function fromObject(e) {
				if (Buffer.isBuffer(e)) {
					const t = checked(e.length) | 0;
					const r = createBuffer(t);
					if (r.length === 0) {
						return r;
					}
					e.copy(r, 0, 0, t);
					return r;
				}
				if (e.length !== undefined) {
					if (typeof e.length !== 'number' || numberIsNaN(e.length)) {
						return createBuffer(0);
					}
					return fromArrayLike(e);
				}
				if (e.type === 'Buffer' && Array.isArray(e.data)) {
					return fromArrayLike(e.data);
				}
			}
			function checked(e) {
				if (e >= c) {
					throw new RangeError(
						'Attempt to allocate Buffer larger than maximum ' +
							'size: 0x' +
							c.toString(16) +
							' bytes'
					);
				}
				return e | 0;
			}
			function SlowBuffer(e) {
				if (+e != e) {
					e = 0;
				}
				return Buffer.alloc(+e);
			}
			Buffer.isBuffer = function isBuffer(e) {
				return e != null && e._isBuffer === true && e !== Buffer.prototype;
			};
			Buffer.compare = function compare(e, t) {
				if (isInstance(e, Uint8Array)) e = Buffer.from(e, e.offset, e.byteLength);
				if (isInstance(t, Uint8Array)) t = Buffer.from(t, t.offset, t.byteLength);
				if (!Buffer.isBuffer(e) || !Buffer.isBuffer(t)) {
					throw new TypeError(
						'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
					);
				}
				if (e === t) return 0;
				let r = e.length;
				let i = t.length;
				for (let a = 0, o = Math.min(r, i); a < o; ++a) {
					if (e[a] !== t[a]) {
						r = e[a];
						i = t[a];
						break;
					}
				}
				if (r < i) return -1;
				if (i < r) return 1;
				return 0;
			};
			Buffer.isEncoding = function isEncoding(e) {
				switch (String(e).toLowerCase()) {
					case 'hex':
					case 'utf8':
					case 'utf-8':
					case 'ascii':
					case 'latin1':
					case 'binary':
					case 'base64':
					case 'ucs2':
					case 'ucs-2':
					case 'utf16le':
					case 'utf-16le':
						return true;
					default:
						return false;
				}
			};
			Buffer.concat = function concat(e, t) {
				if (!Array.isArray(e)) {
					throw new TypeError('"list" argument must be an Array of Buffers');
				}
				if (e.length === 0) {
					return Buffer.alloc(0);
				}
				let r;
				if (t === undefined) {
					t = 0;
					for (r = 0; r < e.length; ++r) {
						t += e[r].length;
					}
				}
				const i = Buffer.allocUnsafe(t);
				let a = 0;
				for (r = 0; r < e.length; ++r) {
					let t = e[r];
					if (isInstance(t, Uint8Array)) {
						if (a + t.length > i.length) {
							if (!Buffer.isBuffer(t)) t = Buffer.from(t);
							t.copy(i, a);
						} else {
							Uint8Array.prototype.set.call(i, t, a);
						}
					} else if (!Buffer.isBuffer(t)) {
						throw new TypeError('"list" argument must be an Array of Buffers');
					} else {
						t.copy(i, a);
					}
					a += t.length;
				}
				return i;
			};
			function byteLength(e, t) {
				if (Buffer.isBuffer(e)) {
					return e.length;
				}
				if (ArrayBuffer.isView(e) || isInstance(e, ArrayBuffer)) {
					return e.byteLength;
				}
				if (typeof e !== 'string') {
					throw new TypeError(
						'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
							'Received type ' +
							typeof e
					);
				}
				const r = e.length;
				const i = arguments.length > 2 && arguments[2] === true;
				if (!i && r === 0) return 0;
				let a = false;
				for (;;) {
					switch (t) {
						case 'ascii':
						case 'latin1':
						case 'binary':
							return r;
						case 'utf8':
						case 'utf-8':
							return utf8ToBytes(e).length;
						case 'ucs2':
						case 'ucs-2':
						case 'utf16le':
						case 'utf-16le':
							return r * 2;
						case 'hex':
							return r >>> 1;
						case 'base64':
							return base64ToBytes(e).length;
						default:
							if (a) {
								return i ? -1 : utf8ToBytes(e).length;
							}
							t = ('' + t).toLowerCase();
							a = true;
					}
				}
			}
			Buffer.byteLength = byteLength;
			function slowToString(e, t, r) {
				let i = false;
				if (t === undefined || t < 0) {
					t = 0;
				}
				if (t > this.length) {
					return '';
				}
				if (r === undefined || r > this.length) {
					r = this.length;
				}
				if (r <= 0) {
					return '';
				}
				r >>>= 0;
				t >>>= 0;
				if (r <= t) {
					return '';
				}
				if (!e) e = 'utf8';
				while (true) {
					switch (e) {
						case 'hex':
							return hexSlice(this, t, r);
						case 'utf8':
						case 'utf-8':
							return utf8Slice(this, t, r);
						case 'ascii':
							return asciiSlice(this, t, r);
						case 'latin1':
						case 'binary':
							return latin1Slice(this, t, r);
						case 'base64':
							return base64Slice(this, t, r);
						case 'ucs2':
						case 'ucs-2':
						case 'utf16le':
						case 'utf-16le':
							return utf16leSlice(this, t, r);
						default:
							if (i) throw new TypeError('Unknown encoding: ' + e);
							e = (e + '').toLowerCase();
							i = true;
					}
				}
			}
			Buffer.prototype._isBuffer = true;
			function swap(e, t, r) {
				const i = e[t];
				e[t] = e[r];
				e[r] = i;
			}
			Buffer.prototype.swap16 = function swap16() {
				const e = this.length;
				if (e % 2 !== 0) {
					throw new RangeError('Buffer size must be a multiple of 16-bits');
				}
				for (let t = 0; t < e; t += 2) {
					swap(this, t, t + 1);
				}
				return this;
			};
			Buffer.prototype.swap32 = function swap32() {
				const e = this.length;
				if (e % 4 !== 0) {
					throw new RangeError('Buffer size must be a multiple of 32-bits');
				}
				for (let t = 0; t < e; t += 4) {
					swap(this, t, t + 3);
					swap(this, t + 1, t + 2);
				}
				return this;
			};
			Buffer.prototype.swap64 = function swap64() {
				const e = this.length;
				if (e % 8 !== 0) {
					throw new RangeError('Buffer size must be a multiple of 64-bits');
				}
				for (let t = 0; t < e; t += 8) {
					swap(this, t, t + 7);
					swap(this, t + 1, t + 6);
					swap(this, t + 2, t + 5);
					swap(this, t + 3, t + 4);
				}
				return this;
			};
			Buffer.prototype.toString = function toString() {
				const e = this.length;
				if (e === 0) return '';
				if (arguments.length === 0) return utf8Slice(this, 0, e);
				return slowToString.apply(this, arguments);
			};
			Buffer.prototype.toLocaleString = Buffer.prototype.toString;
			Buffer.prototype.equals = function equals(e) {
				if (!Buffer.isBuffer(e)) throw new TypeError('Argument must be a Buffer');
				if (this === e) return true;
				return Buffer.compare(this, e) === 0;
			};
			Buffer.prototype.inspect = function inspect() {
				let e = '';
				const r = t.INSPECT_MAX_BYTES;
				e = this.toString('hex', 0, r)
					.replace(/(.{2})/g, '$1 ')
					.trim();
				if (this.length > r) e += ' ... ';
				return '<Buffer ' + e + '>';
			};
			if (o) {
				Buffer.prototype[o] = Buffer.prototype.inspect;
			}
			Buffer.prototype.compare = function compare(e, t, r, i, a) {
				if (isInstance(e, Uint8Array)) {
					e = Buffer.from(e, e.offset, e.byteLength);
				}
				if (!Buffer.isBuffer(e)) {
					throw new TypeError(
						'The "target" argument must be one of type Buffer or Uint8Array. ' +
							'Received type ' +
							typeof e
					);
				}
				if (t === undefined) {
					t = 0;
				}
				if (r === undefined) {
					r = e ? e.length : 0;
				}
				if (i === undefined) {
					i = 0;
				}
				if (a === undefined) {
					a = this.length;
				}
				if (t < 0 || r > e.length || i < 0 || a > this.length) {
					throw new RangeError('out of range index');
				}
				if (i >= a && t >= r) {
					return 0;
				}
				if (i >= a) {
					return -1;
				}
				if (t >= r) {
					return 1;
				}
				t >>>= 0;
				r >>>= 0;
				i >>>= 0;
				a >>>= 0;
				if (this === e) return 0;
				let o = a - i;
				let c = r - t;
				const u = Math.min(o, c);
				const l = this.slice(i, a);
				const d = e.slice(t, r);
				for (let e = 0; e < u; ++e) {
					if (l[e] !== d[e]) {
						o = l[e];
						c = d[e];
						break;
					}
				}
				if (o < c) return -1;
				if (c < o) return 1;
				return 0;
			};
			function bidirectionalIndexOf(e, t, r, i, a) {
				if (e.length === 0) return -1;
				if (typeof r === 'string') {
					i = r;
					r = 0;
				} else if (r > 2147483647) {
					r = 2147483647;
				} else if (r < -2147483648) {
					r = -2147483648;
				}
				r = +r;
				if (numberIsNaN(r)) {
					r = a ? 0 : e.length - 1;
				}
				if (r < 0) r = e.length + r;
				if (r >= e.length) {
					if (a) return -1;
					else r = e.length - 1;
				} else if (r < 0) {
					if (a) r = 0;
					else return -1;
				}
				if (typeof t === 'string') {
					t = Buffer.from(t, i);
				}
				if (Buffer.isBuffer(t)) {
					if (t.length === 0) {
						return -1;
					}
					return arrayIndexOf(e, t, r, i, a);
				} else if (typeof t === 'number') {
					t = t & 255;
					if (typeof Uint8Array.prototype.indexOf === 'function') {
						if (a) {
							return Uint8Array.prototype.indexOf.call(e, t, r);
						} else {
							return Uint8Array.prototype.lastIndexOf.call(e, t, r);
						}
					}
					return arrayIndexOf(e, [t], r, i, a);
				}
				throw new TypeError('val must be string, number or Buffer');
			}
			function arrayIndexOf(e, t, r, i, a) {
				let o = 1;
				let c = e.length;
				let u = t.length;
				if (i !== undefined) {
					i = String(i).toLowerCase();
					if (i === 'ucs2' || i === 'ucs-2' || i === 'utf16le' || i === 'utf-16le') {
						if (e.length < 2 || t.length < 2) {
							return -1;
						}
						o = 2;
						c /= 2;
						u /= 2;
						r /= 2;
					}
				}
				function read(e, t) {
					if (o === 1) {
						return e[t];
					} else {
						return e.readUInt16BE(t * o);
					}
				}
				let l;
				if (a) {
					let i = -1;
					for (l = r; l < c; l++) {
						if (read(e, l) === read(t, i === -1 ? 0 : l - i)) {
							if (i === -1) i = l;
							if (l - i + 1 === u) return i * o;
						} else {
							if (i !== -1) l -= l - i;
							i = -1;
						}
					}
				} else {
					if (r + u > c) r = c - u;
					for (l = r; l >= 0; l--) {
						let r = true;
						for (let i = 0; i < u; i++) {
							if (read(e, l + i) !== read(t, i)) {
								r = false;
								break;
							}
						}
						if (r) return l;
					}
				}
				return -1;
			}
			Buffer.prototype.includes = function includes(e, t, r) {
				return this.indexOf(e, t, r) !== -1;
			};
			Buffer.prototype.indexOf = function indexOf(e, t, r) {
				return bidirectionalIndexOf(this, e, t, r, true);
			};
			Buffer.prototype.lastIndexOf = function lastIndexOf(e, t, r) {
				return bidirectionalIndexOf(this, e, t, r, false);
			};
			function hexWrite(e, t, r, i) {
				r = Number(r) || 0;
				const a = e.length - r;
				if (!i) {
					i = a;
				} else {
					i = Number(i);
					if (i > a) {
						i = a;
					}
				}
				const o = t.length;
				if (i > o / 2) {
					i = o / 2;
				}
				let c;
				for (c = 0; c < i; ++c) {
					const i = parseInt(t.substr(c * 2, 2), 16);
					if (numberIsNaN(i)) return c;
					e[r + c] = i;
				}
				return c;
			}
			function utf8Write(e, t, r, i) {
				return blitBuffer(utf8ToBytes(t, e.length - r), e, r, i);
			}
			function asciiWrite(e, t, r, i) {
				return blitBuffer(asciiToBytes(t), e, r, i);
			}
			function base64Write(e, t, r, i) {
				return blitBuffer(base64ToBytes(t), e, r, i);
			}
			function ucs2Write(e, t, r, i) {
				return blitBuffer(utf16leToBytes(t, e.length - r), e, r, i);
			}
			Buffer.prototype.write = function write(e, t, r, i) {
				if (t === undefined) {
					i = 'utf8';
					r = this.length;
					t = 0;
				} else if (r === undefined && typeof t === 'string') {
					i = t;
					r = this.length;
					t = 0;
				} else if (isFinite(t)) {
					t = t >>> 0;
					if (isFinite(r)) {
						r = r >>> 0;
						if (i === undefined) i = 'utf8';
					} else {
						i = r;
						r = undefined;
					}
				} else {
					throw new Error(
						'Buffer.write(string, encoding, offset[, length]) is no longer supported'
					);
				}
				const a = this.length - t;
				if (r === undefined || r > a) r = a;
				if ((e.length > 0 && (r < 0 || t < 0)) || t > this.length) {
					throw new RangeError('Attempt to write outside buffer bounds');
				}
				if (!i) i = 'utf8';
				let o = false;
				for (;;) {
					switch (i) {
						case 'hex':
							return hexWrite(this, e, t, r);
						case 'utf8':
						case 'utf-8':
							return utf8Write(this, e, t, r);
						case 'ascii':
						case 'latin1':
						case 'binary':
							return asciiWrite(this, e, t, r);
						case 'base64':
							return base64Write(this, e, t, r);
						case 'ucs2':
						case 'ucs-2':
						case 'utf16le':
						case 'utf-16le':
							return ucs2Write(this, e, t, r);
						default:
							if (o) throw new TypeError('Unknown encoding: ' + i);
							i = ('' + i).toLowerCase();
							o = true;
					}
				}
			};
			Buffer.prototype.toJSON = function toJSON() {
				return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) };
			};
			function base64Slice(e, t, r) {
				if (t === 0 && r === e.length) {
					return i.fromByteArray(e);
				} else {
					return i.fromByteArray(e.slice(t, r));
				}
			}
			function utf8Slice(e, t, r) {
				r = Math.min(e.length, r);
				const i = [];
				let a = t;
				while (a < r) {
					const t = e[a];
					let o = null;
					let c = t > 239 ? 4 : t > 223 ? 3 : t > 191 ? 2 : 1;
					if (a + c <= r) {
						let r, i, u, l;
						switch (c) {
							case 1:
								if (t < 128) {
									o = t;
								}
								break;
							case 2:
								r = e[a + 1];
								if ((r & 192) === 128) {
									l = ((t & 31) << 6) | (r & 63);
									if (l > 127) {
										o = l;
									}
								}
								break;
							case 3:
								r = e[a + 1];
								i = e[a + 2];
								if ((r & 192) === 128 && (i & 192) === 128) {
									l = ((t & 15) << 12) | ((r & 63) << 6) | (i & 63);
									if (l > 2047 && (l < 55296 || l > 57343)) {
										o = l;
									}
								}
								break;
							case 4:
								r = e[a + 1];
								i = e[a + 2];
								u = e[a + 3];
								if ((r & 192) === 128 && (i & 192) === 128 && (u & 192) === 128) {
									l = ((t & 15) << 18) | ((r & 63) << 12) | ((i & 63) << 6) | (u & 63);
									if (l > 65535 && l < 1114112) {
										o = l;
									}
								}
						}
					}
					if (o === null) {
						o = 65533;
						c = 1;
					} else if (o > 65535) {
						o -= 65536;
						i.push(((o >>> 10) & 1023) | 55296);
						o = 56320 | (o & 1023);
					}
					i.push(o);
					a += c;
				}
				return decodeCodePointsArray(i);
			}
			const u = 4096;
			function decodeCodePointsArray(e) {
				const t = e.length;
				if (t <= u) {
					return String.fromCharCode.apply(String, e);
				}
				let r = '';
				let i = 0;
				while (i < t) {
					r += String.fromCharCode.apply(String, e.slice(i, (i += u)));
				}
				return r;
			}
			function asciiSlice(e, t, r) {
				let i = '';
				r = Math.min(e.length, r);
				for (let a = t; a < r; ++a) {
					i += String.fromCharCode(e[a] & 127);
				}
				return i;
			}
			function latin1Slice(e, t, r) {
				let i = '';
				r = Math.min(e.length, r);
				for (let a = t; a < r; ++a) {
					i += String.fromCharCode(e[a]);
				}
				return i;
			}
			function hexSlice(e, t, r) {
				const i = e.length;
				if (!t || t < 0) t = 0;
				if (!r || r < 0 || r > i) r = i;
				let a = '';
				for (let i = t; i < r; ++i) {
					a += p[e[i]];
				}
				return a;
			}
			function utf16leSlice(e, t, r) {
				const i = e.slice(t, r);
				let a = '';
				for (let e = 0; e < i.length - 1; e += 2) {
					a += String.fromCharCode(i[e] + i[e + 1] * 256);
				}
				return a;
			}
			Buffer.prototype.slice = function slice(e, t) {
				const r = this.length;
				e = ~~e;
				t = t === undefined ? r : ~~t;
				if (e < 0) {
					e += r;
					if (e < 0) e = 0;
				} else if (e > r) {
					e = r;
				}
				if (t < 0) {
					t += r;
					if (t < 0) t = 0;
				} else if (t > r) {
					t = r;
				}
				if (t < e) t = e;
				const i = this.subarray(e, t);
				Object.setPrototypeOf(i, Buffer.prototype);
				return i;
			};
			function checkOffset(e, t, r) {
				if (e % 1 !== 0 || e < 0) throw new RangeError('offset is not uint');
				if (e + t > r) throw new RangeError('Trying to access beyond buffer length');
			}
			Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(e, t, r) {
				e = e >>> 0;
				t = t >>> 0;
				if (!r) checkOffset(e, t, this.length);
				let i = this[e];
				let a = 1;
				let o = 0;
				while (++o < t && (a *= 256)) {
					i += this[e + o] * a;
				}
				return i;
			};
			Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(e, t, r) {
				e = e >>> 0;
				t = t >>> 0;
				if (!r) {
					checkOffset(e, t, this.length);
				}
				let i = this[e + --t];
				let a = 1;
				while (t > 0 && (a *= 256)) {
					i += this[e + --t] * a;
				}
				return i;
			};
			Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(e, t) {
				e = e >>> 0;
				if (!t) checkOffset(e, 1, this.length);
				return this[e];
			};
			Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(e, t) {
				e = e >>> 0;
				if (!t) checkOffset(e, 2, this.length);
				return this[e] | (this[e + 1] << 8);
			};
			Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(e, t) {
				e = e >>> 0;
				if (!t) checkOffset(e, 2, this.length);
				return (this[e] << 8) | this[e + 1];
			};
			Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(e, t) {
				e = e >>> 0;
				if (!t) checkOffset(e, 4, this.length);
				return (this[e] | (this[e + 1] << 8) | (this[e + 2] << 16)) + this[e + 3] * 16777216;
			};
			Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(e, t) {
				e = e >>> 0;
				if (!t) checkOffset(e, 4, this.length);
				return this[e] * 16777216 + ((this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3]);
			};
			Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(e) {
				e = e >>> 0;
				validateNumber(e, 'offset');
				const t = this[e];
				const r = this[e + 7];
				if (t === undefined || r === undefined) {
					boundsError(e, this.length - 8);
				}
				const i = t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24;
				const a = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + r * 2 ** 24;
				return BigInt(i) + (BigInt(a) << BigInt(32));
			});
			Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(e) {
				e = e >>> 0;
				validateNumber(e, 'offset');
				const t = this[e];
				const r = this[e + 7];
				if (t === undefined || r === undefined) {
					boundsError(e, this.length - 8);
				}
				const i = t * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
				const a = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + r;
				return (BigInt(i) << BigInt(32)) + BigInt(a);
			});
			Buffer.prototype.readIntLE = function readIntLE(e, t, r) {
				e = e >>> 0;
				t = t >>> 0;
				if (!r) checkOffset(e, t, this.length);
				let i = this[e];
				let a = 1;
				let o = 0;
				while (++o < t && (a *= 256)) {
					i += this[e + o] * a;
				}
				a *= 128;
				if (i >= a) i -= Math.pow(2, 8 * t);
				return i;
			};
			Buffer.prototype.readIntBE = function readIntBE(e, t, r) {
				e = e >>> 0;
				t = t >>> 0;
				if (!r) checkOffset(e, t, this.length);
				let i = t;
				let a = 1;
				let o = this[e + --i];
				while (i > 0 && (a *= 256)) {
					o += this[e + --i] * a;
				}
				a *= 128;
				if (o >= a) o -= Math.pow(2, 8 * t);
				return o;
			};
			Buffer.prototype.readInt8 = function readInt8(e, t) {
				e = e >>> 0;
				if (!t) checkOffset(e, 1, this.length);
				if (!(this[e] & 128)) return this[e];
				return (255 - this[e] + 1) * -1;
			};
			Buffer.prototype.readInt16LE = function readInt16LE(e, t) {
				e = e >>> 0;
				if (!t) checkOffset(e, 2, this.length);
				const r = this[e] | (this[e + 1] << 8);
				return r & 32768 ? r | 4294901760 : r;
			};
			Buffer.prototype.readInt16BE = function readInt16BE(e, t) {
				e = e >>> 0;
				if (!t) checkOffset(e, 2, this.length);
				const r = this[e + 1] | (this[e] << 8);
				return r & 32768 ? r | 4294901760 : r;
			};
			Buffer.prototype.readInt32LE = function readInt32LE(e, t) {
				e = e >>> 0;
				if (!t) checkOffset(e, 4, this.length);
				return this[e] | (this[e + 1] << 8) | (this[e + 2] << 16) | (this[e + 3] << 24);
			};
			Buffer.prototype.readInt32BE = function readInt32BE(e, t) {
				e = e >>> 0;
				if (!t) checkOffset(e, 4, this.length);
				return (this[e] << 24) | (this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3];
			};
			Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(e) {
				e = e >>> 0;
				validateNumber(e, 'offset');
				const t = this[e];
				const r = this[e + 7];
				if (t === undefined || r === undefined) {
					boundsError(e, this.length - 8);
				}
				const i = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (r << 24);
				return (
					(BigInt(i) << BigInt(32)) +
					BigInt(t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24)
				);
			});
			Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(e) {
				e = e >>> 0;
				validateNumber(e, 'offset');
				const t = this[e];
				const r = this[e + 7];
				if (t === undefined || r === undefined) {
					boundsError(e, this.length - 8);
				}
				const i = (t << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
				return (
					(BigInt(i) << BigInt(32)) +
					BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + r)
				);
			});
			Buffer.prototype.readFloatLE = function readFloatLE(e, t) {
				e = e >>> 0;
				if (!t) checkOffset(e, 4, this.length);
				return a.read(this, e, true, 23, 4);
			};
			Buffer.prototype.readFloatBE = function readFloatBE(e, t) {
				e = e >>> 0;
				if (!t) checkOffset(e, 4, this.length);
				return a.read(this, e, false, 23, 4);
			};
			Buffer.prototype.readDoubleLE = function readDoubleLE(e, t) {
				e = e >>> 0;
				if (!t) checkOffset(e, 8, this.length);
				return a.read(this, e, true, 52, 8);
			};
			Buffer.prototype.readDoubleBE = function readDoubleBE(e, t) {
				e = e >>> 0;
				if (!t) checkOffset(e, 8, this.length);
				return a.read(this, e, false, 52, 8);
			};
			function checkInt(e, t, r, i, a, o) {
				if (!Buffer.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
				if (t > a || t < o) throw new RangeError('"value" argument is out of bounds');
				if (r + i > e.length) throw new RangeError('Index out of range');
			}
			Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(
				e,
				t,
				r,
				i
			) {
				e = +e;
				t = t >>> 0;
				r = r >>> 0;
				if (!i) {
					const i = Math.pow(2, 8 * r) - 1;
					checkInt(this, e, t, r, i, 0);
				}
				let a = 1;
				let o = 0;
				this[t] = e & 255;
				while (++o < r && (a *= 256)) {
					this[t + o] = (e / a) & 255;
				}
				return t + r;
			};
			Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(
				e,
				t,
				r,
				i
			) {
				e = +e;
				t = t >>> 0;
				r = r >>> 0;
				if (!i) {
					const i = Math.pow(2, 8 * r) - 1;
					checkInt(this, e, t, r, i, 0);
				}
				let a = r - 1;
				let o = 1;
				this[t + a] = e & 255;
				while (--a >= 0 && (o *= 256)) {
					this[t + a] = (e / o) & 255;
				}
				return t + r;
			};
			Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(e, t, r) {
				e = +e;
				t = t >>> 0;
				if (!r) checkInt(this, e, t, 1, 255, 0);
				this[t] = e & 255;
				return t + 1;
			};
			Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(
				e,
				t,
				r
			) {
				e = +e;
				t = t >>> 0;
				if (!r) checkInt(this, e, t, 2, 65535, 0);
				this[t] = e & 255;
				this[t + 1] = e >>> 8;
				return t + 2;
			};
			Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(
				e,
				t,
				r
			) {
				e = +e;
				t = t >>> 0;
				if (!r) checkInt(this, e, t, 2, 65535, 0);
				this[t] = e >>> 8;
				this[t + 1] = e & 255;
				return t + 2;
			};
			Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(
				e,
				t,
				r
			) {
				e = +e;
				t = t >>> 0;
				if (!r) checkInt(this, e, t, 4, 4294967295, 0);
				this[t + 3] = e >>> 24;
				this[t + 2] = e >>> 16;
				this[t + 1] = e >>> 8;
				this[t] = e & 255;
				return t + 4;
			};
			Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(
				e,
				t,
				r
			) {
				e = +e;
				t = t >>> 0;
				if (!r) checkInt(this, e, t, 4, 4294967295, 0);
				this[t] = e >>> 24;
				this[t + 1] = e >>> 16;
				this[t + 2] = e >>> 8;
				this[t + 3] = e & 255;
				return t + 4;
			};
			function wrtBigUInt64LE(e, t, r, i, a) {
				checkIntBI(t, i, a, e, r, 7);
				let o = Number(t & BigInt(4294967295));
				e[r++] = o;
				o = o >> 8;
				e[r++] = o;
				o = o >> 8;
				e[r++] = o;
				o = o >> 8;
				e[r++] = o;
				let c = Number((t >> BigInt(32)) & BigInt(4294967295));
				e[r++] = c;
				c = c >> 8;
				e[r++] = c;
				c = c >> 8;
				e[r++] = c;
				c = c >> 8;
				e[r++] = c;
				return r;
			}
			function wrtBigUInt64BE(e, t, r, i, a) {
				checkIntBI(t, i, a, e, r, 7);
				let o = Number(t & BigInt(4294967295));
				e[r + 7] = o;
				o = o >> 8;
				e[r + 6] = o;
				o = o >> 8;
				e[r + 5] = o;
				o = o >> 8;
				e[r + 4] = o;
				let c = Number((t >> BigInt(32)) & BigInt(4294967295));
				e[r + 3] = c;
				c = c >> 8;
				e[r + 2] = c;
				c = c >> 8;
				e[r + 1] = c;
				c = c >> 8;
				e[r] = c;
				return r + 8;
			}
			Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(e, t = 0) {
				return wrtBigUInt64LE(this, e, t, BigInt(0), BigInt('0xffffffffffffffff'));
			});
			Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(e, t = 0) {
				return wrtBigUInt64BE(this, e, t, BigInt(0), BigInt('0xffffffffffffffff'));
			});
			Buffer.prototype.writeIntLE = function writeIntLE(e, t, r, i) {
				e = +e;
				t = t >>> 0;
				if (!i) {
					const i = Math.pow(2, 8 * r - 1);
					checkInt(this, e, t, r, i - 1, -i);
				}
				let a = 0;
				let o = 1;
				let c = 0;
				this[t] = e & 255;
				while (++a < r && (o *= 256)) {
					if (e < 0 && c === 0 && this[t + a - 1] !== 0) {
						c = 1;
					}
					this[t + a] = (((e / o) >> 0) - c) & 255;
				}
				return t + r;
			};
			Buffer.prototype.writeIntBE = function writeIntBE(e, t, r, i) {
				e = +e;
				t = t >>> 0;
				if (!i) {
					const i = Math.pow(2, 8 * r - 1);
					checkInt(this, e, t, r, i - 1, -i);
				}
				let a = r - 1;
				let o = 1;
				let c = 0;
				this[t + a] = e & 255;
				while (--a >= 0 && (o *= 256)) {
					if (e < 0 && c === 0 && this[t + a + 1] !== 0) {
						c = 1;
					}
					this[t + a] = (((e / o) >> 0) - c) & 255;
				}
				return t + r;
			};
			Buffer.prototype.writeInt8 = function writeInt8(e, t, r) {
				e = +e;
				t = t >>> 0;
				if (!r) checkInt(this, e, t, 1, 127, -128);
				if (e < 0) e = 255 + e + 1;
				this[t] = e & 255;
				return t + 1;
			};
			Buffer.prototype.writeInt16LE = function writeInt16LE(e, t, r) {
				e = +e;
				t = t >>> 0;
				if (!r) checkInt(this, e, t, 2, 32767, -32768);
				this[t] = e & 255;
				this[t + 1] = e >>> 8;
				return t + 2;
			};
			Buffer.prototype.writeInt16BE = function writeInt16BE(e, t, r) {
				e = +e;
				t = t >>> 0;
				if (!r) checkInt(this, e, t, 2, 32767, -32768);
				this[t] = e >>> 8;
				this[t + 1] = e & 255;
				return t + 2;
			};
			Buffer.prototype.writeInt32LE = function writeInt32LE(e, t, r) {
				e = +e;
				t = t >>> 0;
				if (!r) checkInt(this, e, t, 4, 2147483647, -2147483648);
				this[t] = e & 255;
				this[t + 1] = e >>> 8;
				this[t + 2] = e >>> 16;
				this[t + 3] = e >>> 24;
				return t + 4;
			};
			Buffer.prototype.writeInt32BE = function writeInt32BE(e, t, r) {
				e = +e;
				t = t >>> 0;
				if (!r) checkInt(this, e, t, 4, 2147483647, -2147483648);
				if (e < 0) e = 4294967295 + e + 1;
				this[t] = e >>> 24;
				this[t + 1] = e >>> 16;
				this[t + 2] = e >>> 8;
				this[t + 3] = e & 255;
				return t + 4;
			};
			Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(e, t = 0) {
				return wrtBigUInt64LE(
					this,
					e,
					t,
					-BigInt('0x8000000000000000'),
					BigInt('0x7fffffffffffffff')
				);
			});
			Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(e, t = 0) {
				return wrtBigUInt64BE(
					this,
					e,
					t,
					-BigInt('0x8000000000000000'),
					BigInt('0x7fffffffffffffff')
				);
			});
			function checkIEEE754(e, t, r, i, a, o) {
				if (r + i > e.length) throw new RangeError('Index out of range');
				if (r < 0) throw new RangeError('Index out of range');
			}
			function writeFloat(e, t, r, i, o) {
				t = +t;
				r = r >>> 0;
				if (!o) {
					checkIEEE754(e, t, r, 4, 34028234663852886e22, -34028234663852886e22);
				}
				a.write(e, t, r, i, 23, 4);
				return r + 4;
			}
			Buffer.prototype.writeFloatLE = function writeFloatLE(e, t, r) {
				return writeFloat(this, e, t, true, r);
			};
			Buffer.prototype.writeFloatBE = function writeFloatBE(e, t, r) {
				return writeFloat(this, e, t, false, r);
			};
			function writeDouble(e, t, r, i, o) {
				t = +t;
				r = r >>> 0;
				if (!o) {
					checkIEEE754(e, t, r, 8, 17976931348623157e292, -17976931348623157e292);
				}
				a.write(e, t, r, i, 52, 8);
				return r + 8;
			}
			Buffer.prototype.writeDoubleLE = function writeDoubleLE(e, t, r) {
				return writeDouble(this, e, t, true, r);
			};
			Buffer.prototype.writeDoubleBE = function writeDoubleBE(e, t, r) {
				return writeDouble(this, e, t, false, r);
			};
			Buffer.prototype.copy = function copy(e, t, r, i) {
				if (!Buffer.isBuffer(e)) throw new TypeError('argument should be a Buffer');
				if (!r) r = 0;
				if (!i && i !== 0) i = this.length;
				if (t >= e.length) t = e.length;
				if (!t) t = 0;
				if (i > 0 && i < r) i = r;
				if (i === r) return 0;
				if (e.length === 0 || this.length === 0) return 0;
				if (t < 0) {
					throw new RangeError('targetStart out of bounds');
				}
				if (r < 0 || r >= this.length) throw new RangeError('Index out of range');
				if (i < 0) throw new RangeError('sourceEnd out of bounds');
				if (i > this.length) i = this.length;
				if (e.length - t < i - r) {
					i = e.length - t + r;
				}
				const a = i - r;
				if (this === e && typeof Uint8Array.prototype.copyWithin === 'function') {
					this.copyWithin(t, r, i);
				} else {
					Uint8Array.prototype.set.call(e, this.subarray(r, i), t);
				}
				return a;
			};
			Buffer.prototype.fill = function fill(e, t, r, i) {
				if (typeof e === 'string') {
					if (typeof t === 'string') {
						i = t;
						t = 0;
						r = this.length;
					} else if (typeof r === 'string') {
						i = r;
						r = this.length;
					}
					if (i !== undefined && typeof i !== 'string') {
						throw new TypeError('encoding must be a string');
					}
					if (typeof i === 'string' && !Buffer.isEncoding(i)) {
						throw new TypeError('Unknown encoding: ' + i);
					}
					if (e.length === 1) {
						const t = e.charCodeAt(0);
						if ((i === 'utf8' && t < 128) || i === 'latin1') {
							e = t;
						}
					}
				} else if (typeof e === 'number') {
					e = e & 255;
				} else if (typeof e === 'boolean') {
					e = Number(e);
				}
				if (t < 0 || this.length < t || this.length < r) {
					throw new RangeError('Out of range index');
				}
				if (r <= t) {
					return this;
				}
				t = t >>> 0;
				r = r === undefined ? this.length : r >>> 0;
				if (!e) e = 0;
				let a;
				if (typeof e === 'number') {
					for (a = t; a < r; ++a) {
						this[a] = e;
					}
				} else {
					const o = Buffer.isBuffer(e) ? e : Buffer.from(e, i);
					const c = o.length;
					if (c === 0) {
						throw new TypeError('The value "' + e + '" is invalid for argument "value"');
					}
					for (a = 0; a < r - t; ++a) {
						this[a + t] = o[a % c];
					}
				}
				return this;
			};
			const l = {};
			function E(e, t, r) {
				l[e] = class NodeError extends r {
					constructor() {
						super();
						Object.defineProperty(this, 'message', {
							value: t.apply(this, arguments),
							writable: true,
							configurable: true
						});
						this.name = `${this.name} [${e}]`;
						this.stack;
						delete this.name;
					}
					get code() {
						return e;
					}
					set code(e) {
						Object.defineProperty(this, 'code', {
							configurable: true,
							enumerable: true,
							value: e,
							writable: true
						});
					}
					toString() {
						return `${this.name} [${e}]: ${this.message}`;
					}
				};
			}
			E(
				'ERR_BUFFER_OUT_OF_BOUNDS',
				function (e) {
					if (e) {
						return `${e} is outside of buffer bounds`;
					}
					return 'Attempt to access memory outside buffer bounds';
				},
				RangeError
			);
			E(
				'ERR_INVALID_ARG_TYPE',
				function (e, t) {
					return `The "${e}" argument must be of type number. Received type ${typeof t}`;
				},
				TypeError
			);
			E(
				'ERR_OUT_OF_RANGE',
				function (e, t, r) {
					let i = `The value of "${e}" is out of range.`;
					let a = r;
					if (Number.isInteger(r) && Math.abs(r) > 2 ** 32) {
						a = addNumericalSeparator(String(r));
					} else if (typeof r === 'bigint') {
						a = String(r);
						if (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) {
							a = addNumericalSeparator(a);
						}
						a += 'n';
					}
					i += ` It must be ${t}. Received ${a}`;
					return i;
				},
				RangeError
			);
			function addNumericalSeparator(e) {
				let t = '';
				let r = e.length;
				const i = e[0] === '-' ? 1 : 0;
				for (; r >= i + 4; r -= 3) {
					t = `_${e.slice(r - 3, r)}${t}`;
				}
				return `${e.slice(0, r)}${t}`;
			}
			function checkBounds(e, t, r) {
				validateNumber(t, 'offset');
				if (e[t] === undefined || e[t + r] === undefined) {
					boundsError(t, e.length - (r + 1));
				}
			}
			function checkIntBI(e, t, r, i, a, o) {
				if (e > r || e < t) {
					const i = typeof t === 'bigint' ? 'n' : '';
					let a;
					if (o > 3) {
						if (t === 0 || t === BigInt(0)) {
							a = `>= 0${i} and < 2${i} ** ${(o + 1) * 8}${i}`;
						} else {
							a = `>= -(2${i} ** ${(o + 1) * 8 - 1}${i}) and < 2 ** ` + `${(o + 1) * 8 - 1}${i}`;
						}
					} else {
						a = `>= ${t}${i} and <= ${r}${i}`;
					}
					throw new l.ERR_OUT_OF_RANGE('value', a, e);
				}
				checkBounds(i, a, o);
			}
			function validateNumber(e, t) {
				if (typeof e !== 'number') {
					throw new l.ERR_INVALID_ARG_TYPE(t, 'number', e);
				}
			}
			function boundsError(e, t, r) {
				if (Math.floor(e) !== e) {
					validateNumber(e, r);
					throw new l.ERR_OUT_OF_RANGE(r || 'offset', 'an integer', e);
				}
				if (t < 0) {
					throw new l.ERR_BUFFER_OUT_OF_BOUNDS();
				}
				throw new l.ERR_OUT_OF_RANGE(r || 'offset', `>= ${r ? 1 : 0} and <= ${t}`, e);
			}
			const d = /[^+/0-9A-Za-z-_]/g;
			function base64clean(e) {
				e = e.split('=')[0];
				e = e.trim().replace(d, '');
				if (e.length < 2) return '';
				while (e.length % 4 !== 0) {
					e = e + '=';
				}
				return e;
			}
			function utf8ToBytes(e, t) {
				t = t || Infinity;
				let r;
				const i = e.length;
				let a = null;
				const o = [];
				for (let c = 0; c < i; ++c) {
					r = e.charCodeAt(c);
					if (r > 55295 && r < 57344) {
						if (!a) {
							if (r > 56319) {
								if ((t -= 3) > -1) o.push(239, 191, 189);
								continue;
							} else if (c + 1 === i) {
								if ((t -= 3) > -1) o.push(239, 191, 189);
								continue;
							}
							a = r;
							continue;
						}
						if (r < 56320) {
							if ((t -= 3) > -1) o.push(239, 191, 189);
							a = r;
							continue;
						}
						r = (((a - 55296) << 10) | (r - 56320)) + 65536;
					} else if (a) {
						if ((t -= 3) > -1) o.push(239, 191, 189);
					}
					a = null;
					if (r < 128) {
						if ((t -= 1) < 0) break;
						o.push(r);
					} else if (r < 2048) {
						if ((t -= 2) < 0) break;
						o.push((r >> 6) | 192, (r & 63) | 128);
					} else if (r < 65536) {
						if ((t -= 3) < 0) break;
						o.push((r >> 12) | 224, ((r >> 6) & 63) | 128, (r & 63) | 128);
					} else if (r < 1114112) {
						if ((t -= 4) < 0) break;
						o.push((r >> 18) | 240, ((r >> 12) & 63) | 128, ((r >> 6) & 63) | 128, (r & 63) | 128);
					} else {
						throw new Error('Invalid code point');
					}
				}
				return o;
			}
			function asciiToBytes(e) {
				const t = [];
				for (let r = 0; r < e.length; ++r) {
					t.push(e.charCodeAt(r) & 255);
				}
				return t;
			}
			function utf16leToBytes(e, t) {
				let r, i, a;
				const o = [];
				for (let c = 0; c < e.length; ++c) {
					if ((t -= 2) < 0) break;
					r = e.charCodeAt(c);
					i = r >> 8;
					a = r % 256;
					o.push(a);
					o.push(i);
				}
				return o;
			}
			function base64ToBytes(e) {
				return i.toByteArray(base64clean(e));
			}
			function blitBuffer(e, t, r, i) {
				let a;
				for (a = 0; a < i; ++a) {
					if (a + r >= t.length || a >= e.length) break;
					t[a + r] = e[a];
				}
				return a;
			}
			function isInstance(e, t) {
				return (
					e instanceof t ||
					(e != null &&
						e.constructor != null &&
						e.constructor.name != null &&
						e.constructor.name === t.name)
				);
			}
			function numberIsNaN(e) {
				return e !== e;
			}
			const p = (function () {
				const e = '0123456789abcdef';
				const t = new Array(256);
				for (let r = 0; r < 16; ++r) {
					const i = r * 16;
					for (let a = 0; a < 16; ++a) {
						t[i + a] = e[r] + e[a];
					}
				}
				return t;
			})();
			function defineBigIntMethod(e) {
				return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : e;
			}
			function BufferBigIntNotDefined() {
				throw new Error('BigInt not supported');
			}
		},
		8639: (e, t, r) => {
			'use strict';
			var i = r(6608).Buffer;
			var a = r(9191).Transform;
			var o = r(6704).StringDecoder;
			var c = r(1193);
			function CipherBase(e) {
				a.call(this);
				this.hashMode = typeof e === 'string';
				if (this.hashMode) {
					this[e] = this._finalOrDigest;
				} else {
					this['final'] = this._finalOrDigest;
				}
				if (this._final) {
					this.__final = this._final;
					this._final = null;
				}
				this._decoder = null;
				this._encoding = null;
			}
			c(CipherBase, a);
			var u = typeof Uint8Array !== 'undefined';
			var l =
				typeof ArrayBuffer !== 'undefined' &&
				typeof Uint8Array !== 'undefined' &&
				ArrayBuffer.isView &&
				(i.prototype instanceof Uint8Array || i.TYPED_ARRAY_SUPPORT);
			function toBuffer(e, t) {
				if (e instanceof i) {
					return e;
				}
				if (typeof e === 'string') {
					return i.from(e, t);
				}
				if (l && ArrayBuffer.isView(e)) {
					if (e.byteLength === 0) {
						return i.alloc(0);
					}
					var r = i.from(e.buffer, e.byteOffset, e.byteLength);
					if (r.byteLength === e.byteLength) {
						return r;
					}
				}
				if (u && e instanceof Uint8Array) {
					return i.from(e);
				}
				if (
					i.isBuffer(e) &&
					e.constructor &&
					typeof e.constructor.isBuffer === 'function' &&
					e.constructor.isBuffer(e)
				) {
					return i.from(e);
				}
				throw new TypeError(
					'The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.'
				);
			}
			CipherBase.prototype.update = function (e, t, r) {
				var i = toBuffer(e, t);
				var a = this._update(i);
				if (this.hashMode) {
					return this;
				}
				if (r) {
					a = this._toString(a, r);
				}
				return a;
			};
			CipherBase.prototype.setAutoPadding = function () {};
			CipherBase.prototype.getAuthTag = function () {
				throw new Error('trying to get auth tag in unsupported state');
			};
			CipherBase.prototype.setAuthTag = function () {
				throw new Error('trying to set auth tag in unsupported state');
			};
			CipherBase.prototype.setAAD = function () {
				throw new Error('trying to set aad in unsupported state');
			};
			CipherBase.prototype._transform = function (e, t, r) {
				var i;
				try {
					if (this.hashMode) {
						this._update(e);
					} else {
						this.push(this._update(e));
					}
				} catch (e) {
					i = e;
				} finally {
					r(i);
				}
			};
			CipherBase.prototype._flush = function (e) {
				var t;
				try {
					this.push(this.__final());
				} catch (e) {
					t = e;
				}
				e(t);
			};
			CipherBase.prototype._finalOrDigest = function (e) {
				var t = this.__final() || i.alloc(0);
				if (e) {
					t = this._toString(t, e, true);
				}
				return t;
			};
			CipherBase.prototype._toString = function (e, t, r) {
				if (!this._decoder) {
					this._decoder = new o(t);
					this._encoding = t;
				}
				if (this._encoding !== t) {
					throw new Error('cant switch encodings');
				}
				var i = this._decoder.write(e);
				if (r) {
					i += this._decoder.end();
				}
				return i;
			};
			e.exports = CipherBase;
		},
		1556: (e) => {
			function Emitter(e) {
				if (e) {
					return mixin(e);
				}
				this._callbacks = new Map();
			}
			function mixin(e) {
				Object.assign(e, Emitter.prototype);
				e._callbacks = new Map();
				return e;
			}
			Emitter.prototype.on = function (e, t) {
				const r = this._callbacks.get(e) ?? [];
				r.push(t);
				this._callbacks.set(e, r);
				return this;
			};
			Emitter.prototype.once = function (e, t) {
				const on = (...r) => {
					this.off(e, on);
					t.apply(this, r);
				};
				on.fn = t;
				this.on(e, on);
				return this;
			};
			Emitter.prototype.off = function (e, t) {
				if (e === undefined && t === undefined) {
					this._callbacks.clear();
					return this;
				}
				if (t === undefined) {
					this._callbacks.delete(e);
					return this;
				}
				const r = this._callbacks.get(e);
				if (r) {
					for (const [e, i] of r.entries()) {
						if (i === t || i.fn === t) {
							r.splice(e, 1);
							break;
						}
					}
					if (r.length === 0) {
						this._callbacks.delete(e);
					} else {
						this._callbacks.set(e, r);
					}
				}
				return this;
			};
			Emitter.prototype.emit = function (e, ...t) {
				const r = this._callbacks.get(e);
				if (r) {
					const e = [...r];
					for (const r of e) {
						r.apply(this, t);
					}
				}
				return this;
			};
			Emitter.prototype.listeners = function (e) {
				return this._callbacks.get(e) ?? [];
			};
			Emitter.prototype.listenerCount = function (e) {
				if (e) {
					return this.listeners(e).length;
				}
				let t = 0;
				for (const e of this._callbacks.values()) {
					t += e.length;
				}
				return t;
			};
			Emitter.prototype.hasListeners = function (e) {
				return this.listenerCount(e) > 0;
			};
			Emitter.prototype.addEventListener = Emitter.prototype.on;
			Emitter.prototype.removeListener = Emitter.prototype.off;
			Emitter.prototype.removeEventListener = Emitter.prototype.off;
			Emitter.prototype.removeAllListeners = Emitter.prototype.off;
			if (true) {
				e.exports = Emitter;
			}
		},
		1166: (e, t, r) => {
			function isArray(e) {
				if (Array.isArray) {
					return Array.isArray(e);
				}
				return objectToString(e) === '[object Array]';
			}
			t.isArray = isArray;
			function isBoolean(e) {
				return typeof e === 'boolean';
			}
			t.isBoolean = isBoolean;
			function isNull(e) {
				return e === null;
			}
			t.isNull = isNull;
			function isNullOrUndefined(e) {
				return e == null;
			}
			t.isNullOrUndefined = isNullOrUndefined;
			function isNumber(e) {
				return typeof e === 'number';
			}
			t.isNumber = isNumber;
			function isString(e) {
				return typeof e === 'string';
			}
			t.isString = isString;
			function isSymbol(e) {
				return typeof e === 'symbol';
			}
			t.isSymbol = isSymbol;
			function isUndefined(e) {
				return e === void 0;
			}
			t.isUndefined = isUndefined;
			function isRegExp(e) {
				return objectToString(e) === '[object RegExp]';
			}
			t.isRegExp = isRegExp;
			function isObject(e) {
				return typeof e === 'object' && e !== null;
			}
			t.isObject = isObject;
			function isDate(e) {
				return objectToString(e) === '[object Date]';
			}
			t.isDate = isDate;
			function isError(e) {
				return objectToString(e) === '[object Error]' || e instanceof Error;
			}
			t.isError = isError;
			function isFunction(e) {
				return typeof e === 'function';
			}
			t.isFunction = isFunction;
			function isPrimitive(e) {
				return (
					e === null ||
					typeof e === 'boolean' ||
					typeof e === 'number' ||
					typeof e === 'string' ||
					typeof e === 'symbol' ||
					typeof e === 'undefined'
				);
			}
			t.isPrimitive = isPrimitive;
			t.isBuffer = r(6533).Buffer.isBuffer;
			function objectToString(e) {
				return Object.prototype.toString.call(e);
			}
		},
		9520: (e, t, r) => {
			var i = r(6533)['Buffer'];
			var a = r(3071);
			var o = r(3364);
			e.exports = function createECDH(e) {
				return new ECDH(e);
			};
			var c = {
				secp256k1: { name: 'secp256k1', byteLength: 32 },
				secp224r1: { name: 'p224', byteLength: 28 },
				prime256v1: { name: 'p256', byteLength: 32 },
				prime192v1: { name: 'p192', byteLength: 24 },
				ed25519: { name: 'ed25519', byteLength: 32 },
				secp384r1: { name: 'p384', byteLength: 48 },
				secp521r1: { name: 'p521', byteLength: 66 }
			};
			c.p224 = c.secp224r1;
			c.p256 = c.secp256r1 = c.prime256v1;
			c.p192 = c.secp192r1 = c.prime192v1;
			c.p384 = c.secp384r1;
			c.p521 = c.secp521r1;
			function ECDH(e) {
				this.curveType = c[e];
				if (!this.curveType) {
					this.curveType = { name: e };
				}
				this.curve = new a.ec(this.curveType.name);
				this.keys = void 0;
			}
			ECDH.prototype.generateKeys = function (e, t) {
				this.keys = this.curve.genKeyPair();
				return this.getPublicKey(e, t);
			};
			ECDH.prototype.computeSecret = function (e, t, r) {
				t = t || 'utf8';
				if (!i.isBuffer(e)) {
					e = new i(e, t);
				}
				var a = this.curve.keyFromPublic(e).getPublic();
				var o = a.mul(this.keys.getPrivate()).getX();
				return formatReturnValue(o, r, this.curveType.byteLength);
			};
			ECDH.prototype.getPublicKey = function (e, t) {
				var r = this.keys.getPublic(t === 'compressed', true);
				if (t === 'hybrid') {
					if (r[r.length - 1] % 2) {
						r[0] = 7;
					} else {
						r[0] = 6;
					}
				}
				return formatReturnValue(r, e);
			};
			ECDH.prototype.getPrivateKey = function (e) {
				return formatReturnValue(this.keys.getPrivate(), e);
			};
			ECDH.prototype.setPublicKey = function (e, t) {
				t = t || 'utf8';
				if (!i.isBuffer(e)) {
					e = new i(e, t);
				}
				this.keys._importPublic(e);
				return this;
			};
			ECDH.prototype.setPrivateKey = function (e, t) {
				t = t || 'utf8';
				if (!i.isBuffer(e)) {
					e = new i(e, t);
				}
				var r = new o(e);
				r = r.toString(16);
				this.keys = this.curve.genKeyPair();
				this.keys._importPrivate(r);
				return this;
			};
			function formatReturnValue(e, t, r) {
				if (!Array.isArray(e)) {
					e = e.toArray();
				}
				var a = new i(e);
				if (r && a.length < r) {
					var o = new i(r - a.length);
					o.fill(0);
					a = i.concat([o, a]);
				}
				if (!t) {
					return a;
				} else {
					return a.toString(t);
				}
			}
		},
		8955: (e, t, r) => {
			'use strict';
			var i = r(1193);
			var a = r(5035);
			var o = r(3934);
			var c = r(5244);
			var u = r(8639);
			function Hash(e) {
				u.call(this, 'digest');
				this._hash = e;
			}
			i(Hash, u);
			Hash.prototype._update = function (e) {
				this._hash.update(e);
			};
			Hash.prototype._final = function () {
				return this._hash.digest();
			};
			e.exports = function createHash(e) {
				e = e.toLowerCase();
				if (e === 'md5') return new a();
				if (e === 'rmd160' || e === 'ripemd160') return new o();
				return new Hash(c(e));
			};
		},
		6159: (e, t, r) => {
			var i = r(5035);
			e.exports = function (e) {
				return new i().update(e).digest();
			};
		},
		3053: (e, t, r) => {
			'use strict';
			var i = r(1193);
			var a = r(670);
			var o = r(8639);
			var c = r(6608).Buffer;
			var u = r(6159);
			var l = r(3934);
			var d = r(5244);
			var p = c.alloc(128);
			function Hmac(e, t) {
				o.call(this, 'digest');
				if (typeof t === 'string') {
					t = c.from(t);
				}
				var r = e === 'sha512' || e === 'sha384' ? 128 : 64;
				this._alg = e;
				this._key = t;
				if (t.length > r) {
					var i = e === 'rmd160' ? new l() : d(e);
					t = i.update(t).digest();
				} else if (t.length < r) {
					t = c.concat([t, p], r);
				}
				var a = (this._ipad = c.allocUnsafe(r));
				var u = (this._opad = c.allocUnsafe(r));
				for (var m = 0; m < r; m++) {
					a[m] = t[m] ^ 54;
					u[m] = t[m] ^ 92;
				}
				this._hash = e === 'rmd160' ? new l() : d(e);
				this._hash.update(a);
			}
			i(Hmac, o);
			Hmac.prototype._update = function (e) {
				this._hash.update(e);
			};
			Hmac.prototype._final = function () {
				var e = this._hash.digest();
				var t = this._alg === 'rmd160' ? new l() : d(this._alg);
				return t.update(this._opad).update(e).digest();
			};
			e.exports = function createHmac(e, t) {
				e = e.toLowerCase();
				if (e === 'rmd160' || e === 'ripemd160') {
					return new Hmac('rmd160', t);
				}
				if (e === 'md5') {
					return new a(u, t);
				}
				return new Hmac(e, t);
			};
		},
		670: (e, t, r) => {
			'use strict';
			var i = r(1193);
			var a = r(6608).Buffer;
			var o = r(8639);
			var c = a.alloc(128);
			var u = 64;
			function Hmac(e, t) {
				o.call(this, 'digest');
				if (typeof t === 'string') {
					t = a.from(t);
				}
				this._alg = e;
				this._key = t;
				if (t.length > u) {
					t = e(t);
				} else if (t.length < u) {
					t = a.concat([t, c], u);
				}
				var r = (this._ipad = a.allocUnsafe(u));
				var i = (this._opad = a.allocUnsafe(u));
				for (var l = 0; l < u; l++) {
					r[l] = t[l] ^ 54;
					i[l] = t[l] ^ 92;
				}
				this._hash = [r];
			}
			i(Hmac, o);
			Hmac.prototype._update = function (e) {
				this._hash.push(e);
			};
			Hmac.prototype._final = function () {
				var e = this._alg(a.concat(this._hash));
				return this._alg(a.concat([this._opad, e]));
			};
			e.exports = Hmac;
		},
		4215: (e, t, r) => {
			'use strict';
			var i;
			i = i = i = r(2869);
			i = r(8955);
			i = r(3053);
			var a = r(9823);
			var o = Object.keys(a);
			var c = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(o);
			i = function () {
				return c;
			};
			var u = r(3166);
			i = u.pbkdf2;
			i = u.pbkdf2Sync;
			var l = r(8350);
			i = l.Cipher;
			i = l.createCipher;
			i = l.Cipheriv;
			i = l.createCipheriv;
			i = l.Decipher;
			i = l.createDecipher;
			i = l.Decipheriv;
			i = l.createDecipheriv;
			i = l.getCiphers;
			i = l.listCiphers;
			var d = r(8216);
			i = d.DiffieHellmanGroup;
			i = d.createDiffieHellmanGroup;
			i = d.getDiffieHellman;
			i = d.createDiffieHellman;
			i = d.DiffieHellman;
			var p = r(4368);
			i = p.createSign;
			i = p.Sign;
			i = p.createVerify;
			i = p.Verify;
			r(9520);
			var m = r(2211);
			i = m.publicEncrypt;
			i = m.privateEncrypt;
			i = m.publicDecrypt;
			i = m.privateDecrypt;
			var g = r(4925);
			i = g.randomFill;
			i = g.randomFillSync;
			i = function () {
				throw new Error(
					'sorry, createCredentials is not implemented yet\nwe accept pull requests\nhttps://github.com/browserify/crypto-browserify'
				);
			};
			i = {
				DH_CHECK_P_NOT_SAFE_PRIME: 2,
				DH_CHECK_P_NOT_PRIME: 1,
				DH_UNABLE_TO_CHECK_GENERATOR: 4,
				DH_NOT_SUITABLE_GENERATOR: 8,
				NPN_ENABLED: 1,
				ALPN_ENABLED: 1,
				RSA_PKCS1_PADDING: 1,
				RSA_SSLV23_PADDING: 2,
				RSA_NO_PADDING: 3,
				RSA_PKCS1_OAEP_PADDING: 4,
				RSA_X931_PADDING: 5,
				RSA_PKCS1_PSS_PADDING: 6,
				POINT_CONVERSION_COMPRESSED: 2,
				POINT_CONVERSION_UNCOMPRESSED: 4,
				POINT_CONVERSION_HYBRID: 6
			};
		},
		8754: (e, t, r) => {
			'use strict';
			t.utils = r(6012);
			t.Cipher = r(6242);
			t.DES = r(7325);
			t.CBC = r(9015);
			t.EDE = r(2597);
		},
		9015: (e, t, r) => {
			'use strict';
			var i = r(5578);
			var a = r(1193);
			var o = {};
			function CBCState(e) {
				i.equal(e.length, 8, 'Invalid IV length');
				this.iv = new Array(8);
				for (var t = 0; t < this.iv.length; t++) this.iv[t] = e[t];
			}
			function instantiate(e) {
				function CBC(t) {
					e.call(this, t);
					this._cbcInit();
				}
				a(CBC, e);
				var t = Object.keys(o);
				for (var r = 0; r < t.length; r++) {
					var i = t[r];
					CBC.prototype[i] = o[i];
				}
				CBC.create = function create(e) {
					return new CBC(e);
				};
				return CBC;
			}
			t.instantiate = instantiate;
			o._cbcInit = function _cbcInit() {
				var e = new CBCState(this.options.iv);
				this._cbcState = e;
			};
			o._update = function _update(e, t, r, i) {
				var a = this._cbcState;
				var o = this.constructor.super_.prototype;
				var c = a.iv;
				if (this.type === 'encrypt') {
					for (var u = 0; u < this.blockSize; u++) c[u] ^= e[t + u];
					o._update.call(this, c, 0, r, i);
					for (var u = 0; u < this.blockSize; u++) c[u] = r[i + u];
				} else {
					o._update.call(this, e, t, r, i);
					for (var u = 0; u < this.blockSize; u++) r[i + u] ^= c[u];
					for (var u = 0; u < this.blockSize; u++) c[u] = e[t + u];
				}
			};
		},
		6242: (e, t, r) => {
			'use strict';
			var i = r(5578);
			function Cipher(e) {
				this.options = e;
				this.type = this.options.type;
				this.blockSize = 8;
				this._init();
				this.buffer = new Array(this.blockSize);
				this.bufferOff = 0;
				this.padding = e.padding !== false;
			}
			e.exports = Cipher;
			Cipher.prototype._init = function _init() {};
			Cipher.prototype.update = function update(e) {
				if (e.length === 0) return [];
				if (this.type === 'decrypt') return this._updateDecrypt(e);
				else return this._updateEncrypt(e);
			};
			Cipher.prototype._buffer = function _buffer(e, t) {
				var r = Math.min(this.buffer.length - this.bufferOff, e.length - t);
				for (var i = 0; i < r; i++) this.buffer[this.bufferOff + i] = e[t + i];
				this.bufferOff += r;
				return r;
			};
			Cipher.prototype._flushBuffer = function _flushBuffer(e, t) {
				this._update(this.buffer, 0, e, t);
				this.bufferOff = 0;
				return this.blockSize;
			};
			Cipher.prototype._updateEncrypt = function _updateEncrypt(e) {
				var t = 0;
				var r = 0;
				var i = ((this.bufferOff + e.length) / this.blockSize) | 0;
				var a = new Array(i * this.blockSize);
				if (this.bufferOff !== 0) {
					t += this._buffer(e, t);
					if (this.bufferOff === this.buffer.length) r += this._flushBuffer(a, r);
				}
				var o = e.length - ((e.length - t) % this.blockSize);
				for (; t < o; t += this.blockSize) {
					this._update(e, t, a, r);
					r += this.blockSize;
				}
				for (; t < e.length; t++, this.bufferOff++) this.buffer[this.bufferOff] = e[t];
				return a;
			};
			Cipher.prototype._updateDecrypt = function _updateDecrypt(e) {
				var t = 0;
				var r = 0;
				var i = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1;
				var a = new Array(i * this.blockSize);
				for (; i > 0; i--) {
					t += this._buffer(e, t);
					r += this._flushBuffer(a, r);
				}
				t += this._buffer(e, t);
				return a;
			};
			Cipher.prototype.final = function final(e) {
				var t;
				if (e) t = this.update(e);
				var r;
				if (this.type === 'encrypt') r = this._finalEncrypt();
				else r = this._finalDecrypt();
				if (t) return t.concat(r);
				else return r;
			};
			Cipher.prototype._pad = function _pad(e, t) {
				if (t === 0) return false;
				while (t < e.length) e[t++] = 0;
				return true;
			};
			Cipher.prototype._finalEncrypt = function _finalEncrypt() {
				if (!this._pad(this.buffer, this.bufferOff)) return [];
				var e = new Array(this.blockSize);
				this._update(this.buffer, 0, e, 0);
				return e;
			};
			Cipher.prototype._unpad = function _unpad(e) {
				return e;
			};
			Cipher.prototype._finalDecrypt = function _finalDecrypt() {
				i.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
				var e = new Array(this.blockSize);
				this._flushBuffer(e, 0);
				return this._unpad(e);
			};
		},
		7325: (e, t, r) => {
			'use strict';
			var i = r(5578);
			var a = r(1193);
			var o = r(6012);
			var c = r(6242);
			function DESState() {
				this.tmp = new Array(2);
				this.keys = null;
			}
			function DES(e) {
				c.call(this, e);
				var t = new DESState();
				this._desState = t;
				this.deriveKeys(t, e.key);
			}
			a(DES, c);
			e.exports = DES;
			DES.create = function create(e) {
				return new DES(e);
			};
			var u = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
			DES.prototype.deriveKeys = function deriveKeys(e, t) {
				e.keys = new Array(16 * 2);
				i.equal(t.length, this.blockSize, 'Invalid key length');
				var r = o.readUInt32BE(t, 0);
				var a = o.readUInt32BE(t, 4);
				o.pc1(r, a, e.tmp, 0);
				r = e.tmp[0];
				a = e.tmp[1];
				for (var c = 0; c < e.keys.length; c += 2) {
					var l = u[c >>> 1];
					r = o.r28shl(r, l);
					a = o.r28shl(a, l);
					o.pc2(r, a, e.keys, c);
				}
			};
			DES.prototype._update = function _update(e, t, r, i) {
				var a = this._desState;
				var c = o.readUInt32BE(e, t);
				var u = o.readUInt32BE(e, t + 4);
				o.ip(c, u, a.tmp, 0);
				c = a.tmp[0];
				u = a.tmp[1];
				if (this.type === 'encrypt') this._encrypt(a, c, u, a.tmp, 0);
				else this._decrypt(a, c, u, a.tmp, 0);
				c = a.tmp[0];
				u = a.tmp[1];
				o.writeUInt32BE(r, c, i);
				o.writeUInt32BE(r, u, i + 4);
			};
			DES.prototype._pad = function _pad(e, t) {
				if (this.padding === false) {
					return false;
				}
				var r = e.length - t;
				for (var i = t; i < e.length; i++) e[i] = r;
				return true;
			};
			DES.prototype._unpad = function _unpad(e) {
				if (this.padding === false) {
					return e;
				}
				var t = e[e.length - 1];
				for (var r = e.length - t; r < e.length; r++) i.equal(e[r], t);
				return e.slice(0, e.length - t);
			};
			DES.prototype._encrypt = function _encrypt(e, t, r, i, a) {
				var c = t;
				var u = r;
				for (var l = 0; l < e.keys.length; l += 2) {
					var d = e.keys[l];
					var p = e.keys[l + 1];
					o.expand(u, e.tmp, 0);
					d ^= e.tmp[0];
					p ^= e.tmp[1];
					var m = o.substitute(d, p);
					var g = o.permute(m);
					var v = u;
					u = (c ^ g) >>> 0;
					c = v;
				}
				o.rip(u, c, i, a);
			};
			DES.prototype._decrypt = function _decrypt(e, t, r, i, a) {
				var c = r;
				var u = t;
				for (var l = e.keys.length - 2; l >= 0; l -= 2) {
					var d = e.keys[l];
					var p = e.keys[l + 1];
					o.expand(c, e.tmp, 0);
					d ^= e.tmp[0];
					p ^= e.tmp[1];
					var m = o.substitute(d, p);
					var g = o.permute(m);
					var v = c;
					c = (u ^ g) >>> 0;
					u = v;
				}
				o.rip(c, u, i, a);
			};
		},
		2597: (e, t, r) => {
			'use strict';
			var i = r(5578);
			var a = r(1193);
			var o = r(6242);
			var c = r(7325);
			function EDEState(e, t) {
				i.equal(t.length, 24, 'Invalid key length');
				var r = t.slice(0, 8);
				var a = t.slice(8, 16);
				var o = t.slice(16, 24);
				if (e === 'encrypt') {
					this.ciphers = [
						c.create({ type: 'encrypt', key: r }),
						c.create({ type: 'decrypt', key: a }),
						c.create({ type: 'encrypt', key: o })
					];
				} else {
					this.ciphers = [
						c.create({ type: 'decrypt', key: o }),
						c.create({ type: 'encrypt', key: a }),
						c.create({ type: 'decrypt', key: r })
					];
				}
			}
			function EDE(e) {
				o.call(this, e);
				var t = new EDEState(this.type, this.options.key);
				this._edeState = t;
			}
			a(EDE, o);
			e.exports = EDE;
			EDE.create = function create(e) {
				return new EDE(e);
			};
			EDE.prototype._update = function _update(e, t, r, i) {
				var a = this._edeState;
				a.ciphers[0]._update(e, t, r, i);
				a.ciphers[1]._update(r, i, r, i);
				a.ciphers[2]._update(r, i, r, i);
			};
			EDE.prototype._pad = c.prototype._pad;
			EDE.prototype._unpad = c.prototype._unpad;
		},
		6012: (e, t) => {
			'use strict';
			t.readUInt32BE = function readUInt32BE(e, t) {
				var r = (e[0 + t] << 24) | (e[1 + t] << 16) | (e[2 + t] << 8) | e[3 + t];
				return r >>> 0;
			};
			t.writeUInt32BE = function writeUInt32BE(e, t, r) {
				e[0 + r] = t >>> 24;
				e[1 + r] = (t >>> 16) & 255;
				e[2 + r] = (t >>> 8) & 255;
				e[3 + r] = t & 255;
			};
			t.ip = function ip(e, t, r, i) {
				var a = 0;
				var o = 0;
				for (var c = 6; c >= 0; c -= 2) {
					for (var u = 0; u <= 24; u += 8) {
						a <<= 1;
						a |= (t >>> (u + c)) & 1;
					}
					for (var u = 0; u <= 24; u += 8) {
						a <<= 1;
						a |= (e >>> (u + c)) & 1;
					}
				}
				for (var c = 6; c >= 0; c -= 2) {
					for (var u = 1; u <= 25; u += 8) {
						o <<= 1;
						o |= (t >>> (u + c)) & 1;
					}
					for (var u = 1; u <= 25; u += 8) {
						o <<= 1;
						o |= (e >>> (u + c)) & 1;
					}
				}
				r[i + 0] = a >>> 0;
				r[i + 1] = o >>> 0;
			};
			t.rip = function rip(e, t, r, i) {
				var a = 0;
				var o = 0;
				for (var c = 0; c < 4; c++) {
					for (var u = 24; u >= 0; u -= 8) {
						a <<= 1;
						a |= (t >>> (u + c)) & 1;
						a <<= 1;
						a |= (e >>> (u + c)) & 1;
					}
				}
				for (var c = 4; c < 8; c++) {
					for (var u = 24; u >= 0; u -= 8) {
						o <<= 1;
						o |= (t >>> (u + c)) & 1;
						o <<= 1;
						o |= (e >>> (u + c)) & 1;
					}
				}
				r[i + 0] = a >>> 0;
				r[i + 1] = o >>> 0;
			};
			t.pc1 = function pc1(e, t, r, i) {
				var a = 0;
				var o = 0;
				for (var c = 7; c >= 5; c--) {
					for (var u = 0; u <= 24; u += 8) {
						a <<= 1;
						a |= (t >> (u + c)) & 1;
					}
					for (var u = 0; u <= 24; u += 8) {
						a <<= 1;
						a |= (e >> (u + c)) & 1;
					}
				}
				for (var u = 0; u <= 24; u += 8) {
					a <<= 1;
					a |= (t >> (u + c)) & 1;
				}
				for (var c = 1; c <= 3; c++) {
					for (var u = 0; u <= 24; u += 8) {
						o <<= 1;
						o |= (t >> (u + c)) & 1;
					}
					for (var u = 0; u <= 24; u += 8) {
						o <<= 1;
						o |= (e >> (u + c)) & 1;
					}
				}
				for (var u = 0; u <= 24; u += 8) {
					o <<= 1;
					o |= (e >> (u + c)) & 1;
				}
				r[i + 0] = a >>> 0;
				r[i + 1] = o >>> 0;
			};
			t.r28shl = function r28shl(e, t) {
				return ((e << t) & 268435455) | (e >>> (28 - t));
			};
			var r = [
				14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15,
				4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24
			];
			t.pc2 = function pc2(e, t, i, a) {
				var o = 0;
				var c = 0;
				var u = r.length >>> 1;
				for (var l = 0; l < u; l++) {
					o <<= 1;
					o |= (e >>> r[l]) & 1;
				}
				for (var l = u; l < r.length; l++) {
					c <<= 1;
					c |= (t >>> r[l]) & 1;
				}
				i[a + 0] = o >>> 0;
				i[a + 1] = c >>> 0;
			};
			t.expand = function expand(e, t, r) {
				var i = 0;
				var a = 0;
				i = ((e & 1) << 5) | (e >>> 27);
				for (var o = 23; o >= 15; o -= 4) {
					i <<= 6;
					i |= (e >>> o) & 63;
				}
				for (var o = 11; o >= 3; o -= 4) {
					a |= (e >>> o) & 63;
					a <<= 6;
				}
				a |= ((e & 31) << 1) | (e >>> 31);
				t[r + 0] = i >>> 0;
				t[r + 1] = a >>> 0;
			};
			var i = [
				14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9,
				5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7,
				14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12,
				7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13,
				4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6,
				3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10,
				4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7,
				12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1,
				12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3,
				5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
				8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13,
				14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4,
				15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4,
				14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11,
				8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12,
				5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15,
				5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1,
				4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12,
				10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
			];
			t.substitute = function substitute(e, t) {
				var r = 0;
				for (var a = 0; a < 4; a++) {
					var o = (e >>> (18 - a * 6)) & 63;
					var c = i[a * 64 + o];
					r <<= 4;
					r |= c;
				}
				for (var a = 0; a < 4; a++) {
					var o = (t >>> (18 - a * 6)) & 63;
					var c = i[4 * 64 + a * 64 + o];
					r <<= 4;
					r |= c;
				}
				return r >>> 0;
			};
			var a = [
				16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13,
				19, 2, 26, 10, 21, 28, 7
			];
			t.permute = function permute(e) {
				var t = 0;
				for (var r = 0; r < a.length; r++) {
					t <<= 1;
					t |= (e >>> a[r]) & 1;
				}
				return t >>> 0;
			};
			t.padSplit = function padSplit(e, t, r) {
				var i = e.toString(2);
				while (i.length < t) i = '0' + i;
				var a = [];
				for (var o = 0; o < t; o += r) a.push(i.slice(o, o + r));
				return a.join(' ');
			};
		},
		8216: (e, t, r) => {
			var i = r(6533)['Buffer'];
			var a = r(5122);
			var o = r(7821);
			var c = r(9242);
			function getDiffieHellman(e) {
				var t = new i(o[e].prime, 'hex');
				var r = new i(o[e].gen, 'hex');
				return new c(t, r);
			}
			var u = { binary: true, hex: true, base64: true };
			function createDiffieHellman(e, t, r, o) {
				if (i.isBuffer(t) || u[t] === undefined) {
					return createDiffieHellman(e, 'binary', t, r);
				}
				t = t || 'binary';
				o = o || 'binary';
				r = r || new i([2]);
				if (!i.isBuffer(r)) {
					r = new i(r, o);
				}
				if (typeof e === 'number') {
					return new c(a(e, r), r, true);
				}
				if (!i.isBuffer(e)) {
					e = new i(e, t);
				}
				return new c(e, r, true);
			}
			t.DiffieHellmanGroup = t.createDiffieHellmanGroup = t.getDiffieHellman = getDiffieHellman;
			t.createDiffieHellman = t.DiffieHellman = createDiffieHellman;
		},
		9242: (e, t, r) => {
			var i = r(6533)['Buffer'];
			var a = r(3364);
			var o = r(4442);
			var c = new o();
			var u = new a(24);
			var l = new a(11);
			var d = new a(10);
			var p = new a(3);
			var m = new a(7);
			var g = r(5122);
			var v = r(2869);
			e.exports = DH;
			function setPublicKey(e, t) {
				t = t || 'utf8';
				if (!i.isBuffer(e)) {
					e = new i(e, t);
				}
				this._pub = new a(e);
				return this;
			}
			function setPrivateKey(e, t) {
				t = t || 'utf8';
				if (!i.isBuffer(e)) {
					e = new i(e, t);
				}
				this._priv = new a(e);
				return this;
			}
			var y = {};
			function checkPrime(e, t) {
				var r = t.toString('hex');
				var i = [r, e.toString(16)].join('_');
				if (i in y) {
					return y[i];
				}
				var a = 0;
				if (e.isEven() || !g.simpleSieve || !g.fermatTest(e) || !c.test(e)) {
					a += 1;
					if (r === '02' || r === '05') {
						a += 8;
					} else {
						a += 4;
					}
					y[i] = a;
					return a;
				}
				if (!c.test(e.shrn(1))) {
					a += 2;
				}
				var o;
				switch (r) {
					case '02':
						if (e.mod(u).cmp(l)) {
							a += 8;
						}
						break;
					case '05':
						o = e.mod(d);
						if (o.cmp(p) && o.cmp(m)) {
							a += 8;
						}
						break;
					default:
						a += 4;
				}
				y[i] = a;
				return a;
			}
			function DH(e, t, r) {
				this.setGenerator(t);
				this.__prime = new a(e);
				this._prime = a.mont(this.__prime);
				this._primeLen = e.length;
				this._pub = undefined;
				this._priv = undefined;
				this._primeCode = undefined;
				if (r) {
					this.setPublicKey = setPublicKey;
					this.setPrivateKey = setPrivateKey;
				} else {
					this._primeCode = 8;
				}
			}
			Object.defineProperty(DH.prototype, 'verifyError', {
				enumerable: true,
				get: function () {
					if (typeof this._primeCode !== 'number') {
						this._primeCode = checkPrime(this.__prime, this.__gen);
					}
					return this._primeCode;
				}
			});
			DH.prototype.generateKeys = function () {
				if (!this._priv) {
					this._priv = new a(v(this._primeLen));
				}
				this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
				return this.getPublicKey();
			};
			DH.prototype.computeSecret = function (e) {
				e = new a(e);
				e = e.toRed(this._prime);
				var t = e.redPow(this._priv).fromRed();
				var r = new i(t.toArray());
				var o = this.getPrime();
				if (r.length < o.length) {
					var c = new i(o.length - r.length);
					c.fill(0);
					r = i.concat([c, r]);
				}
				return r;
			};
			DH.prototype.getPublicKey = function getPublicKey(e) {
				return formatReturnValue(this._pub, e);
			};
			DH.prototype.getPrivateKey = function getPrivateKey(e) {
				return formatReturnValue(this._priv, e);
			};
			DH.prototype.getPrime = function (e) {
				return formatReturnValue(this.__prime, e);
			};
			DH.prototype.getGenerator = function (e) {
				return formatReturnValue(this._gen, e);
			};
			DH.prototype.setGenerator = function (e, t) {
				t = t || 'utf8';
				if (!i.isBuffer(e)) {
					e = new i(e, t);
				}
				this.__gen = e;
				this._gen = new a(e);
				return this;
			};
			function formatReturnValue(e, t) {
				var r = new i(e.toArray());
				if (!t) {
					return r;
				} else {
					return r.toString(t);
				}
			}
		},
		5122: (e, t, r) => {
			var i = r(2869);
			e.exports = findPrime;
			findPrime.simpleSieve = simpleSieve;
			findPrime.fermatTest = fermatTest;
			var a = r(3364);
			var o = new a(24);
			var c = r(4442);
			var u = new c();
			var l = new a(1);
			var d = new a(2);
			var p = new a(5);
			var m = new a(16);
			var g = new a(8);
			var v = new a(10);
			var y = new a(3);
			var w = new a(7);
			var _ = new a(11);
			var A = new a(4);
			var k = new a(12);
			var N = null;
			function _getPrimes() {
				if (N !== null) return N;
				var e = 1048576;
				var t = [];
				t[0] = 2;
				for (var r = 1, i = 3; i < e; i += 2) {
					var a = Math.ceil(Math.sqrt(i));
					for (var o = 0; o < r && t[o] <= a; o++) if (i % t[o] === 0) break;
					if (r !== o && t[o] <= a) continue;
					t[r++] = i;
				}
				N = t;
				return t;
			}
			function simpleSieve(e) {
				var t = _getPrimes();
				for (var r = 0; r < t.length; r++)
					if (e.modn(t[r]) === 0) {
						if (e.cmpn(t[r]) === 0) {
							return true;
						} else {
							return false;
						}
					}
				return true;
			}
			function fermatTest(e) {
				var t = a.mont(e);
				return d.toRed(t).redPow(e.subn(1)).fromRed().cmpn(1) === 0;
			}
			function findPrime(e, t) {
				if (e < 16) {
					if (t === 2 || t === 5) {
						return new a([140, 123]);
					} else {
						return new a([140, 39]);
					}
				}
				t = new a(t);
				var r, c;
				while (true) {
					r = new a(i(Math.ceil(e / 8)));
					while (r.bitLength() > e) {
						r.ishrn(1);
					}
					if (r.isEven()) {
						r.iadd(l);
					}
					if (!r.testn(1)) {
						r.iadd(d);
					}
					if (!t.cmp(d)) {
						while (r.mod(o).cmp(_)) {
							r.iadd(A);
						}
					} else if (!t.cmp(p)) {
						while (r.mod(v).cmp(y)) {
							r.iadd(A);
						}
					}
					c = r.shrn(1);
					if (
						simpleSieve(c) &&
						simpleSieve(r) &&
						fermatTest(c) &&
						fermatTest(r) &&
						u.test(c) &&
						u.test(r)
					) {
						return r;
					}
				}
			}
		},
		3071: (e, t, r) => {
			'use strict';
			var i = t;
			i.version = r(3718).rE;
			i.utils = r(9185);
			i.rand = r(5442);
			i.curve = r(5228);
			i.curves = r(5366);
			i.ec = r(2961);
			i.eddsa = r(7808);
		},
		4499: (e, t, r) => {
			'use strict';
			var i = r(3364);
			var a = r(9185);
			var o = a.getNAF;
			var c = a.getJSF;
			var u = a.assert;
			function BaseCurve(e, t) {
				this.type = e;
				this.p = new i(t.p, 16);
				this.red = t.prime ? i.red(t.prime) : i.mont(this.p);
				this.zero = new i(0).toRed(this.red);
				this.one = new i(1).toRed(this.red);
				this.two = new i(2).toRed(this.red);
				this.n = t.n && new i(t.n, 16);
				this.g = t.g && this.pointFromJSON(t.g, t.gRed);
				this._wnafT1 = new Array(4);
				this._wnafT2 = new Array(4);
				this._wnafT3 = new Array(4);
				this._wnafT4 = new Array(4);
				this._bitLength = this.n ? this.n.bitLength() : 0;
				var r = this.n && this.p.div(this.n);
				if (!r || r.cmpn(100) > 0) {
					this.redN = null;
				} else {
					this._maxwellTrick = true;
					this.redN = this.n.toRed(this.red);
				}
			}
			e.exports = BaseCurve;
			BaseCurve.prototype.point = function point() {
				throw new Error('Not implemented');
			};
			BaseCurve.prototype.validate = function validate() {
				throw new Error('Not implemented');
			};
			BaseCurve.prototype._fixedNafMul = function _fixedNafMul(e, t) {
				u(e.precomputed);
				var r = e._getDoubles();
				var i = o(t, 1, this._bitLength);
				var a = (1 << (r.step + 1)) - (r.step % 2 === 0 ? 2 : 1);
				a /= 3;
				var c = [];
				var l;
				var d;
				for (l = 0; l < i.length; l += r.step) {
					d = 0;
					for (var p = l + r.step - 1; p >= l; p--) d = (d << 1) + i[p];
					c.push(d);
				}
				var m = this.jpoint(null, null, null);
				var g = this.jpoint(null, null, null);
				for (var v = a; v > 0; v--) {
					for (l = 0; l < c.length; l++) {
						d = c[l];
						if (d === v) g = g.mixedAdd(r.points[l]);
						else if (d === -v) g = g.mixedAdd(r.points[l].neg());
					}
					m = m.add(g);
				}
				return m.toP();
			};
			BaseCurve.prototype._wnafMul = function _wnafMul(e, t) {
				var r = 4;
				var i = e._getNAFPoints(r);
				r = i.wnd;
				var a = i.points;
				var c = o(t, r, this._bitLength);
				var l = this.jpoint(null, null, null);
				for (var d = c.length - 1; d >= 0; d--) {
					for (var p = 0; d >= 0 && c[d] === 0; d--) p++;
					if (d >= 0) p++;
					l = l.dblp(p);
					if (d < 0) break;
					var m = c[d];
					u(m !== 0);
					if (e.type === 'affine') {
						if (m > 0) l = l.mixedAdd(a[(m - 1) >> 1]);
						else l = l.mixedAdd(a[(-m - 1) >> 1].neg());
					} else {
						if (m > 0) l = l.add(a[(m - 1) >> 1]);
						else l = l.add(a[(-m - 1) >> 1].neg());
					}
				}
				return e.type === 'affine' ? l.toP() : l;
			};
			BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(e, t, r, i, a) {
				var u = this._wnafT1;
				var l = this._wnafT2;
				var d = this._wnafT3;
				var p = 0;
				var m;
				var g;
				var v;
				for (m = 0; m < i; m++) {
					v = t[m];
					var y = v._getNAFPoints(e);
					u[m] = y.wnd;
					l[m] = y.points;
				}
				for (m = i - 1; m >= 1; m -= 2) {
					var w = m - 1;
					var _ = m;
					if (u[w] !== 1 || u[_] !== 1) {
						d[w] = o(r[w], u[w], this._bitLength);
						d[_] = o(r[_], u[_], this._bitLength);
						p = Math.max(d[w].length, p);
						p = Math.max(d[_].length, p);
						continue;
					}
					var A = [t[w], null, null, t[_]];
					if (t[w].y.cmp(t[_].y) === 0) {
						A[1] = t[w].add(t[_]);
						A[2] = t[w].toJ().mixedAdd(t[_].neg());
					} else if (t[w].y.cmp(t[_].y.redNeg()) === 0) {
						A[1] = t[w].toJ().mixedAdd(t[_]);
						A[2] = t[w].add(t[_].neg());
					} else {
						A[1] = t[w].toJ().mixedAdd(t[_]);
						A[2] = t[w].toJ().mixedAdd(t[_].neg());
					}
					var k = [-3, -1, -5, -7, 0, 7, 5, 1, 3];
					var N = c(r[w], r[_]);
					p = Math.max(N[0].length, p);
					d[w] = new Array(p);
					d[_] = new Array(p);
					for (g = 0; g < p; g++) {
						var T = N[0][g] | 0;
						var x = N[1][g] | 0;
						d[w][g] = k[(T + 1) * 3 + (x + 1)];
						d[_][g] = 0;
						l[w] = A;
					}
				}
				var B = this.jpoint(null, null, null);
				var P = this._wnafT4;
				for (m = p; m >= 0; m--) {
					var M = 0;
					while (m >= 0) {
						var C = true;
						for (g = 0; g < i; g++) {
							P[g] = d[g][m] | 0;
							if (P[g] !== 0) C = false;
						}
						if (!C) break;
						M++;
						m--;
					}
					if (m >= 0) M++;
					B = B.dblp(M);
					if (m < 0) break;
					for (g = 0; g < i; g++) {
						var I = P[g];
						v;
						if (I === 0) continue;
						else if (I > 0) v = l[g][(I - 1) >> 1];
						else if (I < 0) v = l[g][(-I - 1) >> 1].neg();
						if (v.type === 'affine') B = B.mixedAdd(v);
						else B = B.add(v);
					}
				}
				for (m = 0; m < i; m++) l[m] = null;
				if (a) return B;
				else return B.toP();
			};
			function BasePoint(e, t) {
				this.curve = e;
				this.type = t;
				this.precomputed = null;
			}
			BaseCurve.BasePoint = BasePoint;
			BasePoint.prototype.eq = function eq() {
				throw new Error('Not implemented');
			};
			BasePoint.prototype.validate = function validate() {
				return this.curve.validate(this);
			};
			BaseCurve.prototype.decodePoint = function decodePoint(e, t) {
				e = a.toArray(e, t);
				var r = this.p.byteLength();
				if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * r) {
					if (e[0] === 6) u(e[e.length - 1] % 2 === 0);
					else if (e[0] === 7) u(e[e.length - 1] % 2 === 1);
					var i = this.point(e.slice(1, 1 + r), e.slice(1 + r, 1 + 2 * r));
					return i;
				} else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === r) {
					return this.pointFromX(e.slice(1, 1 + r), e[0] === 3);
				}
				throw new Error('Unknown point format');
			};
			BasePoint.prototype.encodeCompressed = function encodeCompressed(e) {
				return this.encode(e, true);
			};
			BasePoint.prototype._encode = function _encode(e) {
				var t = this.curve.p.byteLength();
				var r = this.getX().toArray('be', t);
				if (e) return [this.getY().isEven() ? 2 : 3].concat(r);
				return [4].concat(r, this.getY().toArray('be', t));
			};
			BasePoint.prototype.encode = function encode(e, t) {
				return a.encode(this._encode(t), e);
			};
			BasePoint.prototype.precompute = function precompute(e) {
				if (this.precomputed) return this;
				var t = { doubles: null, naf: null, beta: null };
				t.naf = this._getNAFPoints(8);
				t.doubles = this._getDoubles(4, e);
				t.beta = this._getBeta();
				this.precomputed = t;
				return this;
			};
			BasePoint.prototype._hasDoubles = function _hasDoubles(e) {
				if (!this.precomputed) return false;
				var t = this.precomputed.doubles;
				if (!t) return false;
				return t.points.length >= Math.ceil((e.bitLength() + 1) / t.step);
			};
			BasePoint.prototype._getDoubles = function _getDoubles(e, t) {
				if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
				var r = [this];
				var i = this;
				for (var a = 0; a < t; a += e) {
					for (var o = 0; o < e; o++) i = i.dbl();
					r.push(i);
				}
				return { step: e, points: r };
			};
			BasePoint.prototype._getNAFPoints = function _getNAFPoints(e) {
				if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
				var t = [this];
				var r = (1 << e) - 1;
				var i = r === 1 ? null : this.dbl();
				for (var a = 1; a < r; a++) t[a] = t[a - 1].add(i);
				return { wnd: e, points: t };
			};
			BasePoint.prototype._getBeta = function _getBeta() {
				return null;
			};
			BasePoint.prototype.dblp = function dblp(e) {
				var t = this;
				for (var r = 0; r < e; r++) t = t.dbl();
				return t;
			};
		},
		3544: (e, t, r) => {
			'use strict';
			var i = r(9185);
			var a = r(3364);
			var o = r(1193);
			var c = r(4499);
			var u = i.assert;
			function EdwardsCurve(e) {
				this.twisted = (e.a | 0) !== 1;
				this.mOneA = this.twisted && (e.a | 0) === -1;
				this.extended = this.mOneA;
				c.call(this, 'edwards', e);
				this.a = new a(e.a, 16).umod(this.red.m);
				this.a = this.a.toRed(this.red);
				this.c = new a(e.c, 16).toRed(this.red);
				this.c2 = this.c.redSqr();
				this.d = new a(e.d, 16).toRed(this.red);
				this.dd = this.d.redAdd(this.d);
				u(!this.twisted || this.c.fromRed().cmpn(1) === 0);
				this.oneC = (e.c | 0) === 1;
			}
			o(EdwardsCurve, c);
			e.exports = EdwardsCurve;
			EdwardsCurve.prototype._mulA = function _mulA(e) {
				if (this.mOneA) return e.redNeg();
				else return this.a.redMul(e);
			};
			EdwardsCurve.prototype._mulC = function _mulC(e) {
				if (this.oneC) return e;
				else return this.c.redMul(e);
			};
			EdwardsCurve.prototype.jpoint = function jpoint(e, t, r, i) {
				return this.point(e, t, r, i);
			};
			EdwardsCurve.prototype.pointFromX = function pointFromX(e, t) {
				e = new a(e, 16);
				if (!e.red) e = e.toRed(this.red);
				var r = e.redSqr();
				var i = this.c2.redSub(this.a.redMul(r));
				var o = this.one.redSub(this.c2.redMul(this.d).redMul(r));
				var c = i.redMul(o.redInvm());
				var u = c.redSqrt();
				if (u.redSqr().redSub(c).cmp(this.zero) !== 0) throw new Error('invalid point');
				var l = u.fromRed().isOdd();
				if ((t && !l) || (!t && l)) u = u.redNeg();
				return this.point(e, u);
			};
			EdwardsCurve.prototype.pointFromY = function pointFromY(e, t) {
				e = new a(e, 16);
				if (!e.red) e = e.toRed(this.red);
				var r = e.redSqr();
				var i = r.redSub(this.c2);
				var o = r.redMul(this.d).redMul(this.c2).redSub(this.a);
				var c = i.redMul(o.redInvm());
				if (c.cmp(this.zero) === 0) {
					if (t) throw new Error('invalid point');
					else return this.point(this.zero, e);
				}
				var u = c.redSqrt();
				if (u.redSqr().redSub(c).cmp(this.zero) !== 0) throw new Error('invalid point');
				if (u.fromRed().isOdd() !== t) u = u.redNeg();
				return this.point(u, e);
			};
			EdwardsCurve.prototype.validate = function validate(e) {
				if (e.isInfinity()) return true;
				e.normalize();
				var t = e.x.redSqr();
				var r = e.y.redSqr();
				var i = t.redMul(this.a).redAdd(r);
				var a = this.c2.redMul(this.one.redAdd(this.d.redMul(t).redMul(r)));
				return i.cmp(a) === 0;
			};
			function Point(e, t, r, i, o) {
				c.BasePoint.call(this, e, 'projective');
				if (t === null && r === null && i === null) {
					this.x = this.curve.zero;
					this.y = this.curve.one;
					this.z = this.curve.one;
					this.t = this.curve.zero;
					this.zOne = true;
				} else {
					this.x = new a(t, 16);
					this.y = new a(r, 16);
					this.z = i ? new a(i, 16) : this.curve.one;
					this.t = o && new a(o, 16);
					if (!this.x.red) this.x = this.x.toRed(this.curve.red);
					if (!this.y.red) this.y = this.y.toRed(this.curve.red);
					if (!this.z.red) this.z = this.z.toRed(this.curve.red);
					if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);
					this.zOne = this.z === this.curve.one;
					if (this.curve.extended && !this.t) {
						this.t = this.x.redMul(this.y);
						if (!this.zOne) this.t = this.t.redMul(this.z.redInvm());
					}
				}
			}
			o(Point, c.BasePoint);
			EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(e) {
				return Point.fromJSON(this, e);
			};
			EdwardsCurve.prototype.point = function point(e, t, r, i) {
				return new Point(this, e, t, r, i);
			};
			Point.fromJSON = function fromJSON(e, t) {
				return new Point(e, t[0], t[1], t[2]);
			};
			Point.prototype.inspect = function inspect() {
				if (this.isInfinity()) return '<EC Point Infinity>';
				return (
					'<EC Point x: ' +
					this.x.fromRed().toString(16, 2) +
					' y: ' +
					this.y.fromRed().toString(16, 2) +
					' z: ' +
					this.z.fromRed().toString(16, 2) +
					'>'
				);
			};
			Point.prototype.isInfinity = function isInfinity() {
				return (
					this.x.cmpn(0) === 0 &&
					(this.y.cmp(this.z) === 0 || (this.zOne && this.y.cmp(this.curve.c) === 0))
				);
			};
			Point.prototype._extDbl = function _extDbl() {
				var e = this.x.redSqr();
				var t = this.y.redSqr();
				var r = this.z.redSqr();
				r = r.redIAdd(r);
				var i = this.curve._mulA(e);
				var a = this.x.redAdd(this.y).redSqr().redISub(e).redISub(t);
				var o = i.redAdd(t);
				var c = o.redSub(r);
				var u = i.redSub(t);
				var l = a.redMul(c);
				var d = o.redMul(u);
				var p = a.redMul(u);
				var m = c.redMul(o);
				return this.curve.point(l, d, m, p);
			};
			Point.prototype._projDbl = function _projDbl() {
				var e = this.x.redAdd(this.y).redSqr();
				var t = this.x.redSqr();
				var r = this.y.redSqr();
				var i;
				var a;
				var o;
				var c;
				var u;
				var l;
				if (this.curve.twisted) {
					c = this.curve._mulA(t);
					var d = c.redAdd(r);
					if (this.zOne) {
						i = e.redSub(t).redSub(r).redMul(d.redSub(this.curve.two));
						a = d.redMul(c.redSub(r));
						o = d.redSqr().redSub(d).redSub(d);
					} else {
						u = this.z.redSqr();
						l = d.redSub(u).redISub(u);
						i = e.redSub(t).redISub(r).redMul(l);
						a = d.redMul(c.redSub(r));
						o = d.redMul(l);
					}
				} else {
					c = t.redAdd(r);
					u = this.curve._mulC(this.z).redSqr();
					l = c.redSub(u).redSub(u);
					i = this.curve._mulC(e.redISub(c)).redMul(l);
					a = this.curve._mulC(c).redMul(t.redISub(r));
					o = c.redMul(l);
				}
				return this.curve.point(i, a, o);
			};
			Point.prototype.dbl = function dbl() {
				if (this.isInfinity()) return this;
				if (this.curve.extended) return this._extDbl();
				else return this._projDbl();
			};
			Point.prototype._extAdd = function _extAdd(e) {
				var t = this.y.redSub(this.x).redMul(e.y.redSub(e.x));
				var r = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x));
				var i = this.t.redMul(this.curve.dd).redMul(e.t);
				var a = this.z.redMul(e.z.redAdd(e.z));
				var o = r.redSub(t);
				var c = a.redSub(i);
				var u = a.redAdd(i);
				var l = r.redAdd(t);
				var d = o.redMul(c);
				var p = u.redMul(l);
				var m = o.redMul(l);
				var g = c.redMul(u);
				return this.curve.point(d, p, g, m);
			};
			Point.prototype._projAdd = function _projAdd(e) {
				var t = this.z.redMul(e.z);
				var r = t.redSqr();
				var i = this.x.redMul(e.x);
				var a = this.y.redMul(e.y);
				var o = this.curve.d.redMul(i).redMul(a);
				var c = r.redSub(o);
				var u = r.redAdd(o);
				var l = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(i).redISub(a);
				var d = t.redMul(c).redMul(l);
				var p;
				var m;
				if (this.curve.twisted) {
					p = t.redMul(u).redMul(a.redSub(this.curve._mulA(i)));
					m = c.redMul(u);
				} else {
					p = t.redMul(u).redMul(a.redSub(i));
					m = this.curve._mulC(c).redMul(u);
				}
				return this.curve.point(d, p, m);
			};
			Point.prototype.add = function add(e) {
				if (this.isInfinity()) return e;
				if (e.isInfinity()) return this;
				if (this.curve.extended) return this._extAdd(e);
				else return this._projAdd(e);
			};
			Point.prototype.mul = function mul(e) {
				if (this._hasDoubles(e)) return this.curve._fixedNafMul(this, e);
				else return this.curve._wnafMul(this, e);
			};
			Point.prototype.mulAdd = function mulAdd(e, t, r) {
				return this.curve._wnafMulAdd(1, [this, t], [e, r], 2, false);
			};
			Point.prototype.jmulAdd = function jmulAdd(e, t, r) {
				return this.curve._wnafMulAdd(1, [this, t], [e, r], 2, true);
			};
			Point.prototype.normalize = function normalize() {
				if (this.zOne) return this;
				var e = this.z.redInvm();
				this.x = this.x.redMul(e);
				this.y = this.y.redMul(e);
				if (this.t) this.t = this.t.redMul(e);
				this.z = this.curve.one;
				this.zOne = true;
				return this;
			};
			Point.prototype.neg = function neg() {
				return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
			};
			Point.prototype.getX = function getX() {
				this.normalize();
				return this.x.fromRed();
			};
			Point.prototype.getY = function getY() {
				this.normalize();
				return this.y.fromRed();
			};
			Point.prototype.eq = function eq(e) {
				return this === e || (this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0);
			};
			Point.prototype.eqXToP = function eqXToP(e) {
				var t = e.toRed(this.curve.red).redMul(this.z);
				if (this.x.cmp(t) === 0) return true;
				var r = e.clone();
				var i = this.curve.redN.redMul(this.z);
				for (;;) {
					r.iadd(this.curve.n);
					if (r.cmp(this.curve.p) >= 0) return false;
					t.redIAdd(i);
					if (this.x.cmp(t) === 0) return true;
				}
			};
			Point.prototype.toP = Point.prototype.normalize;
			Point.prototype.mixedAdd = Point.prototype.add;
		},
		5228: (e, t, r) => {
			'use strict';
			var i = t;
			i.base = r(4499);
			i.short = r(3970);
			i.mont = r(536);
			i.edwards = r(3544);
		},
		536: (e, t, r) => {
			'use strict';
			var i = r(3364);
			var a = r(1193);
			var o = r(4499);
			var c = r(9185);
			function MontCurve(e) {
				o.call(this, 'mont', e);
				this.a = new i(e.a, 16).toRed(this.red);
				this.b = new i(e.b, 16).toRed(this.red);
				this.i4 = new i(4).toRed(this.red).redInvm();
				this.two = new i(2).toRed(this.red);
				this.a24 = this.i4.redMul(this.a.redAdd(this.two));
			}
			a(MontCurve, o);
			e.exports = MontCurve;
			MontCurve.prototype.validate = function validate(e) {
				var t = e.normalize().x;
				var r = t.redSqr();
				var i = r.redMul(t).redAdd(r.redMul(this.a)).redAdd(t);
				var a = i.redSqrt();
				return a.redSqr().cmp(i) === 0;
			};
			function Point(e, t, r) {
				o.BasePoint.call(this, e, 'projective');
				if (t === null && r === null) {
					this.x = this.curve.one;
					this.z = this.curve.zero;
				} else {
					this.x = new i(t, 16);
					this.z = new i(r, 16);
					if (!this.x.red) this.x = this.x.toRed(this.curve.red);
					if (!this.z.red) this.z = this.z.toRed(this.curve.red);
				}
			}
			a(Point, o.BasePoint);
			MontCurve.prototype.decodePoint = function decodePoint(e, t) {
				return this.point(c.toArray(e, t), 1);
			};
			MontCurve.prototype.point = function point(e, t) {
				return new Point(this, e, t);
			};
			MontCurve.prototype.pointFromJSON = function pointFromJSON(e) {
				return Point.fromJSON(this, e);
			};
			Point.prototype.precompute = function precompute() {};
			Point.prototype._encode = function _encode() {
				return this.getX().toArray('be', this.curve.p.byteLength());
			};
			Point.fromJSON = function fromJSON(e, t) {
				return new Point(e, t[0], t[1] || e.one);
			};
			Point.prototype.inspect = function inspect() {
				if (this.isInfinity()) return '<EC Point Infinity>';
				return (
					'<EC Point x: ' +
					this.x.fromRed().toString(16, 2) +
					' z: ' +
					this.z.fromRed().toString(16, 2) +
					'>'
				);
			};
			Point.prototype.isInfinity = function isInfinity() {
				return this.z.cmpn(0) === 0;
			};
			Point.prototype.dbl = function dbl() {
				var e = this.x.redAdd(this.z);
				var t = e.redSqr();
				var r = this.x.redSub(this.z);
				var i = r.redSqr();
				var a = t.redSub(i);
				var o = t.redMul(i);
				var c = a.redMul(i.redAdd(this.curve.a24.redMul(a)));
				return this.curve.point(o, c);
			};
			Point.prototype.add = function add() {
				throw new Error('Not supported on Montgomery curve');
			};
			Point.prototype.diffAdd = function diffAdd(e, t) {
				var r = this.x.redAdd(this.z);
				var i = this.x.redSub(this.z);
				var a = e.x.redAdd(e.z);
				var o = e.x.redSub(e.z);
				var c = o.redMul(r);
				var u = a.redMul(i);
				var l = t.z.redMul(c.redAdd(u).redSqr());
				var d = t.x.redMul(c.redISub(u).redSqr());
				return this.curve.point(l, d);
			};
			Point.prototype.mul = function mul(e) {
				var t = e.clone();
				var r = this;
				var i = this.curve.point(null, null);
				var a = this;
				for (var o = []; t.cmpn(0) !== 0; t.iushrn(1)) o.push(t.andln(1));
				for (var c = o.length - 1; c >= 0; c--) {
					if (o[c] === 0) {
						r = r.diffAdd(i, a);
						i = i.dbl();
					} else {
						i = r.diffAdd(i, a);
						r = r.dbl();
					}
				}
				return i;
			};
			Point.prototype.mulAdd = function mulAdd() {
				throw new Error('Not supported on Montgomery curve');
			};
			Point.prototype.jumlAdd = function jumlAdd() {
				throw new Error('Not supported on Montgomery curve');
			};
			Point.prototype.eq = function eq(e) {
				return this.getX().cmp(e.getX()) === 0;
			};
			Point.prototype.normalize = function normalize() {
				this.x = this.x.redMul(this.z.redInvm());
				this.z = this.curve.one;
				return this;
			};
			Point.prototype.getX = function getX() {
				this.normalize();
				return this.x.fromRed();
			};
		},
		3970: (e, t, r) => {
			'use strict';
			var i = r(9185);
			var a = r(3364);
			var o = r(1193);
			var c = r(4499);
			var u = i.assert;
			function ShortCurve(e) {
				c.call(this, 'short', e);
				this.a = new a(e.a, 16).toRed(this.red);
				this.b = new a(e.b, 16).toRed(this.red);
				this.tinv = this.two.redInvm();
				this.zeroA = this.a.fromRed().cmpn(0) === 0;
				this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
				this.endo = this._getEndomorphism(e);
				this._endoWnafT1 = new Array(4);
				this._endoWnafT2 = new Array(4);
			}
			o(ShortCurve, c);
			e.exports = ShortCurve;
			ShortCurve.prototype._getEndomorphism = function _getEndomorphism(e) {
				if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return;
				var t;
				var r;
				if (e.beta) {
					t = new a(e.beta, 16).toRed(this.red);
				} else {
					var i = this._getEndoRoots(this.p);
					t = i[0].cmp(i[1]) < 0 ? i[0] : i[1];
					t = t.toRed(this.red);
				}
				if (e.lambda) {
					r = new a(e.lambda, 16);
				} else {
					var o = this._getEndoRoots(this.n);
					if (this.g.mul(o[0]).x.cmp(this.g.x.redMul(t)) === 0) {
						r = o[0];
					} else {
						r = o[1];
						u(this.g.mul(r).x.cmp(this.g.x.redMul(t)) === 0);
					}
				}
				var c;
				if (e.basis) {
					c = e.basis.map(function (e) {
						return { a: new a(e.a, 16), b: new a(e.b, 16) };
					});
				} else {
					c = this._getEndoBasis(r);
				}
				return { beta: t, lambda: r, basis: c };
			};
			ShortCurve.prototype._getEndoRoots = function _getEndoRoots(e) {
				var t = e === this.p ? this.red : a.mont(e);
				var r = new a(2).toRed(t).redInvm();
				var i = r.redNeg();
				var o = new a(3).toRed(t).redNeg().redSqrt().redMul(r);
				var c = i.redAdd(o).fromRed();
				var u = i.redSub(o).fromRed();
				return [c, u];
			};
			ShortCurve.prototype._getEndoBasis = function _getEndoBasis(e) {
				var t = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
				var r = e;
				var i = this.n.clone();
				var o = new a(1);
				var c = new a(0);
				var u = new a(0);
				var l = new a(1);
				var d;
				var p;
				var m;
				var g;
				var v;
				var y;
				var w;
				var _ = 0;
				var A;
				var k;
				while (r.cmpn(0) !== 0) {
					var N = i.div(r);
					A = i.sub(N.mul(r));
					k = u.sub(N.mul(o));
					var T = l.sub(N.mul(c));
					if (!m && A.cmp(t) < 0) {
						d = w.neg();
						p = o;
						m = A.neg();
						g = k;
					} else if (m && ++_ === 2) {
						break;
					}
					w = A;
					i = r;
					r = A;
					u = o;
					o = k;
					l = c;
					c = T;
				}
				v = A.neg();
				y = k;
				var x = m.sqr().add(g.sqr());
				var B = v.sqr().add(y.sqr());
				if (B.cmp(x) >= 0) {
					v = d;
					y = p;
				}
				if (m.negative) {
					m = m.neg();
					g = g.neg();
				}
				if (v.negative) {
					v = v.neg();
					y = y.neg();
				}
				return [
					{ a: m, b: g },
					{ a: v, b: y }
				];
			};
			ShortCurve.prototype._endoSplit = function _endoSplit(e) {
				var t = this.endo.basis;
				var r = t[0];
				var i = t[1];
				var a = i.b.mul(e).divRound(this.n);
				var o = r.b.neg().mul(e).divRound(this.n);
				var c = a.mul(r.a);
				var u = o.mul(i.a);
				var l = a.mul(r.b);
				var d = o.mul(i.b);
				var p = e.sub(c).sub(u);
				var m = l.add(d).neg();
				return { k1: p, k2: m };
			};
			ShortCurve.prototype.pointFromX = function pointFromX(e, t) {
				e = new a(e, 16);
				if (!e.red) e = e.toRed(this.red);
				var r = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b);
				var i = r.redSqrt();
				if (i.redSqr().redSub(r).cmp(this.zero) !== 0) throw new Error('invalid point');
				var o = i.fromRed().isOdd();
				if ((t && !o) || (!t && o)) i = i.redNeg();
				return this.point(e, i);
			};
			ShortCurve.prototype.validate = function validate(e) {
				if (e.inf) return true;
				var t = e.x;
				var r = e.y;
				var i = this.a.redMul(t);
				var a = t.redSqr().redMul(t).redIAdd(i).redIAdd(this.b);
				return r.redSqr().redISub(a).cmpn(0) === 0;
			};
			ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(e, t, r) {
				var i = this._endoWnafT1;
				var a = this._endoWnafT2;
				for (var o = 0; o < e.length; o++) {
					var c = this._endoSplit(t[o]);
					var u = e[o];
					var l = u._getBeta();
					if (c.k1.negative) {
						c.k1.ineg();
						u = u.neg(true);
					}
					if (c.k2.negative) {
						c.k2.ineg();
						l = l.neg(true);
					}
					i[o * 2] = u;
					i[o * 2 + 1] = l;
					a[o * 2] = c.k1;
					a[o * 2 + 1] = c.k2;
				}
				var d = this._wnafMulAdd(1, i, a, o * 2, r);
				for (var p = 0; p < o * 2; p++) {
					i[p] = null;
					a[p] = null;
				}
				return d;
			};
			function Point(e, t, r, i) {
				c.BasePoint.call(this, e, 'affine');
				if (t === null && r === null) {
					this.x = null;
					this.y = null;
					this.inf = true;
				} else {
					this.x = new a(t, 16);
					this.y = new a(r, 16);
					if (i) {
						this.x.forceRed(this.curve.red);
						this.y.forceRed(this.curve.red);
					}
					if (!this.x.red) this.x = this.x.toRed(this.curve.red);
					if (!this.y.red) this.y = this.y.toRed(this.curve.red);
					this.inf = false;
				}
			}
			o(Point, c.BasePoint);
			ShortCurve.prototype.point = function point(e, t, r) {
				return new Point(this, e, t, r);
			};
			ShortCurve.prototype.pointFromJSON = function pointFromJSON(e, t) {
				return Point.fromJSON(this, e, t);
			};
			Point.prototype._getBeta = function _getBeta() {
				if (!this.curve.endo) return;
				var e = this.precomputed;
				if (e && e.beta) return e.beta;
				var t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
				if (e) {
					var r = this.curve;
					var endoMul = function (e) {
						return r.point(e.x.redMul(r.endo.beta), e.y);
					};
					e.beta = t;
					t.precomputed = {
						beta: null,
						naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(endoMul) },
						doubles: e.doubles && { step: e.doubles.step, points: e.doubles.points.map(endoMul) }
					};
				}
				return t;
			};
			Point.prototype.toJSON = function toJSON() {
				if (!this.precomputed) return [this.x, this.y];
				return [
					this.x,
					this.y,
					this.precomputed && {
						doubles: this.precomputed.doubles && {
							step: this.precomputed.doubles.step,
							points: this.precomputed.doubles.points.slice(1)
						},
						naf: this.precomputed.naf && {
							wnd: this.precomputed.naf.wnd,
							points: this.precomputed.naf.points.slice(1)
						}
					}
				];
			};
			Point.fromJSON = function fromJSON(e, t, r) {
				if (typeof t === 'string') t = JSON.parse(t);
				var i = e.point(t[0], t[1], r);
				if (!t[2]) return i;
				function obj2point(t) {
					return e.point(t[0], t[1], r);
				}
				var a = t[2];
				i.precomputed = {
					beta: null,
					doubles: a.doubles && {
						step: a.doubles.step,
						points: [i].concat(a.doubles.points.map(obj2point))
					},
					naf: a.naf && { wnd: a.naf.wnd, points: [i].concat(a.naf.points.map(obj2point)) }
				};
				return i;
			};
			Point.prototype.inspect = function inspect() {
				if (this.isInfinity()) return '<EC Point Infinity>';
				return (
					'<EC Point x: ' +
					this.x.fromRed().toString(16, 2) +
					' y: ' +
					this.y.fromRed().toString(16, 2) +
					'>'
				);
			};
			Point.prototype.isInfinity = function isInfinity() {
				return this.inf;
			};
			Point.prototype.add = function add(e) {
				if (this.inf) return e;
				if (e.inf) return this;
				if (this.eq(e)) return this.dbl();
				if (this.neg().eq(e)) return this.curve.point(null, null);
				if (this.x.cmp(e.x) === 0) return this.curve.point(null, null);
				var t = this.y.redSub(e.y);
				if (t.cmpn(0) !== 0) t = t.redMul(this.x.redSub(e.x).redInvm());
				var r = t.redSqr().redISub(this.x).redISub(e.x);
				var i = t.redMul(this.x.redSub(r)).redISub(this.y);
				return this.curve.point(r, i);
			};
			Point.prototype.dbl = function dbl() {
				if (this.inf) return this;
				var e = this.y.redAdd(this.y);
				if (e.cmpn(0) === 0) return this.curve.point(null, null);
				var t = this.curve.a;
				var r = this.x.redSqr();
				var i = e.redInvm();
				var a = r.redAdd(r).redIAdd(r).redIAdd(t).redMul(i);
				var o = a.redSqr().redISub(this.x.redAdd(this.x));
				var c = a.redMul(this.x.redSub(o)).redISub(this.y);
				return this.curve.point(o, c);
			};
			Point.prototype.getX = function getX() {
				return this.x.fromRed();
			};
			Point.prototype.getY = function getY() {
				return this.y.fromRed();
			};
			Point.prototype.mul = function mul(e) {
				e = new a(e, 16);
				if (this.isInfinity()) return this;
				else if (this._hasDoubles(e)) return this.curve._fixedNafMul(this, e);
				else if (this.curve.endo) return this.curve._endoWnafMulAdd([this], [e]);
				else return this.curve._wnafMul(this, e);
			};
			Point.prototype.mulAdd = function mulAdd(e, t, r) {
				var i = [this, t];
				var a = [e, r];
				if (this.curve.endo) return this.curve._endoWnafMulAdd(i, a);
				else return this.curve._wnafMulAdd(1, i, a, 2);
			};
			Point.prototype.jmulAdd = function jmulAdd(e, t, r) {
				var i = [this, t];
				var a = [e, r];
				if (this.curve.endo) return this.curve._endoWnafMulAdd(i, a, true);
				else return this.curve._wnafMulAdd(1, i, a, 2, true);
			};
			Point.prototype.eq = function eq(e) {
				return (
					this === e ||
					(this.inf === e.inf && (this.inf || (this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0)))
				);
			};
			Point.prototype.neg = function neg(e) {
				if (this.inf) return this;
				var t = this.curve.point(this.x, this.y.redNeg());
				if (e && this.precomputed) {
					var r = this.precomputed;
					var negate = function (e) {
						return e.neg();
					};
					t.precomputed = {
						naf: r.naf && { wnd: r.naf.wnd, points: r.naf.points.map(negate) },
						doubles: r.doubles && { step: r.doubles.step, points: r.doubles.points.map(negate) }
					};
				}
				return t;
			};
			Point.prototype.toJ = function toJ() {
				if (this.inf) return this.curve.jpoint(null, null, null);
				var e = this.curve.jpoint(this.x, this.y, this.curve.one);
				return e;
			};
			function JPoint(e, t, r, i) {
				c.BasePoint.call(this, e, 'jacobian');
				if (t === null && r === null && i === null) {
					this.x = this.curve.one;
					this.y = this.curve.one;
					this.z = new a(0);
				} else {
					this.x = new a(t, 16);
					this.y = new a(r, 16);
					this.z = new a(i, 16);
				}
				if (!this.x.red) this.x = this.x.toRed(this.curve.red);
				if (!this.y.red) this.y = this.y.toRed(this.curve.red);
				if (!this.z.red) this.z = this.z.toRed(this.curve.red);
				this.zOne = this.z === this.curve.one;
			}
			o(JPoint, c.BasePoint);
			ShortCurve.prototype.jpoint = function jpoint(e, t, r) {
				return new JPoint(this, e, t, r);
			};
			JPoint.prototype.toP = function toP() {
				if (this.isInfinity()) return this.curve.point(null, null);
				var e = this.z.redInvm();
				var t = e.redSqr();
				var r = this.x.redMul(t);
				var i = this.y.redMul(t).redMul(e);
				return this.curve.point(r, i);
			};
			JPoint.prototype.neg = function neg() {
				return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
			};
			JPoint.prototype.add = function add(e) {
				if (this.isInfinity()) return e;
				if (e.isInfinity()) return this;
				var t = e.z.redSqr();
				var r = this.z.redSqr();
				var i = this.x.redMul(t);
				var a = e.x.redMul(r);
				var o = this.y.redMul(t.redMul(e.z));
				var c = e.y.redMul(r.redMul(this.z));
				var u = i.redSub(a);
				var l = o.redSub(c);
				if (u.cmpn(0) === 0) {
					if (l.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
					else return this.dbl();
				}
				var d = u.redSqr();
				var p = d.redMul(u);
				var m = i.redMul(d);
				var g = l.redSqr().redIAdd(p).redISub(m).redISub(m);
				var v = l.redMul(m.redISub(g)).redISub(o.redMul(p));
				var y = this.z.redMul(e.z).redMul(u);
				return this.curve.jpoint(g, v, y);
			};
			JPoint.prototype.mixedAdd = function mixedAdd(e) {
				if (this.isInfinity()) return e.toJ();
				if (e.isInfinity()) return this;
				var t = this.z.redSqr();
				var r = this.x;
				var i = e.x.redMul(t);
				var a = this.y;
				var o = e.y.redMul(t).redMul(this.z);
				var c = r.redSub(i);
				var u = a.redSub(o);
				if (c.cmpn(0) === 0) {
					if (u.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
					else return this.dbl();
				}
				var l = c.redSqr();
				var d = l.redMul(c);
				var p = r.redMul(l);
				var m = u.redSqr().redIAdd(d).redISub(p).redISub(p);
				var g = u.redMul(p.redISub(m)).redISub(a.redMul(d));
				var v = this.z.redMul(c);
				return this.curve.jpoint(m, g, v);
			};
			JPoint.prototype.dblp = function dblp(e) {
				if (e === 0) return this;
				if (this.isInfinity()) return this;
				if (!e) return this.dbl();
				var t;
				if (this.curve.zeroA || this.curve.threeA) {
					var r = this;
					for (t = 0; t < e; t++) r = r.dbl();
					return r;
				}
				var i = this.curve.a;
				var a = this.curve.tinv;
				var o = this.x;
				var c = this.y;
				var u = this.z;
				var l = u.redSqr().redSqr();
				var d = c.redAdd(c);
				for (t = 0; t < e; t++) {
					var p = o.redSqr();
					var m = d.redSqr();
					var g = m.redSqr();
					var v = p.redAdd(p).redIAdd(p).redIAdd(i.redMul(l));
					var y = o.redMul(m);
					var w = v.redSqr().redISub(y.redAdd(y));
					var _ = y.redISub(w);
					var A = v.redMul(_);
					A = A.redIAdd(A).redISub(g);
					var k = d.redMul(u);
					if (t + 1 < e) l = l.redMul(g);
					o = w;
					u = k;
					d = A;
				}
				return this.curve.jpoint(o, d.redMul(a), u);
			};
			JPoint.prototype.dbl = function dbl() {
				if (this.isInfinity()) return this;
				if (this.curve.zeroA) return this._zeroDbl();
				else if (this.curve.threeA) return this._threeDbl();
				else return this._dbl();
			};
			JPoint.prototype._zeroDbl = function _zeroDbl() {
				var e;
				var t;
				var r;
				if (this.zOne) {
					var i = this.x.redSqr();
					var a = this.y.redSqr();
					var o = a.redSqr();
					var c = this.x.redAdd(a).redSqr().redISub(i).redISub(o);
					c = c.redIAdd(c);
					var u = i.redAdd(i).redIAdd(i);
					var l = u.redSqr().redISub(c).redISub(c);
					var d = o.redIAdd(o);
					d = d.redIAdd(d);
					d = d.redIAdd(d);
					e = l;
					t = u.redMul(c.redISub(l)).redISub(d);
					r = this.y.redAdd(this.y);
				} else {
					var p = this.x.redSqr();
					var m = this.y.redSqr();
					var g = m.redSqr();
					var v = this.x.redAdd(m).redSqr().redISub(p).redISub(g);
					v = v.redIAdd(v);
					var y = p.redAdd(p).redIAdd(p);
					var w = y.redSqr();
					var _ = g.redIAdd(g);
					_ = _.redIAdd(_);
					_ = _.redIAdd(_);
					e = w.redISub(v).redISub(v);
					t = y.redMul(v.redISub(e)).redISub(_);
					r = this.y.redMul(this.z);
					r = r.redIAdd(r);
				}
				return this.curve.jpoint(e, t, r);
			};
			JPoint.prototype._threeDbl = function _threeDbl() {
				var e;
				var t;
				var r;
				if (this.zOne) {
					var i = this.x.redSqr();
					var a = this.y.redSqr();
					var o = a.redSqr();
					var c = this.x.redAdd(a).redSqr().redISub(i).redISub(o);
					c = c.redIAdd(c);
					var u = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a);
					var l = u.redSqr().redISub(c).redISub(c);
					e = l;
					var d = o.redIAdd(o);
					d = d.redIAdd(d);
					d = d.redIAdd(d);
					t = u.redMul(c.redISub(l)).redISub(d);
					r = this.y.redAdd(this.y);
				} else {
					var p = this.z.redSqr();
					var m = this.y.redSqr();
					var g = this.x.redMul(m);
					var v = this.x.redSub(p).redMul(this.x.redAdd(p));
					v = v.redAdd(v).redIAdd(v);
					var y = g.redIAdd(g);
					y = y.redIAdd(y);
					var w = y.redAdd(y);
					e = v.redSqr().redISub(w);
					r = this.y.redAdd(this.z).redSqr().redISub(m).redISub(p);
					var _ = m.redSqr();
					_ = _.redIAdd(_);
					_ = _.redIAdd(_);
					_ = _.redIAdd(_);
					t = v.redMul(y.redISub(e)).redISub(_);
				}
				return this.curve.jpoint(e, t, r);
			};
			JPoint.prototype._dbl = function _dbl() {
				var e = this.curve.a;
				var t = this.x;
				var r = this.y;
				var i = this.z;
				var a = i.redSqr().redSqr();
				var o = t.redSqr();
				var c = r.redSqr();
				var u = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(a));
				var l = t.redAdd(t);
				l = l.redIAdd(l);
				var d = l.redMul(c);
				var p = u.redSqr().redISub(d.redAdd(d));
				var m = d.redISub(p);
				var g = c.redSqr();
				g = g.redIAdd(g);
				g = g.redIAdd(g);
				g = g.redIAdd(g);
				var v = u.redMul(m).redISub(g);
				var y = r.redAdd(r).redMul(i);
				return this.curve.jpoint(p, v, y);
			};
			JPoint.prototype.trpl = function trpl() {
				if (!this.curve.zeroA) return this.dbl().add(this);
				var e = this.x.redSqr();
				var t = this.y.redSqr();
				var r = this.z.redSqr();
				var i = t.redSqr();
				var a = e.redAdd(e).redIAdd(e);
				var o = a.redSqr();
				var c = this.x.redAdd(t).redSqr().redISub(e).redISub(i);
				c = c.redIAdd(c);
				c = c.redAdd(c).redIAdd(c);
				c = c.redISub(o);
				var u = c.redSqr();
				var l = i.redIAdd(i);
				l = l.redIAdd(l);
				l = l.redIAdd(l);
				l = l.redIAdd(l);
				var d = a.redIAdd(c).redSqr().redISub(o).redISub(u).redISub(l);
				var p = t.redMul(d);
				p = p.redIAdd(p);
				p = p.redIAdd(p);
				var m = this.x.redMul(u).redISub(p);
				m = m.redIAdd(m);
				m = m.redIAdd(m);
				var g = this.y.redMul(d.redMul(l.redISub(d)).redISub(c.redMul(u)));
				g = g.redIAdd(g);
				g = g.redIAdd(g);
				g = g.redIAdd(g);
				var v = this.z.redAdd(c).redSqr().redISub(r).redISub(u);
				return this.curve.jpoint(m, g, v);
			};
			JPoint.prototype.mul = function mul(e, t) {
				e = new a(e, t);
				return this.curve._wnafMul(this, e);
			};
			JPoint.prototype.eq = function eq(e) {
				if (e.type === 'affine') return this.eq(e.toJ());
				if (this === e) return true;
				var t = this.z.redSqr();
				var r = e.z.redSqr();
				if (this.x.redMul(r).redISub(e.x.redMul(t)).cmpn(0) !== 0) return false;
				var i = t.redMul(this.z);
				var a = r.redMul(e.z);
				return this.y.redMul(a).redISub(e.y.redMul(i)).cmpn(0) === 0;
			};
			JPoint.prototype.eqXToP = function eqXToP(e) {
				var t = this.z.redSqr();
				var r = e.toRed(this.curve.red).redMul(t);
				if (this.x.cmp(r) === 0) return true;
				var i = e.clone();
				var a = this.curve.redN.redMul(t);
				for (;;) {
					i.iadd(this.curve.n);
					if (i.cmp(this.curve.p) >= 0) return false;
					r.redIAdd(a);
					if (this.x.cmp(r) === 0) return true;
				}
			};
			JPoint.prototype.inspect = function inspect() {
				if (this.isInfinity()) return '<EC JPoint Infinity>';
				return (
					'<EC JPoint x: ' +
					this.x.toString(16, 2) +
					' y: ' +
					this.y.toString(16, 2) +
					' z: ' +
					this.z.toString(16, 2) +
					'>'
				);
			};
			JPoint.prototype.isInfinity = function isInfinity() {
				return this.z.cmpn(0) === 0;
			};
		},
		5366: (e, t, r) => {
			'use strict';
			var i = t;
			var a = r(1631);
			var o = r(5228);
			var c = r(9185);
			var u = c.assert;
			function PresetCurve(e) {
				if (e.type === 'short') this.curve = new o.short(e);
				else if (e.type === 'edwards') this.curve = new o.edwards(e);
				else this.curve = new o.mont(e);
				this.g = this.curve.g;
				this.n = this.curve.n;
				this.hash = e.hash;
				u(this.g.validate(), 'Invalid curve');
				u(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
			}
			i.PresetCurve = PresetCurve;
			function defineCurve(e, t) {
				Object.defineProperty(i, e, {
					configurable: true,
					enumerable: true,
					get: function () {
						var r = new PresetCurve(t);
						Object.defineProperty(i, e, { configurable: true, enumerable: true, value: r });
						return r;
					}
				});
			}
			defineCurve('p192', {
				type: 'short',
				prime: 'p192',
				p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
				a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
				b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
				n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
				hash: a.sha256,
				gRed: false,
				g: [
					'188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
					'07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
				]
			});
			defineCurve('p224', {
				type: 'short',
				prime: 'p224',
				p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
				a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
				b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
				n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
				hash: a.sha256,
				gRed: false,
				g: [
					'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
					'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
				]
			});
			defineCurve('p256', {
				type: 'short',
				prime: null,
				p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
				a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
				b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
				n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
				hash: a.sha256,
				gRed: false,
				g: [
					'6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
					'4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
				]
			});
			defineCurve('p384', {
				type: 'short',
				prime: null,
				p:
					'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
					'fffffffe ffffffff 00000000 00000000 ffffffff',
				a:
					'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
					'fffffffe ffffffff 00000000 00000000 fffffffc',
				b:
					'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
					'5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
				n:
					'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
					'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
				hash: a.sha384,
				gRed: false,
				g: [
					'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
						'5502f25d bf55296c 3a545e38 72760ab7',
					'3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
						'0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
				]
			});
			defineCurve('p521', {
				type: 'short',
				prime: null,
				p:
					'000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
					'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
					'ffffffff ffffffff ffffffff ffffffff ffffffff',
				a:
					'000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
					'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
					'ffffffff ffffffff ffffffff ffffffff fffffffc',
				b:
					'00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
					'99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
					'3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
				n:
					'000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
					'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
					'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
				hash: a.sha512,
				gRed: false,
				g: [
					'000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
						'053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
						'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
					'00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
						'579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
						'3fad0761 353c7086 a272c240 88be9476 9fd16650'
				]
			});
			defineCurve('curve25519', {
				type: 'mont',
				prime: 'p25519',
				p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
				a: '76d06',
				b: '1',
				n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
				hash: a.sha256,
				gRed: false,
				g: ['9']
			});
			defineCurve('ed25519', {
				type: 'edwards',
				prime: 'p25519',
				p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
				a: '-1',
				c: '1',
				d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
				n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
				hash: a.sha256,
				gRed: false,
				g: [
					'216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',
					'6666666666666666666666666666666666666666666666666666666666666658'
				]
			});
			var l;
			try {
				l = r(7153);
			} catch (e) {
				l = undefined;
			}
			defineCurve('secp256k1', {
				type: 'short',
				prime: 'k256',
				p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
				a: '0',
				b: '7',
				n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
				h: '1',
				hash: a.sha256,
				beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
				lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
				basis: [
					{ a: '3086d221a7d46bcde86c90e49284eb15', b: '-e4437ed6010e88286f547fa90abfe4c3' },
					{ a: '114ca50f7a8e2f3f657c1108d9d44cfd8', b: '3086d221a7d46bcde86c90e49284eb15' }
				],
				gRed: false,
				g: [
					'79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
					'483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
					l
				]
			});
		},
		2961: (e, t, r) => {
			'use strict';
			var i = r(3364);
			var a = r(2519);
			var o = r(9185);
			var c = r(5366);
			var u = r(5442);
			var l = o.assert;
			var d = r(5666);
			var p = r(4375);
			function EC(e) {
				if (!(this instanceof EC)) return new EC(e);
				if (typeof e === 'string') {
					l(Object.prototype.hasOwnProperty.call(c, e), 'Unknown curve ' + e);
					e = c[e];
				}
				if (e instanceof c.PresetCurve) e = { curve: e };
				this.curve = e.curve.curve;
				this.n = this.curve.n;
				this.nh = this.n.ushrn(1);
				this.g = this.curve.g;
				this.g = e.curve.g;
				this.g.precompute(e.curve.n.bitLength() + 1);
				this.hash = e.hash || e.curve.hash;
			}
			e.exports = EC;
			EC.prototype.keyPair = function keyPair(e) {
				return new d(this, e);
			};
			EC.prototype.keyFromPrivate = function keyFromPrivate(e, t) {
				return d.fromPrivate(this, e, t);
			};
			EC.prototype.keyFromPublic = function keyFromPublic(e, t) {
				return d.fromPublic(this, e, t);
			};
			EC.prototype.genKeyPair = function genKeyPair(e) {
				if (!e) e = {};
				var t = new a({
					hash: this.hash,
					pers: e.pers,
					persEnc: e.persEnc || 'utf8',
					entropy: e.entropy || u(this.hash.hmacStrength),
					entropyEnc: (e.entropy && e.entropyEnc) || 'utf8',
					nonce: this.n.toArray()
				});
				var r = this.n.byteLength();
				var o = this.n.sub(new i(2));
				for (;;) {
					var c = new i(t.generate(r));
					if (c.cmp(o) > 0) continue;
					c.iaddn(1);
					return this.keyFromPrivate(c);
				}
			};
			EC.prototype._truncateToN = function _truncateToN(e, t, r) {
				var a;
				if (i.isBN(e) || typeof e === 'number') {
					e = new i(e, 16);
					a = e.byteLength();
				} else if (typeof e === 'object') {
					a = e.length;
					e = new i(e, 16);
				} else {
					var o = e.toString();
					a = (o.length + 1) >>> 1;
					e = new i(o, 16);
				}
				if (typeof r !== 'number') {
					r = a * 8;
				}
				var c = r - this.n.bitLength();
				if (c > 0) e = e.ushrn(c);
				if (!t && e.cmp(this.n) >= 0) return e.sub(this.n);
				else return e;
			};
			EC.prototype.sign = function sign(e, t, r, o) {
				if (typeof r === 'object') {
					o = r;
					r = null;
				}
				if (!o) o = {};
				if (typeof e !== 'string' && typeof e !== 'number' && !i.isBN(e)) {
					l(
						typeof e === 'object' && e && typeof e.length === 'number',
						'Expected message to be an array-like, a hex string, or a BN instance'
					);
					l(e.length >>> 0 === e.length);
					for (var c = 0; c < e.length; c++) l((e[c] & 255) === e[c]);
				}
				t = this.keyFromPrivate(t, r);
				e = this._truncateToN(e, false, o.msgBitLength);
				l(!e.isNeg(), 'Can not sign a negative message');
				var u = this.n.byteLength();
				var d = t.getPrivate().toArray('be', u);
				var m = e.toArray('be', u);
				l(new i(m).eq(e), 'Can not sign message');
				var g = new a({
					hash: this.hash,
					entropy: d,
					nonce: m,
					pers: o.pers,
					persEnc: o.persEnc || 'utf8'
				});
				var v = this.n.sub(new i(1));
				for (var y = 0; ; y++) {
					var w = o.k ? o.k(y) : new i(g.generate(this.n.byteLength()));
					w = this._truncateToN(w, true);
					if (w.cmpn(1) <= 0 || w.cmp(v) >= 0) continue;
					var _ = this.g.mul(w);
					if (_.isInfinity()) continue;
					var A = _.getX();
					var k = A.umod(this.n);
					if (k.cmpn(0) === 0) continue;
					var N = w.invm(this.n).mul(k.mul(t.getPrivate()).iadd(e));
					N = N.umod(this.n);
					if (N.cmpn(0) === 0) continue;
					var T = (_.getY().isOdd() ? 1 : 0) | (A.cmp(k) !== 0 ? 2 : 0);
					if (o.canonical && N.cmp(this.nh) > 0) {
						N = this.n.sub(N);
						T ^= 1;
					}
					return new p({ r: k, s: N, recoveryParam: T });
				}
			};
			EC.prototype.verify = function verify(e, t, r, i, a) {
				if (!a) a = {};
				e = this._truncateToN(e, false, a.msgBitLength);
				r = this.keyFromPublic(r, i);
				t = new p(t, 'hex');
				var o = t.r;
				var c = t.s;
				if (o.cmpn(1) < 0 || o.cmp(this.n) >= 0) return false;
				if (c.cmpn(1) < 0 || c.cmp(this.n) >= 0) return false;
				var u = c.invm(this.n);
				var l = u.mul(e).umod(this.n);
				var d = u.mul(o).umod(this.n);
				var m;
				if (!this.curve._maxwellTrick) {
					m = this.g.mulAdd(l, r.getPublic(), d);
					if (m.isInfinity()) return false;
					return m.getX().umod(this.n).cmp(o) === 0;
				}
				m = this.g.jmulAdd(l, r.getPublic(), d);
				if (m.isInfinity()) return false;
				return m.eqXToP(o);
			};
			EC.prototype.recoverPubKey = function (e, t, r, a) {
				l((3 & r) === r, 'The recovery param is more than two bits');
				t = new p(t, a);
				var o = this.n;
				var c = new i(e);
				var u = t.r;
				var d = t.s;
				var m = r & 1;
				var g = r >> 1;
				if (u.cmp(this.curve.p.umod(this.curve.n)) >= 0 && g)
					throw new Error('Unable to find sencond key candinate');
				if (g) u = this.curve.pointFromX(u.add(this.curve.n), m);
				else u = this.curve.pointFromX(u, m);
				var v = t.r.invm(o);
				var y = o.sub(c).mul(v).umod(o);
				var w = d.mul(v).umod(o);
				return this.g.mulAdd(y, u, w);
			};
			EC.prototype.getKeyRecoveryParam = function (e, t, r, i) {
				t = new p(t, i);
				if (t.recoveryParam !== null) return t.recoveryParam;
				for (var a = 0; a < 4; a++) {
					var o;
					try {
						o = this.recoverPubKey(e, t, a);
					} catch (e) {
						continue;
					}
					if (o.eq(r)) return a;
				}
				throw new Error('Unable to find valid recovery factor');
			};
		},
		5666: (e, t, r) => {
			'use strict';
			var i = r(3364);
			var a = r(9185);
			var o = a.assert;
			function KeyPair(e, t) {
				this.ec = e;
				this.priv = null;
				this.pub = null;
				if (t.priv) this._importPrivate(t.priv, t.privEnc);
				if (t.pub) this._importPublic(t.pub, t.pubEnc);
			}
			e.exports = KeyPair;
			KeyPair.fromPublic = function fromPublic(e, t, r) {
				if (t instanceof KeyPair) return t;
				return new KeyPair(e, { pub: t, pubEnc: r });
			};
			KeyPair.fromPrivate = function fromPrivate(e, t, r) {
				if (t instanceof KeyPair) return t;
				return new KeyPair(e, { priv: t, privEnc: r });
			};
			KeyPair.prototype.validate = function validate() {
				var e = this.getPublic();
				if (e.isInfinity()) return { result: false, reason: 'Invalid public key' };
				if (!e.validate()) return { result: false, reason: 'Public key is not a point' };
				if (!e.mul(this.ec.curve.n).isInfinity())
					return { result: false, reason: 'Public key * N != O' };
				return { result: true, reason: null };
			};
			KeyPair.prototype.getPublic = function getPublic(e, t) {
				if (typeof e === 'string') {
					t = e;
					e = null;
				}
				if (!this.pub) this.pub = this.ec.g.mul(this.priv);
				if (!t) return this.pub;
				return this.pub.encode(t, e);
			};
			KeyPair.prototype.getPrivate = function getPrivate(e) {
				if (e === 'hex') return this.priv.toString(16, 2);
				else return this.priv;
			};
			KeyPair.prototype._importPrivate = function _importPrivate(e, t) {
				this.priv = new i(e, t || 16);
				this.priv = this.priv.umod(this.ec.curve.n);
			};
			KeyPair.prototype._importPublic = function _importPublic(e, t) {
				if (e.x || e.y) {
					if (this.ec.curve.type === 'mont') {
						o(e.x, 'Need x coordinate');
					} else if (this.ec.curve.type === 'short' || this.ec.curve.type === 'edwards') {
						o(e.x && e.y, 'Need both x and y coordinate');
					}
					this.pub = this.ec.curve.point(e.x, e.y);
					return;
				}
				this.pub = this.ec.curve.decodePoint(e, t);
			};
			KeyPair.prototype.derive = function derive(e) {
				if (!e.validate()) {
					o(e.validate(), 'public point not validated');
				}
				return e.mul(this.priv).getX();
			};
			KeyPair.prototype.sign = function sign(e, t, r) {
				return this.ec.sign(e, this, t, r);
			};
			KeyPair.prototype.verify = function verify(e, t, r) {
				return this.ec.verify(e, t, this, undefined, r);
			};
			KeyPair.prototype.inspect = function inspect() {
				return (
					'<Key priv: ' +
					(this.priv && this.priv.toString(16, 2)) +
					' pub: ' +
					(this.pub && this.pub.inspect()) +
					' >'
				);
			};
		},
		4375: (e, t, r) => {
			'use strict';
			var i = r(3364);
			var a = r(9185);
			var o = a.assert;
			function Signature(e, t) {
				if (e instanceof Signature) return e;
				if (this._importDER(e, t)) return;
				o(e.r && e.s, 'Signature without r or s');
				this.r = new i(e.r, 16);
				this.s = new i(e.s, 16);
				if (e.recoveryParam === undefined) this.recoveryParam = null;
				else this.recoveryParam = e.recoveryParam;
			}
			e.exports = Signature;
			function Position() {
				this.place = 0;
			}
			function getLength(e, t) {
				var r = e[t.place++];
				if (!(r & 128)) {
					return r;
				}
				var i = r & 15;
				if (i === 0 || i > 4) {
					return false;
				}
				if (e[t.place] === 0) {
					return false;
				}
				var a = 0;
				for (var o = 0, c = t.place; o < i; o++, c++) {
					a <<= 8;
					a |= e[c];
					a >>>= 0;
				}
				if (a <= 127) {
					return false;
				}
				t.place = c;
				return a;
			}
			function rmPadding(e) {
				var t = 0;
				var r = e.length - 1;
				while (!e[t] && !(e[t + 1] & 128) && t < r) {
					t++;
				}
				if (t === 0) {
					return e;
				}
				return e.slice(t);
			}
			Signature.prototype._importDER = function _importDER(e, t) {
				e = a.toArray(e, t);
				var r = new Position();
				if (e[r.place++] !== 48) {
					return false;
				}
				var o = getLength(e, r);
				if (o === false) {
					return false;
				}
				if (o + r.place !== e.length) {
					return false;
				}
				if (e[r.place++] !== 2) {
					return false;
				}
				var c = getLength(e, r);
				if (c === false) {
					return false;
				}
				if ((e[r.place] & 128) !== 0) {
					return false;
				}
				var u = e.slice(r.place, c + r.place);
				r.place += c;
				if (e[r.place++] !== 2) {
					return false;
				}
				var l = getLength(e, r);
				if (l === false) {
					return false;
				}
				if (e.length !== l + r.place) {
					return false;
				}
				if ((e[r.place] & 128) !== 0) {
					return false;
				}
				var d = e.slice(r.place, l + r.place);
				if (u[0] === 0) {
					if (u[1] & 128) {
						u = u.slice(1);
					} else {
						return false;
					}
				}
				if (d[0] === 0) {
					if (d[1] & 128) {
						d = d.slice(1);
					} else {
						return false;
					}
				}
				this.r = new i(u);
				this.s = new i(d);
				this.recoveryParam = null;
				return true;
			};
			function constructLength(e, t) {
				if (t < 128) {
					e.push(t);
					return;
				}
				var r = 1 + ((Math.log(t) / Math.LN2) >>> 3);
				e.push(r | 128);
				while (--r) {
					e.push((t >>> (r << 3)) & 255);
				}
				e.push(t);
			}
			Signature.prototype.toDER = function toDER(e) {
				var t = this.r.toArray();
				var r = this.s.toArray();
				if (t[0] & 128) t = [0].concat(t);
				if (r[0] & 128) r = [0].concat(r);
				t = rmPadding(t);
				r = rmPadding(r);
				while (!r[0] && !(r[1] & 128)) {
					r = r.slice(1);
				}
				var i = [2];
				constructLength(i, t.length);
				i = i.concat(t);
				i.push(2);
				constructLength(i, r.length);
				var o = i.concat(r);
				var c = [48];
				constructLength(c, o.length);
				c = c.concat(o);
				return a.encode(c, e);
			};
		},
		7808: (e, t, r) => {
			'use strict';
			var i = r(1631);
			var a = r(5366);
			var o = r(9185);
			var c = o.assert;
			var u = o.parseBytes;
			var l = r(6419);
			var d = r(5406);
			function EDDSA(e) {
				c(e === 'ed25519', 'only tested with ed25519 so far');
				if (!(this instanceof EDDSA)) return new EDDSA(e);
				e = a[e].curve;
				this.curve = e;
				this.g = e.g;
				this.g.precompute(e.n.bitLength() + 1);
				this.pointClass = e.point().constructor;
				this.encodingLength = Math.ceil(e.n.bitLength() / 8);
				this.hash = i.sha512;
			}
			e.exports = EDDSA;
			EDDSA.prototype.sign = function sign(e, t) {
				e = u(e);
				var r = this.keyFromSecret(t);
				var i = this.hashInt(r.messagePrefix(), e);
				var a = this.g.mul(i);
				var o = this.encodePoint(a);
				var c = this.hashInt(o, r.pubBytes(), e).mul(r.priv());
				var l = i.add(c).umod(this.curve.n);
				return this.makeSignature({ R: a, S: l, Rencoded: o });
			};
			EDDSA.prototype.verify = function verify(e, t, r) {
				e = u(e);
				t = this.makeSignature(t);
				if (t.S().gte(t.eddsa.curve.n) || t.S().isNeg()) {
					return false;
				}
				var i = this.keyFromPublic(r);
				var a = this.hashInt(t.Rencoded(), i.pubBytes(), e);
				var o = this.g.mul(t.S());
				var c = t.R().add(i.pub().mul(a));
				return c.eq(o);
			};
			EDDSA.prototype.hashInt = function hashInt() {
				var e = this.hash();
				for (var t = 0; t < arguments.length; t++) e.update(arguments[t]);
				return o.intFromLE(e.digest()).umod(this.curve.n);
			};
			EDDSA.prototype.keyFromPublic = function keyFromPublic(e) {
				return l.fromPublic(this, e);
			};
			EDDSA.prototype.keyFromSecret = function keyFromSecret(e) {
				return l.fromSecret(this, e);
			};
			EDDSA.prototype.makeSignature = function makeSignature(e) {
				if (e instanceof d) return e;
				return new d(this, e);
			};
			EDDSA.prototype.encodePoint = function encodePoint(e) {
				var t = e.getY().toArray('le', this.encodingLength);
				t[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0;
				return t;
			};
			EDDSA.prototype.decodePoint = function decodePoint(e) {
				e = o.parseBytes(e);
				var t = e.length - 1;
				var r = e.slice(0, t).concat(e[t] & ~128);
				var i = (e[t] & 128) !== 0;
				var a = o.intFromLE(r);
				return this.curve.pointFromY(a, i);
			};
			EDDSA.prototype.encodeInt = function encodeInt(e) {
				return e.toArray('le', this.encodingLength);
			};
			EDDSA.prototype.decodeInt = function decodeInt(e) {
				return o.intFromLE(e);
			};
			EDDSA.prototype.isPoint = function isPoint(e) {
				return e instanceof this.pointClass;
			};
		},
		6419: (e, t, r) => {
			'use strict';
			var i = r(9185);
			var a = i.assert;
			var o = i.parseBytes;
			var c = i.cachedProperty;
			function KeyPair(e, t) {
				this.eddsa = e;
				this._secret = o(t.secret);
				if (e.isPoint(t.pub)) this._pub = t.pub;
				else this._pubBytes = o(t.pub);
			}
			KeyPair.fromPublic = function fromPublic(e, t) {
				if (t instanceof KeyPair) return t;
				return new KeyPair(e, { pub: t });
			};
			KeyPair.fromSecret = function fromSecret(e, t) {
				if (t instanceof KeyPair) return t;
				return new KeyPair(e, { secret: t });
			};
			KeyPair.prototype.secret = function secret() {
				return this._secret;
			};
			c(KeyPair, 'pubBytes', function pubBytes() {
				return this.eddsa.encodePoint(this.pub());
			});
			c(KeyPair, 'pub', function pub() {
				if (this._pubBytes) return this.eddsa.decodePoint(this._pubBytes);
				return this.eddsa.g.mul(this.priv());
			});
			c(KeyPair, 'privBytes', function privBytes() {
				var e = this.eddsa;
				var t = this.hash();
				var r = e.encodingLength - 1;
				var i = t.slice(0, e.encodingLength);
				i[0] &= 248;
				i[r] &= 127;
				i[r] |= 64;
				return i;
			});
			c(KeyPair, 'priv', function priv() {
				return this.eddsa.decodeInt(this.privBytes());
			});
			c(KeyPair, 'hash', function hash() {
				return this.eddsa.hash().update(this.secret()).digest();
			});
			c(KeyPair, 'messagePrefix', function messagePrefix() {
				return this.hash().slice(this.eddsa.encodingLength);
			});
			KeyPair.prototype.sign = function sign(e) {
				a(this._secret, 'KeyPair can only verify');
				return this.eddsa.sign(e, this);
			};
			KeyPair.prototype.verify = function verify(e, t) {
				return this.eddsa.verify(e, t, this);
			};
			KeyPair.prototype.getSecret = function getSecret(e) {
				a(this._secret, 'KeyPair is public only');
				return i.encode(this.secret(), e);
			};
			KeyPair.prototype.getPublic = function getPublic(e) {
				return i.encode(this.pubBytes(), e);
			};
			e.exports = KeyPair;
		},
		5406: (e, t, r) => {
			'use strict';
			var i = r(3364);
			var a = r(9185);
			var o = a.assert;
			var c = a.cachedProperty;
			var u = a.parseBytes;
			function Signature(e, t) {
				this.eddsa = e;
				if (typeof t !== 'object') t = u(t);
				if (Array.isArray(t)) {
					o(t.length === e.encodingLength * 2, 'Signature has invalid size');
					t = { R: t.slice(0, e.encodingLength), S: t.slice(e.encodingLength) };
				}
				o(t.R && t.S, 'Signature without R or S');
				if (e.isPoint(t.R)) this._R = t.R;
				if (t.S instanceof i) this._S = t.S;
				this._Rencoded = Array.isArray(t.R) ? t.R : t.Rencoded;
				this._Sencoded = Array.isArray(t.S) ? t.S : t.Sencoded;
			}
			c(Signature, 'S', function S() {
				return this.eddsa.decodeInt(this.Sencoded());
			});
			c(Signature, 'R', function R() {
				return this.eddsa.decodePoint(this.Rencoded());
			});
			c(Signature, 'Rencoded', function Rencoded() {
				return this.eddsa.encodePoint(this.R());
			});
			c(Signature, 'Sencoded', function Sencoded() {
				return this.eddsa.encodeInt(this.S());
			});
			Signature.prototype.toBytes = function toBytes() {
				return this.Rencoded().concat(this.Sencoded());
			};
			Signature.prototype.toHex = function toHex() {
				return a.encode(this.toBytes(), 'hex').toUpperCase();
			};
			e.exports = Signature;
		},
		7153: (e) => {
			e.exports = {
				doubles: {
					step: 4,
					points: [
						[
							'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
							'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
						],
						[
							'8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
							'11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
						],
						[
							'175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
							'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
						],
						[
							'363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
							'4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
						],
						[
							'8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
							'4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
						],
						[
							'723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
							'96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
						],
						[
							'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
							'5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
						],
						[
							'100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
							'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
						],
						[
							'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
							'9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
						],
						[
							'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
							'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
						],
						[
							'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
							'9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
						],
						[
							'53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
							'5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
						],
						[
							'8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
							'10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
						],
						[
							'385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
							'283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
						],
						[
							'6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
							'7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
						],
						[
							'3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
							'56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
						],
						[
							'85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
							'7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
						],
						[
							'948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
							'53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
						],
						[
							'6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
							'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
						],
						[
							'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
							'4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
						],
						[
							'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
							'7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
						],
						[
							'213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
							'4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
						],
						[
							'4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
							'17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
						],
						[
							'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
							'6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
						],
						[
							'76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
							'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
						],
						[
							'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
							'893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
						],
						[
							'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
							'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
						],
						[
							'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
							'2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
						],
						[
							'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
							'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
						],
						[
							'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
							'7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
						],
						[
							'90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
							'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
						],
						[
							'8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
							'662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
						],
						[
							'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
							'1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
						],
						[
							'8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
							'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
						],
						[
							'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
							'2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
						],
						[
							'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
							'67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
						],
						[
							'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
							'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
						],
						[
							'324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
							'648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
						],
						[
							'4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
							'35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
						],
						[
							'9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
							'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
						],
						[
							'6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
							'9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
						],
						[
							'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
							'40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
						],
						[
							'7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
							'34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
						],
						[
							'928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
							'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
						],
						[
							'85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
							'1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
						],
						[
							'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
							'493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
						],
						[
							'827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
							'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
						],
						[
							'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
							'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
						],
						[
							'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
							'4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
						],
						[
							'1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
							'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
						],
						[
							'146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
							'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
						],
						[
							'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
							'6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
						],
						[
							'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
							'8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
						],
						[
							'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
							'7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
						],
						[
							'174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
							'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
						],
						[
							'959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
							'2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
						],
						[
							'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
							'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
						],
						[
							'64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
							'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
						],
						[
							'8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
							'38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
						],
						[
							'13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
							'69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
						],
						[
							'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
							'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
						],
						[
							'8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
							'40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
						],
						[
							'8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
							'620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
						],
						[
							'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
							'7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
						],
						[
							'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
							'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
						]
					]
				},
				naf: {
					wnd: 7,
					points: [
						[
							'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
							'388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
						],
						[
							'2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
							'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
						],
						[
							'5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
							'6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
						],
						[
							'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
							'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
						],
						[
							'774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
							'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
						],
						[
							'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
							'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
						],
						[
							'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
							'581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
						],
						[
							'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
							'4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
						],
						[
							'2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
							'85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
						],
						[
							'352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
							'321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
						],
						[
							'2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
							'2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
						],
						[
							'9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
							'73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
						],
						[
							'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
							'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
						],
						[
							'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
							'2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
						],
						[
							'6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
							'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
						],
						[
							'1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
							'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
						],
						[
							'605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
							'2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
						],
						[
							'62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
							'80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
						],
						[
							'80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
							'1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
						],
						[
							'7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
							'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
						],
						[
							'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
							'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
						],
						[
							'49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
							'758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
						],
						[
							'77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
							'958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
						],
						[
							'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
							'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
						],
						[
							'463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
							'5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
						],
						[
							'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
							'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
						],
						[
							'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
							'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
						],
						[
							'2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
							'4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
						],
						[
							'7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
							'91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
						],
						[
							'754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
							'673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
						],
						[
							'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
							'59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
						],
						[
							'186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
							'3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
						],
						[
							'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
							'55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
						],
						[
							'5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
							'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
						],
						[
							'290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
							'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
						],
						[
							'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
							'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
						],
						[
							'766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
							'744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
						],
						[
							'59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
							'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
						],
						[
							'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
							'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
						],
						[
							'7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
							'30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
						],
						[
							'948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
							'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
						],
						[
							'7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
							'100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
						],
						[
							'3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
							'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
						],
						[
							'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
							'8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
						],
						[
							'1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
							'68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
						],
						[
							'733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
							'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
						],
						[
							'15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
							'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
						],
						[
							'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
							'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
						],
						[
							'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
							'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
						],
						[
							'311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
							'66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
						],
						[
							'34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
							'9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
						],
						[
							'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
							'4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
						],
						[
							'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
							'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
						],
						[
							'32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
							'5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
						],
						[
							'7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
							'8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
						],
						[
							'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
							'8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
						],
						[
							'16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
							'5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
						],
						[
							'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
							'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
						],
						[
							'78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
							'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
						],
						[
							'494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
							'42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
						],
						[
							'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
							'204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
						],
						[
							'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
							'4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
						],
						[
							'841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
							'73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
						],
						[
							'5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
							'39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
						],
						[
							'36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
							'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
						],
						[
							'336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
							'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
						],
						[
							'8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
							'6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
						],
						[
							'1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
							'60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
						],
						[
							'85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
							'3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
						],
						[
							'29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
							'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
						],
						[
							'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
							'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
						],
						[
							'4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
							'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
						],
						[
							'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
							'6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
						],
						[
							'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
							'322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
						],
						[
							'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
							'6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
						],
						[
							'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
							'2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
						],
						[
							'591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
							'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
						],
						[
							'11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
							'998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
						],
						[
							'3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
							'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
						],
						[
							'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
							'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
						],
						[
							'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
							'6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
						],
						[
							'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
							'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
						],
						[
							'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
							'21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
						],
						[
							'347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
							'60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
						],
						[
							'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
							'49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
						],
						[
							'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
							'5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
						],
						[
							'4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
							'7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
						],
						[
							'3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
							'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
						],
						[
							'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
							'8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
						],
						[
							'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
							'39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
						],
						[
							'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
							'62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
						],
						[
							'48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
							'25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
						],
						[
							'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
							'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
						],
						[
							'6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
							'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
						],
						[
							'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
							'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
						],
						[
							'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
							'6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
						],
						[
							'13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
							'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
						],
						[
							'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
							'1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
						],
						[
							'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
							'5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
						],
						[
							'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
							'438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
						],
						[
							'8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
							'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
						],
						[
							'52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
							'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
						],
						[
							'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
							'6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
						],
						[
							'7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
							'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
						],
						[
							'5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
							'9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
						],
						[
							'32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
							'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
						],
						[
							'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
							'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
						],
						[
							'8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
							'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
						],
						[
							'4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
							'67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
						],
						[
							'3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
							'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
						],
						[
							'674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
							'299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
						],
						[
							'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
							'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
						],
						[
							'30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
							'462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
						],
						[
							'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
							'62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
						],
						[
							'93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
							'7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
						],
						[
							'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
							'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
						],
						[
							'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
							'4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
						],
						[
							'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
							'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
						],
						[
							'463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
							'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
						],
						[
							'7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
							'603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
						],
						[
							'74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
							'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
						],
						[
							'30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
							'553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
						],
						[
							'9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
							'712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
						],
						[
							'176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
							'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
						],
						[
							'75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
							'9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
						],
						[
							'809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
							'9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
						],
						[
							'1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
							'4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
						]
					]
				}
			};
		},
		9185: (e, t, r) => {
			'use strict';
			var i = t;
			var a = r(3364);
			var o = r(5578);
			var c = r(4209);
			i.assert = o;
			i.toArray = c.toArray;
			i.zero2 = c.zero2;
			i.toHex = c.toHex;
			i.encode = c.encode;
			function getNAF(e, t, r) {
				var i = new Array(Math.max(e.bitLength(), r) + 1);
				var a;
				for (a = 0; a < i.length; a += 1) {
					i[a] = 0;
				}
				var o = 1 << (t + 1);
				var c = e.clone();
				for (a = 0; a < i.length; a++) {
					var u;
					var l = c.andln(o - 1);
					if (c.isOdd()) {
						if (l > (o >> 1) - 1) u = (o >> 1) - l;
						else u = l;
						c.isubn(u);
					} else {
						u = 0;
					}
					i[a] = u;
					c.iushrn(1);
				}
				return i;
			}
			i.getNAF = getNAF;
			function getJSF(e, t) {
				var r = [[], []];
				e = e.clone();
				t = t.clone();
				var i = 0;
				var a = 0;
				var o;
				while (e.cmpn(-i) > 0 || t.cmpn(-a) > 0) {
					var c = (e.andln(3) + i) & 3;
					var u = (t.andln(3) + a) & 3;
					if (c === 3) c = -1;
					if (u === 3) u = -1;
					var l;
					if ((c & 1) === 0) {
						l = 0;
					} else {
						o = (e.andln(7) + i) & 7;
						if ((o === 3 || o === 5) && u === 2) l = -c;
						else l = c;
					}
					r[0].push(l);
					var d;
					if ((u & 1) === 0) {
						d = 0;
					} else {
						o = (t.andln(7) + a) & 7;
						if ((o === 3 || o === 5) && c === 2) d = -u;
						else d = u;
					}
					r[1].push(d);
					if (2 * i === l + 1) i = 1 - i;
					if (2 * a === d + 1) a = 1 - a;
					e.iushrn(1);
					t.iushrn(1);
				}
				return r;
			}
			i.getJSF = getJSF;
			function cachedProperty(e, t, r) {
				var i = '_' + t;
				e.prototype[t] = function cachedProperty() {
					return this[i] !== undefined ? this[i] : (this[i] = r.call(this));
				};
			}
			i.cachedProperty = cachedProperty;
			function parseBytes(e) {
				return typeof e === 'string' ? i.toArray(e, 'hex') : e;
			}
			i.parseBytes = parseBytes;
			function intFromLE(e) {
				return new a(e, 'hex', 'le');
			}
			i.intFromLE = intFromLE;
		},
		381: (e) => {
			'use strict';
			var t = typeof Reflect === 'object' ? Reflect : null;
			var r =
				t && typeof t.apply === 'function'
					? t.apply
					: function ReflectApply(e, t, r) {
							return Function.prototype.apply.call(e, t, r);
						};
			var i;
			if (t && typeof t.ownKeys === 'function') {
				i = t.ownKeys;
			} else if (Object.getOwnPropertySymbols) {
				i = function ReflectOwnKeys(e) {
					return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
				};
			} else {
				i = function ReflectOwnKeys(e) {
					return Object.getOwnPropertyNames(e);
				};
			}
			function ProcessEmitWarning(e) {
				if (console && console.warn) console.warn(e);
			}
			var a =
				Number.isNaN ||
				function NumberIsNaN(e) {
					return e !== e;
				};
			function EventEmitter() {
				EventEmitter.init.call(this);
			}
			e.exports = EventEmitter;
			e.exports.once = once;
			EventEmitter.EventEmitter = EventEmitter;
			EventEmitter.prototype._events = undefined;
			EventEmitter.prototype._eventsCount = 0;
			EventEmitter.prototype._maxListeners = undefined;
			var o = 10;
			function checkListener(e) {
				if (typeof e !== 'function') {
					throw new TypeError(
						'The "listener" argument must be of type Function. Received type ' + typeof e
					);
				}
			}
			Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
				enumerable: true,
				get: function () {
					return o;
				},
				set: function (e) {
					if (typeof e !== 'number' || e < 0 || a(e)) {
						throw new RangeError(
							'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
								e +
								'.'
						);
					}
					o = e;
				}
			});
			EventEmitter.init = function () {
				if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
					this._events = Object.create(null);
					this._eventsCount = 0;
				}
				this._maxListeners = this._maxListeners || undefined;
			};
			EventEmitter.prototype.setMaxListeners = function setMaxListeners(e) {
				if (typeof e !== 'number' || e < 0 || a(e)) {
					throw new RangeError(
						'The value of "n" is out of range. It must be a non-negative number. Received ' +
							e +
							'.'
					);
				}
				this._maxListeners = e;
				return this;
			};
			function _getMaxListeners(e) {
				if (e._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
				return e._maxListeners;
			}
			EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
				return _getMaxListeners(this);
			};
			EventEmitter.prototype.emit = function emit(e) {
				var t = [];
				for (var i = 1; i < arguments.length; i++) t.push(arguments[i]);
				var a = e === 'error';
				var o = this._events;
				if (o !== undefined) a = a && o.error === undefined;
				else if (!a) return false;
				if (a) {
					var c;
					if (t.length > 0) c = t[0];
					if (c instanceof Error) {
						throw c;
					}
					var u = new Error('Unhandled error.' + (c ? ' (' + c.message + ')' : ''));
					u.context = c;
					throw u;
				}
				var l = o[e];
				if (l === undefined) return false;
				if (typeof l === 'function') {
					r(l, this, t);
				} else {
					var d = l.length;
					var p = arrayClone(l, d);
					for (var i = 0; i < d; ++i) r(p[i], this, t);
				}
				return true;
			};
			function _addListener(e, t, r, i) {
				var a;
				var o;
				var c;
				checkListener(r);
				o = e._events;
				if (o === undefined) {
					o = e._events = Object.create(null);
					e._eventsCount = 0;
				} else {
					if (o.newListener !== undefined) {
						e.emit('newListener', t, r.listener ? r.listener : r);
						o = e._events;
					}
					c = o[t];
				}
				if (c === undefined) {
					c = o[t] = r;
					++e._eventsCount;
				} else {
					if (typeof c === 'function') {
						c = o[t] = i ? [r, c] : [c, r];
					} else if (i) {
						c.unshift(r);
					} else {
						c.push(r);
					}
					a = _getMaxListeners(e);
					if (a > 0 && c.length > a && !c.warned) {
						c.warned = true;
						var u = new Error(
							'Possible EventEmitter memory leak detected. ' +
								c.length +
								' ' +
								String(t) +
								' listeners ' +
								'added. Use emitter.setMaxListeners() to ' +
								'increase limit'
						);
						u.name = 'MaxListenersExceededWarning';
						u.emitter = e;
						u.type = t;
						u.count = c.length;
						ProcessEmitWarning(u);
					}
				}
				return e;
			}
			EventEmitter.prototype.addListener = function addListener(e, t) {
				return _addListener(this, e, t, false);
			};
			EventEmitter.prototype.on = EventEmitter.prototype.addListener;
			EventEmitter.prototype.prependListener = function prependListener(e, t) {
				return _addListener(this, e, t, true);
			};
			function onceWrapper() {
				if (!this.fired) {
					this.target.removeListener(this.type, this.wrapFn);
					this.fired = true;
					if (arguments.length === 0) return this.listener.call(this.target);
					return this.listener.apply(this.target, arguments);
				}
			}
			function _onceWrap(e, t, r) {
				var i = { fired: false, wrapFn: undefined, target: e, type: t, listener: r };
				var a = onceWrapper.bind(i);
				a.listener = r;
				i.wrapFn = a;
				return a;
			}
			EventEmitter.prototype.once = function once(e, t) {
				checkListener(t);
				this.on(e, _onceWrap(this, e, t));
				return this;
			};
			EventEmitter.prototype.prependOnceListener = function prependOnceListener(e, t) {
				checkListener(t);
				this.prependListener(e, _onceWrap(this, e, t));
				return this;
			};
			EventEmitter.prototype.removeListener = function removeListener(e, t) {
				var r, i, a, o, c;
				checkListener(t);
				i = this._events;
				if (i === undefined) return this;
				r = i[e];
				if (r === undefined) return this;
				if (r === t || r.listener === t) {
					if (--this._eventsCount === 0) this._events = Object.create(null);
					else {
						delete i[e];
						if (i.removeListener) this.emit('removeListener', e, r.listener || t);
					}
				} else if (typeof r !== 'function') {
					a = -1;
					for (o = r.length - 1; o >= 0; o--) {
						if (r[o] === t || r[o].listener === t) {
							c = r[o].listener;
							a = o;
							break;
						}
					}
					if (a < 0) return this;
					if (a === 0) r.shift();
					else {
						spliceOne(r, a);
					}
					if (r.length === 1) i[e] = r[0];
					if (i.removeListener !== undefined) this.emit('removeListener', e, c || t);
				}
				return this;
			};
			EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
			EventEmitter.prototype.removeAllListeners = function removeAllListeners(e) {
				var t, r, i;
				r = this._events;
				if (r === undefined) return this;
				if (r.removeListener === undefined) {
					if (arguments.length === 0) {
						this._events = Object.create(null);
						this._eventsCount = 0;
					} else if (r[e] !== undefined) {
						if (--this._eventsCount === 0) this._events = Object.create(null);
						else delete r[e];
					}
					return this;
				}
				if (arguments.length === 0) {
					var a = Object.keys(r);
					var o;
					for (i = 0; i < a.length; ++i) {
						o = a[i];
						if (o === 'removeListener') continue;
						this.removeAllListeners(o);
					}
					this.removeAllListeners('removeListener');
					this._events = Object.create(null);
					this._eventsCount = 0;
					return this;
				}
				t = r[e];
				if (typeof t === 'function') {
					this.removeListener(e, t);
				} else if (t !== undefined) {
					for (i = t.length - 1; i >= 0; i--) {
						this.removeListener(e, t[i]);
					}
				}
				return this;
			};
			function _listeners(e, t, r) {
				var i = e._events;
				if (i === undefined) return [];
				var a = i[t];
				if (a === undefined) return [];
				if (typeof a === 'function') return r ? [a.listener || a] : [a];
				return r ? unwrapListeners(a) : arrayClone(a, a.length);
			}
			EventEmitter.prototype.listeners = function listeners(e) {
				return _listeners(this, e, true);
			};
			EventEmitter.prototype.rawListeners = function rawListeners(e) {
				return _listeners(this, e, false);
			};
			EventEmitter.listenerCount = function (e, t) {
				if (typeof e.listenerCount === 'function') {
					return e.listenerCount(t);
				} else {
					return listenerCount.call(e, t);
				}
			};
			EventEmitter.prototype.listenerCount = listenerCount;
			function listenerCount(e) {
				var t = this._events;
				if (t !== undefined) {
					var r = t[e];
					if (typeof r === 'function') {
						return 1;
					} else if (r !== undefined) {
						return r.length;
					}
				}
				return 0;
			}
			EventEmitter.prototype.eventNames = function eventNames() {
				return this._eventsCount > 0 ? i(this._events) : [];
			};
			function arrayClone(e, t) {
				var r = new Array(t);
				for (var i = 0; i < t; ++i) r[i] = e[i];
				return r;
			}
			function spliceOne(e, t) {
				for (; t + 1 < e.length; t++) e[t] = e[t + 1];
				e.pop();
			}
			function unwrapListeners(e) {
				var t = new Array(e.length);
				for (var r = 0; r < t.length; ++r) {
					t[r] = e[r].listener || e[r];
				}
				return t;
			}
			function once(e, t) {
				return new Promise(function (r, i) {
					function errorListener(r) {
						e.removeListener(t, resolver);
						i(r);
					}
					function resolver() {
						if (typeof e.removeListener === 'function') {
							e.removeListener('error', errorListener);
						}
						r([].slice.call(arguments));
					}
					eventTargetAgnosticAddListener(e, t, resolver, { once: true });
					if (t !== 'error') {
						addErrorHandlerIfEventEmitter(e, errorListener, { once: true });
					}
				});
			}
			function addErrorHandlerIfEventEmitter(e, t, r) {
				if (typeof e.on === 'function') {
					eventTargetAgnosticAddListener(e, 'error', t, r);
				}
			}
			function eventTargetAgnosticAddListener(e, t, r, i) {
				if (typeof e.on === 'function') {
					if (i.once) {
						e.once(t, r);
					} else {
						e.on(t, r);
					}
				} else if (typeof e.addEventListener === 'function') {
					e.addEventListener(t, function wrapListener(a) {
						if (i.once) {
							e.removeEventListener(t, wrapListener);
						}
						r(a);
					});
				} else {
					throw new TypeError(
						'The "emitter" argument must be of type EventEmitter. Received type ' + typeof e
					);
				}
			}
		},
		1804: (e, t, r) => {
			var i = r(6608).Buffer;
			var a = r(5035);
			function EVP_BytesToKey(e, t, r, o) {
				if (!i.isBuffer(e)) e = i.from(e, 'binary');
				if (t) {
					if (!i.isBuffer(t)) t = i.from(t, 'binary');
					if (t.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length');
				}
				var c = r / 8;
				var u = i.alloc(c);
				var l = i.alloc(o || 0);
				var d = i.alloc(0);
				while (c > 0 || o > 0) {
					var p = new a();
					p.update(d);
					p.update(e);
					if (t) p.update(t);
					d = p.digest();
					var m = 0;
					if (c > 0) {
						var g = u.length - c;
						m = Math.min(c, d.length);
						d.copy(u, g, 0, m);
						c -= m;
					}
					if (m < d.length && o > 0) {
						var v = l.length - o;
						var y = Math.min(o, d.length - m);
						d.copy(l, v, m, m + y);
						o -= y;
					}
				}
				d.fill(0);
				return { key: u, iv: l };
			}
			e.exports = EVP_BytesToKey;
		},
		7824: (e, t, r) => {
			'use strict';
			var i = r(6608).Buffer;
			var a = r(9191).Transform;
			var o = r(1193);
			function HashBase(e) {
				a.call(this);
				this._block = i.allocUnsafe(e);
				this._blockSize = e;
				this._blockOffset = 0;
				this._length = [0, 0, 0, 0];
				this._finalized = false;
			}
			o(HashBase, a);
			HashBase.prototype._transform = function (e, t, r) {
				var i = null;
				try {
					this.update(e, t);
				} catch (e) {
					i = e;
				}
				r(i);
			};
			HashBase.prototype._flush = function (e) {
				var t = null;
				try {
					this.push(this.digest());
				} catch (e) {
					t = e;
				}
				e(t);
			};
			var c = typeof Uint8Array !== 'undefined';
			var u =
				typeof ArrayBuffer !== 'undefined' &&
				typeof Uint8Array !== 'undefined' &&
				ArrayBuffer.isView &&
				(i.prototype instanceof Uint8Array || i.TYPED_ARRAY_SUPPORT);
			function toBuffer(e, t) {
				if (e instanceof i) return e;
				if (typeof e === 'string') return i.from(e, t);
				if (u && ArrayBuffer.isView(e)) {
					if (e.byteLength === 0) return i.alloc(0);
					var r = i.from(e.buffer, e.byteOffset, e.byteLength);
					if (r.byteLength === e.byteLength) return r;
				}
				if (c && e instanceof Uint8Array) return i.from(e);
				if (
					i.isBuffer(e) &&
					e.constructor &&
					typeof e.constructor.isBuffer === 'function' &&
					e.constructor.isBuffer(e)
				) {
					return i.from(e);
				}
				throw new TypeError(
					'The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.'
				);
			}
			HashBase.prototype.update = function (e, t) {
				if (this._finalized) throw new Error('Digest already called');
				e = toBuffer(e, t);
				var r = this._block;
				var i = 0;
				while (this._blockOffset + e.length - i >= this._blockSize) {
					for (var a = this._blockOffset; a < this._blockSize; ) r[a++] = e[i++];
					this._update();
					this._blockOffset = 0;
				}
				while (i < e.length) r[this._blockOffset++] = e[i++];
				for (var o = 0, c = e.length * 8; c > 0; ++o) {
					this._length[o] += c;
					c = (this._length[o] / 4294967296) | 0;
					if (c > 0) this._length[o] -= 4294967296 * c;
				}
				return this;
			};
			HashBase.prototype._update = function () {
				throw new Error('_update is not implemented');
			};
			HashBase.prototype.digest = function (e) {
				if (this._finalized) throw new Error('Digest already called');
				this._finalized = true;
				var t = this._digest();
				if (e !== undefined) t = t.toString(e);
				this._block.fill(0);
				this._blockOffset = 0;
				for (var r = 0; r < 4; ++r) this._length[r] = 0;
				return t;
			};
			HashBase.prototype._digest = function () {
				throw new Error('_digest is not implemented');
			};
			e.exports = HashBase;
		},
		1631: (e, t, r) => {
			var i = t;
			i.utils = r(7905);
			i.common = r(4427);
			i.sha = r(1822);
			i.ripemd = r(7317);
			i.hmac = r(7309);
			i.sha1 = i.sha.sha1;
			i.sha256 = i.sha.sha256;
			i.sha224 = i.sha.sha224;
			i.sha384 = i.sha.sha384;
			i.sha512 = i.sha.sha512;
			i.ripemd160 = i.ripemd.ripemd160;
		},
		4427: (e, t, r) => {
			'use strict';
			var i = r(7905);
			var a = r(5578);
			function BlockHash() {
				this.pending = null;
				this.pendingTotal = 0;
				this.blockSize = this.constructor.blockSize;
				this.outSize = this.constructor.outSize;
				this.hmacStrength = this.constructor.hmacStrength;
				this.padLength = this.constructor.padLength / 8;
				this.endian = 'big';
				this._delta8 = this.blockSize / 8;
				this._delta32 = this.blockSize / 32;
			}
			t.BlockHash = BlockHash;
			BlockHash.prototype.update = function update(e, t) {
				e = i.toArray(e, t);
				if (!this.pending) this.pending = e;
				else this.pending = this.pending.concat(e);
				this.pendingTotal += e.length;
				if (this.pending.length >= this._delta8) {
					e = this.pending;
					var r = e.length % this._delta8;
					this.pending = e.slice(e.length - r, e.length);
					if (this.pending.length === 0) this.pending = null;
					e = i.join32(e, 0, e.length - r, this.endian);
					for (var a = 0; a < e.length; a += this._delta32) this._update(e, a, a + this._delta32);
				}
				return this;
			};
			BlockHash.prototype.digest = function digest(e) {
				this.update(this._pad());
				a(this.pending === null);
				return this._digest(e);
			};
			BlockHash.prototype._pad = function pad() {
				var e = this.pendingTotal;
				var t = this._delta8;
				var r = t - ((e + this.padLength) % t);
				var i = new Array(r + this.padLength);
				i[0] = 128;
				for (var a = 1; a < r; a++) i[a] = 0;
				e <<= 3;
				if (this.endian === 'big') {
					for (var o = 8; o < this.padLength; o++) i[a++] = 0;
					i[a++] = 0;
					i[a++] = 0;
					i[a++] = 0;
					i[a++] = 0;
					i[a++] = (e >>> 24) & 255;
					i[a++] = (e >>> 16) & 255;
					i[a++] = (e >>> 8) & 255;
					i[a++] = e & 255;
				} else {
					i[a++] = e & 255;
					i[a++] = (e >>> 8) & 255;
					i[a++] = (e >>> 16) & 255;
					i[a++] = (e >>> 24) & 255;
					i[a++] = 0;
					i[a++] = 0;
					i[a++] = 0;
					i[a++] = 0;
					for (o = 8; o < this.padLength; o++) i[a++] = 0;
				}
				return i;
			};
		},
		7309: (e, t, r) => {
			'use strict';
			var i = r(7905);
			var a = r(5578);
			function Hmac(e, t, r) {
				if (!(this instanceof Hmac)) return new Hmac(e, t, r);
				this.Hash = e;
				this.blockSize = e.blockSize / 8;
				this.outSize = e.outSize / 8;
				this.inner = null;
				this.outer = null;
				this._init(i.toArray(t, r));
			}
			e.exports = Hmac;
			Hmac.prototype._init = function init(e) {
				if (e.length > this.blockSize) e = new this.Hash().update(e).digest();
				a(e.length <= this.blockSize);
				for (var t = e.length; t < this.blockSize; t++) e.push(0);
				for (t = 0; t < e.length; t++) e[t] ^= 54;
				this.inner = new this.Hash().update(e);
				for (t = 0; t < e.length; t++) e[t] ^= 106;
				this.outer = new this.Hash().update(e);
			};
			Hmac.prototype.update = function update(e, t) {
				this.inner.update(e, t);
				return this;
			};
			Hmac.prototype.digest = function digest(e) {
				this.outer.update(this.inner.digest());
				return this.outer.digest(e);
			};
		},
		7317: (e, t, r) => {
			'use strict';
			var i = r(7905);
			var a = r(4427);
			var o = i.rotl32;
			var c = i.sum32;
			var u = i.sum32_3;
			var l = i.sum32_4;
			var d = a.BlockHash;
			function RIPEMD160() {
				if (!(this instanceof RIPEMD160)) return new RIPEMD160();
				d.call(this);
				this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
				this.endian = 'little';
			}
			i.inherits(RIPEMD160, d);
			t.ripemd160 = RIPEMD160;
			RIPEMD160.blockSize = 512;
			RIPEMD160.outSize = 160;
			RIPEMD160.hmacStrength = 192;
			RIPEMD160.padLength = 64;
			RIPEMD160.prototype._update = function update(e, t) {
				var r = this.h[0];
				var i = this.h[1];
				var a = this.h[2];
				var d = this.h[3];
				var y = this.h[4];
				var w = r;
				var _ = i;
				var A = a;
				var k = d;
				var N = y;
				for (var T = 0; T < 80; T++) {
					var x = c(o(l(r, f(T, i, a, d), e[p[T] + t], K(T)), g[T]), y);
					r = y;
					y = d;
					d = o(a, 10);
					a = i;
					i = x;
					x = c(o(l(w, f(79 - T, _, A, k), e[m[T] + t], Kh(T)), v[T]), N);
					w = N;
					N = k;
					k = o(A, 10);
					A = _;
					_ = x;
				}
				x = u(this.h[1], a, k);
				this.h[1] = u(this.h[2], d, N);
				this.h[2] = u(this.h[3], y, w);
				this.h[3] = u(this.h[4], r, _);
				this.h[4] = u(this.h[0], i, A);
				this.h[0] = x;
			};
			RIPEMD160.prototype._digest = function digest(e) {
				if (e === 'hex') return i.toHex32(this.h, 'little');
				else return i.split32(this.h, 'little');
			};
			function f(e, t, r, i) {
				if (e <= 15) return t ^ r ^ i;
				else if (e <= 31) return (t & r) | (~t & i);
				else if (e <= 47) return (t | ~r) ^ i;
				else if (e <= 63) return (t & i) | (r & ~i);
				else return t ^ (r | ~i);
			}
			function K(e) {
				if (e <= 15) return 0;
				else if (e <= 31) return 1518500249;
				else if (e <= 47) return 1859775393;
				else if (e <= 63) return 2400959708;
				else return 2840853838;
			}
			function Kh(e) {
				if (e <= 15) return 1352829926;
				else if (e <= 31) return 1548603684;
				else if (e <= 47) return 1836072691;
				else if (e <= 63) return 2053994217;
				else return 0;
			}
			var p = [
				0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9,
				5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8,
				12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
			];
			var m = [
				5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8,
				12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15,
				0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
			];
			var g = [
				11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12,
				15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14,
				15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11,
				8, 5, 6
			];
			var v = [
				8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7,
				12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11,
				14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13,
				11, 11
			];
		},
		1822: (e, t, r) => {
			'use strict';
			t.sha1 = r(2750);
			t.sha224 = r(7485);
			t.sha256 = r(7292);
			t.sha384 = r(696);
			t.sha512 = r(8889);
		},
		2750: (e, t, r) => {
			'use strict';
			var i = r(7905);
			var a = r(4427);
			var o = r(5660);
			var c = i.rotl32;
			var u = i.sum32;
			var l = i.sum32_5;
			var d = o.ft_1;
			var p = a.BlockHash;
			var m = [1518500249, 1859775393, 2400959708, 3395469782];
			function SHA1() {
				if (!(this instanceof SHA1)) return new SHA1();
				p.call(this);
				this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
				this.W = new Array(80);
			}
			i.inherits(SHA1, p);
			e.exports = SHA1;
			SHA1.blockSize = 512;
			SHA1.outSize = 160;
			SHA1.hmacStrength = 80;
			SHA1.padLength = 64;
			SHA1.prototype._update = function _update(e, t) {
				var r = this.W;
				for (var i = 0; i < 16; i++) r[i] = e[t + i];
				for (; i < r.length; i++) r[i] = c(r[i - 3] ^ r[i - 8] ^ r[i - 14] ^ r[i - 16], 1);
				var a = this.h[0];
				var o = this.h[1];
				var p = this.h[2];
				var g = this.h[3];
				var v = this.h[4];
				for (i = 0; i < r.length; i++) {
					var y = ~~(i / 20);
					var w = l(c(a, 5), d(y, o, p, g), v, r[i], m[y]);
					v = g;
					g = p;
					p = c(o, 30);
					o = a;
					a = w;
				}
				this.h[0] = u(this.h[0], a);
				this.h[1] = u(this.h[1], o);
				this.h[2] = u(this.h[2], p);
				this.h[3] = u(this.h[3], g);
				this.h[4] = u(this.h[4], v);
			};
			SHA1.prototype._digest = function digest(e) {
				if (e === 'hex') return i.toHex32(this.h, 'big');
				else return i.split32(this.h, 'big');
			};
		},
		7485: (e, t, r) => {
			'use strict';
			var i = r(7905);
			var a = r(7292);
			function SHA224() {
				if (!(this instanceof SHA224)) return new SHA224();
				a.call(this);
				this.h = [
					3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839,
					3204075428
				];
			}
			i.inherits(SHA224, a);
			e.exports = SHA224;
			SHA224.blockSize = 512;
			SHA224.outSize = 224;
			SHA224.hmacStrength = 192;
			SHA224.padLength = 64;
			SHA224.prototype._digest = function digest(e) {
				if (e === 'hex') return i.toHex32(this.h.slice(0, 7), 'big');
				else return i.split32(this.h.slice(0, 7), 'big');
			};
		},
		7292: (e, t, r) => {
			'use strict';
			var i = r(7905);
			var a = r(4427);
			var o = r(5660);
			var c = r(5578);
			var u = i.sum32;
			var l = i.sum32_4;
			var d = i.sum32_5;
			var p = o.ch32;
			var m = o.maj32;
			var g = o.s0_256;
			var v = o.s1_256;
			var y = o.g0_256;
			var w = o.g1_256;
			var _ = a.BlockHash;
			var A = [
				1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748,
				2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206,
				2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122,
				1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891,
				3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700,
				1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771,
				3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877,
				958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452,
				2361852424, 2428436474, 2756734187, 3204031479, 3329325298
			];
			function SHA256() {
				if (!(this instanceof SHA256)) return new SHA256();
				_.call(this);
				this.h = [
					1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,
					1541459225
				];
				this.k = A;
				this.W = new Array(64);
			}
			i.inherits(SHA256, _);
			e.exports = SHA256;
			SHA256.blockSize = 512;
			SHA256.outSize = 256;
			SHA256.hmacStrength = 192;
			SHA256.padLength = 64;
			SHA256.prototype._update = function _update(e, t) {
				var r = this.W;
				for (var i = 0; i < 16; i++) r[i] = e[t + i];
				for (; i < r.length; i++) r[i] = l(w(r[i - 2]), r[i - 7], y(r[i - 15]), r[i - 16]);
				var a = this.h[0];
				var o = this.h[1];
				var _ = this.h[2];
				var A = this.h[3];
				var k = this.h[4];
				var N = this.h[5];
				var T = this.h[6];
				var x = this.h[7];
				c(this.k.length === r.length);
				for (i = 0; i < r.length; i++) {
					var B = d(x, v(k), p(k, N, T), this.k[i], r[i]);
					var P = u(g(a), m(a, o, _));
					x = T;
					T = N;
					N = k;
					k = u(A, B);
					A = _;
					_ = o;
					o = a;
					a = u(B, P);
				}
				this.h[0] = u(this.h[0], a);
				this.h[1] = u(this.h[1], o);
				this.h[2] = u(this.h[2], _);
				this.h[3] = u(this.h[3], A);
				this.h[4] = u(this.h[4], k);
				this.h[5] = u(this.h[5], N);
				this.h[6] = u(this.h[6], T);
				this.h[7] = u(this.h[7], x);
			};
			SHA256.prototype._digest = function digest(e) {
				if (e === 'hex') return i.toHex32(this.h, 'big');
				else return i.split32(this.h, 'big');
			};
		},
		696: (e, t, r) => {
			'use strict';
			var i = r(7905);
			var a = r(8889);
			function SHA384() {
				if (!(this instanceof SHA384)) return new SHA384();
				a.call(this);
				this.h = [
					3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360,
					4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839,
					1203062813, 3204075428
				];
			}
			i.inherits(SHA384, a);
			e.exports = SHA384;
			SHA384.blockSize = 1024;
			SHA384.outSize = 384;
			SHA384.hmacStrength = 192;
			SHA384.padLength = 128;
			SHA384.prototype._digest = function digest(e) {
				if (e === 'hex') return i.toHex32(this.h.slice(0, 12), 'big');
				else return i.split32(this.h.slice(0, 12), 'big');
			};
		},
		8889: (e, t, r) => {
			'use strict';
			var i = r(7905);
			var a = r(4427);
			var o = r(5578);
			var c = i.rotr64_hi;
			var u = i.rotr64_lo;
			var l = i.shr64_hi;
			var d = i.shr64_lo;
			var p = i.sum64;
			var m = i.sum64_hi;
			var g = i.sum64_lo;
			var v = i.sum64_4_hi;
			var y = i.sum64_4_lo;
			var w = i.sum64_5_hi;
			var _ = i.sum64_5_lo;
			var A = a.BlockHash;
			var k = [
				1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573,
				2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579,
				2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278,
				1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113,
				2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774,
				944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122,
				1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339,
				2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891,
				1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205,
				1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823,
				1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037,
				344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657,
				3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909,
				1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556,
				3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403,
				1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815,
				1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344,
				2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614,
				3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992,
				116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315,
				685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676,
				1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316,
				1246189591
			];
			function SHA512() {
				if (!(this instanceof SHA512)) return new SHA512();
				A.call(this);
				this.h = [
					1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762,
					1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547,
					1541459225, 327033209
				];
				this.k = k;
				this.W = new Array(160);
			}
			i.inherits(SHA512, A);
			e.exports = SHA512;
			SHA512.blockSize = 1024;
			SHA512.outSize = 512;
			SHA512.hmacStrength = 192;
			SHA512.padLength = 128;
			SHA512.prototype._prepareBlock = function _prepareBlock(e, t) {
				var r = this.W;
				for (var i = 0; i < 32; i++) r[i] = e[t + i];
				for (; i < r.length; i += 2) {
					var a = g1_512_hi(r[i - 4], r[i - 3]);
					var o = g1_512_lo(r[i - 4], r[i - 3]);
					var c = r[i - 14];
					var u = r[i - 13];
					var l = g0_512_hi(r[i - 30], r[i - 29]);
					var d = g0_512_lo(r[i - 30], r[i - 29]);
					var p = r[i - 32];
					var m = r[i - 31];
					r[i] = v(a, o, c, u, l, d, p, m);
					r[i + 1] = y(a, o, c, u, l, d, p, m);
				}
			};
			SHA512.prototype._update = function _update(e, t) {
				this._prepareBlock(e, t);
				var r = this.W;
				var i = this.h[0];
				var a = this.h[1];
				var c = this.h[2];
				var u = this.h[3];
				var l = this.h[4];
				var d = this.h[5];
				var v = this.h[6];
				var y = this.h[7];
				var A = this.h[8];
				var k = this.h[9];
				var N = this.h[10];
				var T = this.h[11];
				var x = this.h[12];
				var B = this.h[13];
				var P = this.h[14];
				var M = this.h[15];
				o(this.k.length === r.length);
				for (var C = 0; C < r.length; C += 2) {
					var I = P;
					var O = M;
					var F = s1_512_hi(A, k);
					var D = s1_512_lo(A, k);
					var L = ch64_hi(A, k, N, T, x, B);
					var U = ch64_lo(A, k, N, T, x, B);
					var j = this.k[C];
					var H = this.k[C + 1];
					var z = r[C];
					var $ = r[C + 1];
					var G = w(I, O, F, D, L, U, j, H, z, $);
					var q = _(I, O, F, D, L, U, j, H, z, $);
					I = s0_512_hi(i, a);
					O = s0_512_lo(i, a);
					F = maj64_hi(i, a, c, u, l, d);
					D = maj64_lo(i, a, c, u, l, d);
					var V = m(I, O, F, D);
					var W = g(I, O, F, D);
					P = x;
					M = B;
					x = N;
					B = T;
					N = A;
					T = k;
					A = m(v, y, G, q);
					k = g(y, y, G, q);
					v = l;
					y = d;
					l = c;
					d = u;
					c = i;
					u = a;
					i = m(G, q, V, W);
					a = g(G, q, V, W);
				}
				p(this.h, 0, i, a);
				p(this.h, 2, c, u);
				p(this.h, 4, l, d);
				p(this.h, 6, v, y);
				p(this.h, 8, A, k);
				p(this.h, 10, N, T);
				p(this.h, 12, x, B);
				p(this.h, 14, P, M);
			};
			SHA512.prototype._digest = function digest(e) {
				if (e === 'hex') return i.toHex32(this.h, 'big');
				else return i.split32(this.h, 'big');
			};
			function ch64_hi(e, t, r, i, a) {
				var o = (e & r) ^ (~e & a);
				if (o < 0) o += 4294967296;
				return o;
			}
			function ch64_lo(e, t, r, i, a, o) {
				var c = (t & i) ^ (~t & o);
				if (c < 0) c += 4294967296;
				return c;
			}
			function maj64_hi(e, t, r, i, a) {
				var o = (e & r) ^ (e & a) ^ (r & a);
				if (o < 0) o += 4294967296;
				return o;
			}
			function maj64_lo(e, t, r, i, a, o) {
				var c = (t & i) ^ (t & o) ^ (i & o);
				if (c < 0) c += 4294967296;
				return c;
			}
			function s0_512_hi(e, t) {
				var r = c(e, t, 28);
				var i = c(t, e, 2);
				var a = c(t, e, 7);
				var o = r ^ i ^ a;
				if (o < 0) o += 4294967296;
				return o;
			}
			function s0_512_lo(e, t) {
				var r = u(e, t, 28);
				var i = u(t, e, 2);
				var a = u(t, e, 7);
				var o = r ^ i ^ a;
				if (o < 0) o += 4294967296;
				return o;
			}
			function s1_512_hi(e, t) {
				var r = c(e, t, 14);
				var i = c(e, t, 18);
				var a = c(t, e, 9);
				var o = r ^ i ^ a;
				if (o < 0) o += 4294967296;
				return o;
			}
			function s1_512_lo(e, t) {
				var r = u(e, t, 14);
				var i = u(e, t, 18);
				var a = u(t, e, 9);
				var o = r ^ i ^ a;
				if (o < 0) o += 4294967296;
				return o;
			}
			function g0_512_hi(e, t) {
				var r = c(e, t, 1);
				var i = c(e, t, 8);
				var a = l(e, t, 7);
				var o = r ^ i ^ a;
				if (o < 0) o += 4294967296;
				return o;
			}
			function g0_512_lo(e, t) {
				var r = u(e, t, 1);
				var i = u(e, t, 8);
				var a = d(e, t, 7);
				var o = r ^ i ^ a;
				if (o < 0) o += 4294967296;
				return o;
			}
			function g1_512_hi(e, t) {
				var r = c(e, t, 19);
				var i = c(t, e, 29);
				var a = l(e, t, 6);
				var o = r ^ i ^ a;
				if (o < 0) o += 4294967296;
				return o;
			}
			function g1_512_lo(e, t) {
				var r = u(e, t, 19);
				var i = u(t, e, 29);
				var a = d(e, t, 6);
				var o = r ^ i ^ a;
				if (o < 0) o += 4294967296;
				return o;
			}
		},
		5660: (e, t, r) => {
			'use strict';
			var i = r(7905);
			var a = i.rotr32;
			function ft_1(e, t, r, i) {
				if (e === 0) return ch32(t, r, i);
				if (e === 1 || e === 3) return p32(t, r, i);
				if (e === 2) return maj32(t, r, i);
			}
			t.ft_1 = ft_1;
			function ch32(e, t, r) {
				return (e & t) ^ (~e & r);
			}
			t.ch32 = ch32;
			function maj32(e, t, r) {
				return (e & t) ^ (e & r) ^ (t & r);
			}
			t.maj32 = maj32;
			function p32(e, t, r) {
				return e ^ t ^ r;
			}
			t.p32 = p32;
			function s0_256(e) {
				return a(e, 2) ^ a(e, 13) ^ a(e, 22);
			}
			t.s0_256 = s0_256;
			function s1_256(e) {
				return a(e, 6) ^ a(e, 11) ^ a(e, 25);
			}
			t.s1_256 = s1_256;
			function g0_256(e) {
				return a(e, 7) ^ a(e, 18) ^ (e >>> 3);
			}
			t.g0_256 = g0_256;
			function g1_256(e) {
				return a(e, 17) ^ a(e, 19) ^ (e >>> 10);
			}
			t.g1_256 = g1_256;
		},
		7905: (e, t, r) => {
			'use strict';
			var i = r(5578);
			var a = r(1193);
			t.inherits = a;
			function isSurrogatePair(e, t) {
				if ((e.charCodeAt(t) & 64512) !== 55296) {
					return false;
				}
				if (t < 0 || t + 1 >= e.length) {
					return false;
				}
				return (e.charCodeAt(t + 1) & 64512) === 56320;
			}
			function toArray(e, t) {
				if (Array.isArray(e)) return e.slice();
				if (!e) return [];
				var r = [];
				if (typeof e === 'string') {
					if (!t) {
						var i = 0;
						for (var a = 0; a < e.length; a++) {
							var o = e.charCodeAt(a);
							if (o < 128) {
								r[i++] = o;
							} else if (o < 2048) {
								r[i++] = (o >> 6) | 192;
								r[i++] = (o & 63) | 128;
							} else if (isSurrogatePair(e, a)) {
								o = 65536 + ((o & 1023) << 10) + (e.charCodeAt(++a) & 1023);
								r[i++] = (o >> 18) | 240;
								r[i++] = ((o >> 12) & 63) | 128;
								r[i++] = ((o >> 6) & 63) | 128;
								r[i++] = (o & 63) | 128;
							} else {
								r[i++] = (o >> 12) | 224;
								r[i++] = ((o >> 6) & 63) | 128;
								r[i++] = (o & 63) | 128;
							}
						}
					} else if (t === 'hex') {
						e = e.replace(/[^a-z0-9]+/gi, '');
						if (e.length % 2 !== 0) e = '0' + e;
						for (a = 0; a < e.length; a += 2) r.push(parseInt(e[a] + e[a + 1], 16));
					}
				} else {
					for (a = 0; a < e.length; a++) r[a] = e[a] | 0;
				}
				return r;
			}
			t.toArray = toArray;
			function toHex(e) {
				var t = '';
				for (var r = 0; r < e.length; r++) t += zero2(e[r].toString(16));
				return t;
			}
			t.toHex = toHex;
			function htonl(e) {
				var t = (e >>> 24) | ((e >>> 8) & 65280) | ((e << 8) & 16711680) | ((e & 255) << 24);
				return t >>> 0;
			}
			t.htonl = htonl;
			function toHex32(e, t) {
				var r = '';
				for (var i = 0; i < e.length; i++) {
					var a = e[i];
					if (t === 'little') a = htonl(a);
					r += zero8(a.toString(16));
				}
				return r;
			}
			t.toHex32 = toHex32;
			function zero2(e) {
				if (e.length === 1) return '0' + e;
				else return e;
			}
			t.zero2 = zero2;
			function zero8(e) {
				if (e.length === 7) return '0' + e;
				else if (e.length === 6) return '00' + e;
				else if (e.length === 5) return '000' + e;
				else if (e.length === 4) return '0000' + e;
				else if (e.length === 3) return '00000' + e;
				else if (e.length === 2) return '000000' + e;
				else if (e.length === 1) return '0000000' + e;
				else return e;
			}
			t.zero8 = zero8;
			function join32(e, t, r, a) {
				var o = r - t;
				i(o % 4 === 0);
				var c = new Array(o / 4);
				for (var u = 0, l = t; u < c.length; u++, l += 4) {
					var d;
					if (a === 'big') d = (e[l] << 24) | (e[l + 1] << 16) | (e[l + 2] << 8) | e[l + 3];
					else d = (e[l + 3] << 24) | (e[l + 2] << 16) | (e[l + 1] << 8) | e[l];
					c[u] = d >>> 0;
				}
				return c;
			}
			t.join32 = join32;
			function split32(e, t) {
				var r = new Array(e.length * 4);
				for (var i = 0, a = 0; i < e.length; i++, a += 4) {
					var o = e[i];
					if (t === 'big') {
						r[a] = o >>> 24;
						r[a + 1] = (o >>> 16) & 255;
						r[a + 2] = (o >>> 8) & 255;
						r[a + 3] = o & 255;
					} else {
						r[a + 3] = o >>> 24;
						r[a + 2] = (o >>> 16) & 255;
						r[a + 1] = (o >>> 8) & 255;
						r[a] = o & 255;
					}
				}
				return r;
			}
			t.split32 = split32;
			function rotr32(e, t) {
				return (e >>> t) | (e << (32 - t));
			}
			t.rotr32 = rotr32;
			function rotl32(e, t) {
				return (e << t) | (e >>> (32 - t));
			}
			t.rotl32 = rotl32;
			function sum32(e, t) {
				return (e + t) >>> 0;
			}
			t.sum32 = sum32;
			function sum32_3(e, t, r) {
				return (e + t + r) >>> 0;
			}
			t.sum32_3 = sum32_3;
			function sum32_4(e, t, r, i) {
				return (e + t + r + i) >>> 0;
			}
			t.sum32_4 = sum32_4;
			function sum32_5(e, t, r, i, a) {
				return (e + t + r + i + a) >>> 0;
			}
			t.sum32_5 = sum32_5;
			function sum64(e, t, r, i) {
				var a = e[t];
				var o = e[t + 1];
				var c = (i + o) >>> 0;
				var u = (c < i ? 1 : 0) + r + a;
				e[t] = u >>> 0;
				e[t + 1] = c;
			}
			t.sum64 = sum64;
			function sum64_hi(e, t, r, i) {
				var a = (t + i) >>> 0;
				var o = (a < t ? 1 : 0) + e + r;
				return o >>> 0;
			}
			t.sum64_hi = sum64_hi;
			function sum64_lo(e, t, r, i) {
				var a = t + i;
				return a >>> 0;
			}
			t.sum64_lo = sum64_lo;
			function sum64_4_hi(e, t, r, i, a, o, c, u) {
				var l = 0;
				var d = t;
				d = (d + i) >>> 0;
				l += d < t ? 1 : 0;
				d = (d + o) >>> 0;
				l += d < o ? 1 : 0;
				d = (d + u) >>> 0;
				l += d < u ? 1 : 0;
				var p = e + r + a + c + l;
				return p >>> 0;
			}
			t.sum64_4_hi = sum64_4_hi;
			function sum64_4_lo(e, t, r, i, a, o, c, u) {
				var l = t + i + o + u;
				return l >>> 0;
			}
			t.sum64_4_lo = sum64_4_lo;
			function sum64_5_hi(e, t, r, i, a, o, c, u, l, d) {
				var p = 0;
				var m = t;
				m = (m + i) >>> 0;
				p += m < t ? 1 : 0;
				m = (m + o) >>> 0;
				p += m < o ? 1 : 0;
				m = (m + u) >>> 0;
				p += m < u ? 1 : 0;
				m = (m + d) >>> 0;
				p += m < d ? 1 : 0;
				var g = e + r + a + c + l + p;
				return g >>> 0;
			}
			t.sum64_5_hi = sum64_5_hi;
			function sum64_5_lo(e, t, r, i, a, o, c, u, l, d) {
				var p = t + i + o + u + d;
				return p >>> 0;
			}
			t.sum64_5_lo = sum64_5_lo;
			function rotr64_hi(e, t, r) {
				var i = (t << (32 - r)) | (e >>> r);
				return i >>> 0;
			}
			t.rotr64_hi = rotr64_hi;
			function rotr64_lo(e, t, r) {
				var i = (e << (32 - r)) | (t >>> r);
				return i >>> 0;
			}
			t.rotr64_lo = rotr64_lo;
			function shr64_hi(e, t, r) {
				return e >>> r;
			}
			t.shr64_hi = shr64_hi;
			function shr64_lo(e, t, r) {
				var i = (e << (32 - r)) | (t >>> r);
				return i >>> 0;
			}
			t.shr64_lo = shr64_lo;
		},
		2519: (e, t, r) => {
			'use strict';
			var i = r(1631);
			var a = r(4209);
			var o = r(5578);
			function HmacDRBG(e) {
				if (!(this instanceof HmacDRBG)) return new HmacDRBG(e);
				this.hash = e.hash;
				this.predResist = !!e.predResist;
				this.outLen = this.hash.outSize;
				this.minEntropy = e.minEntropy || this.hash.hmacStrength;
				this._reseed = null;
				this.reseedInterval = null;
				this.K = null;
				this.V = null;
				var t = a.toArray(e.entropy, e.entropyEnc || 'hex');
				var r = a.toArray(e.nonce, e.nonceEnc || 'hex');
				var i = a.toArray(e.pers, e.persEnc || 'hex');
				o(
					t.length >= this.minEntropy / 8,
					'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'
				);
				this._init(t, r, i);
			}
			e.exports = HmacDRBG;
			HmacDRBG.prototype._init = function init(e, t, r) {
				var i = e.concat(t).concat(r);
				this.K = new Array(this.outLen / 8);
				this.V = new Array(this.outLen / 8);
				for (var a = 0; a < this.V.length; a++) {
					this.K[a] = 0;
					this.V[a] = 1;
				}
				this._update(i);
				this._reseed = 1;
				this.reseedInterval = 281474976710656;
			};
			HmacDRBG.prototype._hmac = function hmac() {
				return new i.hmac(this.hash, this.K);
			};
			HmacDRBG.prototype._update = function update(e) {
				var t = this._hmac().update(this.V).update([0]);
				if (e) t = t.update(e);
				this.K = t.digest();
				this.V = this._hmac().update(this.V).digest();
				if (!e) return;
				this.K = this._hmac().update(this.V).update([1]).update(e).digest();
				this.V = this._hmac().update(this.V).digest();
			};
			HmacDRBG.prototype.reseed = function reseed(e, t, r, i) {
				if (typeof t !== 'string') {
					i = r;
					r = t;
					t = null;
				}
				e = a.toArray(e, t);
				r = a.toArray(r, i);
				o(
					e.length >= this.minEntropy / 8,
					'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'
				);
				this._update(e.concat(r || []));
				this._reseed = 1;
			};
			HmacDRBG.prototype.generate = function generate(e, t, r, i) {
				if (this._reseed > this.reseedInterval) throw new Error('Reseed is required');
				if (typeof t !== 'string') {
					i = r;
					r = t;
					t = null;
				}
				if (r) {
					r = a.toArray(r, i || 'hex');
					this._update(r);
				}
				var o = [];
				while (o.length < e) {
					this.V = this._hmac().update(this.V).digest();
					o = o.concat(this.V);
				}
				var c = o.slice(0, e);
				this._update(r);
				this._reseed++;
				return a.encode(c, t);
			};
		},
		3328: (e, t) => {
			t.read = function (e, t, r, i, a) {
				var o, c;
				var u = a * 8 - i - 1;
				var l = (1 << u) - 1;
				var d = l >> 1;
				var p = -7;
				var m = r ? a - 1 : 0;
				var g = r ? -1 : 1;
				var v = e[t + m];
				m += g;
				o = v & ((1 << -p) - 1);
				v >>= -p;
				p += u;
				for (; p > 0; o = o * 256 + e[t + m], m += g, p -= 8) {}
				c = o & ((1 << -p) - 1);
				o >>= -p;
				p += i;
				for (; p > 0; c = c * 256 + e[t + m], m += g, p -= 8) {}
				if (o === 0) {
					o = 1 - d;
				} else if (o === l) {
					return c ? NaN : (v ? -1 : 1) * Infinity;
				} else {
					c = c + Math.pow(2, i);
					o = o - d;
				}
				return (v ? -1 : 1) * c * Math.pow(2, o - i);
			};
			t.write = function (e, t, r, i, a, o) {
				var c, u, l;
				var d = o * 8 - a - 1;
				var p = (1 << d) - 1;
				var m = p >> 1;
				var g = a === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
				var v = i ? 0 : o - 1;
				var y = i ? 1 : -1;
				var w = t < 0 || (t === 0 && 1 / t < 0) ? 1 : 0;
				t = Math.abs(t);
				if (isNaN(t) || t === Infinity) {
					u = isNaN(t) ? 1 : 0;
					c = p;
				} else {
					c = Math.floor(Math.log(t) / Math.LN2);
					if (t * (l = Math.pow(2, -c)) < 1) {
						c--;
						l *= 2;
					}
					if (c + m >= 1) {
						t += g / l;
					} else {
						t += g * Math.pow(2, 1 - m);
					}
					if (t * l >= 2) {
						c++;
						l /= 2;
					}
					if (c + m >= p) {
						u = 0;
						c = p;
					} else if (c + m >= 1) {
						u = (t * l - 1) * Math.pow(2, a);
						c = c + m;
					} else {
						u = t * Math.pow(2, m - 1) * Math.pow(2, a);
						c = 0;
					}
				}
				for (; a >= 8; e[r + v] = u & 255, v += y, u /= 256, a -= 8) {}
				c = (c << a) | u;
				d += a;
				for (; d > 0; e[r + v] = c & 255, v += y, c /= 256, d -= 8) {}
				e[r + v - y] |= w * 128;
			};
		},
		1193: (e) => {
			if (typeof Object.create === 'function') {
				e.exports = function inherits(e, t) {
					if (t) {
						e.super_ = t;
						e.prototype = Object.create(t.prototype, {
							constructor: { value: e, enumerable: false, writable: true, configurable: true }
						});
					}
				};
			} else {
				e.exports = function inherits(e, t) {
					if (t) {
						e.super_ = t;
						var TempCtor = function () {};
						TempCtor.prototype = t.prototype;
						e.prototype = new TempCtor();
						e.prototype.constructor = e;
					}
				};
			}
		},
		5101: (e) => {
			var t = {}.toString;
			e.exports =
				Array.isArray ||
				function (e) {
					return t.call(e) == '[object Array]';
				};
		},
		9162: (e, t, r) => {
			var i = r(5409);
			var a;
			(function () {
				'use strict';
				var o = 'input is invalid type';
				var c = 'finalize already called';
				var u = typeof window === 'object';
				var l = u ? window : {};
				if (l.JS_SHA3_NO_WINDOW) {
					u = false;
				}
				var d = !u && typeof self === 'object';
				var p = !l.JS_SHA3_NO_NODE_JS && typeof i === 'object' && i.versions && i.versions.node;
				if (p) {
					l = r.g;
				} else if (d) {
					l = self;
				}
				var m = !l.JS_SHA3_NO_COMMON_JS && 'object' === 'object' && e.exports;
				var g = true && r.amdO;
				var v = !l.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
				var y = '0123456789abcdef'.split('');
				var w = [31, 7936, 2031616, 520093696];
				var _ = [4, 1024, 262144, 67108864];
				var A = [1, 256, 65536, 16777216];
				var k = [6, 1536, 393216, 100663296];
				var N = [0, 8, 16, 24];
				var T = [
					1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0,
					2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0,
					2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648,
					128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896,
					2147483648, 2147483649, 0, 2147516424, 2147483648
				];
				var x = [224, 256, 384, 512];
				var B = [128, 256];
				var P = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
				var M = { 128: 168, 256: 136 };
				if (l.JS_SHA3_NO_NODE_JS || !Array.isArray) {
					Array.isArray = function (e) {
						return Object.prototype.toString.call(e) === '[object Array]';
					};
				}
				if (v && (l.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
					ArrayBuffer.isView = function (e) {
						return typeof e === 'object' && e.buffer && e.buffer.constructor === ArrayBuffer;
					};
				}
				var createOutputMethod = function (e, t, r) {
					return function (i) {
						return new Keccak(e, t, e).update(i)[r]();
					};
				};
				var createShakeOutputMethod = function (e, t, r) {
					return function (i, a) {
						return new Keccak(e, t, a).update(i)[r]();
					};
				};
				var createCshakeOutputMethod = function (e, t, r) {
					return function (t, i, a, o) {
						return I['cshake' + e].update(t, i, a, o)[r]();
					};
				};
				var createKmacOutputMethod = function (e, t, r) {
					return function (t, i, a, o) {
						return I['kmac' + e].update(t, i, a, o)[r]();
					};
				};
				var createOutputMethods = function (e, t, r, i) {
					for (var a = 0; a < P.length; ++a) {
						var o = P[a];
						e[o] = t(r, i, o);
					}
					return e;
				};
				var createMethod = function (e, t) {
					var r = createOutputMethod(e, t, 'hex');
					r.create = function () {
						return new Keccak(e, t, e);
					};
					r.update = function (e) {
						return r.create().update(e);
					};
					return createOutputMethods(r, createOutputMethod, e, t);
				};
				var createShakeMethod = function (e, t) {
					var r = createShakeOutputMethod(e, t, 'hex');
					r.create = function (r) {
						return new Keccak(e, t, r);
					};
					r.update = function (e, t) {
						return r.create(t).update(e);
					};
					return createOutputMethods(r, createShakeOutputMethod, e, t);
				};
				var createCshakeMethod = function (e, t) {
					var r = M[e];
					var i = createCshakeOutputMethod(e, t, 'hex');
					i.create = function (i, a, o) {
						if (!a && !o) {
							return I['shake' + e].create(i);
						} else {
							return new Keccak(e, t, i).bytepad([a, o], r);
						}
					};
					i.update = function (e, t, r, a) {
						return i.create(t, r, a).update(e);
					};
					return createOutputMethods(i, createCshakeOutputMethod, e, t);
				};
				var createKmacMethod = function (e, t) {
					var r = M[e];
					var i = createKmacOutputMethod(e, t, 'hex');
					i.create = function (i, a, o) {
						return new Kmac(e, t, a).bytepad(['KMAC', o], r).bytepad([i], r);
					};
					i.update = function (e, t, r, a) {
						return i.create(e, r, a).update(t);
					};
					return createOutputMethods(i, createKmacOutputMethod, e, t);
				};
				var C = [
					{ name: 'keccak', padding: A, bits: x, createMethod },
					{ name: 'sha3', padding: k, bits: x, createMethod },
					{ name: 'shake', padding: w, bits: B, createMethod: createShakeMethod },
					{ name: 'cshake', padding: _, bits: B, createMethod: createCshakeMethod },
					{ name: 'kmac', padding: _, bits: B, createMethod: createKmacMethod }
				];
				var I = {},
					O = [];
				for (var F = 0; F < C.length; ++F) {
					var D = C[F];
					var L = D.bits;
					for (var U = 0; U < L.length; ++U) {
						var j = D.name + '_' + L[U];
						O.push(j);
						I[j] = D.createMethod(L[U], D.padding);
						if (D.name !== 'sha3') {
							var H = D.name + L[U];
							O.push(H);
							I[H] = I[j];
						}
					}
				}
				function Keccak(e, t, r) {
					this.blocks = [];
					this.s = [];
					this.padding = t;
					this.outputBits = r;
					this.reset = true;
					this.finalized = false;
					this.block = 0;
					this.start = 0;
					this.blockCount = (1600 - (e << 1)) >> 5;
					this.byteCount = this.blockCount << 2;
					this.outputBlocks = r >> 5;
					this.extraBytes = (r & 31) >> 3;
					for (var i = 0; i < 50; ++i) {
						this.s[i] = 0;
					}
				}
				Keccak.prototype.update = function (e) {
					if (this.finalized) {
						throw new Error(c);
					}
					var t,
						r = typeof e;
					if (r !== 'string') {
						if (r === 'object') {
							if (e === null) {
								throw new Error(o);
							} else if (v && e.constructor === ArrayBuffer) {
								e = new Uint8Array(e);
							} else if (!Array.isArray(e)) {
								if (!v || !ArrayBuffer.isView(e)) {
									throw new Error(o);
								}
							}
						} else {
							throw new Error(o);
						}
						t = true;
					}
					var i = this.blocks,
						a = this.byteCount,
						u = e.length,
						l = this.blockCount,
						d = 0,
						p = this.s,
						m,
						g;
					while (d < u) {
						if (this.reset) {
							this.reset = false;
							i[0] = this.block;
							for (m = 1; m < l + 1; ++m) {
								i[m] = 0;
							}
						}
						if (t) {
							for (m = this.start; d < u && m < a; ++d) {
								i[m >> 2] |= e[d] << N[m++ & 3];
							}
						} else {
							for (m = this.start; d < u && m < a; ++d) {
								g = e.charCodeAt(d);
								if (g < 128) {
									i[m >> 2] |= g << N[m++ & 3];
								} else if (g < 2048) {
									i[m >> 2] |= (192 | (g >> 6)) << N[m++ & 3];
									i[m >> 2] |= (128 | (g & 63)) << N[m++ & 3];
								} else if (g < 55296 || g >= 57344) {
									i[m >> 2] |= (224 | (g >> 12)) << N[m++ & 3];
									i[m >> 2] |= (128 | ((g >> 6) & 63)) << N[m++ & 3];
									i[m >> 2] |= (128 | (g & 63)) << N[m++ & 3];
								} else {
									g = 65536 + (((g & 1023) << 10) | (e.charCodeAt(++d) & 1023));
									i[m >> 2] |= (240 | (g >> 18)) << N[m++ & 3];
									i[m >> 2] |= (128 | ((g >> 12) & 63)) << N[m++ & 3];
									i[m >> 2] |= (128 | ((g >> 6) & 63)) << N[m++ & 3];
									i[m >> 2] |= (128 | (g & 63)) << N[m++ & 3];
								}
							}
						}
						this.lastByteIndex = m;
						if (m >= a) {
							this.start = m - a;
							this.block = i[l];
							for (m = 0; m < l; ++m) {
								p[m] ^= i[m];
							}
							f(p);
							this.reset = true;
						} else {
							this.start = m;
						}
					}
					return this;
				};
				Keccak.prototype.encode = function (e, t) {
					var r = e & 255,
						i = 1;
					var a = [r];
					e = e >> 8;
					r = e & 255;
					while (r > 0) {
						a.unshift(r);
						e = e >> 8;
						r = e & 255;
						++i;
					}
					if (t) {
						a.push(i);
					} else {
						a.unshift(i);
					}
					this.update(a);
					return a.length;
				};
				Keccak.prototype.encodeString = function (e) {
					var t,
						r = typeof e;
					if (r !== 'string') {
						if (r === 'object') {
							if (e === null) {
								throw new Error(o);
							} else if (v && e.constructor === ArrayBuffer) {
								e = new Uint8Array(e);
							} else if (!Array.isArray(e)) {
								if (!v || !ArrayBuffer.isView(e)) {
									throw new Error(o);
								}
							}
						} else {
							throw new Error(o);
						}
						t = true;
					}
					var i = 0,
						a = e.length;
					if (t) {
						i = a;
					} else {
						for (var c = 0; c < e.length; ++c) {
							var u = e.charCodeAt(c);
							if (u < 128) {
								i += 1;
							} else if (u < 2048) {
								i += 2;
							} else if (u < 55296 || u >= 57344) {
								i += 3;
							} else {
								u = 65536 + (((u & 1023) << 10) | (e.charCodeAt(++c) & 1023));
								i += 4;
							}
						}
					}
					i += this.encode(i * 8);
					this.update(e);
					return i;
				};
				Keccak.prototype.bytepad = function (e, t) {
					var r = this.encode(t);
					for (var i = 0; i < e.length; ++i) {
						r += this.encodeString(e[i]);
					}
					var a = t - (r % t);
					var o = [];
					o.length = a;
					this.update(o);
					return this;
				};
				Keccak.prototype.finalize = function () {
					if (this.finalized) {
						return;
					}
					this.finalized = true;
					var e = this.blocks,
						t = this.lastByteIndex,
						r = this.blockCount,
						i = this.s;
					e[t >> 2] |= this.padding[t & 3];
					if (this.lastByteIndex === this.byteCount) {
						e[0] = e[r];
						for (t = 1; t < r + 1; ++t) {
							e[t] = 0;
						}
					}
					e[r - 1] |= 2147483648;
					for (t = 0; t < r; ++t) {
						i[t] ^= e[t];
					}
					f(i);
				};
				Keccak.prototype.toString = Keccak.prototype.hex = function () {
					this.finalize();
					var e = this.blockCount,
						t = this.s,
						r = this.outputBlocks,
						i = this.extraBytes,
						a = 0,
						o = 0;
					var c = '',
						u;
					while (o < r) {
						for (a = 0; a < e && o < r; ++a, ++o) {
							u = t[a];
							c +=
								y[(u >> 4) & 15] +
								y[u & 15] +
								y[(u >> 12) & 15] +
								y[(u >> 8) & 15] +
								y[(u >> 20) & 15] +
								y[(u >> 16) & 15] +
								y[(u >> 28) & 15] +
								y[(u >> 24) & 15];
						}
						if (o % e === 0) {
							f(t);
							a = 0;
						}
					}
					if (i) {
						u = t[a];
						c += y[(u >> 4) & 15] + y[u & 15];
						if (i > 1) {
							c += y[(u >> 12) & 15] + y[(u >> 8) & 15];
						}
						if (i > 2) {
							c += y[(u >> 20) & 15] + y[(u >> 16) & 15];
						}
					}
					return c;
				};
				Keccak.prototype.arrayBuffer = function () {
					this.finalize();
					var e = this.blockCount,
						t = this.s,
						r = this.outputBlocks,
						i = this.extraBytes,
						a = 0,
						o = 0;
					var c = this.outputBits >> 3;
					var u;
					if (i) {
						u = new ArrayBuffer((r + 1) << 2);
					} else {
						u = new ArrayBuffer(c);
					}
					var l = new Uint32Array(u);
					while (o < r) {
						for (a = 0; a < e && o < r; ++a, ++o) {
							l[o] = t[a];
						}
						if (o % e === 0) {
							f(t);
						}
					}
					if (i) {
						l[a] = t[a];
						u = u.slice(0, c);
					}
					return u;
				};
				Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
				Keccak.prototype.digest = Keccak.prototype.array = function () {
					this.finalize();
					var e = this.blockCount,
						t = this.s,
						r = this.outputBlocks,
						i = this.extraBytes,
						a = 0,
						o = 0;
					var c = [],
						u,
						l;
					while (o < r) {
						for (a = 0; a < e && o < r; ++a, ++o) {
							u = o << 2;
							l = t[a];
							c[u] = l & 255;
							c[u + 1] = (l >> 8) & 255;
							c[u + 2] = (l >> 16) & 255;
							c[u + 3] = (l >> 24) & 255;
						}
						if (o % e === 0) {
							f(t);
						}
					}
					if (i) {
						u = o << 2;
						l = t[a];
						c[u] = l & 255;
						if (i > 1) {
							c[u + 1] = (l >> 8) & 255;
						}
						if (i > 2) {
							c[u + 2] = (l >> 16) & 255;
						}
					}
					return c;
				};
				function Kmac(e, t, r) {
					Keccak.call(this, e, t, r);
				}
				Kmac.prototype = new Keccak();
				Kmac.prototype.finalize = function () {
					this.encode(this.outputBits, true);
					return Keccak.prototype.finalize.call(this);
				};
				var f = function (e) {
					var t,
						r,
						i,
						a,
						o,
						c,
						u,
						l,
						d,
						p,
						m,
						g,
						v,
						y,
						w,
						_,
						A,
						k,
						N,
						x,
						B,
						P,
						M,
						C,
						I,
						O,
						F,
						D,
						L,
						U,
						j,
						H,
						z,
						$,
						G,
						q,
						V,
						W,
						J,
						Z,
						Q,
						Y,
						X,
						ee,
						te,
						re,
						ne,
						ie,
						se,
						ae,
						oe,
						ce,
						ue,
						le,
						de,
						he,
						pe,
						me,
						ve,
						ye,
						be,
						we,
						_e;
					for (i = 0; i < 48; i += 2) {
						a = e[0] ^ e[10] ^ e[20] ^ e[30] ^ e[40];
						o = e[1] ^ e[11] ^ e[21] ^ e[31] ^ e[41];
						c = e[2] ^ e[12] ^ e[22] ^ e[32] ^ e[42];
						u = e[3] ^ e[13] ^ e[23] ^ e[33] ^ e[43];
						l = e[4] ^ e[14] ^ e[24] ^ e[34] ^ e[44];
						d = e[5] ^ e[15] ^ e[25] ^ e[35] ^ e[45];
						p = e[6] ^ e[16] ^ e[26] ^ e[36] ^ e[46];
						m = e[7] ^ e[17] ^ e[27] ^ e[37] ^ e[47];
						g = e[8] ^ e[18] ^ e[28] ^ e[38] ^ e[48];
						v = e[9] ^ e[19] ^ e[29] ^ e[39] ^ e[49];
						t = g ^ ((c << 1) | (u >>> 31));
						r = v ^ ((u << 1) | (c >>> 31));
						e[0] ^= t;
						e[1] ^= r;
						e[10] ^= t;
						e[11] ^= r;
						e[20] ^= t;
						e[21] ^= r;
						e[30] ^= t;
						e[31] ^= r;
						e[40] ^= t;
						e[41] ^= r;
						t = a ^ ((l << 1) | (d >>> 31));
						r = o ^ ((d << 1) | (l >>> 31));
						e[2] ^= t;
						e[3] ^= r;
						e[12] ^= t;
						e[13] ^= r;
						e[22] ^= t;
						e[23] ^= r;
						e[32] ^= t;
						e[33] ^= r;
						e[42] ^= t;
						e[43] ^= r;
						t = c ^ ((p << 1) | (m >>> 31));
						r = u ^ ((m << 1) | (p >>> 31));
						e[4] ^= t;
						e[5] ^= r;
						e[14] ^= t;
						e[15] ^= r;
						e[24] ^= t;
						e[25] ^= r;
						e[34] ^= t;
						e[35] ^= r;
						e[44] ^= t;
						e[45] ^= r;
						t = l ^ ((g << 1) | (v >>> 31));
						r = d ^ ((v << 1) | (g >>> 31));
						e[6] ^= t;
						e[7] ^= r;
						e[16] ^= t;
						e[17] ^= r;
						e[26] ^= t;
						e[27] ^= r;
						e[36] ^= t;
						e[37] ^= r;
						e[46] ^= t;
						e[47] ^= r;
						t = p ^ ((a << 1) | (o >>> 31));
						r = m ^ ((o << 1) | (a >>> 31));
						e[8] ^= t;
						e[9] ^= r;
						e[18] ^= t;
						e[19] ^= r;
						e[28] ^= t;
						e[29] ^= r;
						e[38] ^= t;
						e[39] ^= r;
						e[48] ^= t;
						e[49] ^= r;
						y = e[0];
						w = e[1];
						re = (e[11] << 4) | (e[10] >>> 28);
						ne = (e[10] << 4) | (e[11] >>> 28);
						D = (e[20] << 3) | (e[21] >>> 29);
						L = (e[21] << 3) | (e[20] >>> 29);
						ye = (e[31] << 9) | (e[30] >>> 23);
						be = (e[30] << 9) | (e[31] >>> 23);
						Y = (e[40] << 18) | (e[41] >>> 14);
						X = (e[41] << 18) | (e[40] >>> 14);
						$ = (e[2] << 1) | (e[3] >>> 31);
						G = (e[3] << 1) | (e[2] >>> 31);
						_ = (e[13] << 12) | (e[12] >>> 20);
						A = (e[12] << 12) | (e[13] >>> 20);
						ie = (e[22] << 10) | (e[23] >>> 22);
						se = (e[23] << 10) | (e[22] >>> 22);
						U = (e[33] << 13) | (e[32] >>> 19);
						j = (e[32] << 13) | (e[33] >>> 19);
						we = (e[42] << 2) | (e[43] >>> 30);
						_e = (e[43] << 2) | (e[42] >>> 30);
						le = (e[5] << 30) | (e[4] >>> 2);
						de = (e[4] << 30) | (e[5] >>> 2);
						q = (e[14] << 6) | (e[15] >>> 26);
						V = (e[15] << 6) | (e[14] >>> 26);
						k = (e[25] << 11) | (e[24] >>> 21);
						N = (e[24] << 11) | (e[25] >>> 21);
						ae = (e[34] << 15) | (e[35] >>> 17);
						oe = (e[35] << 15) | (e[34] >>> 17);
						H = (e[45] << 29) | (e[44] >>> 3);
						z = (e[44] << 29) | (e[45] >>> 3);
						C = (e[6] << 28) | (e[7] >>> 4);
						I = (e[7] << 28) | (e[6] >>> 4);
						he = (e[17] << 23) | (e[16] >>> 9);
						pe = (e[16] << 23) | (e[17] >>> 9);
						W = (e[26] << 25) | (e[27] >>> 7);
						J = (e[27] << 25) | (e[26] >>> 7);
						x = (e[36] << 21) | (e[37] >>> 11);
						B = (e[37] << 21) | (e[36] >>> 11);
						ce = (e[47] << 24) | (e[46] >>> 8);
						ue = (e[46] << 24) | (e[47] >>> 8);
						ee = (e[8] << 27) | (e[9] >>> 5);
						te = (e[9] << 27) | (e[8] >>> 5);
						O = (e[18] << 20) | (e[19] >>> 12);
						F = (e[19] << 20) | (e[18] >>> 12);
						me = (e[29] << 7) | (e[28] >>> 25);
						ve = (e[28] << 7) | (e[29] >>> 25);
						Z = (e[38] << 8) | (e[39] >>> 24);
						Q = (e[39] << 8) | (e[38] >>> 24);
						P = (e[48] << 14) | (e[49] >>> 18);
						M = (e[49] << 14) | (e[48] >>> 18);
						e[0] = y ^ (~_ & k);
						e[1] = w ^ (~A & N);
						e[10] = C ^ (~O & D);
						e[11] = I ^ (~F & L);
						e[20] = $ ^ (~q & W);
						e[21] = G ^ (~V & J);
						e[30] = ee ^ (~re & ie);
						e[31] = te ^ (~ne & se);
						e[40] = le ^ (~he & me);
						e[41] = de ^ (~pe & ve);
						e[2] = _ ^ (~k & x);
						e[3] = A ^ (~N & B);
						e[12] = O ^ (~D & U);
						e[13] = F ^ (~L & j);
						e[22] = q ^ (~W & Z);
						e[23] = V ^ (~J & Q);
						e[32] = re ^ (~ie & ae);
						e[33] = ne ^ (~se & oe);
						e[42] = he ^ (~me & ye);
						e[43] = pe ^ (~ve & be);
						e[4] = k ^ (~x & P);
						e[5] = N ^ (~B & M);
						e[14] = D ^ (~U & H);
						e[15] = L ^ (~j & z);
						e[24] = W ^ (~Z & Y);
						e[25] = J ^ (~Q & X);
						e[34] = ie ^ (~ae & ce);
						e[35] = se ^ (~oe & ue);
						e[44] = me ^ (~ye & we);
						e[45] = ve ^ (~be & _e);
						e[6] = x ^ (~P & y);
						e[7] = B ^ (~M & w);
						e[16] = U ^ (~H & C);
						e[17] = j ^ (~z & I);
						e[26] = Z ^ (~Y & $);
						e[27] = Q ^ (~X & G);
						e[36] = ae ^ (~ce & ee);
						e[37] = oe ^ (~ue & te);
						e[46] = ye ^ (~we & le);
						e[47] = be ^ (~_e & de);
						e[8] = P ^ (~y & _);
						e[9] = M ^ (~w & A);
						e[18] = H ^ (~C & O);
						e[19] = z ^ (~I & F);
						e[28] = Y ^ (~$ & q);
						e[29] = X ^ (~G & V);
						e[38] = ce ^ (~ee & re);
						e[39] = ue ^ (~te & ne);
						e[48] = we ^ (~le & he);
						e[49] = _e ^ (~de & pe);
						e[0] ^= T[i];
						e[1] ^= T[i + 1];
					}
				};
				if (m) {
					e.exports = I;
				} else {
					for (F = 0; F < O.length; ++F) {
						l[O[F]] = I[O[F]];
					}
					if (g) {
						!((a = function () {
							return I;
						}.call(t, r, t, e)),
						a !== undefined && (e.exports = a));
					}
				}
			})();
		},
		5035: (e, t, r) => {
			'use strict';
			var i = r(1193);
			var a = r(7824);
			var o = r(6608).Buffer;
			var c = new Array(16);
			function MD5() {
				a.call(this, 64);
				this._a = 1732584193;
				this._b = 4023233417;
				this._c = 2562383102;
				this._d = 271733878;
			}
			i(MD5, a);
			MD5.prototype._update = function () {
				var e = c;
				for (var t = 0; t < 16; ++t) e[t] = this._block.readInt32LE(t * 4);
				var r = this._a;
				var i = this._b;
				var a = this._c;
				var o = this._d;
				r = fnF(r, i, a, o, e[0], 3614090360, 7);
				o = fnF(o, r, i, a, e[1], 3905402710, 12);
				a = fnF(a, o, r, i, e[2], 606105819, 17);
				i = fnF(i, a, o, r, e[3], 3250441966, 22);
				r = fnF(r, i, a, o, e[4], 4118548399, 7);
				o = fnF(o, r, i, a, e[5], 1200080426, 12);
				a = fnF(a, o, r, i, e[6], 2821735955, 17);
				i = fnF(i, a, o, r, e[7], 4249261313, 22);
				r = fnF(r, i, a, o, e[8], 1770035416, 7);
				o = fnF(o, r, i, a, e[9], 2336552879, 12);
				a = fnF(a, o, r, i, e[10], 4294925233, 17);
				i = fnF(i, a, o, r, e[11], 2304563134, 22);
				r = fnF(r, i, a, o, e[12], 1804603682, 7);
				o = fnF(o, r, i, a, e[13], 4254626195, 12);
				a = fnF(a, o, r, i, e[14], 2792965006, 17);
				i = fnF(i, a, o, r, e[15], 1236535329, 22);
				r = fnG(r, i, a, o, e[1], 4129170786, 5);
				o = fnG(o, r, i, a, e[6], 3225465664, 9);
				a = fnG(a, o, r, i, e[11], 643717713, 14);
				i = fnG(i, a, o, r, e[0], 3921069994, 20);
				r = fnG(r, i, a, o, e[5], 3593408605, 5);
				o = fnG(o, r, i, a, e[10], 38016083, 9);
				a = fnG(a, o, r, i, e[15], 3634488961, 14);
				i = fnG(i, a, o, r, e[4], 3889429448, 20);
				r = fnG(r, i, a, o, e[9], 568446438, 5);
				o = fnG(o, r, i, a, e[14], 3275163606, 9);
				a = fnG(a, o, r, i, e[3], 4107603335, 14);
				i = fnG(i, a, o, r, e[8], 1163531501, 20);
				r = fnG(r, i, a, o, e[13], 2850285829, 5);
				o = fnG(o, r, i, a, e[2], 4243563512, 9);
				a = fnG(a, o, r, i, e[7], 1735328473, 14);
				i = fnG(i, a, o, r, e[12], 2368359562, 20);
				r = fnH(r, i, a, o, e[5], 4294588738, 4);
				o = fnH(o, r, i, a, e[8], 2272392833, 11);
				a = fnH(a, o, r, i, e[11], 1839030562, 16);
				i = fnH(i, a, o, r, e[14], 4259657740, 23);
				r = fnH(r, i, a, o, e[1], 2763975236, 4);
				o = fnH(o, r, i, a, e[4], 1272893353, 11);
				a = fnH(a, o, r, i, e[7], 4139469664, 16);
				i = fnH(i, a, o, r, e[10], 3200236656, 23);
				r = fnH(r, i, a, o, e[13], 681279174, 4);
				o = fnH(o, r, i, a, e[0], 3936430074, 11);
				a = fnH(a, o, r, i, e[3], 3572445317, 16);
				i = fnH(i, a, o, r, e[6], 76029189, 23);
				r = fnH(r, i, a, o, e[9], 3654602809, 4);
				o = fnH(o, r, i, a, e[12], 3873151461, 11);
				a = fnH(a, o, r, i, e[15], 530742520, 16);
				i = fnH(i, a, o, r, e[2], 3299628645, 23);
				r = fnI(r, i, a, o, e[0], 4096336452, 6);
				o = fnI(o, r, i, a, e[7], 1126891415, 10);
				a = fnI(a, o, r, i, e[14], 2878612391, 15);
				i = fnI(i, a, o, r, e[5], 4237533241, 21);
				r = fnI(r, i, a, o, e[12], 1700485571, 6);
				o = fnI(o, r, i, a, e[3], 2399980690, 10);
				a = fnI(a, o, r, i, e[10], 4293915773, 15);
				i = fnI(i, a, o, r, e[1], 2240044497, 21);
				r = fnI(r, i, a, o, e[8], 1873313359, 6);
				o = fnI(o, r, i, a, e[15], 4264355552, 10);
				a = fnI(a, o, r, i, e[6], 2734768916, 15);
				i = fnI(i, a, o, r, e[13], 1309151649, 21);
				r = fnI(r, i, a, o, e[4], 4149444226, 6);
				o = fnI(o, r, i, a, e[11], 3174756917, 10);
				a = fnI(a, o, r, i, e[2], 718787259, 15);
				i = fnI(i, a, o, r, e[9], 3951481745, 21);
				this._a = (this._a + r) | 0;
				this._b = (this._b + i) | 0;
				this._c = (this._c + a) | 0;
				this._d = (this._d + o) | 0;
			};
			MD5.prototype._digest = function () {
				this._block[this._blockOffset++] = 128;
				if (this._blockOffset > 56) {
					this._block.fill(0, this._blockOffset, 64);
					this._update();
					this._blockOffset = 0;
				}
				this._block.fill(0, this._blockOffset, 56);
				this._block.writeUInt32LE(this._length[0], 56);
				this._block.writeUInt32LE(this._length[1], 60);
				this._update();
				var e = o.allocUnsafe(16);
				e.writeInt32LE(this._a, 0);
				e.writeInt32LE(this._b, 4);
				e.writeInt32LE(this._c, 8);
				e.writeInt32LE(this._d, 12);
				return e;
			};
			function rotl(e, t) {
				return (e << t) | (e >>> (32 - t));
			}
			function fnF(e, t, r, i, a, o, c) {
				return (rotl((e + ((t & r) | (~t & i)) + a + o) | 0, c) + t) | 0;
			}
			function fnG(e, t, r, i, a, o, c) {
				return (rotl((e + ((t & i) | (r & ~i)) + a + o) | 0, c) + t) | 0;
			}
			function fnH(e, t, r, i, a, o, c) {
				return (rotl((e + (t ^ r ^ i) + a + o) | 0, c) + t) | 0;
			}
			function fnI(e, t, r, i, a, o, c) {
				return (rotl((e + (r ^ (t | ~i)) + a + o) | 0, c) + t) | 0;
			}
			e.exports = MD5;
		},
		4442: (e, t, r) => {
			var i = r(3364);
			var a = r(5442);
			function MillerRabin(e) {
				this.rand = e || new a.Rand();
			}
			e.exports = MillerRabin;
			MillerRabin.create = function create(e) {
				return new MillerRabin(e);
			};
			MillerRabin.prototype._randbelow = function _randbelow(e) {
				var t = e.bitLength();
				var r = Math.ceil(t / 8);
				do {
					var a = new i(this.rand.generate(r));
				} while (a.cmp(e) >= 0);
				return a;
			};
			MillerRabin.prototype._randrange = function _randrange(e, t) {
				var r = t.sub(e);
				return e.add(this._randbelow(r));
			};
			MillerRabin.prototype.test = function test(e, t, r) {
				var a = e.bitLength();
				var o = i.mont(e);
				var c = new i(1).toRed(o);
				if (!t) t = Math.max(1, (a / 48) | 0);
				var u = e.subn(1);
				for (var l = 0; !u.testn(l); l++) {}
				var d = e.shrn(l);
				var p = u.toRed(o);
				var m = true;
				for (; t > 0; t--) {
					var g = this._randrange(new i(2), u);
					if (r) r(g);
					var v = g.toRed(o).redPow(d);
					if (v.cmp(c) === 0 || v.cmp(p) === 0) continue;
					for (var y = 1; y < l; y++) {
						v = v.redSqr();
						if (v.cmp(c) === 0) return false;
						if (v.cmp(p) === 0) break;
					}
					if (y === l) return false;
				}
				return m;
			};
			MillerRabin.prototype.getDivisor = function getDivisor(e, t) {
				var r = e.bitLength();
				var a = i.mont(e);
				var o = new i(1).toRed(a);
				if (!t) t = Math.max(1, (r / 48) | 0);
				var c = e.subn(1);
				for (var u = 0; !c.testn(u); u++) {}
				var l = e.shrn(u);
				var d = c.toRed(a);
				for (; t > 0; t--) {
					var p = this._randrange(new i(2), c);
					var m = e.gcd(p);
					if (m.cmpn(1) !== 0) return m;
					var g = p.toRed(a).redPow(l);
					if (g.cmp(o) === 0 || g.cmp(d) === 0) continue;
					for (var v = 1; v < u; v++) {
						g = g.redSqr();
						if (g.cmp(o) === 0) return g.fromRed().subn(1).gcd(e);
						if (g.cmp(d) === 0) break;
					}
					if (v === u) {
						g = g.redSqr();
						return g.fromRed().subn(1).gcd(e);
					}
				}
				return false;
			};
		},
		5578: (e) => {
			e.exports = assert;
			function assert(e, t) {
				if (!e) throw new Error(t || 'Assertion failed');
			}
			assert.equal = function assertEqual(e, t, r) {
				if (e != t) throw new Error(r || 'Assertion failed: ' + e + ' != ' + t);
			};
		},
		4209: (e, t) => {
			'use strict';
			var r = t;
			function toArray(e, t) {
				if (Array.isArray(e)) return e.slice();
				if (!e) return [];
				var r = [];
				if (typeof e !== 'string') {
					for (var i = 0; i < e.length; i++) r[i] = e[i] | 0;
					return r;
				}
				if (t === 'hex') {
					e = e.replace(/[^a-z0-9]+/gi, '');
					if (e.length % 2 !== 0) e = '0' + e;
					for (var i = 0; i < e.length; i += 2) r.push(parseInt(e[i] + e[i + 1], 16));
				} else {
					for (var i = 0; i < e.length; i++) {
						var a = e.charCodeAt(i);
						var o = a >> 8;
						var c = a & 255;
						if (o) r.push(o, c);
						else r.push(c);
					}
				}
				return r;
			}
			r.toArray = toArray;
			function zero2(e) {
				if (e.length === 1) return '0' + e;
				else return e;
			}
			r.zero2 = zero2;
			function toHex(e) {
				var t = '';
				for (var r = 0; r < e.length; r++) t += zero2(e[r].toString(16));
				return t;
			}
			r.toHex = toHex;
			r.encode = function encode(e, t) {
				if (t === 'hex') return toHex(e);
				else return e;
			};
		},
		6874: (e, t, r) => {
			'use strict';
			var i = r(8071);
			t.certificate = r(1900);
			var a = i.define('RSAPrivateKey', function () {
				this.seq().obj(
					this.key('version')['int'](),
					this.key('modulus')['int'](),
					this.key('publicExponent')['int'](),
					this.key('privateExponent')['int'](),
					this.key('prime1')['int'](),
					this.key('prime2')['int'](),
					this.key('exponent1')['int'](),
					this.key('exponent2')['int'](),
					this.key('coefficient')['int']()
				);
			});
			t.RSAPrivateKey = a;
			var o = i.define('RSAPublicKey', function () {
				this.seq().obj(this.key('modulus')['int'](), this.key('publicExponent')['int']());
			});
			t.RSAPublicKey = o;
			var c = i.define('AlgorithmIdentifier', function () {
				this.seq().obj(
					this.key('algorithm').objid(),
					this.key('none').null_().optional(),
					this.key('curve').objid().optional(),
					this.key('params')
						.seq()
						.obj(this.key('p')['int'](), this.key('q')['int'](), this.key('g')['int']())
						.optional()
				);
			});
			var u = i.define('SubjectPublicKeyInfo', function () {
				this.seq().obj(this.key('algorithm').use(c), this.key('subjectPublicKey').bitstr());
			});
			t.PublicKey = u;
			var l = i.define('PrivateKeyInfo', function () {
				this.seq().obj(
					this.key('version')['int'](),
					this.key('algorithm').use(c),
					this.key('subjectPrivateKey').octstr()
				);
			});
			t.PrivateKey = l;
			var d = i.define('EncryptedPrivateKeyInfo', function () {
				this.seq().obj(
					this.key('algorithm')
						.seq()
						.obj(
							this.key('id').objid(),
							this.key('decrypt')
								.seq()
								.obj(
									this.key('kde')
										.seq()
										.obj(
											this.key('id').objid(),
											this.key('kdeparams')
												.seq()
												.obj(this.key('salt').octstr(), this.key('iters')['int']())
										),
									this.key('cipher').seq().obj(this.key('algo').objid(), this.key('iv').octstr())
								)
						),
					this.key('subjectPrivateKey').octstr()
				);
			});
			t.EncryptedPrivateKey = d;
			var p = i.define('DSAPrivateKey', function () {
				this.seq().obj(
					this.key('version')['int'](),
					this.key('p')['int'](),
					this.key('q')['int'](),
					this.key('g')['int'](),
					this.key('pub_key')['int'](),
					this.key('priv_key')['int']()
				);
			});
			t.DSAPrivateKey = p;
			t.DSAparam = i.define('DSAparam', function () {
				this['int']();
			});
			var m = i.define('ECParameters', function () {
				this.choice({ namedCurve: this.objid() });
			});
			var g = i.define('ECPrivateKey', function () {
				this.seq().obj(
					this.key('version')['int'](),
					this.key('privateKey').octstr(),
					this.key('parameters').optional().explicit(0).use(m),
					this.key('publicKey').optional().explicit(1).bitstr()
				);
			});
			t.ECPrivateKey = g;
			t.signature = i.define('signature', function () {
				this.seq().obj(this.key('r')['int'](), this.key('s')['int']());
			});
		},
		1900: (e, t, r) => {
			'use strict';
			var i = r(8071);
			var a = i.define('Time', function () {
				this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
			});
			var o = i.define('AttributeTypeValue', function () {
				this.seq().obj(this.key('type').objid(), this.key('value').any());
			});
			var c = i.define('AlgorithmIdentifier', function () {
				this.seq().obj(
					this.key('algorithm').objid(),
					this.key('parameters').optional(),
					this.key('curve').objid().optional()
				);
			});
			var u = i.define('SubjectPublicKeyInfo', function () {
				this.seq().obj(this.key('algorithm').use(c), this.key('subjectPublicKey').bitstr());
			});
			var l = i.define('RelativeDistinguishedName', function () {
				this.setof(o);
			});
			var d = i.define('RDNSequence', function () {
				this.seqof(l);
			});
			var p = i.define('Name', function () {
				this.choice({ rdnSequence: this.use(d) });
			});
			var m = i.define('Validity', function () {
				this.seq().obj(this.key('notBefore').use(a), this.key('notAfter').use(a));
			});
			var g = i.define('Extension', function () {
				this.seq().obj(
					this.key('extnID').objid(),
					this.key('critical').bool().def(false),
					this.key('extnValue').octstr()
				);
			});
			var v = i.define('TBSCertificate', function () {
				this.seq().obj(
					this.key('version').explicit(0)['int']().optional(),
					this.key('serialNumber')['int'](),
					this.key('signature').use(c),
					this.key('issuer').use(p),
					this.key('validity').use(m),
					this.key('subject').use(p),
					this.key('subjectPublicKeyInfo').use(u),
					this.key('issuerUniqueID').implicit(1).bitstr().optional(),
					this.key('subjectUniqueID').implicit(2).bitstr().optional(),
					this.key('extensions').explicit(3).seqof(g).optional()
				);
			});
			var y = i.define('X509Certificate', function () {
				this.seq().obj(
					this.key('tbsCertificate').use(v),
					this.key('signatureAlgorithm').use(c),
					this.key('signatureValue').bitstr()
				);
			});
			e.exports = y;
		},
		808: (e, t, r) => {
			'use strict';
			var i =
				/Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
			var a = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
			var o = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
			var c = r(1804);
			var u = r(5007);
			var l = r(6608).Buffer;
			e.exports = function (e, t) {
				var r = e.toString();
				var d = r.match(i);
				var p;
				if (!d) {
					var m = r.match(o);
					p = l.from(m[2].replace(/[\r\n]/g, ''), 'base64');
				} else {
					var g = 'aes' + d[1];
					var v = l.from(d[2], 'hex');
					var y = l.from(d[3].replace(/[\r\n]/g, ''), 'base64');
					var w = c(t, v.slice(0, 8), parseInt(d[1], 10)).key;
					var _ = [];
					var A = u.createDecipheriv(g, w, v);
					_.push(A.update(y));
					_.push(A['final']());
					p = l.concat(_);
				}
				var k = r.match(a)[1];
				return { tag: k, data: p };
			};
		},
		9979: (e, t, r) => {
			'use strict';
			var i = r(6874);
			var a = r(482);
			var o = r(808);
			var c = r(5007);
			var u = r(3166);
			var l = r(6608).Buffer;
			function decrypt(e, t) {
				var r = e.algorithm.decrypt.kde.kdeparams.salt;
				var i = parseInt(e.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
				var o = a[e.algorithm.decrypt.cipher.algo.join('.')];
				var d = e.algorithm.decrypt.cipher.iv;
				var p = e.subjectPrivateKey;
				var m = parseInt(o.split('-')[1], 10) / 8;
				var g = u.pbkdf2Sync(t, r, i, m, 'sha1');
				var v = c.createDecipheriv(o, g, d);
				var y = [];
				y.push(v.update(p));
				y.push(v['final']());
				return l.concat(y);
			}
			function parseKeys(e) {
				var t;
				if (typeof e === 'object' && !l.isBuffer(e)) {
					t = e.passphrase;
					e = e.key;
				}
				if (typeof e === 'string') {
					e = l.from(e);
				}
				var r = o(e, t);
				var a = r.tag;
				var c = r.data;
				var u, d;
				switch (a) {
					case 'CERTIFICATE':
						d = i.certificate.decode(c, 'der').tbsCertificate.subjectPublicKeyInfo;
					case 'PUBLIC KEY':
						if (!d) {
							d = i.PublicKey.decode(c, 'der');
						}
						u = d.algorithm.algorithm.join('.');
						switch (u) {
							case '1.2.840.113549.1.1.1':
								return i.RSAPublicKey.decode(d.subjectPublicKey.data, 'der');
							case '1.2.840.10045.2.1':
								d.subjectPrivateKey = d.subjectPublicKey;
								return { type: 'ec', data: d };
							case '1.2.840.10040.4.1':
								d.algorithm.params.pub_key = i.DSAparam.decode(d.subjectPublicKey.data, 'der');
								return { type: 'dsa', data: d.algorithm.params };
							default:
								throw new Error('unknown key id ' + u);
						}
					case 'ENCRYPTED PRIVATE KEY':
						c = i.EncryptedPrivateKey.decode(c, 'der');
						c = decrypt(c, t);
					case 'PRIVATE KEY':
						d = i.PrivateKey.decode(c, 'der');
						u = d.algorithm.algorithm.join('.');
						switch (u) {
							case '1.2.840.113549.1.1.1':
								return i.RSAPrivateKey.decode(d.subjectPrivateKey, 'der');
							case '1.2.840.10045.2.1':
								return {
									curve: d.algorithm.curve,
									privateKey: i.ECPrivateKey.decode(d.subjectPrivateKey, 'der').privateKey
								};
							case '1.2.840.10040.4.1':
								d.algorithm.params.priv_key = i.DSAparam.decode(d.subjectPrivateKey, 'der');
								return { type: 'dsa', params: d.algorithm.params };
							default:
								throw new Error('unknown key id ' + u);
						}
					case 'RSA PUBLIC KEY':
						return i.RSAPublicKey.decode(c, 'der');
					case 'RSA PRIVATE KEY':
						return i.RSAPrivateKey.decode(c, 'der');
					case 'DSA PRIVATE KEY':
						return { type: 'dsa', params: i.DSAPrivateKey.decode(c, 'der') };
					case 'EC PRIVATE KEY':
						c = i.ECPrivateKey.decode(c, 'der');
						return { curve: c.parameters.value, privateKey: c.privateKey };
					default:
						throw new Error('unknown key type ' + a);
				}
			}
			parseKeys.signature = i.signature;
			e.exports = parseKeys;
		},
		3166: (e, t, r) => {
			t.pbkdf2 = r(7638);
			t.pbkdf2Sync = r(8674);
		},
		7638: (e, t, r) => {
			var i = r(6608).Buffer;
			var a = r(362);
			var o = r(9749);
			var c = r(8674);
			var u = r(4300);
			var l;
			var d = r.g.crypto && r.g.crypto.subtle;
			var p = {
				sha: 'SHA-1',
				'sha-1': 'SHA-1',
				sha1: 'SHA-1',
				sha256: 'SHA-256',
				'sha-256': 'SHA-256',
				sha384: 'SHA-384',
				'sha-384': 'SHA-384',
				'sha-512': 'SHA-512',
				sha512: 'SHA-512'
			};
			var m = [];
			function checkNative(e) {
				if (r.g.process && !r.g.process.browser) {
					return Promise.resolve(false);
				}
				if (!d || !d.importKey || !d.deriveBits) {
					return Promise.resolve(false);
				}
				if (m[e] !== undefined) {
					return m[e];
				}
				l = l || i.alloc(8);
				var t = browserPbkdf2(l, l, 10, 128, e)
					.then(function () {
						return true;
					})
					.catch(function () {
						return false;
					});
				m[e] = t;
				return t;
			}
			var g;
			function getNextTick() {
				if (g) {
					return g;
				}
				if (r.g.process && r.g.process.nextTick) {
					g = r.g.process.nextTick;
				} else if (r.g.queueMicrotask) {
					g = r.g.queueMicrotask;
				} else if (r.g.setImmediate) {
					g = r.g.setImmediate;
				} else {
					g = r.g.setTimeout;
				}
				return g;
			}
			function browserPbkdf2(e, t, r, a, o) {
				return d
					.importKey('raw', e, { name: 'PBKDF2' }, false, ['deriveBits'])
					.then(function (e) {
						return d.deriveBits(
							{ name: 'PBKDF2', salt: t, iterations: r, hash: { name: o } },
							e,
							a << 3
						);
					})
					.then(function (e) {
						return i.from(e);
					});
			}
			function resolvePromise(e, t) {
				e.then(
					function (e) {
						getNextTick()(function () {
							t(null, e);
						});
					},
					function (e) {
						getNextTick()(function () {
							t(e);
						});
					}
				);
			}
			e.exports = function (e, t, i, l, d, m) {
				if (typeof d === 'function') {
					m = d;
					d = undefined;
				}
				d = d || 'sha1';
				var g = p[d.toLowerCase()];
				if (!g || typeof r.g.Promise !== 'function') {
					getNextTick()(function () {
						var r;
						try {
							r = c(e, t, i, l, d);
						} catch (e) {
							return m(e);
						}
						m(null, r);
					});
					return;
				}
				a(i, l);
				e = u(e, o, 'Password');
				t = u(t, o, 'Salt');
				if (typeof m !== 'function') throw new Error('No callback provided to pbkdf2');
				resolvePromise(
					checkNative(g).then(function (r) {
						if (r) return browserPbkdf2(e, t, i, l, g);
						return c(e, t, i, l, d);
					}),
					m
				);
			};
		},
		9749: (e, t, r) => {
			var i = r(5409);
			var a;
			if (r.g.process && r.g.process.browser) {
				a = 'utf-8';
			} else if (r.g.process && r.g.process.version) {
				var o = parseInt(i.version.split('.')[0].slice(1), 10);
				a = o >= 6 ? 'utf-8' : 'binary';
			} else {
				a = 'utf-8';
			}
			e.exports = a;
		},
		362: (e) => {
			var t = Math.pow(2, 30) - 1;
			e.exports = function (e, r) {
				if (typeof e !== 'number') {
					throw new TypeError('Iterations not a number');
				}
				if (e < 0) {
					throw new TypeError('Bad iterations');
				}
				if (typeof r !== 'number') {
					throw new TypeError('Key length not a number');
				}
				if (r < 0 || r > t || r !== r) {
					throw new TypeError('Bad key length');
				}
			};
		},
		8674: (e, t, r) => {
			var i = r(6159);
			var a = r(3934);
			var o = r(5244);
			var c = r(6608).Buffer;
			var u = r(362);
			var l = r(9749);
			var d = r(4300);
			var p = c.alloc(128);
			var m = {
				md5: 16,
				sha1: 20,
				sha224: 28,
				sha256: 32,
				sha384: 48,
				sha512: 64,
				rmd160: 20,
				ripemd160: 20
			};
			function Hmac(e, t, r) {
				var i = getDigest(e);
				var a = e === 'sha512' || e === 'sha384' ? 128 : 64;
				if (t.length > a) {
					t = i(t);
				} else if (t.length < a) {
					t = c.concat([t, p], a);
				}
				var o = c.allocUnsafe(a + m[e]);
				var u = c.allocUnsafe(a + m[e]);
				for (var l = 0; l < a; l++) {
					o[l] = t[l] ^ 54;
					u[l] = t[l] ^ 92;
				}
				var d = c.allocUnsafe(a + r + 4);
				o.copy(d, 0, 0, a);
				this.ipad1 = d;
				this.ipad2 = o;
				this.opad = u;
				this.alg = e;
				this.blocksize = a;
				this.hash = i;
				this.size = m[e];
			}
			Hmac.prototype.run = function (e, t) {
				e.copy(t, this.blocksize);
				var r = this.hash(t);
				r.copy(this.opad, this.blocksize);
				return this.hash(this.opad);
			};
			function getDigest(e) {
				function shaFunc(t) {
					return o(e).update(t).digest();
				}
				function rmd160Func(e) {
					return new a().update(e).digest();
				}
				if (e === 'rmd160' || e === 'ripemd160') return rmd160Func;
				if (e === 'md5') return i;
				return shaFunc;
			}
			function pbkdf2(e, t, r, i, a) {
				u(r, i);
				e = d(e, l, 'Password');
				t = d(t, l, 'Salt');
				a = a || 'sha1';
				var o = new Hmac(a, e, t.length);
				var p = c.allocUnsafe(i);
				var g = c.allocUnsafe(t.length + 4);
				t.copy(g, 0, 0, t.length);
				var v = 0;
				var y = m[a];
				var w = Math.ceil(i / y);
				for (var _ = 1; _ <= w; _++) {
					g.writeUInt32BE(_, t.length);
					var A = o.run(g, o.ipad1);
					var k = A;
					for (var N = 1; N < r; N++) {
						k = o.run(k, o.ipad2);
						for (var T = 0; T < y; T++) A[T] ^= k[T];
					}
					A.copy(p, v);
					v += y;
				}
				return p;
			}
			e.exports = pbkdf2;
		},
		4300: (e, t, r) => {
			var i = r(6608).Buffer;
			e.exports = function (e, t, r) {
				if (i.isBuffer(e)) {
					return e;
				} else if (typeof e === 'string') {
					return i.from(e, t);
				} else if (ArrayBuffer.isView(e)) {
					return i.from(e.buffer);
				} else {
					throw new TypeError(r + ' must be a string, a Buffer, a typed array or a DataView');
				}
			};
		},
		9387: (e, t, r) => {
			'use strict';
			var i = r(5409);
			if (
				typeof i === 'undefined' ||
				!i.version ||
				i.version.indexOf('v0.') === 0 ||
				(i.version.indexOf('v1.') === 0 && i.version.indexOf('v1.8.') !== 0)
			) {
				e.exports = { nextTick };
			} else {
				e.exports = i;
			}
			function nextTick(e, t, r, a) {
				if (typeof e !== 'function') {
					throw new TypeError('"callback" argument must be a function');
				}
				var o = arguments.length;
				var c, u;
				switch (o) {
					case 0:
					case 1:
						return i.nextTick(e);
					case 2:
						return i.nextTick(function afterTickOne() {
							e.call(null, t);
						});
					case 3:
						return i.nextTick(function afterTickTwo() {
							e.call(null, t, r);
						});
					case 4:
						return i.nextTick(function afterTickThree() {
							e.call(null, t, r, a);
						});
					default:
						c = new Array(o - 1);
						u = 0;
						while (u < c.length) {
							c[u++] = arguments[u];
						}
						return i.nextTick(function afterTick() {
							e.apply(null, c);
						});
				}
			}
		},
		5409: (e) => {
			var t = (e.exports = {});
			var r;
			var i;
			function defaultSetTimout() {
				throw new Error('setTimeout has not been defined');
			}
			function defaultClearTimeout() {
				throw new Error('clearTimeout has not been defined');
			}
			(function () {
				try {
					if (typeof setTimeout === 'function') {
						r = setTimeout;
					} else {
						r = defaultSetTimout;
					}
				} catch (e) {
					r = defaultSetTimout;
				}
				try {
					if (typeof clearTimeout === 'function') {
						i = clearTimeout;
					} else {
						i = defaultClearTimeout;
					}
				} catch (e) {
					i = defaultClearTimeout;
				}
			})();
			function runTimeout(e) {
				if (r === setTimeout) {
					return setTimeout(e, 0);
				}
				if ((r === defaultSetTimout || !r) && setTimeout) {
					r = setTimeout;
					return setTimeout(e, 0);
				}
				try {
					return r(e, 0);
				} catch (t) {
					try {
						return r.call(null, e, 0);
					} catch (t) {
						return r.call(this, e, 0);
					}
				}
			}
			function runClearTimeout(e) {
				if (i === clearTimeout) {
					return clearTimeout(e);
				}
				if ((i === defaultClearTimeout || !i) && clearTimeout) {
					i = clearTimeout;
					return clearTimeout(e);
				}
				try {
					return i(e);
				} catch (t) {
					try {
						return i.call(null, e);
					} catch (t) {
						return i.call(this, e);
					}
				}
			}
			var a = [];
			var o = false;
			var c;
			var u = -1;
			function cleanUpNextTick() {
				if (!o || !c) {
					return;
				}
				o = false;
				if (c.length) {
					a = c.concat(a);
				} else {
					u = -1;
				}
				if (a.length) {
					drainQueue();
				}
			}
			function drainQueue() {
				if (o) {
					return;
				}
				var e = runTimeout(cleanUpNextTick);
				o = true;
				var t = a.length;
				while (t) {
					c = a;
					a = [];
					while (++u < t) {
						if (c) {
							c[u].run();
						}
					}
					u = -1;
					t = a.length;
				}
				c = null;
				o = false;
				runClearTimeout(e);
			}
			t.nextTick = function (e) {
				var t = new Array(arguments.length - 1);
				if (arguments.length > 1) {
					for (var r = 1; r < arguments.length; r++) {
						t[r - 1] = arguments[r];
					}
				}
				a.push(new Item(e, t));
				if (a.length === 1 && !o) {
					runTimeout(drainQueue);
				}
			};
			function Item(e, t) {
				this.fun = e;
				this.array = t;
			}
			Item.prototype.run = function () {
				this.fun.apply(null, this.array);
			};
			t.title = 'browser';
			t.browser = true;
			t.env = {};
			t.argv = [];
			t.version = '';
			t.versions = {};
			function noop() {}
			t.on = noop;
			t.addListener = noop;
			t.once = noop;
			t.off = noop;
			t.removeListener = noop;
			t.removeAllListeners = noop;
			t.emit = noop;
			t.prependListener = noop;
			t.prependOnceListener = noop;
			t.listeners = function (e) {
				return [];
			};
			t.binding = function (e) {
				throw new Error('process.binding is not supported');
			};
			t.cwd = function () {
				return '/';
			};
			t.chdir = function (e) {
				throw new Error('process.chdir is not supported');
			};
			t.umask = function () {
				return 0;
			};
		},
		940: (e) => {
			'use strict';
			function Cache(e) {
				this._maxSize = e;
				this.clear();
			}
			Cache.prototype.clear = function () {
				this._size = 0;
				this._values = Object.create(null);
			};
			Cache.prototype.get = function (e) {
				return this._values[e];
			};
			Cache.prototype.set = function (e, t) {
				this._size >= this._maxSize && this.clear();
				if (!(e in this._values)) this._size++;
				return (this._values[e] = t);
			};
			var t = /[^.^\]^[]+|(?=\[\]|\.\.)/g,
				r = /^\d+$/,
				i = /^\d/,
				a = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g,
				o = /^\s*(['"]?)(.*?)(\1)\s*$/,
				c = 512;
			var u = new Cache(c),
				l = new Cache(c),
				d = new Cache(c);
			var p;
			e.exports = {
				Cache,
				split,
				normalizePath,
				setter: function (e) {
					var t = normalizePath(e);
					return (
						l.get(e) ||
						l.set(e, function setter(e, r) {
							var i = 0;
							var a = t.length;
							var o = e;
							while (i < a - 1) {
								var c = t[i];
								if (c === '__proto__' || c === 'constructor' || c === 'prototype') {
									return e;
								}
								o = o[t[i++]];
							}
							o[t[i]] = r;
						})
					);
				},
				getter: function (e, t) {
					var r = normalizePath(e);
					return (
						d.get(e) ||
						d.set(e, function getter(e) {
							var i = 0,
								a = r.length;
							while (i < a) {
								if (e != null || !t) e = e[r[i++]];
								else return;
							}
							return e;
						})
					);
				},
				join: function (e) {
					return e.reduce(function (e, t) {
						return e + (isQuoted(t) || r.test(t) ? '[' + t + ']' : (e ? '.' : '') + t);
					}, '');
				},
				forEach: function (e, t, r) {
					forEach(Array.isArray(e) ? e : split(e), t, r);
				}
			};
			function normalizePath(e) {
				return (
					u.get(e) ||
					u.set(
						e,
						split(e).map(function (e) {
							return e.replace(o, '$2');
						})
					)
				);
			}
			function split(e) {
				return e.match(t) || [''];
			}
			function forEach(e, t, r) {
				var i = e.length,
					a,
					o,
					c,
					u;
				for (o = 0; o < i; o++) {
					a = e[o];
					if (a) {
						if (shouldBeQuoted(a)) {
							a = '"' + a + '"';
						}
						u = isQuoted(a);
						c = !u && /^\d+$/.test(a);
						t.call(r, a, u, c, o, e);
					}
				}
			}
			function isQuoted(e) {
				return typeof e === 'string' && e && ["'", '"'].indexOf(e.charAt(0)) !== -1;
			}
			function hasLeadingNumber(e) {
				return e.match(i) && !e.match(r);
			}
			function hasSpecialChars(e) {
				return a.test(e);
			}
			function shouldBeQuoted(e) {
				return !isQuoted(e) && (hasLeadingNumber(e) || hasSpecialChars(e));
			}
		},
		2211: (e, t, r) => {
			t.publicEncrypt = r(3909);
			t.privateDecrypt = r(2399);
			t.privateEncrypt = function privateEncrypt(e, r) {
				return t.publicEncrypt(e, r, true);
			};
			t.publicDecrypt = function publicDecrypt(e, r) {
				return t.privateDecrypt(e, r, true);
			};
		},
		8929: (e, t, r) => {
			var i = r(8955);
			var a = r(6608).Buffer;
			e.exports = function (e, t) {
				var r = a.alloc(0);
				var o = 0;
				var c;
				while (r.length < t) {
					c = i2ops(o++);
					r = a.concat([r, i('sha1').update(e).update(c).digest()]);
				}
				return r.slice(0, t);
			};
			function i2ops(e) {
				var t = a.allocUnsafe(4);
				t.writeUInt32BE(e, 0);
				return t;
			}
		},
		2399: (e, t, r) => {
			var i = r(9979);
			var a = r(8929);
			var o = r(7794);
			var c = r(3364);
			var u = r(8538);
			var l = r(8955);
			var d = r(7390);
			var p = r(6608).Buffer;
			e.exports = function privateDecrypt(e, t, r) {
				var a;
				if (e.padding) {
					a = e.padding;
				} else if (r) {
					a = 1;
				} else {
					a = 4;
				}
				var o = i(e);
				var l = o.modulus.byteLength();
				if (t.length > l || new c(t).cmp(o.modulus) >= 0) {
					throw new Error('decryption error');
				}
				var m;
				if (r) {
					m = d(new c(t), o);
				} else {
					m = u(t, o);
				}
				var g = p.alloc(l - m.length);
				m = p.concat([g, m], l);
				if (a === 4) {
					return oaep(o, m);
				} else if (a === 1) {
					return pkcs1(o, m, r);
				} else if (a === 3) {
					return m;
				} else {
					throw new Error('unknown padding');
				}
			};
			function oaep(e, t) {
				var r = e.modulus.byteLength();
				var i = l('sha1').update(p.alloc(0)).digest();
				var c = i.length;
				if (t[0] !== 0) {
					throw new Error('decryption error');
				}
				var u = t.slice(1, c + 1);
				var d = t.slice(c + 1);
				var m = o(u, a(d, c));
				var g = o(d, a(m, r - c - 1));
				if (compare(i, g.slice(0, c))) {
					throw new Error('decryption error');
				}
				var v = c;
				while (g[v] === 0) {
					v++;
				}
				if (g[v++] !== 1) {
					throw new Error('decryption error');
				}
				return g.slice(v);
			}
			function pkcs1(e, t, r) {
				var i = t.slice(0, 2);
				var a = 2;
				var o = 0;
				while (t[a++] !== 0) {
					if (a >= t.length) {
						o++;
						break;
					}
				}
				var c = t.slice(2, a - 1);
				if ((i.toString('hex') !== '0002' && !r) || (i.toString('hex') !== '0001' && r)) {
					o++;
				}
				if (c.length < 8) {
					o++;
				}
				if (o) {
					throw new Error('decryption error');
				}
				return t.slice(a);
			}
			function compare(e, t) {
				e = p.from(e);
				t = p.from(t);
				var r = 0;
				var i = e.length;
				if (e.length !== t.length) {
					r++;
					i = Math.min(e.length, t.length);
				}
				var a = -1;
				while (++a < i) {
					r += e[a] ^ t[a];
				}
				return r;
			}
		},
		3909: (e, t, r) => {
			var i = r(9979);
			var a = r(2869);
			var o = r(8955);
			var c = r(8929);
			var u = r(7794);
			var l = r(3364);
			var d = r(7390);
			var p = r(8538);
			var m = r(6608).Buffer;
			e.exports = function publicEncrypt(e, t, r) {
				var a;
				if (e.padding) {
					a = e.padding;
				} else if (r) {
					a = 1;
				} else {
					a = 4;
				}
				var o = i(e);
				var c;
				if (a === 4) {
					c = oaep(o, t);
				} else if (a === 1) {
					c = pkcs1(o, t, r);
				} else if (a === 3) {
					c = new l(t);
					if (c.cmp(o.modulus) >= 0) {
						throw new Error('data too long for modulus');
					}
				} else {
					throw new Error('unknown padding');
				}
				if (r) {
					return p(c, o);
				} else {
					return d(c, o);
				}
			};
			function oaep(e, t) {
				var r = e.modulus.byteLength();
				var i = t.length;
				var d = o('sha1').update(m.alloc(0)).digest();
				var p = d.length;
				var g = 2 * p;
				if (i > r - g - 2) {
					throw new Error('message too long');
				}
				var v = m.alloc(r - i - g - 2);
				var y = r - p - 1;
				var w = a(p);
				var _ = u(m.concat([d, v, m.alloc(1, 1), t], y), c(w, y));
				var A = u(w, c(_, p));
				return new l(m.concat([m.alloc(1), A, _], r));
			}
			function pkcs1(e, t, r) {
				var i = t.length;
				var a = e.modulus.byteLength();
				if (i > a - 11) {
					throw new Error('message too long');
				}
				var o;
				if (r) {
					o = m.alloc(a - i - 3, 255);
				} else {
					o = nonZero(a - i - 3);
				}
				return new l(m.concat([m.from([0, r ? 1 : 2]), o, m.alloc(1), t], a));
			}
			function nonZero(e) {
				var t = m.allocUnsafe(e);
				var r = 0;
				var i = a(e * 2);
				var o = 0;
				var c;
				while (r < e) {
					if (o === i.length) {
						i = a(e * 2);
						o = 0;
					}
					c = i[o++];
					if (c) {
						t[r++] = c;
					}
				}
				return t;
			}
		},
		7390: (e, t, r) => {
			var i = r(3364);
			var a = r(6608).Buffer;
			function withPublic(e, t) {
				return a.from(
					e.toRed(i.mont(t.modulus)).redPow(new i(t.publicExponent)).fromRed().toArray()
				);
			}
			e.exports = withPublic;
		},
		7794: (e) => {
			e.exports = function xor(e, t) {
				var r = e.length;
				var i = -1;
				while (++i < r) {
					e[i] ^= t[i];
				}
				return e;
			};
		},
		2869: (e, t, r) => {
			'use strict';
			var i = r(5409);
			var a = 65536;
			var o = 4294967295;
			function oldBrowser() {
				throw new Error(
					'Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11'
				);
			}
			var c = r(6608).Buffer;
			var u = r.g.crypto || r.g.msCrypto;
			if (u && u.getRandomValues) {
				e.exports = randomBytes;
			} else {
				e.exports = oldBrowser;
			}
			function randomBytes(e, t) {
				if (e > o) throw new RangeError('requested too many random bytes');
				var r = c.allocUnsafe(e);
				if (e > 0) {
					if (e > a) {
						for (var l = 0; l < e; l += a) {
							u.getRandomValues(r.slice(l, l + a));
						}
					} else {
						u.getRandomValues(r);
					}
				}
				if (typeof t === 'function') {
					return i.nextTick(function () {
						t(null, r);
					});
				}
				return r;
			}
		},
		4925: (e, t, r) => {
			'use strict';
			var i = r(5409);
			function oldBrowser() {
				throw new Error(
					'secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11'
				);
			}
			var a = r(6608);
			var o = r(2869);
			var c = a.Buffer;
			var u = a.kMaxLength;
			var l = r.g.crypto || r.g.msCrypto;
			var d = Math.pow(2, 32) - 1;
			function assertOffset(e, t) {
				if (typeof e !== 'number' || e !== e) {
					throw new TypeError('offset must be a number');
				}
				if (e > d || e < 0) {
					throw new TypeError('offset must be a uint32');
				}
				if (e > u || e > t) {
					throw new RangeError('offset out of range');
				}
			}
			function assertSize(e, t, r) {
				if (typeof e !== 'number' || e !== e) {
					throw new TypeError('size must be a number');
				}
				if (e > d || e < 0) {
					throw new TypeError('size must be a uint32');
				}
				if (e + t > r || e > u) {
					throw new RangeError('buffer too small');
				}
			}
			if ((l && l.getRandomValues) || !i.browser) {
				t.randomFill = randomFill;
				t.randomFillSync = randomFillSync;
			} else {
				t.randomFill = oldBrowser;
				t.randomFillSync = oldBrowser;
			}
			function randomFill(e, t, i, a) {
				if (!c.isBuffer(e) && !(e instanceof r.g.Uint8Array)) {
					throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
				}
				if (typeof t === 'function') {
					a = t;
					t = 0;
					i = e.length;
				} else if (typeof i === 'function') {
					a = i;
					i = e.length - t;
				} else if (typeof a !== 'function') {
					throw new TypeError('"cb" argument must be a function');
				}
				assertOffset(t, e.length);
				assertSize(i, t, e.length);
				return actualFill(e, t, i, a);
			}
			function actualFill(e, t, r, a) {
				if (i.browser) {
					var c = e.buffer;
					var u = new Uint8Array(c, t, r);
					l.getRandomValues(u);
					if (a) {
						i.nextTick(function () {
							a(null, e);
						});
						return;
					}
					return e;
				}
				if (a) {
					o(r, function (r, i) {
						if (r) {
							return a(r);
						}
						i.copy(e, t);
						a(null, e);
					});
					return;
				}
				var d = o(r);
				d.copy(e, t);
				return e;
			}
			function randomFillSync(e, t, i) {
				if (typeof t === 'undefined') {
					t = 0;
				}
				if (!c.isBuffer(e) && !(e instanceof r.g.Uint8Array)) {
					throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
				}
				assertOffset(t, e.length);
				if (i === undefined) i = e.length - t;
				assertSize(i, t, e.length);
				return actualFill(e, t, i);
			}
		},
		6357: (e, t, r) => {
			'use strict';
			var i = r(9387);
			var a =
				Object.keys ||
				function (e) {
					var t = [];
					for (var r in e) {
						t.push(r);
					}
					return t;
				};
			e.exports = Duplex;
			var o = Object.create(r(1166));
			o.inherits = r(1193);
			var c = r(1755);
			var u = r(8511);
			o.inherits(Duplex, c);
			{
				var l = a(u.prototype);
				for (var d = 0; d < l.length; d++) {
					var p = l[d];
					if (!Duplex.prototype[p]) Duplex.prototype[p] = u.prototype[p];
				}
			}
			function Duplex(e) {
				if (!(this instanceof Duplex)) return new Duplex(e);
				c.call(this, e);
				u.call(this, e);
				if (e && e.readable === false) this.readable = false;
				if (e && e.writable === false) this.writable = false;
				this.allowHalfOpen = true;
				if (e && e.allowHalfOpen === false) this.allowHalfOpen = false;
				this.once('end', onend);
			}
			Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
				enumerable: false,
				get: function () {
					return this._writableState.highWaterMark;
				}
			});
			function onend() {
				if (this.allowHalfOpen || this._writableState.ended) return;
				i.nextTick(onEndNT, this);
			}
			function onEndNT(e) {
				e.end();
			}
			Object.defineProperty(Duplex.prototype, 'destroyed', {
				get: function () {
					if (this._readableState === undefined || this._writableState === undefined) {
						return false;
					}
					return this._readableState.destroyed && this._writableState.destroyed;
				},
				set: function (e) {
					if (this._readableState === undefined || this._writableState === undefined) {
						return;
					}
					this._readableState.destroyed = e;
					this._writableState.destroyed = e;
				}
			});
			Duplex.prototype._destroy = function (e, t) {
				this.push(null);
				this.end();
				i.nextTick(t, e);
			};
		},
		5825: (e, t, r) => {
			'use strict';
			e.exports = PassThrough;
			var i = r(8235);
			var a = Object.create(r(1166));
			a.inherits = r(1193);
			a.inherits(PassThrough, i);
			function PassThrough(e) {
				if (!(this instanceof PassThrough)) return new PassThrough(e);
				i.call(this, e);
			}
			PassThrough.prototype._transform = function (e, t, r) {
				r(null, e);
			};
		},
		1755: (e, t, r) => {
			'use strict';
			var i = r(5409);
			var a = r(9387);
			e.exports = Readable;
			var o = r(5101);
			var c;
			Readable.ReadableState = ReadableState;
			var u = r(381).EventEmitter;
			var EElistenerCount = function (e, t) {
				return e.listeners(t).length;
			};
			var l = r(4484);
			var d = r(8604).Buffer;
			var p =
				(typeof r.g !== 'undefined'
					? r.g
					: typeof window !== 'undefined'
						? window
						: typeof self !== 'undefined'
							? self
							: {}
				).Uint8Array || function () {};
			function _uint8ArrayToBuffer(e) {
				return d.from(e);
			}
			function _isUint8Array(e) {
				return d.isBuffer(e) || e instanceof p;
			}
			var m = Object.create(r(1166));
			m.inherits = r(1193);
			var g = r(7679);
			var v = void 0;
			if (g && g.debuglog) {
				v = g.debuglog('stream');
			} else {
				v = function () {};
			}
			var y = r(3211);
			var w = r(6955);
			var _;
			m.inherits(Readable, l);
			var A = ['error', 'close', 'destroy', 'pause', 'resume'];
			function prependListener(e, t, r) {
				if (typeof e.prependListener === 'function') return e.prependListener(t, r);
				if (!e._events || !e._events[t]) e.on(t, r);
				else if (o(e._events[t])) e._events[t].unshift(r);
				else e._events[t] = [r, e._events[t]];
			}
			function ReadableState(e, t) {
				c = c || r(6357);
				e = e || {};
				var i = t instanceof c;
				this.objectMode = !!e.objectMode;
				if (i) this.objectMode = this.objectMode || !!e.readableObjectMode;
				var a = e.highWaterMark;
				var o = e.readableHighWaterMark;
				var u = this.objectMode ? 16 : 16 * 1024;
				if (a || a === 0) this.highWaterMark = a;
				else if (i && (o || o === 0)) this.highWaterMark = o;
				else this.highWaterMark = u;
				this.highWaterMark = Math.floor(this.highWaterMark);
				this.buffer = new y();
				this.length = 0;
				this.pipes = null;
				this.pipesCount = 0;
				this.flowing = null;
				this.ended = false;
				this.endEmitted = false;
				this.reading = false;
				this.sync = true;
				this.needReadable = false;
				this.emittedReadable = false;
				this.readableListening = false;
				this.resumeScheduled = false;
				this.destroyed = false;
				this.defaultEncoding = e.defaultEncoding || 'utf8';
				this.awaitDrain = 0;
				this.readingMore = false;
				this.decoder = null;
				this.encoding = null;
				if (e.encoding) {
					if (!_) _ = r(9851).I;
					this.decoder = new _(e.encoding);
					this.encoding = e.encoding;
				}
			}
			function Readable(e) {
				c = c || r(6357);
				if (!(this instanceof Readable)) return new Readable(e);
				this._readableState = new ReadableState(e, this);
				this.readable = true;
				if (e) {
					if (typeof e.read === 'function') this._read = e.read;
					if (typeof e.destroy === 'function') this._destroy = e.destroy;
				}
				l.call(this);
			}
			Object.defineProperty(Readable.prototype, 'destroyed', {
				get: function () {
					if (this._readableState === undefined) {
						return false;
					}
					return this._readableState.destroyed;
				},
				set: function (e) {
					if (!this._readableState) {
						return;
					}
					this._readableState.destroyed = e;
				}
			});
			Readable.prototype.destroy = w.destroy;
			Readable.prototype._undestroy = w.undestroy;
			Readable.prototype._destroy = function (e, t) {
				this.push(null);
				t(e);
			};
			Readable.prototype.push = function (e, t) {
				var r = this._readableState;
				var i;
				if (!r.objectMode) {
					if (typeof e === 'string') {
						t = t || r.defaultEncoding;
						if (t !== r.encoding) {
							e = d.from(e, t);
							t = '';
						}
						i = true;
					}
				} else {
					i = true;
				}
				return readableAddChunk(this, e, t, false, i);
			};
			Readable.prototype.unshift = function (e) {
				return readableAddChunk(this, e, null, true, false);
			};
			function readableAddChunk(e, t, r, i, a) {
				var o = e._readableState;
				if (t === null) {
					o.reading = false;
					onEofChunk(e, o);
				} else {
					var c;
					if (!a) c = chunkInvalid(o, t);
					if (c) {
						e.emit('error', c);
					} else if (o.objectMode || (t && t.length > 0)) {
						if (
							typeof t !== 'string' &&
							!o.objectMode &&
							Object.getPrototypeOf(t) !== d.prototype
						) {
							t = _uint8ArrayToBuffer(t);
						}
						if (i) {
							if (o.endEmitted) e.emit('error', new Error('stream.unshift() after end event'));
							else addChunk(e, o, t, true);
						} else if (o.ended) {
							e.emit('error', new Error('stream.push() after EOF'));
						} else {
							o.reading = false;
							if (o.decoder && !r) {
								t = o.decoder.write(t);
								if (o.objectMode || t.length !== 0) addChunk(e, o, t, false);
								else maybeReadMore(e, o);
							} else {
								addChunk(e, o, t, false);
							}
						}
					} else if (!i) {
						o.reading = false;
					}
				}
				return needMoreData(o);
			}
			function addChunk(e, t, r, i) {
				if (t.flowing && t.length === 0 && !t.sync) {
					e.emit('data', r);
					e.read(0);
				} else {
					t.length += t.objectMode ? 1 : r.length;
					if (i) t.buffer.unshift(r);
					else t.buffer.push(r);
					if (t.needReadable) emitReadable(e);
				}
				maybeReadMore(e, t);
			}
			function chunkInvalid(e, t) {
				var r;
				if (!_isUint8Array(t) && typeof t !== 'string' && t !== undefined && !e.objectMode) {
					r = new TypeError('Invalid non-string/buffer chunk');
				}
				return r;
			}
			function needMoreData(e) {
				return !e.ended && (e.needReadable || e.length < e.highWaterMark || e.length === 0);
			}
			Readable.prototype.isPaused = function () {
				return this._readableState.flowing === false;
			};
			Readable.prototype.setEncoding = function (e) {
				if (!_) _ = r(9851).I;
				this._readableState.decoder = new _(e);
				this._readableState.encoding = e;
				return this;
			};
			var k = 8388608;
			function computeNewHighWaterMark(e) {
				if (e >= k) {
					e = k;
				} else {
					e--;
					e |= e >>> 1;
					e |= e >>> 2;
					e |= e >>> 4;
					e |= e >>> 8;
					e |= e >>> 16;
					e++;
				}
				return e;
			}
			function howMuchToRead(e, t) {
				if (e <= 0 || (t.length === 0 && t.ended)) return 0;
				if (t.objectMode) return 1;
				if (e !== e) {
					if (t.flowing && t.length) return t.buffer.head.data.length;
					else return t.length;
				}
				if (e > t.highWaterMark) t.highWaterMark = computeNewHighWaterMark(e);
				if (e <= t.length) return e;
				if (!t.ended) {
					t.needReadable = true;
					return 0;
				}
				return t.length;
			}
			Readable.prototype.read = function (e) {
				v('read', e);
				e = parseInt(e, 10);
				var t = this._readableState;
				var r = e;
				if (e !== 0) t.emittedReadable = false;
				if (e === 0 && t.needReadable && (t.length >= t.highWaterMark || t.ended)) {
					v('read: emitReadable', t.length, t.ended);
					if (t.length === 0 && t.ended) endReadable(this);
					else emitReadable(this);
					return null;
				}
				e = howMuchToRead(e, t);
				if (e === 0 && t.ended) {
					if (t.length === 0) endReadable(this);
					return null;
				}
				var i = t.needReadable;
				v('need readable', i);
				if (t.length === 0 || t.length - e < t.highWaterMark) {
					i = true;
					v('length less than watermark', i);
				}
				if (t.ended || t.reading) {
					i = false;
					v('reading or ended', i);
				} else if (i) {
					v('do read');
					t.reading = true;
					t.sync = true;
					if (t.length === 0) t.needReadable = true;
					this._read(t.highWaterMark);
					t.sync = false;
					if (!t.reading) e = howMuchToRead(r, t);
				}
				var a;
				if (e > 0) a = fromList(e, t);
				else a = null;
				if (a === null) {
					t.needReadable = true;
					e = 0;
				} else {
					t.length -= e;
				}
				if (t.length === 0) {
					if (!t.ended) t.needReadable = true;
					if (r !== e && t.ended) endReadable(this);
				}
				if (a !== null) this.emit('data', a);
				return a;
			};
			function onEofChunk(e, t) {
				if (t.ended) return;
				if (t.decoder) {
					var r = t.decoder.end();
					if (r && r.length) {
						t.buffer.push(r);
						t.length += t.objectMode ? 1 : r.length;
					}
				}
				t.ended = true;
				emitReadable(e);
			}
			function emitReadable(e) {
				var t = e._readableState;
				t.needReadable = false;
				if (!t.emittedReadable) {
					v('emitReadable', t.flowing);
					t.emittedReadable = true;
					if (t.sync) a.nextTick(emitReadable_, e);
					else emitReadable_(e);
				}
			}
			function emitReadable_(e) {
				v('emit readable');
				e.emit('readable');
				flow(e);
			}
			function maybeReadMore(e, t) {
				if (!t.readingMore) {
					t.readingMore = true;
					a.nextTick(maybeReadMore_, e, t);
				}
			}
			function maybeReadMore_(e, t) {
				var r = t.length;
				while (!t.reading && !t.flowing && !t.ended && t.length < t.highWaterMark) {
					v('maybeReadMore read 0');
					e.read(0);
					if (r === t.length) break;
					else r = t.length;
				}
				t.readingMore = false;
			}
			Readable.prototype._read = function (e) {
				this.emit('error', new Error('_read() is not implemented'));
			};
			Readable.prototype.pipe = function (e, t) {
				var r = this;
				var o = this._readableState;
				switch (o.pipesCount) {
					case 0:
						o.pipes = e;
						break;
					case 1:
						o.pipes = [o.pipes, e];
						break;
					default:
						o.pipes.push(e);
						break;
				}
				o.pipesCount += 1;
				v('pipe count=%d opts=%j', o.pipesCount, t);
				var c = (!t || t.end !== false) && e !== i.stdout && e !== i.stderr;
				var u = c ? onend : unpipe;
				if (o.endEmitted) a.nextTick(u);
				else r.once('end', u);
				e.on('unpipe', onunpipe);
				function onunpipe(e, t) {
					v('onunpipe');
					if (e === r) {
						if (t && t.hasUnpiped === false) {
							t.hasUnpiped = true;
							cleanup();
						}
					}
				}
				function onend() {
					v('onend');
					e.end();
				}
				var l = pipeOnDrain(r);
				e.on('drain', l);
				var d = false;
				function cleanup() {
					v('cleanup');
					e.removeListener('close', onclose);
					e.removeListener('finish', onfinish);
					e.removeListener('drain', l);
					e.removeListener('error', onerror);
					e.removeListener('unpipe', onunpipe);
					r.removeListener('end', onend);
					r.removeListener('end', unpipe);
					r.removeListener('data', ondata);
					d = true;
					if (o.awaitDrain && (!e._writableState || e._writableState.needDrain)) l();
				}
				var p = false;
				r.on('data', ondata);
				function ondata(t) {
					v('ondata');
					p = false;
					var i = e.write(t);
					if (false === i && !p) {
						if (
							((o.pipesCount === 1 && o.pipes === e) ||
								(o.pipesCount > 1 && indexOf(o.pipes, e) !== -1)) &&
							!d
						) {
							v('false write response, pause', o.awaitDrain);
							o.awaitDrain++;
							p = true;
						}
						r.pause();
					}
				}
				function onerror(t) {
					v('onerror', t);
					unpipe();
					e.removeListener('error', onerror);
					if (EElistenerCount(e, 'error') === 0) e.emit('error', t);
				}
				prependListener(e, 'error', onerror);
				function onclose() {
					e.removeListener('finish', onfinish);
					unpipe();
				}
				e.once('close', onclose);
				function onfinish() {
					v('onfinish');
					e.removeListener('close', onclose);
					unpipe();
				}
				e.once('finish', onfinish);
				function unpipe() {
					v('unpipe');
					r.unpipe(e);
				}
				e.emit('pipe', r);
				if (!o.flowing) {
					v('pipe resume');
					r.resume();
				}
				return e;
			};
			function pipeOnDrain(e) {
				return function () {
					var t = e._readableState;
					v('pipeOnDrain', t.awaitDrain);
					if (t.awaitDrain) t.awaitDrain--;
					if (t.awaitDrain === 0 && EElistenerCount(e, 'data')) {
						t.flowing = true;
						flow(e);
					}
				};
			}
			Readable.prototype.unpipe = function (e) {
				var t = this._readableState;
				var r = { hasUnpiped: false };
				if (t.pipesCount === 0) return this;
				if (t.pipesCount === 1) {
					if (e && e !== t.pipes) return this;
					if (!e) e = t.pipes;
					t.pipes = null;
					t.pipesCount = 0;
					t.flowing = false;
					if (e) e.emit('unpipe', this, r);
					return this;
				}
				if (!e) {
					var i = t.pipes;
					var a = t.pipesCount;
					t.pipes = null;
					t.pipesCount = 0;
					t.flowing = false;
					for (var o = 0; o < a; o++) {
						i[o].emit('unpipe', this, { hasUnpiped: false });
					}
					return this;
				}
				var c = indexOf(t.pipes, e);
				if (c === -1) return this;
				t.pipes.splice(c, 1);
				t.pipesCount -= 1;
				if (t.pipesCount === 1) t.pipes = t.pipes[0];
				e.emit('unpipe', this, r);
				return this;
			};
			Readable.prototype.on = function (e, t) {
				var r = l.prototype.on.call(this, e, t);
				if (e === 'data') {
					if (this._readableState.flowing !== false) this.resume();
				} else if (e === 'readable') {
					var i = this._readableState;
					if (!i.endEmitted && !i.readableListening) {
						i.readableListening = i.needReadable = true;
						i.emittedReadable = false;
						if (!i.reading) {
							a.nextTick(nReadingNextTick, this);
						} else if (i.length) {
							emitReadable(this);
						}
					}
				}
				return r;
			};
			Readable.prototype.addListener = Readable.prototype.on;
			function nReadingNextTick(e) {
				v('readable nexttick read 0');
				e.read(0);
			}
			Readable.prototype.resume = function () {
				var e = this._readableState;
				if (!e.flowing) {
					v('resume');
					e.flowing = true;
					resume(this, e);
				}
				return this;
			};
			function resume(e, t) {
				if (!t.resumeScheduled) {
					t.resumeScheduled = true;
					a.nextTick(resume_, e, t);
				}
			}
			function resume_(e, t) {
				if (!t.reading) {
					v('resume read 0');
					e.read(0);
				}
				t.resumeScheduled = false;
				t.awaitDrain = 0;
				e.emit('resume');
				flow(e);
				if (t.flowing && !t.reading) e.read(0);
			}
			Readable.prototype.pause = function () {
				v('call pause flowing=%j', this._readableState.flowing);
				if (false !== this._readableState.flowing) {
					v('pause');
					this._readableState.flowing = false;
					this.emit('pause');
				}
				return this;
			};
			function flow(e) {
				var t = e._readableState;
				v('flow', t.flowing);
				while (t.flowing && e.read() !== null) {}
			}
			Readable.prototype.wrap = function (e) {
				var t = this;
				var r = this._readableState;
				var i = false;
				e.on('end', function () {
					v('wrapped end');
					if (r.decoder && !r.ended) {
						var e = r.decoder.end();
						if (e && e.length) t.push(e);
					}
					t.push(null);
				});
				e.on('data', function (a) {
					v('wrapped data');
					if (r.decoder) a = r.decoder.write(a);
					if (r.objectMode && (a === null || a === undefined)) return;
					else if (!r.objectMode && (!a || !a.length)) return;
					var o = t.push(a);
					if (!o) {
						i = true;
						e.pause();
					}
				});
				for (var a in e) {
					if (this[a] === undefined && typeof e[a] === 'function') {
						this[a] = (function (t) {
							return function () {
								return e[t].apply(e, arguments);
							};
						})(a);
					}
				}
				for (var o = 0; o < A.length; o++) {
					e.on(A[o], this.emit.bind(this, A[o]));
				}
				this._read = function (t) {
					v('wrapped _read', t);
					if (i) {
						i = false;
						e.resume();
					}
				};
				return this;
			};
			Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
				enumerable: false,
				get: function () {
					return this._readableState.highWaterMark;
				}
			});
			Readable._fromList = fromList;
			function fromList(e, t) {
				if (t.length === 0) return null;
				var r;
				if (t.objectMode) r = t.buffer.shift();
				else if (!e || e >= t.length) {
					if (t.decoder) r = t.buffer.join('');
					else if (t.buffer.length === 1) r = t.buffer.head.data;
					else r = t.buffer.concat(t.length);
					t.buffer.clear();
				} else {
					r = fromListPartial(e, t.buffer, t.decoder);
				}
				return r;
			}
			function fromListPartial(e, t, r) {
				var i;
				if (e < t.head.data.length) {
					i = t.head.data.slice(0, e);
					t.head.data = t.head.data.slice(e);
				} else if (e === t.head.data.length) {
					i = t.shift();
				} else {
					i = r ? copyFromBufferString(e, t) : copyFromBuffer(e, t);
				}
				return i;
			}
			function copyFromBufferString(e, t) {
				var r = t.head;
				var i = 1;
				var a = r.data;
				e -= a.length;
				while ((r = r.next)) {
					var o = r.data;
					var c = e > o.length ? o.length : e;
					if (c === o.length) a += o;
					else a += o.slice(0, e);
					e -= c;
					if (e === 0) {
						if (c === o.length) {
							++i;
							if (r.next) t.head = r.next;
							else t.head = t.tail = null;
						} else {
							t.head = r;
							r.data = o.slice(c);
						}
						break;
					}
					++i;
				}
				t.length -= i;
				return a;
			}
			function copyFromBuffer(e, t) {
				var r = d.allocUnsafe(e);
				var i = t.head;
				var a = 1;
				i.data.copy(r);
				e -= i.data.length;
				while ((i = i.next)) {
					var o = i.data;
					var c = e > o.length ? o.length : e;
					o.copy(r, r.length - e, 0, c);
					e -= c;
					if (e === 0) {
						if (c === o.length) {
							++a;
							if (i.next) t.head = i.next;
							else t.head = t.tail = null;
						} else {
							t.head = i;
							i.data = o.slice(c);
						}
						break;
					}
					++a;
				}
				t.length -= a;
				return r;
			}
			function endReadable(e) {
				var t = e._readableState;
				if (t.length > 0) throw new Error('"endReadable()" called on non-empty stream');
				if (!t.endEmitted) {
					t.ended = true;
					a.nextTick(endReadableNT, t, e);
				}
			}
			function endReadableNT(e, t) {
				if (!e.endEmitted && e.length === 0) {
					e.endEmitted = true;
					t.readable = false;
					t.emit('end');
				}
			}
			function indexOf(e, t) {
				for (var r = 0, i = e.length; r < i; r++) {
					if (e[r] === t) return r;
				}
				return -1;
			}
		},
		8235: (e, t, r) => {
			'use strict';
			e.exports = Transform;
			var i = r(6357);
			var a = Object.create(r(1166));
			a.inherits = r(1193);
			a.inherits(Transform, i);
			function afterTransform(e, t) {
				var r = this._transformState;
				r.transforming = false;
				var i = r.writecb;
				if (!i) {
					return this.emit('error', new Error('write callback called multiple times'));
				}
				r.writechunk = null;
				r.writecb = null;
				if (t != null) this.push(t);
				i(e);
				var a = this._readableState;
				a.reading = false;
				if (a.needReadable || a.length < a.highWaterMark) {
					this._read(a.highWaterMark);
				}
			}
			function Transform(e) {
				if (!(this instanceof Transform)) return new Transform(e);
				i.call(this, e);
				this._transformState = {
					afterTransform: afterTransform.bind(this),
					needTransform: false,
					transforming: false,
					writecb: null,
					writechunk: null,
					writeencoding: null
				};
				this._readableState.needReadable = true;
				this._readableState.sync = false;
				if (e) {
					if (typeof e.transform === 'function') this._transform = e.transform;
					if (typeof e.flush === 'function') this._flush = e.flush;
				}
				this.on('prefinish', prefinish);
			}
			function prefinish() {
				var e = this;
				if (typeof this._flush === 'function') {
					this._flush(function (t, r) {
						done(e, t, r);
					});
				} else {
					done(this, null, null);
				}
			}
			Transform.prototype.push = function (e, t) {
				this._transformState.needTransform = false;
				return i.prototype.push.call(this, e, t);
			};
			Transform.prototype._transform = function (e, t, r) {
				throw new Error('_transform() is not implemented');
			};
			Transform.prototype._write = function (e, t, r) {
				var i = this._transformState;
				i.writecb = r;
				i.writechunk = e;
				i.writeencoding = t;
				if (!i.transforming) {
					var a = this._readableState;
					if (i.needTransform || a.needReadable || a.length < a.highWaterMark)
						this._read(a.highWaterMark);
				}
			};
			Transform.prototype._read = function (e) {
				var t = this._transformState;
				if (t.writechunk !== null && t.writecb && !t.transforming) {
					t.transforming = true;
					this._transform(t.writechunk, t.writeencoding, t.afterTransform);
				} else {
					t.needTransform = true;
				}
			};
			Transform.prototype._destroy = function (e, t) {
				var r = this;
				i.prototype._destroy.call(this, e, function (e) {
					t(e);
					r.emit('close');
				});
			};
			function done(e, t, r) {
				if (t) return e.emit('error', t);
				if (r != null) e.push(r);
				if (e._writableState.length) throw new Error('Calling transform done when ws.length != 0');
				if (e._transformState.transforming)
					throw new Error('Calling transform done when still transforming');
				return e.push(null);
			}
		},
		8511: (e, t, r) => {
			'use strict';
			var i = r(5409);
			var a = r(9387);
			e.exports = Writable;
			function WriteReq(e, t, r) {
				this.chunk = e;
				this.encoding = t;
				this.callback = r;
				this.next = null;
			}
			function CorkedRequest(e) {
				var t = this;
				this.next = null;
				this.entry = null;
				this.finish = function () {
					onCorkedFinish(t, e);
				};
			}
			var o =
				!i.browser && ['v0.10', 'v0.9.'].indexOf(i.version.slice(0, 5)) > -1
					? setImmediate
					: a.nextTick;
			var c;
			Writable.WritableState = WritableState;
			var u = Object.create(r(1166));
			u.inherits = r(1193);
			var l = { deprecate: r(1947) };
			var d = r(4484);
			var p = r(8604).Buffer;
			var m =
				(typeof r.g !== 'undefined'
					? r.g
					: typeof window !== 'undefined'
						? window
						: typeof self !== 'undefined'
							? self
							: {}
				).Uint8Array || function () {};
			function _uint8ArrayToBuffer(e) {
				return p.from(e);
			}
			function _isUint8Array(e) {
				return p.isBuffer(e) || e instanceof m;
			}
			var g = r(6955);
			u.inherits(Writable, d);
			function nop() {}
			function WritableState(e, t) {
				c = c || r(6357);
				e = e || {};
				var i = t instanceof c;
				this.objectMode = !!e.objectMode;
				if (i) this.objectMode = this.objectMode || !!e.writableObjectMode;
				var a = e.highWaterMark;
				var o = e.writableHighWaterMark;
				var u = this.objectMode ? 16 : 16 * 1024;
				if (a || a === 0) this.highWaterMark = a;
				else if (i && (o || o === 0)) this.highWaterMark = o;
				else this.highWaterMark = u;
				this.highWaterMark = Math.floor(this.highWaterMark);
				this.finalCalled = false;
				this.needDrain = false;
				this.ending = false;
				this.ended = false;
				this.finished = false;
				this.destroyed = false;
				var l = e.decodeStrings === false;
				this.decodeStrings = !l;
				this.defaultEncoding = e.defaultEncoding || 'utf8';
				this.length = 0;
				this.writing = false;
				this.corked = 0;
				this.sync = true;
				this.bufferProcessing = false;
				this.onwrite = function (e) {
					onwrite(t, e);
				};
				this.writecb = null;
				this.writelen = 0;
				this.bufferedRequest = null;
				this.lastBufferedRequest = null;
				this.pendingcb = 0;
				this.prefinished = false;
				this.errorEmitted = false;
				this.bufferedRequestCount = 0;
				this.corkedRequestsFree = new CorkedRequest(this);
			}
			WritableState.prototype.getBuffer = function getBuffer() {
				var e = this.bufferedRequest;
				var t = [];
				while (e) {
					t.push(e);
					e = e.next;
				}
				return t;
			};
			(function () {
				try {
					Object.defineProperty(WritableState.prototype, 'buffer', {
						get: l.deprecate(
							function () {
								return this.getBuffer();
							},
							'_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.',
							'DEP0003'
						)
					});
				} catch (e) {}
			})();
			var v;
			if (
				typeof Symbol === 'function' &&
				Symbol.hasInstance &&
				typeof Function.prototype[Symbol.hasInstance] === 'function'
			) {
				v = Function.prototype[Symbol.hasInstance];
				Object.defineProperty(Writable, Symbol.hasInstance, {
					value: function (e) {
						if (v.call(this, e)) return true;
						if (this !== Writable) return false;
						return e && e._writableState instanceof WritableState;
					}
				});
			} else {
				v = function (e) {
					return e instanceof this;
				};
			}
			function Writable(e) {
				c = c || r(6357);
				if (!v.call(Writable, this) && !(this instanceof c)) {
					return new Writable(e);
				}
				this._writableState = new WritableState(e, this);
				this.writable = true;
				if (e) {
					if (typeof e.write === 'function') this._write = e.write;
					if (typeof e.writev === 'function') this._writev = e.writev;
					if (typeof e.destroy === 'function') this._destroy = e.destroy;
					if (typeof e.final === 'function') this._final = e.final;
				}
				d.call(this);
			}
			Writable.prototype.pipe = function () {
				this.emit('error', new Error('Cannot pipe, not readable'));
			};
			function writeAfterEnd(e, t) {
				var r = new Error('write after end');
				e.emit('error', r);
				a.nextTick(t, r);
			}
			function validChunk(e, t, r, i) {
				var o = true;
				var c = false;
				if (r === null) {
					c = new TypeError('May not write null values to stream');
				} else if (typeof r !== 'string' && r !== undefined && !t.objectMode) {
					c = new TypeError('Invalid non-string/buffer chunk');
				}
				if (c) {
					e.emit('error', c);
					a.nextTick(i, c);
					o = false;
				}
				return o;
			}
			Writable.prototype.write = function (e, t, r) {
				var i = this._writableState;
				var a = false;
				var o = !i.objectMode && _isUint8Array(e);
				if (o && !p.isBuffer(e)) {
					e = _uint8ArrayToBuffer(e);
				}
				if (typeof t === 'function') {
					r = t;
					t = null;
				}
				if (o) t = 'buffer';
				else if (!t) t = i.defaultEncoding;
				if (typeof r !== 'function') r = nop;
				if (i.ended) writeAfterEnd(this, r);
				else if (o || validChunk(this, i, e, r)) {
					i.pendingcb++;
					a = writeOrBuffer(this, i, o, e, t, r);
				}
				return a;
			};
			Writable.prototype.cork = function () {
				var e = this._writableState;
				e.corked++;
			};
			Writable.prototype.uncork = function () {
				var e = this._writableState;
				if (e.corked) {
					e.corked--;
					if (!e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest)
						clearBuffer(this, e);
				}
			};
			Writable.prototype.setDefaultEncoding = function setDefaultEncoding(e) {
				if (typeof e === 'string') e = e.toLowerCase();
				if (
					!(
						[
							'hex',
							'utf8',
							'utf-8',
							'ascii',
							'binary',
							'base64',
							'ucs2',
							'ucs-2',
							'utf16le',
							'utf-16le',
							'raw'
						].indexOf((e + '').toLowerCase()) > -1
					)
				)
					throw new TypeError('Unknown encoding: ' + e);
				this._writableState.defaultEncoding = e;
				return this;
			};
			function decodeChunk(e, t, r) {
				if (!e.objectMode && e.decodeStrings !== false && typeof t === 'string') {
					t = p.from(t, r);
				}
				return t;
			}
			Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
				enumerable: false,
				get: function () {
					return this._writableState.highWaterMark;
				}
			});
			function writeOrBuffer(e, t, r, i, a, o) {
				if (!r) {
					var c = decodeChunk(t, i, a);
					if (i !== c) {
						r = true;
						a = 'buffer';
						i = c;
					}
				}
				var u = t.objectMode ? 1 : i.length;
				t.length += u;
				var l = t.length < t.highWaterMark;
				if (!l) t.needDrain = true;
				if (t.writing || t.corked) {
					var d = t.lastBufferedRequest;
					t.lastBufferedRequest = { chunk: i, encoding: a, isBuf: r, callback: o, next: null };
					if (d) {
						d.next = t.lastBufferedRequest;
					} else {
						t.bufferedRequest = t.lastBufferedRequest;
					}
					t.bufferedRequestCount += 1;
				} else {
					doWrite(e, t, false, u, i, a, o);
				}
				return l;
			}
			function doWrite(e, t, r, i, a, o, c) {
				t.writelen = i;
				t.writecb = c;
				t.writing = true;
				t.sync = true;
				if (r) e._writev(a, t.onwrite);
				else e._write(a, o, t.onwrite);
				t.sync = false;
			}
			function onwriteError(e, t, r, i, o) {
				--t.pendingcb;
				if (r) {
					a.nextTick(o, i);
					a.nextTick(finishMaybe, e, t);
					e._writableState.errorEmitted = true;
					e.emit('error', i);
				} else {
					o(i);
					e._writableState.errorEmitted = true;
					e.emit('error', i);
					finishMaybe(e, t);
				}
			}
			function onwriteStateUpdate(e) {
				e.writing = false;
				e.writecb = null;
				e.length -= e.writelen;
				e.writelen = 0;
			}
			function onwrite(e, t) {
				var r = e._writableState;
				var i = r.sync;
				var a = r.writecb;
				onwriteStateUpdate(r);
				if (t) onwriteError(e, r, i, t, a);
				else {
					var c = needFinish(r);
					if (!c && !r.corked && !r.bufferProcessing && r.bufferedRequest) {
						clearBuffer(e, r);
					}
					if (i) {
						o(afterWrite, e, r, c, a);
					} else {
						afterWrite(e, r, c, a);
					}
				}
			}
			function afterWrite(e, t, r, i) {
				if (!r) onwriteDrain(e, t);
				t.pendingcb--;
				i();
				finishMaybe(e, t);
			}
			function onwriteDrain(e, t) {
				if (t.length === 0 && t.needDrain) {
					t.needDrain = false;
					e.emit('drain');
				}
			}
			function clearBuffer(e, t) {
				t.bufferProcessing = true;
				var r = t.bufferedRequest;
				if (e._writev && r && r.next) {
					var i = t.bufferedRequestCount;
					var a = new Array(i);
					var o = t.corkedRequestsFree;
					o.entry = r;
					var c = 0;
					var u = true;
					while (r) {
						a[c] = r;
						if (!r.isBuf) u = false;
						r = r.next;
						c += 1;
					}
					a.allBuffers = u;
					doWrite(e, t, true, t.length, a, '', o.finish);
					t.pendingcb++;
					t.lastBufferedRequest = null;
					if (o.next) {
						t.corkedRequestsFree = o.next;
						o.next = null;
					} else {
						t.corkedRequestsFree = new CorkedRequest(t);
					}
					t.bufferedRequestCount = 0;
				} else {
					while (r) {
						var l = r.chunk;
						var d = r.encoding;
						var p = r.callback;
						var m = t.objectMode ? 1 : l.length;
						doWrite(e, t, false, m, l, d, p);
						r = r.next;
						t.bufferedRequestCount--;
						if (t.writing) {
							break;
						}
					}
					if (r === null) t.lastBufferedRequest = null;
				}
				t.bufferedRequest = r;
				t.bufferProcessing = false;
			}
			Writable.prototype._write = function (e, t, r) {
				r(new Error('_write() is not implemented'));
			};
			Writable.prototype._writev = null;
			Writable.prototype.end = function (e, t, r) {
				var i = this._writableState;
				if (typeof e === 'function') {
					r = e;
					e = null;
					t = null;
				} else if (typeof t === 'function') {
					r = t;
					t = null;
				}
				if (e !== null && e !== undefined) this.write(e, t);
				if (i.corked) {
					i.corked = 1;
					this.uncork();
				}
				if (!i.ending) endWritable(this, i, r);
			};
			function needFinish(e) {
				return (
					e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing
				);
			}
			function callFinal(e, t) {
				e._final(function (r) {
					t.pendingcb--;
					if (r) {
						e.emit('error', r);
					}
					t.prefinished = true;
					e.emit('prefinish');
					finishMaybe(e, t);
				});
			}
			function prefinish(e, t) {
				if (!t.prefinished && !t.finalCalled) {
					if (typeof e._final === 'function') {
						t.pendingcb++;
						t.finalCalled = true;
						a.nextTick(callFinal, e, t);
					} else {
						t.prefinished = true;
						e.emit('prefinish');
					}
				}
			}
			function finishMaybe(e, t) {
				var r = needFinish(t);
				if (r) {
					prefinish(e, t);
					if (t.pendingcb === 0) {
						t.finished = true;
						e.emit('finish');
					}
				}
				return r;
			}
			function endWritable(e, t, r) {
				t.ending = true;
				finishMaybe(e, t);
				if (r) {
					if (t.finished) a.nextTick(r);
					else e.once('finish', r);
				}
				t.ended = true;
				e.writable = false;
			}
			function onCorkedFinish(e, t, r) {
				var i = e.entry;
				e.entry = null;
				while (i) {
					var a = i.callback;
					t.pendingcb--;
					a(r);
					i = i.next;
				}
				t.corkedRequestsFree.next = e;
			}
			Object.defineProperty(Writable.prototype, 'destroyed', {
				get: function () {
					if (this._writableState === undefined) {
						return false;
					}
					return this._writableState.destroyed;
				},
				set: function (e) {
					if (!this._writableState) {
						return;
					}
					this._writableState.destroyed = e;
				}
			});
			Writable.prototype.destroy = g.destroy;
			Writable.prototype._undestroy = g.undestroy;
			Writable.prototype._destroy = function (e, t) {
				this.end();
				t(e);
			};
		},
		3211: (e, t, r) => {
			'use strict';
			function _classCallCheck(e, t) {
				if (!(e instanceof t)) {
					throw new TypeError('Cannot call a class as a function');
				}
			}
			var i = r(8604).Buffer;
			var a = r(9603);
			function copyBuffer(e, t, r) {
				e.copy(t, r);
			}
			e.exports = (function () {
				function BufferList() {
					_classCallCheck(this, BufferList);
					this.head = null;
					this.tail = null;
					this.length = 0;
				}
				BufferList.prototype.push = function push(e) {
					var t = { data: e, next: null };
					if (this.length > 0) this.tail.next = t;
					else this.head = t;
					this.tail = t;
					++this.length;
				};
				BufferList.prototype.unshift = function unshift(e) {
					var t = { data: e, next: this.head };
					if (this.length === 0) this.tail = t;
					this.head = t;
					++this.length;
				};
				BufferList.prototype.shift = function shift() {
					if (this.length === 0) return;
					var e = this.head.data;
					if (this.length === 1) this.head = this.tail = null;
					else this.head = this.head.next;
					--this.length;
					return e;
				};
				BufferList.prototype.clear = function clear() {
					this.head = this.tail = null;
					this.length = 0;
				};
				BufferList.prototype.join = function join(e) {
					if (this.length === 0) return '';
					var t = this.head;
					var r = '' + t.data;
					while ((t = t.next)) {
						r += e + t.data;
					}
					return r;
				};
				BufferList.prototype.concat = function concat(e) {
					if (this.length === 0) return i.alloc(0);
					var t = i.allocUnsafe(e >>> 0);
					var r = this.head;
					var a = 0;
					while (r) {
						copyBuffer(r.data, t, a);
						a += r.data.length;
						r = r.next;
					}
					return t;
				};
				return BufferList;
			})();
			if (a && a.inspect && a.inspect.custom) {
				e.exports.prototype[a.inspect.custom] = function () {
					var e = a.inspect({ length: this.length });
					return this.constructor.name + ' ' + e;
				};
			}
		},
		6955: (e, t, r) => {
			'use strict';
			var i = r(9387);
			function destroy(e, t) {
				var r = this;
				var a = this._readableState && this._readableState.destroyed;
				var o = this._writableState && this._writableState.destroyed;
				if (a || o) {
					if (t) {
						t(e);
					} else if (e) {
						if (!this._writableState) {
							i.nextTick(emitErrorNT, this, e);
						} else if (!this._writableState.errorEmitted) {
							this._writableState.errorEmitted = true;
							i.nextTick(emitErrorNT, this, e);
						}
					}
					return this;
				}
				if (this._readableState) {
					this._readableState.destroyed = true;
				}
				if (this._writableState) {
					this._writableState.destroyed = true;
				}
				this._destroy(e || null, function (e) {
					if (!t && e) {
						if (!r._writableState) {
							i.nextTick(emitErrorNT, r, e);
						} else if (!r._writableState.errorEmitted) {
							r._writableState.errorEmitted = true;
							i.nextTick(emitErrorNT, r, e);
						}
					} else if (t) {
						t(e);
					}
				});
				return this;
			}
			function undestroy() {
				if (this._readableState) {
					this._readableState.destroyed = false;
					this._readableState.reading = false;
					this._readableState.ended = false;
					this._readableState.endEmitted = false;
				}
				if (this._writableState) {
					this._writableState.destroyed = false;
					this._writableState.ended = false;
					this._writableState.ending = false;
					this._writableState.finalCalled = false;
					this._writableState.prefinished = false;
					this._writableState.finished = false;
					this._writableState.errorEmitted = false;
				}
			}
			function emitErrorNT(e, t) {
				e.emit('error', t);
			}
			e.exports = { destroy, undestroy };
		},
		4484: (e, t, r) => {
			e.exports = r(381).EventEmitter;
		},
		9464: (e, t, r) => {
			t = e.exports = r(1755);
			t.Stream = t;
			t.Readable = t;
			t.Writable = r(8511);
			t.Duplex = r(6357);
			t.Transform = r(8235);
			t.PassThrough = r(5825);
		},
		3934: (e, t, r) => {
			'use strict';
			var i = r(6533).Buffer;
			var a = r(1193);
			var o = r(7824);
			var c = new Array(16);
			var u = [
				0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9,
				5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8,
				12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
			];
			var l = [
				5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8,
				12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15,
				0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
			];
			var d = [
				11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12,
				15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14,
				15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11,
				8, 5, 6
			];
			var p = [
				8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7,
				12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11,
				14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13,
				11, 11
			];
			var m = [0, 1518500249, 1859775393, 2400959708, 2840853838];
			var g = [1352829926, 1548603684, 1836072691, 2053994217, 0];
			function RIPEMD160() {
				o.call(this, 64);
				this._a = 1732584193;
				this._b = 4023233417;
				this._c = 2562383102;
				this._d = 271733878;
				this._e = 3285377520;
			}
			a(RIPEMD160, o);
			RIPEMD160.prototype._update = function () {
				var e = c;
				for (var t = 0; t < 16; ++t) e[t] = this._block.readInt32LE(t * 4);
				var r = this._a | 0;
				var i = this._b | 0;
				var a = this._c | 0;
				var o = this._d | 0;
				var v = this._e | 0;
				var y = this._a | 0;
				var w = this._b | 0;
				var _ = this._c | 0;
				var A = this._d | 0;
				var k = this._e | 0;
				for (var N = 0; N < 80; N += 1) {
					var T;
					var x;
					if (N < 16) {
						T = fn1(r, i, a, o, v, e[u[N]], m[0], d[N]);
						x = fn5(y, w, _, A, k, e[l[N]], g[0], p[N]);
					} else if (N < 32) {
						T = fn2(r, i, a, o, v, e[u[N]], m[1], d[N]);
						x = fn4(y, w, _, A, k, e[l[N]], g[1], p[N]);
					} else if (N < 48) {
						T = fn3(r, i, a, o, v, e[u[N]], m[2], d[N]);
						x = fn3(y, w, _, A, k, e[l[N]], g[2], p[N]);
					} else if (N < 64) {
						T = fn4(r, i, a, o, v, e[u[N]], m[3], d[N]);
						x = fn2(y, w, _, A, k, e[l[N]], g[3], p[N]);
					} else {
						T = fn5(r, i, a, o, v, e[u[N]], m[4], d[N]);
						x = fn1(y, w, _, A, k, e[l[N]], g[4], p[N]);
					}
					r = v;
					v = o;
					o = rotl(a, 10);
					a = i;
					i = T;
					y = k;
					k = A;
					A = rotl(_, 10);
					_ = w;
					w = x;
				}
				var B = (this._b + a + A) | 0;
				this._b = (this._c + o + k) | 0;
				this._c = (this._d + v + y) | 0;
				this._d = (this._e + r + w) | 0;
				this._e = (this._a + i + _) | 0;
				this._a = B;
			};
			RIPEMD160.prototype._digest = function () {
				this._block[this._blockOffset++] = 128;
				if (this._blockOffset > 56) {
					this._block.fill(0, this._blockOffset, 64);
					this._update();
					this._blockOffset = 0;
				}
				this._block.fill(0, this._blockOffset, 56);
				this._block.writeUInt32LE(this._length[0], 56);
				this._block.writeUInt32LE(this._length[1], 60);
				this._update();
				var e = i.alloc ? i.alloc(20) : new i(20);
				e.writeInt32LE(this._a, 0);
				e.writeInt32LE(this._b, 4);
				e.writeInt32LE(this._c, 8);
				e.writeInt32LE(this._d, 12);
				e.writeInt32LE(this._e, 16);
				return e;
			};
			function rotl(e, t) {
				return (e << t) | (e >>> (32 - t));
			}
			function fn1(e, t, r, i, a, o, c, u) {
				return (rotl((e + (t ^ r ^ i) + o + c) | 0, u) + a) | 0;
			}
			function fn2(e, t, r, i, a, o, c, u) {
				return (rotl((e + ((t & r) | (~t & i)) + o + c) | 0, u) + a) | 0;
			}
			function fn3(e, t, r, i, a, o, c, u) {
				return (rotl((e + ((t | ~r) ^ i) + o + c) | 0, u) + a) | 0;
			}
			function fn4(e, t, r, i, a, o, c, u) {
				return (rotl((e + ((t & i) | (r & ~i)) + o + c) | 0, u) + a) | 0;
			}
			function fn5(e, t, r, i, a, o, c, u) {
				return (rotl((e + (t ^ (r | ~i)) + o + c) | 0, u) + a) | 0;
			}
			e.exports = RIPEMD160;
		},
		8604: (e, t, r) => {
			var i = r(6533);
			var a = i.Buffer;
			function copyProps(e, t) {
				for (var r in e) {
					t[r] = e[r];
				}
			}
			if (a.from && a.alloc && a.allocUnsafe && a.allocUnsafeSlow) {
				e.exports = i;
			} else {
				copyProps(i, t);
				t.Buffer = SafeBuffer;
			}
			function SafeBuffer(e, t, r) {
				return a(e, t, r);
			}
			copyProps(a, SafeBuffer);
			SafeBuffer.from = function (e, t, r) {
				if (typeof e === 'number') {
					throw new TypeError('Argument must not be a number');
				}
				return a(e, t, r);
			};
			SafeBuffer.alloc = function (e, t, r) {
				if (typeof e !== 'number') {
					throw new TypeError('Argument must be a number');
				}
				var i = a(e);
				if (t !== undefined) {
					if (typeof r === 'string') {
						i.fill(t, r);
					} else {
						i.fill(t);
					}
				} else {
					i.fill(0);
				}
				return i;
			};
			SafeBuffer.allocUnsafe = function (e) {
				if (typeof e !== 'number') {
					throw new TypeError('Argument must be a number');
				}
				return a(e);
			};
			SafeBuffer.allocUnsafeSlow = function (e) {
				if (typeof e !== 'number') {
					throw new TypeError('Argument must be a number');
				}
				return i.SlowBuffer(e);
			};
		},
		6608: (e, t, r) => {
			var i = r(6533);
			var a = i.Buffer;
			function copyProps(e, t) {
				for (var r in e) {
					t[r] = e[r];
				}
			}
			if (a.from && a.alloc && a.allocUnsafe && a.allocUnsafeSlow) {
				e.exports = i;
			} else {
				copyProps(i, t);
				t.Buffer = SafeBuffer;
			}
			function SafeBuffer(e, t, r) {
				return a(e, t, r);
			}
			SafeBuffer.prototype = Object.create(a.prototype);
			copyProps(a, SafeBuffer);
			SafeBuffer.from = function (e, t, r) {
				if (typeof e === 'number') {
					throw new TypeError('Argument must not be a number');
				}
				return a(e, t, r);
			};
			SafeBuffer.alloc = function (e, t, r) {
				if (typeof e !== 'number') {
					throw new TypeError('Argument must be a number');
				}
				var i = a(e);
				if (t !== undefined) {
					if (typeof r === 'string') {
						i.fill(t, r);
					} else {
						i.fill(t);
					}
				} else {
					i.fill(0);
				}
				return i;
			};
			SafeBuffer.allocUnsafe = function (e) {
				if (typeof e !== 'number') {
					throw new TypeError('Argument must be a number');
				}
				return a(e);
			};
			SafeBuffer.allocUnsafeSlow = function (e) {
				if (typeof e !== 'number') {
					throw new TypeError('Argument must be a number');
				}
				return i.SlowBuffer(e);
			};
		},
		4923: function (e) {
			'use strict';
			(function (t) {
				const r = 2147483647;
				function SHA256(e) {
					const t = new Uint32Array([
						1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748,
						2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206,
						2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983,
						1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671,
						3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372,
						1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
						3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734,
						506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
						1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
						3329325298
					]);
					let r = 1779033703,
						i = 3144134277,
						a = 1013904242,
						o = 2773480762;
					let c = 1359893119,
						u = 2600822924,
						l = 528734635,
						d = 1541459225;
					const p = new Uint32Array(64);
					function blocks(e) {
						let m = 0,
							g = e.length;
						while (g >= 64) {
							let v = r,
								y = i,
								w = a,
								_ = o,
								A = c,
								k = u,
								N = l,
								T = d,
								x,
								B,
								P,
								M,
								C;
							for (B = 0; B < 16; B++) {
								P = m + B * 4;
								p[B] =
									((e[P] & 255) << 24) |
									((e[P + 1] & 255) << 16) |
									((e[P + 2] & 255) << 8) |
									(e[P + 3] & 255);
							}
							for (B = 16; B < 64; B++) {
								x = p[B - 2];
								M = ((x >>> 17) | (x << (32 - 17))) ^ ((x >>> 19) | (x << (32 - 19))) ^ (x >>> 10);
								x = p[B - 15];
								C = ((x >>> 7) | (x << (32 - 7))) ^ ((x >>> 18) | (x << (32 - 18))) ^ (x >>> 3);
								p[B] = (((M + p[B - 7]) | 0) + ((C + p[B - 16]) | 0)) | 0;
							}
							for (B = 0; B < 64; B++) {
								M =
									((((((A >>> 6) | (A << (32 - 6))) ^
										((A >>> 11) | (A << (32 - 11))) ^
										((A >>> 25) | (A << (32 - 25)))) +
										((A & k) ^ (~A & N))) |
										0) +
										((T + ((t[B] + p[B]) | 0)) | 0)) |
									0;
								C =
									((((v >>> 2) | (v << (32 - 2))) ^
										((v >>> 13) | (v << (32 - 13))) ^
										((v >>> 22) | (v << (32 - 22)))) +
										((v & y) ^ (v & w) ^ (y & w))) |
									0;
								T = N;
								N = k;
								k = A;
								A = (_ + M) | 0;
								_ = w;
								w = y;
								y = v;
								v = (M + C) | 0;
							}
							r = (r + v) | 0;
							i = (i + y) | 0;
							a = (a + w) | 0;
							o = (o + _) | 0;
							c = (c + A) | 0;
							u = (u + k) | 0;
							l = (l + N) | 0;
							d = (d + T) | 0;
							m += 64;
							g -= 64;
						}
					}
					blocks(e);
					let m,
						g = e.length % 64,
						v = (e.length / 536870912) | 0,
						y = e.length << 3,
						w = g < 56 ? 56 : 120,
						_ = e.slice(e.length - g, e.length);
					_.push(128);
					for (m = g + 1; m < w; m++) {
						_.push(0);
					}
					_.push((v >>> 24) & 255);
					_.push((v >>> 16) & 255);
					_.push((v >>> 8) & 255);
					_.push((v >>> 0) & 255);
					_.push((y >>> 24) & 255);
					_.push((y >>> 16) & 255);
					_.push((y >>> 8) & 255);
					_.push((y >>> 0) & 255);
					blocks(_);
					return [
						(r >>> 24) & 255,
						(r >>> 16) & 255,
						(r >>> 8) & 255,
						(r >>> 0) & 255,
						(i >>> 24) & 255,
						(i >>> 16) & 255,
						(i >>> 8) & 255,
						(i >>> 0) & 255,
						(a >>> 24) & 255,
						(a >>> 16) & 255,
						(a >>> 8) & 255,
						(a >>> 0) & 255,
						(o >>> 24) & 255,
						(o >>> 16) & 255,
						(o >>> 8) & 255,
						(o >>> 0) & 255,
						(c >>> 24) & 255,
						(c >>> 16) & 255,
						(c >>> 8) & 255,
						(c >>> 0) & 255,
						(u >>> 24) & 255,
						(u >>> 16) & 255,
						(u >>> 8) & 255,
						(u >>> 0) & 255,
						(l >>> 24) & 255,
						(l >>> 16) & 255,
						(l >>> 8) & 255,
						(l >>> 0) & 255,
						(d >>> 24) & 255,
						(d >>> 16) & 255,
						(d >>> 8) & 255,
						(d >>> 0) & 255
					];
				}
				function PBKDF2_HMAC_SHA256_OneIter(e, t, r) {
					e = e.length <= 64 ? e : SHA256(e);
					const i = 64 + t.length + 4;
					const a = new Array(i);
					const o = new Array(64);
					let c;
					let u = [];
					for (c = 0; c < 64; c++) {
						a[c] = 54;
					}
					for (c = 0; c < e.length; c++) {
						a[c] ^= e[c];
					}
					for (c = 0; c < t.length; c++) {
						a[64 + c] = t[c];
					}
					for (c = i - 4; c < i; c++) {
						a[c] = 0;
					}
					for (c = 0; c < 64; c++) o[c] = 92;
					for (c = 0; c < e.length; c++) o[c] ^= e[c];
					function incrementCounter() {
						for (let e = i - 1; e >= i - 4; e--) {
							a[e]++;
							if (a[e] <= 255) return;
							a[e] = 0;
						}
					}
					while (r >= 32) {
						incrementCounter();
						u = u.concat(SHA256(o.concat(SHA256(a))));
						r -= 32;
					}
					if (r > 0) {
						incrementCounter();
						u = u.concat(SHA256(o.concat(SHA256(a))).slice(0, r));
					}
					return u;
				}
				function blockmix_salsa8(e, t, r, i, a) {
					let o;
					arraycopy(e, (2 * r - 1) * 16, a, 0, 16);
					for (o = 0; o < 2 * r; o++) {
						blockxor(e, o * 16, a, 16);
						salsa20_8(a, i);
						arraycopy(a, 0, e, t + o * 16, 16);
					}
					for (o = 0; o < r; o++) {
						arraycopy(e, t + o * 2 * 16, e, o * 16, 16);
					}
					for (o = 0; o < r; o++) {
						arraycopy(e, t + (o * 2 + 1) * 16, e, (o + r) * 16, 16);
					}
				}
				function R(e, t) {
					return (e << t) | (e >>> (32 - t));
				}
				function salsa20_8(e, t) {
					arraycopy(e, 0, t, 0, 16);
					for (let e = 8; e > 0; e -= 2) {
						t[4] ^= R(t[0] + t[12], 7);
						t[8] ^= R(t[4] + t[0], 9);
						t[12] ^= R(t[8] + t[4], 13);
						t[0] ^= R(t[12] + t[8], 18);
						t[9] ^= R(t[5] + t[1], 7);
						t[13] ^= R(t[9] + t[5], 9);
						t[1] ^= R(t[13] + t[9], 13);
						t[5] ^= R(t[1] + t[13], 18);
						t[14] ^= R(t[10] + t[6], 7);
						t[2] ^= R(t[14] + t[10], 9);
						t[6] ^= R(t[2] + t[14], 13);
						t[10] ^= R(t[6] + t[2], 18);
						t[3] ^= R(t[15] + t[11], 7);
						t[7] ^= R(t[3] + t[15], 9);
						t[11] ^= R(t[7] + t[3], 13);
						t[15] ^= R(t[11] + t[7], 18);
						t[1] ^= R(t[0] + t[3], 7);
						t[2] ^= R(t[1] + t[0], 9);
						t[3] ^= R(t[2] + t[1], 13);
						t[0] ^= R(t[3] + t[2], 18);
						t[6] ^= R(t[5] + t[4], 7);
						t[7] ^= R(t[6] + t[5], 9);
						t[4] ^= R(t[7] + t[6], 13);
						t[5] ^= R(t[4] + t[7], 18);
						t[11] ^= R(t[10] + t[9], 7);
						t[8] ^= R(t[11] + t[10], 9);
						t[9] ^= R(t[8] + t[11], 13);
						t[10] ^= R(t[9] + t[8], 18);
						t[12] ^= R(t[15] + t[14], 7);
						t[13] ^= R(t[12] + t[15], 9);
						t[14] ^= R(t[13] + t[12], 13);
						t[15] ^= R(t[14] + t[13], 18);
					}
					for (let r = 0; r < 16; ++r) {
						e[r] += t[r];
					}
				}
				function blockxor(e, t, r, i) {
					for (let a = 0; a < i; a++) {
						r[a] ^= e[t + a];
					}
				}
				function arraycopy(e, t, r, i, a) {
					while (a--) {
						r[i++] = e[t++];
					}
				}
				function checkBufferish(e) {
					if (!e || typeof e.length !== 'number') {
						return false;
					}
					for (let t = 0; t < e.length; t++) {
						const r = e[t];
						if (typeof r !== 'number' || r % 1 || r < 0 || r >= 256) {
							return false;
						}
					}
					return true;
				}
				function ensureInteger(e, t) {
					if (typeof e !== 'number' || e % 1) {
						throw new Error('invalid ' + t);
					}
					return e;
				}
				function _scrypt(e, t, i, a, o, c, u) {
					i = ensureInteger(i, 'N');
					a = ensureInteger(a, 'r');
					o = ensureInteger(o, 'p');
					c = ensureInteger(c, 'dkLen');
					if (i === 0 || (i & (i - 1)) !== 0) {
						throw new Error('N must be power of 2');
					}
					if (i > r / 128 / a) {
						throw new Error('N too large');
					}
					if (a > r / 128 / o) {
						throw new Error('r too large');
					}
					if (!checkBufferish(e)) {
						throw new Error('password must be an array or buffer');
					}
					e = Array.prototype.slice.call(e);
					if (!checkBufferish(t)) {
						throw new Error('salt must be an array or buffer');
					}
					t = Array.prototype.slice.call(t);
					let l = PBKDF2_HMAC_SHA256_OneIter(e, t, o * 128 * a);
					const d = new Uint32Array(o * 32 * a);
					for (let e = 0; e < d.length; e++) {
						const t = e * 4;
						d[e] =
							((l[t + 3] & 255) << 24) |
							((l[t + 2] & 255) << 16) |
							((l[t + 1] & 255) << 8) |
							((l[t + 0] & 255) << 0);
					}
					const p = new Uint32Array(64 * a);
					const m = new Uint32Array(32 * a * i);
					const g = 32 * a;
					const v = new Uint32Array(16);
					const y = new Uint32Array(16);
					const w = o * i * 2;
					let _ = 0;
					let A = null;
					let k = false;
					let N = 0;
					let T = 0,
						x;
					let B;
					const P = u ? parseInt(1e3 / a) : 4294967295;
					const M = typeof setImmediate !== 'undefined' ? setImmediate : setTimeout;
					const incrementalSMix = function () {
						if (k) {
							return u(new Error('cancelled'), _ / w);
						}
						let t;
						switch (N) {
							case 0:
								B = T * 32 * a;
								arraycopy(d, B, p, 0, g);
								N = 1;
								x = 0;
							case 1:
								t = i - x;
								if (t > P) {
									t = P;
								}
								for (let e = 0; e < t; e++) {
									arraycopy(p, 0, m, (x + e) * g, g);
									blockmix_salsa8(p, g, a, v, y);
								}
								x += t;
								_ += t;
								if (u) {
									const e = parseInt((1e3 * _) / w);
									if (e !== A) {
										k = u(null, _ / w);
										if (k) {
											break;
										}
										A = e;
									}
								}
								if (x < i) {
									break;
								}
								x = 0;
								N = 2;
							case 2:
								t = i - x;
								if (t > P) {
									t = P;
								}
								for (let e = 0; e < t; e++) {
									const e = (2 * a - 1) * 16;
									const t = p[e] & (i - 1);
									blockxor(m, t * g, p, g);
									blockmix_salsa8(p, g, a, v, y);
								}
								x += t;
								_ += t;
								if (u) {
									const e = parseInt((1e3 * _) / w);
									if (e !== A) {
										k = u(null, _ / w);
										if (k) {
											break;
										}
										A = e;
									}
								}
								if (x < i) {
									break;
								}
								arraycopy(p, 0, d, B, g);
								T++;
								if (T < o) {
									N = 0;
									break;
								}
								l = [];
								for (let e = 0; e < d.length; e++) {
									l.push((d[e] >> 0) & 255);
									l.push((d[e] >> 8) & 255);
									l.push((d[e] >> 16) & 255);
									l.push((d[e] >> 24) & 255);
								}
								const r = PBKDF2_HMAC_SHA256_OneIter(e, l, c);
								if (u) {
									u(null, 1, r);
								}
								return r;
						}
						if (u) {
							M(incrementalSMix);
						}
					};
					if (!u) {
						while (true) {
							const e = incrementalSMix();
							if (e != undefined) {
								return e;
							}
						}
					}
					incrementalSMix();
				}
				const i = {
					scrypt: function (e, t, r, i, a, o, c) {
						return new Promise(function (u, l) {
							let d = 0;
							if (c) {
								c(0);
							}
							_scrypt(e, t, r, i, a, o, function (e, t, r) {
								if (e) {
									l(e);
								} else if (r) {
									if (c && d !== 1) {
										c(1);
									}
									u(new Uint8Array(r));
								} else if (c && t !== d) {
									d = t;
									return c(t);
								}
							});
						});
					},
					syncScrypt: function (e, t, r, i, a, o) {
						return new Uint8Array(_scrypt(e, t, r, i, a, o));
					}
				};
				if (true) {
					e.exports = i;
				} else {
				}
			})(this);
		},
		3366: (e, t, r) => {
			var i = r(6608).Buffer;
			function Hash(e, t) {
				this._block = i.alloc(e);
				this._finalSize = t;
				this._blockSize = e;
				this._len = 0;
			}
			Hash.prototype.update = function (e, t) {
				if (typeof e === 'string') {
					t = t || 'utf8';
					e = i.from(e, t);
				}
				var r = this._block;
				var a = this._blockSize;
				var o = e.length;
				var c = this._len;
				for (var u = 0; u < o; ) {
					var l = c % a;
					var d = Math.min(o - u, a - l);
					for (var p = 0; p < d; p++) {
						r[l + p] = e[u + p];
					}
					c += d;
					u += d;
					if (c % a === 0) {
						this._update(r);
					}
				}
				this._len += o;
				return this;
			};
			Hash.prototype.digest = function (e) {
				var t = this._len % this._blockSize;
				this._block[t] = 128;
				this._block.fill(0, t + 1);
				if (t >= this._finalSize) {
					this._update(this._block);
					this._block.fill(0);
				}
				var r = this._len * 8;
				if (r <= 4294967295) {
					this._block.writeUInt32BE(r, this._blockSize - 4);
				} else {
					var i = (r & 4294967295) >>> 0;
					var a = (r - i) / 4294967296;
					this._block.writeUInt32BE(a, this._blockSize - 8);
					this._block.writeUInt32BE(i, this._blockSize - 4);
				}
				this._update(this._block);
				var o = this._hash();
				return e ? o.toString(e) : o;
			};
			Hash.prototype._update = function () {
				throw new Error('_update must be implemented by subclass');
			};
			e.exports = Hash;
		},
		5244: (e, t, r) => {
			var i = (e.exports = function SHA(e) {
				e = e.toLowerCase();
				var t = i[e];
				if (!t) throw new Error(e + ' is not supported (we accept pull requests)');
				return new t();
			});
			i.sha = r(2954);
			i.sha1 = r(6375);
			i.sha224 = r(4012);
			i.sha256 = r(8729);
			i.sha384 = r(1453);
			i.sha512 = r(1756);
		},
		2954: (e, t, r) => {
			var i = r(1193);
			var a = r(3366);
			var o = r(6608).Buffer;
			var c = [1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0];
			var u = new Array(80);
			function Sha() {
				this.init();
				this._w = u;
				a.call(this, 64, 56);
			}
			i(Sha, a);
			Sha.prototype.init = function () {
				this._a = 1732584193;
				this._b = 4023233417;
				this._c = 2562383102;
				this._d = 271733878;
				this._e = 3285377520;
				return this;
			};
			function rotl5(e) {
				return (e << 5) | (e >>> 27);
			}
			function rotl30(e) {
				return (e << 30) | (e >>> 2);
			}
			function ft(e, t, r, i) {
				if (e === 0) return (t & r) | (~t & i);
				if (e === 2) return (t & r) | (t & i) | (r & i);
				return t ^ r ^ i;
			}
			Sha.prototype._update = function (e) {
				var t = this._w;
				var r = this._a | 0;
				var i = this._b | 0;
				var a = this._c | 0;
				var o = this._d | 0;
				var u = this._e | 0;
				for (var l = 0; l < 16; ++l) t[l] = e.readInt32BE(l * 4);
				for (; l < 80; ++l) t[l] = t[l - 3] ^ t[l - 8] ^ t[l - 14] ^ t[l - 16];
				for (var d = 0; d < 80; ++d) {
					var p = ~~(d / 20);
					var m = (rotl5(r) + ft(p, i, a, o) + u + t[d] + c[p]) | 0;
					u = o;
					o = a;
					a = rotl30(i);
					i = r;
					r = m;
				}
				this._a = (r + this._a) | 0;
				this._b = (i + this._b) | 0;
				this._c = (a + this._c) | 0;
				this._d = (o + this._d) | 0;
				this._e = (u + this._e) | 0;
			};
			Sha.prototype._hash = function () {
				var e = o.allocUnsafe(20);
				e.writeInt32BE(this._a | 0, 0);
				e.writeInt32BE(this._b | 0, 4);
				e.writeInt32BE(this._c | 0, 8);
				e.writeInt32BE(this._d | 0, 12);
				e.writeInt32BE(this._e | 0, 16);
				return e;
			};
			e.exports = Sha;
		},
		6375: (e, t, r) => {
			var i = r(1193);
			var a = r(3366);
			var o = r(6608).Buffer;
			var c = [1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0];
			var u = new Array(80);
			function Sha1() {
				this.init();
				this._w = u;
				a.call(this, 64, 56);
			}
			i(Sha1, a);
			Sha1.prototype.init = function () {
				this._a = 1732584193;
				this._b = 4023233417;
				this._c = 2562383102;
				this._d = 271733878;
				this._e = 3285377520;
				return this;
			};
			function rotl1(e) {
				return (e << 1) | (e >>> 31);
			}
			function rotl5(e) {
				return (e << 5) | (e >>> 27);
			}
			function rotl30(e) {
				return (e << 30) | (e >>> 2);
			}
			function ft(e, t, r, i) {
				if (e === 0) return (t & r) | (~t & i);
				if (e === 2) return (t & r) | (t & i) | (r & i);
				return t ^ r ^ i;
			}
			Sha1.prototype._update = function (e) {
				var t = this._w;
				var r = this._a | 0;
				var i = this._b | 0;
				var a = this._c | 0;
				var o = this._d | 0;
				var u = this._e | 0;
				for (var l = 0; l < 16; ++l) t[l] = e.readInt32BE(l * 4);
				for (; l < 80; ++l) t[l] = rotl1(t[l - 3] ^ t[l - 8] ^ t[l - 14] ^ t[l - 16]);
				for (var d = 0; d < 80; ++d) {
					var p = ~~(d / 20);
					var m = (rotl5(r) + ft(p, i, a, o) + u + t[d] + c[p]) | 0;
					u = o;
					o = a;
					a = rotl30(i);
					i = r;
					r = m;
				}
				this._a = (r + this._a) | 0;
				this._b = (i + this._b) | 0;
				this._c = (a + this._c) | 0;
				this._d = (o + this._d) | 0;
				this._e = (u + this._e) | 0;
			};
			Sha1.prototype._hash = function () {
				var e = o.allocUnsafe(20);
				e.writeInt32BE(this._a | 0, 0);
				e.writeInt32BE(this._b | 0, 4);
				e.writeInt32BE(this._c | 0, 8);
				e.writeInt32BE(this._d | 0, 12);
				e.writeInt32BE(this._e | 0, 16);
				return e;
			};
			e.exports = Sha1;
		},
		4012: (e, t, r) => {
			var i = r(1193);
			var a = r(8729);
			var o = r(3366);
			var c = r(6608).Buffer;
			var u = new Array(64);
			function Sha224() {
				this.init();
				this._w = u;
				o.call(this, 64, 56);
			}
			i(Sha224, a);
			Sha224.prototype.init = function () {
				this._a = 3238371032;
				this._b = 914150663;
				this._c = 812702999;
				this._d = 4144912697;
				this._e = 4290775857;
				this._f = 1750603025;
				this._g = 1694076839;
				this._h = 3204075428;
				return this;
			};
			Sha224.prototype._hash = function () {
				var e = c.allocUnsafe(28);
				e.writeInt32BE(this._a, 0);
				e.writeInt32BE(this._b, 4);
				e.writeInt32BE(this._c, 8);
				e.writeInt32BE(this._d, 12);
				e.writeInt32BE(this._e, 16);
				e.writeInt32BE(this._f, 20);
				e.writeInt32BE(this._g, 24);
				return e;
			};
			e.exports = Sha224;
		},
		8729: (e, t, r) => {
			var i = r(1193);
			var a = r(3366);
			var o = r(6608).Buffer;
			var c = [
				1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748,
				2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206,
				2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122,
				1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891,
				3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700,
				1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771,
				3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877,
				958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452,
				2361852424, 2428436474, 2756734187, 3204031479, 3329325298
			];
			var u = new Array(64);
			function Sha256() {
				this.init();
				this._w = u;
				a.call(this, 64, 56);
			}
			i(Sha256, a);
			Sha256.prototype.init = function () {
				this._a = 1779033703;
				this._b = 3144134277;
				this._c = 1013904242;
				this._d = 2773480762;
				this._e = 1359893119;
				this._f = 2600822924;
				this._g = 528734635;
				this._h = 1541459225;
				return this;
			};
			function ch(e, t, r) {
				return r ^ (e & (t ^ r));
			}
			function maj(e, t, r) {
				return (e & t) | (r & (e | t));
			}
			function sigma0(e) {
				return ((e >>> 2) | (e << 30)) ^ ((e >>> 13) | (e << 19)) ^ ((e >>> 22) | (e << 10));
			}
			function sigma1(e) {
				return ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));
			}
			function gamma0(e) {
				return ((e >>> 7) | (e << 25)) ^ ((e >>> 18) | (e << 14)) ^ (e >>> 3);
			}
			function gamma1(e) {
				return ((e >>> 17) | (e << 15)) ^ ((e >>> 19) | (e << 13)) ^ (e >>> 10);
			}
			Sha256.prototype._update = function (e) {
				var t = this._w;
				var r = this._a | 0;
				var i = this._b | 0;
				var a = this._c | 0;
				var o = this._d | 0;
				var u = this._e | 0;
				var l = this._f | 0;
				var d = this._g | 0;
				var p = this._h | 0;
				for (var m = 0; m < 16; ++m) t[m] = e.readInt32BE(m * 4);
				for (; m < 64; ++m)
					t[m] = (gamma1(t[m - 2]) + t[m - 7] + gamma0(t[m - 15]) + t[m - 16]) | 0;
				for (var g = 0; g < 64; ++g) {
					var v = (p + sigma1(u) + ch(u, l, d) + c[g] + t[g]) | 0;
					var y = (sigma0(r) + maj(r, i, a)) | 0;
					p = d;
					d = l;
					l = u;
					u = (o + v) | 0;
					o = a;
					a = i;
					i = r;
					r = (v + y) | 0;
				}
				this._a = (r + this._a) | 0;
				this._b = (i + this._b) | 0;
				this._c = (a + this._c) | 0;
				this._d = (o + this._d) | 0;
				this._e = (u + this._e) | 0;
				this._f = (l + this._f) | 0;
				this._g = (d + this._g) | 0;
				this._h = (p + this._h) | 0;
			};
			Sha256.prototype._hash = function () {
				var e = o.allocUnsafe(32);
				e.writeInt32BE(this._a, 0);
				e.writeInt32BE(this._b, 4);
				e.writeInt32BE(this._c, 8);
				e.writeInt32BE(this._d, 12);
				e.writeInt32BE(this._e, 16);
				e.writeInt32BE(this._f, 20);
				e.writeInt32BE(this._g, 24);
				e.writeInt32BE(this._h, 28);
				return e;
			};
			e.exports = Sha256;
		},
		1453: (e, t, r) => {
			var i = r(1193);
			var a = r(1756);
			var o = r(3366);
			var c = r(6608).Buffer;
			var u = new Array(160);
			function Sha384() {
				this.init();
				this._w = u;
				o.call(this, 128, 112);
			}
			i(Sha384, a);
			Sha384.prototype.init = function () {
				this._ah = 3418070365;
				this._bh = 1654270250;
				this._ch = 2438529370;
				this._dh = 355462360;
				this._eh = 1731405415;
				this._fh = 2394180231;
				this._gh = 3675008525;
				this._hh = 1203062813;
				this._al = 3238371032;
				this._bl = 914150663;
				this._cl = 812702999;
				this._dl = 4144912697;
				this._el = 4290775857;
				this._fl = 1750603025;
				this._gl = 1694076839;
				this._hl = 3204075428;
				return this;
			};
			Sha384.prototype._hash = function () {
				var e = c.allocUnsafe(48);
				function writeInt64BE(t, r, i) {
					e.writeInt32BE(t, i);
					e.writeInt32BE(r, i + 4);
				}
				writeInt64BE(this._ah, this._al, 0);
				writeInt64BE(this._bh, this._bl, 8);
				writeInt64BE(this._ch, this._cl, 16);
				writeInt64BE(this._dh, this._dl, 24);
				writeInt64BE(this._eh, this._el, 32);
				writeInt64BE(this._fh, this._fl, 40);
				return e;
			};
			e.exports = Sha384;
		},
		1756: (e, t, r) => {
			var i = r(1193);
			var a = r(3366);
			var o = r(6608).Buffer;
			var c = [
				1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573,
				2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579,
				2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278,
				1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113,
				2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774,
				944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122,
				1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339,
				2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891,
				1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205,
				1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823,
				1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037,
				344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657,
				3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909,
				1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556,
				3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403,
				1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815,
				1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344,
				2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614,
				3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992,
				116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315,
				685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676,
				1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316,
				1246189591
			];
			var u = new Array(160);
			function Sha512() {
				this.init();
				this._w = u;
				a.call(this, 128, 112);
			}
			i(Sha512, a);
			Sha512.prototype.init = function () {
				this._ah = 1779033703;
				this._bh = 3144134277;
				this._ch = 1013904242;
				this._dh = 2773480762;
				this._eh = 1359893119;
				this._fh = 2600822924;
				this._gh = 528734635;
				this._hh = 1541459225;
				this._al = 4089235720;
				this._bl = 2227873595;
				this._cl = 4271175723;
				this._dl = 1595750129;
				this._el = 2917565137;
				this._fl = 725511199;
				this._gl = 4215389547;
				this._hl = 327033209;
				return this;
			};
			function Ch(e, t, r) {
				return r ^ (e & (t ^ r));
			}
			function maj(e, t, r) {
				return (e & t) | (r & (e | t));
			}
			function sigma0(e, t) {
				return ((e >>> 28) | (t << 4)) ^ ((t >>> 2) | (e << 30)) ^ ((t >>> 7) | (e << 25));
			}
			function sigma1(e, t) {
				return ((e >>> 14) | (t << 18)) ^ ((e >>> 18) | (t << 14)) ^ ((t >>> 9) | (e << 23));
			}
			function Gamma0(e, t) {
				return ((e >>> 1) | (t << 31)) ^ ((e >>> 8) | (t << 24)) ^ (e >>> 7);
			}
			function Gamma0l(e, t) {
				return ((e >>> 1) | (t << 31)) ^ ((e >>> 8) | (t << 24)) ^ ((e >>> 7) | (t << 25));
			}
			function Gamma1(e, t) {
				return ((e >>> 19) | (t << 13)) ^ ((t >>> 29) | (e << 3)) ^ (e >>> 6);
			}
			function Gamma1l(e, t) {
				return ((e >>> 19) | (t << 13)) ^ ((t >>> 29) | (e << 3)) ^ ((e >>> 6) | (t << 26));
			}
			function getCarry(e, t) {
				return e >>> 0 < t >>> 0 ? 1 : 0;
			}
			Sha512.prototype._update = function (e) {
				var t = this._w;
				var r = this._ah | 0;
				var i = this._bh | 0;
				var a = this._ch | 0;
				var o = this._dh | 0;
				var u = this._eh | 0;
				var l = this._fh | 0;
				var d = this._gh | 0;
				var p = this._hh | 0;
				var m = this._al | 0;
				var g = this._bl | 0;
				var v = this._cl | 0;
				var y = this._dl | 0;
				var w = this._el | 0;
				var _ = this._fl | 0;
				var A = this._gl | 0;
				var k = this._hl | 0;
				for (var N = 0; N < 32; N += 2) {
					t[N] = e.readInt32BE(N * 4);
					t[N + 1] = e.readInt32BE(N * 4 + 4);
				}
				for (; N < 160; N += 2) {
					var T = t[N - 15 * 2];
					var x = t[N - 15 * 2 + 1];
					var B = Gamma0(T, x);
					var P = Gamma0l(x, T);
					T = t[N - 2 * 2];
					x = t[N - 2 * 2 + 1];
					var M = Gamma1(T, x);
					var C = Gamma1l(x, T);
					var I = t[N - 7 * 2];
					var O = t[N - 7 * 2 + 1];
					var F = t[N - 16 * 2];
					var D = t[N - 16 * 2 + 1];
					var L = (P + O) | 0;
					var U = (B + I + getCarry(L, P)) | 0;
					L = (L + C) | 0;
					U = (U + M + getCarry(L, C)) | 0;
					L = (L + D) | 0;
					U = (U + F + getCarry(L, D)) | 0;
					t[N] = U;
					t[N + 1] = L;
				}
				for (var j = 0; j < 160; j += 2) {
					U = t[j];
					L = t[j + 1];
					var H = maj(r, i, a);
					var z = maj(m, g, v);
					var $ = sigma0(r, m);
					var G = sigma0(m, r);
					var q = sigma1(u, w);
					var V = sigma1(w, u);
					var W = c[j];
					var J = c[j + 1];
					var Z = Ch(u, l, d);
					var Q = Ch(w, _, A);
					var Y = (k + V) | 0;
					var X = (p + q + getCarry(Y, k)) | 0;
					Y = (Y + Q) | 0;
					X = (X + Z + getCarry(Y, Q)) | 0;
					Y = (Y + J) | 0;
					X = (X + W + getCarry(Y, J)) | 0;
					Y = (Y + L) | 0;
					X = (X + U + getCarry(Y, L)) | 0;
					var ee = (G + z) | 0;
					var te = ($ + H + getCarry(ee, G)) | 0;
					p = d;
					k = A;
					d = l;
					A = _;
					l = u;
					_ = w;
					w = (y + Y) | 0;
					u = (o + X + getCarry(w, y)) | 0;
					o = a;
					y = v;
					a = i;
					v = g;
					i = r;
					g = m;
					m = (Y + ee) | 0;
					r = (X + te + getCarry(m, Y)) | 0;
				}
				this._al = (this._al + m) | 0;
				this._bl = (this._bl + g) | 0;
				this._cl = (this._cl + v) | 0;
				this._dl = (this._dl + y) | 0;
				this._el = (this._el + w) | 0;
				this._fl = (this._fl + _) | 0;
				this._gl = (this._gl + A) | 0;
				this._hl = (this._hl + k) | 0;
				this._ah = (this._ah + r + getCarry(this._al, m)) | 0;
				this._bh = (this._bh + i + getCarry(this._bl, g)) | 0;
				this._ch = (this._ch + a + getCarry(this._cl, v)) | 0;
				this._dh = (this._dh + o + getCarry(this._dl, y)) | 0;
				this._eh = (this._eh + u + getCarry(this._el, w)) | 0;
				this._fh = (this._fh + l + getCarry(this._fl, _)) | 0;
				this._gh = (this._gh + d + getCarry(this._gl, A)) | 0;
				this._hh = (this._hh + p + getCarry(this._hl, k)) | 0;
			};
			Sha512.prototype._hash = function () {
				var e = o.allocUnsafe(64);
				function writeInt64BE(t, r, i) {
					e.writeInt32BE(t, i);
					e.writeInt32BE(r, i + 4);
				}
				writeInt64BE(this._ah, this._al, 0);
				writeInt64BE(this._bh, this._bl, 8);
				writeInt64BE(this._ch, this._cl, 16);
				writeInt64BE(this._dh, this._dl, 24);
				writeInt64BE(this._eh, this._el, 32);
				writeInt64BE(this._fh, this._fl, 40);
				writeInt64BE(this._gh, this._gl, 48);
				writeInt64BE(this._hh, this._hl, 56);
				return e;
			};
			e.exports = Sha512;
		},
		9191: (e, t, r) => {
			var i = r(1556);
			function Stream() {
				i.call(this);
			}
			Stream.prototype = new i();
			e.exports = Stream;
			Stream.Stream = Stream;
			Stream.prototype.pipe = function (e, t) {
				var r = this;
				function ondata(t) {
					if (e.writable) {
						if (false === e.write(t) && r.pause) {
							r.pause();
						}
					}
				}
				r.on('data', ondata);
				function ondrain() {
					if (r.readable && r.resume) {
						r.resume();
					}
				}
				e.on('drain', ondrain);
				if (!e._isStdio && (!t || t.end !== false)) {
					r.on('end', onend);
					r.on('close', onclose);
				}
				var i = false;
				function onend() {
					if (i) return;
					i = true;
					e.end();
				}
				function onclose() {
					if (i) return;
					i = true;
					if (typeof e.destroy === 'function') e.destroy();
				}
				function onerror(e) {
					cleanup();
					if (!this.hasListeners('error')) {
						throw e;
					}
				}
				r.on('error', onerror);
				e.on('error', onerror);
				function cleanup() {
					r.off('data', ondata);
					e.off('drain', ondrain);
					r.off('end', onend);
					r.off('close', onclose);
					r.off('error', onerror);
					e.off('error', onerror);
					r.off('end', cleanup);
					r.off('close', cleanup);
					e.off('end', cleanup);
					e.off('close', cleanup);
				}
				r.on('end', cleanup);
				r.on('close', cleanup);
				e.on('end', cleanup);
				e.on('close', cleanup);
				e.emit('pipe', r);
				return e;
			};
		},
		9851: (e, t, r) => {
			'use strict';
			var i = r(8604).Buffer;
			var a =
				i.isEncoding ||
				function (e) {
					e = '' + e;
					switch (e && e.toLowerCase()) {
						case 'hex':
						case 'utf8':
						case 'utf-8':
						case 'ascii':
						case 'binary':
						case 'base64':
						case 'ucs2':
						case 'ucs-2':
						case 'utf16le':
						case 'utf-16le':
						case 'raw':
							return true;
						default:
							return false;
					}
				};
			function _normalizeEncoding(e) {
				if (!e) return 'utf8';
				var t;
				while (true) {
					switch (e) {
						case 'utf8':
						case 'utf-8':
							return 'utf8';
						case 'ucs2':
						case 'ucs-2':
						case 'utf16le':
						case 'utf-16le':
							return 'utf16le';
						case 'latin1':
						case 'binary':
							return 'latin1';
						case 'base64':
						case 'ascii':
						case 'hex':
							return e;
						default:
							if (t) return;
							e = ('' + e).toLowerCase();
							t = true;
					}
				}
			}
			function normalizeEncoding(e) {
				var t = _normalizeEncoding(e);
				if (typeof t !== 'string' && (i.isEncoding === a || !a(e)))
					throw new Error('Unknown encoding: ' + e);
				return t || e;
			}
			t.I = StringDecoder;
			function StringDecoder(e) {
				this.encoding = normalizeEncoding(e);
				var t;
				switch (this.encoding) {
					case 'utf16le':
						this.text = utf16Text;
						this.end = utf16End;
						t = 4;
						break;
					case 'utf8':
						this.fillLast = utf8FillLast;
						t = 4;
						break;
					case 'base64':
						this.text = base64Text;
						this.end = base64End;
						t = 3;
						break;
					default:
						this.write = simpleWrite;
						this.end = simpleEnd;
						return;
				}
				this.lastNeed = 0;
				this.lastTotal = 0;
				this.lastChar = i.allocUnsafe(t);
			}
			StringDecoder.prototype.write = function (e) {
				if (e.length === 0) return '';
				var t;
				var r;
				if (this.lastNeed) {
					t = this.fillLast(e);
					if (t === undefined) return '';
					r = this.lastNeed;
					this.lastNeed = 0;
				} else {
					r = 0;
				}
				if (r < e.length) return t ? t + this.text(e, r) : this.text(e, r);
				return t || '';
			};
			StringDecoder.prototype.end = utf8End;
			StringDecoder.prototype.text = utf8Text;
			StringDecoder.prototype.fillLast = function (e) {
				if (this.lastNeed <= e.length) {
					e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
					return this.lastChar.toString(this.encoding, 0, this.lastTotal);
				}
				e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length);
				this.lastNeed -= e.length;
			};
			function utf8CheckByte(e) {
				if (e <= 127) return 0;
				else if (e >> 5 === 6) return 2;
				else if (e >> 4 === 14) return 3;
				else if (e >> 3 === 30) return 4;
				return e >> 6 === 2 ? -1 : -2;
			}
			function utf8CheckIncomplete(e, t, r) {
				var i = t.length - 1;
				if (i < r) return 0;
				var a = utf8CheckByte(t[i]);
				if (a >= 0) {
					if (a > 0) e.lastNeed = a - 1;
					return a;
				}
				if (--i < r || a === -2) return 0;
				a = utf8CheckByte(t[i]);
				if (a >= 0) {
					if (a > 0) e.lastNeed = a - 2;
					return a;
				}
				if (--i < r || a === -2) return 0;
				a = utf8CheckByte(t[i]);
				if (a >= 0) {
					if (a > 0) {
						if (a === 2) a = 0;
						else e.lastNeed = a - 3;
					}
					return a;
				}
				return 0;
			}
			function utf8CheckExtraBytes(e, t, r) {
				if ((t[0] & 192) !== 128) {
					e.lastNeed = 0;
					return '';
				}
				if (e.lastNeed > 1 && t.length > 1) {
					if ((t[1] & 192) !== 128) {
						e.lastNeed = 1;
						return '';
					}
					if (e.lastNeed > 2 && t.length > 2) {
						if ((t[2] & 192) !== 128) {
							e.lastNeed = 2;
							return '';
						}
					}
				}
			}
			function utf8FillLast(e) {
				var t = this.lastTotal - this.lastNeed;
				var r = utf8CheckExtraBytes(this, e, t);
				if (r !== undefined) return r;
				if (this.lastNeed <= e.length) {
					e.copy(this.lastChar, t, 0, this.lastNeed);
					return this.lastChar.toString(this.encoding, 0, this.lastTotal);
				}
				e.copy(this.lastChar, t, 0, e.length);
				this.lastNeed -= e.length;
			}
			function utf8Text(e, t) {
				var r = utf8CheckIncomplete(this, e, t);
				if (!this.lastNeed) return e.toString('utf8', t);
				this.lastTotal = r;
				var i = e.length - (r - this.lastNeed);
				e.copy(this.lastChar, 0, i);
				return e.toString('utf8', t, i);
			}
			function utf8End(e) {
				var t = e && e.length ? this.write(e) : '';
				if (this.lastNeed) return t + '';
				return t;
			}
			function utf16Text(e, t) {
				if ((e.length - t) % 2 === 0) {
					var r = e.toString('utf16le', t);
					if (r) {
						var i = r.charCodeAt(r.length - 1);
						if (i >= 55296 && i <= 56319) {
							this.lastNeed = 2;
							this.lastTotal = 4;
							this.lastChar[0] = e[e.length - 2];
							this.lastChar[1] = e[e.length - 1];
							return r.slice(0, -1);
						}
					}
					return r;
				}
				this.lastNeed = 1;
				this.lastTotal = 2;
				this.lastChar[0] = e[e.length - 1];
				return e.toString('utf16le', t, e.length - 1);
			}
			function utf16End(e) {
				var t = e && e.length ? this.write(e) : '';
				if (this.lastNeed) {
					var r = this.lastTotal - this.lastNeed;
					return t + this.lastChar.toString('utf16le', 0, r);
				}
				return t;
			}
			function base64Text(e, t) {
				var r = (e.length - t) % 3;
				if (r === 0) return e.toString('base64', t);
				this.lastNeed = 3 - r;
				this.lastTotal = 3;
				if (r === 1) {
					this.lastChar[0] = e[e.length - 1];
				} else {
					this.lastChar[0] = e[e.length - 2];
					this.lastChar[1] = e[e.length - 1];
				}
				return e.toString('base64', t, e.length - r);
			}
			function base64End(e) {
				var t = e && e.length ? this.write(e) : '';
				if (this.lastNeed) return t + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
				return t;
			}
			function simpleWrite(e) {
				return e.toString(this.encoding);
			}
			function simpleEnd(e) {
				return e && e.length ? this.write(e) : '';
			}
		},
		4282: (e) => {
			const t =
				/[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g;
			const words = (e) => e.match(t) || [];
			const upperFirst = (e) => e[0].toUpperCase() + e.slice(1);
			const join = (e, t) => words(e).join(t).toLowerCase();
			const camelCase = (e) =>
				words(e).reduce(
					(e, t) => `${e}${!e ? t.toLowerCase() : t[0].toUpperCase() + t.slice(1).toLowerCase()}`,
					''
				);
			const pascalCase = (e) => upperFirst(camelCase(e));
			const snakeCase = (e) => join(e, '_');
			const kebabCase = (e) => join(e, '-');
			const sentenceCase = (e) => upperFirst(join(e, ' '));
			const titleCase = (e) => words(e).map(upperFirst).join(' ');
			e.exports = {
				words,
				upperFirst,
				camelCase,
				pascalCase,
				snakeCase,
				kebabCase,
				sentenceCase,
				titleCase
			};
		},
		6918: (e) => {
			e.exports = function (e) {
				return toposort(uniqueNodes(e), e);
			};
			e.exports.array = toposort;
			function toposort(e, t) {
				var r = e.length,
					i = new Array(r),
					a = {},
					o = r,
					c = makeOutgoingEdges(t),
					u = makeNodesHash(e);
				t.forEach(function (e) {
					if (!u.has(e[0]) || !u.has(e[1])) {
						throw new Error('Unknown node. There is an unknown node in the supplied edges.');
					}
				});
				while (o--) {
					if (!a[o]) visit(e[o], o, new Set());
				}
				return i;
				function visit(e, t, o) {
					if (o.has(e)) {
						var l;
						try {
							l = ', node was:' + JSON.stringify(e);
						} catch (e) {
							l = '';
						}
						throw new Error('Cyclic dependency' + l);
					}
					if (!u.has(e)) {
						throw new Error(
							'Found unknown node. Make sure to provided all involved nodes. Unknown node: ' +
								JSON.stringify(e)
						);
					}
					if (a[t]) return;
					a[t] = true;
					var d = c.get(e) || new Set();
					d = Array.from(d);
					if ((t = d.length)) {
						o.add(e);
						do {
							var p = d[--t];
							visit(p, u.get(p), o);
						} while (t);
						o.delete(e);
					}
					i[--r] = e;
				}
			}
			function uniqueNodes(e) {
				var t = new Set();
				for (var r = 0, i = e.length; r < i; r++) {
					var a = e[r];
					t.add(a[0]);
					t.add(a[1]);
				}
				return Array.from(t);
			}
			function makeOutgoingEdges(e) {
				var t = new Map();
				for (var r = 0, i = e.length; r < i; r++) {
					var a = e[r];
					if (!t.has(a[0])) t.set(a[0], new Set());
					if (!t.has(a[1])) t.set(a[1], new Set());
					t.get(a[0]).add(a[1]);
				}
				return t;
			}
			function makeNodesHash(e) {
				var t = new Map();
				for (var r = 0, i = e.length; r < i; r++) {
					t.set(e[r], r);
				}
				return t;
			}
		},
		1947: (e, t, r) => {
			e.exports = deprecate;
			function deprecate(e, t) {
				if (config('noDeprecation')) {
					return e;
				}
				var r = false;
				function deprecated() {
					if (!r) {
						if (config('throwDeprecation')) {
							throw new Error(t);
						} else if (config('traceDeprecation')) {
							console.trace(t);
						} else {
							console.warn(t);
						}
						r = true;
					}
					return e.apply(this, arguments);
				}
				return deprecated;
			}
			function config(e) {
				try {
					if (!r.g.localStorage) return false;
				} catch (e) {
					return false;
				}
				var t = r.g.localStorage[e];
				if (null == t) return false;
				return String(t).toLowerCase() === 'true';
			}
		},
		168: (__unused_webpack_module, exports) => {
			var indexOf = function (e, t) {
				if (e.indexOf) return e.indexOf(t);
				else
					for (var r = 0; r < e.length; r++) {
						if (e[r] === t) return r;
					}
				return -1;
			};
			var Object_keys = function (e) {
				if (Object.keys) return Object.keys(e);
				else {
					var t = [];
					for (var r in e) t.push(r);
					return t;
				}
			};
			var forEach = function (e, t) {
				if (e.forEach) return e.forEach(t);
				else
					for (var r = 0; r < e.length; r++) {
						t(e[r], r, e);
					}
			};
			var defineProp = (function () {
				try {
					Object.defineProperty({}, '_', {});
					return function (e, t, r) {
						Object.defineProperty(e, t, {
							writable: true,
							enumerable: false,
							configurable: true,
							value: r
						});
					};
				} catch (e) {
					return function (e, t, r) {
						e[t] = r;
					};
				}
			})();
			var globals = [
				'Array',
				'Boolean',
				'Date',
				'Error',
				'EvalError',
				'Function',
				'Infinity',
				'JSON',
				'Math',
				'NaN',
				'Number',
				'Object',
				'RangeError',
				'ReferenceError',
				'RegExp',
				'String',
				'SyntaxError',
				'TypeError',
				'URIError',
				'decodeURI',
				'decodeURIComponent',
				'encodeURI',
				'encodeURIComponent',
				'escape',
				'eval',
				'isFinite',
				'isNaN',
				'parseFloat',
				'parseInt',
				'undefined',
				'unescape'
			];
			function Context() {}
			Context.prototype = {};
			var Script = (exports.Script = function NodeScript(e) {
				if (!(this instanceof Script)) return new Script(e);
				this.code = e;
			});
			Script.prototype.runInContext = function (e) {
				if (!(e instanceof Context)) {
					throw new TypeError("needs a 'context' argument.");
				}
				var t = document.createElement('iframe');
				if (!t.style) t.style = {};
				t.style.display = 'none';
				document.body.appendChild(t);
				var r = t.contentWindow;
				var i = r.eval,
					a = r.execScript;
				if (!i && a) {
					a.call(r, 'null');
					i = r.eval;
				}
				forEach(Object_keys(e), function (t) {
					r[t] = e[t];
				});
				forEach(globals, function (t) {
					if (e[t]) {
						r[t] = e[t];
					}
				});
				var o = Object_keys(r);
				var c = i.call(r, this.code);
				forEach(Object_keys(r), function (t) {
					if (t in e || indexOf(o, t) === -1) {
						e[t] = r[t];
					}
				});
				forEach(globals, function (t) {
					if (!(t in e)) {
						defineProp(e, t, r[t]);
					}
				});
				document.body.removeChild(t);
				return c;
			};
			Script.prototype.runInThisContext = function () {
				return eval(this.code);
			};
			Script.prototype.runInNewContext = function (e) {
				var t = Script.createContext(e);
				var r = this.runInContext(t);
				if (e) {
					forEach(Object_keys(t), function (r) {
						e[r] = t[r];
					});
				}
				return r;
			};
			forEach(Object_keys(Script.prototype), function (e) {
				exports[e] = Script[e] = function (t) {
					var r = Script(t);
					return r[e].apply(r, [].slice.call(arguments, 1));
				};
			});
			exports.isContext = function (e) {
				return e instanceof Context;
			};
			exports.createScript = function (e) {
				return exports.Script(e);
			};
			exports.createContext = Script.createContext = function (e) {
				var t = new Context();
				if (typeof e === 'object') {
					forEach(Object_keys(e), function (r) {
						t[r] = e[r];
					});
				}
				return t;
			};
		},
		8121: (e, t, r) => {
			'use strict';
			var i = r(940);
			var a = r.n(i);
			var o = r(4282);
			var c = r.n(o);
			var u = r(6918);
			var l = r.n(u);
			const d = Object.prototype.toString;
			const p = Error.prototype.toString;
			const m = RegExp.prototype.toString;
			const g = typeof Symbol !== 'undefined' ? Symbol.prototype.toString : () => '';
			const v = /^Symbol\((.*)\)(.*)$/;
			function printNumber(e) {
				if (e != +e) return 'NaN';
				const t = e === 0 && 1 / e < 0;
				return t ? '-0' : '' + e;
			}
			function printSimpleValue(e, t = false) {
				if (e == null || e === true || e === false) return '' + e;
				const r = typeof e;
				if (r === 'number') return printNumber(e);
				if (r === 'string') return t ? `"${e}"` : e;
				if (r === 'function') return '[Function ' + (e.name || 'anonymous') + ']';
				if (r === 'symbol') return g.call(e).replace(v, 'Symbol($1)');
				const i = d.call(e).slice(8, -1);
				if (i === 'Date') return isNaN(e.getTime()) ? '' + e : e.toISOString(e);
				if (i === 'Error' || e instanceof Error) return '[' + p.call(e) + ']';
				if (i === 'RegExp') return m.call(e);
				return null;
			}
			function printValue(e, t) {
				let r = printSimpleValue(e, t);
				if (r !== null) return r;
				return JSON.stringify(
					e,
					function (e, r) {
						let i = printSimpleValue(this[e], t);
						if (i !== null) return i;
						return r;
					},
					2
				);
			}
			function toArray(e) {
				return e == null ? [] : [].concat(e);
			}
			let y, w, _;
			let A = /\$\{\s*(\w+)\s*\}/g;
			y = Symbol.toStringTag;
			class ValidationErrorNoStack {
				constructor(e, t, r, i) {
					this.name = void 0;
					this.message = void 0;
					this.value = void 0;
					this.path = void 0;
					this.type = void 0;
					this.params = void 0;
					this.errors = void 0;
					this.inner = void 0;
					this[y] = 'Error';
					this.name = 'ValidationError';
					this.value = t;
					this.path = r;
					this.type = i;
					this.errors = [];
					this.inner = [];
					toArray(e).forEach((e) => {
						if (ValidationError.isError(e)) {
							this.errors.push(...e.errors);
							const t = e.inner.length ? e.inner : [e];
							this.inner.push(...t);
						} else {
							this.errors.push(e);
						}
					});
					this.message =
						this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
				}
			}
			w = Symbol.hasInstance;
			_ = Symbol.toStringTag;
			class ValidationError extends Error {
				static formatError(e, t) {
					const r = t.label || t.path || 'this';
					t = Object.assign({}, t, { path: r, originalPath: t.path });
					if (typeof e === 'string') return e.replace(A, (e, r) => printValue(t[r]));
					if (typeof e === 'function') return e(t);
					return e;
				}
				static isError(e) {
					return e && e.name === 'ValidationError';
				}
				constructor(e, t, r, i, a) {
					const o = new ValidationErrorNoStack(e, t, r, i);
					if (a) {
						return o;
					}
					super();
					this.value = void 0;
					this.path = void 0;
					this.type = void 0;
					this.params = void 0;
					this.errors = [];
					this.inner = [];
					this[_] = 'Error';
					this.name = o.name;
					this.message = o.message;
					this.type = o.type;
					this.value = o.value;
					this.path = o.path;
					this.errors = o.errors;
					this.inner = o.inner;
					if (Error.captureStackTrace) {
						Error.captureStackTrace(this, ValidationError);
					}
				}
				static [w](e) {
					return ValidationErrorNoStack[Symbol.hasInstance](e) || super[Symbol.hasInstance](e);
				}
			}
			let k = {
				default: '${path} is invalid',
				required: '${path} is a required field',
				defined: '${path} must be defined',
				notNull: '${path} cannot be null',
				oneOf: '${path} must be one of the following values: ${values}',
				notOneOf: '${path} must not be one of the following values: ${values}',
				notType: ({ path: e, type: t, value: r, originalValue: i }) => {
					const a =
						i != null && i !== r ? ` (cast from the value \`${printValue(i, true)}\`).` : '.';
					return t !== 'mixed'
						? `${e} must be a \`${t}\` type, ` +
								`but the final value was: \`${printValue(r, true)}\`` +
								a
						: `${e} must match the configured type. ` +
								`The validated value was: \`${printValue(r, true)}\`` +
								a;
				}
			};
			let N = {
				length: '${path} must be exactly ${length} characters',
				min: '${path} must be at least ${min} characters',
				max: '${path} must be at most ${max} characters',
				matches: '${path} must match the following: "${regex}"',
				email: '${path} must be a valid email',
				url: '${path} must be a valid URL',
				uuid: '${path} must be a valid UUID',
				datetime: '${path} must be a valid ISO date-time',
				datetime_precision:
					'${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits',
				datetime_offset: '${path} must be a valid ISO date-time with UTC "Z" timezone',
				trim: '${path} must be a trimmed string',
				lowercase: '${path} must be a lowercase string',
				uppercase: '${path} must be a upper case string'
			};
			let T = {
				min: '${path} must be greater than or equal to ${min}',
				max: '${path} must be less than or equal to ${max}',
				lessThan: '${path} must be less than ${less}',
				moreThan: '${path} must be greater than ${more}',
				positive: '${path} must be a positive number',
				negative: '${path} must be a negative number',
				integer: '${path} must be an integer'
			};
			let x = {
				min: '${path} field must be later than ${min}',
				max: '${path} field must be at earlier than ${max}'
			};
			let B = { isValue: '${path} field must be ${value}' };
			let P = {
				noUnknown: '${path} field has unspecified keys: ${unknown}',
				exact: '${path} object contains unknown properties: ${properties}'
			};
			let M = {
				min: '${path} field must have at least ${min} items',
				max: '${path} field must have less than or equal to ${max} items',
				length: '${path} must have ${length} items'
			};
			let C = {
				notType: (e) => {
					const { path: t, value: r, spec: i } = e;
					const a = i.types.length;
					if (Array.isArray(r)) {
						if (r.length < a)
							return `${t} tuple value has too few items, expected a length of ${a} but got ${r.length} for value: \`${printValue(r, true)}\``;
						if (r.length > a)
							return `${t} tuple value has too many items, expected a length of ${a} but got ${r.length} for value: \`${printValue(r, true)}\``;
					}
					return ValidationError.formatError(k.notType, e);
				}
			};
			var I = Object.assign(Object.create(null), {
				mixed: k,
				string: N,
				number: T,
				date: x,
				object: P,
				array: M,
				boolean: B,
				tuple: C
			});
			const isSchema = (e) => e && e.__isYupSchema__;
			class Condition {
				static fromOptions(e, t) {
					if (!t.then && !t.otherwise)
						throw new TypeError(
							'either `then:` or `otherwise:` is required for `when()` conditions'
						);
					let { is: r, then: i, otherwise: a } = t;
					let o = typeof r === 'function' ? r : (...e) => e.every((e) => e === r);
					return new Condition(e, (e, t) => {
						var r;
						let c = o(...e) ? i : a;
						return (r = c == null ? void 0 : c(t)) != null ? r : t;
					});
				}
				constructor(e, t) {
					this.fn = void 0;
					this.refs = e;
					this.refs = e;
					this.fn = t;
				}
				resolve(e, t) {
					let r = this.refs.map((e) =>
						e.getValue(
							t == null ? void 0 : t.value,
							t == null ? void 0 : t.parent,
							t == null ? void 0 : t.context
						)
					);
					let i = this.fn(r, e, t);
					if (i === undefined || i === e) {
						return e;
					}
					if (!isSchema(i)) throw new TypeError('conditions must return a schema object');
					return i.resolve(t);
				}
			}
			const O = { context: '$', value: '.' };
			function create$9(e, t) {
				return new Reference(e, t);
			}
			class Reference {
				constructor(e, t = {}) {
					this.key = void 0;
					this.isContext = void 0;
					this.isValue = void 0;
					this.isSibling = void 0;
					this.path = void 0;
					this.getter = void 0;
					this.map = void 0;
					if (typeof e !== 'string') throw new TypeError('ref must be a string, got: ' + e);
					this.key = e.trim();
					if (e === '') throw new TypeError('ref must be a non-empty string');
					this.isContext = this.key[0] === O.context;
					this.isValue = this.key[0] === O.value;
					this.isSibling = !this.isContext && !this.isValue;
					let r = this.isContext ? O.context : this.isValue ? O.value : '';
					this.path = this.key.slice(r.length);
					this.getter = this.path && (0, i.getter)(this.path, true);
					this.map = t.map;
				}
				getValue(e, t, r) {
					let i = this.isContext ? r : this.isValue ? e : t;
					if (this.getter) i = this.getter(i || {});
					if (this.map) i = this.map(i);
					return i;
				}
				cast(e, t) {
					return this.getValue(e, t == null ? void 0 : t.parent, t == null ? void 0 : t.context);
				}
				resolve() {
					return this;
				}
				describe() {
					return { type: 'ref', key: this.key };
				}
				toString() {
					return `Ref(${this.key})`;
				}
				static isRef(e) {
					return e && e.__isYupRef;
				}
			}
			Reference.prototype.__isYupRef = true;
			const isAbsent = (e) => e == null;
			function createValidation(e) {
				function validate(
					{ value: t, path: r = '', options: i, originalValue: a, schema: o },
					c,
					u
				) {
					const { name: l, test: d, params: p, message: m, skipAbsent: g } = e;
					let {
						parent: v,
						context: y,
						abortEarly: w = o.spec.abortEarly,
						disableStackTrace: _ = o.spec.disableStackTrace
					} = i;
					function resolve(e) {
						return Reference.isRef(e) ? e.getValue(t, v, y) : e;
					}
					function createError(e = {}) {
						const i = Object.assign(
							{
								value: t,
								originalValue: a,
								label: o.spec.label,
								path: e.path || r,
								spec: o.spec,
								disableStackTrace: e.disableStackTrace || _
							},
							p,
							e.params
						);
						for (const e of Object.keys(i)) i[e] = resolve(i[e]);
						const c = new ValidationError(
							ValidationError.formatError(e.message || m, i),
							t,
							i.path,
							e.type || l,
							i.disableStackTrace
						);
						c.params = i;
						return c;
					}
					const A = w ? c : u;
					let k = {
						path: r,
						parent: v,
						type: l,
						from: i.from,
						createError,
						resolve,
						options: i,
						originalValue: a,
						schema: o
					};
					const handleResult = (e) => {
						if (ValidationError.isError(e)) A(e);
						else if (!e) A(createError());
						else u(null);
					};
					const handleError = (e) => {
						if (ValidationError.isError(e)) A(e);
						else c(e);
					};
					const N = g && isAbsent(t);
					if (N) {
						return handleResult(true);
					}
					let T;
					try {
						var x;
						T = d.call(k, t, k);
						if (typeof ((x = T) == null ? void 0 : x.then) === 'function') {
							if (i.sync) {
								throw new Error(
									`Validation test of type: "${k.type}" returned a Promise during a synchronous validate. ` +
										`This test will finish after the validate call has returned`
								);
							}
							return Promise.resolve(T).then(handleResult, handleError);
						}
					} catch (e) {
						handleError(e);
						return;
					}
					handleResult(T);
				}
				validate.OPTIONS = e;
				return validate;
			}
			function getIn(e, t, r, a = r) {
				let o, c, u;
				if (!t) return { parent: o, parentPath: t, schema: e };
				(0, i.forEach)(t, (i, l, d) => {
					let p = l ? i.slice(1, i.length - 1) : i;
					e = e.resolve({ context: a, parent: o, value: r });
					let m = e.type === 'tuple';
					let g = d ? parseInt(p, 10) : 0;
					if (e.innerType || m) {
						if (m && !d)
							throw new Error(
								`Yup.reach cannot implicitly index into a tuple type. the path part "${u}" must contain an index to the tuple element, e.g. "${u}[0]"`
							);
						if (r && g >= r.length) {
							throw new Error(
								`Yup.reach cannot resolve an array item at index: ${i}, in the path: ${t}. ` +
									`because there is no value at that index. `
							);
						}
						o = r;
						r = r && r[g];
						e = m ? e.spec.types[g] : e.innerType;
					}
					if (!d) {
						if (!e.fields || !e.fields[p])
							throw new Error(
								`The schema does not contain the path: ${t}. ` +
									`(failed at: ${u} which is a type: "${e.type}")`
							);
						o = r;
						r = r && r[p];
						e = e.fields[p];
					}
					c = p;
					u = l ? '[' + i + ']' : '.' + i;
				});
				return { schema: e, parent: o, parentPath: c };
			}
			function reach(e, t, r, i) {
				return getIn(e, t, r, i).schema;
			}
			class ReferenceSet extends Set {
				describe() {
					const e = [];
					for (const t of this.values()) {
						e.push(Reference.isRef(t) ? t.describe() : t);
					}
					return e;
				}
				resolveAll(e) {
					let t = [];
					for (const r of this.values()) {
						t.push(e(r));
					}
					return t;
				}
				clone() {
					return new ReferenceSet(this.values());
				}
				merge(e, t) {
					const r = this.clone();
					e.forEach((e) => r.add(e));
					t.forEach((e) => r.delete(e));
					return r;
				}
			}
			function clone(e, t = new Map()) {
				if (isSchema(e) || !e || typeof e !== 'object') return e;
				if (t.has(e)) return t.get(e);
				let r;
				if (e instanceof Date) {
					r = new Date(e.getTime());
					t.set(e, r);
				} else if (e instanceof RegExp) {
					r = new RegExp(e);
					t.set(e, r);
				} else if (Array.isArray(e)) {
					r = new Array(e.length);
					t.set(e, r);
					for (let i = 0; i < e.length; i++) r[i] = clone(e[i], t);
				} else if (e instanceof Map) {
					r = new Map();
					t.set(e, r);
					for (const [i, a] of e.entries()) r.set(i, clone(a, t));
				} else if (e instanceof Set) {
					r = new Set();
					t.set(e, r);
					for (const i of e) r.add(clone(i, t));
				} else if (e instanceof Object) {
					r = {};
					t.set(e, r);
					for (const [i, a] of Object.entries(e)) r[i] = clone(a, t);
				} else {
					throw Error(`Unable to clone ${e}`);
				}
				return r;
			}
			class Schema {
				constructor(e) {
					this.type = void 0;
					this.deps = [];
					this.tests = void 0;
					this.transforms = void 0;
					this.conditions = [];
					this._mutate = void 0;
					this.internalTests = {};
					this._whitelist = new ReferenceSet();
					this._blacklist = new ReferenceSet();
					this.exclusiveTests = Object.create(null);
					this._typeCheck = void 0;
					this.spec = void 0;
					this.tests = [];
					this.transforms = [];
					this.withMutation(() => {
						this.typeError(k.notType);
					});
					this.type = e.type;
					this._typeCheck = e.check;
					this.spec = Object.assign(
						{
							strip: false,
							strict: false,
							abortEarly: true,
							recursive: true,
							disableStackTrace: false,
							nullable: false,
							optional: true,
							coerce: true
						},
						e == null ? void 0 : e.spec
					);
					this.withMutation((e) => {
						e.nonNullable();
					});
				}
				get _type() {
					return this.type;
				}
				clone(e) {
					if (this._mutate) {
						if (e) Object.assign(this.spec, e);
						return this;
					}
					const t = Object.create(Object.getPrototypeOf(this));
					t.type = this.type;
					t._typeCheck = this._typeCheck;
					t._whitelist = this._whitelist.clone();
					t._blacklist = this._blacklist.clone();
					t.internalTests = Object.assign({}, this.internalTests);
					t.exclusiveTests = Object.assign({}, this.exclusiveTests);
					t.deps = [...this.deps];
					t.conditions = [...this.conditions];
					t.tests = [...this.tests];
					t.transforms = [...this.transforms];
					t.spec = clone(Object.assign({}, this.spec, e));
					return t;
				}
				label(e) {
					let t = this.clone();
					t.spec.label = e;
					return t;
				}
				meta(...e) {
					if (e.length === 0) return this.spec.meta;
					let t = this.clone();
					t.spec.meta = Object.assign(t.spec.meta || {}, e[0]);
					return t;
				}
				withMutation(e) {
					let t = this._mutate;
					this._mutate = true;
					let r = e(this);
					this._mutate = t;
					return r;
				}
				concat(e) {
					if (!e || e === this) return this;
					if (e.type !== this.type && this.type !== 'mixed')
						throw new TypeError(
							`You cannot \`concat()\` schema's of different types: ${this.type} and ${e.type}`
						);
					let t = this;
					let r = e.clone();
					const i = Object.assign({}, t.spec, r.spec);
					r.spec = i;
					r.internalTests = Object.assign({}, t.internalTests, r.internalTests);
					r._whitelist = t._whitelist.merge(e._whitelist, e._blacklist);
					r._blacklist = t._blacklist.merge(e._blacklist, e._whitelist);
					r.tests = t.tests;
					r.exclusiveTests = t.exclusiveTests;
					r.withMutation((t) => {
						e.tests.forEach((e) => {
							t.test(e.OPTIONS);
						});
					});
					r.transforms = [...t.transforms, ...r.transforms];
					return r;
				}
				isType(e) {
					if (e == null) {
						if (this.spec.nullable && e === null) return true;
						if (this.spec.optional && e === undefined) return true;
						return false;
					}
					return this._typeCheck(e);
				}
				resolve(e) {
					let t = this;
					if (t.conditions.length) {
						let r = t.conditions;
						t = t.clone();
						t.conditions = [];
						t = r.reduce((t, r) => r.resolve(t, e), t);
						t = t.resolve(e);
					}
					return t;
				}
				resolveOptions(e) {
					var t, r, i, a;
					return Object.assign({}, e, {
						from: e.from || [],
						strict: (t = e.strict) != null ? t : this.spec.strict,
						abortEarly: (r = e.abortEarly) != null ? r : this.spec.abortEarly,
						recursive: (i = e.recursive) != null ? i : this.spec.recursive,
						disableStackTrace: (a = e.disableStackTrace) != null ? a : this.spec.disableStackTrace
					});
				}
				cast(e, t = {}) {
					let r = this.resolve(Object.assign({ value: e }, t));
					let i = t.assert === 'ignore-optionality';
					let a = r._cast(e, t);
					if (t.assert !== false && !r.isType(a)) {
						if (i && isAbsent(a)) {
							return a;
						}
						let o = printValue(e);
						let c = printValue(a);
						throw new TypeError(
							`The value of ${t.path || 'field'} could not be cast to a value ` +
								`that satisfies the schema type: "${r.type}". \n\n` +
								`attempted value: ${o} \n` +
								(c !== o ? `result of cast: ${c}` : '')
						);
					}
					return a;
				}
				_cast(e, t) {
					let r =
						e === undefined ? e : this.transforms.reduce((t, r) => r.call(this, t, e, this), e);
					if (r === undefined) {
						r = this.getDefault(t);
					}
					return r;
				}
				_validate(e, t = {}, r, i) {
					let { path: a, originalValue: o = e, strict: c = this.spec.strict } = t;
					let u = e;
					if (!c) {
						u = this._cast(u, Object.assign({ assert: false }, t));
					}
					let l = [];
					for (let e of Object.values(this.internalTests)) {
						if (e) l.push(e);
					}
					this.runTests({ path: a, value: u, originalValue: o, options: t, tests: l }, r, (e) => {
						if (e.length) {
							return i(e, u);
						}
						this.runTests(
							{ path: a, value: u, originalValue: o, options: t, tests: this.tests },
							r,
							i
						);
					});
				}
				runTests(e, t, r) {
					let i = false;
					let { tests: a, value: o, originalValue: c, path: u, options: l } = e;
					let panicOnce = (e) => {
						if (i) return;
						i = true;
						t(e, o);
					};
					let nextOnce = (e) => {
						if (i) return;
						i = true;
						r(e, o);
					};
					let d = a.length;
					let p = [];
					if (!d) return nextOnce([]);
					let m = { value: o, originalValue: c, path: u, options: l, schema: this };
					for (let e = 0; e < a.length; e++) {
						const t = a[e];
						t(m, panicOnce, function finishTestRun(e) {
							if (e) {
								Array.isArray(e) ? p.push(...e) : p.push(e);
							}
							if (--d <= 0) {
								nextOnce(p);
							}
						});
					}
				}
				asNestedTest({
					key: e,
					index: t,
					parent: r,
					parentPath: i,
					originalParent: a,
					options: o
				}) {
					const c = e != null ? e : t;
					if (c == null) {
						throw TypeError('Must include `key` or `index` for nested validations');
					}
					const u = typeof c === 'number';
					let l = r[c];
					const d = Object.assign({}, o, {
						strict: true,
						parent: r,
						value: l,
						originalValue: a[c],
						key: undefined,
						[u ? 'index' : 'key']: c,
						path: u || c.includes('.') ? `${i || ''}[${u ? c : `"${c}"`}]` : (i ? `${i}.` : '') + e
					});
					return (e, t, r) => this.resolve(d)._validate(l, d, t, r);
				}
				validate(e, t) {
					var r;
					let i = this.resolve(Object.assign({}, t, { value: e }));
					let a =
						(r = t == null ? void 0 : t.disableStackTrace) != null ? r : i.spec.disableStackTrace;
					return new Promise((r, o) =>
						i._validate(
							e,
							t,
							(e, t) => {
								if (ValidationError.isError(e)) e.value = t;
								o(e);
							},
							(e, t) => {
								if (e.length) o(new ValidationError(e, t, undefined, undefined, a));
								else r(t);
							}
						)
					);
				}
				validateSync(e, t) {
					var r;
					let i = this.resolve(Object.assign({}, t, { value: e }));
					let a;
					let o =
						(r = t == null ? void 0 : t.disableStackTrace) != null ? r : i.spec.disableStackTrace;
					i._validate(
						e,
						Object.assign({}, t, { sync: true }),
						(e, t) => {
							if (ValidationError.isError(e)) e.value = t;
							throw e;
						},
						(t, r) => {
							if (t.length) throw new ValidationError(t, e, undefined, undefined, o);
							a = r;
						}
					);
					return a;
				}
				isValid(e, t) {
					return this.validate(e, t).then(
						() => true,
						(e) => {
							if (ValidationError.isError(e)) return false;
							throw e;
						}
					);
				}
				isValidSync(e, t) {
					try {
						this.validateSync(e, t);
						return true;
					} catch (e) {
						if (ValidationError.isError(e)) return false;
						throw e;
					}
				}
				_getDefault(e) {
					let t = this.spec.default;
					if (t == null) {
						return t;
					}
					return typeof t === 'function' ? t.call(this, e) : clone(t);
				}
				getDefault(e) {
					let t = this.resolve(e || {});
					return t._getDefault(e);
				}
				default(e) {
					if (arguments.length === 0) {
						return this._getDefault();
					}
					let t = this.clone({ default: e });
					return t;
				}
				strict(e = true) {
					return this.clone({ strict: e });
				}
				nullability(e, t) {
					const r = this.clone({ nullable: e });
					r.internalTests.nullable = createValidation({
						message: t,
						name: 'nullable',
						test(e) {
							return e === null ? this.schema.spec.nullable : true;
						}
					});
					return r;
				}
				optionality(e, t) {
					const r = this.clone({ optional: e });
					r.internalTests.optionality = createValidation({
						message: t,
						name: 'optionality',
						test(e) {
							return e === undefined ? this.schema.spec.optional : true;
						}
					});
					return r;
				}
				optional() {
					return this.optionality(true);
				}
				defined(e = k.defined) {
					return this.optionality(false, e);
				}
				nullable() {
					return this.nullability(true);
				}
				nonNullable(e = k.notNull) {
					return this.nullability(false, e);
				}
				required(e = k.required) {
					return this.clone().withMutation((t) => t.nonNullable(e).defined(e));
				}
				notRequired() {
					return this.clone().withMutation((e) => e.nullable().optional());
				}
				transform(e) {
					let t = this.clone();
					t.transforms.push(e);
					return t;
				}
				test(...e) {
					let t;
					if (e.length === 1) {
						if (typeof e[0] === 'function') {
							t = { test: e[0] };
						} else {
							t = e[0];
						}
					} else if (e.length === 2) {
						t = { name: e[0], test: e[1] };
					} else {
						t = { name: e[0], message: e[1], test: e[2] };
					}
					if (t.message === undefined) t.message = k.default;
					if (typeof t.test !== 'function') throw new TypeError('`test` is a required parameters');
					let r = this.clone();
					let i = createValidation(t);
					let a = t.exclusive || (t.name && r.exclusiveTests[t.name] === true);
					if (t.exclusive) {
						if (!t.name)
							throw new TypeError(
								'Exclusive tests must provide a unique `name` identifying the test'
							);
					}
					if (t.name) r.exclusiveTests[t.name] = !!t.exclusive;
					r.tests = r.tests.filter((e) => {
						if (e.OPTIONS.name === t.name) {
							if (a) return false;
							if (e.OPTIONS.test === i.OPTIONS.test) return false;
						}
						return true;
					});
					r.tests.push(i);
					return r;
				}
				when(e, t) {
					if (!Array.isArray(e) && typeof e !== 'string') {
						t = e;
						e = '.';
					}
					let r = this.clone();
					let i = toArray(e).map((e) => new Reference(e));
					i.forEach((e) => {
						if (e.isSibling) r.deps.push(e.key);
					});
					r.conditions.push(
						typeof t === 'function' ? new Condition(i, t) : Condition.fromOptions(i, t)
					);
					return r;
				}
				typeError(e) {
					let t = this.clone();
					t.internalTests.typeError = createValidation({
						message: e,
						name: 'typeError',
						skipAbsent: true,
						test(e) {
							if (!this.schema._typeCheck(e))
								return this.createError({ params: { type: this.schema.type } });
							return true;
						}
					});
					return t;
				}
				oneOf(e, t = k.oneOf) {
					let r = this.clone();
					e.forEach((e) => {
						r._whitelist.add(e);
						r._blacklist.delete(e);
					});
					r.internalTests.whiteList = createValidation({
						message: t,
						name: 'oneOf',
						skipAbsent: true,
						test(e) {
							let t = this.schema._whitelist;
							let r = t.resolveAll(this.resolve);
							return r.includes(e)
								? true
								: this.createError({ params: { values: Array.from(t).join(', '), resolved: r } });
						}
					});
					return r;
				}
				notOneOf(e, t = k.notOneOf) {
					let r = this.clone();
					e.forEach((e) => {
						r._blacklist.add(e);
						r._whitelist.delete(e);
					});
					r.internalTests.blacklist = createValidation({
						message: t,
						name: 'notOneOf',
						test(e) {
							let t = this.schema._blacklist;
							let r = t.resolveAll(this.resolve);
							if (r.includes(e))
								return this.createError({
									params: { values: Array.from(t).join(', '), resolved: r }
								});
							return true;
						}
					});
					return r;
				}
				strip(e = true) {
					let t = this.clone();
					t.spec.strip = e;
					return t;
				}
				describe(e) {
					const t = (e ? this.resolve(e) : this).clone();
					const { label: r, meta: i, optional: a, nullable: o } = t.spec;
					const c = {
						meta: i,
						label: r,
						optional: a,
						nullable: o,
						default: t.getDefault(e),
						type: t.type,
						oneOf: t._whitelist.describe(),
						notOneOf: t._blacklist.describe(),
						tests: t.tests
							.map((e) => ({ name: e.OPTIONS.name, params: e.OPTIONS.params }))
							.filter((e, t, r) => r.findIndex((t) => t.name === e.name) === t)
					};
					return c;
				}
			}
			Schema.prototype.__isYupSchema__ = true;
			for (const e of ['validate', 'validateSync'])
				Schema.prototype[`${e}At`] = function (t, r, i = {}) {
					const { parent: a, parentPath: o, schema: c } = getIn(this, t, r, i.context);
					return c[e](a && a[o], Object.assign({}, i, { parent: a, path: t }));
				};
			for (const e of ['equals', 'is']) Schema.prototype[e] = Schema.prototype.oneOf;
			for (const e of ['not', 'nope']) Schema.prototype[e] = Schema.prototype.notOneOf;
			const returnsTrue = () => true;
			function create$8(e) {
				return new MixedSchema(e);
			}
			class MixedSchema extends Schema {
				constructor(e) {
					super(
						typeof e === 'function'
							? { type: 'mixed', check: e }
							: Object.assign({ type: 'mixed', check: returnsTrue }, e)
					);
				}
			}
			create$8.prototype = MixedSchema.prototype;
			function create$7() {
				return new BooleanSchema();
			}
			class BooleanSchema extends Schema {
				constructor() {
					super({
						type: 'boolean',
						check(e) {
							if (e instanceof Boolean) e = e.valueOf();
							return typeof e === 'boolean';
						}
					});
					this.withMutation(() => {
						this.transform((e, t, r) => {
							if (r.spec.coerce && !r.isType(e)) {
								if (/^(true|1)$/i.test(String(e))) return true;
								if (/^(false|0)$/i.test(String(e))) return false;
							}
							return e;
						});
					});
				}
				isTrue(e = B.isValue) {
					return this.test({
						message: e,
						name: 'is-value',
						exclusive: true,
						params: { value: 'true' },
						test(e) {
							return isAbsent(e) || e === true;
						}
					});
				}
				isFalse(e = B.isValue) {
					return this.test({
						message: e,
						name: 'is-value',
						exclusive: true,
						params: { value: 'false' },
						test(e) {
							return isAbsent(e) || e === false;
						}
					});
				}
				default(e) {
					return super.default(e);
				}
				defined(e) {
					return super.defined(e);
				}
				optional() {
					return super.optional();
				}
				required(e) {
					return super.required(e);
				}
				notRequired() {
					return super.notRequired();
				}
				nullable() {
					return super.nullable();
				}
				nonNullable(e) {
					return super.nonNullable(e);
				}
				strip(e) {
					return super.strip(e);
				}
			}
			create$7.prototype = BooleanSchema.prototype;
			const F =
				/^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
			function parseIsoDate(e) {
				const t = parseDateStruct(e);
				if (!t) return Date.parse ? Date.parse(e) : Number.NaN;
				if (t.z === undefined && t.plusMinus === undefined) {
					return new Date(
						t.year,
						t.month,
						t.day,
						t.hour,
						t.minute,
						t.second,
						t.millisecond
					).valueOf();
				}
				let r = 0;
				if (t.z !== 'Z' && t.plusMinus !== undefined) {
					r = t.hourOffset * 60 + t.minuteOffset;
					if (t.plusMinus === '+') r = 0 - r;
				}
				return Date.UTC(t.year, t.month, t.day, t.hour, t.minute + r, t.second, t.millisecond);
			}
			function parseDateStruct(e) {
				var t, r;
				const i = F.exec(e);
				if (!i) return null;
				return {
					year: toNumber(i[1]),
					month: toNumber(i[2], 1) - 1,
					day: toNumber(i[3], 1),
					hour: toNumber(i[4]),
					minute: toNumber(i[5]),
					second: toNumber(i[6]),
					millisecond: i[7] ? toNumber(i[7].substring(0, 3)) : 0,
					precision: (t = (r = i[7]) == null ? void 0 : r.length) != null ? t : undefined,
					z: i[8] || undefined,
					plusMinus: i[9] || undefined,
					hourOffset: toNumber(i[10]),
					minuteOffset: toNumber(i[11])
				};
			}
			function toNumber(e, t = 0) {
				return Number(e) || t;
			}
			let D =
				/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
			let L =
				/^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
			let U =
				/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
			let j = '^\\d{4}-\\d{2}-\\d{2}';
			let H = '\\d{2}:\\d{2}:\\d{2}';
			let z = '(([+-]\\d{2}(:?\\d{2})?)|Z)';
			let $ = new RegExp(`${j}T${H}(\\.\\d+)?${z}$`);
			let isTrimmed = (e) => isAbsent(e) || e === e.trim();
			let G = {}.toString();
			function create$6() {
				return new StringSchema();
			}
			class StringSchema extends Schema {
				constructor() {
					super({
						type: 'string',
						check(e) {
							if (e instanceof String) e = e.valueOf();
							return typeof e === 'string';
						}
					});
					this.withMutation(() => {
						this.transform((e, t, r) => {
							if (!r.spec.coerce || r.isType(e)) return e;
							if (Array.isArray(e)) return e;
							const i = e != null && e.toString ? e.toString() : e;
							if (i === G) return e;
							return i;
						});
					});
				}
				required(e) {
					return super.required(e).withMutation((t) =>
						t.test({
							message: e || k.required,
							name: 'required',
							skipAbsent: true,
							test: (e) => !!e.length
						})
					);
				}
				notRequired() {
					return super.notRequired().withMutation((e) => {
						e.tests = e.tests.filter((e) => e.OPTIONS.name !== 'required');
						return e;
					});
				}
				length(e, t = N.length) {
					return this.test({
						message: t,
						name: 'length',
						exclusive: true,
						params: { length: e },
						skipAbsent: true,
						test(t) {
							return t.length === this.resolve(e);
						}
					});
				}
				min(e, t = N.min) {
					return this.test({
						message: t,
						name: 'min',
						exclusive: true,
						params: { min: e },
						skipAbsent: true,
						test(t) {
							return t.length >= this.resolve(e);
						}
					});
				}
				max(e, t = N.max) {
					return this.test({
						name: 'max',
						exclusive: true,
						message: t,
						params: { max: e },
						skipAbsent: true,
						test(t) {
							return t.length <= this.resolve(e);
						}
					});
				}
				matches(e, t) {
					let r = false;
					let i;
					let a;
					if (t) {
						if (typeof t === 'object') {
							({ excludeEmptyString: r = false, message: i, name: a } = t);
						} else {
							i = t;
						}
					}
					return this.test({
						name: a || 'matches',
						message: i || N.matches,
						params: { regex: e },
						skipAbsent: true,
						test: (t) => (t === '' && r) || t.search(e) !== -1
					});
				}
				email(e = N.email) {
					return this.matches(D, { name: 'email', message: e, excludeEmptyString: true });
				}
				url(e = N.url) {
					return this.matches(L, { name: 'url', message: e, excludeEmptyString: true });
				}
				uuid(e = N.uuid) {
					return this.matches(U, { name: 'uuid', message: e, excludeEmptyString: false });
				}
				datetime(e) {
					let t = '';
					let r;
					let i;
					if (e) {
						if (typeof e === 'object') {
							({ message: t = '', allowOffset: r = false, precision: i = undefined } = e);
						} else {
							t = e;
						}
					}
					return this.matches($, {
						name: 'datetime',
						message: t || N.datetime,
						excludeEmptyString: true
					})
						.test({
							name: 'datetime_offset',
							message: t || N.datetime_offset,
							params: { allowOffset: r },
							skipAbsent: true,
							test: (e) => {
								if (!e || r) return true;
								const t = parseDateStruct(e);
								if (!t) return false;
								return !!t.z;
							}
						})
						.test({
							name: 'datetime_precision',
							message: t || N.datetime_precision,
							params: { precision: i },
							skipAbsent: true,
							test: (e) => {
								if (!e || i == undefined) return true;
								const t = parseDateStruct(e);
								if (!t) return false;
								return t.precision === i;
							}
						});
				}
				ensure() {
					return this.default('').transform((e) => (e === null ? '' : e));
				}
				trim(e = N.trim) {
					return this.transform((e) => (e != null ? e.trim() : e)).test({
						message: e,
						name: 'trim',
						test: isTrimmed
					});
				}
				lowercase(e = N.lowercase) {
					return this.transform((e) => (!isAbsent(e) ? e.toLowerCase() : e)).test({
						message: e,
						name: 'string_case',
						exclusive: true,
						skipAbsent: true,
						test: (e) => isAbsent(e) || e === e.toLowerCase()
					});
				}
				uppercase(e = N.uppercase) {
					return this.transform((e) => (!isAbsent(e) ? e.toUpperCase() : e)).test({
						message: e,
						name: 'string_case',
						exclusive: true,
						skipAbsent: true,
						test: (e) => isAbsent(e) || e === e.toUpperCase()
					});
				}
			}
			create$6.prototype = StringSchema.prototype;
			let isNaN$1 = (e) => e != +e;
			function create$5() {
				return new NumberSchema();
			}
			class NumberSchema extends Schema {
				constructor() {
					super({
						type: 'number',
						check(e) {
							if (e instanceof Number) e = e.valueOf();
							return typeof e === 'number' && !isNaN$1(e);
						}
					});
					this.withMutation(() => {
						this.transform((e, t, r) => {
							if (!r.spec.coerce) return e;
							let i = e;
							if (typeof i === 'string') {
								i = i.replace(/\s/g, '');
								if (i === '') return NaN;
								i = +i;
							}
							if (r.isType(i) || i === null) return i;
							return parseFloat(i);
						});
					});
				}
				min(e, t = T.min) {
					return this.test({
						message: t,
						name: 'min',
						exclusive: true,
						params: { min: e },
						skipAbsent: true,
						test(t) {
							return t >= this.resolve(e);
						}
					});
				}
				max(e, t = T.max) {
					return this.test({
						message: t,
						name: 'max',
						exclusive: true,
						params: { max: e },
						skipAbsent: true,
						test(t) {
							return t <= this.resolve(e);
						}
					});
				}
				lessThan(e, t = T.lessThan) {
					return this.test({
						message: t,
						name: 'max',
						exclusive: true,
						params: { less: e },
						skipAbsent: true,
						test(t) {
							return t < this.resolve(e);
						}
					});
				}
				moreThan(e, t = T.moreThan) {
					return this.test({
						message: t,
						name: 'min',
						exclusive: true,
						params: { more: e },
						skipAbsent: true,
						test(t) {
							return t > this.resolve(e);
						}
					});
				}
				positive(e = T.positive) {
					return this.moreThan(0, e);
				}
				negative(e = T.negative) {
					return this.lessThan(0, e);
				}
				integer(e = T.integer) {
					return this.test({
						name: 'integer',
						message: e,
						skipAbsent: true,
						test: (e) => Number.isInteger(e)
					});
				}
				truncate() {
					return this.transform((e) => (!isAbsent(e) ? e | 0 : e));
				}
				round(e) {
					var t;
					let r = ['ceil', 'floor', 'round', 'trunc'];
					e = ((t = e) == null ? void 0 : t.toLowerCase()) || 'round';
					if (e === 'trunc') return this.truncate();
					if (r.indexOf(e.toLowerCase()) === -1)
						throw new TypeError('Only valid options for round() are: ' + r.join(', '));
					return this.transform((t) => (!isAbsent(t) ? Math[e](t) : t));
				}
			}
			create$5.prototype = NumberSchema.prototype;
			let q = new Date('');
			let isDate = (e) => Object.prototype.toString.call(e) === '[object Date]';
			function create$4() {
				return new DateSchema();
			}
			class DateSchema extends Schema {
				constructor() {
					super({
						type: 'date',
						check(e) {
							return isDate(e) && !isNaN(e.getTime());
						}
					});
					this.withMutation(() => {
						this.transform((e, t, r) => {
							if (!r.spec.coerce || r.isType(e) || e === null) return e;
							e = parseIsoDate(e);
							return !isNaN(e) ? new Date(e) : DateSchema.INVALID_DATE;
						});
					});
				}
				prepareParam(e, t) {
					let r;
					if (!Reference.isRef(e)) {
						let i = this.cast(e);
						if (!this._typeCheck(i))
							throw new TypeError(
								`\`${t}\` must be a Date or a value that can be \`cast()\` to a Date`
							);
						r = i;
					} else {
						r = e;
					}
					return r;
				}
				min(e, t = x.min) {
					let r = this.prepareParam(e, 'min');
					return this.test({
						message: t,
						name: 'min',
						exclusive: true,
						params: { min: e },
						skipAbsent: true,
						test(e) {
							return e >= this.resolve(r);
						}
					});
				}
				max(e, t = x.max) {
					let r = this.prepareParam(e, 'max');
					return this.test({
						message: t,
						name: 'max',
						exclusive: true,
						params: { max: e },
						skipAbsent: true,
						test(e) {
							return e <= this.resolve(r);
						}
					});
				}
			}
			DateSchema.INVALID_DATE = q;
			create$4.prototype = DateSchema.prototype;
			create$4.INVALID_DATE = q;
			function sortFields(e, t = []) {
				let r = [];
				let a = new Set();
				let o = new Set(t.map(([e, t]) => `${e}-${t}`));
				function addNode(e, t) {
					let c = (0, i.split)(e)[0];
					a.add(c);
					if (!o.has(`${t}-${c}`)) r.push([t, c]);
				}
				for (const t of Object.keys(e)) {
					let r = e[t];
					a.add(t);
					if (Reference.isRef(r) && r.isSibling) addNode(r.path, t);
					else if (isSchema(r) && 'deps' in r) r.deps.forEach((e) => addNode(e, t));
				}
				return l().array(Array.from(a), r).reverse();
			}
			function findIndex(e, t) {
				let r = Infinity;
				e.some((e, i) => {
					var a;
					if ((a = t.path) != null && a.includes(e)) {
						r = i;
						return true;
					}
				});
				return r;
			}
			function sortByKeyOrder(e) {
				return (t, r) => findIndex(e, t) - findIndex(e, r);
			}
			const parseJson = (e, t, r) => {
				if (typeof e !== 'string') {
					return e;
				}
				let i = e;
				try {
					i = JSON.parse(e);
				} catch (e) {}
				return r.isType(i) ? i : e;
			};
			function deepPartial(e) {
				if ('fields' in e) {
					const t = {};
					for (const [r, i] of Object.entries(e.fields)) {
						t[r] = deepPartial(i);
					}
					return e.setFields(t);
				}
				if (e.type === 'array') {
					const t = e.optional();
					if (t.innerType) t.innerType = deepPartial(t.innerType);
					return t;
				}
				if (e.type === 'tuple') {
					return e.optional().clone({ types: e.spec.types.map(deepPartial) });
				}
				if ('optional' in e) {
					return e.optional();
				}
				return e;
			}
			const deepHas = (e, t) => {
				const r = [...(0, i.normalizePath)(t)];
				if (r.length === 1) return r[0] in e;
				let a = r.pop();
				let o = (0, i.getter)((0, i.join)(r), true)(e);
				return !!(o && a in o);
			};
			let isObject = (e) => Object.prototype.toString.call(e) === '[object Object]';
			function unknown(e, t) {
				let r = Object.keys(e.fields);
				return Object.keys(t).filter((e) => r.indexOf(e) === -1);
			}
			const V = sortByKeyOrder([]);
			function create$3(e) {
				return new ObjectSchema(e);
			}
			class ObjectSchema extends Schema {
				constructor(e) {
					super({
						type: 'object',
						check(e) {
							return isObject(e) || typeof e === 'function';
						}
					});
					this.fields = Object.create(null);
					this._sortErrors = V;
					this._nodes = [];
					this._excludedEdges = [];
					this.withMutation(() => {
						if (e) {
							this.shape(e);
						}
					});
				}
				_cast(e, t = {}) {
					var r;
					let i = super._cast(e, t);
					if (i === undefined) return this.getDefault(t);
					if (!this._typeCheck(i)) return i;
					let a = this.fields;
					let o = (r = t.stripUnknown) != null ? r : this.spec.noUnknown;
					let c = [].concat(
						this._nodes,
						Object.keys(i).filter((e) => !this._nodes.includes(e))
					);
					let u = {};
					let l = Object.assign({}, t, { parent: u, __validating: t.__validating || false });
					let d = false;
					for (const e of c) {
						let r = a[e];
						let c = e in i;
						if (r) {
							let a;
							let o = i[e];
							l.path = (t.path ? `${t.path}.` : '') + e;
							r = r.resolve({ value: o, context: t.context, parent: u });
							let c = r instanceof Schema ? r.spec : undefined;
							let p = c == null ? void 0 : c.strict;
							if (c != null && c.strip) {
								d = d || e in i;
								continue;
							}
							a = !t.__validating || !p ? r.cast(i[e], l) : i[e];
							if (a !== undefined) {
								u[e] = a;
							}
						} else if (c && !o) {
							u[e] = i[e];
						}
						if (c !== e in u || u[e] !== i[e]) {
							d = true;
						}
					}
					return d ? u : i;
				}
				_validate(e, t = {}, r, i) {
					let { from: a = [], originalValue: o = e, recursive: c = this.spec.recursive } = t;
					t.from = [{ schema: this, value: o }, ...a];
					t.__validating = true;
					t.originalValue = o;
					super._validate(e, t, r, (e, a) => {
						if (!c || !isObject(a)) {
							i(e, a);
							return;
						}
						o = o || a;
						let u = [];
						for (let e of this._nodes) {
							let r = this.fields[e];
							if (!r || Reference.isRef(r)) {
								continue;
							}
							u.push(
								r.asNestedTest({
									options: t,
									key: e,
									parent: a,
									parentPath: t.path,
									originalParent: o
								})
							);
						}
						this.runTests({ tests: u, value: a, originalValue: o, options: t }, r, (t) => {
							i(t.sort(this._sortErrors).concat(e), a);
						});
					});
				}
				clone(e) {
					const t = super.clone(e);
					t.fields = Object.assign({}, this.fields);
					t._nodes = this._nodes;
					t._excludedEdges = this._excludedEdges;
					t._sortErrors = this._sortErrors;
					return t;
				}
				concat(e) {
					let t = super.concat(e);
					let r = t.fields;
					for (let [e, t] of Object.entries(this.fields)) {
						const i = r[e];
						r[e] = i === undefined ? t : i;
					}
					return t.withMutation((t) =>
						t.setFields(r, [...this._excludedEdges, ...e._excludedEdges])
					);
				}
				_getDefault(e) {
					if ('default' in this.spec) {
						return super._getDefault(e);
					}
					if (!this._nodes.length) {
						return undefined;
					}
					let t = {};
					this._nodes.forEach((r) => {
						var i;
						const a = this.fields[r];
						let o = e;
						if ((i = o) != null && i.value) {
							o = Object.assign({}, o, { parent: o.value, value: o.value[r] });
						}
						t[r] = a && 'getDefault' in a ? a.getDefault(o) : undefined;
					});
					return t;
				}
				setFields(e, t) {
					let r = this.clone();
					r.fields = e;
					r._nodes = sortFields(e, t);
					r._sortErrors = sortByKeyOrder(Object.keys(e));
					if (t) r._excludedEdges = t;
					return r;
				}
				shape(e, t = []) {
					return this.clone().withMutation((r) => {
						let i = r._excludedEdges;
						if (t.length) {
							if (!Array.isArray(t[0])) t = [t];
							i = [...r._excludedEdges, ...t];
						}
						return r.setFields(Object.assign(r.fields, e), i);
					});
				}
				partial() {
					const e = {};
					for (const [t, r] of Object.entries(this.fields)) {
						e[t] = 'optional' in r && r.optional instanceof Function ? r.optional() : r;
					}
					return this.setFields(e);
				}
				deepPartial() {
					const e = deepPartial(this);
					return e;
				}
				pick(e) {
					const t = {};
					for (const r of e) {
						if (this.fields[r]) t[r] = this.fields[r];
					}
					return this.setFields(
						t,
						this._excludedEdges.filter(([t, r]) => e.includes(t) && e.includes(r))
					);
				}
				omit(e) {
					const t = [];
					for (const r of Object.keys(this.fields)) {
						if (e.includes(r)) continue;
						t.push(r);
					}
					return this.pick(t);
				}
				from(e, t, r) {
					let a = (0, i.getter)(e, true);
					return this.transform((i) => {
						if (!i) return i;
						let o = i;
						if (deepHas(i, e)) {
							o = Object.assign({}, i);
							if (!r) delete o[e];
							o[t] = a(i);
						}
						return o;
					});
				}
				json() {
					return this.transform(parseJson);
				}
				exact(e) {
					return this.test({
						name: 'exact',
						exclusive: true,
						message: e || P.exact,
						test(e) {
							if (e == null) return true;
							const t = unknown(this.schema, e);
							return t.length === 0 || this.createError({ params: { properties: t.join(', ') } });
						}
					});
				}
				stripUnknown() {
					return this.clone({ noUnknown: true });
				}
				noUnknown(e = true, t = P.noUnknown) {
					if (typeof e !== 'boolean') {
						t = e;
						e = true;
					}
					let r = this.test({
						name: 'noUnknown',
						exclusive: true,
						message: t,
						test(t) {
							if (t == null) return true;
							const r = unknown(this.schema, t);
							return (
								!e || r.length === 0 || this.createError({ params: { unknown: r.join(', ') } })
							);
						}
					});
					r.spec.noUnknown = e;
					return r;
				}
				unknown(e = true, t = P.noUnknown) {
					return this.noUnknown(!e, t);
				}
				transformKeys(e) {
					return this.transform((t) => {
						if (!t) return t;
						const r = {};
						for (const i of Object.keys(t)) r[e(i)] = t[i];
						return r;
					});
				}
				camelCase() {
					return this.transformKeys(o.camelCase);
				}
				snakeCase() {
					return this.transformKeys(o.snakeCase);
				}
				constantCase() {
					return this.transformKeys((e) => (0, o.snakeCase)(e).toUpperCase());
				}
				describe(e) {
					const t = (e ? this.resolve(e) : this).clone();
					const r = super.describe(e);
					r.fields = {};
					for (const [a, o] of Object.entries(t.fields)) {
						var i;
						let t = e;
						if ((i = t) != null && i.value) {
							t = Object.assign({}, t, { parent: t.value, value: t.value[a] });
						}
						r.fields[a] = o.describe(t);
					}
					return r;
				}
			}
			create$3.prototype = ObjectSchema.prototype;
			function create$2(e) {
				return new ArraySchema(e);
			}
			class ArraySchema extends Schema {
				constructor(e) {
					super({
						type: 'array',
						spec: { types: e },
						check(e) {
							return Array.isArray(e);
						}
					});
					this.innerType = void 0;
					this.innerType = e;
				}
				_cast(e, t) {
					const r = super._cast(e, t);
					if (!this._typeCheck(r) || !this.innerType) {
						return r;
					}
					let i = false;
					const a = r.map((e, r) => {
						const a = this.innerType.cast(
							e,
							Object.assign({}, t, { path: `${t.path || ''}[${r}]` })
						);
						if (a !== e) {
							i = true;
						}
						return a;
					});
					return i ? a : r;
				}
				_validate(e, t = {}, r, i) {
					var a;
					let o = this.innerType;
					let c = (a = t.recursive) != null ? a : this.spec.recursive;
					t.originalValue != null ? t.originalValue : e;
					super._validate(e, t, r, (a, u) => {
						var l;
						if (!c || !o || !this._typeCheck(u)) {
							i(a, u);
							return;
						}
						let d = new Array(u.length);
						for (let r = 0; r < u.length; r++) {
							var p;
							d[r] = o.asNestedTest({
								options: t,
								index: r,
								parent: u,
								parentPath: t.path,
								originalParent: (p = t.originalValue) != null ? p : e
							});
						}
						this.runTests(
							{
								value: u,
								tests: d,
								originalValue: (l = t.originalValue) != null ? l : e,
								options: t
							},
							r,
							(e) => i(e.concat(a), u)
						);
					});
				}
				clone(e) {
					const t = super.clone(e);
					t.innerType = this.innerType;
					return t;
				}
				json() {
					return this.transform(parseJson);
				}
				concat(e) {
					let t = super.concat(e);
					t.innerType = this.innerType;
					if (e.innerType)
						t.innerType = t.innerType ? t.innerType.concat(e.innerType) : e.innerType;
					return t;
				}
				of(e) {
					let t = this.clone();
					if (!isSchema(e))
						throw new TypeError(
							'`array.of()` sub-schema must be a valid yup schema not: ' + printValue(e)
						);
					t.innerType = e;
					t.spec = Object.assign({}, t.spec, { types: e });
					return t;
				}
				length(e, t = M.length) {
					return this.test({
						message: t,
						name: 'length',
						exclusive: true,
						params: { length: e },
						skipAbsent: true,
						test(t) {
							return t.length === this.resolve(e);
						}
					});
				}
				min(e, t) {
					t = t || M.min;
					return this.test({
						message: t,
						name: 'min',
						exclusive: true,
						params: { min: e },
						skipAbsent: true,
						test(t) {
							return t.length >= this.resolve(e);
						}
					});
				}
				max(e, t) {
					t = t || M.max;
					return this.test({
						message: t,
						name: 'max',
						exclusive: true,
						params: { max: e },
						skipAbsent: true,
						test(t) {
							return t.length <= this.resolve(e);
						}
					});
				}
				ensure() {
					return this.default(() => []).transform((e, t) => {
						if (this._typeCheck(e)) return e;
						return t == null ? [] : [].concat(t);
					});
				}
				compact(e) {
					let t = !e ? (e) => !!e : (t, r, i) => !e(t, r, i);
					return this.transform((e) => (e != null ? e.filter(t) : e));
				}
				describe(e) {
					const t = (e ? this.resolve(e) : this).clone();
					const r = super.describe(e);
					if (t.innerType) {
						var i;
						let a = e;
						if ((i = a) != null && i.value) {
							a = Object.assign({}, a, { parent: a.value, value: a.value[0] });
						}
						r.innerType = t.innerType.describe(a);
					}
					return r;
				}
			}
			create$2.prototype = ArraySchema.prototype;
			function create$1(e) {
				return new TupleSchema(e);
			}
			class TupleSchema extends Schema {
				constructor(e) {
					super({
						type: 'tuple',
						spec: { types: e },
						check(e) {
							const t = this.spec.types;
							return Array.isArray(e) && e.length === t.length;
						}
					});
					this.withMutation(() => {
						this.typeError(C.notType);
					});
				}
				_cast(e, t) {
					const { types: r } = this.spec;
					const i = super._cast(e, t);
					if (!this._typeCheck(i)) {
						return i;
					}
					let a = false;
					const o = r.map((e, r) => {
						const o = e.cast(i[r], Object.assign({}, t, { path: `${t.path || ''}[${r}]` }));
						if (o !== i[r]) a = true;
						return o;
					});
					return a ? o : i;
				}
				_validate(e, t = {}, r, i) {
					let a = this.spec.types;
					super._validate(e, t, r, (o, c) => {
						var u;
						if (!this._typeCheck(c)) {
							i(o, c);
							return;
						}
						let l = [];
						for (let [r, i] of a.entries()) {
							var d;
							l[r] = i.asNestedTest({
								options: t,
								index: r,
								parent: c,
								parentPath: t.path,
								originalParent: (d = t.originalValue) != null ? d : e
							});
						}
						this.runTests(
							{
								value: c,
								tests: l,
								originalValue: (u = t.originalValue) != null ? u : e,
								options: t
							},
							r,
							(e) => i(e.concat(o), c)
						);
					});
				}
				describe(e) {
					const t = (e ? this.resolve(e) : this).clone();
					const r = super.describe(e);
					r.innerType = t.spec.types.map((t, r) => {
						var i;
						let a = e;
						if ((i = a) != null && i.value) {
							a = Object.assign({}, a, { parent: a.value, value: a.value[r] });
						}
						return t.describe(a);
					});
					return r;
				}
			}
			create$1.prototype = TupleSchema.prototype;
			function create(e) {
				return new Lazy(e);
			}
			function catchValidationError(e) {
				try {
					return e();
				} catch (e) {
					if (ValidationError.isError(e)) return Promise.reject(e);
					throw e;
				}
			}
			class Lazy {
				constructor(e) {
					this.type = 'lazy';
					this.__isYupSchema__ = true;
					this.spec = void 0;
					this._resolve = (e, t = {}) => {
						let r = this.builder(e, t);
						if (!isSchema(r)) throw new TypeError('lazy() functions must return a valid schema');
						if (this.spec.optional) r = r.optional();
						return r.resolve(t);
					};
					this.builder = e;
					this.spec = { meta: undefined, optional: false };
				}
				clone(e) {
					const t = new Lazy(this.builder);
					t.spec = Object.assign({}, this.spec, e);
					return t;
				}
				optionality(e) {
					const t = this.clone({ optional: e });
					return t;
				}
				optional() {
					return this.optionality(true);
				}
				resolve(e) {
					return this._resolve(e.value, e);
				}
				cast(e, t) {
					return this._resolve(e, t).cast(e, t);
				}
				asNestedTest(e) {
					let { key: t, index: r, parent: i, options: a } = e;
					let o = i[r != null ? r : t];
					return this._resolve(o, Object.assign({}, a, { value: o, parent: i })).asNestedTest(e);
				}
				validate(e, t) {
					return catchValidationError(() => this._resolve(e, t).validate(e, t));
				}
				validateSync(e, t) {
					return this._resolve(e, t).validateSync(e, t);
				}
				validateAt(e, t, r) {
					return catchValidationError(() => this._resolve(t, r).validateAt(e, t, r));
				}
				validateSyncAt(e, t, r) {
					return this._resolve(t, r).validateSyncAt(e, t, r);
				}
				isValid(e, t) {
					try {
						return this._resolve(e, t).isValid(e, t);
					} catch (e) {
						if (ValidationError.isError(e)) {
							return Promise.resolve(false);
						}
						throw e;
					}
				}
				isValidSync(e, t) {
					return this._resolve(e, t).isValidSync(e, t);
				}
				describe(e) {
					return e
						? this.resolve(e).describe(e)
						: { type: 'lazy', meta: this.spec.meta, label: undefined };
				}
				meta(...e) {
					if (e.length === 0) return this.spec.meta;
					let t = this.clone();
					t.spec.meta = Object.assign(t.spec.meta || {}, e[0]);
					return t;
				}
			}
			function setLocale(e) {
				Object.keys(e).forEach((t) => {
					Object.keys(e[t]).forEach((r) => {
						I[t][r] = e[t][r];
					});
				});
			}
			function addMethod(e, t, r) {
				if (!e || !isSchema(e.prototype))
					throw new TypeError('You must provide a yup schema constructor function');
				if (typeof t !== 'string') throw new TypeError('A Method name must be provided');
				if (typeof r !== 'function') throw new TypeError('Method function must be provided');
				e.prototype[t] = r;
			}
		},
		6638: (e, t, r) => {
			'use strict';
			r.d(t, {
				CG: () => output,
				ai: () => number,
				ee: () => bytes,
				t2: () => exists,
				tW: () => hash
			});
			function number(e) {
				if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`);
			}
			function bool(e) {
				if (typeof e !== 'boolean') throw new Error(`Expected boolean, not ${e}`);
			}
			function bytes(e, ...t) {
				if (!(e instanceof Uint8Array)) throw new Error('Expected Uint8Array');
				if (t.length > 0 && !t.includes(e.length))
					throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
			}
			function hash(e) {
				if (typeof e !== 'function' || typeof e.create !== 'function')
					throw new Error('Hash should be wrapped by utils.wrapConstructor');
				number(e.outputLen);
				number(e.blockLen);
			}
			function exists(e, t = true) {
				if (e.destroyed) throw new Error('Hash instance has been destroyed');
				if (t && e.finished) throw new Error('Hash#digest() has already been called');
			}
			function output(e, t) {
				bytes(e);
				const r = t.outputLen;
				if (e.length < r) {
					throw new Error(`digestInto() expects output buffer of length at least ${r}`);
				}
			}
			const i = { number, bool, bytes, hash, exists, output };
			var a = null && i;
		},
		9496: (e, t, r) => {
			'use strict';
			r.d(t, { D: () => SHA2 });
			var i = r(6638);
			var a = r(3067);
			function setBigUint64(e, t, r, i) {
				if (typeof e.setBigUint64 === 'function') return e.setBigUint64(t, r, i);
				const a = BigInt(32);
				const o = BigInt(4294967295);
				const c = Number((r >> a) & o);
				const u = Number(r & o);
				const l = i ? 4 : 0;
				const d = i ? 0 : 4;
				e.setUint32(t + l, c, i);
				e.setUint32(t + d, u, i);
			}
			class SHA2 extends a.Vw {
				constructor(e, t, r, i) {
					super();
					this.blockLen = e;
					this.outputLen = t;
					this.padOffset = r;
					this.isLE = i;
					this.finished = false;
					this.length = 0;
					this.pos = 0;
					this.destroyed = false;
					this.buffer = new Uint8Array(e);
					this.view = (0, a.O8)(this.buffer);
				}
				update(e) {
					(0, i.t2)(this);
					const { view: t, buffer: r, blockLen: o } = this;
					e = (0, a.ZJ)(e);
					const c = e.length;
					for (let i = 0; i < c; ) {
						const u = Math.min(o - this.pos, c - i);
						if (u === o) {
							const t = (0, a.O8)(e);
							for (; o <= c - i; i += o) this.process(t, i);
							continue;
						}
						r.set(e.subarray(i, i + u), this.pos);
						this.pos += u;
						i += u;
						if (this.pos === o) {
							this.process(t, 0);
							this.pos = 0;
						}
					}
					this.length += e.length;
					this.roundClean();
					return this;
				}
				digestInto(e) {
					(0, i.t2)(this);
					(0, i.CG)(e, this);
					this.finished = true;
					const { buffer: t, view: r, blockLen: o, isLE: c } = this;
					let { pos: u } = this;
					t[u++] = 128;
					this.buffer.subarray(u).fill(0);
					if (this.padOffset > o - u) {
						this.process(r, 0);
						u = 0;
					}
					for (let e = u; e < o; e++) t[e] = 0;
					setBigUint64(r, o - 8, BigInt(this.length * 8), c);
					this.process(r, 0);
					const l = (0, a.O8)(e);
					const d = this.outputLen;
					if (d % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
					const p = d / 4;
					const m = this.get();
					if (p > m.length) throw new Error('_sha2: outputLen bigger than state');
					for (let e = 0; e < p; e++) l.setUint32(4 * e, m[e], c);
				}
				digest() {
					const { buffer: e, outputLen: t } = this;
					this.digestInto(e);
					const r = e.slice(0, t);
					this.destroy();
					return r;
				}
				_cloneInto(e) {
					e || (e = new this.constructor());
					e.set(...this.get());
					const { blockLen: t, buffer: r, length: i, finished: a, destroyed: o, pos: c } = this;
					e.length = i;
					e.pos = c;
					e.finished = a;
					e.destroyed = o;
					if (i % t) e.buffer.set(r);
					return e;
				}
			}
		},
		7839: (e, t, r) => {
			'use strict';
			r.d(t, {
				Ay: () => c,
				B4: () => rotlSL,
				P5: () => rotlSH,
				WM: () => rotlBH,
				im: () => rotlBL,
				lD: () => split
			});
			const i = BigInt(2 ** 32 - 1);
			const a = BigInt(32);
			function fromBig(e, t = false) {
				if (t) return { h: Number(e & i), l: Number((e >> a) & i) };
				return { h: Number((e >> a) & i) | 0, l: Number(e & i) | 0 };
			}
			function split(e, t = false) {
				let r = new Uint32Array(e.length);
				let i = new Uint32Array(e.length);
				for (let a = 0; a < e.length; a++) {
					const { h: o, l: c } = fromBig(e[a], t);
					[r[a], i[a]] = [o, c];
				}
				return [r, i];
			}
			const toBig = (e, t) => (BigInt(e >>> 0) << a) | BigInt(t >>> 0);
			const shrSH = (e, t, r) => e >>> r;
			const shrSL = (e, t, r) => (e << (32 - r)) | (t >>> r);
			const rotrSH = (e, t, r) => (e >>> r) | (t << (32 - r));
			const rotrSL = (e, t, r) => (e << (32 - r)) | (t >>> r);
			const rotrBH = (e, t, r) => (e << (64 - r)) | (t >>> (r - 32));
			const rotrBL = (e, t, r) => (e >>> (r - 32)) | (t << (64 - r));
			const rotr32H = (e, t) => t;
			const rotr32L = (e, t) => e;
			const rotlSH = (e, t, r) => (e << r) | (t >>> (32 - r));
			const rotlSL = (e, t, r) => (t << r) | (e >>> (32 - r));
			const rotlBH = (e, t, r) => (t << (r - 32)) | (e >>> (64 - r));
			const rotlBL = (e, t, r) => (e << (r - 32)) | (t >>> (64 - r));
			function add(e, t, r, i) {
				const a = (t >>> 0) + (i >>> 0);
				return { h: (e + r + ((a / 2 ** 32) | 0)) | 0, l: a | 0 };
			}
			const add3L = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0);
			const add3H = (e, t, r, i) => (t + r + i + ((e / 2 ** 32) | 0)) | 0;
			const add4L = (e, t, r, i) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0);
			const add4H = (e, t, r, i, a) => (t + r + i + a + ((e / 2 ** 32) | 0)) | 0;
			const add5L = (e, t, r, i, a) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0) + (a >>> 0);
			const add5H = (e, t, r, i, a, o) => (t + r + i + a + o + ((e / 2 ** 32) | 0)) | 0;
			const o = {
				fromBig,
				split,
				toBig,
				shrSH,
				shrSL,
				rotrSH,
				rotrSL,
				rotrBH,
				rotrBL,
				rotr32H,
				rotr32L,
				rotlSH,
				rotlSL,
				rotlBH,
				rotlBL,
				add,
				add3L,
				add3H,
				add4L,
				add4H,
				add5H,
				add5L
			};
			const c = o;
		},
		1878: (e, t, r) => {
			'use strict';
			r.d(t, { w: () => hmac });
			var i = r(6638);
			var a = r(3067);
			class HMAC extends a.Vw {
				constructor(e, t) {
					super();
					this.finished = false;
					this.destroyed = false;
					(0, i.tW)(e);
					const r = (0, a.ZJ)(t);
					this.iHash = e.create();
					if (typeof this.iHash.update !== 'function')
						throw new Error('Expected instance of class which extends utils.Hash');
					this.blockLen = this.iHash.blockLen;
					this.outputLen = this.iHash.outputLen;
					const o = this.blockLen;
					const c = new Uint8Array(o);
					c.set(r.length > o ? e.create().update(r).digest() : r);
					for (let e = 0; e < c.length; e++) c[e] ^= 54;
					this.iHash.update(c);
					this.oHash = e.create();
					for (let e = 0; e < c.length; e++) c[e] ^= 54 ^ 92;
					this.oHash.update(c);
					c.fill(0);
				}
				update(e) {
					(0, i.t2)(this);
					this.iHash.update(e);
					return this;
				}
				digestInto(e) {
					(0, i.t2)(this);
					(0, i.ee)(e, this.outputLen);
					this.finished = true;
					this.iHash.digestInto(e);
					this.oHash.update(e);
					this.oHash.digestInto(e);
					this.destroy();
				}
				digest() {
					const e = new Uint8Array(this.oHash.outputLen);
					this.digestInto(e);
					return e;
				}
				_cloneInto(e) {
					e || (e = Object.create(Object.getPrototypeOf(this), {}));
					const { oHash: t, iHash: r, finished: i, destroyed: a, blockLen: o, outputLen: c } = this;
					e = e;
					e.finished = i;
					e.destroyed = a;
					e.blockLen = o;
					e.outputLen = c;
					e.oHash = t._cloneInto(e.oHash);
					e.iHash = r._cloneInto(e.iHash);
					return e;
				}
				destroy() {
					this.destroyed = true;
					this.oHash.destroy();
					this.iHash.destroy();
				}
			}
			const hmac = (e, t, r) => new HMAC(e, t).update(r).digest();
			hmac.create = (e, t) => new HMAC(e, t);
		},
		9584: (e, t, r) => {
			'use strict';
			r.d(t, { A: () => pbkdf2 });
			var i = r(6638);
			var a = r(1878);
			var o = r(3067);
			function pbkdf2Init(e, t, r, c) {
				(0, i.tW)(e);
				const u = (0, o.tY)({ dkLen: 32, asyncTick: 10 }, c);
				const { c: l, dkLen: d, asyncTick: p } = u;
				(0, i.ai)(l);
				(0, i.ai)(d);
				(0, i.ai)(p);
				if (l < 1) throw new Error('PBKDF2: iterations (c) should be >= 1');
				const m = (0, o.ZJ)(t);
				const g = (0, o.ZJ)(r);
				const v = new Uint8Array(d);
				const y = a.w.create(e, m);
				const w = y._cloneInto().update(g);
				return { c: l, dkLen: d, asyncTick: p, DK: v, PRF: y, PRFSalt: w };
			}
			function pbkdf2Output(e, t, r, i, a) {
				e.destroy();
				t.destroy();
				if (i) i.destroy();
				a.fill(0);
				return r;
			}
			function pbkdf2(e, t, r, i) {
				const { c: a, dkLen: c, DK: u, PRF: l, PRFSalt: d } = pbkdf2Init(e, t, r, i);
				let p;
				const m = new Uint8Array(4);
				const g = (0, o.O8)(m);
				const v = new Uint8Array(l.outputLen);
				for (let e = 1, t = 0; t < c; e++, t += l.outputLen) {
					const r = u.subarray(t, t + l.outputLen);
					g.setInt32(0, e, false);
					(p = d._cloneInto(p)).update(m).digestInto(v);
					r.set(v.subarray(0, r.length));
					for (let e = 1; e < a; e++) {
						l._cloneInto(p).update(v).digestInto(v);
						for (let e = 0; e < r.length; e++) r[e] ^= v[e];
					}
				}
				return pbkdf2Output(l, d, u, p, v);
			}
			async function pbkdf2Async(e, t, r, i) {
				const { c: a, dkLen: o, asyncTick: c, DK: u, PRF: l, PRFSalt: d } = pbkdf2Init(e, t, r, i);
				let p;
				const m = new Uint8Array(4);
				const g = createView(m);
				const v = new Uint8Array(l.outputLen);
				for (let e = 1, t = 0; t < o; e++, t += l.outputLen) {
					const r = u.subarray(t, t + l.outputLen);
					g.setInt32(0, e, false);
					(p = d._cloneInto(p)).update(m).digestInto(v);
					r.set(v.subarray(0, r.length));
					await asyncLoop(a - 1, c, () => {
						l._cloneInto(p).update(v).digestInto(v);
						for (let e = 0; e < r.length; e++) r[e] ^= v[e];
					});
				}
				return pbkdf2Output(l, d, u, p, v);
			}
		},
		330: (e, t, r) => {
			'use strict';
			r.d(t, { s: () => l });
			var i = r(9496);
			var a = r(3067);
			const Chi = (e, t, r) => (e & t) ^ (~e & r);
			const Maj = (e, t, r) => (e & t) ^ (e & r) ^ (t & r);
			const o = new Uint32Array([
				1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748,
				2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206,
				2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122,
				1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891,
				3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700,
				1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771,
				3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877,
				958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452,
				2361852424, 2428436474, 2756734187, 3204031479, 3329325298
			]);
			const c = new Uint32Array([
				1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,
				1541459225
			]);
			const u = new Uint32Array(64);
			class SHA256 extends i.D {
				constructor() {
					super(64, 32, 8, false);
					this.A = c[0] | 0;
					this.B = c[1] | 0;
					this.C = c[2] | 0;
					this.D = c[3] | 0;
					this.E = c[4] | 0;
					this.F = c[5] | 0;
					this.G = c[6] | 0;
					this.H = c[7] | 0;
				}
				get() {
					const { A: e, B: t, C: r, D: i, E: a, F: o, G: c, H: u } = this;
					return [e, t, r, i, a, o, c, u];
				}
				set(e, t, r, i, a, o, c, u) {
					this.A = e | 0;
					this.B = t | 0;
					this.C = r | 0;
					this.D = i | 0;
					this.E = a | 0;
					this.F = o | 0;
					this.G = c | 0;
					this.H = u | 0;
				}
				process(e, t) {
					for (let r = 0; r < 16; r++, t += 4) u[r] = e.getUint32(t, false);
					for (let e = 16; e < 64; e++) {
						const t = u[e - 15];
						const r = u[e - 2];
						const i = (0, a.Ow)(t, 7) ^ (0, a.Ow)(t, 18) ^ (t >>> 3);
						const o = (0, a.Ow)(r, 17) ^ (0, a.Ow)(r, 19) ^ (r >>> 10);
						u[e] = (o + u[e - 7] + i + u[e - 16]) | 0;
					}
					let { A: r, B: i, C: c, D: l, E: d, F: p, G: m, H: g } = this;
					for (let e = 0; e < 64; e++) {
						const t = (0, a.Ow)(d, 6) ^ (0, a.Ow)(d, 11) ^ (0, a.Ow)(d, 25);
						const v = (g + t + Chi(d, p, m) + o[e] + u[e]) | 0;
						const y = (0, a.Ow)(r, 2) ^ (0, a.Ow)(r, 13) ^ (0, a.Ow)(r, 22);
						const w = (y + Maj(r, i, c)) | 0;
						g = m;
						m = p;
						p = d;
						d = (l + v) | 0;
						l = c;
						c = i;
						i = r;
						r = (v + w) | 0;
					}
					r = (r + this.A) | 0;
					i = (i + this.B) | 0;
					c = (c + this.C) | 0;
					l = (l + this.D) | 0;
					d = (d + this.E) | 0;
					p = (p + this.F) | 0;
					m = (m + this.G) | 0;
					g = (g + this.H) | 0;
					this.set(r, i, c, l, d, p, m, g);
				}
				roundClean() {
					u.fill(0);
				}
				destroy() {
					this.set(0, 0, 0, 0, 0, 0, 0, 0);
					this.buffer.fill(0);
				}
			}
			class SHA224 extends SHA256 {
				constructor() {
					super();
					this.A = 3238371032 | 0;
					this.B = 914150663 | 0;
					this.C = 812702999 | 0;
					this.D = 4144912697 | 0;
					this.E = 4290775857 | 0;
					this.F = 1750603025 | 0;
					this.G = 1694076839 | 0;
					this.H = 3204075428 | 0;
					this.outputLen = 28;
				}
			}
			const l = (0, a.ld)(() => new SHA256());
			const d = null && wrapConstructor(() => new SHA224());
		},
		3067: (e, t, r) => {
			'use strict';
			r.d(t, {
				Vw: () => Hash,
				$h: () => asyncLoop,
				tY: () => checkOpts,
				Id: () => concatBytes,
				O8: () => createView,
				po: () => randomBytes,
				Ow: () => rotr,
				ZJ: () => toBytes,
				DH: () => u32,
				ld: () => wrapConstructor
			});
			const i =
				typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;
			const u8a = (e) => e instanceof Uint8Array;
			const u8 = (e) => new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
			const u32 = (e) => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
			const createView = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
			const rotr = (e, t) => (e << (32 - t)) | (e >>> t);
			const a = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
			if (!a) throw new Error('Non little-endian hardware is not supported');
			const o = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0'));
			function bytesToHex(e) {
				if (!u8a(e)) throw new Error('Uint8Array expected');
				let t = '';
				for (let r = 0; r < e.length; r++) {
					t += o[e[r]];
				}
				return t;
			}
			function hexToBytes(e) {
				if (typeof e !== 'string') throw new Error('hex string expected, got ' + typeof e);
				const t = e.length;
				if (t % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + t);
				const r = new Uint8Array(t / 2);
				for (let t = 0; t < r.length; t++) {
					const i = t * 2;
					const a = e.slice(i, i + 2);
					const o = Number.parseInt(a, 16);
					if (Number.isNaN(o) || o < 0) throw new Error('Invalid byte sequence');
					r[t] = o;
				}
				return r;
			}
			const nextTick = async () => {};
			async function asyncLoop(e, t, r) {
				let i = Date.now();
				for (let a = 0; a < e; a++) {
					r(a);
					const e = Date.now() - i;
					if (e >= 0 && e < t) continue;
					await nextTick();
					i += e;
				}
			}
			function utf8ToBytes(e) {
				if (typeof e !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
				return new Uint8Array(new TextEncoder().encode(e));
			}
			function toBytes(e) {
				if (typeof e === 'string') e = utf8ToBytes(e);
				if (!u8a(e)) throw new Error(`expected Uint8Array, got ${typeof e}`);
				return e;
			}
			function concatBytes(...e) {
				const t = new Uint8Array(e.reduce((e, t) => e + t.length, 0));
				let r = 0;
				e.forEach((e) => {
					if (!u8a(e)) throw new Error('Uint8Array expected');
					t.set(e, r);
					r += e.length;
				});
				return t;
			}
			class Hash {
				clone() {
					return this._cloneInto();
				}
			}
			const c = {}.toString;
			function checkOpts(e, t) {
				if (t !== undefined && c.call(t) !== '[object Object]')
					throw new Error('Options should be object or undefined');
				const r = Object.assign(e, t);
				return r;
			}
			function wrapConstructor(e) {
				const hashC = (t) => e().update(toBytes(t)).digest();
				const t = e();
				hashC.outputLen = t.outputLen;
				hashC.blockLen = t.blockLen;
				hashC.create = () => e();
				return hashC;
			}
			function wrapConstructorWithOpts(e) {
				const hashC = (t, r) => e(r).update(toBytes(t)).digest();
				const t = e({});
				hashC.outputLen = t.outputLen;
				hashC.blockLen = t.blockLen;
				hashC.create = (t) => e(t);
				return hashC;
			}
			function wrapXOFConstructorWithOpts(e) {
				const hashC = (t, r) => e(r).update(toBytes(t)).digest();
				const t = e({});
				hashC.outputLen = t.outputLen;
				hashC.blockLen = t.blockLen;
				hashC.create = (t) => e(t);
				return hashC;
			}
			function randomBytes(e = 32) {
				if (i && typeof i.getRandomValues === 'function') {
					return i.getRandomValues(new Uint8Array(e));
				}
				throw new Error('crypto.getRandomValues must be defined');
			}
		},
		4067: (e, t, r) => {
			'use strict';
			r.d(t, { Xp: () => CBC, cf: () => CTR, ny: () => pkcs7Strip });
			var i =
				(undefined && undefined.__classPrivateFieldGet) ||
				function (e, t, r, i) {
					if (r === 'a' && !i) throw new TypeError('Private accessor was defined without a getter');
					if (typeof t === 'function' ? e !== t || !i : !t.has(e))
						throw new TypeError(
							'Cannot read private member from an object whose class did not declare it'
						);
					return r === 'm' ? i : r === 'a' ? i.call(e) : i ? i.value : t.get(e);
				};
			var a =
				(undefined && undefined.__classPrivateFieldSet) ||
				function (e, t, r, i, a) {
					if (i === 'm') throw new TypeError('Private method is not writable');
					if (i === 'a' && !a) throw new TypeError('Private accessor was defined without a setter');
					if (typeof t === 'function' ? e !== t || !a : !t.has(e))
						throw new TypeError(
							'Cannot write private member to an object whose class did not declare it'
						);
					return i === 'a' ? a.call(e, r) : a ? (a.value = r) : t.set(e, r), r;
				};
			var o, c, u;
			const l = { 16: 10, 24: 12, 32: 14 };
			const d = [
				1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53,
				106, 212, 179, 125, 250, 239, 197, 145
			];
			const p = [
				99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201,
				125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63,
				247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128,
				226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47,
				132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170,
				251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56,
				245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126,
				61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11,
				219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55,
				109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180,
				198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87,
				185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85,
				40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22
			];
			const m = [
				82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130,
				155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61,
				238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73,
				109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182,
				146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216,
				171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15,
				2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207,
				206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117,
				223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86,
				62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7,
				199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122,
				159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83,
				153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125
			];
			const g = [
				3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041,
				2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474,
				1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645,
				2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738,
				597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774,
				1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420,
				3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908,
				2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577,
				605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043,
				495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614,
				1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799,
				2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621,
				3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944,
				2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463,
				1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508,
				631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660,
				1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632,
				3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079,
				3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354,
				2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720,
				2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882,
				3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934,
				3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172,
				3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756,
				3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028,
				2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077,
				3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399,
				1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932,
				3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232,
				2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154,
				3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745,
				3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399,
				765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080,
				2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982,
				3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068,
				1841019862, 739644986
			];
			const v = [
				2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751,
				1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899,
				2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041,
				3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108,
				4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398,
				1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129,
				2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331,
				1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848,
				1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339,
				1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114,
				1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724,
				4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131,
				3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064,
				1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773,
				1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160,
				1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239,
				2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098,
				1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699,
				801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751,
				2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144,
				2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144,
				3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883,
				1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134,
				1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105,
				2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389,
				2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468,
				634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856,
				1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992,
				2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234,
				2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494,
				2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965,
				3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838,
				2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045,
				2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311,
				836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607,
				3413881008, 4238890068, 3597515707, 975967766
			];
			const y = [
				1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791,
				3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099,
				1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841,
				1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188,
				2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518,
				911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069,
				4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651,
				3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768,
				3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252,
				439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278,
				3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0,
				3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667,
				3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360,
				4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541,
				1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671,
				2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285,
				944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895,
				4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855,
				2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525,
				1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615,
				3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566,
				3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546,
				978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131,
				2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455,
				3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425,
				1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822,
				135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164,
				3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765,
				2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264,
				50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686,
				3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729,
				1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927,
				3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649,
				2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905,
				2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126
			];
			const w = [
				1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006,
				3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549,
				1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266,
				1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243,
				2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788,
				909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729,
				4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246,
				3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963,
				3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872,
				437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943,
				3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0,
				3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717,
				3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995,
				4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921,
				1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221,
				2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225,
				943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645,
				4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230,
				2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170,
				1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070,
				3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671,
				3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716,
				976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021,
				2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725,
				3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505,
				1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567,
				134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419,
				3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545,
				2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584,
				50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911,
				3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874,
				1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917,
				3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649,
				2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930,
				2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436
			];
			const _ = [
				1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787,
				540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152,
				3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058,
				2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843,
				1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046,
				4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237,
				2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743,
				1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835,
				2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154,
				4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293,
				2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657,
				2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164,
				3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483,
				2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830,
				4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554,
				202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374,
				3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864,
				1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661,
				1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384,
				328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059,
				3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396,
				2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334,
				2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195,
				1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924,
				1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377,
				1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502,
				3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584,
				1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806,
				395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075,
				3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386,
				2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441,
				3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761,
				1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942,
				941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206,
				3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890
			];
			const A = [
				1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216,
				2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987,
				2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728,
				2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123,
				3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113,
				3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459,
				1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965,
				2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370,
				2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276,
				2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614,
				2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976,
				4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868,
				4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339,
				954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597,
				2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590,
				3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021,
				2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197,
				2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624,
				2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940,
				1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730,
				1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489,
				4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110,
				3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837,
				223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695,
				3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147,
				2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751,
				3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259,
				818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826,
				243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840,
				3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242,
				870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569,
				3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469,
				1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296,
				1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780,
				2422494913, 1635502980, 1893020342, 1950903388, 1120974935
			];
			const k = [
				2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946,
				59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562,
				1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311,
				4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298,
				2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3,
				1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209,
				2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725,
				1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725,
				2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631,
				3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174,
				1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737,
				273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318,
				369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849,
				1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627,
				1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047,
				2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075,
				3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147,
				218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199,
				648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005,
				4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705,
				2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052,
				1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200,
				2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442,
				2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595,
				2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892,
				3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991,
				3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639,
				2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196,
				3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910,
				3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831,
				1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464,
				1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610,
				3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519,
				3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544,
				3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600
			];
			const N = [
				4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116,
				3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702,
				1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793,
				1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988,
				1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143,
				3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559,
				1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055,
				3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170,
				3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866,
				2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668,
				4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261,
				562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348,
				1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919,
				425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802,
				292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400,
				1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416,
				3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742,
				2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535,
				1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952,
				836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110,
				698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689,
				2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655,
				953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791,
				983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814,
				3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952,
				2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230,
				4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305,
				2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872,
				2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739,
				2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909,
				2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253,
				3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689,
				1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159,
				1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990,
				3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988,
				3414450555, 850817237, 1817998408, 3092726480
			];
			const T = [
				0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496,
				2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529,
				3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474,
				3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407,
				3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343,
				3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942,
				2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150,
				59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414,
				1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520,
				3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269,
				3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366,
				1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127,
				1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711,
				1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311,
				1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783,
				742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354,
				3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937,
				3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034,
				2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354,
				159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386,
				2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377,
				3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743,
				2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284,
				3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213,
				2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582,
				1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814,
				540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566,
				3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557,
				2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293,
				975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661,
				1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950,
				25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806,
				1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247,
				4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420,
				3043140495, 2673705150, 2438237621, 2203032232, 2370213795
			];
			const x = [
				0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576,
				1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459,
				2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614,
				2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537,
				3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543,
				1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535,
				77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207,
				3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884,
				3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975,
				3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824,
				3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461,
				1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622,
				507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846,
				2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216,
				3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375,
				4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879,
				129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162,
				1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469,
				3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840,
				2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175,
				1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130,
				350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921,
				2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618,
				3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127,
				3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767,
				223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560,
				1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046,
				1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387,
				2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696,
				2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037,
				4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969,
				1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148,
				692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636,
				3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663,
				2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882,
				2743944855
			];
			const B = [
				0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376,
				1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639,
				3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174,
				4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557,
				2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663,
				2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032,
				3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033,
				2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201,
				344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180,
				2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772,
				313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932,
				2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135,
				3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085,
				3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354,
				3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963,
				2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195,
				621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600,
				1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968,
				3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199,
				2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431,
				1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311,
				1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613,
				1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205,
				516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645,
				2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318,
				3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634,
				3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549,
				3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452,
				4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591,
				1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135,
				567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692,
				574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501,
				1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562,
				3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315,
				2744104290, 2159976285, 2377486676, 2594734927, 2544078150
			];
			const P = [
				0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936,
				1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874,
				2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524,
				2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222,
				4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221,
				227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909,
				1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947,
				2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729,
				3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905,
				1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619,
				740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739,
				4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493,
				2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231,
				1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426,
				1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418,
				983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424,
				3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382,
				3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219,
				3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765,
				3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655,
				1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905,
				1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426,
				3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048,
				2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542,
				2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780,
				1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620,
				972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988,
				3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166,
				4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766,
				777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662,
				1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147,
				3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233,
				4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431,
				953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159,
				1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925
			];
			function convertToInt32(e) {
				const t = [];
				for (let r = 0; r < e.length; r += 4) {
					t.push((e[r] << 24) | (e[r + 1] << 16) | (e[r + 2] << 8) | e[r + 3]);
				}
				return t;
			}
			class AES {
				get key() {
					return i(this, o, 'f').slice();
				}
				constructor(e) {
					o.set(this, void 0);
					c.set(this, void 0);
					u.set(this, void 0);
					if (!(this instanceof AES)) {
						throw Error('AES must be instanitated with `new`');
					}
					a(this, o, new Uint8Array(e), 'f');
					const t = l[this.key.length];
					if (t == null) {
						throw new TypeError('invalid key size (must be 16, 24 or 32 bytes)');
					}
					a(this, u, [], 'f');
					a(this, c, [], 'f');
					for (let e = 0; e <= t; e++) {
						i(this, u, 'f').push([0, 0, 0, 0]);
						i(this, c, 'f').push([0, 0, 0, 0]);
					}
					const r = (t + 1) * 4;
					const m = this.key.length / 4;
					const g = convertToInt32(this.key);
					let v;
					for (let e = 0; e < m; e++) {
						v = e >> 2;
						i(this, u, 'f')[v][e % 4] = g[e];
						i(this, c, 'f')[t - v][e % 4] = g[e];
					}
					let y = 0;
					let w = m,
						_;
					while (w < r) {
						_ = g[m - 1];
						g[0] ^=
							(p[(_ >> 16) & 255] << 24) ^
							(p[(_ >> 8) & 255] << 16) ^
							(p[_ & 255] << 8) ^
							p[(_ >> 24) & 255] ^
							(d[y] << 24);
						y += 1;
						if (m != 8) {
							for (let e = 1; e < m; e++) {
								g[e] ^= g[e - 1];
							}
						} else {
							for (let e = 1; e < m / 2; e++) {
								g[e] ^= g[e - 1];
							}
							_ = g[m / 2 - 1];
							g[m / 2] ^=
								p[_ & 255] ^
								(p[(_ >> 8) & 255] << 8) ^
								(p[(_ >> 16) & 255] << 16) ^
								(p[(_ >> 24) & 255] << 24);
							for (let e = m / 2 + 1; e < m; e++) {
								g[e] ^= g[e - 1];
							}
						}
						let e = 0,
							a,
							o;
						while (e < m && w < r) {
							a = w >> 2;
							o = w % 4;
							i(this, u, 'f')[a][o] = g[e];
							i(this, c, 'f')[t - a][o] = g[e++];
							w++;
						}
					}
					for (let e = 1; e < t; e++) {
						for (let t = 0; t < 4; t++) {
							_ = i(this, c, 'f')[e][t];
							i(this, c, 'f')[e][t] =
								T[(_ >> 24) & 255] ^ x[(_ >> 16) & 255] ^ B[(_ >> 8) & 255] ^ P[_ & 255];
						}
					}
				}
				encrypt(e) {
					if (e.length != 16) {
						throw new TypeError('invalid plaintext size (must be 16 bytes)');
					}
					const t = i(this, u, 'f').length - 1;
					const r = [0, 0, 0, 0];
					let a = convertToInt32(e);
					for (let e = 0; e < 4; e++) {
						a[e] ^= i(this, u, 'f')[0][e];
					}
					for (let e = 1; e < t; e++) {
						for (let t = 0; t < 4; t++) {
							r[t] =
								g[(a[t] >> 24) & 255] ^
								v[(a[(t + 1) % 4] >> 16) & 255] ^
								y[(a[(t + 2) % 4] >> 8) & 255] ^
								w[a[(t + 3) % 4] & 255] ^
								i(this, u, 'f')[e][t];
						}
						a = r.slice();
					}
					const o = new Uint8Array(16);
					let c = 0;
					for (let e = 0; e < 4; e++) {
						c = i(this, u, 'f')[t][e];
						o[4 * e] = (p[(a[e] >> 24) & 255] ^ (c >> 24)) & 255;
						o[4 * e + 1] = (p[(a[(e + 1) % 4] >> 16) & 255] ^ (c >> 16)) & 255;
						o[4 * e + 2] = (p[(a[(e + 2) % 4] >> 8) & 255] ^ (c >> 8)) & 255;
						o[4 * e + 3] = (p[a[(e + 3) % 4] & 255] ^ c) & 255;
					}
					return o;
				}
				decrypt(e) {
					if (e.length != 16) {
						throw new TypeError('invalid ciphertext size (must be 16 bytes)');
					}
					const t = i(this, c, 'f').length - 1;
					const r = [0, 0, 0, 0];
					let a = convertToInt32(e);
					for (let e = 0; e < 4; e++) {
						a[e] ^= i(this, c, 'f')[0][e];
					}
					for (let e = 1; e < t; e++) {
						for (let t = 0; t < 4; t++) {
							r[t] =
								_[(a[t] >> 24) & 255] ^
								A[(a[(t + 3) % 4] >> 16) & 255] ^
								k[(a[(t + 2) % 4] >> 8) & 255] ^
								N[a[(t + 1) % 4] & 255] ^
								i(this, c, 'f')[e][t];
						}
						a = r.slice();
					}
					const o = new Uint8Array(16);
					let u = 0;
					for (let e = 0; e < 4; e++) {
						u = i(this, c, 'f')[t][e];
						o[4 * e] = (m[(a[e] >> 24) & 255] ^ (u >> 24)) & 255;
						o[4 * e + 1] = (m[(a[(e + 3) % 4] >> 16) & 255] ^ (u >> 16)) & 255;
						o[4 * e + 2] = (m[(a[(e + 2) % 4] >> 8) & 255] ^ (u >> 8)) & 255;
						o[4 * e + 3] = (m[a[(e + 1) % 4] & 255] ^ u) & 255;
					}
					return o;
				}
			}
			(o = new WeakMap()), (c = new WeakMap()), (u = new WeakMap());
			class ModeOfOperation {
				constructor(e, t, r) {
					if (r && !(this instanceof r)) {
						throw new Error(`${e} must be instantiated with "new"`);
					}
					Object.defineProperties(this, {
						aes: { enumerable: true, value: new AES(t) },
						name: { enumerable: true, value: e }
					});
				}
			}
			var M =
				(undefined && undefined.__classPrivateFieldSet) ||
				function (e, t, r, i, a) {
					if (i === 'm') throw new TypeError('Private method is not writable');
					if (i === 'a' && !a) throw new TypeError('Private accessor was defined without a setter');
					if (typeof t === 'function' ? e !== t || !a : !t.has(e))
						throw new TypeError(
							'Cannot write private member to an object whose class did not declare it'
						);
					return i === 'a' ? a.call(e, r) : a ? (a.value = r) : t.set(e, r), r;
				};
			var C =
				(undefined && undefined.__classPrivateFieldGet) ||
				function (e, t, r, i) {
					if (r === 'a' && !i) throw new TypeError('Private accessor was defined without a getter');
					if (typeof t === 'function' ? e !== t || !i : !t.has(e))
						throw new TypeError(
							'Cannot read private member from an object whose class did not declare it'
						);
					return r === 'm' ? i : r === 'a' ? i.call(e) : i ? i.value : t.get(e);
				};
			var I, O;
			class CBC extends ModeOfOperation {
				constructor(e, t) {
					super('ECC', e, CBC);
					I.set(this, void 0);
					O.set(this, void 0);
					if (t) {
						if (t.length % 16) {
							throw new TypeError('invalid iv size (must be 16 bytes)');
						}
						M(this, I, new Uint8Array(t), 'f');
					} else {
						M(this, I, new Uint8Array(16), 'f');
					}
					M(this, O, this.iv, 'f');
				}
				get iv() {
					return new Uint8Array(C(this, I, 'f'));
				}
				encrypt(e) {
					if (e.length % 16) {
						throw new TypeError('invalid plaintext size (must be multiple of 16 bytes)');
					}
					const t = new Uint8Array(e.length);
					for (let r = 0; r < e.length; r += 16) {
						for (let t = 0; t < 16; t++) {
							C(this, O, 'f')[t] ^= e[r + t];
						}
						M(this, O, this.aes.encrypt(C(this, O, 'f')), 'f');
						t.set(C(this, O, 'f'), r);
					}
					return t;
				}
				decrypt(e) {
					if (e.length % 16) {
						throw new TypeError('invalid ciphertext size (must be multiple of 16 bytes)');
					}
					const t = new Uint8Array(e.length);
					for (let r = 0; r < e.length; r += 16) {
						const i = this.aes.decrypt(e.subarray(r, r + 16));
						for (let a = 0; a < 16; a++) {
							t[r + a] = i[a] ^ C(this, O, 'f')[a];
							C(this, O, 'f')[a] = e[r + a];
						}
					}
					return t;
				}
			}
			(I = new WeakMap()), (O = new WeakMap());
			var F =
				(undefined && undefined.__classPrivateFieldSet) ||
				function (e, t, r, i, a) {
					if (i === 'm') throw new TypeError('Private method is not writable');
					if (i === 'a' && !a) throw new TypeError('Private accessor was defined without a setter');
					if (typeof t === 'function' ? e !== t || !a : !t.has(e))
						throw new TypeError(
							'Cannot write private member to an object whose class did not declare it'
						);
					return i === 'a' ? a.call(e, r) : a ? (a.value = r) : t.set(e, r), r;
				};
			var D =
				(undefined && undefined.__classPrivateFieldGet) ||
				function (e, t, r, i) {
					if (r === 'a' && !i) throw new TypeError('Private accessor was defined without a getter');
					if (typeof t === 'function' ? e !== t || !i : !t.has(e))
						throw new TypeError(
							'Cannot read private member from an object whose class did not declare it'
						);
					return r === 'm' ? i : r === 'a' ? i.call(e) : i ? i.value : t.get(e);
				};
			var L, U, j, H;
			class CFB extends ModeOfOperation {
				constructor(e, t, r = 8) {
					super('CFB', e, CFB);
					L.add(this);
					U.set(this, void 0);
					j.set(this, void 0);
					if (!Number.isInteger(r) || r % 8) {
						throw new TypeError('invalid segmentSize');
					}
					Object.defineProperties(this, { segmentSize: { enumerable: true, value: r } });
					if (t) {
						if (t.length % 16) {
							throw new TypeError('invalid iv size (must be 16 bytes)');
						}
						F(this, U, new Uint8Array(t), 'f');
					} else {
						F(this, U, new Uint8Array(16), 'f');
					}
					F(this, j, this.iv, 'f');
				}
				get iv() {
					return new Uint8Array(D(this, U, 'f'));
				}
				encrypt(e) {
					if ((8 * e.length) % this.segmentSize) {
						throw new TypeError('invalid plaintext size (must be multiple of segmentSize bytes)');
					}
					const t = this.segmentSize / 8;
					const r = new Uint8Array(e);
					for (let e = 0; e < r.length; e += t) {
						const i = this.aes.encrypt(D(this, j, 'f'));
						for (let a = 0; a < t; a++) {
							r[e + a] ^= i[a];
						}
						D(this, L, 'm', H).call(this, r.subarray(e));
					}
					return r;
				}
				decrypt(e) {
					if ((8 * e.length) % this.segmentSize) {
						throw new TypeError('invalid ciphertext size (must be multiple of segmentSize bytes)');
					}
					const t = this.segmentSize / 8;
					const r = new Uint8Array(e);
					for (let i = 0; i < r.length; i += t) {
						const a = this.aes.encrypt(D(this, j, 'f'));
						for (let e = 0; e < t; e++) {
							r[i + e] ^= a[e];
						}
						D(this, L, 'm', H).call(this, e.subarray(i));
					}
					return r;
				}
			}
			(U = new WeakMap()),
				(j = new WeakMap()),
				(L = new WeakSet()),
				(H = function _CFB_shift(e) {
					const t = this.segmentSize / 8;
					D(this, j, 'f').set(D(this, j, 'f').subarray(t));
					D(this, j, 'f').set(e.subarray(0, t), 16 - t);
				});
			var z =
				(undefined && undefined.__classPrivateFieldSet) ||
				function (e, t, r, i, a) {
					if (i === 'm') throw new TypeError('Private method is not writable');
					if (i === 'a' && !a) throw new TypeError('Private accessor was defined without a setter');
					if (typeof t === 'function' ? e !== t || !a : !t.has(e))
						throw new TypeError(
							'Cannot write private member to an object whose class did not declare it'
						);
					return i === 'a' ? a.call(e, r) : a ? (a.value = r) : t.set(e, r), r;
				};
			var $ =
				(undefined && undefined.__classPrivateFieldGet) ||
				function (e, t, r, i) {
					if (r === 'a' && !i) throw new TypeError('Private accessor was defined without a getter');
					if (typeof t === 'function' ? e !== t || !i : !t.has(e))
						throw new TypeError(
							'Cannot read private member from an object whose class did not declare it'
						);
					return r === 'm' ? i : r === 'a' ? i.call(e) : i ? i.value : t.get(e);
				};
			var G, q, V;
			class CTR extends ModeOfOperation {
				constructor(e, t) {
					super('CTR', e, CTR);
					G.set(this, void 0);
					q.set(this, void 0);
					V.set(this, void 0);
					z(this, V, new Uint8Array(16), 'f');
					$(this, V, 'f').fill(0);
					z(this, G, $(this, V, 'f'), 'f');
					z(this, q, 16, 'f');
					if (t == null) {
						t = 1;
					}
					if (typeof t === 'number') {
						this.setCounterValue(t);
					} else {
						this.setCounterBytes(t);
					}
				}
				get counter() {
					return new Uint8Array($(this, V, 'f'));
				}
				setCounterValue(e) {
					if (!Number.isInteger(e) || e < 0 || e > Number.MAX_SAFE_INTEGER) {
						throw new TypeError('invalid counter initial integer value');
					}
					for (let t = 15; t >= 0; --t) {
						$(this, V, 'f')[t] = e % 256;
						e = Math.floor(e / 256);
					}
				}
				setCounterBytes(e) {
					if (e.length !== 16) {
						throw new TypeError('invalid counter initial Uint8Array value length');
					}
					$(this, V, 'f').set(e);
				}
				increment() {
					for (let e = 15; e >= 0; e--) {
						if ($(this, V, 'f')[e] === 255) {
							$(this, V, 'f')[e] = 0;
						} else {
							$(this, V, 'f')[e]++;
							break;
						}
					}
				}
				encrypt(e) {
					var t, r;
					const i = new Uint8Array(e);
					for (let e = 0; e < i.length; e++) {
						if ($(this, q, 'f') === 16) {
							z(this, G, this.aes.encrypt($(this, V, 'f')), 'f');
							z(this, q, 0, 'f');
							this.increment();
						}
						i[e] ^= $(this, G, 'f')[(z(this, q, ((r = $(this, q, 'f')), (t = r++), r), 'f'), t)];
					}
					return i;
				}
				decrypt(e) {
					return this.encrypt(e);
				}
			}
			(G = new WeakMap()), (q = new WeakMap()), (V = new WeakMap());
			class ECB extends ModeOfOperation {
				constructor(e) {
					super('ECB', e, ECB);
				}
				encrypt(e) {
					if (e.length % 16) {
						throw new TypeError('invalid plaintext size (must be multiple of 16 bytes)');
					}
					const t = new Uint8Array(e.length);
					for (let r = 0; r < e.length; r += 16) {
						t.set(this.aes.encrypt(e.subarray(r, r + 16)), r);
					}
					return t;
				}
				decrypt(e) {
					if (e.length % 16) {
						throw new TypeError('invalid ciphertext size (must be multiple of 16 bytes)');
					}
					const t = new Uint8Array(e.length);
					for (let r = 0; r < e.length; r += 16) {
						t.set(this.aes.decrypt(e.subarray(r, r + 16)), r);
					}
					return t;
				}
			}
			var W =
				(undefined && undefined.__classPrivateFieldSet) ||
				function (e, t, r, i, a) {
					if (i === 'm') throw new TypeError('Private method is not writable');
					if (i === 'a' && !a) throw new TypeError('Private accessor was defined without a setter');
					if (typeof t === 'function' ? e !== t || !a : !t.has(e))
						throw new TypeError(
							'Cannot write private member to an object whose class did not declare it'
						);
					return i === 'a' ? a.call(e, r) : a ? (a.value = r) : t.set(e, r), r;
				};
			var J =
				(undefined && undefined.__classPrivateFieldGet) ||
				function (e, t, r, i) {
					if (r === 'a' && !i) throw new TypeError('Private accessor was defined without a getter');
					if (typeof t === 'function' ? e !== t || !i : !t.has(e))
						throw new TypeError(
							'Cannot read private member from an object whose class did not declare it'
						);
					return r === 'm' ? i : r === 'a' ? i.call(e) : i ? i.value : t.get(e);
				};
			var Z, Q, Y;
			class OFB extends ModeOfOperation {
				constructor(e, t) {
					super('OFB', e, OFB);
					Z.set(this, void 0);
					Q.set(this, void 0);
					Y.set(this, void 0);
					if (t) {
						if (t.length % 16) {
							throw new TypeError('invalid iv size (must be 16 bytes)');
						}
						W(this, Z, new Uint8Array(t), 'f');
					} else {
						W(this, Z, new Uint8Array(16), 'f');
					}
					W(this, Q, this.iv, 'f');
					W(this, Y, 16, 'f');
				}
				get iv() {
					return new Uint8Array(J(this, Z, 'f'));
				}
				encrypt(e) {
					var t, r;
					if (e.length % 16) {
						throw new TypeError('invalid plaintext size (must be multiple of 16 bytes)');
					}
					const i = new Uint8Array(e);
					for (let e = 0; e < i.length; e++) {
						if (J(this, Y, 'f') === 16) {
							W(this, Q, this.aes.encrypt(J(this, Q, 'f')), 'f');
							W(this, Y, 0, 'f');
						}
						i[e] ^= J(this, Q, 'f')[(W(this, Y, ((r = J(this, Y, 'f')), (t = r++), r), 'f'), t)];
					}
					return i;
				}
				decrypt(e) {
					if (e.length % 16) {
						throw new TypeError('invalid ciphertext size (must be multiple of 16 bytes)');
					}
					return this.encrypt(e);
				}
			}
			(Z = new WeakMap()), (Q = new WeakMap()), (Y = new WeakMap());
			function pkcs7Pad(e) {
				const t = 16 - (e.length % 16);
				const r = new Uint8Array(e.length + t);
				r.set(e);
				for (let i = e.length; i < r.length; i++) {
					r[i] = t;
				}
				return r;
			}
			function pkcs7Strip(e) {
				if (e.length < 16) {
					throw new TypeError('PKCS#7 invalid length');
				}
				const t = e[e.length - 1];
				if (t > 16) {
					throw new TypeError('PKCS#7 padding byte out of range');
				}
				const r = e.length - t;
				for (let i = 0; i < t; i++) {
					if (e[r + i] !== t) {
						throw new TypeError('PKCS#7 invalid padding byte');
					}
				}
				return new Uint8Array(e.subarray(0, r));
			}
		},
		235: (e, t, r) => {
			'use strict';
			r.d(t, { A: () => i });
			const i = false;
		},
		2186: (e, t, r) => {
			'use strict';
			r.d(t, { r: () => i });
			const i = '6.13.5';
		},
		1586: (e, t, r) => {
			'use strict';
			r.d(t, { y: () => AbiCoder });
			var i = r(8492);
			var a = r(9397);
			var o = r(6686);
			var c = r(572);
			var u = r(4440);
			class AddressCoder extends a.Ue {
				constructor(e) {
					super('address', 'address', e, false);
				}
				defaultValue() {
					return '0x0000000000000000000000000000000000000000';
				}
				encode(e, t) {
					let r = u.V.dereference(t, 'string');
					try {
						r = (0, o.b)(r);
					} catch (e) {
						return this._throwError(e.message, t);
					}
					return e.writeValue(r);
				}
				decode(e) {
					return (0, o.b)((0, c.up)(e.readValue(), 20));
				}
			}
			var l = r(4918);
			class AnonymousCoder extends a.Ue {
				coder;
				constructor(e) {
					super(e.name, e.type, '_', e.dynamic);
					this.coder = e;
				}
				defaultValue() {
					return this.coder.defaultValue();
				}
				encode(e, t) {
					return this.coder.encode(e, t);
				}
				decode(e) {
					return this.coder.decode(e);
				}
			}
			function pack(e, t, r) {
				let o = [];
				if (Array.isArray(r)) {
					o = r;
				} else if (r && typeof r === 'object') {
					let e = {};
					o = t.map((t) => {
						const a = t.localName;
						(0, i.vA)(
							a,
							'cannot encode object for signature with missing names',
							'INVALID_ARGUMENT',
							{ argument: 'values', info: { coder: t }, value: r }
						);
						(0, i.vA)(
							!e[a],
							'cannot encode object for signature with duplicate names',
							'INVALID_ARGUMENT',
							{ argument: 'values', info: { coder: t }, value: r }
						);
						e[a] = true;
						return r[a];
					});
				} else {
					(0, i.MR)(false, 'invalid tuple value', 'tuple', r);
				}
				(0, i.MR)(t.length === o.length, 'types/value length mismatch', 'tuple', r);
				let c = new a.AU();
				let u = new a.AU();
				let l = [];
				t.forEach((e, t) => {
					let r = o[t];
					if (e.dynamic) {
						let t = u.length;
						e.encode(u, r);
						let i = c.writeUpdatableValue();
						l.push((e) => {
							i(e + t);
						});
					} else {
						e.encode(c, r);
					}
				});
				l.forEach((e) => {
					e(c.length);
				});
				let d = e.appendWriter(c);
				d += e.appendWriter(u);
				return d;
			}
			function unpack(e, t) {
				let r = [];
				let o = [];
				let c = e.subReader(0);
				t.forEach((t) => {
					let a = null;
					if (t.dynamic) {
						let r = e.readIndex();
						let o = c.subReader(r);
						try {
							a = t.decode(o);
						} catch (e) {
							if ((0, i.bJ)(e, 'BUFFER_OVERRUN')) {
								throw e;
							}
							a = e;
							a.baseType = t.name;
							a.name = t.localName;
							a.type = t.type;
						}
					} else {
						try {
							a = t.decode(e);
						} catch (e) {
							if ((0, i.bJ)(e, 'BUFFER_OVERRUN')) {
								throw e;
							}
							a = e;
							a.baseType = t.name;
							a.name = t.localName;
							a.type = t.type;
						}
					}
					if (a == undefined) {
						throw new Error('investigate');
					}
					r.push(a);
					o.push(t.localName || null);
				});
				return a.Q7.fromItems(r, o);
			}
			class ArrayCoder extends a.Ue {
				coder;
				length;
				constructor(e, t, r) {
					const i = e.type + '[' + (t >= 0 ? t : '') + ']';
					const a = t === -1 || e.dynamic;
					super('array', i, r, a);
					(0, l.n)(this, { coder: e, length: t });
				}
				defaultValue() {
					const e = this.coder.defaultValue();
					const t = [];
					for (let r = 0; r < this.length; r++) {
						t.push(e);
					}
					return t;
				}
				encode(e, t) {
					const r = u.V.dereference(t, 'array');
					if (!Array.isArray(r)) {
						this._throwError('expected array value', r);
					}
					let a = this.length;
					if (a === -1) {
						a = r.length;
						e.writeValue(r.length);
					}
					(0, i.dd)(r.length, a, 'coder array' + (this.localName ? ' ' + this.localName : ''));
					let o = [];
					for (let e = 0; e < r.length; e++) {
						o.push(this.coder);
					}
					return pack(e, o, r);
				}
				decode(e) {
					let t = this.length;
					if (t === -1) {
						t = e.readIndex();
						(0, i.vA)(t * a.Yx <= e.dataLength, 'insufficient data length', 'BUFFER_OVERRUN', {
							buffer: e.bytes,
							offset: t * a.Yx,
							length: e.dataLength
						});
					}
					let r = [];
					for (let e = 0; e < t; e++) {
						r.push(new AnonymousCoder(this.coder));
					}
					return unpack(e, r);
				}
			}
			class BooleanCoder extends a.Ue {
				constructor(e) {
					super('bool', 'bool', e, false);
				}
				defaultValue() {
					return false;
				}
				encode(e, t) {
					const r = u.V.dereference(t, 'bool');
					return e.writeValue(r ? 1 : 0);
				}
				decode(e) {
					return !!e.readValue();
				}
			}
			var d = r(6919);
			class DynamicBytesCoder extends a.Ue {
				constructor(e, t) {
					super(e, e, t, true);
				}
				defaultValue() {
					return '0x';
				}
				encode(e, t) {
					t = (0, d.Lm)(t);
					let r = e.writeValue(t.length);
					r += e.writeBytes(t);
					return r;
				}
				decode(e) {
					return e.readBytes(e.readIndex(), true);
				}
			}
			class BytesCoder extends DynamicBytesCoder {
				constructor(e) {
					super('bytes', e);
				}
				decode(e) {
					return (0, d.c$)(super.decode(e));
				}
			}
			class FixedBytesCoder extends a.Ue {
				size;
				constructor(e, t) {
					let r = 'bytes' + String(e);
					super(r, r, t, false);
					(0, l.n)(this, { size: e }, { size: 'number' });
				}
				defaultValue() {
					return '0x0000000000000000000000000000000000000000000000000000000000000000'.substring(
						0,
						2 + this.size * 2
					);
				}
				encode(e, t) {
					let r = (0, d.Lm)(u.V.dereference(t, this.type));
					if (r.length !== this.size) {
						this._throwError('incorrect data length', t);
					}
					return e.writeBytes(r);
				}
				decode(e) {
					return (0, d.c$)(e.readBytes(this.size));
				}
			}
			const p = new Uint8Array([]);
			class NullCoder extends a.Ue {
				constructor(e) {
					super('null', '', e, false);
				}
				defaultValue() {
					return null;
				}
				encode(e, t) {
					if (t != null) {
						this._throwError('not null', t);
					}
					return e.writeBytes(p);
				}
				decode(e) {
					e.readBytes(0);
					return null;
				}
			}
			const m = BigInt(0);
			const g = BigInt(1);
			const v = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
			class NumberCoder extends a.Ue {
				size;
				signed;
				constructor(e, t, r) {
					const i = (t ? 'int' : 'uint') + e * 8;
					super(i, i, r, false);
					(0, l.n)(this, { size: e, signed: t }, { size: 'number', signed: 'boolean' });
				}
				defaultValue() {
					return 0;
				}
				encode(e, t) {
					let r = (0, c.Ab)(u.V.dereference(t, this.type));
					let i = (0, c.dK)(v, a.Yx * 8);
					if (this.signed) {
						let e = (0, c.dK)(i, this.size * 8 - 1);
						if (r > e || r < -(e + g)) {
							this._throwError('value out-of-bounds', t);
						}
						r = (0, c.JJ)(r, 8 * a.Yx);
					} else if (r < m || r > (0, c.dK)(i, this.size * 8)) {
						this._throwError('value out-of-bounds', t);
					}
					return e.writeValue(r);
				}
				decode(e) {
					let t = (0, c.dK)(e.readValue(), this.size * 8);
					if (this.signed) {
						t = (0, c.ST)(t, this.size * 8);
					}
					return t;
				}
			}
			var y = r(7756);
			class StringCoder extends DynamicBytesCoder {
				constructor(e) {
					super('string', e);
				}
				defaultValue() {
					return '';
				}
				encode(e, t) {
					return super.encode(e, (0, y.YW)(u.V.dereference(t, 'string')));
				}
				decode(e) {
					return (0, y._v)(super.decode(e));
				}
			}
			class TupleCoder extends a.Ue {
				coders;
				constructor(e, t) {
					let r = false;
					const i = [];
					e.forEach((e) => {
						if (e.dynamic) {
							r = true;
						}
						i.push(e.type);
					});
					const a = 'tuple(' + i.join(',') + ')';
					super('tuple', a, t, r);
					(0, l.n)(this, { coders: Object.freeze(e.slice()) });
				}
				defaultValue() {
					const e = [];
					this.coders.forEach((t) => {
						e.push(t.defaultValue());
					});
					const t = this.coders.reduce((e, t) => {
						const r = t.localName;
						if (r) {
							if (!e[r]) {
								e[r] = 0;
							}
							e[r]++;
						}
						return e;
					}, {});
					this.coders.forEach((r, i) => {
						let a = r.localName;
						if (!a || t[a] !== 1) {
							return;
						}
						if (a === 'length') {
							a = '_length';
						}
						if (e[a] != null) {
							return;
						}
						e[a] = e[i];
					});
					return Object.freeze(e);
				}
				encode(e, t) {
					const r = u.V.dereference(t, 'tuple');
					return pack(e, this.coders, r);
				}
				decode(e) {
					return unpack(e, this.coders);
				}
			}
			var w = r(893);
			const _ = new Map();
			_.set(0, 'GENERIC_PANIC');
			_.set(1, 'ASSERT_FALSE');
			_.set(17, 'OVERFLOW');
			_.set(18, 'DIVIDE_BY_ZERO');
			_.set(33, 'ENUM_RANGE_ERROR');
			_.set(34, 'BAD_STORAGE_DATA');
			_.set(49, 'STACK_UNDERFLOW');
			_.set(50, 'ARRAY_RANGE_ERROR');
			_.set(65, 'OUT_OF_MEMORY');
			_.set(81, 'UNINITIALIZED_FUNCTION_CALL');
			const A = new RegExp(/^bytes([0-9]*)$/);
			const k = new RegExp(/^(u?int)([0-9]*)$/);
			let N = null;
			let T = 1024;
			function getBuiltinCallException(e, t, r, a) {
				let c = 'missing revert data';
				let u = null;
				const l = null;
				let p = null;
				if (r) {
					c = 'execution reverted';
					const e = (0, d.q5)(r);
					r = (0, d.c$)(r);
					if (e.length === 0) {
						c += ' (no data present; likely require(false) occurred';
						u = 'require(false)';
					} else if (e.length % 32 !== 4) {
						c += ' (could not decode reason; invalid data length)';
					} else if ((0, d.c$)(e.slice(0, 4)) === '0x08c379a0') {
						try {
							u = a.decode(['string'], e.slice(4))[0];
							p = { signature: 'Error(string)', name: 'Error', args: [u] };
							c += `: ${JSON.stringify(u)}`;
						} catch (e) {
							c += ' (could not decode reason; invalid string data)';
						}
					} else if ((0, d.c$)(e.slice(0, 4)) === '0x4e487b71') {
						try {
							const t = Number(a.decode(['uint256'], e.slice(4))[0]);
							p = { signature: 'Panic(uint256)', name: 'Panic', args: [t] };
							u = `Panic due to ${_.get(t) || 'UNKNOWN'}(${t})`;
							c += `: ${u}`;
						} catch (e) {
							c += ' (could not decode panic code)';
						}
					} else {
						c += ' (unknown custom error)';
					}
				}
				const m = { to: t.to ? (0, o.b)(t.to) : null, data: t.data || '0x' };
				if (t.from) {
					m.from = (0, o.b)(t.from);
				}
				return (0, i.xz)(c, 'CALL_EXCEPTION', {
					action: e,
					data: r,
					reason: u,
					transaction: m,
					invocation: l,
					revert: p
				});
			}
			class AbiCoder {
				#e(e) {
					if (e.isArray()) {
						return new ArrayCoder(this.#e(e.arrayChildren), e.arrayLength, e.name);
					}
					if (e.isTuple()) {
						return new TupleCoder(
							e.components.map((e) => this.#e(e)),
							e.name
						);
					}
					switch (e.baseType) {
						case 'address':
							return new AddressCoder(e.name);
						case 'bool':
							return new BooleanCoder(e.name);
						case 'string':
							return new StringCoder(e.name);
						case 'bytes':
							return new BytesCoder(e.name);
						case '':
							return new NullCoder(e.name);
					}
					let t = e.type.match(k);
					if (t) {
						let r = parseInt(t[2] || '256');
						(0, i.MR)(
							r !== 0 && r <= 256 && r % 8 === 0,
							'invalid ' + t[1] + ' bit length',
							'param',
							e
						);
						return new NumberCoder(r / 8, t[1] === 'int', e.name);
					}
					t = e.type.match(A);
					if (t) {
						let r = parseInt(t[1]);
						(0, i.MR)(r !== 0 && r <= 32, 'invalid bytes length', 'param', e);
						return new FixedBytesCoder(r, e.name);
					}
					(0, i.MR)(false, 'invalid type', 'type', e.type);
				}
				getDefaultValue(e) {
					const t = e.map((e) => this.#e(w.aX.from(e)));
					const r = new TupleCoder(t, '_');
					return r.defaultValue();
				}
				encode(e, t) {
					(0, i.dd)(t.length, e.length, 'types/values length mismatch');
					const r = e.map((e) => this.#e(w.aX.from(e)));
					const o = new TupleCoder(r, '_');
					const c = new a.AU();
					o.encode(c, t);
					return c.data;
				}
				decode(e, t, r) {
					const i = e.map((e) => this.#e(w.aX.from(e)));
					const o = new TupleCoder(i, '_');
					return o.decode(new a.mP(t, r, T));
				}
				static _setDefaultMaxInflation(e) {
					(0, i.MR)(
						typeof e === 'number' && Number.isInteger(e),
						'invalid defaultMaxInflation factor',
						'value',
						e
					);
					T = e;
				}
				static defaultAbiCoder() {
					if (N == null) {
						N = new AbiCoder();
					}
					return N;
				}
				static getBuiltinCallException(e, t, r) {
					return getBuiltinCallException(e, t, r, AbiCoder.defaultAbiCoder());
				}
			}
		},
		9397: (e, t, r) => {
			'use strict';
			r.d(t, {
				AU: () => Writer,
				Q7: () => Result,
				Ue: () => Coder,
				Yx: () => u,
				mP: () => Reader
			});
			var i = r(572);
			var a = r(8492);
			var o = r(6919);
			var c = r(4918);
			const u = 32;
			const l = new Uint8Array(u);
			const d = ['then'];
			const p = {};
			const m = new WeakMap();
			function getNames(e) {
				return m.get(e);
			}
			function setNames(e, t) {
				m.set(e, t);
			}
			function throwError(e, t) {
				const r = new Error(`deferred error during ABI decoding triggered accessing ${e}`);
				r.error = t;
				throw r;
			}
			function toObject(e, t, r) {
				if (e.indexOf(null) >= 0) {
					return t.map((e, t) => {
						if (e instanceof Result) {
							return toObject(getNames(e), e, r);
						}
						return e;
					});
				}
				return e.reduce((e, i, a) => {
					let o = t.getValue(i);
					if (!(i in e)) {
						if (r && o instanceof Result) {
							o = toObject(getNames(o), o, r);
						}
						e[i] = o;
					}
					return e;
				}, {});
			}
			class Result extends Array {
				#t;
				constructor(...e) {
					const t = e[0];
					let r = e[1];
					let a = (e[2] || []).slice();
					let o = true;
					if (t !== p) {
						r = e;
						a = [];
						o = false;
					}
					super(r.length);
					r.forEach((e, t) => {
						this[t] = e;
					});
					const c = a.reduce((e, t) => {
						if (typeof t === 'string') {
							e.set(t, (e.get(t) || 0) + 1);
						}
						return e;
					}, new Map());
					setNames(
						this,
						Object.freeze(
							r.map((e, t) => {
								const r = a[t];
								if (r != null && c.get(r) === 1) {
									return r;
								}
								return null;
							})
						)
					);
					this.#t = [];
					if (this.#t == null) {
						void this.#t;
					}
					if (!o) {
						return;
					}
					Object.freeze(this);
					const u = new Proxy(this, {
						get: (e, t, r) => {
							if (typeof t === 'string') {
								if (t.match(/^[0-9]+$/)) {
									const r = (0, i.WZ)(t, '%index');
									if (r < 0 || r >= this.length) {
										throw new RangeError('out of result range');
									}
									const a = e[r];
									if (a instanceof Error) {
										throwError(`index ${r}`, a);
									}
									return a;
								}
								if (d.indexOf(t) >= 0) {
									return Reflect.get(e, t, r);
								}
								const a = e[t];
								if (a instanceof Function) {
									return function (...t) {
										return a.apply(this === r ? e : this, t);
									};
								} else if (!(t in e)) {
									return e.getValue.apply(this === r ? e : this, [t]);
								}
							}
							return Reflect.get(e, t, r);
						}
					});
					setNames(u, getNames(this));
					return u;
				}
				toArray(e) {
					const t = [];
					this.forEach((r, i) => {
						if (r instanceof Error) {
							throwError(`index ${i}`, r);
						}
						if (e && r instanceof Result) {
							r = r.toArray(e);
						}
						t.push(r);
					});
					return t;
				}
				toObject(e) {
					const t = getNames(this);
					return t.reduce((r, i, o) => {
						(0, a.vA)(i != null, `value at index ${o} unnamed`, 'UNSUPPORTED_OPERATION', {
							operation: 'toObject()'
						});
						return toObject(t, this, e);
					}, {});
				}
				slice(e, t) {
					if (e == null) {
						e = 0;
					}
					if (e < 0) {
						e += this.length;
						if (e < 0) {
							e = 0;
						}
					}
					if (t == null) {
						t = this.length;
					}
					if (t < 0) {
						t += this.length;
						if (t < 0) {
							t = 0;
						}
					}
					if (t > this.length) {
						t = this.length;
					}
					const r = getNames(this);
					const i = [],
						a = [];
					for (let o = e; o < t; o++) {
						i.push(this[o]);
						a.push(r[o]);
					}
					return new Result(p, i, a);
				}
				filter(e, t) {
					const r = getNames(this);
					const i = [],
						a = [];
					for (let o = 0; o < this.length; o++) {
						const c = this[o];
						if (c instanceof Error) {
							throwError(`index ${o}`, c);
						}
						if (e.call(t, c, o, this)) {
							i.push(c);
							a.push(r[o]);
						}
					}
					return new Result(p, i, a);
				}
				map(e, t) {
					const r = [];
					for (let i = 0; i < this.length; i++) {
						const a = this[i];
						if (a instanceof Error) {
							throwError(`index ${i}`, a);
						}
						r.push(e.call(t, a, i, this));
					}
					return r;
				}
				getValue(e) {
					const t = getNames(this).indexOf(e);
					if (t === -1) {
						return undefined;
					}
					const r = this[t];
					if (r instanceof Error) {
						throwError(`property ${JSON.stringify(e)}`, r.error);
					}
					return r;
				}
				static fromItems(e, t) {
					return new Result(p, e, t);
				}
			}
			function checkResultErrors(e) {
				const t = [];
				const checkErrors = function (e, r) {
					if (!Array.isArray(r)) {
						return;
					}
					for (let i in r) {
						const a = e.slice();
						a.push(i);
						try {
							checkErrors(a, r[i]);
						} catch (e) {
							t.push({ path: a, error: e });
						}
					}
				};
				checkErrors([], e);
				return t;
			}
			function getValue(e) {
				let t = (0, i.c4)(e);
				(0, a.vA)(t.length <= u, 'value out-of-bounds', 'BUFFER_OVERRUN', {
					buffer: t,
					length: u,
					offset: t.length
				});
				if (t.length !== u) {
					t = (0, o.Lm)((0, o.xW)([l.slice(t.length % u), t]));
				}
				return t;
			}
			class Coder {
				name;
				type;
				localName;
				dynamic;
				constructor(e, t, r, i) {
					(0, c.n)(
						this,
						{ name: e, type: t, localName: r, dynamic: i },
						{ name: 'string', type: 'string', localName: 'string', dynamic: 'boolean' }
					);
				}
				_throwError(e, t) {
					(0, a.MR)(false, e, this.localName, t);
				}
			}
			class Writer {
				#r;
				#n;
				constructor() {
					this.#r = [];
					this.#n = 0;
				}
				get data() {
					return (0, o.xW)(this.#r);
				}
				get length() {
					return this.#n;
				}
				#i(e) {
					this.#r.push(e);
					this.#n += e.length;
					return e.length;
				}
				appendWriter(e) {
					return this.#i((0, o.Lm)(e.data));
				}
				writeBytes(e) {
					let t = (0, o.Lm)(e);
					const r = t.length % u;
					if (r) {
						t = (0, o.Lm)((0, o.xW)([t, l.slice(r)]));
					}
					return this.#i(t);
				}
				writeValue(e) {
					return this.#i(getValue(e));
				}
				writeUpdatableValue() {
					const e = this.#r.length;
					this.#r.push(l);
					this.#n += u;
					return (t) => {
						this.#r[e] = getValue(t);
					};
				}
			}
			class Reader {
				allowLoose;
				#r;
				#s;
				#a;
				#o;
				#c;
				constructor(e, t, r) {
					(0, c.n)(this, { allowLoose: !!t });
					this.#r = (0, o.Lm)(e);
					this.#a = 0;
					this.#o = null;
					this.#c = r != null ? r : 1024;
					this.#s = 0;
				}
				get data() {
					return (0, o.c$)(this.#r);
				}
				get dataLength() {
					return this.#r.length;
				}
				get consumed() {
					return this.#s;
				}
				get bytes() {
					return new Uint8Array(this.#r);
				}
				#f(e) {
					if (this.#o) {
						return this.#o.#f(e);
					}
					this.#a += e;
					(0, a.vA)(
						this.#c < 1 || this.#a <= this.#c * this.dataLength,
						`compressed ABI data exceeds inflation ratio of ${this.#c} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`,
						'BUFFER_OVERRUN',
						{
							buffer: (0, o.Lm)(this.#r),
							offset: this.#s,
							length: e,
							info: { bytesRead: this.#a, dataLength: this.dataLength }
						}
					);
				}
				#u(e, t, r) {
					let i = Math.ceil(t / u) * u;
					if (this.#s + i > this.#r.length) {
						if (this.allowLoose && r && this.#s + t <= this.#r.length) {
							i = t;
						} else {
							(0, a.vA)(false, 'data out-of-bounds', 'BUFFER_OVERRUN', {
								buffer: (0, o.Lm)(this.#r),
								length: this.#r.length,
								offset: this.#s + i
							});
						}
					}
					return this.#r.slice(this.#s, this.#s + i);
				}
				subReader(e) {
					const t = new Reader(this.#r.slice(this.#s + e), this.allowLoose, this.#c);
					t.#o = this;
					return t;
				}
				readBytes(e, t) {
					let r = this.#u(0, e, !!t);
					this.#f(e);
					this.#s += r.length;
					return r.slice(0, e);
				}
				readValue() {
					return (0, i.Dg)(this.readBytes(u));
				}
				readIndex() {
					return (0, i.Ro)(this.readBytes(u));
				}
			}
		},
		893: (e, t, r) => {
			'use strict';
			r.d(t, {
				FK: () => Fragment,
				Pw: () => ConstructorFragment,
				Zp: () => EventFragment,
				aX: () => ParamType,
				bp: () => ErrorFragment,
				hc: () => FunctionFragment
			});
			var i = r(572);
			var a = r(8492);
			var o = r(4918);
			var c = r(8425);
			function setify(e) {
				const t = new Set();
				e.forEach((e) => t.add(e));
				return Object.freeze(t);
			}
			const u = 'external public payable override';
			const l = setify(u.split(' '));
			const d = 'constant external internal payable private public pure view override';
			const p = setify(d.split(' '));
			const m = 'constructor error event fallback function receive struct';
			const g = setify(m.split(' '));
			const v = 'calldata memory storage payable indexed';
			const y = setify(v.split(' '));
			const w = 'tuple returns';
			const _ = [m, v, w, d].join(' ');
			const A = setify(_.split(' '));
			const k = {
				'(': 'OPEN_PAREN',
				')': 'CLOSE_PAREN',
				'[': 'OPEN_BRACKET',
				']': 'CLOSE_BRACKET',
				',': 'COMMA',
				'@': 'AT'
			};
			const N = new RegExp('^(\\s*)');
			const T = new RegExp('^([0-9]+)');
			const x = new RegExp('^([a-zA-Z$_][a-zA-Z0-9$_]*)');
			const B = new RegExp('^([a-zA-Z$_][a-zA-Z0-9$_]*)$');
			const P = new RegExp('^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$');
			class TokenString {
				#s;
				#l;
				get offset() {
					return this.#s;
				}
				get length() {
					return this.#l.length - this.#s;
				}
				constructor(e) {
					this.#s = 0;
					this.#l = e.slice();
				}
				clone() {
					return new TokenString(this.#l);
				}
				reset() {
					this.#s = 0;
				}
				#d(e = 0, t = 0) {
					return new TokenString(
						this.#l.slice(e, t).map((t) =>
							Object.freeze(
								Object.assign({}, t, {
									match: t.match - e,
									linkBack: t.linkBack - e,
									linkNext: t.linkNext - e
								})
							)
						)
					);
				}
				popKeyword(e) {
					const t = this.peek();
					if (t.type !== 'KEYWORD' || !e.has(t.text)) {
						throw new Error(`expected keyword ${t.text}`);
					}
					return this.pop().text;
				}
				popType(e) {
					if (this.peek().type !== e) {
						const t = this.peek();
						throw new Error(`expected ${e}; got ${t.type} ${JSON.stringify(t.text)}`);
					}
					return this.pop().text;
				}
				popParen() {
					const e = this.peek();
					if (e.type !== 'OPEN_PAREN') {
						throw new Error('bad start');
					}
					const t = this.#d(this.#s + 1, e.match + 1);
					this.#s = e.match + 1;
					return t;
				}
				popParams() {
					const e = this.peek();
					if (e.type !== 'OPEN_PAREN') {
						throw new Error('bad start');
					}
					const t = [];
					while (this.#s < e.match - 1) {
						const e = this.peek().linkNext;
						t.push(this.#d(this.#s + 1, e));
						this.#s = e;
					}
					this.#s = e.match + 1;
					return t;
				}
				peek() {
					if (this.#s >= this.#l.length) {
						throw new Error('out-of-bounds');
					}
					return this.#l[this.#s];
				}
				peekKeyword(e) {
					const t = this.peekType('KEYWORD');
					return t != null && e.has(t) ? t : null;
				}
				peekType(e) {
					if (this.length === 0) {
						return null;
					}
					const t = this.peek();
					return t.type === e ? t.text : null;
				}
				pop() {
					const e = this.peek();
					this.#s++;
					return e;
				}
				toString() {
					const e = [];
					for (let t = this.#s; t < this.#l.length; t++) {
						const r = this.#l[t];
						e.push(`${r.type}:${r.text}`);
					}
					return `<TokenString ${e.join(' ')}>`;
				}
			}
			function lex(e) {
				const t = [];
				const throwError = (t) => {
					const r = o < e.length ? JSON.stringify(e[o]) : '$EOI';
					throw new Error(`invalid token ${r} at ${o}: ${t}`);
				};
				let r = [];
				let a = [];
				let o = 0;
				while (o < e.length) {
					let c = e.substring(o);
					let u = c.match(N);
					if (u) {
						o += u[1].length;
						c = e.substring(o);
					}
					const l = {
						depth: r.length,
						linkBack: -1,
						linkNext: -1,
						match: -1,
						type: '',
						text: '',
						offset: o,
						value: -1
					};
					t.push(l);
					let d = k[c[0]] || '';
					if (d) {
						l.type = d;
						l.text = c[0];
						o++;
						if (d === 'OPEN_PAREN') {
							r.push(t.length - 1);
							a.push(t.length - 1);
						} else if (d == 'CLOSE_PAREN') {
							if (r.length === 0) {
								throwError('no matching open bracket');
							}
							l.match = r.pop();
							t[l.match].match = t.length - 1;
							l.depth--;
							l.linkBack = a.pop();
							t[l.linkBack].linkNext = t.length - 1;
						} else if (d === 'COMMA') {
							l.linkBack = a.pop();
							t[l.linkBack].linkNext = t.length - 1;
							a.push(t.length - 1);
						} else if (d === 'OPEN_BRACKET') {
							l.type = 'BRACKET';
						} else if (d === 'CLOSE_BRACKET') {
							let e = t.pop().text;
							if (t.length > 0 && t[t.length - 1].type === 'NUMBER') {
								const r = t.pop().text;
								e = r + e;
								t[t.length - 1].value = (0, i.WZ)(r);
							}
							if (t.length === 0 || t[t.length - 1].type !== 'BRACKET') {
								throw new Error('missing opening bracket');
							}
							t[t.length - 1].text += e;
						}
						continue;
					}
					u = c.match(x);
					if (u) {
						l.text = u[1];
						o += l.text.length;
						if (A.has(l.text)) {
							l.type = 'KEYWORD';
							continue;
						}
						if (l.text.match(P)) {
							l.type = 'TYPE';
							continue;
						}
						l.type = 'ID';
						continue;
					}
					u = c.match(T);
					if (u) {
						l.text = u[1];
						l.type = 'NUMBER';
						o += l.text.length;
						continue;
					}
					throw new Error(`unexpected token ${JSON.stringify(c[0])} at position ${o}`);
				}
				return new TokenString(t.map((e) => Object.freeze(e)));
			}
			function allowSingle(e, t) {
				let r = [];
				for (const i in t.keys()) {
					if (e.has(i)) {
						r.push(i);
					}
				}
				if (r.length > 1) {
					throw new Error(`conflicting types: ${r.join(', ')}`);
				}
			}
			function consumeName(e, t) {
				if (t.peekKeyword(g)) {
					const r = t.pop().text;
					if (r !== e) {
						throw new Error(`expected ${e}, got ${r}`);
					}
				}
				return t.popType('ID');
			}
			function consumeKeywords(e, t) {
				const r = new Set();
				while (true) {
					const i = e.peekType('KEYWORD');
					if (i == null || (t && !t.has(i))) {
						break;
					}
					e.pop();
					if (r.has(i)) {
						throw new Error(`duplicate keywords: ${JSON.stringify(i)}`);
					}
					r.add(i);
				}
				return Object.freeze(r);
			}
			function consumeMutability(e) {
				let t = consumeKeywords(e, p);
				allowSingle(t, setify('constant payable nonpayable'.split(' ')));
				allowSingle(t, setify('pure view payable nonpayable'.split(' ')));
				if (t.has('view')) {
					return 'view';
				}
				if (t.has('pure')) {
					return 'pure';
				}
				if (t.has('payable')) {
					return 'payable';
				}
				if (t.has('nonpayable')) {
					return 'nonpayable';
				}
				if (t.has('constant')) {
					return 'view';
				}
				return 'nonpayable';
			}
			function consumeParams(e, t) {
				return e.popParams().map((e) => ParamType.from(e, t));
			}
			function consumeGas(e) {
				if (e.peekType('AT')) {
					e.pop();
					if (e.peekType('NUMBER')) {
						return (0, i.Ab)(e.pop().text);
					}
					throw new Error('invalid gas');
				}
				return null;
			}
			function consumeEoi(e) {
				if (e.length) {
					throw new Error(`unexpected tokens at offset ${e.offset}: ${e.toString()}`);
				}
			}
			const M = new RegExp(/^(.*)\[([0-9]*)\]$/);
			function verifyBasicType(e) {
				const t = e.match(P);
				(0, a.MR)(t, 'invalid type', 'type', e);
				if (e === 'uint') {
					return 'uint256';
				}
				if (e === 'int') {
					return 'int256';
				}
				if (t[2]) {
					const r = parseInt(t[2]);
					(0, a.MR)(r !== 0 && r <= 32, 'invalid bytes length', 'type', e);
				} else if (t[3]) {
					const r = parseInt(t[3]);
					(0, a.MR)(r !== 0 && r <= 256 && r % 8 === 0, 'invalid numeric width', 'type', e);
				}
				return e;
			}
			const C = {};
			const I = Symbol.for('_ethers_internal');
			const O = '_ParamTypeInternal';
			const F = '_ErrorInternal';
			const D = '_EventInternal';
			const L = '_ConstructorInternal';
			const U = '_FallbackInternal';
			const j = '_FunctionInternal';
			const H = '_StructInternal';
			class ParamType {
				name;
				type;
				baseType;
				indexed;
				components;
				arrayLength;
				arrayChildren;
				constructor(e, t, r, i, c, u, l, d) {
					(0, a.gk)(e, C, 'ParamType');
					Object.defineProperty(this, I, { value: O });
					if (u) {
						u = Object.freeze(u.slice());
					}
					if (i === 'array') {
						if (l == null || d == null) {
							throw new Error('');
						}
					} else if (l != null || d != null) {
						throw new Error('');
					}
					if (i === 'tuple') {
						if (u == null) {
							throw new Error('');
						}
					} else if (u != null) {
						throw new Error('');
					}
					(0, o.n)(this, {
						name: t,
						type: r,
						baseType: i,
						indexed: c,
						components: u,
						arrayLength: l,
						arrayChildren: d
					});
				}
				format(e) {
					if (e == null) {
						e = 'sighash';
					}
					if (e === 'json') {
						const t = this.name || '';
						if (this.isArray()) {
							const e = JSON.parse(this.arrayChildren.format('json'));
							e.name = t;
							e.type += `[${this.arrayLength < 0 ? '' : String(this.arrayLength)}]`;
							return JSON.stringify(e);
						}
						const r = { type: this.baseType === 'tuple' ? 'tuple' : this.type, name: t };
						if (typeof this.indexed === 'boolean') {
							r.indexed = this.indexed;
						}
						if (this.isTuple()) {
							r.components = this.components.map((t) => JSON.parse(t.format(e)));
						}
						return JSON.stringify(r);
					}
					let t = '';
					if (this.isArray()) {
						t += this.arrayChildren.format(e);
						t += `[${this.arrayLength < 0 ? '' : String(this.arrayLength)}]`;
					} else {
						if (this.isTuple()) {
							t +=
								'(' + this.components.map((t) => t.format(e)).join(e === 'full' ? ', ' : ',') + ')';
						} else {
							t += this.type;
						}
					}
					if (e !== 'sighash') {
						if (this.indexed === true) {
							t += ' indexed';
						}
						if (e === 'full' && this.name) {
							t += ' ' + this.name;
						}
					}
					return t;
				}
				isArray() {
					return this.baseType === 'array';
				}
				isTuple() {
					return this.baseType === 'tuple';
				}
				isIndexable() {
					return this.indexed != null;
				}
				walk(e, t) {
					if (this.isArray()) {
						if (!Array.isArray(e)) {
							throw new Error('invalid array value');
						}
						if (this.arrayLength !== -1 && e.length !== this.arrayLength) {
							throw new Error('array is wrong length');
						}
						const r = this;
						return e.map((e) => r.arrayChildren.walk(e, t));
					}
					if (this.isTuple()) {
						if (!Array.isArray(e)) {
							throw new Error('invalid tuple value');
						}
						if (e.length !== this.components.length) {
							throw new Error('array is wrong length');
						}
						const r = this;
						return e.map((e, i) => r.components[i].walk(e, t));
					}
					return t(this.type, e);
				}
				#h(e, t, r, i) {
					if (this.isArray()) {
						if (!Array.isArray(t)) {
							throw new Error('invalid array value');
						}
						if (this.arrayLength !== -1 && t.length !== this.arrayLength) {
							throw new Error('array is wrong length');
						}
						const a = this.arrayChildren;
						const o = t.slice();
						o.forEach((t, i) => {
							a.#h(e, t, r, (e) => {
								o[i] = e;
							});
						});
						i(o);
						return;
					}
					if (this.isTuple()) {
						const a = this.components;
						let o;
						if (Array.isArray(t)) {
							o = t.slice();
						} else {
							if (t == null || typeof t !== 'object') {
								throw new Error('invalid tuple value');
							}
							o = a.map((e) => {
								if (!e.name) {
									throw new Error('cannot use object value with unnamed components');
								}
								if (!(e.name in t)) {
									throw new Error(`missing value for component ${e.name}`);
								}
								return t[e.name];
							});
						}
						if (o.length !== this.components.length) {
							throw new Error('array is wrong length');
						}
						o.forEach((t, i) => {
							a[i].#h(e, t, r, (e) => {
								o[i] = e;
							});
						});
						i(o);
						return;
					}
					const a = r(this.type, t);
					if (a.then) {
						e.push(
							(async function () {
								i(await a);
							})()
						);
					} else {
						i(a);
					}
				}
				async walkAsync(e, t) {
					const r = [];
					const i = [e];
					this.#h(r, e, t, (e) => {
						i[0] = e;
					});
					if (r.length) {
						await Promise.all(r);
					}
					return i[0];
				}
				static from(e, t) {
					if (ParamType.isParamType(e)) {
						return e;
					}
					if (typeof e === 'string') {
						try {
							return ParamType.from(lex(e), t);
						} catch (t) {
							(0, a.MR)(false, 'invalid param type', 'obj', e);
						}
					} else if (e instanceof TokenString) {
						let r = '',
							i = '';
						let a = null;
						if (consumeKeywords(e, setify(['tuple'])).has('tuple') || e.peekType('OPEN_PAREN')) {
							i = 'tuple';
							a = e.popParams().map((e) => ParamType.from(e));
							r = `tuple(${a.map((e) => e.format()).join(',')})`;
						} else {
							r = verifyBasicType(e.popType('TYPE'));
							i = r;
						}
						let o = null;
						let c = null;
						while (e.length && e.peekType('BRACKET')) {
							const t = e.pop();
							o = new ParamType(C, '', r, i, null, a, c, o);
							c = t.value;
							r += t.text;
							i = 'array';
							a = null;
						}
						let u = null;
						const l = consumeKeywords(e, y);
						if (l.has('indexed')) {
							if (!t) {
								throw new Error('');
							}
							u = true;
						}
						const d = e.peekType('ID') ? e.pop().text : '';
						if (e.length) {
							throw new Error('leftover tokens');
						}
						return new ParamType(C, d, r, i, u, a, c, o);
					}
					const r = e.name;
					(0, a.MR)(!r || (typeof r === 'string' && r.match(B)), 'invalid name', 'obj.name', r);
					let i = e.indexed;
					if (i != null) {
						(0, a.MR)(t, 'parameter cannot be indexed', 'obj.indexed', e.indexed);
						i = !!i;
					}
					let o = e.type;
					let c = o.match(M);
					if (c) {
						const t = parseInt(c[2] || '-1');
						const a = ParamType.from({ type: c[1], components: e.components });
						return new ParamType(C, r || '', o, 'array', i, null, t, a);
					}
					if (o === 'tuple' || o.startsWith('tuple(') || o.startsWith('(')) {
						const t = e.components != null ? e.components.map((e) => ParamType.from(e)) : null;
						const a = new ParamType(C, r || '', o, 'tuple', i, t, null, null);
						return a;
					}
					o = verifyBasicType(e.type);
					return new ParamType(C, r || '', o, o, i, null, null, null);
				}
				static isParamType(e) {
					return e && e[I] === O;
				}
			}
			class Fragment {
				type;
				inputs;
				constructor(e, t, r) {
					(0, a.gk)(e, C, 'Fragment');
					r = Object.freeze(r.slice());
					(0, o.n)(this, { type: t, inputs: r });
				}
				static from(e) {
					if (typeof e === 'string') {
						try {
							Fragment.from(JSON.parse(e));
						} catch (e) {}
						return Fragment.from(lex(e));
					}
					if (e instanceof TokenString) {
						const t = e.peekKeyword(g);
						switch (t) {
							case 'constructor':
								return ConstructorFragment.from(e);
							case 'error':
								return ErrorFragment.from(e);
							case 'event':
								return EventFragment.from(e);
							case 'fallback':
							case 'receive':
								return FallbackFragment.from(e);
							case 'function':
								return FunctionFragment.from(e);
							case 'struct':
								return StructFragment.from(e);
						}
					} else if (typeof e === 'object') {
						switch (e.type) {
							case 'constructor':
								return ConstructorFragment.from(e);
							case 'error':
								return ErrorFragment.from(e);
							case 'event':
								return EventFragment.from(e);
							case 'fallback':
							case 'receive':
								return FallbackFragment.from(e);
							case 'function':
								return FunctionFragment.from(e);
							case 'struct':
								return StructFragment.from(e);
						}
						(0, a.vA)(false, `unsupported type: ${e.type}`, 'UNSUPPORTED_OPERATION', {
							operation: 'Fragment.from'
						});
					}
					(0, a.MR)(false, 'unsupported frgament object', 'obj', e);
				}
				static isConstructor(e) {
					return ConstructorFragment.isFragment(e);
				}
				static isError(e) {
					return ErrorFragment.isFragment(e);
				}
				static isEvent(e) {
					return EventFragment.isFragment(e);
				}
				static isFunction(e) {
					return FunctionFragment.isFragment(e);
				}
				static isStruct(e) {
					return StructFragment.isFragment(e);
				}
			}
			class NamedFragment extends Fragment {
				name;
				constructor(e, t, r, i) {
					super(e, t, i);
					(0, a.MR)(typeof r === 'string' && r.match(B), 'invalid identifier', 'name', r);
					i = Object.freeze(i.slice());
					(0, o.n)(this, { name: r });
				}
			}
			function joinParams(e, t) {
				return '(' + t.map((t) => t.format(e)).join(e === 'full' ? ', ' : ',') + ')';
			}
			class ErrorFragment extends NamedFragment {
				constructor(e, t, r) {
					super(e, 'error', t, r);
					Object.defineProperty(this, I, { value: F });
				}
				get selector() {
					return (0, c.id)(this.format('sighash')).substring(0, 10);
				}
				format(e) {
					if (e == null) {
						e = 'sighash';
					}
					if (e === 'json') {
						return JSON.stringify({
							type: 'error',
							name: this.name,
							inputs: this.inputs.map((t) => JSON.parse(t.format(e)))
						});
					}
					const t = [];
					if (e !== 'sighash') {
						t.push('error');
					}
					t.push(this.name + joinParams(e, this.inputs));
					return t.join(' ');
				}
				static from(e) {
					if (ErrorFragment.isFragment(e)) {
						return e;
					}
					if (typeof e === 'string') {
						return ErrorFragment.from(lex(e));
					} else if (e instanceof TokenString) {
						const t = consumeName('error', e);
						const r = consumeParams(e);
						consumeEoi(e);
						return new ErrorFragment(C, t, r);
					}
					return new ErrorFragment(C, e.name, e.inputs ? e.inputs.map(ParamType.from) : []);
				}
				static isFragment(e) {
					return e && e[I] === F;
				}
			}
			class EventFragment extends NamedFragment {
				anonymous;
				constructor(e, t, r, i) {
					super(e, 'event', t, r);
					Object.defineProperty(this, I, { value: D });
					(0, o.n)(this, { anonymous: i });
				}
				get topicHash() {
					return (0, c.id)(this.format('sighash'));
				}
				format(e) {
					if (e == null) {
						e = 'sighash';
					}
					if (e === 'json') {
						return JSON.stringify({
							type: 'event',
							anonymous: this.anonymous,
							name: this.name,
							inputs: this.inputs.map((t) => JSON.parse(t.format(e)))
						});
					}
					const t = [];
					if (e !== 'sighash') {
						t.push('event');
					}
					t.push(this.name + joinParams(e, this.inputs));
					if (e !== 'sighash' && this.anonymous) {
						t.push('anonymous');
					}
					return t.join(' ');
				}
				static getTopicHash(e, t) {
					t = (t || []).map((e) => ParamType.from(e));
					const r = new EventFragment(C, e, t, false);
					return r.topicHash;
				}
				static from(e) {
					if (EventFragment.isFragment(e)) {
						return e;
					}
					if (typeof e === 'string') {
						try {
							return EventFragment.from(lex(e));
						} catch (t) {
							(0, a.MR)(false, 'invalid event fragment', 'obj', e);
						}
					} else if (e instanceof TokenString) {
						const t = consumeName('event', e);
						const r = consumeParams(e, true);
						const i = !!consumeKeywords(e, setify(['anonymous'])).has('anonymous');
						consumeEoi(e);
						return new EventFragment(C, t, r, i);
					}
					return new EventFragment(
						C,
						e.name,
						e.inputs ? e.inputs.map((e) => ParamType.from(e, true)) : [],
						!!e.anonymous
					);
				}
				static isFragment(e) {
					return e && e[I] === D;
				}
			}
			class ConstructorFragment extends Fragment {
				payable;
				gas;
				constructor(e, t, r, i, a) {
					super(e, t, r);
					Object.defineProperty(this, I, { value: L });
					(0, o.n)(this, { payable: i, gas: a });
				}
				format(e) {
					(0, a.vA)(
						e != null && e !== 'sighash',
						'cannot format a constructor for sighash',
						'UNSUPPORTED_OPERATION',
						{ operation: 'format(sighash)' }
					);
					if (e === 'json') {
						return JSON.stringify({
							type: 'constructor',
							stateMutability: this.payable ? 'payable' : 'undefined',
							payable: this.payable,
							gas: this.gas != null ? this.gas : undefined,
							inputs: this.inputs.map((t) => JSON.parse(t.format(e)))
						});
					}
					const t = [`constructor${joinParams(e, this.inputs)}`];
					if (this.payable) {
						t.push('payable');
					}
					if (this.gas != null) {
						t.push(`@${this.gas.toString()}`);
					}
					return t.join(' ');
				}
				static from(e) {
					if (ConstructorFragment.isFragment(e)) {
						return e;
					}
					if (typeof e === 'string') {
						try {
							return ConstructorFragment.from(lex(e));
						} catch (t) {
							(0, a.MR)(false, 'invalid constuctor fragment', 'obj', e);
						}
					} else if (e instanceof TokenString) {
						consumeKeywords(e, setify(['constructor']));
						const t = consumeParams(e);
						const r = !!consumeKeywords(e, l).has('payable');
						const i = consumeGas(e);
						consumeEoi(e);
						return new ConstructorFragment(C, 'constructor', t, r, i);
					}
					return new ConstructorFragment(
						C,
						'constructor',
						e.inputs ? e.inputs.map(ParamType.from) : [],
						!!e.payable,
						e.gas != null ? e.gas : null
					);
				}
				static isFragment(e) {
					return e && e[I] === L;
				}
			}
			class FallbackFragment extends Fragment {
				payable;
				constructor(e, t, r) {
					super(e, 'fallback', t);
					Object.defineProperty(this, I, { value: U });
					(0, o.n)(this, { payable: r });
				}
				format(e) {
					const t = this.inputs.length === 0 ? 'receive' : 'fallback';
					if (e === 'json') {
						const e = this.payable ? 'payable' : 'nonpayable';
						return JSON.stringify({ type: t, stateMutability: e });
					}
					return `${t}()${this.payable ? ' payable' : ''}`;
				}
				static from(e) {
					if (FallbackFragment.isFragment(e)) {
						return e;
					}
					if (typeof e === 'string') {
						try {
							return FallbackFragment.from(lex(e));
						} catch (t) {
							(0, a.MR)(false, 'invalid fallback fragment', 'obj', e);
						}
					} else if (e instanceof TokenString) {
						const t = e.toString();
						const r = e.peekKeyword(setify(['fallback', 'receive']));
						(0, a.MR)(r, 'type must be fallback or receive', 'obj', t);
						const i = e.popKeyword(setify(['fallback', 'receive']));
						if (i === 'receive') {
							const t = consumeParams(e);
							(0, a.MR)(t.length === 0, `receive cannot have arguments`, 'obj.inputs', t);
							consumeKeywords(e, setify(['payable']));
							consumeEoi(e);
							return new FallbackFragment(C, [], true);
						}
						let o = consumeParams(e);
						if (o.length) {
							(0, a.MR)(
								o.length === 1 && o[0].type === 'bytes',
								'invalid fallback inputs',
								'obj.inputs',
								o.map((e) => e.format('minimal')).join(', ')
							);
						} else {
							o = [ParamType.from('bytes')];
						}
						const c = consumeMutability(e);
						(0, a.MR)(
							c === 'nonpayable' || c === 'payable',
							'fallback cannot be constants',
							'obj.stateMutability',
							c
						);
						if (consumeKeywords(e, setify(['returns'])).has('returns')) {
							const t = consumeParams(e);
							(0, a.MR)(
								t.length === 1 && t[0].type === 'bytes',
								'invalid fallback outputs',
								'obj.outputs',
								t.map((e) => e.format('minimal')).join(', ')
							);
						}
						consumeEoi(e);
						return new FallbackFragment(C, o, c === 'payable');
					}
					if (e.type === 'receive') {
						return new FallbackFragment(C, [], true);
					}
					if (e.type === 'fallback') {
						const t = [ParamType.from('bytes')];
						const r = e.stateMutability === 'payable';
						return new FallbackFragment(C, t, r);
					}
					(0, a.MR)(false, 'invalid fallback description', 'obj', e);
				}
				static isFragment(e) {
					return e && e[I] === U;
				}
			}
			class FunctionFragment extends NamedFragment {
				constant;
				outputs;
				stateMutability;
				payable;
				gas;
				constructor(e, t, r, i, a, c) {
					super(e, 'function', t, i);
					Object.defineProperty(this, I, { value: j });
					a = Object.freeze(a.slice());
					const u = r === 'view' || r === 'pure';
					const l = r === 'payable';
					(0, o.n)(this, { constant: u, gas: c, outputs: a, payable: l, stateMutability: r });
				}
				get selector() {
					return (0, c.id)(this.format('sighash')).substring(0, 10);
				}
				format(e) {
					if (e == null) {
						e = 'sighash';
					}
					if (e === 'json') {
						return JSON.stringify({
							type: 'function',
							name: this.name,
							constant: this.constant,
							stateMutability:
								this.stateMutability !== 'nonpayable' ? this.stateMutability : undefined,
							payable: this.payable,
							gas: this.gas != null ? this.gas : undefined,
							inputs: this.inputs.map((t) => JSON.parse(t.format(e))),
							outputs: this.outputs.map((t) => JSON.parse(t.format(e)))
						});
					}
					const t = [];
					if (e !== 'sighash') {
						t.push('function');
					}
					t.push(this.name + joinParams(e, this.inputs));
					if (e !== 'sighash') {
						if (this.stateMutability !== 'nonpayable') {
							t.push(this.stateMutability);
						}
						if (this.outputs && this.outputs.length) {
							t.push('returns');
							t.push(joinParams(e, this.outputs));
						}
						if (this.gas != null) {
							t.push(`@${this.gas.toString()}`);
						}
					}
					return t.join(' ');
				}
				static getSelector(e, t) {
					t = (t || []).map((e) => ParamType.from(e));
					const r = new FunctionFragment(C, e, 'view', t, [], null);
					return r.selector;
				}
				static from(e) {
					if (FunctionFragment.isFragment(e)) {
						return e;
					}
					if (typeof e === 'string') {
						try {
							return FunctionFragment.from(lex(e));
						} catch (t) {
							(0, a.MR)(false, 'invalid function fragment', 'obj', e);
						}
					} else if (e instanceof TokenString) {
						const t = consumeName('function', e);
						const r = consumeParams(e);
						const i = consumeMutability(e);
						let a = [];
						if (consumeKeywords(e, setify(['returns'])).has('returns')) {
							a = consumeParams(e);
						}
						const o = consumeGas(e);
						consumeEoi(e);
						return new FunctionFragment(C, t, i, r, a, o);
					}
					let t = e.stateMutability;
					if (t == null) {
						t = 'payable';
						if (typeof e.constant === 'boolean') {
							t = 'view';
							if (!e.constant) {
								t = 'payable';
								if (typeof e.payable === 'boolean' && !e.payable) {
									t = 'nonpayable';
								}
							}
						} else if (typeof e.payable === 'boolean' && !e.payable) {
							t = 'nonpayable';
						}
					}
					return new FunctionFragment(
						C,
						e.name,
						t,
						e.inputs ? e.inputs.map(ParamType.from) : [],
						e.outputs ? e.outputs.map(ParamType.from) : [],
						e.gas != null ? e.gas : null
					);
				}
				static isFragment(e) {
					return e && e[I] === j;
				}
			}
			class StructFragment extends NamedFragment {
				constructor(e, t, r) {
					super(e, 'struct', t, r);
					Object.defineProperty(this, I, { value: H });
				}
				format() {
					throw new Error('@TODO');
				}
				static from(e) {
					if (typeof e === 'string') {
						try {
							return StructFragment.from(lex(e));
						} catch (t) {
							(0, a.MR)(false, 'invalid struct fragment', 'obj', e);
						}
					} else if (e instanceof TokenString) {
						const t = consumeName('struct', e);
						const r = consumeParams(e);
						consumeEoi(e);
						return new StructFragment(C, t, r);
					}
					return new StructFragment(C, e.name, e.inputs ? e.inputs.map(ParamType.from) : []);
				}
				static isFragment(e) {
					return e && e[I] === H;
				}
			}
		},
		9351: (e, t, r) => {
			'use strict';
			r.d(t, { KA: () => Interface });
			var i = r(822);
			var a = r(8425);
			var o = r(4918);
			var c = r(8492);
			var u = r(6919);
			var l = r(572);
			var d = r(1586);
			var p = r(9397);
			var m = r(893);
			var g = r(4440);
			class LogDescription {
				fragment;
				name;
				signature;
				topic;
				args;
				constructor(e, t, r) {
					const i = e.name,
						a = e.format();
					(0, o.n)(this, { fragment: e, name: i, signature: a, topic: t, args: r });
				}
			}
			class TransactionDescription {
				fragment;
				name;
				args;
				signature;
				selector;
				value;
				constructor(e, t, r, i) {
					const a = e.name,
						c = e.format();
					(0, o.n)(this, { fragment: e, name: a, args: r, signature: c, selector: t, value: i });
				}
			}
			class ErrorDescription {
				fragment;
				name;
				args;
				signature;
				selector;
				constructor(e, t, r) {
					const i = e.name,
						a = e.format();
					(0, o.n)(this, { fragment: e, name: i, args: r, signature: a, selector: t });
				}
			}
			class Indexed {
				hash;
				_isIndexed;
				static isIndexed(e) {
					return !!(e && e._isIndexed);
				}
				constructor(e) {
					(0, o.n)(this, { hash: e, _isIndexed: true });
				}
			}
			const v = {
				0: 'generic panic',
				1: 'assert(false)',
				17: 'arithmetic overflow',
				18: 'division or modulo by zero',
				33: 'enum overflow',
				34: 'invalid encoded storage byte array accessed',
				49: 'out-of-bounds array access; popping on an empty array',
				50: 'out-of-bounds access of an array or bytesN',
				65: 'out of memory',
				81: 'uninitialized function'
			};
			const y = {
				'0x08c379a0': {
					signature: 'Error(string)',
					name: 'Error',
					inputs: ['string'],
					reason: (e) => `reverted with reason string ${JSON.stringify(e)}`
				},
				'0x4e487b71': {
					signature: 'Panic(uint256)',
					name: 'Panic',
					inputs: ['uint256'],
					reason: (e) => {
						let t = 'unknown panic code';
						if (e >= 0 && e <= 255 && v[e.toString()]) {
							t = v[e.toString()];
						}
						return `reverted with panic code 0x${e.toString(16)} (${t})`;
					}
				}
			};
			class Interface {
				fragments;
				deploy;
				fallback;
				receive;
				#p;
				#m;
				#g;
				#v;
				constructor(e) {
					let t = [];
					if (typeof e === 'string') {
						t = JSON.parse(e);
					} else {
						t = e;
					}
					this.#g = new Map();
					this.#p = new Map();
					this.#m = new Map();
					const r = [];
					for (const e of t) {
						try {
							r.push(m.FK.from(e));
						} catch (t) {
							console.log(`[Warning] Invalid Fragment ${JSON.stringify(e)}:`, t.message);
						}
					}
					(0, o.n)(this, { fragments: Object.freeze(r) });
					let i = null;
					let a = false;
					this.#v = this.getAbiCoder();
					this.fragments.forEach((e, t) => {
						let r;
						switch (e.type) {
							case 'constructor':
								if (this.deploy) {
									console.log('duplicate definition - constructor');
									return;
								}
								(0, o.n)(this, { deploy: e });
								return;
							case 'fallback':
								if (e.inputs.length === 0) {
									a = true;
								} else {
									(0, c.MR)(
										!i || e.payable !== i.payable,
										'conflicting fallback fragments',
										`fragments[${t}]`,
										e
									);
									i = e;
									a = i.payable;
								}
								return;
							case 'function':
								r = this.#g;
								break;
							case 'event':
								r = this.#m;
								break;
							case 'error':
								r = this.#p;
								break;
							default:
								return;
						}
						const u = e.format();
						if (r.has(u)) {
							return;
						}
						r.set(u, e);
					});
					if (!this.deploy) {
						(0, o.n)(this, { deploy: m.Pw.from('constructor()') });
					}
					(0, o.n)(this, { fallback: i, receive: a });
				}
				format(e) {
					const t = e ? 'minimal' : 'full';
					const r = this.fragments.map((e) => e.format(t));
					return r;
				}
				formatJson() {
					const e = this.fragments.map((e) => e.format('json'));
					return JSON.stringify(e.map((e) => JSON.parse(e)));
				}
				getAbiCoder() {
					return d.y.defaultAbiCoder();
				}
				#y(e, t, r) {
					if ((0, u.Lo)(e)) {
						const t = e.toLowerCase();
						for (const e of this.#g.values()) {
							if (t === e.selector) {
								return e;
							}
						}
						return null;
					}
					if (e.indexOf('(') === -1) {
						const i = [];
						for (const [t, r] of this.#g) {
							if (t.split('(')[0] === e) {
								i.push(r);
							}
						}
						if (t) {
							const e = t.length > 0 ? t[t.length - 1] : null;
							let r = t.length;
							let a = true;
							if (g.V.isTyped(e) && e.type === 'overrides') {
								a = false;
								r--;
							}
							for (let e = i.length - 1; e >= 0; e--) {
								const t = i[e].inputs.length;
								if (t !== r && (!a || t !== r - 1)) {
									i.splice(e, 1);
								}
							}
							for (let e = i.length - 1; e >= 0; e--) {
								const r = i[e].inputs;
								for (let a = 0; a < t.length; a++) {
									if (!g.V.isTyped(t[a])) {
										continue;
									}
									if (a >= r.length) {
										if (t[a].type === 'overrides') {
											continue;
										}
										i.splice(e, 1);
										break;
									}
									if (t[a].type !== r[a].baseType) {
										i.splice(e, 1);
										break;
									}
								}
							}
						}
						if (i.length === 1 && t && t.length !== i[0].inputs.length) {
							const e = t[t.length - 1];
							if (e == null || Array.isArray(e) || typeof e !== 'object') {
								i.splice(0, 1);
							}
						}
						if (i.length === 0) {
							return null;
						}
						if (i.length > 1 && r) {
							const t = i.map((e) => JSON.stringify(e.format())).join(', ');
							(0, c.MR)(false, `ambiguous function description (i.e. matches ${t})`, 'key', e);
						}
						return i[0];
					}
					const i = this.#g.get(m.hc.from(e).format());
					if (i) {
						return i;
					}
					return null;
				}
				getFunctionName(e) {
					const t = this.#y(e, null, false);
					(0, c.MR)(t, 'no matching function', 'key', e);
					return t.name;
				}
				hasFunction(e) {
					return !!this.#y(e, null, false);
				}
				getFunction(e, t) {
					return this.#y(e, t || null, true);
				}
				forEachFunction(e) {
					const t = Array.from(this.#g.keys());
					t.sort((e, t) => e.localeCompare(t));
					for (let r = 0; r < t.length; r++) {
						const i = t[r];
						e(this.#g.get(i), r);
					}
				}
				#b(e, t, r) {
					if ((0, u.Lo)(e)) {
						const t = e.toLowerCase();
						for (const e of this.#m.values()) {
							if (t === e.topicHash) {
								return e;
							}
						}
						return null;
					}
					if (e.indexOf('(') === -1) {
						const i = [];
						for (const [t, r] of this.#m) {
							if (t.split('(')[0] === e) {
								i.push(r);
							}
						}
						if (t) {
							for (let e = i.length - 1; e >= 0; e--) {
								if (i[e].inputs.length < t.length) {
									i.splice(e, 1);
								}
							}
							for (let e = i.length - 1; e >= 0; e--) {
								const r = i[e].inputs;
								for (let a = 0; a < t.length; a++) {
									if (!g.V.isTyped(t[a])) {
										continue;
									}
									if (t[a].type !== r[a].baseType) {
										i.splice(e, 1);
										break;
									}
								}
							}
						}
						if (i.length === 0) {
							return null;
						}
						if (i.length > 1 && r) {
							const t = i.map((e) => JSON.stringify(e.format())).join(', ');
							(0, c.MR)(false, `ambiguous event description (i.e. matches ${t})`, 'key', e);
						}
						return i[0];
					}
					const i = this.#m.get(m.Zp.from(e).format());
					if (i) {
						return i;
					}
					return null;
				}
				getEventName(e) {
					const t = this.#b(e, null, false);
					(0, c.MR)(t, 'no matching event', 'key', e);
					return t.name;
				}
				hasEvent(e) {
					return !!this.#b(e, null, false);
				}
				getEvent(e, t) {
					return this.#b(e, t || null, true);
				}
				forEachEvent(e) {
					const t = Array.from(this.#m.keys());
					t.sort((e, t) => e.localeCompare(t));
					for (let r = 0; r < t.length; r++) {
						const i = t[r];
						e(this.#m.get(i), r);
					}
				}
				getError(e, t) {
					if ((0, u.Lo)(e)) {
						const t = e.toLowerCase();
						if (y[t]) {
							return m.bp.from(y[t].signature);
						}
						for (const e of this.#p.values()) {
							if (t === e.selector) {
								return e;
							}
						}
						return null;
					}
					if (e.indexOf('(') === -1) {
						const t = [];
						for (const [r, i] of this.#p) {
							if (r.split('(')[0] === e) {
								t.push(i);
							}
						}
						if (t.length === 0) {
							if (e === 'Error') {
								return m.bp.from('error Error(string)');
							}
							if (e === 'Panic') {
								return m.bp.from('error Panic(uint256)');
							}
							return null;
						} else if (t.length > 1) {
							const r = t.map((e) => JSON.stringify(e.format())).join(', ');
							(0, c.MR)(false, `ambiguous error description (i.e. ${r})`, 'name', e);
						}
						return t[0];
					}
					e = m.bp.from(e).format();
					if (e === 'Error(string)') {
						return m.bp.from('error Error(string)');
					}
					if (e === 'Panic(uint256)') {
						return m.bp.from('error Panic(uint256)');
					}
					const r = this.#p.get(e);
					if (r) {
						return r;
					}
					return null;
				}
				forEachError(e) {
					const t = Array.from(this.#p.keys());
					t.sort((e, t) => e.localeCompare(t));
					for (let r = 0; r < t.length; r++) {
						const i = t[r];
						e(this.#p.get(i), r);
					}
				}
				_decodeParams(e, t) {
					return this.#v.decode(e, t);
				}
				_encodeParams(e, t) {
					return this.#v.encode(e, t);
				}
				encodeDeploy(e) {
					return this._encodeParams(this.deploy.inputs, e || []);
				}
				decodeErrorResult(e, t) {
					if (typeof e === 'string') {
						const t = this.getError(e);
						(0, c.MR)(t, 'unknown error', 'fragment', e);
						e = t;
					}
					(0, c.MR)(
						(0, u.ZG)(t, 0, 4) === e.selector,
						`data signature does not match error ${e.name}.`,
						'data',
						t
					);
					return this._decodeParams(e.inputs, (0, u.ZG)(t, 4));
				}
				encodeErrorResult(e, t) {
					if (typeof e === 'string') {
						const t = this.getError(e);
						(0, c.MR)(t, 'unknown error', 'fragment', e);
						e = t;
					}
					return (0, u.xW)([e.selector, this._encodeParams(e.inputs, t || [])]);
				}
				decodeFunctionData(e, t) {
					if (typeof e === 'string') {
						const t = this.getFunction(e);
						(0, c.MR)(t, 'unknown function', 'fragment', e);
						e = t;
					}
					(0, c.MR)(
						(0, u.ZG)(t, 0, 4) === e.selector,
						`data signature does not match function ${e.name}.`,
						'data',
						t
					);
					return this._decodeParams(e.inputs, (0, u.ZG)(t, 4));
				}
				encodeFunctionData(e, t) {
					if (typeof e === 'string') {
						const t = this.getFunction(e);
						(0, c.MR)(t, 'unknown function', 'fragment', e);
						e = t;
					}
					return (0, u.xW)([e.selector, this._encodeParams(e.inputs, t || [])]);
				}
				decodeFunctionResult(e, t) {
					if (typeof e === 'string') {
						const t = this.getFunction(e);
						(0, c.MR)(t, 'unknown function', 'fragment', e);
						e = t;
					}
					let r = 'invalid length for result data';
					const i = (0, u.Lm)(t);
					if (i.length % 32 === 0) {
						try {
							return this.#v.decode(e.outputs, i);
						} catch (e) {
							r = 'could not decode result data';
						}
					}
					(0, c.vA)(false, r, 'BAD_DATA', {
						value: (0, u.c$)(i),
						info: { method: e.name, signature: e.format() }
					});
				}
				makeError(e, t) {
					const r = (0, u.q5)(e, 'data');
					const i = d.y.getBuiltinCallException('call', t, r);
					const a = 'execution reverted (unknown custom error)';
					if (i.message.startsWith(a)) {
						const e = (0, u.c$)(r.slice(0, 4));
						const t = this.getError(e);
						if (t) {
							try {
								const e = this.#v.decode(t.inputs, r.slice(4));
								i.revert = { name: t.name, signature: t.format(), args: e };
								i.reason = i.revert.signature;
								i.message = `execution reverted: ${i.reason}`;
							} catch (e) {
								i.message = `execution reverted (coult not decode custom error)`;
							}
						}
					}
					const o = this.parseTransaction(t);
					if (o) {
						i.invocation = { method: o.name, signature: o.signature, args: o.args };
					}
					return i;
				}
				encodeFunctionResult(e, t) {
					if (typeof e === 'string') {
						const t = this.getFunction(e);
						(0, c.MR)(t, 'unknown function', 'fragment', e);
						e = t;
					}
					return (0, u.c$)(this.#v.encode(e.outputs, t || []));
				}
				encodeFilterTopics(e, t) {
					if (typeof e === 'string') {
						const t = this.getEvent(e);
						(0, c.MR)(t, 'unknown event', 'eventFragment', e);
						e = t;
					}
					(0, c.vA)(
						t.length <= e.inputs.length,
						`too many arguments for ${e.format()}`,
						'UNEXPECTED_ARGUMENT',
						{ count: t.length, expectedCount: e.inputs.length }
					);
					const r = [];
					if (!e.anonymous) {
						r.push(e.topicHash);
					}
					const encodeTopic = (e, t) => {
						if (e.type === 'string') {
							return (0, a.id)(t);
						} else if (e.type === 'bytes') {
							return (0, i.S)((0, u.c$)(t));
						}
						if (e.type === 'bool' && typeof t === 'boolean') {
							t = t ? '0x01' : '0x00';
						} else if (e.type.match(/^u?int/)) {
							t = (0, l.up)(t);
						} else if (e.type.match(/^bytes/)) {
							t = (0, u.X_)(t, 32);
						} else if (e.type === 'address') {
							this.#v.encode(['address'], [t]);
						}
						return (0, u.nx)((0, u.c$)(t), 32);
					};
					t.forEach((t, i) => {
						const a = e.inputs[i];
						if (!a.indexed) {
							(0, c.MR)(
								t == null,
								'cannot filter non-indexed parameters; must be null',
								'contract.' + a.name,
								t
							);
							return;
						}
						if (t == null) {
							r.push(null);
						} else if (a.baseType === 'array' || a.baseType === 'tuple') {
							(0, c.MR)(
								false,
								'filtering with tuples or arrays not supported',
								'contract.' + a.name,
								t
							);
						} else if (Array.isArray(t)) {
							r.push(t.map((e) => encodeTopic(a, e)));
						} else {
							r.push(encodeTopic(a, t));
						}
					});
					while (r.length && r[r.length - 1] === null) {
						r.pop();
					}
					return r;
				}
				encodeEventLog(e, t) {
					if (typeof e === 'string') {
						const t = this.getEvent(e);
						(0, c.MR)(t, 'unknown event', 'eventFragment', e);
						e = t;
					}
					const r = [];
					const o = [];
					const u = [];
					if (!e.anonymous) {
						r.push(e.topicHash);
					}
					(0, c.MR)(t.length === e.inputs.length, 'event arguments/values mismatch', 'values', t);
					e.inputs.forEach((e, c) => {
						const l = t[c];
						if (e.indexed) {
							if (e.type === 'string') {
								r.push((0, a.id)(l));
							} else if (e.type === 'bytes') {
								r.push((0, i.S)(l));
							} else if (e.baseType === 'tuple' || e.baseType === 'array') {
								throw new Error('not implemented');
							} else {
								r.push(this.#v.encode([e.type], [l]));
							}
						} else {
							o.push(e);
							u.push(l);
						}
					});
					return { data: this.#v.encode(o, u), topics: r };
				}
				decodeEventLog(e, t, r) {
					if (typeof e === 'string') {
						const t = this.getEvent(e);
						(0, c.MR)(t, 'unknown event', 'eventFragment', e);
						e = t;
					}
					if (r != null && !e.anonymous) {
						const t = e.topicHash;
						(0, c.MR)(
							(0, u.Lo)(r[0], 32) && r[0].toLowerCase() === t,
							'fragment/topic mismatch',
							'topics[0]',
							r[0]
						);
						r = r.slice(1);
					}
					const i = [];
					const a = [];
					const o = [];
					e.inputs.forEach((e, t) => {
						if (e.indexed) {
							if (
								e.type === 'string' ||
								e.type === 'bytes' ||
								e.baseType === 'tuple' ||
								e.baseType === 'array'
							) {
								i.push(m.aX.from({ type: 'bytes32', name: e.name }));
								o.push(true);
							} else {
								i.push(e);
								o.push(false);
							}
						} else {
							a.push(e);
							o.push(false);
						}
					});
					const l = r != null ? this.#v.decode(i, (0, u.xW)(r)) : null;
					const d = this.#v.decode(a, t, true);
					const g = [];
					const v = [];
					let y = 0,
						w = 0;
					e.inputs.forEach((e, t) => {
						let r = null;
						if (e.indexed) {
							if (l == null) {
								r = new Indexed(null);
							} else if (o[t]) {
								r = new Indexed(l[w++]);
							} else {
								try {
									r = l[w++];
								} catch (e) {
									r = e;
								}
							}
						} else {
							try {
								r = d[y++];
							} catch (e) {
								r = e;
							}
						}
						g.push(r);
						v.push(e.name || null);
					});
					return p.Q7.fromItems(g, v);
				}
				parseTransaction(e) {
					const t = (0, u.q5)(e.data, 'tx.data');
					const r = (0, l.Ab)(e.value != null ? e.value : 0, 'tx.value');
					const i = this.getFunction((0, u.c$)(t.slice(0, 4)));
					if (!i) {
						return null;
					}
					const a = this.#v.decode(i.inputs, t.slice(4));
					return new TransactionDescription(i, i.selector, a, r);
				}
				parseCallResult(e) {
					throw new Error('@TODO');
				}
				parseLog(e) {
					const t = this.getEvent(e.topics[0]);
					if (!t || t.anonymous) {
						return null;
					}
					return new LogDescription(t, t.topicHash, this.decodeEventLog(t, e.data, e.topics));
				}
				parseError(e) {
					const t = (0, u.c$)(e);
					const r = this.getError((0, u.ZG)(t, 0, 4));
					if (!r) {
						return null;
					}
					const i = this.#v.decode(r.inputs, (0, u.ZG)(t, 4));
					return new ErrorDescription(r, r.selector, i);
				}
				static from(e) {
					if (e instanceof Interface) {
						return e;
					}
					if (typeof e === 'string') {
						return new Interface(JSON.parse(e));
					}
					if (typeof e.formatJson === 'function') {
						return new Interface(e.formatJson());
					}
					if (typeof e.format === 'function') {
						return new Interface(e.format('json'));
					}
					return new Interface(e);
				}
			}
		},
		4440: (e, t, r) => {
			'use strict';
			r.d(t, { V: () => Typed });
			var i = r(8492);
			var a = r(4918);
			const o = {};
			function n(e, t) {
				let r = false;
				if (t < 0) {
					r = true;
					t *= -1;
				}
				return new Typed(o, `${r ? '' : 'u'}int${t}`, e, { signed: r, width: t });
			}
			function b(e, t) {
				return new Typed(o, `bytes${t ? t : ''}`, e, { size: t });
			}
			const c = Symbol.for('_ethers_typed');
			class Typed {
				type;
				value;
				#w;
				_typedSymbol;
				constructor(e, t, r, u) {
					if (u == null) {
						u = null;
					}
					(0, i.gk)(o, e, 'Typed');
					(0, a.n)(this, { _typedSymbol: c, type: t, value: r });
					this.#w = u;
					this.format();
				}
				format() {
					if (this.type === 'array') {
						throw new Error('');
					} else if (this.type === 'dynamicArray') {
						throw new Error('');
					} else if (this.type === 'tuple') {
						return `tuple(${this.value.map((e) => e.format()).join(',')})`;
					}
					return this.type;
				}
				defaultValue() {
					return 0;
				}
				minValue() {
					return 0;
				}
				maxValue() {
					return 0;
				}
				isBigInt() {
					return !!this.type.match(/^u?int[0-9]+$/);
				}
				isData() {
					return this.type.startsWith('bytes');
				}
				isString() {
					return this.type === 'string';
				}
				get tupleName() {
					if (this.type !== 'tuple') {
						throw TypeError('not a tuple');
					}
					return this.#w;
				}
				get arrayLength() {
					if (this.type !== 'array') {
						throw TypeError('not an array');
					}
					if (this.#w === true) {
						return -1;
					}
					if (this.#w === false) {
						return this.value.length;
					}
					return null;
				}
				static from(e, t) {
					return new Typed(o, e, t);
				}
				static uint8(e) {
					return n(e, 8);
				}
				static uint16(e) {
					return n(e, 16);
				}
				static uint24(e) {
					return n(e, 24);
				}
				static uint32(e) {
					return n(e, 32);
				}
				static uint40(e) {
					return n(e, 40);
				}
				static uint48(e) {
					return n(e, 48);
				}
				static uint56(e) {
					return n(e, 56);
				}
				static uint64(e) {
					return n(e, 64);
				}
				static uint72(e) {
					return n(e, 72);
				}
				static uint80(e) {
					return n(e, 80);
				}
				static uint88(e) {
					return n(e, 88);
				}
				static uint96(e) {
					return n(e, 96);
				}
				static uint104(e) {
					return n(e, 104);
				}
				static uint112(e) {
					return n(e, 112);
				}
				static uint120(e) {
					return n(e, 120);
				}
				static uint128(e) {
					return n(e, 128);
				}
				static uint136(e) {
					return n(e, 136);
				}
				static uint144(e) {
					return n(e, 144);
				}
				static uint152(e) {
					return n(e, 152);
				}
				static uint160(e) {
					return n(e, 160);
				}
				static uint168(e) {
					return n(e, 168);
				}
				static uint176(e) {
					return n(e, 176);
				}
				static uint184(e) {
					return n(e, 184);
				}
				static uint192(e) {
					return n(e, 192);
				}
				static uint200(e) {
					return n(e, 200);
				}
				static uint208(e) {
					return n(e, 208);
				}
				static uint216(e) {
					return n(e, 216);
				}
				static uint224(e) {
					return n(e, 224);
				}
				static uint232(e) {
					return n(e, 232);
				}
				static uint240(e) {
					return n(e, 240);
				}
				static uint248(e) {
					return n(e, 248);
				}
				static uint256(e) {
					return n(e, 256);
				}
				static uint(e) {
					return n(e, 256);
				}
				static int8(e) {
					return n(e, -8);
				}
				static int16(e) {
					return n(e, -16);
				}
				static int24(e) {
					return n(e, -24);
				}
				static int32(e) {
					return n(e, -32);
				}
				static int40(e) {
					return n(e, -40);
				}
				static int48(e) {
					return n(e, -48);
				}
				static int56(e) {
					return n(e, -56);
				}
				static int64(e) {
					return n(e, -64);
				}
				static int72(e) {
					return n(e, -72);
				}
				static int80(e) {
					return n(e, -80);
				}
				static int88(e) {
					return n(e, -88);
				}
				static int96(e) {
					return n(e, -96);
				}
				static int104(e) {
					return n(e, -104);
				}
				static int112(e) {
					return n(e, -112);
				}
				static int120(e) {
					return n(e, -120);
				}
				static int128(e) {
					return n(e, -128);
				}
				static int136(e) {
					return n(e, -136);
				}
				static int144(e) {
					return n(e, -144);
				}
				static int152(e) {
					return n(e, -152);
				}
				static int160(e) {
					return n(e, -160);
				}
				static int168(e) {
					return n(e, -168);
				}
				static int176(e) {
					return n(e, -176);
				}
				static int184(e) {
					return n(e, -184);
				}
				static int192(e) {
					return n(e, -192);
				}
				static int200(e) {
					return n(e, -200);
				}
				static int208(e) {
					return n(e, -208);
				}
				static int216(e) {
					return n(e, -216);
				}
				static int224(e) {
					return n(e, -224);
				}
				static int232(e) {
					return n(e, -232);
				}
				static int240(e) {
					return n(e, -240);
				}
				static int248(e) {
					return n(e, -248);
				}
				static int256(e) {
					return n(e, -256);
				}
				static int(e) {
					return n(e, -256);
				}
				static bytes1(e) {
					return b(e, 1);
				}
				static bytes2(e) {
					return b(e, 2);
				}
				static bytes3(e) {
					return b(e, 3);
				}
				static bytes4(e) {
					return b(e, 4);
				}
				static bytes5(e) {
					return b(e, 5);
				}
				static bytes6(e) {
					return b(e, 6);
				}
				static bytes7(e) {
					return b(e, 7);
				}
				static bytes8(e) {
					return b(e, 8);
				}
				static bytes9(e) {
					return b(e, 9);
				}
				static bytes10(e) {
					return b(e, 10);
				}
				static bytes11(e) {
					return b(e, 11);
				}
				static bytes12(e) {
					return b(e, 12);
				}
				static bytes13(e) {
					return b(e, 13);
				}
				static bytes14(e) {
					return b(e, 14);
				}
				static bytes15(e) {
					return b(e, 15);
				}
				static bytes16(e) {
					return b(e, 16);
				}
				static bytes17(e) {
					return b(e, 17);
				}
				static bytes18(e) {
					return b(e, 18);
				}
				static bytes19(e) {
					return b(e, 19);
				}
				static bytes20(e) {
					return b(e, 20);
				}
				static bytes21(e) {
					return b(e, 21);
				}
				static bytes22(e) {
					return b(e, 22);
				}
				static bytes23(e) {
					return b(e, 23);
				}
				static bytes24(e) {
					return b(e, 24);
				}
				static bytes25(e) {
					return b(e, 25);
				}
				static bytes26(e) {
					return b(e, 26);
				}
				static bytes27(e) {
					return b(e, 27);
				}
				static bytes28(e) {
					return b(e, 28);
				}
				static bytes29(e) {
					return b(e, 29);
				}
				static bytes30(e) {
					return b(e, 30);
				}
				static bytes31(e) {
					return b(e, 31);
				}
				static bytes32(e) {
					return b(e, 32);
				}
				static address(e) {
					return new Typed(o, 'address', e);
				}
				static bool(e) {
					return new Typed(o, 'bool', !!e);
				}
				static bytes(e) {
					return new Typed(o, 'bytes', e);
				}
				static string(e) {
					return new Typed(o, 'string', e);
				}
				static array(e, t) {
					throw new Error('not implemented yet');
					return new Typed(o, 'array', e, t);
				}
				static tuple(e, t) {
					throw new Error('not implemented yet');
					return new Typed(o, 'tuple', e, t);
				}
				static overrides(e) {
					return new Typed(o, 'overrides', Object.assign({}, e));
				}
				static isTyped(e) {
					return e && typeof e === 'object' && '_typedSymbol' in e && e._typedSymbol === c;
				}
				static dereference(e, t) {
					if (Typed.isTyped(e)) {
						if (e.type !== t) {
							throw new Error(`invalid type: expecetd ${t}, got ${e.type}`);
						}
						return e.value;
					}
					return e;
				}
			}
		},
		6686: (e, t, r) => {
			'use strict';
			r.d(t, { b: () => getAddress });
			var i = r(822);
			var a = r(6919);
			var o = r(8492);
			const c = BigInt(0);
			const u = BigInt(36);
			function getChecksumAddress(e) {
				e = e.toLowerCase();
				const t = e.substring(2).split('');
				const r = new Uint8Array(40);
				for (let e = 0; e < 40; e++) {
					r[e] = t[e].charCodeAt(0);
				}
				const o = (0, a.q5)((0, i.S)(r));
				for (let e = 0; e < 40; e += 2) {
					if (o[e >> 1] >> 4 >= 8) {
						t[e] = t[e].toUpperCase();
					}
					if ((o[e >> 1] & 15) >= 8) {
						t[e + 1] = t[e + 1].toUpperCase();
					}
				}
				return '0x' + t.join('');
			}
			const l = {};
			for (let e = 0; e < 10; e++) {
				l[String(e)] = String(e);
			}
			for (let e = 0; e < 26; e++) {
				l[String.fromCharCode(65 + e)] = String(10 + e);
			}
			const d = 15;
			function ibanChecksum(e) {
				e = e.toUpperCase();
				e = e.substring(4) + e.substring(0, 2) + '00';
				let t = e
					.split('')
					.map((e) => l[e])
					.join('');
				while (t.length >= d) {
					let e = t.substring(0, d);
					t = (parseInt(e, 10) % 97) + t.substring(e.length);
				}
				let r = String(98 - (parseInt(t, 10) % 97));
				while (r.length < 2) {
					r = '0' + r;
				}
				return r;
			}
			const p = (function () {
				const e = {};
				for (let t = 0; t < 36; t++) {
					const r = '0123456789abcdefghijklmnopqrstuvwxyz'[t];
					e[r] = BigInt(t);
				}
				return e;
			})();
			function fromBase36(e) {
				e = e.toLowerCase();
				let t = c;
				for (let r = 0; r < e.length; r++) {
					t = t * u + p[e[r]];
				}
				return t;
			}
			function getAddress(e) {
				(0, o.MR)(typeof e === 'string', 'invalid address', 'address', e);
				if (e.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
					if (!e.startsWith('0x')) {
						e = '0x' + e;
					}
					const t = getChecksumAddress(e);
					(0, o.MR)(
						!e.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || t === e,
						'bad address checksum',
						'address',
						e
					);
					return t;
				}
				if (e.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
					(0, o.MR)(e.substring(2, 4) === ibanChecksum(e), 'bad icap checksum', 'address', e);
					let t = fromBase36(e.substring(4)).toString(16);
					while (t.length < 40) {
						t = '0' + t;
					}
					return getChecksumAddress('0x' + t);
				}
				(0, o.MR)(false, 'invalid address', 'address', e);
			}
			function getIcapAddress(e) {
				let t = BigInt(getAddress(e)).toString(36).toUpperCase();
				while (t.length < 30) {
					t = '0' + t;
				}
				return 'XE' + ibanChecksum('XE00' + t) + t;
			}
		},
		2857: (e, t, r) => {
			'use strict';
			r.d(t, { $C: () => isAddressable, PW: () => isAddress, tG: () => resolveAddress });
			var i = r(8492);
			var a = r(6686);
			function isAddressable(e) {
				return e && typeof e.getAddress === 'function';
			}
			function isAddress(e) {
				try {
					(0, a.b)(e);
					return true;
				} catch (e) {}
				return false;
			}
			async function checkAddress(e, t) {
				const r = await t;
				if (r == null || r === '0x0000000000000000000000000000000000000000') {
					(0, i.vA)(typeof e !== 'string', 'unconfigured name', 'UNCONFIGURED_NAME', { value: e });
					(0, i.MR)(
						false,
						'invalid AddressLike value; did not resolve to a value address',
						'target',
						e
					);
				}
				return (0, a.b)(r);
			}
			function resolveAddress(e, t) {
				if (typeof e === 'string') {
					if (e.match(/^0x[0-9a-f]{40}$/i)) {
						return (0, a.b)(e);
					}
					(0, i.vA)(t != null, 'ENS resolution requires a provider', 'UNSUPPORTED_OPERATION', {
						operation: 'resolveName'
					});
					return checkAddress(e, t.resolveName(e));
				} else if (isAddressable(e)) {
					return checkAddress(e, e.getAddress());
				} else if (e && typeof e.then === 'function') {
					return checkAddress(e, e);
				}
				(0, i.MR)(false, 'unsupported addressable value', 'target', e);
			}
		},
		6935: (e, t, r) => {
			'use strict';
			r.d(t, { j: () => i });
			const i = '0x0000000000000000000000000000000000000000';
		},
		9848: (e, t, r) => {
			'use strict';
			r.d(t, { NZ: () => Contract });
			var i = r(4440);
			var a = r(9351);
			var o = r(2857);
			var c = r(3679);
			var u = r(4918);
			var l = r(8492);
			var d = r(572);
			var p = r(6919);
			var m = r(5362);
			class EventLog extends c.tG {
				interface;
				fragment;
				args;
				constructor(e, t, r) {
					super(e, e.provider);
					const i = t.decodeEventLog(r, e.data, e.topics);
					(0, u.n)(this, { args: i, fragment: r, interface: t });
				}
				get eventName() {
					return this.fragment.name;
				}
				get eventSignature() {
					return this.fragment.format();
				}
			}
			class UndecodedEventLog extends c.tG {
				error;
				constructor(e, t) {
					super(e, e.provider);
					(0, u.n)(this, { error: t });
				}
			}
			class ContractTransactionReceipt extends c.z5 {
				#_;
				constructor(e, t, r) {
					super(r, t);
					this.#_ = e;
				}
				get logs() {
					return super.logs.map((e) => {
						const t = e.topics.length ? this.#_.getEvent(e.topics[0]) : null;
						if (t) {
							try {
								return new EventLog(e, this.#_, t);
							} catch (t) {
								return new UndecodedEventLog(e, t);
							}
						}
						return e;
					});
				}
			}
			class ContractTransactionResponse extends c.uI {
				#_;
				constructor(e, t, r) {
					super(r, t);
					this.#_ = e;
				}
				async wait(e, t) {
					const r = await super.wait(e, t);
					if (r == null) {
						return null;
					}
					return new ContractTransactionReceipt(this.#_, this.provider, r);
				}
			}
			class ContractUnknownEventPayload extends m.z {
				log;
				constructor(e, t, r, i) {
					super(e, t, r);
					(0, u.n)(this, { log: i });
				}
				async getBlock() {
					return await this.log.getBlock();
				}
				async getTransaction() {
					return await this.log.getTransaction();
				}
				async getTransactionReceipt() {
					return await this.log.getTransactionReceipt();
				}
			}
			class ContractEventPayload extends ContractUnknownEventPayload {
				constructor(e, t, r, i, a) {
					super(e, t, r, new EventLog(a, e.interface, i));
					const o = e.interface.decodeEventLog(i, this.log.data, this.log.topics);
					(0, u.n)(this, { args: o, fragment: i });
				}
				get eventName() {
					return this.fragment.name;
				}
				get eventSignature() {
					return this.fragment.format();
				}
			}
			const g = BigInt(0);
			function canCall(e) {
				return e && typeof e.call === 'function';
			}
			function canEstimate(e) {
				return e && typeof e.estimateGas === 'function';
			}
			function canResolve(e) {
				return e && typeof e.resolveName === 'function';
			}
			function canSend(e) {
				return e && typeof e.sendTransaction === 'function';
			}
			function getResolver(e) {
				if (e != null) {
					if (canResolve(e)) {
						return e;
					}
					if (e.provider) {
						return e.provider;
					}
				}
				return undefined;
			}
			class PreparedTopicFilter {
				#A;
				fragment;
				constructor(e, t, r) {
					(0, u.n)(this, { fragment: t });
					if (t.inputs.length < r.length) {
						throw new Error('too many arguments');
					}
					const i = getRunner(e.runner, 'resolveName');
					const a = canResolve(i) ? i : null;
					this.#A = (async function () {
						const i = await Promise.all(
							t.inputs.map((e, t) => {
								const i = r[t];
								if (i == null) {
									return null;
								}
								return e.walkAsync(r[t], (e, t) => {
									if (e === 'address') {
										if (Array.isArray(t)) {
											return Promise.all(t.map((e) => (0, o.tG)(e, a)));
										}
										return (0, o.tG)(t, a);
									}
									return t;
								});
							})
						);
						return e.interface.encodeFilterTopics(t, i);
					})();
				}
				getTopicFilter() {
					return this.#A;
				}
			}
			function getRunner(e, t) {
				if (e == null) {
					return null;
				}
				if (typeof e[t] === 'function') {
					return e;
				}
				if (e.provider && typeof e.provider[t] === 'function') {
					return e.provider;
				}
				return null;
			}
			function getProvider(e) {
				if (e == null) {
					return null;
				}
				return e.provider || null;
			}
			async function copyOverrides(e, t) {
				const r = i.V.dereference(e, 'overrides');
				(0, l.MR)(typeof r === 'object', 'invalid overrides parameter', 'overrides', e);
				const a = (0, c.VS)(r);
				(0, l.MR)(
					a.to == null || (t || []).indexOf('to') >= 0,
					'cannot override to',
					'overrides.to',
					a.to
				);
				(0, l.MR)(
					a.data == null || (t || []).indexOf('data') >= 0,
					'cannot override data',
					'overrides.data',
					a.data
				);
				if (a.from) {
					a.from = a.from;
				}
				return a;
			}
			async function resolveArgs(e, t, r) {
				const a = getRunner(e, 'resolveName');
				const c = canResolve(a) ? a : null;
				return await Promise.all(
					t.map((e, t) =>
						e.walkAsync(r[t], (e, t) => {
							t = i.V.dereference(t, e);
							if (e === 'address') {
								return (0, o.tG)(t, c);
							}
							return t;
						})
					)
				);
			}
			function buildWrappedFallback(e) {
				const populateTransaction = async function (t) {
					const r = await copyOverrides(t, ['data']);
					r.to = await e.getAddress();
					if (r.from) {
						r.from = await (0, o.tG)(r.from, getResolver(e.runner));
					}
					const i = e.interface;
					const a = (0, d.Ab)(r.value || g, 'overrides.value') === g;
					const c = (r.data || '0x') === '0x';
					if (i.fallback && !i.fallback.payable && i.receive && !c && !a) {
						(0, l.MR)(
							false,
							'cannot send data to receive or send value to non-payable fallback',
							'overrides',
							t
						);
					}
					(0, l.MR)(
						i.fallback || c,
						'cannot send data to receive-only contract',
						'overrides.data',
						r.data
					);
					const u = i.receive || (i.fallback && i.fallback.payable);
					(0, l.MR)(
						u || a,
						'cannot send value to non-payable fallback',
						'overrides.value',
						r.value
					);
					(0, l.MR)(
						i.fallback || c,
						'cannot send data to receive-only contract',
						'overrides.data',
						r.data
					);
					return r;
				};
				const staticCall = async function (t) {
					const r = getRunner(e.runner, 'call');
					(0, l.vA)(
						canCall(r),
						'contract runner does not support calling',
						'UNSUPPORTED_OPERATION',
						{ operation: 'call' }
					);
					const i = await populateTransaction(t);
					try {
						return await r.call(i);
					} catch (t) {
						if ((0, l.E)(t) && t.data) {
							throw e.interface.makeError(t.data, i);
						}
						throw t;
					}
				};
				const send = async function (t) {
					const r = e.runner;
					(0, l.vA)(
						canSend(r),
						'contract runner does not support sending transactions',
						'UNSUPPORTED_OPERATION',
						{ operation: 'sendTransaction' }
					);
					const i = await r.sendTransaction(await populateTransaction(t));
					const a = getProvider(e.runner);
					return new ContractTransactionResponse(e.interface, a, i);
				};
				const estimateGas = async function (t) {
					const r = getRunner(e.runner, 'estimateGas');
					(0, l.vA)(
						canEstimate(r),
						'contract runner does not support gas estimation',
						'UNSUPPORTED_OPERATION',
						{ operation: 'estimateGas' }
					);
					return await r.estimateGas(await populateTransaction(t));
				};
				const method = async (e) => await send(e);
				(0, u.n)(method, { _contract: e, estimateGas, populateTransaction, send, staticCall });
				return method;
			}
			function buildWrappedMethod(e, t) {
				const getFragment = function (...r) {
					const i = e.interface.getFunction(t, r);
					(0, l.vA)(i, 'no matching fragment', 'UNSUPPORTED_OPERATION', {
						operation: 'fragment',
						info: { key: t, args: r }
					});
					return i;
				};
				const populateTransaction = async function (...t) {
					const r = getFragment(...t);
					let i = {};
					if (r.inputs.length + 1 === t.length) {
						i = await copyOverrides(t.pop());
						if (i.from) {
							i.from = await (0, o.tG)(i.from, getResolver(e.runner));
						}
					}
					if (r.inputs.length !== t.length) {
						throw new Error(
							"internal error: fragment inputs doesn't match arguments; should not happen"
						);
					}
					const a = await resolveArgs(e.runner, r.inputs, t);
					return Object.assign(
						{},
						i,
						await (0, u.k)({ to: e.getAddress(), data: e.interface.encodeFunctionData(r, a) })
					);
				};
				const staticCall = async function (...e) {
					const t = await staticCallResult(...e);
					if (t.length === 1) {
						return t[0];
					}
					return t;
				};
				const send = async function (...t) {
					const r = e.runner;
					(0, l.vA)(
						canSend(r),
						'contract runner does not support sending transactions',
						'UNSUPPORTED_OPERATION',
						{ operation: 'sendTransaction' }
					);
					const i = await r.sendTransaction(await populateTransaction(...t));
					const a = getProvider(e.runner);
					return new ContractTransactionResponse(e.interface, a, i);
				};
				const estimateGas = async function (...t) {
					const r = getRunner(e.runner, 'estimateGas');
					(0, l.vA)(
						canEstimate(r),
						'contract runner does not support gas estimation',
						'UNSUPPORTED_OPERATION',
						{ operation: 'estimateGas' }
					);
					return await r.estimateGas(await populateTransaction(...t));
				};
				const staticCallResult = async function (...t) {
					const r = getRunner(e.runner, 'call');
					(0, l.vA)(
						canCall(r),
						'contract runner does not support calling',
						'UNSUPPORTED_OPERATION',
						{ operation: 'call' }
					);
					const i = await populateTransaction(...t);
					let a = '0x';
					try {
						a = await r.call(i);
					} catch (t) {
						if ((0, l.E)(t) && t.data) {
							throw e.interface.makeError(t.data, i);
						}
						throw t;
					}
					const o = getFragment(...t);
					return e.interface.decodeFunctionResult(o, a);
				};
				const method = async (...e) => {
					const t = getFragment(...e);
					if (t.constant) {
						return await staticCall(...e);
					}
					return await send(...e);
				};
				(0, u.n)(method, {
					name: e.interface.getFunctionName(t),
					_contract: e,
					_key: t,
					getFragment,
					estimateGas,
					populateTransaction,
					send,
					staticCall,
					staticCallResult
				});
				Object.defineProperty(method, 'fragment', {
					configurable: false,
					enumerable: true,
					get: () => {
						const r = e.interface.getFunction(t);
						(0, l.vA)(r, 'no matching fragment', 'UNSUPPORTED_OPERATION', {
							operation: 'fragment',
							info: { key: t }
						});
						return r;
					}
				});
				return method;
			}
			function buildWrappedEvent(e, t) {
				const getFragment = function (...r) {
					const i = e.interface.getEvent(t, r);
					(0, l.vA)(i, 'no matching fragment', 'UNSUPPORTED_OPERATION', {
						operation: 'fragment',
						info: { key: t, args: r }
					});
					return i;
				};
				const method = function (...t) {
					return new PreparedTopicFilter(e, getFragment(...t), t);
				};
				(0, u.n)(method, { name: e.interface.getEventName(t), _contract: e, _key: t, getFragment });
				Object.defineProperty(method, 'fragment', {
					configurable: false,
					enumerable: true,
					get: () => {
						const r = e.interface.getEvent(t);
						(0, l.vA)(r, 'no matching fragment', 'UNSUPPORTED_OPERATION', {
							operation: 'fragment',
							info: { key: t }
						});
						return r;
					}
				});
				return method;
			}
			const v = Symbol.for('_ethersInternal_contract');
			const y = new WeakMap();
			function setInternal(e, t) {
				y.set(e[v], t);
			}
			function getInternal(e) {
				return y.get(e[v]);
			}
			function isDeferred(e) {
				return (
					e &&
					typeof e === 'object' &&
					'getTopicFilter' in e &&
					typeof e.getTopicFilter === 'function' &&
					e.fragment
				);
			}
			async function getSubInfo(e, t) {
				let r;
				let i = null;
				if (Array.isArray(t)) {
					const topicHashify = function (t) {
						if ((0, p.Lo)(t, 32)) {
							return t;
						}
						const r = e.interface.getEvent(t);
						(0, l.MR)(r, 'unknown fragment', 'name', t);
						return r.topicHash;
					};
					r = t.map((e) => {
						if (e == null) {
							return null;
						}
						if (Array.isArray(e)) {
							return e.map(topicHashify);
						}
						return topicHashify(e);
					});
				} else if (t === '*') {
					r = [null];
				} else if (typeof t === 'string') {
					if ((0, p.Lo)(t, 32)) {
						r = [t];
					} else {
						i = e.interface.getEvent(t);
						(0, l.MR)(i, 'unknown fragment', 'event', t);
						r = [i.topicHash];
					}
				} else if (isDeferred(t)) {
					r = await t.getTopicFilter();
				} else if ('fragment' in t) {
					i = t.fragment;
					r = [i.topicHash];
				} else {
					(0, l.MR)(false, 'unknown event name', 'event', t);
				}
				r = r.map((e) => {
					if (e == null) {
						return null;
					}
					if (Array.isArray(e)) {
						const t = Array.from(new Set(e.map((e) => e.toLowerCase())).values());
						if (t.length === 1) {
							return t[0];
						}
						t.sort();
						return t;
					}
					return e.toLowerCase();
				});
				const a = r
					.map((e) => {
						if (e == null) {
							return 'null';
						}
						if (Array.isArray(e)) {
							return e.join('|');
						}
						return e;
					})
					.join('&');
				return { fragment: i, tag: a, topics: r };
			}
			async function hasSub(e, t) {
				const { subs: r } = getInternal(e);
				return r.get((await getSubInfo(e, t)).tag) || null;
			}
			async function getSub(e, t, r) {
				const i = getProvider(e.runner);
				(0, l.vA)(i, 'contract runner does not support subscribing', 'UNSUPPORTED_OPERATION', {
					operation: t
				});
				const { fragment: a, tag: o, topics: c } = await getSubInfo(e, r);
				const { addr: u, subs: d } = getInternal(e);
				let p = d.get(o);
				if (!p) {
					const t = u ? u : e;
					const l = { address: t, topics: c };
					const listener = (t) => {
						let i = a;
						if (i == null) {
							try {
								i = e.interface.getEvent(t.topics[0]);
							} catch (e) {}
						}
						if (i) {
							const o = i;
							const c = a ? e.interface.decodeEventLog(a, t.data, t.topics) : [];
							emit(e, r, c, (i) => new ContractEventPayload(e, i, r, o, t));
						} else {
							emit(e, r, [], (i) => new ContractUnknownEventPayload(e, i, r, t));
						}
					};
					let m = [];
					const start = () => {
						if (m.length) {
							return;
						}
						m.push(i.on(l, listener));
					};
					const stop = async () => {
						if (m.length == 0) {
							return;
						}
						let e = m;
						m = [];
						await Promise.all(e);
						i.off(l, listener);
					};
					p = { tag: o, listeners: [], start, stop };
					d.set(o, p);
				}
				return p;
			}
			let w = Promise.resolve();
			async function _emit(e, t, r, i) {
				await w;
				const a = await hasSub(e, t);
				if (!a) {
					return false;
				}
				const o = a.listeners.length;
				a.listeners = a.listeners.filter(({ listener: t, once: a }) => {
					const o = Array.from(r);
					if (i) {
						o.push(i(a ? null : t));
					}
					try {
						t.call(e, ...o);
					} catch (e) {}
					return !a;
				});
				if (a.listeners.length === 0) {
					a.stop();
					getInternal(e).subs.delete(a.tag);
				}
				return o > 0;
			}
			async function emit(e, t, r, i) {
				try {
					await w;
				} catch (e) {}
				const a = _emit(e, t, r, i);
				w = a;
				return await a;
			}
			const _ = ['then'];
			class BaseContract {
				target;
				interface;
				runner;
				filters;
				[v];
				fallback;
				constructor(e, t, r, i) {
					(0, l.MR)(
						typeof e === 'string' || (0, o.$C)(e),
						'invalid value for Contract target',
						'target',
						e
					);
					if (r == null) {
						r = null;
					}
					const c = a.KA.from(t);
					(0, u.n)(this, { target: e, runner: r, interface: c });
					Object.defineProperty(this, v, { value: {} });
					let d;
					let m = null;
					let g = null;
					if (i) {
						const e = getProvider(r);
						g = new ContractTransactionResponse(this.interface, e, i);
					}
					let y = new Map();
					if (typeof e === 'string') {
						if ((0, p.Lo)(e)) {
							m = e;
							d = Promise.resolve(e);
						} else {
							const t = getRunner(r, 'resolveName');
							if (!canResolve(t)) {
								throw (0, l.xz)(
									'contract runner does not support name resolution',
									'UNSUPPORTED_OPERATION',
									{ operation: 'resolveName' }
								);
							}
							d = t.resolveName(e).then((t) => {
								if (t == null) {
									throw (0, l.xz)(
										'an ENS name used for a contract target must be correctly configured',
										'UNCONFIGURED_NAME',
										{ value: e }
									);
								}
								getInternal(this).addr = t;
								return t;
							});
						}
					} else {
						d = e.getAddress().then((e) => {
							if (e == null) {
								throw new Error('TODO');
							}
							getInternal(this).addr = e;
							return e;
						});
					}
					setInternal(this, { addrPromise: d, addr: m, deployTx: g, subs: y });
					const w = new Proxy(
						{},
						{
							get: (e, t, r) => {
								if (typeof t === 'symbol' || _.indexOf(t) >= 0) {
									return Reflect.get(e, t, r);
								}
								try {
									return this.getEvent(t);
								} catch (e) {
									if (!(0, l.bJ)(e, 'INVALID_ARGUMENT') || e.argument !== 'key') {
										throw e;
									}
								}
								return undefined;
							},
							has: (e, t) => {
								if (_.indexOf(t) >= 0) {
									return Reflect.has(e, t);
								}
								return Reflect.has(e, t) || this.interface.hasEvent(String(t));
							}
						}
					);
					(0, u.n)(this, { filters: w });
					(0, u.n)(this, { fallback: c.receive || c.fallback ? buildWrappedFallback(this) : null });
					return new Proxy(this, {
						get: (e, t, r) => {
							if (typeof t === 'symbol' || t in e || _.indexOf(t) >= 0) {
								return Reflect.get(e, t, r);
							}
							try {
								return e.getFunction(t);
							} catch (e) {
								if (!(0, l.bJ)(e, 'INVALID_ARGUMENT') || e.argument !== 'key') {
									throw e;
								}
							}
							return undefined;
						},
						has: (e, t) => {
							if (typeof t === 'symbol' || t in e || _.indexOf(t) >= 0) {
								return Reflect.has(e, t);
							}
							return e.interface.hasFunction(t);
						}
					});
				}
				connect(e) {
					return new BaseContract(this.target, this.interface, e);
				}
				attach(e) {
					return new BaseContract(e, this.interface, this.runner);
				}
				async getAddress() {
					return await getInternal(this).addrPromise;
				}
				async getDeployedCode() {
					const e = getProvider(this.runner);
					(0, l.vA)(e, 'runner does not support .provider', 'UNSUPPORTED_OPERATION', {
						operation: 'getDeployedCode'
					});
					const t = await e.getCode(await this.getAddress());
					if (t === '0x') {
						return null;
					}
					return t;
				}
				async waitForDeployment() {
					const e = this.deploymentTransaction();
					if (e) {
						await e.wait();
						return this;
					}
					const t = await this.getDeployedCode();
					if (t != null) {
						return this;
					}
					const r = getProvider(this.runner);
					(0, l.vA)(
						r != null,
						'contract runner does not support .provider',
						'UNSUPPORTED_OPERATION',
						{ operation: 'waitForDeployment' }
					);
					return new Promise((e, t) => {
						const checkCode = async () => {
							try {
								const t = await this.getDeployedCode();
								if (t != null) {
									return e(this);
								}
								r.once('block', checkCode);
							} catch (e) {
								t(e);
							}
						};
						checkCode();
					});
				}
				deploymentTransaction() {
					return getInternal(this).deployTx;
				}
				getFunction(e) {
					if (typeof e !== 'string') {
						e = e.format();
					}
					const t = buildWrappedMethod(this, e);
					return t;
				}
				getEvent(e) {
					if (typeof e !== 'string') {
						e = e.format();
					}
					return buildWrappedEvent(this, e);
				}
				async queryTransaction(e) {
					throw new Error('@TODO');
				}
				async queryFilter(e, t, r) {
					if (t == null) {
						t = 0;
					}
					if (r == null) {
						r = 'latest';
					}
					const { addr: i, addrPromise: a } = getInternal(this);
					const o = i ? i : await a;
					const { fragment: u, topics: d } = await getSubInfo(this, e);
					const p = { address: o, topics: d, fromBlock: t, toBlock: r };
					const m = getProvider(this.runner);
					(0, l.vA)(m, 'contract runner does not have a provider', 'UNSUPPORTED_OPERATION', {
						operation: 'queryFilter'
					});
					return (await m.getLogs(p)).map((e) => {
						let t = u;
						if (t == null) {
							try {
								t = this.interface.getEvent(e.topics[0]);
							} catch (e) {}
						}
						if (t) {
							try {
								return new EventLog(e, this.interface, t);
							} catch (t) {
								return new UndecodedEventLog(e, t);
							}
						}
						return new c.tG(e, m);
					});
				}
				async on(e, t) {
					const r = await getSub(this, 'on', e);
					r.listeners.push({ listener: t, once: false });
					r.start();
					return this;
				}
				async once(e, t) {
					const r = await getSub(this, 'once', e);
					r.listeners.push({ listener: t, once: true });
					r.start();
					return this;
				}
				async emit(e, ...t) {
					return await emit(this, e, t, null);
				}
				async listenerCount(e) {
					if (e) {
						const t = await hasSub(this, e);
						if (!t) {
							return 0;
						}
						return t.listeners.length;
					}
					const { subs: t } = getInternal(this);
					let r = 0;
					for (const { listeners: e } of t.values()) {
						r += e.length;
					}
					return r;
				}
				async listeners(e) {
					if (e) {
						const t = await hasSub(this, e);
						if (!t) {
							return [];
						}
						return t.listeners.map(({ listener: e }) => e);
					}
					const { subs: t } = getInternal(this);
					let r = [];
					for (const { listeners: e } of t.values()) {
						r = r.concat(e.map(({ listener: e }) => e));
					}
					return r;
				}
				async off(e, t) {
					const r = await hasSub(this, e);
					if (!r) {
						return this;
					}
					if (t) {
						const e = r.listeners.map(({ listener: e }) => e).indexOf(t);
						if (e >= 0) {
							r.listeners.splice(e, 1);
						}
					}
					if (t == null || r.listeners.length === 0) {
						r.stop();
						getInternal(this).subs.delete(r.tag);
					}
					return this;
				}
				async removeAllListeners(e) {
					if (e) {
						const t = await hasSub(this, e);
						if (!t) {
							return this;
						}
						t.stop();
						getInternal(this).subs.delete(t.tag);
					} else {
						const { subs: e } = getInternal(this);
						for (const { tag: t, stop: r } of e.values()) {
							r();
							e.delete(t);
						}
					}
					return this;
				}
				async addListener(e, t) {
					return await this.on(e, t);
				}
				async removeListener(e, t) {
					return await this.off(e, t);
				}
				static buildClass(e) {
					class CustomContract extends BaseContract {
						constructor(t, r = null) {
							super(t, e, r);
						}
					}
					return CustomContract;
				}
				static from(e, t, r) {
					if (r == null) {
						r = null;
					}
					const i = new this(e, t, r);
					return i;
				}
			}
			function _ContractBase() {
				return BaseContract;
			}
			class Contract extends _ContractBase() {}
		},
		3042: (e, t, r) => {
			'use strict';
			r.d(t, {
				n1: () => createHash,
				Gz: () => createHmac,
				T_: () => pbkdf2Sync,
				po: () => randomBytes
			});
			var i = r(1878);
			var a = r(9584);
			var o = r(330);
			var c = r(9496);
			var u = r(7839);
			var l = r(3067);
			const [d, p] = (() =>
				u.Ay.split(
					[
						'0x428a2f98d728ae22',
						'0x7137449123ef65cd',
						'0xb5c0fbcfec4d3b2f',
						'0xe9b5dba58189dbbc',
						'0x3956c25bf348b538',
						'0x59f111f1b605d019',
						'0x923f82a4af194f9b',
						'0xab1c5ed5da6d8118',
						'0xd807aa98a3030242',
						'0x12835b0145706fbe',
						'0x243185be4ee4b28c',
						'0x550c7dc3d5ffb4e2',
						'0x72be5d74f27b896f',
						'0x80deb1fe3b1696b1',
						'0x9bdc06a725c71235',
						'0xc19bf174cf692694',
						'0xe49b69c19ef14ad2',
						'0xefbe4786384f25e3',
						'0x0fc19dc68b8cd5b5',
						'0x240ca1cc77ac9c65',
						'0x2de92c6f592b0275',
						'0x4a7484aa6ea6e483',
						'0x5cb0a9dcbd41fbd4',
						'0x76f988da831153b5',
						'0x983e5152ee66dfab',
						'0xa831c66d2db43210',
						'0xb00327c898fb213f',
						'0xbf597fc7beef0ee4',
						'0xc6e00bf33da88fc2',
						'0xd5a79147930aa725',
						'0x06ca6351e003826f',
						'0x142929670a0e6e70',
						'0x27b70a8546d22ffc',
						'0x2e1b21385c26c926',
						'0x4d2c6dfc5ac42aed',
						'0x53380d139d95b3df',
						'0x650a73548baf63de',
						'0x766a0abb3c77b2a8',
						'0x81c2c92e47edaee6',
						'0x92722c851482353b',
						'0xa2bfe8a14cf10364',
						'0xa81a664bbc423001',
						'0xc24b8b70d0f89791',
						'0xc76c51a30654be30',
						'0xd192e819d6ef5218',
						'0xd69906245565a910',
						'0xf40e35855771202a',
						'0x106aa07032bbd1b8',
						'0x19a4c116b8d2d0c8',
						'0x1e376c085141ab53',
						'0x2748774cdf8eeb99',
						'0x34b0bcb5e19b48a8',
						'0x391c0cb3c5c95a63',
						'0x4ed8aa4ae3418acb',
						'0x5b9cca4f7763e373',
						'0x682e6ff3d6b2b8a3',
						'0x748f82ee5defb2fc',
						'0x78a5636f43172f60',
						'0x84c87814a1f0ab72',
						'0x8cc702081a6439ec',
						'0x90befffa23631e28',
						'0xa4506cebde82bde9',
						'0xbef9a3f7b2c67915',
						'0xc67178f2e372532b',
						'0xca273eceea26619c',
						'0xd186b8c721c0c207',
						'0xeada7dd6cde0eb1e',
						'0xf57d4f7fee6ed178',
						'0x06f067aa72176fba',
						'0x0a637dc5a2c898a6',
						'0x113f9804bef90dae',
						'0x1b710b35131c471b',
						'0x28db77f523047d84',
						'0x32caab7b40c72493',
						'0x3c9ebe0a15c9bebc',
						'0x431d67c49c100d4c',
						'0x4cc5d4becb3e42b6',
						'0x597f299cfc657e2a',
						'0x5fcb6fab3ad6faec',
						'0x6c44198c4a475817'
					].map((e) => BigInt(e))
				))();
			const m = new Uint32Array(80);
			const g = new Uint32Array(80);
			class SHA512 extends c.D {
				constructor() {
					super(128, 64, 16, false);
					this.Ah = 1779033703 | 0;
					this.Al = 4089235720 | 0;
					this.Bh = 3144134277 | 0;
					this.Bl = 2227873595 | 0;
					this.Ch = 1013904242 | 0;
					this.Cl = 4271175723 | 0;
					this.Dh = 2773480762 | 0;
					this.Dl = 1595750129 | 0;
					this.Eh = 1359893119 | 0;
					this.El = 2917565137 | 0;
					this.Fh = 2600822924 | 0;
					this.Fl = 725511199 | 0;
					this.Gh = 528734635 | 0;
					this.Gl = 4215389547 | 0;
					this.Hh = 1541459225 | 0;
					this.Hl = 327033209 | 0;
				}
				get() {
					const {
						Ah: e,
						Al: t,
						Bh: r,
						Bl: i,
						Ch: a,
						Cl: o,
						Dh: c,
						Dl: u,
						Eh: l,
						El: d,
						Fh: p,
						Fl: m,
						Gh: g,
						Gl: v,
						Hh: y,
						Hl: w
					} = this;
					return [e, t, r, i, a, o, c, u, l, d, p, m, g, v, y, w];
				}
				set(e, t, r, i, a, o, c, u, l, d, p, m, g, v, y, w) {
					this.Ah = e | 0;
					this.Al = t | 0;
					this.Bh = r | 0;
					this.Bl = i | 0;
					this.Ch = a | 0;
					this.Cl = o | 0;
					this.Dh = c | 0;
					this.Dl = u | 0;
					this.Eh = l | 0;
					this.El = d | 0;
					this.Fh = p | 0;
					this.Fl = m | 0;
					this.Gh = g | 0;
					this.Gl = v | 0;
					this.Hh = y | 0;
					this.Hl = w | 0;
				}
				process(e, t) {
					for (let r = 0; r < 16; r++, t += 4) {
						m[r] = e.getUint32(t);
						g[r] = e.getUint32((t += 4));
					}
					for (let e = 16; e < 80; e++) {
						const t = m[e - 15] | 0;
						const r = g[e - 15] | 0;
						const i = u.Ay.rotrSH(t, r, 1) ^ u.Ay.rotrSH(t, r, 8) ^ u.Ay.shrSH(t, r, 7);
						const a = u.Ay.rotrSL(t, r, 1) ^ u.Ay.rotrSL(t, r, 8) ^ u.Ay.shrSL(t, r, 7);
						const o = m[e - 2] | 0;
						const c = g[e - 2] | 0;
						const l = u.Ay.rotrSH(o, c, 19) ^ u.Ay.rotrBH(o, c, 61) ^ u.Ay.shrSH(o, c, 6);
						const d = u.Ay.rotrSL(o, c, 19) ^ u.Ay.rotrBL(o, c, 61) ^ u.Ay.shrSL(o, c, 6);
						const p = u.Ay.add4L(a, d, g[e - 7], g[e - 16]);
						const v = u.Ay.add4H(p, i, l, m[e - 7], m[e - 16]);
						m[e] = v | 0;
						g[e] = p | 0;
					}
					let {
						Ah: r,
						Al: i,
						Bh: a,
						Bl: o,
						Ch: c,
						Cl: l,
						Dh: v,
						Dl: y,
						Eh: w,
						El: _,
						Fh: A,
						Fl: k,
						Gh: N,
						Gl: T,
						Hh: x,
						Hl: B
					} = this;
					for (let e = 0; e < 80; e++) {
						const t = u.Ay.rotrSH(w, _, 14) ^ u.Ay.rotrSH(w, _, 18) ^ u.Ay.rotrBH(w, _, 41);
						const P = u.Ay.rotrSL(w, _, 14) ^ u.Ay.rotrSL(w, _, 18) ^ u.Ay.rotrBL(w, _, 41);
						const M = (w & A) ^ (~w & N);
						const C = (_ & k) ^ (~_ & T);
						const I = u.Ay.add5L(B, P, C, p[e], g[e]);
						const O = u.Ay.add5H(I, x, t, M, d[e], m[e]);
						const F = I | 0;
						const D = u.Ay.rotrSH(r, i, 28) ^ u.Ay.rotrBH(r, i, 34) ^ u.Ay.rotrBH(r, i, 39);
						const L = u.Ay.rotrSL(r, i, 28) ^ u.Ay.rotrBL(r, i, 34) ^ u.Ay.rotrBL(r, i, 39);
						const U = (r & a) ^ (r & c) ^ (a & c);
						const j = (i & o) ^ (i & l) ^ (o & l);
						x = N | 0;
						B = T | 0;
						N = A | 0;
						T = k | 0;
						A = w | 0;
						k = _ | 0;
						({ h: w, l: _ } = u.Ay.add(v | 0, y | 0, O | 0, F | 0));
						v = c | 0;
						y = l | 0;
						c = a | 0;
						l = o | 0;
						a = r | 0;
						o = i | 0;
						const H = u.Ay.add3L(F, L, j);
						r = u.Ay.add3H(H, O, D, U);
						i = H | 0;
					}
					({ h: r, l: i } = u.Ay.add(this.Ah | 0, this.Al | 0, r | 0, i | 0));
					({ h: a, l: o } = u.Ay.add(this.Bh | 0, this.Bl | 0, a | 0, o | 0));
					({ h: c, l } = u.Ay.add(this.Ch | 0, this.Cl | 0, c | 0, l | 0));
					({ h: v, l: y } = u.Ay.add(this.Dh | 0, this.Dl | 0, v | 0, y | 0));
					({ h: w, l: _ } = u.Ay.add(this.Eh | 0, this.El | 0, w | 0, _ | 0));
					({ h: A, l: k } = u.Ay.add(this.Fh | 0, this.Fl | 0, A | 0, k | 0));
					({ h: N, l: T } = u.Ay.add(this.Gh | 0, this.Gl | 0, N | 0, T | 0));
					({ h: x, l: B } = u.Ay.add(this.Hh | 0, this.Hl | 0, x | 0, B | 0));
					this.set(r, i, a, o, c, l, v, y, w, _, A, k, N, T, x, B);
				}
				roundClean() {
					m.fill(0);
					g.fill(0);
				}
				destroy() {
					this.buffer.fill(0);
					this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
				}
			}
			class SHA512_224 extends SHA512 {
				constructor() {
					super();
					this.Ah = 2352822216 | 0;
					this.Al = 424955298 | 0;
					this.Bh = 1944164710 | 0;
					this.Bl = 2312950998 | 0;
					this.Ch = 502970286 | 0;
					this.Cl = 855612546 | 0;
					this.Dh = 1738396948 | 0;
					this.Dl = 1479516111 | 0;
					this.Eh = 258812777 | 0;
					this.El = 2077511080 | 0;
					this.Fh = 2011393907 | 0;
					this.Fl = 79989058 | 0;
					this.Gh = 1067287976 | 0;
					this.Gl = 1780299464 | 0;
					this.Hh = 286451373 | 0;
					this.Hl = 2446758561 | 0;
					this.outputLen = 28;
				}
			}
			class SHA512_256 extends SHA512 {
				constructor() {
					super();
					this.Ah = 573645204 | 0;
					this.Al = 4230739756 | 0;
					this.Bh = 2673172387 | 0;
					this.Bl = 3360449730 | 0;
					this.Ch = 596883563 | 0;
					this.Cl = 1867755857 | 0;
					this.Dh = 2520282905 | 0;
					this.Dl = 1497426621 | 0;
					this.Eh = 2519219938 | 0;
					this.El = 2827943907 | 0;
					this.Fh = 3193839141 | 0;
					this.Fl = 1401305490 | 0;
					this.Gh = 721525244 | 0;
					this.Gl = 746961066 | 0;
					this.Hh = 246885852 | 0;
					this.Hl = 2177182882 | 0;
					this.outputLen = 32;
				}
			}
			class SHA384 extends SHA512 {
				constructor() {
					super();
					this.Ah = 3418070365 | 0;
					this.Al = 3238371032 | 0;
					this.Bh = 1654270250 | 0;
					this.Bl = 914150663 | 0;
					this.Ch = 2438529370 | 0;
					this.Cl = 812702999 | 0;
					this.Dh = 355462360 | 0;
					this.Dl = 4144912697 | 0;
					this.Eh = 1731405415 | 0;
					this.El = 4290775857 | 0;
					this.Fh = 2394180231 | 0;
					this.Fl = 1750603025 | 0;
					this.Gh = 3675008525 | 0;
					this.Gl = 1694076839 | 0;
					this.Hh = 1203062813 | 0;
					this.Hl = 3204075428 | 0;
					this.outputLen = 48;
				}
			}
			const v = (0, l.ld)(() => new SHA512());
			const y = null && wrapConstructor(() => new SHA512_224());
			const w = null && wrapConstructor(() => new SHA512_256());
			const _ = null && wrapConstructor(() => new SHA384());
			var A = r(8492);
			function getGlobal() {
				if (typeof self !== 'undefined') {
					return self;
				}
				if (typeof window !== 'undefined') {
					return window;
				}
				if (typeof global !== 'undefined') {
					return global;
				}
				throw new Error('unable to locate global object');
			}
			const k = getGlobal();
			const N = k.crypto || k.msCrypto;
			function createHash(e) {
				switch (e) {
					case 'sha256':
						return o.s.create();
					case 'sha512':
						return v.create();
				}
				(0, A.MR)(false, 'invalid hashing algorithm name', 'algorithm', e);
			}
			function createHmac(e, t) {
				const r = { sha256: o.s, sha512: v }[e];
				(0, A.MR)(r != null, 'invalid hmac algorithm', 'algorithm', e);
				return i.w.create(r, t);
			}
			function pbkdf2Sync(e, t, r, i, c) {
				const u = { sha256: o.s, sha512: v }[c];
				(0, A.MR)(u != null, 'invalid pbkdf2 algorithm', 'algorithm', c);
				return (0, a.A)(u, e, t, { c: r, dkLen: i });
			}
			function randomBytes(e) {
				(0, A.vA)(
					N != null,
					'platform does not support secure random numbers',
					'UNSUPPORTED_OPERATION',
					{ operation: 'randomBytes' }
				);
				(0, A.MR)(Number.isInteger(e) && e > 0 && e <= 1024, 'invalid length', 'length', e);
				const t = new Uint8Array(e);
				N.getRandomValues(t);
				return t;
			}
		},
		822: (e, t, r) => {
			'use strict';
			r.d(t, { S: () => keccak256 });
			var i = r(6638);
			var a = r(7839);
			var o = r(3067);
			const [c, u, l] = [[], [], []];
			const d = BigInt(0);
			const p = BigInt(1);
			const m = BigInt(2);
			const g = BigInt(7);
			const v = BigInt(256);
			const y = BigInt(113);
			for (let e = 0, t = p, r = 1, i = 0; e < 24; e++) {
				[r, i] = [i, (2 * r + 3 * i) % 5];
				c.push(2 * (5 * i + r));
				u.push((((e + 1) * (e + 2)) / 2) % 64);
				let a = d;
				for (let e = 0; e < 7; e++) {
					t = ((t << p) ^ ((t >> g) * y)) % v;
					if (t & m) a ^= p << ((p << BigInt(e)) - p);
				}
				l.push(a);
			}
			const [w, _] = (0, a.lD)(l, true);
			const rotlH = (e, t, r) => (r > 32 ? (0, a.WM)(e, t, r) : (0, a.P5)(e, t, r));
			const rotlL = (e, t, r) => (r > 32 ? (0, a.im)(e, t, r) : (0, a.B4)(e, t, r));
			function keccakP(e, t = 24) {
				const r = new Uint32Array(5 * 2);
				for (let i = 24 - t; i < 24; i++) {
					for (let t = 0; t < 10; t++) r[t] = e[t] ^ e[t + 10] ^ e[t + 20] ^ e[t + 30] ^ e[t + 40];
					for (let t = 0; t < 10; t += 2) {
						const i = (t + 8) % 10;
						const a = (t + 2) % 10;
						const o = r[a];
						const c = r[a + 1];
						const u = rotlH(o, c, 1) ^ r[i];
						const l = rotlL(o, c, 1) ^ r[i + 1];
						for (let r = 0; r < 50; r += 10) {
							e[t + r] ^= u;
							e[t + r + 1] ^= l;
						}
					}
					let t = e[2];
					let a = e[3];
					for (let r = 0; r < 24; r++) {
						const i = u[r];
						const o = rotlH(t, a, i);
						const l = rotlL(t, a, i);
						const d = c[r];
						t = e[d];
						a = e[d + 1];
						e[d] = o;
						e[d + 1] = l;
					}
					for (let t = 0; t < 50; t += 10) {
						for (let i = 0; i < 10; i++) r[i] = e[t + i];
						for (let i = 0; i < 10; i++) e[t + i] ^= ~r[(i + 2) % 10] & r[(i + 4) % 10];
					}
					e[0] ^= w[i];
					e[1] ^= _[i];
				}
				r.fill(0);
			}
			class Keccak extends o.Vw {
				constructor(e, t, r, a = false, c = 24) {
					super();
					this.blockLen = e;
					this.suffix = t;
					this.outputLen = r;
					this.enableXOF = a;
					this.rounds = c;
					this.pos = 0;
					this.posOut = 0;
					this.finished = false;
					this.destroyed = false;
					(0, i.ai)(r);
					if (0 >= this.blockLen || this.blockLen >= 200)
						throw new Error('Sha3 supports only keccak-f1600 function');
					this.state = new Uint8Array(200);
					this.state32 = (0, o.DH)(this.state);
				}
				keccak() {
					keccakP(this.state32, this.rounds);
					this.posOut = 0;
					this.pos = 0;
				}
				update(e) {
					(0, i.t2)(this);
					const { blockLen: t, state: r } = this;
					e = (0, o.ZJ)(e);
					const a = e.length;
					for (let i = 0; i < a; ) {
						const o = Math.min(t - this.pos, a - i);
						for (let t = 0; t < o; t++) r[this.pos++] ^= e[i++];
						if (this.pos === t) this.keccak();
					}
					return this;
				}
				finish() {
					if (this.finished) return;
					this.finished = true;
					const { state: e, suffix: t, pos: r, blockLen: i } = this;
					e[r] ^= t;
					if ((t & 128) !== 0 && r === i - 1) this.keccak();
					e[i - 1] ^= 128;
					this.keccak();
				}
				writeInto(e) {
					(0, i.t2)(this, false);
					(0, i.ee)(e);
					this.finish();
					const t = this.state;
					const { blockLen: r } = this;
					for (let i = 0, a = e.length; i < a; ) {
						if (this.posOut >= r) this.keccak();
						const o = Math.min(r - this.posOut, a - i);
						e.set(t.subarray(this.posOut, this.posOut + o), i);
						this.posOut += o;
						i += o;
					}
					return e;
				}
				xofInto(e) {
					if (!this.enableXOF) throw new Error('XOF is not possible for this instance');
					return this.writeInto(e);
				}
				xof(e) {
					(0, i.ai)(e);
					return this.xofInto(new Uint8Array(e));
				}
				digestInto(e) {
					(0, i.CG)(e, this);
					if (this.finished) throw new Error('digest() was already called');
					this.writeInto(e);
					this.destroy();
					return e;
				}
				digest() {
					return this.digestInto(new Uint8Array(this.outputLen));
				}
				destroy() {
					this.destroyed = true;
					this.state.fill(0);
				}
				_cloneInto(e) {
					const { blockLen: t, suffix: r, outputLen: i, rounds: a, enableXOF: o } = this;
					e || (e = new Keccak(t, r, i, o, a));
					e.state32.set(this.state32);
					e.pos = this.pos;
					e.posOut = this.posOut;
					e.finished = this.finished;
					e.rounds = a;
					e.suffix = r;
					e.outputLen = i;
					e.enableXOF = o;
					e.destroyed = this.destroyed;
					return e;
				}
			}
			const gen = (e, t, r) => (0, o.ld)(() => new Keccak(t, e, r));
			const A = null && gen(6, 144, 224 / 8);
			const k = null && gen(6, 136, 256 / 8);
			const N = null && gen(6, 104, 384 / 8);
			const T = null && gen(6, 72, 512 / 8);
			const x = null && gen(1, 144, 224 / 8);
			const B = gen(1, 136, 256 / 8);
			const P = null && gen(1, 104, 384 / 8);
			const M = null && gen(1, 72, 512 / 8);
			const genShake = (e, t, r) =>
				wrapXOFConstructorWithOpts(
					(i = {}) => new Keccak(t, e, i.dkLen === undefined ? r : i.dkLen, true)
				);
			const C = null && genShake(31, 168, 128 / 8);
			const I = null && genShake(31, 136, 256 / 8);
			var O = r(6919);
			let F = false;
			const _keccak256 = function (e) {
				return B(e);
			};
			let D = _keccak256;
			function keccak256(e) {
				const t = (0, O.q5)(e, 'data');
				return (0, O.c$)(D(t));
			}
			keccak256._ = _keccak256;
			keccak256.lock = function () {
				F = true;
			};
			keccak256.register = function (e) {
				if (F) {
					throw new TypeError('keccak256 is locked');
				}
				D = e;
			};
			Object.freeze(keccak256);
		},
		1950: (e, t, r) => {
			'use strict';
			r.d(t, { A: () => pbkdf2 });
			var i = r(3042);
			var a = r(6919);
			let o = false;
			const _pbkdf2 = function (e, t, r, a, o) {
				return (0, i.T_)(e, t, r, a, o);
			};
			let c = _pbkdf2;
			function pbkdf2(e, t, r, i, o) {
				const u = (0, a.q5)(e, 'password');
				const l = (0, a.q5)(t, 'salt');
				return (0, a.c$)(c(u, l, r, i, o));
			}
			pbkdf2._ = _pbkdf2;
			pbkdf2.lock = function () {
				o = true;
			};
			pbkdf2.register = function (e) {
				if (o) {
					throw new Error('pbkdf2 is locked');
				}
				c = e;
			};
			Object.freeze(pbkdf2);
		},
		1396: (e, t, r) => {
			'use strict';
			r.d(t, { p: () => randomBytes });
			var i = r(3042);
			let a = false;
			const _randomBytes = function (e) {
				return new Uint8Array((0, i.po)(e));
			};
			let o = _randomBytes;
			function randomBytes(e) {
				return o(e);
			}
			randomBytes._ = _randomBytes;
			randomBytes.lock = function () {
				a = true;
			};
			randomBytes.register = function (e) {
				if (a) {
					throw new Error('randomBytes is locked');
				}
				o = e;
			};
			Object.freeze(randomBytes);
		},
		4931: (e, t, r) => {
			'use strict';
			r.d(t, { s: () => sha256 });
			var i = r(3042);
			var a = r(6919);
			const _sha256 = function (e) {
				return (0, i.n1)('sha256').update(e).digest();
			};
			const _sha512 = function (e) {
				return (0, i.n1)('sha512').update(e).digest();
			};
			let o = _sha256;
			let c = _sha512;
			let u = false,
				l = false;
			function sha256(e) {
				const t = (0, a.q5)(e, 'data');
				return (0, a.c$)(o(t));
			}
			sha256._ = _sha256;
			sha256.lock = function () {
				u = true;
			};
			sha256.register = function (e) {
				if (u) {
					throw new Error('sha256 is locked');
				}
				o = e;
			};
			Object.freeze(sha256);
			function sha512(e) {
				const t = (0, a.q5)(e, 'data');
				return (0, a.c$)(c(t));
			}
			sha512._ = _sha512;
			sha512.lock = function () {
				l = true;
			};
			sha512.register = function (e) {
				if (l) {
					throw new Error('sha512 is locked');
				}
				c = e;
			};
			Object.freeze(sha256);
		},
		8249: (e, t, r) => {
			'use strict';
			r.d(t, { t: () => Signature });
			const i = '0x0000000000000000000000000000000000000000000000000000000000000000';
			var a = r(6919);
			var o = r(572);
			var c = r(8492);
			const u = BigInt(0);
			const l = BigInt(1);
			const d = BigInt(2);
			const p = BigInt(27);
			const m = BigInt(28);
			const g = BigInt(35);
			const v = {};
			function toUint256(e) {
				return (0, a.nx)((0, o.c4)(e), 32);
			}
			class Signature {
				#E;
				#S;
				#k;
				#N;
				get r() {
					return this.#E;
				}
				set r(e) {
					(0, c.MR)((0, a.pO)(e) === 32, 'invalid r', 'value', e);
					this.#E = (0, a.c$)(e);
				}
				get s() {
					return this.#S;
				}
				set s(e) {
					(0, c.MR)((0, a.pO)(e) === 32, 'invalid s', 'value', e);
					const t = (0, a.c$)(e);
					(0, c.MR)(parseInt(t.substring(0, 3)) < 8, 'non-canonical s', 'value', t);
					this.#S = t;
				}
				get v() {
					return this.#k;
				}
				set v(e) {
					const t = (0, o.WZ)(e, 'value');
					(0, c.MR)(t === 27 || t === 28, 'invalid v', 'v', e);
					this.#k = t;
				}
				get networkV() {
					return this.#N;
				}
				get legacyChainId() {
					const e = this.networkV;
					if (e == null) {
						return null;
					}
					return Signature.getChainId(e);
				}
				get yParity() {
					return this.v === 27 ? 0 : 1;
				}
				get yParityAndS() {
					const e = (0, a.q5)(this.s);
					if (this.yParity) {
						e[0] |= 128;
					}
					return (0, a.c$)(e);
				}
				get compactSerialized() {
					return (0, a.xW)([this.r, this.yParityAndS]);
				}
				get serialized() {
					return (0, a.xW)([this.r, this.s, this.yParity ? '0x1c' : '0x1b']);
				}
				constructor(e, t, r, i) {
					(0, c.gk)(e, v, 'Signature');
					this.#E = t;
					this.#S = r;
					this.#k = i;
					this.#N = null;
				}
				[Symbol.for('nodejs.util.inspect.custom')]() {
					return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
				}
				clone() {
					const e = new Signature(v, this.r, this.s, this.v);
					if (this.networkV) {
						e.#N = this.networkV;
					}
					return e;
				}
				toJSON() {
					const e = this.networkV;
					return {
						_type: 'signature',
						networkV: e != null ? e.toString() : null,
						r: this.r,
						s: this.s,
						v: this.v
					};
				}
				static getChainId(e) {
					const t = (0, o.Ab)(e, 'v');
					if (t == p || t == m) {
						return u;
					}
					(0, c.MR)(t >= g, 'invalid EIP-155 v', 'v', e);
					return (t - g) / d;
				}
				static getChainIdV(e, t) {
					return (0, o.Ab)(e) * d + BigInt(35 + t - 27);
				}
				static getNormalizedV(e) {
					const t = (0, o.Ab)(e);
					if (t === u || t === p) {
						return 27;
					}
					if (t === l || t === m) {
						return 28;
					}
					(0, c.MR)(t >= g, 'invalid v', 'v', e);
					return t & l ? 27 : 28;
				}
				static from(e) {
					function assertError(t, r) {
						(0, c.MR)(t, r, 'signature', e);
					}
					if (e == null) {
						return new Signature(v, i, i, 27);
					}
					if (typeof e === 'string') {
						const t = (0, a.q5)(e, 'signature');
						if (t.length === 64) {
							const e = (0, a.c$)(t.slice(0, 32));
							const r = t.slice(32, 64);
							const i = r[0] & 128 ? 28 : 27;
							r[0] &= 127;
							return new Signature(v, e, (0, a.c$)(r), i);
						}
						if (t.length === 65) {
							const e = (0, a.c$)(t.slice(0, 32));
							const r = t.slice(32, 64);
							assertError((r[0] & 128) === 0, 'non-canonical s');
							const i = Signature.getNormalizedV(t[64]);
							return new Signature(v, e, (0, a.c$)(r), i);
						}
						assertError(false, 'invalid raw signature length');
					}
					if (e instanceof Signature) {
						return e.clone();
					}
					const t = e.r;
					assertError(t != null, 'missing r');
					const r = toUint256(t);
					const u = (function (e, t) {
						if (e != null) {
							return toUint256(e);
						}
						if (t != null) {
							assertError((0, a.Lo)(t, 32), 'invalid yParityAndS');
							const e = (0, a.q5)(t);
							e[0] &= 127;
							return (0, a.c$)(e);
						}
						assertError(false, 'missing s');
					})(e.s, e.yParityAndS);
					assertError(((0, a.q5)(u)[0] & 128) == 0, 'non-canonical s');
					const { networkV: l, v: d } = (function (e, t, r) {
						if (e != null) {
							const t = (0, o.Ab)(e);
							return { networkV: t >= g ? t : undefined, v: Signature.getNormalizedV(t) };
						}
						if (t != null) {
							assertError((0, a.Lo)(t, 32), 'invalid yParityAndS');
							return { v: (0, a.q5)(t)[0] & 128 ? 28 : 27 };
						}
						if (r != null) {
							switch ((0, o.WZ)(r, 'sig.yParity')) {
								case 0:
									return { v: 27 };
								case 1:
									return { v: 28 };
							}
							assertError(false, 'invalid yParity');
						}
						assertError(false, 'missing v');
					})(e.v, e.yParityAndS, e.yParity);
					const p = new Signature(v, r, u, d);
					if (l) {
						p.#N = l;
					}
					assertError(
						e.yParity == null || (0, o.WZ)(e.yParity, 'sig.yParity') === p.yParity,
						'yParity mismatch'
					);
					assertError(
						e.yParityAndS == null || e.yParityAndS === p.yParityAndS,
						'yParityAndS mismatch'
					);
					return p;
				}
			}
		},
		6945: (e, t, r) => {
			'use strict';
			r.d(t, { h: () => SigningKey });
			var i = {};
			r.r(i);
			r.d(i, {
				OG: () => bitMask,
				My: () => bytesToHex,
				Ph: () => utils_bytesToNumberBE,
				lX: () => utils_bytesToNumberLE,
				Id: () => utils_concatBytes,
				fg: () => createHmacDrbg,
				qj: () => utils_ensureBytes,
				aT: () => hexToBytes,
				lq: () => utils_numberToBytesBE,
				z: () => numberToBytesLE,
				Q5: () => validateObject
			});
			var a = r(330);
			const o = BigInt(0);
			const c = BigInt(1);
			const u = BigInt(2);
			const u8a = (e) => e instanceof Uint8Array;
			const l = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0'));
			function bytesToHex(e) {
				if (!u8a(e)) throw new Error('Uint8Array expected');
				let t = '';
				for (let r = 0; r < e.length; r++) {
					t += l[e[r]];
				}
				return t;
			}
			function numberToHexUnpadded(e) {
				const t = e.toString(16);
				return t.length & 1 ? `0${t}` : t;
			}
			function hexToNumber(e) {
				if (typeof e !== 'string') throw new Error('hex string expected, got ' + typeof e);
				return BigInt(e === '' ? '0' : `0x${e}`);
			}
			function hexToBytes(e) {
				if (typeof e !== 'string') throw new Error('hex string expected, got ' + typeof e);
				const t = e.length;
				if (t % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + t);
				const r = new Uint8Array(t / 2);
				for (let t = 0; t < r.length; t++) {
					const i = t * 2;
					const a = e.slice(i, i + 2);
					const o = Number.parseInt(a, 16);
					if (Number.isNaN(o) || o < 0) throw new Error('Invalid byte sequence');
					r[t] = o;
				}
				return r;
			}
			function utils_bytesToNumberBE(e) {
				return hexToNumber(bytesToHex(e));
			}
			function utils_bytesToNumberLE(e) {
				if (!u8a(e)) throw new Error('Uint8Array expected');
				return hexToNumber(bytesToHex(Uint8Array.from(e).reverse()));
			}
			function utils_numberToBytesBE(e, t) {
				return hexToBytes(e.toString(16).padStart(t * 2, '0'));
			}
			function numberToBytesLE(e, t) {
				return utils_numberToBytesBE(e, t).reverse();
			}
			function numberToVarBytesBE(e) {
				return hexToBytes(numberToHexUnpadded(e));
			}
			function utils_ensureBytes(e, t, r) {
				let i;
				if (typeof t === 'string') {
					try {
						i = hexToBytes(t);
					} catch (r) {
						throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${r}`);
					}
				} else if (u8a(t)) {
					i = Uint8Array.from(t);
				} else {
					throw new Error(`${e} must be hex string or Uint8Array`);
				}
				const a = i.length;
				if (typeof r === 'number' && a !== r) throw new Error(`${e} expected ${r} bytes, got ${a}`);
				return i;
			}
			function utils_concatBytes(...e) {
				const t = new Uint8Array(e.reduce((e, t) => e + t.length, 0));
				let r = 0;
				e.forEach((e) => {
					if (!u8a(e)) throw new Error('Uint8Array expected');
					t.set(e, r);
					r += e.length;
				});
				return t;
			}
			function equalBytes(e, t) {
				if (e.length !== t.length) return false;
				for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return false;
				return true;
			}
			function utf8ToBytes(e) {
				if (typeof e !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
				return new Uint8Array(new TextEncoder().encode(e));
			}
			function bitLen(e) {
				let t;
				for (t = 0; e > o; e >>= c, t += 1);
				return t;
			}
			function bitGet(e, t) {
				return (e >> BigInt(t)) & c;
			}
			const bitSet = (e, t, r) => e | ((r ? c : o) << BigInt(t));
			const bitMask = (e) => (u << BigInt(e - 1)) - c;
			const u8n = (e) => new Uint8Array(e);
			const u8fr = (e) => Uint8Array.from(e);
			function createHmacDrbg(e, t, r) {
				if (typeof e !== 'number' || e < 2) throw new Error('hashLen must be a number');
				if (typeof t !== 'number' || t < 2) throw new Error('qByteLen must be a number');
				if (typeof r !== 'function') throw new Error('hmacFn must be a function');
				let i = u8n(e);
				let a = u8n(e);
				let o = 0;
				const reset = () => {
					i.fill(1);
					a.fill(0);
					o = 0;
				};
				const h = (...e) => r(a, i, ...e);
				const reseed = (e = u8n()) => {
					a = h(u8fr([0]), e);
					i = h();
					if (e.length === 0) return;
					a = h(u8fr([1]), e);
					i = h();
				};
				const gen = () => {
					if (o++ >= 1e3) throw new Error('drbg: tried 1000 values');
					let e = 0;
					const r = [];
					while (e < t) {
						i = h();
						const t = i.slice();
						r.push(t);
						e += i.length;
					}
					return utils_concatBytes(...r);
				};
				const genUntil = (e, t) => {
					reset();
					reseed(e);
					let r = undefined;
					while (!(r = t(gen()))) reseed();
					reset();
					return r;
				};
				return genUntil;
			}
			const d = {
				bigint: (e) => typeof e === 'bigint',
				function: (e) => typeof e === 'function',
				boolean: (e) => typeof e === 'boolean',
				string: (e) => typeof e === 'string',
				stringOrUint8Array: (e) => typeof e === 'string' || e instanceof Uint8Array,
				isSafeInteger: (e) => Number.isSafeInteger(e),
				array: (e) => Array.isArray(e),
				field: (e, t) => t.Fp.isValid(e),
				hash: (e) => typeof e === 'function' && Number.isSafeInteger(e.outputLen)
			};
			function validateObject(e, t, r = {}) {
				const checkField = (t, r, i) => {
					const a = d[r];
					if (typeof a !== 'function')
						throw new Error(`Invalid validator "${r}", expected function`);
					const o = e[t];
					if (i && o === undefined) return;
					if (!a(o, e)) {
						throw new Error(`Invalid param ${String(t)}=${o} (${typeof o}), expected ${r}`);
					}
				};
				for (const [e, r] of Object.entries(t)) checkField(e, r, false);
				for (const [e, t] of Object.entries(r)) checkField(e, t, true);
				return e;
			}
			const p = BigInt(0),
				m = BigInt(1),
				g = BigInt(2),
				v = BigInt(3);
			const y = BigInt(4),
				w = BigInt(5),
				_ = BigInt(8);
			const A = BigInt(9),
				k = BigInt(16);
			function modular_mod(e, t) {
				const r = e % t;
				return r >= p ? r : t + r;
			}
			function pow(e, t, r) {
				if (r <= p || t < p) throw new Error('Expected power/modulo > 0');
				if (r === m) return p;
				let i = m;
				while (t > p) {
					if (t & m) i = (i * e) % r;
					e = (e * e) % r;
					t >>= m;
				}
				return i;
			}
			function pow2(e, t, r) {
				let i = e;
				while (t-- > p) {
					i *= i;
					i %= r;
				}
				return i;
			}
			function invert(e, t) {
				if (e === p || t <= p) {
					throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
				}
				let r = modular_mod(e, t);
				let i = t;
				let a = p,
					o = m,
					c = m,
					u = p;
				while (r !== p) {
					const e = i / r;
					const t = i % r;
					const l = a - c * e;
					const d = o - u * e;
					(i = r), (r = t), (a = c), (o = u), (c = l), (u = d);
				}
				const l = i;
				if (l !== m) throw new Error('invert: does not exist');
				return modular_mod(a, t);
			}
			function tonelliShanks(e) {
				const t = (e - m) / g;
				let r, i, a;
				for (r = e - m, i = 0; r % g === p; r /= g, i++);
				for (a = g; a < e && pow(a, t, e) !== e - m; a++);
				if (i === 1) {
					const t = (e + m) / y;
					return function tonelliFast(e, r) {
						const i = e.pow(r, t);
						if (!e.eql(e.sqr(i), r)) throw new Error('Cannot find square root');
						return i;
					};
				}
				const o = (r + m) / g;
				return function tonelliSlow(e, c) {
					if (e.pow(c, t) === e.neg(e.ONE)) throw new Error('Cannot find square root');
					let u = i;
					let l = e.pow(e.mul(e.ONE, a), r);
					let d = e.pow(c, o);
					let p = e.pow(c, r);
					while (!e.eql(p, e.ONE)) {
						if (e.eql(p, e.ZERO)) return e.ZERO;
						let t = 1;
						for (let r = e.sqr(p); t < u; t++) {
							if (e.eql(r, e.ONE)) break;
							r = e.sqr(r);
						}
						const r = e.pow(l, m << BigInt(u - t - 1));
						l = e.sqr(r);
						d = e.mul(d, r);
						p = e.mul(p, l);
						u = t;
					}
					return d;
				};
			}
			function FpSqrt(e) {
				if (e % y === v) {
					const t = (e + m) / y;
					return function sqrt3mod4(e, r) {
						const i = e.pow(r, t);
						if (!e.eql(e.sqr(i), r)) throw new Error('Cannot find square root');
						return i;
					};
				}
				if (e % _ === w) {
					const t = (e - w) / _;
					return function sqrt5mod8(e, r) {
						const i = e.mul(r, g);
						const a = e.pow(i, t);
						const o = e.mul(r, a);
						const c = e.mul(e.mul(o, g), a);
						const u = e.mul(o, e.sub(c, e.ONE));
						if (!e.eql(e.sqr(u), r)) throw new Error('Cannot find square root');
						return u;
					};
				}
				if (e % k === A) {
				}
				return tonelliShanks(e);
			}
			const isNegativeLE = (e, t) => (modular_mod(e, t) & m) === m;
			const N = [
				'create',
				'isValid',
				'is0',
				'neg',
				'inv',
				'sqrt',
				'sqr',
				'eql',
				'add',
				'sub',
				'mul',
				'pow',
				'div',
				'addN',
				'subN',
				'mulN',
				'sqrN'
			];
			function validateField(e) {
				const t = {
					ORDER: 'bigint',
					MASK: 'bigint',
					BYTES: 'isSafeInteger',
					BITS: 'isSafeInteger'
				};
				const r = N.reduce((e, t) => {
					e[t] = 'function';
					return e;
				}, t);
				return validateObject(e, r);
			}
			function FpPow(e, t, r) {
				if (r < p) throw new Error('Expected power > 0');
				if (r === p) return e.ONE;
				if (r === m) return t;
				let i = e.ONE;
				let a = t;
				while (r > p) {
					if (r & m) i = e.mul(i, a);
					a = e.sqr(a);
					r >>= m;
				}
				return i;
			}
			function FpInvertBatch(e, t) {
				const r = new Array(t.length);
				const i = t.reduce((t, i, a) => {
					if (e.is0(i)) return t;
					r[a] = t;
					return e.mul(t, i);
				}, e.ONE);
				const a = e.inv(i);
				t.reduceRight((t, i, a) => {
					if (e.is0(i)) return t;
					r[a] = e.mul(t, r[a]);
					return e.mul(t, i);
				}, a);
				return r;
			}
			function FpDiv(e, t, r) {
				return e.mul(t, typeof r === 'bigint' ? invert(r, e.ORDER) : e.inv(r));
			}
			function FpIsSquare(e) {
				const t = (e.ORDER - m) / g;
				return (r) => {
					const i = e.pow(r, t);
					return e.eql(i, e.ZERO) || e.eql(i, e.ONE);
				};
			}
			function nLength(e, t) {
				const r = t !== undefined ? t : e.toString(2).length;
				const i = Math.ceil(r / 8);
				return { nBitLength: r, nByteLength: i };
			}
			function Field(e, t, r = false, i = {}) {
				if (e <= p) throw new Error(`Expected Field ORDER > 0, got ${e}`);
				const { nBitLength: a, nByteLength: o } = nLength(e, t);
				if (o > 2048) throw new Error('Field lengths over 2048 bytes are not supported');
				const c = FpSqrt(e);
				const u = Object.freeze({
					ORDER: e,
					BITS: a,
					BYTES: o,
					MASK: bitMask(a),
					ZERO: p,
					ONE: m,
					create: (t) => modular_mod(t, e),
					isValid: (t) => {
						if (typeof t !== 'bigint')
							throw new Error(`Invalid field element: expected bigint, got ${typeof t}`);
						return p <= t && t < e;
					},
					is0: (e) => e === p,
					isOdd: (e) => (e & m) === m,
					neg: (t) => modular_mod(-t, e),
					eql: (e, t) => e === t,
					sqr: (t) => modular_mod(t * t, e),
					add: (t, r) => modular_mod(t + r, e),
					sub: (t, r) => modular_mod(t - r, e),
					mul: (t, r) => modular_mod(t * r, e),
					pow: (e, t) => FpPow(u, e, t),
					div: (t, r) => modular_mod(t * invert(r, e), e),
					sqrN: (e) => e * e,
					addN: (e, t) => e + t,
					subN: (e, t) => e - t,
					mulN: (e, t) => e * t,
					inv: (t) => invert(t, e),
					sqrt: i.sqrt || ((e) => c(u, e)),
					invertBatch: (e) => FpInvertBatch(u, e),
					cmov: (e, t, r) => (r ? t : e),
					toBytes: (e) => (r ? numberToBytesLE(e, o) : utils_numberToBytesBE(e, o)),
					fromBytes: (e) => {
						if (e.length !== o) throw new Error(`Fp.fromBytes: expected ${o}, got ${e.length}`);
						return r ? utils_bytesToNumberLE(e) : utils_bytesToNumberBE(e);
					}
				});
				return Object.freeze(u);
			}
			function FpSqrtOdd(e, t) {
				if (!e.isOdd) throw new Error(`Field doesn't have isOdd`);
				const r = e.sqrt(t);
				return e.isOdd(r) ? r : e.neg(r);
			}
			function FpSqrtEven(e, t) {
				if (!e.isOdd) throw new Error(`Field doesn't have isOdd`);
				const r = e.sqrt(t);
				return e.isOdd(r) ? e.neg(r) : r;
			}
			function hashToPrivateScalar(e, t, r = false) {
				e = ensureBytes('privateHash', e);
				const i = e.length;
				const a = nLength(t).nByteLength + 8;
				if (a < 24 || i < a || i > 1024)
					throw new Error(`hashToPrivateScalar: expected ${a}-1024 bytes of input, got ${i}`);
				const o = r ? bytesToNumberLE(e) : bytesToNumberBE(e);
				return modular_mod(o, t - m) + m;
			}
			function getFieldBytesLength(e) {
				if (typeof e !== 'bigint') throw new Error('field order must be bigint');
				const t = e.toString(2).length;
				return Math.ceil(t / 8);
			}
			function getMinHashLength(e) {
				const t = getFieldBytesLength(e);
				return t + Math.ceil(t / 2);
			}
			function mapHashToField(e, t, r = false) {
				const i = e.length;
				const a = getFieldBytesLength(t);
				const o = getMinHashLength(t);
				if (i < 16 || i < o || i > 1024)
					throw new Error(`expected ${o}-1024 bytes of input, got ${i}`);
				const c = r ? utils_bytesToNumberBE(e) : utils_bytesToNumberLE(e);
				const u = modular_mod(c, t - m) + m;
				return r ? numberToBytesLE(u, a) : utils_numberToBytesBE(u, a);
			}
			var T = r(1878);
			var x = r(3067);
			const B = BigInt(0);
			const P = BigInt(1);
			function wNAF(e, t) {
				const constTimeNegate = (e, t) => {
					const r = t.negate();
					return e ? r : t;
				};
				const opts = (e) => {
					const r = Math.ceil(t / e) + 1;
					const i = 2 ** (e - 1);
					return { windows: r, windowSize: i };
				};
				return {
					constTimeNegate,
					unsafeLadder(t, r) {
						let i = e.ZERO;
						let a = t;
						while (r > B) {
							if (r & P) i = i.add(a);
							a = a.double();
							r >>= P;
						}
						return i;
					},
					precomputeWindow(e, t) {
						const { windows: r, windowSize: i } = opts(t);
						const a = [];
						let o = e;
						let c = o;
						for (let e = 0; e < r; e++) {
							c = o;
							a.push(c);
							for (let e = 1; e < i; e++) {
								c = c.add(o);
								a.push(c);
							}
							o = c.double();
						}
						return a;
					},
					wNAF(t, r, i) {
						const { windows: a, windowSize: o } = opts(t);
						let c = e.ZERO;
						let u = e.BASE;
						const l = BigInt(2 ** t - 1);
						const d = 2 ** t;
						const p = BigInt(t);
						for (let e = 0; e < a; e++) {
							const t = e * o;
							let a = Number(i & l);
							i >>= p;
							if (a > o) {
								a -= d;
								i += P;
							}
							const m = t;
							const g = t + Math.abs(a) - 1;
							const v = e % 2 !== 0;
							const y = a < 0;
							if (a === 0) {
								u = u.add(constTimeNegate(v, r[m]));
							} else {
								c = c.add(constTimeNegate(y, r[g]));
							}
						}
						return { p: c, f: u };
					},
					wNAFCached(e, t, r, i) {
						const a = e._WINDOW_SIZE || 1;
						let o = t.get(e);
						if (!o) {
							o = this.precomputeWindow(e, a);
							if (a !== 1) {
								t.set(e, i(o));
							}
						}
						return this.wNAF(a, o, r);
					}
				};
			}
			function validateBasic(e) {
				validateField(e.Fp);
				validateObject(
					e,
					{ n: 'bigint', h: 'bigint', Gx: 'field', Gy: 'field' },
					{ nBitLength: 'isSafeInteger', nByteLength: 'isSafeInteger' }
				);
				return Object.freeze({ ...nLength(e.n, e.nBitLength), ...e, ...{ p: e.Fp.ORDER } });
			}
			function validatePointOpts(e) {
				const t = validateBasic(e);
				validateObject(
					t,
					{ a: 'field', b: 'field' },
					{
						allowedPrivateKeyLengths: 'array',
						wrapPrivateKey: 'boolean',
						isTorsionFree: 'function',
						clearCofactor: 'function',
						allowInfinityPoint: 'boolean',
						fromBytes: 'function',
						toBytes: 'function'
					}
				);
				const { endo: r, Fp: i, a } = t;
				if (r) {
					if (!i.eql(a, i.ZERO)) {
						throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');
					}
					if (
						typeof r !== 'object' ||
						typeof r.beta !== 'bigint' ||
						typeof r.splitScalar !== 'function'
					) {
						throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');
					}
				}
				return Object.freeze({ ...t });
			}
			const { Ph: M, aT: C } = i;
			const I = {
				Err: class DERErr extends Error {
					constructor(e = '') {
						super(e);
					}
				},
				_parseInt(e) {
					const { Err: t } = I;
					if (e.length < 2 || e[0] !== 2) throw new t('Invalid signature integer tag');
					const r = e[1];
					const i = e.subarray(2, r + 2);
					if (!r || i.length !== r) throw new t('Invalid signature integer: wrong length');
					if (i[0] & 128) throw new t('Invalid signature integer: negative');
					if (i[0] === 0 && !(i[1] & 128))
						throw new t('Invalid signature integer: unnecessary leading zero');
					return { d: M(i), l: e.subarray(r + 2) };
				},
				toSig(e) {
					const { Err: t } = I;
					const r = typeof e === 'string' ? C(e) : e;
					if (!(r instanceof Uint8Array)) throw new Error('ui8a expected');
					let i = r.length;
					if (i < 2 || r[0] != 48) throw new t('Invalid signature tag');
					if (r[1] !== i - 2) throw new t('Invalid signature: incorrect length');
					const { d: a, l: o } = I._parseInt(r.subarray(2));
					const { d: c, l: u } = I._parseInt(o);
					if (u.length) throw new t('Invalid signature: left bytes after parsing');
					return { r: a, s: c };
				},
				hexFromSig(e) {
					const slice = (e) => (Number.parseInt(e[0], 16) & 8 ? '00' + e : e);
					const h = (e) => {
						const t = e.toString(16);
						return t.length & 1 ? `0${t}` : t;
					};
					const t = slice(h(e.s));
					const r = slice(h(e.r));
					const i = t.length / 2;
					const a = r.length / 2;
					const o = h(i);
					const c = h(a);
					return `30${h(a + i + 4)}02${c}${r}02${o}${t}`;
				}
			};
			const O = BigInt(0),
				F = BigInt(1),
				D = BigInt(2),
				L = BigInt(3),
				U = BigInt(4);
			function weierstrassPoints(e) {
				const t = validatePointOpts(e);
				const { Fp: r } = t;
				const i =
					t.toBytes ||
					((e, t, i) => {
						const a = t.toAffine();
						return utils_concatBytes(Uint8Array.from([4]), r.toBytes(a.x), r.toBytes(a.y));
					});
				const a =
					t.fromBytes ||
					((e) => {
						const t = e.subarray(1);
						const i = r.fromBytes(t.subarray(0, r.BYTES));
						const a = r.fromBytes(t.subarray(r.BYTES, 2 * r.BYTES));
						return { x: i, y: a };
					});
				function weierstrassEquation(e) {
					const { a: i, b: a } = t;
					const o = r.sqr(e);
					const c = r.mul(o, e);
					return r.add(r.add(c, r.mul(e, i)), a);
				}
				if (!r.eql(r.sqr(t.Gy), weierstrassEquation(t.Gx)))
					throw new Error('bad generator point: equation left != right');
				function isWithinCurveOrder(e) {
					return typeof e === 'bigint' && O < e && e < t.n;
				}
				function assertGE(e) {
					if (!isWithinCurveOrder(e))
						throw new Error('Expected valid bigint: 0 < bigint < curve.n');
				}
				function normPrivateKeyToScalar(e) {
					const { allowedPrivateKeyLengths: r, nByteLength: i, wrapPrivateKey: a, n: o } = t;
					if (r && typeof e !== 'bigint') {
						if (e instanceof Uint8Array) e = bytesToHex(e);
						if (typeof e !== 'string' || !r.includes(e.length)) throw new Error('Invalid key');
						e = e.padStart(i * 2, '0');
					}
					let c;
					try {
						c =
							typeof e === 'bigint'
								? e
								: utils_bytesToNumberBE(utils_ensureBytes('private key', e, i));
					} catch (t) {
						throw new Error(`private key must be ${i} bytes, hex or bigint, not ${typeof e}`);
					}
					if (a) c = modular_mod(c, o);
					assertGE(c);
					return c;
				}
				const o = new Map();
				function assertPrjPoint(e) {
					if (!(e instanceof Point)) throw new Error('ProjectivePoint expected');
				}
				class Point {
					constructor(e, t, i) {
						this.px = e;
						this.py = t;
						this.pz = i;
						if (e == null || !r.isValid(e)) throw new Error('x required');
						if (t == null || !r.isValid(t)) throw new Error('y required');
						if (i == null || !r.isValid(i)) throw new Error('z required');
					}
					static fromAffine(e) {
						const { x: t, y: i } = e || {};
						if (!e || !r.isValid(t) || !r.isValid(i)) throw new Error('invalid affine point');
						if (e instanceof Point) throw new Error('projective point not allowed');
						const is0 = (e) => r.eql(e, r.ZERO);
						if (is0(t) && is0(i)) return Point.ZERO;
						return new Point(t, i, r.ONE);
					}
					get x() {
						return this.toAffine().x;
					}
					get y() {
						return this.toAffine().y;
					}
					static normalizeZ(e) {
						const t = r.invertBatch(e.map((e) => e.pz));
						return e.map((e, r) => e.toAffine(t[r])).map(Point.fromAffine);
					}
					static fromHex(e) {
						const t = Point.fromAffine(a(utils_ensureBytes('pointHex', e)));
						t.assertValidity();
						return t;
					}
					static fromPrivateKey(e) {
						return Point.BASE.multiply(normPrivateKeyToScalar(e));
					}
					_setWindowSize(e) {
						this._WINDOW_SIZE = e;
						o.delete(this);
					}
					assertValidity() {
						if (this.is0()) {
							if (t.allowInfinityPoint && !r.is0(this.py)) return;
							throw new Error('bad point: ZERO');
						}
						const { x: e, y: i } = this.toAffine();
						if (!r.isValid(e) || !r.isValid(i)) throw new Error('bad point: x or y not FE');
						const a = r.sqr(i);
						const o = weierstrassEquation(e);
						if (!r.eql(a, o)) throw new Error('bad point: equation left != right');
						if (!this.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');
					}
					hasEvenY() {
						const { y: e } = this.toAffine();
						if (r.isOdd) return !r.isOdd(e);
						throw new Error("Field doesn't support isOdd");
					}
					equals(e) {
						assertPrjPoint(e);
						const { px: t, py: i, pz: a } = this;
						const { px: o, py: c, pz: u } = e;
						const l = r.eql(r.mul(t, u), r.mul(o, a));
						const d = r.eql(r.mul(i, u), r.mul(c, a));
						return l && d;
					}
					negate() {
						return new Point(this.px, r.neg(this.py), this.pz);
					}
					double() {
						const { a: e, b: i } = t;
						const a = r.mul(i, L);
						const { px: o, py: c, pz: u } = this;
						let l = r.ZERO,
							d = r.ZERO,
							p = r.ZERO;
						let m = r.mul(o, o);
						let g = r.mul(c, c);
						let v = r.mul(u, u);
						let y = r.mul(o, c);
						y = r.add(y, y);
						p = r.mul(o, u);
						p = r.add(p, p);
						l = r.mul(e, p);
						d = r.mul(a, v);
						d = r.add(l, d);
						l = r.sub(g, d);
						d = r.add(g, d);
						d = r.mul(l, d);
						l = r.mul(y, l);
						p = r.mul(a, p);
						v = r.mul(e, v);
						y = r.sub(m, v);
						y = r.mul(e, y);
						y = r.add(y, p);
						p = r.add(m, m);
						m = r.add(p, m);
						m = r.add(m, v);
						m = r.mul(m, y);
						d = r.add(d, m);
						v = r.mul(c, u);
						v = r.add(v, v);
						m = r.mul(v, y);
						l = r.sub(l, m);
						p = r.mul(v, g);
						p = r.add(p, p);
						p = r.add(p, p);
						return new Point(l, d, p);
					}
					add(e) {
						assertPrjPoint(e);
						const { px: i, py: a, pz: o } = this;
						const { px: c, py: u, pz: l } = e;
						let d = r.ZERO,
							p = r.ZERO,
							m = r.ZERO;
						const g = t.a;
						const v = r.mul(t.b, L);
						let y = r.mul(i, c);
						let w = r.mul(a, u);
						let _ = r.mul(o, l);
						let A = r.add(i, a);
						let k = r.add(c, u);
						A = r.mul(A, k);
						k = r.add(y, w);
						A = r.sub(A, k);
						k = r.add(i, o);
						let N = r.add(c, l);
						k = r.mul(k, N);
						N = r.add(y, _);
						k = r.sub(k, N);
						N = r.add(a, o);
						d = r.add(u, l);
						N = r.mul(N, d);
						d = r.add(w, _);
						N = r.sub(N, d);
						m = r.mul(g, k);
						d = r.mul(v, _);
						m = r.add(d, m);
						d = r.sub(w, m);
						m = r.add(w, m);
						p = r.mul(d, m);
						w = r.add(y, y);
						w = r.add(w, y);
						_ = r.mul(g, _);
						k = r.mul(v, k);
						w = r.add(w, _);
						_ = r.sub(y, _);
						_ = r.mul(g, _);
						k = r.add(k, _);
						y = r.mul(w, k);
						p = r.add(p, y);
						y = r.mul(N, k);
						d = r.mul(A, d);
						d = r.sub(d, y);
						y = r.mul(A, w);
						m = r.mul(N, m);
						m = r.add(m, y);
						return new Point(d, p, m);
					}
					subtract(e) {
						return this.add(e.negate());
					}
					is0() {
						return this.equals(Point.ZERO);
					}
					wNAF(e) {
						return u.wNAFCached(this, o, e, (e) => {
							const t = r.invertBatch(e.map((e) => e.pz));
							return e.map((e, r) => e.toAffine(t[r])).map(Point.fromAffine);
						});
					}
					multiplyUnsafe(e) {
						const i = Point.ZERO;
						if (e === O) return i;
						assertGE(e);
						if (e === F) return this;
						const { endo: a } = t;
						if (!a) return u.unsafeLadder(this, e);
						let { k1neg: o, k1: c, k2neg: l, k2: d } = a.splitScalar(e);
						let p = i;
						let m = i;
						let g = this;
						while (c > O || d > O) {
							if (c & F) p = p.add(g);
							if (d & F) m = m.add(g);
							g = g.double();
							c >>= F;
							d >>= F;
						}
						if (o) p = p.negate();
						if (l) m = m.negate();
						m = new Point(r.mul(m.px, a.beta), m.py, m.pz);
						return p.add(m);
					}
					multiply(e) {
						assertGE(e);
						let i = e;
						let a, o;
						const { endo: c } = t;
						if (c) {
							const { k1neg: e, k1: t, k2neg: l, k2: d } = c.splitScalar(i);
							let { p, f: m } = this.wNAF(t);
							let { p: g, f: v } = this.wNAF(d);
							p = u.constTimeNegate(e, p);
							g = u.constTimeNegate(l, g);
							g = new Point(r.mul(g.px, c.beta), g.py, g.pz);
							a = p.add(g);
							o = m.add(v);
						} else {
							const { p: e, f: t } = this.wNAF(i);
							a = e;
							o = t;
						}
						return Point.normalizeZ([a, o])[0];
					}
					multiplyAndAddUnsafe(e, t, r) {
						const i = Point.BASE;
						const mul = (e, t) =>
							t === O || t === F || !e.equals(i) ? e.multiplyUnsafe(t) : e.multiply(t);
						const a = mul(this, t).add(mul(e, r));
						return a.is0() ? undefined : a;
					}
					toAffine(e) {
						const { px: t, py: i, pz: a } = this;
						const o = this.is0();
						if (e == null) e = o ? r.ONE : r.inv(a);
						const c = r.mul(t, e);
						const u = r.mul(i, e);
						const l = r.mul(a, e);
						if (o) return { x: r.ZERO, y: r.ZERO };
						if (!r.eql(l, r.ONE)) throw new Error('invZ was invalid');
						return { x: c, y: u };
					}
					isTorsionFree() {
						const { h: e, isTorsionFree: r } = t;
						if (e === F) return true;
						if (r) return r(Point, this);
						throw new Error('isTorsionFree() has not been declared for the elliptic curve');
					}
					clearCofactor() {
						const { h: e, clearCofactor: r } = t;
						if (e === F) return this;
						if (r) return r(Point, this);
						return this.multiplyUnsafe(t.h);
					}
					toRawBytes(e = true) {
						this.assertValidity();
						return i(Point, this, e);
					}
					toHex(e = true) {
						return bytesToHex(this.toRawBytes(e));
					}
				}
				Point.BASE = new Point(t.Gx, t.Gy, r.ONE);
				Point.ZERO = new Point(r.ZERO, r.ONE, r.ZERO);
				const c = t.nBitLength;
				const u = wNAF(Point, t.endo ? Math.ceil(c / 2) : c);
				return {
					CURVE: t,
					ProjectivePoint: Point,
					normPrivateKeyToScalar,
					weierstrassEquation,
					isWithinCurveOrder
				};
			}
			function validateOpts(e) {
				const t = validateBasic(e);
				validateObject(
					t,
					{ hash: 'hash', hmac: 'function', randomBytes: 'function' },
					{ bits2int: 'function', bits2int_modN: 'function', lowS: 'boolean' }
				);
				return Object.freeze({ lowS: true, ...t });
			}
			function weierstrass(e) {
				const t = validateOpts(e);
				const { Fp: r, n: i } = t;
				const a = r.BYTES + 1;
				const o = 2 * r.BYTES + 1;
				function isValidFieldElement(e) {
					return O < e && e < r.ORDER;
				}
				function modN(e) {
					return modular_mod(e, i);
				}
				function invN(e) {
					return invert(e, i);
				}
				const {
					ProjectivePoint: c,
					normPrivateKeyToScalar: u,
					weierstrassEquation: l,
					isWithinCurveOrder: d
				} = weierstrassPoints({
					...t,
					toBytes(e, t, i) {
						const a = t.toAffine();
						const o = r.toBytes(a.x);
						const c = utils_concatBytes;
						if (i) {
							return c(Uint8Array.from([t.hasEvenY() ? 2 : 3]), o);
						} else {
							return c(Uint8Array.from([4]), o, r.toBytes(a.y));
						}
					},
					fromBytes(e) {
						const t = e.length;
						const i = e[0];
						const c = e.subarray(1);
						if (t === a && (i === 2 || i === 3)) {
							const e = utils_bytesToNumberBE(c);
							if (!isValidFieldElement(e)) throw new Error('Point is not on curve');
							const t = l(e);
							let a = r.sqrt(t);
							const o = (a & F) === F;
							const u = (i & 1) === 1;
							if (u !== o) a = r.neg(a);
							return { x: e, y: a };
						} else if (t === o && i === 4) {
							const e = r.fromBytes(c.subarray(0, r.BYTES));
							const t = r.fromBytes(c.subarray(r.BYTES, 2 * r.BYTES));
							return { x: e, y: t };
						} else {
							throw new Error(
								`Point of length ${t} was invalid. Expected ${a} compressed bytes or ${o} uncompressed bytes`
							);
						}
					}
				});
				const numToNByteStr = (e) => bytesToHex(utils_numberToBytesBE(e, t.nByteLength));
				function isBiggerThanHalfOrder(e) {
					const t = i >> F;
					return e > t;
				}
				function normalizeS(e) {
					return isBiggerThanHalfOrder(e) ? modN(-e) : e;
				}
				const slcNum = (e, t, r) => utils_bytesToNumberBE(e.slice(t, r));
				class Signature {
					constructor(e, t, r) {
						this.r = e;
						this.s = t;
						this.recovery = r;
						this.assertValidity();
					}
					static fromCompact(e) {
						const r = t.nByteLength;
						e = utils_ensureBytes('compactSignature', e, r * 2);
						return new Signature(slcNum(e, 0, r), slcNum(e, r, 2 * r));
					}
					static fromDER(e) {
						const { r: t, s: r } = I.toSig(utils_ensureBytes('DER', e));
						return new Signature(t, r);
					}
					assertValidity() {
						if (!d(this.r)) throw new Error('r must be 0 < r < CURVE.n');
						if (!d(this.s)) throw new Error('s must be 0 < s < CURVE.n');
					}
					addRecoveryBit(e) {
						return new Signature(this.r, this.s, e);
					}
					recoverPublicKey(e) {
						const { r: i, s: a, recovery: o } = this;
						const u = g(utils_ensureBytes('msgHash', e));
						if (o == null || ![0, 1, 2, 3].includes(o)) throw new Error('recovery id invalid');
						const l = o === 2 || o === 3 ? i + t.n : i;
						if (l >= r.ORDER) throw new Error('recovery id 2 or 3 invalid');
						const d = (o & 1) === 0 ? '02' : '03';
						const p = c.fromHex(d + numToNByteStr(l));
						const m = invN(l);
						const v = modN(-u * m);
						const y = modN(a * m);
						const w = c.BASE.multiplyAndAddUnsafe(p, v, y);
						if (!w) throw new Error('point at infinify');
						w.assertValidity();
						return w;
					}
					hasHighS() {
						return isBiggerThanHalfOrder(this.s);
					}
					normalizeS() {
						return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
					}
					toDERRawBytes() {
						return hexToBytes(this.toDERHex());
					}
					toDERHex() {
						return I.hexFromSig({ r: this.r, s: this.s });
					}
					toCompactRawBytes() {
						return hexToBytes(this.toCompactHex());
					}
					toCompactHex() {
						return numToNByteStr(this.r) + numToNByteStr(this.s);
					}
				}
				const p = {
					isValidPrivateKey(e) {
						try {
							u(e);
							return true;
						} catch (e) {
							return false;
						}
					},
					normPrivateKeyToScalar: u,
					randomPrivateKey: () => {
						const e = getMinHashLength(t.n);
						return mapHashToField(t.randomBytes(e), t.n);
					},
					precompute(e = 8, t = c.BASE) {
						t._setWindowSize(e);
						t.multiply(BigInt(3));
						return t;
					}
				};
				function getPublicKey(e, t = true) {
					return c.fromPrivateKey(e).toRawBytes(t);
				}
				function isProbPub(e) {
					const t = e instanceof Uint8Array;
					const r = typeof e === 'string';
					const i = (t || r) && e.length;
					if (t) return i === a || i === o;
					if (r) return i === 2 * a || i === 2 * o;
					if (e instanceof c) return true;
					return false;
				}
				function getSharedSecret(e, t, r = true) {
					if (isProbPub(e)) throw new Error('first arg must be private key');
					if (!isProbPub(t)) throw new Error('second arg must be public key');
					const i = c.fromHex(t);
					return i.multiply(u(e)).toRawBytes(r);
				}
				const m =
					t.bits2int ||
					function (e) {
						const r = utils_bytesToNumberBE(e);
						const i = e.length * 8 - t.nBitLength;
						return i > 0 ? r >> BigInt(i) : r;
					};
				const g =
					t.bits2int_modN ||
					function (e) {
						return modN(m(e));
					};
				const v = bitMask(t.nBitLength);
				function int2octets(e) {
					if (typeof e !== 'bigint') throw new Error('bigint expected');
					if (!(O <= e && e < v)) throw new Error(`bigint expected < 2^${t.nBitLength}`);
					return utils_numberToBytesBE(e, t.nByteLength);
				}
				function prepSig(e, i, a = y) {
					if (['recovered', 'canonical'].some((e) => e in a))
						throw new Error('sign() legacy options not supported');
					const { hash: o, randomBytes: l } = t;
					let { lowS: p, prehash: v, extraEntropy: w } = a;
					if (p == null) p = true;
					e = utils_ensureBytes('msgHash', e);
					if (v) e = utils_ensureBytes('prehashed msgHash', o(e));
					const _ = g(e);
					const A = u(i);
					const k = [int2octets(A), int2octets(_)];
					if (w != null) {
						const e = w === true ? l(r.BYTES) : w;
						k.push(utils_ensureBytes('extraEntropy', e));
					}
					const N = utils_concatBytes(...k);
					const T = _;
					function k2sig(e) {
						const t = m(e);
						if (!d(t)) return;
						const r = invN(t);
						const i = c.BASE.multiply(t).toAffine();
						const a = modN(i.x);
						if (a === O) return;
						const o = modN(r * modN(T + a * A));
						if (o === O) return;
						let u = (i.x === a ? 0 : 2) | Number(i.y & F);
						let l = o;
						if (p && isBiggerThanHalfOrder(o)) {
							l = normalizeS(o);
							u ^= 1;
						}
						return new Signature(a, l, u);
					}
					return { seed: N, k2sig };
				}
				const y = { lowS: t.lowS, prehash: false };
				const w = { lowS: t.lowS, prehash: false };
				function sign(e, r, i = y) {
					const { seed: a, k2sig: o } = prepSig(e, r, i);
					const c = t;
					const u = createHmacDrbg(c.hash.outputLen, c.nByteLength, c.hmac);
					return u(a, o);
				}
				c.BASE._setWindowSize(8);
				function verify(e, r, i, a = w) {
					const o = e;
					r = utils_ensureBytes('msgHash', r);
					i = utils_ensureBytes('publicKey', i);
					if ('strict' in a) throw new Error('options.strict was renamed to lowS');
					const { lowS: u, prehash: l } = a;
					let d = undefined;
					let p;
					try {
						if (typeof o === 'string' || o instanceof Uint8Array) {
							try {
								d = Signature.fromDER(o);
							} catch (e) {
								if (!(e instanceof I.Err)) throw e;
								d = Signature.fromCompact(o);
							}
						} else if (
							typeof o === 'object' &&
							typeof o.r === 'bigint' &&
							typeof o.s === 'bigint'
						) {
							const { r: e, s: t } = o;
							d = new Signature(e, t);
						} else {
							throw new Error('PARSE');
						}
						p = c.fromHex(i);
					} catch (e) {
						if (e.message === 'PARSE')
							throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
						return false;
					}
					if (u && d.hasHighS()) return false;
					if (l) r = t.hash(r);
					const { r: m, s: v } = d;
					const y = g(r);
					const _ = invN(v);
					const A = modN(y * _);
					const k = modN(m * _);
					const N = c.BASE.multiplyAndAddUnsafe(p, A, k)?.toAffine();
					if (!N) return false;
					const T = modN(N.x);
					return T === m;
				}
				return {
					CURVE: t,
					getPublicKey,
					getSharedSecret,
					sign,
					verify,
					ProjectivePoint: c,
					Signature,
					utils: p
				};
			}
			function SWUFpSqrtRatio(e, t) {
				const r = e.ORDER;
				let i = O;
				for (let e = r - F; e % D === O; e /= D) i += F;
				const a = i;
				const o = D << (a - F - F);
				const c = o * D;
				const u = (r - F) / c;
				const l = (u - F) / D;
				const d = c - F;
				const p = o;
				const m = e.pow(t, u);
				const g = e.pow(t, (u + F) / D);
				let sqrtRatio = (t, r) => {
					let i = m;
					let o = e.pow(r, d);
					let c = e.sqr(o);
					c = e.mul(c, r);
					let u = e.mul(t, c);
					u = e.pow(u, l);
					u = e.mul(u, o);
					o = e.mul(u, r);
					c = e.mul(u, t);
					let v = e.mul(c, o);
					u = e.pow(v, p);
					let y = e.eql(u, e.ONE);
					o = e.mul(c, g);
					u = e.mul(v, i);
					c = e.cmov(o, c, y);
					v = e.cmov(u, v, y);
					for (let t = a; t > F; t--) {
						let r = t - D;
						r = D << (r - F);
						let a = e.pow(v, r);
						const u = e.eql(a, e.ONE);
						o = e.mul(c, i);
						i = e.mul(i, i);
						a = e.mul(v, i);
						c = e.cmov(o, c, u);
						v = e.cmov(a, v, u);
					}
					return { isValid: y, value: c };
				};
				if (e.ORDER % U === L) {
					const r = (e.ORDER - L) / U;
					const i = e.sqrt(e.neg(t));
					sqrtRatio = (t, a) => {
						let o = e.sqr(a);
						const c = e.mul(t, a);
						o = e.mul(o, c);
						let u = e.pow(o, r);
						u = e.mul(u, c);
						const l = e.mul(u, i);
						const d = e.mul(e.sqr(u), a);
						const p = e.eql(d, t);
						let m = e.cmov(l, u, p);
						return { isValid: p, value: m };
					};
				}
				return sqrtRatio;
			}
			function weierstrass_mapToCurveSimpleSWU(e, t) {
				mod.validateField(e);
				if (!e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z))
					throw new Error('mapToCurveSimpleSWU: invalid opts');
				const r = SWUFpSqrtRatio(e, t.Z);
				if (!e.isOdd) throw new Error('Fp.isOdd is not implemented!');
				return (i) => {
					let a, o, c, u, l, d, p, m;
					a = e.sqr(i);
					a = e.mul(a, t.Z);
					o = e.sqr(a);
					o = e.add(o, a);
					c = e.add(o, e.ONE);
					c = e.mul(c, t.B);
					u = e.cmov(t.Z, e.neg(o), !e.eql(o, e.ZERO));
					u = e.mul(u, t.A);
					o = e.sqr(c);
					d = e.sqr(u);
					l = e.mul(d, t.A);
					o = e.add(o, l);
					o = e.mul(o, c);
					d = e.mul(d, u);
					l = e.mul(d, t.B);
					o = e.add(o, l);
					p = e.mul(a, c);
					const { isValid: g, value: v } = r(o, d);
					m = e.mul(a, i);
					m = e.mul(m, v);
					p = e.cmov(p, c, g);
					m = e.cmov(m, v, g);
					const y = e.isOdd(i) === e.isOdd(m);
					m = e.cmov(e.neg(m), m, y);
					p = e.div(p, u);
					return { x: p, y: m };
				};
			}
			function getHash(e) {
				return { hash: e, hmac: (t, ...r) => (0, T.w)(e, t, (0, x.Id)(...r)), randomBytes: x.po };
			}
			function createCurve(e, t) {
				const create = (t) => weierstrass({ ...e, ...getHash(t) });
				return Object.freeze({ ...create(t), create });
			}
			const j = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');
			const H = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
			const z = BigInt(1);
			const $ = BigInt(2);
			const divNearest = (e, t) => (e + t / $) / t;
			function sqrtMod(e) {
				const t = j;
				const r = BigInt(3),
					i = BigInt(6),
					a = BigInt(11),
					o = BigInt(22);
				const c = BigInt(23),
					u = BigInt(44),
					l = BigInt(88);
				const d = (e * e * e) % t;
				const p = (d * d * e) % t;
				const m = (pow2(p, r, t) * p) % t;
				const g = (pow2(m, r, t) * p) % t;
				const v = (pow2(g, $, t) * d) % t;
				const y = (pow2(v, a, t) * v) % t;
				const w = (pow2(y, o, t) * y) % t;
				const _ = (pow2(w, u, t) * w) % t;
				const A = (pow2(_, l, t) * _) % t;
				const k = (pow2(A, u, t) * w) % t;
				const N = (pow2(k, r, t) * p) % t;
				const T = (pow2(N, c, t) * y) % t;
				const x = (pow2(T, i, t) * d) % t;
				const B = pow2(x, $, t);
				if (!G.eql(G.sqr(B), e)) throw new Error('Cannot find square root');
				return B;
			}
			const G = Field(j, undefined, undefined, { sqrt: sqrtMod });
			const q = createCurve(
				{
					a: BigInt(0),
					b: BigInt(7),
					Fp: G,
					n: H,
					Gx: BigInt(
						'55066263022277343669578718895168534326250603453777594175500187360389116729240'
					),
					Gy: BigInt(
						'32670510020758816978083085130507043184471273380659243275938904335757337482424'
					),
					h: BigInt(1),
					lowS: true,
					endo: {
						beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
						splitScalar: (e) => {
							const t = H;
							const r = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
							const i = -z * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
							const a = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
							const o = r;
							const c = BigInt('0x100000000000000000000000000000000');
							const u = divNearest(o * e, t);
							const l = divNearest(-i * e, t);
							let d = modular_mod(e - u * r - l * a, t);
							let p = modular_mod(-u * i - l * o, t);
							const m = d > c;
							const g = p > c;
							if (m) d = t - d;
							if (g) p = t - p;
							if (d > c || p > c) {
								throw new Error('splitScalar: Endomorphism failed, k=' + e);
							}
							return { k1neg: m, k1: d, k2neg: g, k2: p };
						}
					}
				},
				a.s
			);
			const V = BigInt(0);
			const fe = (e) => typeof e === 'bigint' && V < e && e < j;
			const ge = (e) => typeof e === 'bigint' && V < e && e < H;
			const W = {};
			function taggedHash(e, ...t) {
				let r = W[e];
				if (r === undefined) {
					const t = sha256(Uint8Array.from(e, (e) => e.charCodeAt(0)));
					r = concatBytes(t, t);
					W[e] = r;
				}
				return sha256(concatBytes(r, ...t));
			}
			const pointToBytes = (e) => e.toRawBytes(true).slice(1);
			const numTo32b = (e) => numberToBytesBE(e, 32);
			const modP = (e) => mod(e, j);
			const modN = (e) => mod(e, H);
			const J = q.ProjectivePoint;
			const GmulAdd = (e, t, r) => J.BASE.multiplyAndAddUnsafe(e, t, r);
			function schnorrGetExtPubKey(e) {
				let t = q.utils.normPrivateKeyToScalar(e);
				let r = J.fromPrivateKey(t);
				const i = r.hasEvenY() ? t : modN(-t);
				return { scalar: i, bytes: pointToBytes(r) };
			}
			function lift_x(e) {
				if (!fe(e)) throw new Error('bad x: need 0 < x < p');
				const t = modP(e * e);
				const r = modP(t * e + BigInt(7));
				let i = sqrtMod(r);
				if (i % $ !== V) i = modP(-i);
				const a = new J(e, i, z);
				a.assertValidity();
				return a;
			}
			function challenge(...e) {
				return modN(bytesToNumberBE(taggedHash('BIP0340/challenge', ...e)));
			}
			function schnorrGetPublicKey(e) {
				return schnorrGetExtPubKey(e).bytes;
			}
			function schnorrSign(e, t, r = randomBytes(32)) {
				const i = ensureBytes('message', e);
				const { bytes: a, scalar: o } = schnorrGetExtPubKey(t);
				const c = ensureBytes('auxRand', r, 32);
				const u = numTo32b(o ^ bytesToNumberBE(taggedHash('BIP0340/aux', c)));
				const l = taggedHash('BIP0340/nonce', u, a, i);
				const d = modN(bytesToNumberBE(l));
				if (d === V) throw new Error('sign failed: k is zero');
				const { bytes: p, scalar: m } = schnorrGetExtPubKey(d);
				const g = challenge(p, a, i);
				const v = new Uint8Array(64);
				v.set(p, 0);
				v.set(numTo32b(modN(m + g * o)), 32);
				if (!schnorrVerify(v, i, a)) throw new Error('sign: Invalid signature produced');
				return v;
			}
			function schnorrVerify(e, t, r) {
				const i = ensureBytes('signature', e, 64);
				const a = ensureBytes('message', t);
				const o = ensureBytes('publicKey', r, 32);
				try {
					const e = lift_x(bytesToNumberBE(o));
					const t = bytesToNumberBE(i.subarray(0, 32));
					if (!fe(t)) return false;
					const r = bytesToNumberBE(i.subarray(32, 64));
					if (!ge(r)) return false;
					const c = challenge(numTo32b(t), pointToBytes(e), a);
					const u = GmulAdd(e, r, modN(-c));
					if (!u || !u.hasEvenY() || u.toAffine().x !== t) return false;
					return true;
				} catch (e) {
					return false;
				}
			}
			const Z =
				null &&
				(() => ({
					getPublicKey: schnorrGetPublicKey,
					sign: schnorrSign,
					verify: schnorrVerify,
					utils: {
						randomPrivateKey: q.utils.randomPrivateKey,
						lift_x,
						pointToBytes,
						numberToBytesBE,
						bytesToNumberBE,
						taggedHash,
						mod
					}
				}))();
			const Q =
				null &&
				(() =>
					isogenyMap(
						G,
						[
							[
								'0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',
								'0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',
								'0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',
								'0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c'
							],
							[
								'0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',
								'0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',
								'0x0000000000000000000000000000000000000000000000000000000000000001'
							],
							[
								'0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',
								'0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',
								'0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',
								'0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84'
							],
							[
								'0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',
								'0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',
								'0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',
								'0x0000000000000000000000000000000000000000000000000000000000000001'
							]
						].map((e) => e.map((e) => BigInt(e)))
					))();
			const Y =
				null &&
				(() =>
					mapToCurveSimpleSWU(G, {
						A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),
						B: BigInt('1771'),
						Z: G.create(BigInt('-11'))
					}))();
			const X =
				null &&
				(() =>
					createHasher(
						q.ProjectivePoint,
						(e) => {
							const { x: t, y: r } = Y(G.create(e[0]));
							return Q(t, r);
						},
						{
							DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',
							encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',
							p: G.ORDER,
							m: 1,
							k: 128,
							expand: 'xmd',
							hash: sha256
						}
					))();
			const ee = null && (() => X.hashToCurve)();
			const te = null && (() => X.encodeToCurve)();
			var re = r(8492);
			var ne = r(6919);
			var ie = r(572);
			var se = r(8249);
			class SigningKey {
				#T;
				constructor(e) {
					(0, re.MR)((0, ne.pO)(e) === 32, 'invalid private key', 'privateKey', '[REDACTED]');
					this.#T = (0, ne.c$)(e);
				}
				get privateKey() {
					return this.#T;
				}
				get publicKey() {
					return SigningKey.computePublicKey(this.#T);
				}
				get compressedPublicKey() {
					return SigningKey.computePublicKey(this.#T, true);
				}
				sign(e) {
					(0, re.MR)((0, ne.pO)(e) === 32, 'invalid digest length', 'digest', e);
					const t = q.sign((0, ne.Lm)(e), (0, ne.Lm)(this.#T), { lowS: true });
					return se.t.from({
						r: (0, ie.up)(t.r, 32),
						s: (0, ie.up)(t.s, 32),
						v: t.recovery ? 28 : 27
					});
				}
				computeSharedSecret(e) {
					const t = SigningKey.computePublicKey(e);
					return (0, ne.c$)(q.getSharedSecret((0, ne.Lm)(this.#T), (0, ne.q5)(t), false));
				}
				static computePublicKey(e, t) {
					let r = (0, ne.q5)(e, 'key');
					if (r.length === 32) {
						const e = q.getPublicKey(r, !!t);
						return (0, ne.c$)(e);
					}
					if (r.length === 64) {
						const e = new Uint8Array(65);
						e[0] = 4;
						e.set(r, 1);
						r = e;
					}
					const i = q.ProjectivePoint.fromHex(r);
					return (0, ne.c$)(i.toRawBytes(t));
				}
				static recoverPublicKey(e, t) {
					(0, re.MR)((0, ne.pO)(e) === 32, 'invalid digest length', 'digest', e);
					const r = se.t.from(t);
					let i = q.Signature.fromCompact((0, ne.Lm)((0, ne.xW)([r.r, r.s])));
					i = i.addRecoveryBit(r.yParity);
					const a = i.recoverPublicKey((0, ne.Lm)(e));
					(0, re.MR)(a != null, 'invalid signautre for digest', 'signature', t);
					return '0x' + a.toHex(false);
				}
				static addPoints(e, t, r) {
					const i = q.ProjectivePoint.fromHex(SigningKey.computePublicKey(e).substring(2));
					const a = q.ProjectivePoint.fromHex(SigningKey.computePublicKey(t).substring(2));
					return '0x' + i.add(a).toHex(!!r);
				}
			}
		},
		8425: (e, t, r) => {
			'use strict';
			r.d(t, { id: () => id });
			var i = r(822);
			var a = r(7756);
			function id(e) {
				return (0, i.S)((0, a.YW)(e));
			}
		},
		3944: (e, t, r) => {
			'use strict';
			r.d(t, { A: () => hashMessage });
			var i = r(822);
			const a = '';
			const o = 'Ethereum Signed Message:\n';
			var c = r(7756);
			var u = r(6919);
			function hashMessage(e) {
				if (typeof e === 'string') {
					e = (0, c.YW)(e);
				}
				return (0, i.S)((0, u.xW)([(0, c.YW)(o), (0, c.YW)(String(e.length)), e]));
			}
			function verifyMessage(e, t) {
				const r = hashMessage(e);
				return recoverAddress(r, t);
			}
		},
		5647: (e, t, r) => {
			'use strict';
			r.d(t, { z: () => TypedDataEncoder });
			var i = r(6686);
			var a = r(822);
			var o = r(6919);
			var c = r(572);
			var u = r(8492);
			var l = r(4918);
			var d = r(8425);
			const p = new Uint8Array(32);
			p.fill(0);
			const m = BigInt(-1);
			const g = BigInt(0);
			const v = BigInt(1);
			const y = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
			function hexPadRight(e) {
				const t = (0, o.q5)(e);
				const r = t.length % 32;
				if (r) {
					return (0, o.xW)([t, p.slice(r)]);
				}
				return (0, o.c$)(t);
			}
			const w = (0, c.up)(v, 32);
			const _ = (0, c.up)(g, 32);
			const A = {
				name: 'string',
				version: 'string',
				chainId: 'uint256',
				verifyingContract: 'address',
				salt: 'bytes32'
			};
			const k = ['name', 'version', 'chainId', 'verifyingContract', 'salt'];
			function checkString(e) {
				return function (t) {
					(0, u.MR)(
						typeof t === 'string',
						`invalid domain value for ${JSON.stringify(e)}`,
						`domain.${e}`,
						t
					);
					return t;
				};
			}
			const N = {
				name: checkString('name'),
				version: checkString('version'),
				chainId: function (e) {
					const t = (0, c.Ab)(e, 'domain.chainId');
					(0, u.MR)(t >= 0, 'invalid chain ID', 'domain.chainId', e);
					if (Number.isSafeInteger(t)) {
						return Number(t);
					}
					return (0, c.nD)(t);
				},
				verifyingContract: function (e) {
					try {
						return (0, i.b)(e).toLowerCase();
					} catch (e) {}
					(0, u.MR)(
						false,
						`invalid domain value "verifyingContract"`,
						'domain.verifyingContract',
						e
					);
				},
				salt: function (e) {
					const t = (0, o.q5)(e, 'domain.salt');
					(0, u.MR)(t.length === 32, `invalid domain value "salt"`, 'domain.salt', e);
					return (0, o.c$)(t);
				}
			};
			function getBaseEncoder(e) {
				{
					const t = e.match(/^(u?)int(\d+)$/);
					if (t) {
						const r = t[1] === '';
						const i = parseInt(t[2]);
						(0, u.MR)(
							i % 8 === 0 && i !== 0 && i <= 256 && t[2] === String(i),
							'invalid numeric width',
							'type',
							e
						);
						const a = (0, c.dK)(y, r ? i - 1 : i);
						const o = r ? (a + v) * m : g;
						return function (t) {
							const i = (0, c.Ab)(t, 'value');
							(0, u.MR)(i >= o && i <= a, `value out-of-bounds for ${e}`, 'value', i);
							return (0, c.up)(r ? (0, c.JJ)(i, 256) : i, 32);
						};
					}
				}
				{
					const t = e.match(/^bytes(\d+)$/);
					if (t) {
						const r = parseInt(t[1]);
						(0, u.MR)(r !== 0 && r <= 32 && t[1] === String(r), 'invalid bytes width', 'type', e);
						return function (t) {
							const i = (0, o.q5)(t);
							(0, u.MR)(i.length === r, `invalid length for ${e}`, 'value', t);
							return hexPadRight(t);
						};
					}
				}
				switch (e) {
					case 'address':
						return function (e) {
							return (0, o.nx)((0, i.b)(e), 32);
						};
					case 'bool':
						return function (e) {
							return !e ? _ : w;
						};
					case 'bytes':
						return function (e) {
							return (0, a.S)(e);
						};
					case 'string':
						return function (e) {
							return (0, d.id)(e);
						};
				}
				return null;
			}
			function encodeType(e, t) {
				return `${e}(${t.map(({ name: e, type: t }) => t + ' ' + e).join(',')})`;
			}
			function splitArray(e) {
				const t = e.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
				if (t) {
					return {
						base: t[1],
						index: t[2] + t[4],
						array: { base: t[1], prefix: t[1] + t[2], count: t[5] ? parseInt(t[5]) : -1 }
					};
				}
				return { base: e };
			}
			class TypedDataEncoder {
				primaryType;
				#x;
				get types() {
					return JSON.parse(this.#x);
				}
				#B;
				#R;
				constructor(e) {
					this.#B = new Map();
					this.#R = new Map();
					const t = new Map();
					const r = new Map();
					const i = new Map();
					const a = {};
					Object.keys(e).forEach((o) => {
						a[o] = e[o].map(({ name: t, type: r }) => {
							let { base: i, index: a } = splitArray(r);
							if (i === 'int' && !e['int']) {
								i = 'int256';
							}
							if (i === 'uint' && !e['uint']) {
								i = 'uint256';
							}
							return { name: t, type: i + (a || '') };
						});
						t.set(o, new Set());
						r.set(o, []);
						i.set(o, new Set());
					});
					this.#x = JSON.stringify(a);
					for (const i in a) {
						const o = new Set();
						for (const c of a[i]) {
							(0, u.MR)(
								!o.has(c.name),
								`duplicate variable name ${JSON.stringify(c.name)} in ${JSON.stringify(i)}`,
								'types',
								e
							);
							o.add(c.name);
							const a = splitArray(c.type).base;
							(0, u.MR)(a !== i, `circular type reference to ${JSON.stringify(a)}`, 'types', e);
							const l = getBaseEncoder(a);
							if (l) {
								continue;
							}
							(0, u.MR)(r.has(a), `unknown type ${JSON.stringify(a)}`, 'types', e);
							r.get(a).push(i);
							t.get(i).add(a);
						}
					}
					const o = Array.from(r.keys()).filter((e) => r.get(e).length === 0);
					(0, u.MR)(o.length !== 0, 'missing primary type', 'types', e);
					(0, u.MR)(
						o.length === 1,
						`ambiguous primary types or unused types: ${o.map((e) => JSON.stringify(e)).join(', ')}`,
						'types',
						e
					);
					(0, l.n)(this, { primaryType: o[0] });
					function checkCircular(a, o) {
						(0, u.MR)(!o.has(a), `circular type reference to ${JSON.stringify(a)}`, 'types', e);
						o.add(a);
						for (const e of t.get(a)) {
							if (!r.has(e)) {
								continue;
							}
							checkCircular(e, o);
							for (const t of o) {
								i.get(t).add(e);
							}
						}
						o.delete(a);
					}
					checkCircular(this.primaryType, new Set());
					for (const [e, t] of i) {
						const r = Array.from(t);
						r.sort();
						this.#B.set(e, encodeType(e, a[e]) + r.map((e) => encodeType(e, a[e])).join(''));
					}
				}
				getEncoder(e) {
					let t = this.#R.get(e);
					if (!t) {
						t = this.#P(e);
						this.#R.set(e, t);
					}
					return t;
				}
				#P(e) {
					{
						const t = getBaseEncoder(e);
						if (t) {
							return t;
						}
					}
					const t = splitArray(e).array;
					if (t) {
						const e = t.prefix;
						const r = this.getEncoder(e);
						return (i) => {
							(0, u.MR)(
								t.count === -1 || t.count === i.length,
								`array length mismatch; expected length ${t.count}`,
								'value',
								i
							);
							let c = i.map(r);
							if (this.#B.has(e)) {
								c = c.map(a.S);
							}
							return (0, a.S)((0, o.xW)(c));
						};
					}
					const r = this.types[e];
					if (r) {
						const t = (0, d.id)(this.#B.get(e));
						return (e) => {
							const i = r.map(({ name: t, type: r }) => {
								const i = this.getEncoder(r)(e[t]);
								if (this.#B.has(r)) {
									return (0, a.S)(i);
								}
								return i;
							});
							i.unshift(t);
							return (0, o.xW)(i);
						};
					}
					(0, u.MR)(false, `unknown type: ${e}`, 'type', e);
				}
				encodeType(e) {
					const t = this.#B.get(e);
					(0, u.MR)(t, `unknown type: ${JSON.stringify(e)}`, 'name', e);
					return t;
				}
				encodeData(e, t) {
					return this.getEncoder(e)(t);
				}
				hashStruct(e, t) {
					return (0, a.S)(this.encodeData(e, t));
				}
				encode(e) {
					return this.encodeData(this.primaryType, e);
				}
				hash(e) {
					return this.hashStruct(this.primaryType, e);
				}
				_visit(e, t, r) {
					{
						const i = getBaseEncoder(e);
						if (i) {
							return r(e, t);
						}
					}
					const i = splitArray(e).array;
					if (i) {
						(0, u.MR)(
							i.count === -1 || i.count === t.length,
							`array length mismatch; expected length ${i.count}`,
							'value',
							t
						);
						return t.map((e) => this._visit(i.prefix, e, r));
					}
					const a = this.types[e];
					if (a) {
						return a.reduce((e, { name: i, type: a }) => {
							e[i] = this._visit(a, t[i], r);
							return e;
						}, {});
					}
					(0, u.MR)(false, `unknown type: ${e}`, 'type', e);
				}
				visit(e, t) {
					return this._visit(this.primaryType, e, t);
				}
				static from(e) {
					return new TypedDataEncoder(e);
				}
				static getPrimaryType(e) {
					return TypedDataEncoder.from(e).primaryType;
				}
				static hashStruct(e, t, r) {
					return TypedDataEncoder.from(t).hashStruct(e, r);
				}
				static hashDomain(e) {
					const t = [];
					for (const r in e) {
						if (e[r] == null) {
							continue;
						}
						const i = A[r];
						(0, u.MR)(i, `invalid typed-data domain key: ${JSON.stringify(r)}`, 'domain', e);
						t.push({ name: r, type: i });
					}
					t.sort((e, t) => k.indexOf(e.name) - k.indexOf(t.name));
					return TypedDataEncoder.hashStruct('EIP712Domain', { EIP712Domain: t }, e);
				}
				static encode(e, t, r) {
					return (0, o.xW)([
						'0x1901',
						TypedDataEncoder.hashDomain(e),
						TypedDataEncoder.from(t).hash(r)
					]);
				}
				static hash(e, t, r) {
					return (0, a.S)(TypedDataEncoder.encode(e, t, r));
				}
				static async resolveNames(e, t, r, i) {
					e = Object.assign({}, e);
					for (const t in e) {
						if (e[t] == null) {
							delete e[t];
						}
					}
					const a = {};
					if (e.verifyingContract && !(0, o.Lo)(e.verifyingContract, 20)) {
						a[e.verifyingContract] = '0x';
					}
					const c = TypedDataEncoder.from(t);
					c.visit(r, (e, t) => {
						if (e === 'address' && !(0, o.Lo)(t, 20)) {
							a[t] = '0x';
						}
						return t;
					});
					for (const e in a) {
						a[e] = await i(e);
					}
					if (e.verifyingContract && a[e.verifyingContract]) {
						e.verifyingContract = a[e.verifyingContract];
					}
					r = c.visit(r, (e, t) => {
						if (e === 'address' && a[t]) {
							return a[t];
						}
						return t;
					});
					return { domain: e, value: r };
				}
				static getPayload(e, t, r) {
					TypedDataEncoder.hashDomain(e);
					const i = {};
					const a = [];
					k.forEach((t) => {
						const r = e[t];
						if (r == null) {
							return;
						}
						i[t] = N[t](r);
						a.push({ name: t, type: A[t] });
					});
					const l = TypedDataEncoder.from(t);
					t = l.types;
					const d = Object.assign({}, t);
					(0, u.MR)(
						d.EIP712Domain == null,
						'types must not contain EIP712Domain type',
						'types.EIP712Domain',
						t
					);
					d.EIP712Domain = a;
					l.encode(r);
					return {
						types: d,
						domain: i,
						primaryType: l.primaryType,
						message: l.visit(r, (e, t) => {
							if (e.match(/^bytes(\d*)/)) {
								return (0, o.c$)((0, o.q5)(t));
							}
							if (e.match(/^u?int/)) {
								return (0, c.Ab)(t).toString();
							}
							switch (e) {
								case 'address':
									return t.toLowerCase();
								case 'bool':
									return !!t;
								case 'string':
									(0, u.MR)(typeof t === 'string', 'invalid string', 'value', t);
									return t;
							}
							(0, u.MR)(false, 'unsupported type', 'type', e);
						})
					};
				}
			}
			function verifyTypedData(e, t, r, i) {
				return recoverAddress(TypedDataEncoder.hash(e, t, r), i);
			}
		},
		6959: (e, t, r) => {
			'use strict';
			r.d(t, { J: () => VoidSigner, Z: () => AbstractSigner });
			var i = r(2857);
			var a = r(7818);
			var o = r(8492);
			var c = r(4918);
			var u = r(572);
			var l = r(3679);
			function checkProvider(e, t) {
				if (e.provider) {
					return e.provider;
				}
				(0, o.vA)(false, 'missing provider', 'UNSUPPORTED_OPERATION', { operation: t });
			}
			async function populate(e, t) {
				let r = (0, l.VS)(t);
				if (r.to != null) {
					r.to = (0, i.tG)(r.to, e);
				}
				if (r.from != null) {
					const t = r.from;
					r.from = Promise.all([e.getAddress(), (0, i.tG)(t, e)]).then(([e, t]) => {
						(0, o.MR)(
							e.toLowerCase() === t.toLowerCase(),
							'transaction from mismatch',
							'tx.from',
							t
						);
						return e;
					});
				} else {
					r.from = e.getAddress();
				}
				return await (0, c.k)(r);
			}
			class AbstractSigner {
				provider;
				constructor(e) {
					(0, c.n)(this, { provider: e || null });
				}
				async getNonce(e) {
					return checkProvider(this, 'getTransactionCount').getTransactionCount(
						await this.getAddress(),
						e
					);
				}
				async populateCall(e) {
					const t = await populate(this, e);
					return t;
				}
				async populateTransaction(e) {
					const t = checkProvider(this, 'populateTransaction');
					const r = await populate(this, e);
					if (r.nonce == null) {
						r.nonce = await this.getNonce('pending');
					}
					if (r.gasLimit == null) {
						r.gasLimit = await this.estimateGas(r);
					}
					const i = await this.provider.getNetwork();
					if (r.chainId != null) {
						const t = (0, u.Ab)(r.chainId);
						(0, o.MR)(t === i.chainId, 'transaction chainId mismatch', 'tx.chainId', e.chainId);
					} else {
						r.chainId = i.chainId;
					}
					const a = r.maxFeePerGas != null || r.maxPriorityFeePerGas != null;
					if (r.gasPrice != null && (r.type === 2 || a)) {
						(0, o.MR)(false, 'eip-1559 transaction do not support gasPrice', 'tx', e);
					} else if ((r.type === 0 || r.type === 1) && a) {
						(0, o.MR)(
							false,
							'pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas',
							'tx',
							e
						);
					}
					if (
						(r.type === 2 || r.type == null) &&
						r.maxFeePerGas != null &&
						r.maxPriorityFeePerGas != null
					) {
						r.type = 2;
					} else if (r.type === 0 || r.type === 1) {
						const e = await t.getFeeData();
						(0, o.vA)(
							e.gasPrice != null,
							'network does not support gasPrice',
							'UNSUPPORTED_OPERATION',
							{ operation: 'getGasPrice' }
						);
						if (r.gasPrice == null) {
							r.gasPrice = e.gasPrice;
						}
					} else {
						const e = await t.getFeeData();
						if (r.type == null) {
							if (e.maxFeePerGas != null && e.maxPriorityFeePerGas != null) {
								r.type = 2;
								if (r.gasPrice != null) {
									const e = r.gasPrice;
									delete r.gasPrice;
									r.maxFeePerGas = e;
									r.maxPriorityFeePerGas = e;
								} else {
									if (r.maxFeePerGas == null) {
										r.maxFeePerGas = e.maxFeePerGas;
									}
									if (r.maxPriorityFeePerGas == null) {
										r.maxPriorityFeePerGas = e.maxPriorityFeePerGas;
									}
								}
							} else if (e.gasPrice != null) {
								(0, o.vA)(!a, 'network does not support EIP-1559', 'UNSUPPORTED_OPERATION', {
									operation: 'populateTransaction'
								});
								if (r.gasPrice == null) {
									r.gasPrice = e.gasPrice;
								}
								r.type = 0;
							} else {
								(0, o.vA)(false, 'failed to get consistent fee data', 'UNSUPPORTED_OPERATION', {
									operation: 'signer.getFeeData'
								});
							}
						} else if (r.type === 2 || r.type === 3) {
							if (r.maxFeePerGas == null) {
								r.maxFeePerGas = e.maxFeePerGas;
							}
							if (r.maxPriorityFeePerGas == null) {
								r.maxPriorityFeePerGas = e.maxPriorityFeePerGas;
							}
						}
					}
					return await (0, c.k)(r);
				}
				async estimateGas(e) {
					return checkProvider(this, 'estimateGas').estimateGas(await this.populateCall(e));
				}
				async call(e) {
					return checkProvider(this, 'call').call(await this.populateCall(e));
				}
				async resolveName(e) {
					const t = checkProvider(this, 'resolveName');
					return await t.resolveName(e);
				}
				async sendTransaction(e) {
					const t = checkProvider(this, 'sendTransaction');
					const r = await this.populateTransaction(e);
					delete r.from;
					const i = a.Z.from(r);
					return await t.broadcastTransaction(await this.signTransaction(i));
				}
			}
			class VoidSigner extends AbstractSigner {
				address;
				constructor(e, t) {
					super(t);
					(0, c.n)(this, { address: e });
				}
				async getAddress() {
					return this.address;
				}
				connect(e) {
					return new VoidSigner(this.address, e);
				}
				#M(e, t) {
					(0, o.vA)(false, `VoidSigner cannot sign ${e}`, 'UNSUPPORTED_OPERATION', {
						operation: t
					});
				}
				async signTransaction(e) {
					this.#M('transactions', 'signTransaction');
				}
				async signMessage(e) {
					this.#M('messages', 'signMessage');
				}
				async signTypedData(e, t, r) {
					this.#M('typed-data', 'signTypedData');
				}
			}
		},
		547: (e, t, r) => {
			'use strict';
			r.d(t, { FR: () => JsonRpcProvider });
			var i = r(1586);
			var a = r(6686);
			var o = r(2857);
			var c = r(5647);
			var u = r(7486);
			var l = r(4918);
			var d = r(8492);
			var p = r(7756);
			var m = r(6919);
			var g = r(572);
			function decodeBase64(e) {
				e = atob(e);
				const t = new Uint8Array(e.length);
				for (let r = 0; r < e.length; r++) {
					t[r] = e.charCodeAt(r);
				}
				return (0, m.q5)(t);
			}
			function encodeBase64(e) {
				const t = (0, m.q5)(e);
				let r = '';
				for (let e = 0; e < t.length; e++) {
					r += String.fromCharCode(t[e]);
				}
				return btoa(r);
			}
			function createGetUrl(e) {
				async function getUrl(e, t) {
					(0, d.vA)(t == null || !t.cancelled, 'request cancelled before sending', 'CANCELLED');
					const r = e.url.split(':')[0].toLowerCase();
					(0, d.vA)(
						r === 'http' || r === 'https',
						`unsupported protocol ${r}`,
						'UNSUPPORTED_OPERATION',
						{ info: { protocol: r }, operation: 'request' }
					);
					(0, d.vA)(
						r === 'https' || !e.credentials || e.allowInsecureAuthentication,
						'insecure authorized connections unsupported',
						'UNSUPPORTED_OPERATION',
						{ operation: 'request' }
					);
					let i = null;
					const a = new AbortController();
					const o = setTimeout(() => {
						i = (0, d.xz)('request timeout', 'TIMEOUT');
						a.abort();
					}, e.timeout);
					if (t) {
						t.addListener(() => {
							i = (0, d.xz)('request cancelled', 'CANCELLED');
							a.abort();
						});
					}
					const c = {
						method: e.method,
						headers: new Headers(Array.from(e)),
						body: e.body || undefined,
						signal: a.signal
					};
					let u;
					try {
						u = await fetch(e.url, c);
					} catch (e) {
						clearTimeout(o);
						if (i) {
							throw i;
						}
						throw e;
					}
					clearTimeout(o);
					const l = {};
					u.headers.forEach((e, t) => {
						l[t.toLowerCase()] = e;
					});
					const p = await u.arrayBuffer();
					const m = p == null ? null : new Uint8Array(p);
					return { statusCode: u.status, statusMessage: u.statusText, headers: l, body: m };
				}
				return getUrl;
			}
			const v = createGetUrl({});
			async function getUrl(e, t) {
				return v(e, t);
			}
			const y = 12;
			const w = 250;
			let _ = createGetUrl();
			const A = new RegExp('^data:([^;:]*)?(;base64)?,(.*)$', 'i');
			const k = new RegExp('^ipfs://(ipfs/)?(.*)$', 'i');
			let N = false;
			async function dataGatewayFunc(e, t) {
				try {
					const t = e.match(A);
					if (!t) {
						throw new Error('invalid data');
					}
					return new FetchResponse(
						200,
						'OK',
						{ 'content-type': t[1] || 'text/plain' },
						t[2] ? decodeBase64(t[3]) : unpercent(t[3])
					);
				} catch (t) {
					return new FetchResponse(
						599,
						'BAD REQUEST (invalid data: URI)',
						{},
						null,
						new FetchRequest(e)
					);
				}
			}
			function getIpfsGatewayFunc(e) {
				async function gatewayIpfs(t, r) {
					try {
						const r = t.match(k);
						if (!r) {
							throw new Error('invalid link');
						}
						return new FetchRequest(`${e}${r[2]}`);
					} catch (e) {
						return new FetchResponse(
							599,
							'BAD REQUEST (invalid IPFS URI)',
							{},
							null,
							new FetchRequest(t)
						);
					}
				}
				return gatewayIpfs;
			}
			const T = {
				data: dataGatewayFunc,
				ipfs: getIpfsGatewayFunc('https://gateway.ipfs.io/ipfs/')
			};
			const x = new WeakMap();
			class FetchCancelSignal {
				#C;
				#I;
				constructor(e) {
					this.#C = [];
					this.#I = false;
					x.set(e, () => {
						if (this.#I) {
							return;
						}
						this.#I = true;
						for (const e of this.#C) {
							setTimeout(() => {
								e();
							}, 0);
						}
						this.#C = [];
					});
				}
				addListener(e) {
					(0, d.vA)(!this.#I, 'singal already cancelled', 'UNSUPPORTED_OPERATION', {
						operation: 'fetchCancelSignal.addCancelListener'
					});
					this.#C.push(e);
				}
				get cancelled() {
					return this.#I;
				}
				checkSignal() {
					(0, d.vA)(!this.cancelled, 'cancelled', 'CANCELLED', {});
				}
			}
			function checkSignal(e) {
				if (e == null) {
					throw new Error('missing signal; should not happen');
				}
				e.checkSignal();
				return e;
			}
			class FetchRequest {
				#O;
				#F;
				#D;
				#L;
				#U;
				#j;
				#H;
				#z;
				#$;
				#G;
				#q;
				#V;
				#K;
				#W;
				#J;
				get url() {
					return this.#j;
				}
				set url(e) {
					this.#j = String(e);
				}
				get body() {
					if (this.#H == null) {
						return null;
					}
					return new Uint8Array(this.#H);
				}
				set body(e) {
					if (e == null) {
						this.#H = undefined;
						this.#z = undefined;
					} else if (typeof e === 'string') {
						this.#H = (0, p.YW)(e);
						this.#z = 'text/plain';
					} else if (e instanceof Uint8Array) {
						this.#H = e;
						this.#z = 'application/octet-stream';
					} else if (typeof e === 'object') {
						this.#H = (0, p.YW)(JSON.stringify(e));
						this.#z = 'application/json';
					} else {
						throw new Error('invalid body');
					}
				}
				hasBody() {
					return this.#H != null;
				}
				get method() {
					if (this.#L) {
						return this.#L;
					}
					if (this.hasBody()) {
						return 'POST';
					}
					return 'GET';
				}
				set method(e) {
					if (e == null) {
						e = '';
					}
					this.#L = String(e).toUpperCase();
				}
				get headers() {
					const e = Object.assign({}, this.#D);
					if (this.#$) {
						e['authorization'] = `Basic ${encodeBase64((0, p.YW)(this.#$))}`;
					}
					if (this.allowGzip) {
						e['accept-encoding'] = 'gzip';
					}
					if (e['content-type'] == null && this.#z) {
						e['content-type'] = this.#z;
					}
					if (this.body) {
						e['content-length'] = String(this.body.length);
					}
					return e;
				}
				getHeader(e) {
					return this.headers[e.toLowerCase()];
				}
				setHeader(e, t) {
					this.#D[String(e).toLowerCase()] = String(t);
				}
				clearHeaders() {
					this.#D = {};
				}
				[Symbol.iterator]() {
					const e = this.headers;
					const t = Object.keys(e);
					let r = 0;
					return {
						next: () => {
							if (r < t.length) {
								const i = t[r++];
								return { value: [i, e[i]], done: false };
							}
							return { value: undefined, done: true };
						}
					};
				}
				get credentials() {
					return this.#$ || null;
				}
				setCredentials(e, t) {
					(0, d.MR)(
						!e.match(/:/),
						'invalid basic authentication username',
						'username',
						'[REDACTED]'
					);
					this.#$ = `${e}:${t}`;
				}
				get allowGzip() {
					return this.#F;
				}
				set allowGzip(e) {
					this.#F = !!e;
				}
				get allowInsecureAuthentication() {
					return !!this.#O;
				}
				set allowInsecureAuthentication(e) {
					this.#O = !!e;
				}
				get timeout() {
					return this.#U;
				}
				set timeout(e) {
					(0, d.MR)(e >= 0, 'timeout must be non-zero', 'timeout', e);
					this.#U = e;
				}
				get preflightFunc() {
					return this.#G || null;
				}
				set preflightFunc(e) {
					this.#G = e;
				}
				get processFunc() {
					return this.#q || null;
				}
				set processFunc(e) {
					this.#q = e;
				}
				get retryFunc() {
					return this.#V || null;
				}
				set retryFunc(e) {
					this.#V = e;
				}
				get getUrlFunc() {
					return this.#J || _;
				}
				set getUrlFunc(e) {
					this.#J = e;
				}
				constructor(e) {
					this.#j = String(e);
					this.#O = false;
					this.#F = true;
					this.#D = {};
					this.#L = '';
					this.#U = 3e5;
					this.#W = { slotInterval: w, maxAttempts: y };
					this.#J = null;
				}
				toString() {
					return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#H ? (0, m.c$)(this.#H) : 'null'}>`;
				}
				setThrottleParams(e) {
					if (e.slotInterval != null) {
						this.#W.slotInterval = e.slotInterval;
					}
					if (e.maxAttempts != null) {
						this.#W.maxAttempts = e.maxAttempts;
					}
				}
				async #Z(e, t, r, i, a) {
					if (e >= this.#W.maxAttempts) {
						return a.makeServerError('exceeded maximum retry limit');
					}
					(0, d.vA)(getTime() <= t, 'timeout', 'TIMEOUT', {
						operation: 'request.send',
						reason: 'timeout',
						request: i
					});
					if (r > 0) {
						await wait(r);
					}
					let o = this.clone();
					const c = (o.url.split(':')[0] || '').toLowerCase();
					if (c in T) {
						const e = await T[c](o.url, checkSignal(i.#K));
						if (e instanceof FetchResponse) {
							let t = e;
							if (this.processFunc) {
								checkSignal(i.#K);
								try {
									t = await this.processFunc(o, t);
								} catch (e) {
									if (e.throttle == null || typeof e.stall !== 'number') {
										t.makeServerError('error in post-processing function', e).assertOk();
									}
								}
							}
							return t;
						}
						o = e;
					}
					if (this.preflightFunc) {
						o = await this.preflightFunc(o);
					}
					const u = await this.getUrlFunc(o, checkSignal(i.#K));
					let l = new FetchResponse(u.statusCode, u.statusMessage, u.headers, u.body, i);
					if (l.statusCode === 301 || l.statusCode === 302) {
						try {
							const r = l.headers.location || '';
							return o.redirect(r).#Z(e + 1, t, 0, i, l);
						} catch (e) {}
						return l;
					} else if (l.statusCode === 429) {
						if (this.retryFunc == null || (await this.retryFunc(o, l, e))) {
							const r = l.headers['retry-after'];
							let a = this.#W.slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
							if (typeof r === 'string' && r.match(/^[1-9][0-9]*$/)) {
								a = parseInt(r);
							}
							return o.clone().#Z(e + 1, t, a, i, l);
						}
					}
					if (this.processFunc) {
						checkSignal(i.#K);
						try {
							l = await this.processFunc(o, l);
						} catch (r) {
							if (r.throttle == null || typeof r.stall !== 'number') {
								l.makeServerError('error in post-processing function', r).assertOk();
							}
							let a = this.#W.slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
							if (r.stall >= 0) {
								a = r.stall;
							}
							return o.clone().#Z(e + 1, t, a, i, l);
						}
					}
					return l;
				}
				send() {
					(0, d.vA)(this.#K == null, 'request already sent', 'UNSUPPORTED_OPERATION', {
						operation: 'fetchRequest.send'
					});
					this.#K = new FetchCancelSignal(this);
					return this.#Z(
						0,
						getTime() + this.timeout,
						0,
						this,
						new FetchResponse(0, '', {}, null, this)
					);
				}
				cancel() {
					(0, d.vA)(this.#K != null, 'request has not been sent', 'UNSUPPORTED_OPERATION', {
						operation: 'fetchRequest.cancel'
					});
					const e = x.get(this);
					if (!e) {
						throw new Error('missing signal; should not happen');
					}
					e();
				}
				redirect(e) {
					const t = this.url.split(':')[0].toLowerCase();
					const r = e.split(':')[0].toLowerCase();
					(0, d.vA)(
						this.method === 'GET' && (t !== 'https' || r !== 'http') && e.match(/^https?:/),
						`unsupported redirect`,
						'UNSUPPORTED_OPERATION',
						{
							operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(e)})`
						}
					);
					const i = new FetchRequest(e);
					i.method = 'GET';
					i.allowGzip = this.allowGzip;
					i.timeout = this.timeout;
					i.#D = Object.assign({}, this.#D);
					if (this.#H) {
						i.#H = new Uint8Array(this.#H);
					}
					i.#z = this.#z;
					return i;
				}
				clone() {
					const e = new FetchRequest(this.url);
					e.#L = this.#L;
					if (this.#H) {
						e.#H = this.#H;
					}
					e.#z = this.#z;
					e.#D = Object.assign({}, this.#D);
					e.#$ = this.#$;
					if (this.allowGzip) {
						e.allowGzip = true;
					}
					e.timeout = this.timeout;
					if (this.allowInsecureAuthentication) {
						e.allowInsecureAuthentication = true;
					}
					e.#G = this.#G;
					e.#q = this.#q;
					e.#V = this.#V;
					e.#W = Object.assign({}, this.#W);
					e.#J = this.#J;
					return e;
				}
				static lockConfig() {
					N = true;
				}
				static getGateway(e) {
					return T[e.toLowerCase()] || null;
				}
				static registerGateway(e, t) {
					e = e.toLowerCase();
					if (e === 'http' || e === 'https') {
						throw new Error(`cannot intercept ${e}; use registerGetUrl`);
					}
					if (N) {
						throw new Error('gateways locked');
					}
					T[e] = t;
				}
				static registerGetUrl(e) {
					if (N) {
						throw new Error('gateways locked');
					}
					_ = e;
				}
				static createGetUrlFunc(e) {
					return createGetUrl(e);
				}
				static createDataGateway() {
					return dataGatewayFunc;
				}
				static createIpfsGatewayFunc(e) {
					return getIpfsGatewayFunc(e);
				}
			}
			class FetchResponse {
				#Q;
				#Y;
				#D;
				#H;
				#X;
				#ee;
				toString() {
					return `<FetchResponse status=${this.statusCode} body=${this.#H ? (0, m.c$)(this.#H) : 'null'}>`;
				}
				get statusCode() {
					return this.#Q;
				}
				get statusMessage() {
					return this.#Y;
				}
				get headers() {
					return Object.assign({}, this.#D);
				}
				get body() {
					return this.#H == null ? null : new Uint8Array(this.#H);
				}
				get bodyText() {
					try {
						return this.#H == null ? '' : (0, p._v)(this.#H);
					} catch (e) {
						(0, d.vA)(false, 'response body is not valid UTF-8 data', 'UNSUPPORTED_OPERATION', {
							operation: 'bodyText',
							info: { response: this }
						});
					}
				}
				get bodyJson() {
					try {
						return JSON.parse(this.bodyText);
					} catch (e) {
						(0, d.vA)(false, 'response body is not valid JSON', 'UNSUPPORTED_OPERATION', {
							operation: 'bodyJson',
							info: { response: this }
						});
					}
				}
				[Symbol.iterator]() {
					const e = this.headers;
					const t = Object.keys(e);
					let r = 0;
					return {
						next: () => {
							if (r < t.length) {
								const i = t[r++];
								return { value: [i, e[i]], done: false };
							}
							return { value: undefined, done: true };
						}
					};
				}
				constructor(e, t, r, i, a) {
					this.#Q = e;
					this.#Y = t;
					this.#D = Object.keys(r).reduce((e, t) => {
						e[t.toLowerCase()] = String(r[t]);
						return e;
					}, {});
					this.#H = i == null ? null : new Uint8Array(i);
					this.#X = a || null;
					this.#ee = { message: '' };
				}
				makeServerError(e, t) {
					let r;
					if (!e) {
						e = `${this.statusCode} ${this.statusMessage}`;
						r = `CLIENT ESCALATED SERVER ERROR (${e})`;
					} else {
						r = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${e})`;
					}
					const i = new FetchResponse(599, r, this.headers, this.body, this.#X || undefined);
					i.#ee = { message: e, error: t };
					return i;
				}
				throwThrottleError(e, t) {
					if (t == null) {
						t = -1;
					} else {
						(0, d.MR)(Number.isInteger(t) && t >= 0, 'invalid stall timeout', 'stall', t);
					}
					const r = new Error(e || 'throttling requests');
					(0, l.n)(r, { stall: t, throttle: true });
					throw r;
				}
				getHeader(e) {
					return this.headers[e.toLowerCase()];
				}
				hasBody() {
					return this.#H != null;
				}
				get request() {
					return this.#X;
				}
				ok() {
					return this.#ee.message === '' && this.statusCode >= 200 && this.statusCode < 300;
				}
				assertOk() {
					if (this.ok()) {
						return;
					}
					let { message: e, error: t } = this.#ee;
					if (e === '') {
						e = `server response ${this.statusCode} ${this.statusMessage}`;
					}
					let r = null;
					if (this.request) {
						r = this.request.url;
					}
					let i = null;
					try {
						if (this.#H) {
							i = (0, p._v)(this.#H);
						}
					} catch (e) {}
					(0, d.vA)(false, e, 'SERVER_ERROR', {
						request: this.request || 'unknown request',
						response: this,
						error: t,
						info: {
							requestUrl: r,
							responseBody: i,
							responseStatus: `${this.statusCode} ${this.statusMessage}`
						}
					});
				}
			}
			function getTime() {
				return new Date().getTime();
			}
			function unpercent(e) {
				return (0, p.YW)(
					e.replace(/%([0-9a-f][0-9a-f])/gi, (e, t) => String.fromCharCode(parseInt(t, 16)))
				);
			}
			function wait(e) {
				return new Promise((t) => setTimeout(t, e));
			}
			var B = r(6935);
			var P = r(9848);
			var M = r(822);
			var C =
				'AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI';
			const I = new Map([
				[8217, 'apostrophe'],
				[8260, 'fraction slash'],
				[12539, 'middle dot']
			]);
			const O = 4;
			function decode_arithmetic(e) {
				let t = 0;
				function u16() {
					return (e[t++] << 8) | e[t++];
				}
				let r = u16();
				let i = 1;
				let a = [0, 1];
				for (let e = 1; e < r; e++) {
					a.push((i += u16()));
				}
				let o = u16();
				let c = t;
				t += o;
				let u = 0;
				let l = 0;
				function read_bit() {
					if (u == 0) {
						l = (l << 8) | e[t++];
						u = 8;
					}
					return (l >> --u) & 1;
				}
				const d = 31;
				const p = 2 ** d;
				const m = p >>> 1;
				const g = m >> 1;
				const v = p - 1;
				let y = 0;
				for (let e = 0; e < d; e++) y = (y << 1) | read_bit();
				let w = [];
				let _ = 0;
				let A = p;
				while (true) {
					let e = Math.floor(((y - _ + 1) * i - 1) / A);
					let t = 0;
					let o = r;
					while (o - t > 1) {
						let r = (t + o) >>> 1;
						if (e < a[r]) {
							o = r;
						} else {
							t = r;
						}
					}
					if (t == 0) break;
					w.push(t);
					let c = _ + Math.floor((A * a[t]) / i);
					let u = _ + Math.floor((A * a[t + 1]) / i) - 1;
					while (((c ^ u) & m) == 0) {
						y = ((y << 1) & v) | read_bit();
						c = (c << 1) & v;
						u = ((u << 1) & v) | 1;
					}
					while (c & ~u & g) {
						y = (y & m) | ((y << 1) & (v >>> 1)) | read_bit();
						c = (c << 1) ^ m;
						u = ((u ^ m) << 1) | m | 1;
					}
					_ = c;
					A = 1 + u - c;
				}
				let k = r - 4;
				return w.map((t) => {
					switch (t - k) {
						case 3:
							return k + 65792 + ((e[c++] << 16) | (e[c++] << 8) | e[c++]);
						case 2:
							return k + 256 + ((e[c++] << 8) | e[c++]);
						case 1:
							return k + e[c++];
						default:
							return t - 1;
					}
				});
			}
			function read_payload(e) {
				let t = 0;
				return () => e[t++];
			}
			function read_compressed_payload(e) {
				return read_payload(decode_arithmetic(unsafe_atob(e)));
			}
			function unsafe_atob(e) {
				let t = [];
				[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach(
					(e, r) => (t[e.charCodeAt(0)] = r)
				);
				let r = e.length;
				let i = new Uint8Array((6 * r) >> 3);
				for (let a = 0, o = 0, c = 0, u = 0; a < r; a++) {
					u = (u << 6) | t[e.charCodeAt(a)];
					c += 6;
					if (c >= 8) {
						i[o++] = u >> (c -= 8);
					}
				}
				return i;
			}
			function signed(e) {
				return e & 1 ? ~e >> 1 : e >> 1;
			}
			function read_deltas(e, t) {
				let r = Array(e);
				for (let i = 0, a = 0; i < e; i++) r[i] = a += signed(t());
				return r;
			}
			function read_sorted(e, t = 0) {
				let r = [];
				while (true) {
					let i = e();
					let a = e();
					if (!a) break;
					t += i;
					for (let e = 0; e < a; e++) {
						r.push(t + e);
					}
					t += a + 1;
				}
				return r;
			}
			function read_sorted_arrays(e) {
				return read_array_while(() => {
					let t = read_sorted(e);
					if (t.length) return t;
				});
			}
			function read_mapped(e) {
				let t = [];
				while (true) {
					let r = e();
					if (r == 0) break;
					t.push(read_linear_table(r, e));
				}
				while (true) {
					let r = e() - 1;
					if (r < 0) break;
					t.push(read_replacement_table(r, e));
				}
				return t.flat();
			}
			function read_array_while(e) {
				let t = [];
				while (true) {
					let r = e(t.length);
					if (!r) break;
					t.push(r);
				}
				return t;
			}
			function read_transposed(e, t, r) {
				let i = Array(e)
					.fill()
					.map(() => []);
				for (let a = 0; a < t; a++) {
					read_deltas(e, r).forEach((e, t) => i[t].push(e));
				}
				return i;
			}
			function read_linear_table(e, t) {
				let r = 1 + t();
				let i = t();
				let a = read_array_while(t);
				let o = read_transposed(a.length, 1 + e, t);
				return o.flatMap((e, t) => {
					let [o, ...c] = e;
					return Array(a[t])
						.fill()
						.map((e, t) => {
							let a = t * i;
							return [o + t * r, c.map((e) => e + a)];
						});
				});
			}
			function read_replacement_table(e, t) {
				let r = 1 + t();
				let i = read_transposed(r, 1 + e, t);
				return i.map((e) => [e[0], e.slice(1)]);
			}
			function read_trie(e) {
				let t = [];
				let r = read_sorted(e);
				expand(decode([]), []);
				return t;
				function decode(t) {
					let i = e();
					let a = read_array_while(() => {
						let t = read_sorted(e).map((e) => r[e]);
						if (t.length) return decode(t);
					});
					return { S: i, B: a, Q: t };
				}
				function expand({ S: e, B: r }, i, a) {
					if (e & 4 && a === i[i.length - 1]) return;
					if (e & 2) a = i[i.length - 1];
					if (e & 1) t.push(i);
					for (let e of r) {
						for (let t of e.Q) {
							expand(e, [...i, t], a);
						}
					}
				}
			}
			function hex_cp(e) {
				return e.toString(16).toUpperCase().padStart(2, '0');
			}
			function quote_cp(e) {
				return `{${hex_cp(e)}}`;
			}
			function explode_cp(e) {
				let t = [];
				for (let r = 0, i = e.length; r < i; ) {
					let i = e.codePointAt(r);
					r += i < 65536 ? 1 : 2;
					t.push(i);
				}
				return t;
			}
			function str_from_cps(e) {
				const t = 4096;
				let r = e.length;
				if (r < t) return String.fromCodePoint(...e);
				let i = [];
				for (let a = 0; a < r; ) {
					i.push(String.fromCodePoint(...e.slice(a, (a += t))));
				}
				return i.join('');
			}
			function compare_arrays(e, t) {
				let r = e.length;
				let i = r - t.length;
				for (let a = 0; i == 0 && a < r; a++) i = e[a] - t[a];
				return i;
			}
			var F =
				'AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g';
			const D = 44032;
			const L = 4352;
			const U = 4449;
			const j = 4519;
			const H = 19;
			const z = 21;
			const $ = 28;
			const G = z * $;
			const q = H * G;
			const V = D + q;
			const W = L + H;
			const J = U + z;
			const Z = j + $;
			function unpack_cc(e) {
				return (e >> 24) & 255;
			}
			function unpack_cp(e) {
				return e & 16777215;
			}
			let Q, Y, X, ee;
			function init$1() {
				let e = read_compressed_payload(F);
				Q = new Map(read_sorted_arrays(e).flatMap((e, t) => e.map((e) => [e, (t + 1) << 24])));
				Y = new Set(read_sorted(e));
				X = new Map();
				ee = new Map();
				for (let [t, r] of read_mapped(e)) {
					if (!Y.has(t) && r.length == 2) {
						let [e, i] = r;
						let a = ee.get(e);
						if (!a) {
							a = new Map();
							ee.set(e, a);
						}
						a.set(i, t);
					}
					X.set(t, r.reverse());
				}
			}
			function is_hangul(e) {
				return e >= D && e < V;
			}
			function compose_pair(e, t) {
				if (e >= L && e < W && t >= U && t < J) {
					return D + (e - L) * G + (t - U) * $;
				} else if (is_hangul(e) && t > j && t < Z && (e - D) % $ == 0) {
					return e + (t - j);
				} else {
					let r = ee.get(e);
					if (r) {
						r = r.get(t);
						if (r) {
							return r;
						}
					}
					return -1;
				}
			}
			function decomposed(e) {
				if (!Q) init$1();
				let t = [];
				let r = [];
				let i = false;
				function add(e) {
					let r = Q.get(e);
					if (r) {
						i = true;
						e |= r;
					}
					t.push(e);
				}
				for (let i of e) {
					while (true) {
						if (i < 128) {
							t.push(i);
						} else if (is_hangul(i)) {
							let e = i - D;
							let t = (e / G) | 0;
							let r = ((e % G) / $) | 0;
							let a = e % $;
							add(L + t);
							add(U + r);
							if (a > 0) add(j + a);
						} else {
							let e = X.get(i);
							if (e) {
								r.push(...e);
							} else {
								add(i);
							}
						}
						if (!r.length) break;
						i = r.pop();
					}
				}
				if (i && t.length > 1) {
					let e = unpack_cc(t[0]);
					for (let r = 1; r < t.length; r++) {
						let i = unpack_cc(t[r]);
						if (i == 0 || e <= i) {
							e = i;
							continue;
						}
						let a = r - 1;
						while (true) {
							let r = t[a + 1];
							t[a + 1] = t[a];
							t[a] = r;
							if (!a) break;
							e = unpack_cc(t[--a]);
							if (e <= i) break;
						}
						e = unpack_cc(t[r]);
					}
				}
				return t;
			}
			function composed_from_decomposed(e) {
				let t = [];
				let r = [];
				let i = -1;
				let a = 0;
				for (let o of e) {
					let e = unpack_cc(o);
					let c = unpack_cp(o);
					if (i == -1) {
						if (e == 0) {
							i = c;
						} else {
							t.push(c);
						}
					} else if (a > 0 && a >= e) {
						if (e == 0) {
							t.push(i, ...r);
							r.length = 0;
							i = c;
						} else {
							r.push(c);
						}
						a = e;
					} else {
						let o = compose_pair(i, c);
						if (o >= 0) {
							i = o;
						} else if (a == 0 && e == 0) {
							t.push(i);
							i = c;
						} else {
							r.push(c);
							a = e;
						}
					}
				}
				if (i >= 0) {
					t.push(i, ...r);
				}
				return t;
			}
			function nfd(e) {
				return decomposed(e).map(unpack_cp);
			}
			function nfc(e) {
				return composed_from_decomposed(decomposed(e));
			}
			const te = 45;
			const re = 46;
			const ne = '.';
			const ie = 65039;
			const se = 1;
			const Array_from = (e) => Array.from(e);
			function group_has_cp(e, t) {
				return e.P.has(t) || e.Q.has(t);
			}
			class Emoji extends Array {
				get is_emoji() {
					return true;
				}
			}
			let ae, oe, ce, ue, le, de, he, pe, me, ve, ye, be;
			function init() {
				if (ae) return;
				let e = read_compressed_payload(C);
				const read_sorted_array = () => read_sorted(e);
				const read_sorted_set = () => new Set(read_sorted_array());
				const set_add_many = (e, t) => t.forEach((t) => e.add(t));
				ae = new Map(read_mapped(e));
				oe = read_sorted_set();
				ce = read_sorted_array();
				ue = new Set(read_sorted_array().map((e) => ce[e]));
				ce = new Set(ce);
				le = read_sorted_set();
				de = read_sorted_set();
				let t = read_sorted_arrays(e);
				let r = e();
				const read_chunked = () => {
					let e = new Set();
					read_sorted_array().forEach((r) => set_add_many(e, t[r]));
					set_add_many(e, read_sorted_array());
					return e;
				};
				he = read_array_while((t) => {
					let i = read_array_while(e).map((e) => e + 96);
					if (i.length) {
						let a = t >= r;
						i[0] -= 32;
						i = str_from_cps(i);
						if (a) i = `Restricted[${i}]`;
						let o = read_chunked();
						let c = read_chunked();
						let u = !e();
						return { N: i, P: o, Q: c, M: u, R: a };
					}
				});
				pe = read_sorted_set();
				me = new Map();
				let i = read_sorted_array()
					.concat(Array_from(pe))
					.sort((e, t) => e - t);
				i.forEach((t, r) => {
					let a = e();
					let o = (i[r] = a ? i[r - a] : { V: [], M: new Map() });
					o.V.push(t);
					if (!pe.has(t)) {
						me.set(t, o);
					}
				});
				for (let { V: e, M: t } of new Set(me.values())) {
					let r = [];
					for (let t of e) {
						let e = he.filter((e) => group_has_cp(e, t));
						let i = r.find(({ G: t }) => e.some((e) => t.has(e)));
						if (!i) {
							i = { G: new Set(), V: [] };
							r.push(i);
						}
						i.V.push(t);
						set_add_many(i.G, e);
					}
					let i = r.flatMap((e) => Array_from(e.G));
					for (let { G: e, V: a } of r) {
						let r = new Set(i.filter((t) => !e.has(t)));
						for (let e of a) {
							t.set(e, r);
						}
					}
				}
				ve = new Set();
				let a = new Set();
				const add_to_union = (e) => (ve.has(e) ? a.add(e) : ve.add(e));
				for (let e of he) {
					for (let t of e.P) add_to_union(t);
					for (let t of e.Q) add_to_union(t);
				}
				for (let e of ve) {
					if (!me.has(e) && !a.has(e)) {
						me.set(e, se);
					}
				}
				set_add_many(ve, nfd(ve));
				ye = read_trie(e)
					.map((e) => Emoji.from(e))
					.sort(compare_arrays);
				be = new Map();
				for (let e of ye) {
					let t = [be];
					for (let r of e) {
						let e = t.map((e) => {
							let t = e.get(r);
							if (!t) {
								t = new Map();
								e.set(r, t);
							}
							return t;
						});
						if (r === ie) {
							t.push(...e);
						} else {
							t = e;
						}
					}
					for (let r of t) {
						r.V = e;
					}
				}
			}
			function quoted_cp(e) {
				return (should_escape(e) ? '' : `${bidi_qq(safe_str_from_cps([e]))} `) + quote_cp(e);
			}
			function bidi_qq(e) {
				return `"${e}"`;
			}
			function check_label_extension(e) {
				if (e.length >= 4 && e[2] == te && e[3] == te) {
					throw new Error(`invalid label extension: "${str_from_cps(e.slice(0, 4))}"`);
				}
			}
			function check_leading_underscore(e) {
				const t = 95;
				for (let r = e.lastIndexOf(t); r > 0; ) {
					if (e[--r] !== t) {
						throw new Error('underscore allowed only at start');
					}
				}
			}
			function check_fenced(e) {
				let t = e[0];
				let r = I.get(t);
				if (r) throw error_placement(`leading ${r}`);
				let i = e.length;
				let a = -1;
				for (let o = 1; o < i; o++) {
					t = e[o];
					let i = I.get(t);
					if (i) {
						if (a == o) throw error_placement(`${r} + ${i}`);
						a = o + 1;
						r = i;
					}
				}
				if (a == i) throw error_placement(`trailing ${r}`);
			}
			function safe_str_from_cps(e, t = Infinity, r = quote_cp) {
				let i = [];
				if (is_combining_mark(e[0])) i.push('');
				if (e.length > t) {
					t >>= 1;
					e = [...e.slice(0, t), 8230, ...e.slice(-t)];
				}
				let a = 0;
				let o = e.length;
				for (let t = 0; t < o; t++) {
					let o = e[t];
					if (should_escape(o)) {
						i.push(str_from_cps(e.slice(a, t)));
						i.push(r(o));
						a = t + 1;
					}
				}
				i.push(str_from_cps(e.slice(a, o)));
				return i.join('');
			}
			function is_combining_mark(e) {
				init();
				return ce.has(e);
			}
			function should_escape(e) {
				init();
				return le.has(e);
			}
			function ens_emoji() {
				init();
				return ye.map((e) => e.slice());
			}
			function ens_normalize_fragment(e, t) {
				init();
				let r = t ? nfd : nfc;
				return e
					.split(ne)
					.map((e) => str_from_cps(tokens_from_str(explode_cp(e), r, filter_fe0f).flat()))
					.join(ne);
			}
			function ens_normalize(e) {
				return flatten(split(e, nfc, filter_fe0f));
			}
			function ens_beautify(e) {
				let t = split(e, nfc, (e) => e);
				for (let { type: e, output: r, error: i } of t) {
					if (i) break;
					if (e !== 'Greek') array_replace(r, 958, 926);
				}
				return flatten(t);
			}
			function array_replace(e, t, r) {
				let i = 0;
				while (true) {
					let a = e.indexOf(t, i);
					if (a < 0) break;
					e[a] = r;
					i = a + 1;
				}
			}
			function ens_split(e, t) {
				return split(e, nfc, t ? (e) => e.slice() : filter_fe0f);
			}
			function split(e, t, r) {
				if (!e) return [];
				init();
				let i = 0;
				return e.split(ne).map((e) => {
					let a = explode_cp(e);
					let o = { input: a, offset: i };
					i += a.length + 1;
					try {
						let e = (o.tokens = tokens_from_str(a, t, r));
						let i = e.length;
						let c;
						if (!i) {
							throw new Error(`empty label`);
						}
						let u = (o.output = e.flat());
						check_leading_underscore(u);
						let l = (o.emoji = i > 1 || e[0].is_emoji);
						if (!l && u.every((e) => e < 128)) {
							check_label_extension(u);
							c = 'ASCII';
						} else {
							let t = e.flatMap((e) => (e.is_emoji ? [] : e));
							if (!t.length) {
								c = 'Emoji';
							} else {
								if (ce.has(u[0])) throw error_placement('leading combining mark');
								for (let t = 1; t < i; t++) {
									let r = e[t];
									if (!r.is_emoji && ce.has(r[0])) {
										throw error_placement(
											`emoji + combining mark: "${str_from_cps(e[t - 1])} + ${safe_str_from_cps([r[0]])}"`
										);
									}
								}
								check_fenced(u);
								let r = Array_from(new Set(t));
								let [a] = determine_group(r);
								check_group(a, t);
								check_whole(a, r);
								c = a.N;
							}
						}
						o.type = c;
					} catch (e) {
						o.error = e;
					}
					return o;
				});
			}
			function check_whole(e, t) {
				let r;
				let i = [];
				for (let e of t) {
					let t = me.get(e);
					if (t === se) return;
					if (t) {
						let i = t.M.get(e);
						r = r ? r.filter((e) => i.has(e)) : Array_from(i);
						if (!r.length) return;
					} else {
						i.push(e);
					}
				}
				if (r) {
					for (let t of r) {
						if (i.every((e) => group_has_cp(t, e))) {
							throw new Error(`whole-script confusable: ${e.N}/${t.N}`);
						}
					}
				}
			}
			function determine_group(e) {
				let t = he;
				for (let r of e) {
					let e = t.filter((e) => group_has_cp(e, r));
					if (!e.length) {
						if (!he.some((e) => group_has_cp(e, r))) {
							throw error_disallowed(r);
						} else {
							throw error_group_member(t[0], r);
						}
					}
					t = e;
					if (e.length == 1) break;
				}
				return t;
			}
			function flatten(e) {
				return e
					.map(({ input: t, error: r, output: i }) => {
						if (r) {
							let i = r.message;
							throw new Error(
								e.length == 1 ? i : `Invalid label ${bidi_qq(safe_str_from_cps(t, 63))}: ${i}`
							);
						}
						return str_from_cps(i);
					})
					.join(ne);
			}
			function error_disallowed(e) {
				return new Error(`disallowed character: ${quoted_cp(e)}`);
			}
			function error_group_member(e, t) {
				let r = quoted_cp(t);
				let i = he.find((e) => e.P.has(t));
				if (i) {
					r = `${i.N} ${r}`;
				}
				return new Error(`illegal mixture: ${e.N} + ${r}`);
			}
			function error_placement(e) {
				return new Error(`illegal placement: ${e}`);
			}
			function check_group(e, t) {
				for (let r of t) {
					if (!group_has_cp(e, r)) {
						throw error_group_member(e, r);
					}
				}
				if (e.M) {
					let e = nfd(t);
					for (let t = 1, r = e.length; t < r; t++) {
						if (ue.has(e[t])) {
							let i = t + 1;
							for (let a; i < r && ue.has((a = e[i])); i++) {
								for (let r = t; r < i; r++) {
									if (e[r] == a) {
										throw new Error(`duplicate non-spacing marks: ${quoted_cp(a)}`);
									}
								}
							}
							if (i - t > O) {
								throw new Error(
									`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(e.slice(t - 1, i)))} (${i - t}/${O})`
								);
							}
							t = i;
						}
					}
				}
			}
			function tokens_from_str(e, t, r) {
				let i = [];
				let a = [];
				e = e.slice().reverse();
				while (e.length) {
					let o = consume_emoji_reversed(e);
					if (o) {
						if (a.length) {
							i.push(t(a));
							a = [];
						}
						i.push(r(o));
					} else {
						let t = e.pop();
						if (ve.has(t)) {
							a.push(t);
						} else {
							let e = ae.get(t);
							if (e) {
								a.push(...e);
							} else if (!oe.has(t)) {
								throw error_disallowed(t);
							}
						}
					}
				}
				if (a.length) {
					i.push(t(a));
				}
				return i;
			}
			function filter_fe0f(e) {
				return e.filter((e) => e != ie);
			}
			function consume_emoji_reversed(e, t) {
				let r = be;
				let i;
				let a = e.length;
				while (a) {
					r = r.get(e[--a]);
					if (!r) break;
					let { V: o } = r;
					if (o) {
						i = o;
						if (t) t.push(...e.slice(a).reverse());
						e.length = a;
					}
				}
				return i;
			}
			const we = 'valid';
			const _e = 'mapped';
			const Ae = 'ignored';
			const Ee = 'disallowed';
			const Se = 'emoji';
			const ke = 'nfc';
			const Ne = 'stop';
			function ens_tokenize(e, { nf: t = true } = {}) {
				init();
				let r = explode_cp(e).reverse();
				let i = [];
				let a = [];
				while (r.length) {
					let e = consume_emoji_reversed(r, i);
					if (e) {
						a.push({ type: Se, emoji: e.slice(), input: i, cps: filter_fe0f(e) });
						i = [];
					} else {
						let e = r.pop();
						if (e == re) {
							a.push({ type: Ne, cp: e });
						} else if (ve.has(e)) {
							a.push({ type: we, cps: [e] });
						} else if (oe.has(e)) {
							a.push({ type: Ae, cp: e });
						} else {
							let t = ae.get(e);
							if (t) {
								a.push({ type: _e, cp: e, cps: t.slice() });
							} else {
								a.push({ type: Ee, cp: e });
							}
						}
					}
				}
				if (t) {
					for (let e = 0, t = -1; e < a.length; e++) {
						let r = a[e];
						if (is_valid_or_mapped(r.type)) {
							if (requires_check(r.cps)) {
								let r = e + 1;
								for (let e = r; e < a.length; e++) {
									let { type: t, cps: i } = a[e];
									if (is_valid_or_mapped(t)) {
										if (!requires_check(i)) break;
										r = e + 1;
									} else if (t !== Ae) {
										break;
									}
								}
								if (t < 0) t = e;
								let i = a.slice(t, r);
								let o = i.flatMap((e) => (is_valid_or_mapped(e.type) ? e.cps : []));
								let c = nfc(o);
								if (compare_arrays(c, o)) {
									a.splice(t, r - t, {
										type: ke,
										input: o,
										cps: c,
										tokens0: collapse_valid_tokens(i),
										tokens: ens_tokenize(str_from_cps(c), { nf: false })
									});
									e = t;
								} else {
									e = r - 1;
								}
								t = -1;
							} else {
								t = e;
							}
						} else if (r.type !== Ae) {
							t = -1;
						}
					}
				}
				return collapse_valid_tokens(a);
			}
			function is_valid_or_mapped(e) {
				return e == we || e == _e;
			}
			function requires_check(e) {
				return e.some((e) => de.has(e));
			}
			function collapse_valid_tokens(e) {
				for (let t = 0; t < e.length; t++) {
					if (e[t].type == we) {
						let r = t + 1;
						while (r < e.length && e[r].type == we) r++;
						e.splice(t, r - t, { type: we, cps: e.slice(t, r).flatMap((e) => e.cps) });
					}
				}
				return e;
			}
			const Te = new Uint8Array(32);
			Te.fill(0);
			function checkComponent(e) {
				(0, d.MR)(e.length !== 0, 'invalid ENS name; empty component', 'comp', e);
				return e;
			}
			function ensNameSplit(e) {
				const t = (0, p.YW)(ensNormalize(e));
				const r = [];
				if (e.length === 0) {
					return r;
				}
				let i = 0;
				for (let e = 0; e < t.length; e++) {
					const a = t[e];
					if (a === 46) {
						r.push(checkComponent(t.slice(i, e)));
						i = e + 1;
					}
				}
				(0, d.MR)(i < t.length, 'invalid ENS name; empty component', 'name', e);
				r.push(checkComponent(t.slice(i)));
				return r;
			}
			function ensNormalize(e) {
				try {
					if (e.length === 0) {
						throw new Error('empty label');
					}
					return ens_normalize(e);
				} catch (t) {
					(0, d.MR)(false, `invalid ENS name (${t.message})`, 'name', e);
				}
			}
			function isValidName(e) {
				try {
					return ensNameSplit(e).length !== 0;
				} catch (e) {}
				return false;
			}
			function namehash(e) {
				(0, d.MR)(typeof e === 'string', 'invalid ENS name; not a string', 'name', e);
				(0, d.MR)(e.length, `invalid ENS name (empty label)`, 'name', e);
				let t = Te;
				const r = ensNameSplit(e);
				while (r.length) {
					t = (0, M.S)((0, m.xW)([t, (0, M.S)(r.pop())]));
				}
				return (0, m.c$)(t);
			}
			function dnsEncode(e, t) {
				const r = t != null ? t : 63;
				(0, d.MR)(r <= 255, 'DNS encoded label cannot exceed 255', 'length', r);
				return (
					(0, m.c$)(
						(0, m.xW)(
							ensNameSplit(e).map((t) => {
								(0, d.MR)(
									t.length <= r,
									`label ${JSON.stringify(e)} exceeds ${r} bytes`,
									'name',
									e
								);
								const i = new Uint8Array(t.length + 1);
								i.set(t, 1);
								i[0] = i.length - 1;
								return i;
							})
						)
					) + '00'
				);
			}
			var xe = r(7818);
			var Be = r(5362);
			var Re = r(9735);
			function getIpfsLink(e) {
				if (e.match(/^ipfs:\/\/ipfs\//i)) {
					e = e.substring(12);
				} else if (e.match(/^ipfs:\/\//i)) {
					e = e.substring(7);
				} else {
					(0, d.MR)(false, 'unsupported IPFS format', 'link', e);
				}
				return `https://gateway.ipfs.io/ipfs/${e}`;
			}
			class MulticoinProviderPlugin {
				name;
				constructor(e) {
					(0, l.n)(this, { name: e });
				}
				connect(e) {
					return this;
				}
				supportsCoinType(e) {
					return false;
				}
				async encodeAddress(e, t) {
					throw new Error('unsupported coin');
				}
				async decodeAddress(e, t) {
					throw new Error('unsupported coin');
				}
			}
			const Pe = 'org.ethers.plugins.provider.BasicMulticoin';
			class BasicMulticoinProviderPlugin extends MulticoinProviderPlugin {
				constructor() {
					super(Pe);
				}
			}
			const Me = new RegExp('^(ipfs)://(.*)$', 'i');
			const Ce = [
				new RegExp('^(https)://(.*)$', 'i'),
				new RegExp('^(data):(.*)$', 'i'),
				Me,
				new RegExp('^eip155:[0-9]+/(erc[0-9]+):(.*)$', 'i')
			];
			class EnsResolver {
				provider;
				address;
				name;
				#te;
				#re;
				constructor(e, t, r) {
					(0, l.n)(this, { provider: e, address: t, name: r });
					this.#te = null;
					this.#re = new P.NZ(
						t,
						[
							'function supportsInterface(bytes4) view returns (bool)',
							'function resolve(bytes, bytes) view returns (bytes)',
							'function addr(bytes32) view returns (address)',
							'function addr(bytes32, uint) view returns (bytes)',
							'function text(bytes32, string) view returns (string)',
							'function contenthash(bytes32) view returns (bytes)'
						],
						e
					);
				}
				async supportsWildcard() {
					if (this.#te == null) {
						this.#te = (async () => {
							try {
								return await this.#re.supportsInterface('0x9061b923');
							} catch (e) {
								if ((0, d.bJ)(e, 'CALL_EXCEPTION')) {
									return false;
								}
								this.#te = null;
								throw e;
							}
						})();
					}
					return await this.#te;
				}
				async #ne(e, t) {
					t = (t || []).slice();
					const r = this.#re.interface;
					t.unshift(namehash(this.name));
					let i = null;
					if (await this.supportsWildcard()) {
						i = r.getFunction(e);
						(0, d.vA)(i, 'missing fragment', 'UNKNOWN_ERROR', { info: { funcName: e } });
						t = [dnsEncode(this.name, 255), r.encodeFunctionData(i, t)];
						e = 'resolve(bytes,bytes)';
					}
					t.push({ enableCcipRead: true });
					try {
						const a = await this.#re[e](...t);
						if (i) {
							return r.decodeFunctionResult(i, a)[0];
						}
						return a;
					} catch (e) {
						if (!(0, d.bJ)(e, 'CALL_EXCEPTION')) {
							throw e;
						}
					}
					return null;
				}
				async getAddress(e) {
					if (e == null) {
						e = 60;
					}
					if (e === 60) {
						try {
							const e = await this.#ne('addr(bytes32)');
							if (e == null || e === B.j) {
								return null;
							}
							return e;
						} catch (e) {
							if ((0, d.bJ)(e, 'CALL_EXCEPTION')) {
								return null;
							}
							throw e;
						}
					}
					if (e >= 0 && e < 2147483648) {
						let t = e + 2147483648;
						const r = await this.#ne('addr(bytes32,uint)', [t]);
						if ((0, m.Lo)(r, 20)) {
							return (0, a.b)(r);
						}
					}
					let t = null;
					for (const r of this.provider.plugins) {
						if (!(r instanceof MulticoinProviderPlugin)) {
							continue;
						}
						if (r.supportsCoinType(e)) {
							t = r;
							break;
						}
					}
					if (t == null) {
						return null;
					}
					const r = await this.#ne('addr(bytes32,uint)', [e]);
					if (r == null || r === '0x') {
						return null;
					}
					const i = await t.decodeAddress(e, r);
					if (i != null) {
						return i;
					}
					(0, d.vA)(false, `invalid coin data`, 'UNSUPPORTED_OPERATION', {
						operation: `getAddress(${e})`,
						info: { coinType: e, data: r }
					});
				}
				async getText(e) {
					const t = await this.#ne('text(bytes32,string)', [e]);
					if (t == null || t === '0x') {
						return null;
					}
					return t;
				}
				async getContentHash() {
					const e = await this.#ne('contenthash(bytes32)');
					if (e == null || e === '0x') {
						return null;
					}
					const t = e.match(
						/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/
					);
					if (t) {
						const e = t[1] === 'e3010170' ? 'ipfs' : 'ipns';
						const r = parseInt(t[4], 16);
						if (t[5].length === r * 2) {
							return `${e}://${(0, Re.R)('0x' + t[2])}`;
						}
					}
					const r = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
					if (r && r[1].length === 64) {
						return `bzz://${r[1]}`;
					}
					(0, d.vA)(false, `invalid or unsupported content hash data`, 'UNSUPPORTED_OPERATION', {
						operation: 'getContentHash()',
						info: { data: e }
					});
				}
				async getAvatar() {
					const e = await this._getAvatar();
					return e.url;
				}
				async _getAvatar() {
					const e = [{ type: 'name', value: this.name }];
					try {
						const t = await this.getText('avatar');
						if (t == null) {
							e.push({ type: '!avatar', value: '' });
							return { url: null, linkage: e };
						}
						e.push({ type: 'avatar', value: t });
						for (let r = 0; r < Ce.length; r++) {
							const i = t.match(Ce[r]);
							if (i == null) {
								continue;
							}
							const a = i[1].toLowerCase();
							switch (a) {
								case 'https':
								case 'data':
									e.push({ type: 'url', value: t });
									return { linkage: e, url: t };
								case 'ipfs': {
									const r = getIpfsLink(t);
									e.push({ type: 'ipfs', value: t });
									e.push({ type: 'url', value: r });
									return { linkage: e, url: r };
								}
								case 'erc721':
								case 'erc1155': {
									const r = a === 'erc721' ? 'tokenURI(uint256)' : 'uri(uint256)';
									e.push({ type: a, value: t });
									const o = await this.getAddress();
									if (o == null) {
										e.push({ type: '!owner', value: '' });
										return { url: null, linkage: e };
									}
									const c = (i[2] || '').split('/');
									if (c.length !== 2) {
										e.push({ type: `!${a}caip`, value: i[2] || '' });
										return { url: null, linkage: e };
									}
									const u = c[1];
									const l = new P.NZ(
										c[0],
										[
											'function tokenURI(uint) view returns (string)',
											'function ownerOf(uint) view returns (address)',
											'function uri(uint) view returns (string)',
											'function balanceOf(address, uint256) view returns (uint)'
										],
										this.provider
									);
									if (a === 'erc721') {
										const t = await l.ownerOf(u);
										if (o !== t) {
											e.push({ type: '!owner', value: t });
											return { url: null, linkage: e };
										}
										e.push({ type: 'owner', value: t });
									} else if (a === 'erc1155') {
										const t = await l.balanceOf(o, u);
										if (!t) {
											e.push({ type: '!balance', value: '0' });
											return { url: null, linkage: e };
										}
										e.push({ type: 'balance', value: t.toString() });
									}
									let d = await l[r](u);
									if (d == null || d === '0x') {
										e.push({ type: '!metadata-url', value: '' });
										return { url: null, linkage: e };
									}
									e.push({ type: 'metadata-url-base', value: d });
									if (a === 'erc1155') {
										d = d.replace('{id}', (0, g.up)(u, 32).substring(2));
										e.push({ type: 'metadata-url-expanded', value: d });
									}
									if (d.match(/^ipfs:/i)) {
										d = getIpfsLink(d);
									}
									e.push({ type: 'metadata-url', value: d });
									let p = {};
									const v = await new FetchRequest(d).send();
									v.assertOk();
									try {
										p = v.bodyJson;
									} catch (t) {
										try {
											e.push({ type: '!metadata', value: v.bodyText });
										} catch (t) {
											const r = v.body;
											if (r) {
												e.push({ type: '!metadata', value: (0, m.c$)(r) });
											}
											return { url: null, linkage: e };
										}
										return { url: null, linkage: e };
									}
									if (!p) {
										e.push({ type: '!metadata', value: '' });
										return { url: null, linkage: e };
									}
									e.push({ type: 'metadata', value: JSON.stringify(p) });
									let y = p.image;
									if (typeof y !== 'string') {
										e.push({ type: '!imageUrl', value: '' });
										return { url: null, linkage: e };
									}
									if (y.match(/^(https:\/\/|data:)/i)) {
									} else {
										const t = y.match(Me);
										if (t == null) {
											e.push({ type: '!imageUrl-ipfs', value: y });
											return { url: null, linkage: e };
										}
										e.push({ type: 'imageUrl-ipfs', value: y });
										y = getIpfsLink(y);
									}
									e.push({ type: 'url', value: y });
									return { linkage: e, url: y };
								}
							}
						}
					} catch (e) {}
					return { linkage: e, url: null };
				}
				static async getEnsAddress(e) {
					const t = await e.getNetwork();
					const r = t.getPlugin('org.ethers.plugins.network.Ens');
					(0, d.vA)(r, 'network does not support ENS', 'UNSUPPORTED_OPERATION', {
						operation: 'getEnsAddress',
						info: { network: t }
					});
					return r.address;
				}
				static async #ie(e, t) {
					const r = await EnsResolver.getEnsAddress(e);
					try {
						const i = new P.NZ(r, ['function resolver(bytes32) view returns (address)'], e);
						const a = await i.resolver(namehash(t), { enableCcipRead: true });
						if (a === B.j) {
							return null;
						}
						return a;
					} catch (e) {
						throw e;
					}
					return null;
				}
				static async fromName(e, t) {
					let r = t;
					while (true) {
						if (r === '' || r === '.') {
							return null;
						}
						if (t !== 'eth' && r === 'eth') {
							return null;
						}
						const i = await EnsResolver.#ie(e, r);
						if (i != null) {
							const a = new EnsResolver(e, i, t);
							if (r !== t && !(await a.supportsWildcard())) {
								return null;
							}
							return a;
						}
						r = r.split('.').slice(1).join('.');
					}
				}
			}
			var Ie = r(3996);
			function getCreateAddress(e) {
				const t = (0, a.b)(e.from);
				const r = (0, g.Ab)(e.nonce, 'tx.nonce');
				let i = r.toString(16);
				if (i === '0') {
					i = '0x';
				} else if (i.length % 2) {
					i = '0x0' + i;
				} else {
					i = '0x' + i;
				}
				return (0, a.b)((0, m.ZG)((0, M.S)((0, Ie.R)([t, i])), 12));
			}
			function getCreate2Address(e, t, r) {
				const i = getAddress(e);
				const a = getBytes(t, 'salt');
				const o = getBytes(r, 'initCodeHash');
				assertArgument(a.length === 32, 'salt must be 32 bytes', 'salt', t);
				assertArgument(o.length === 32, 'initCodeHash must be 32 bytes', 'initCodeHash', r);
				return getAddress(dataSlice(keccak256(concat(['0xff', i, a, o])), 12));
			}
			var Oe = r(8249);
			const Fe = BigInt(0);
			function allowNull(e, t) {
				return function (r) {
					if (r == null) {
						return t;
					}
					return e(r);
				};
			}
			function arrayOf(e, t) {
				return (r) => {
					if (t && r == null) {
						return null;
					}
					if (!Array.isArray(r)) {
						throw new Error('not an array');
					}
					return r.map((t) => e(t));
				};
			}
			function object(e, t) {
				return (r) => {
					const i = {};
					for (const a in e) {
						let o = a;
						if (t && a in t && !(o in r)) {
							for (const e of t[a]) {
								if (e in r) {
									o = e;
									break;
								}
							}
						}
						try {
							const t = e[a](r[o]);
							if (t !== undefined) {
								i[a] = t;
							}
						} catch (e) {
							const t = e instanceof Error ? e.message : 'not-an-error';
							(0, d.vA)(false, `invalid value for value.${a} (${t})`, 'BAD_DATA', { value: r });
						}
					}
					return i;
				};
			}
			function formatBoolean(e) {
				switch (e) {
					case true:
					case 'true':
						return true;
					case false:
					case 'false':
						return false;
				}
				(0, d.MR)(false, `invalid boolean; ${JSON.stringify(e)}`, 'value', e);
			}
			function formatData(e) {
				(0, d.MR)((0, m.Lo)(e, true), 'invalid data', 'value', e);
				return e;
			}
			function formatHash(e) {
				(0, d.MR)((0, m.Lo)(e, 32), 'invalid hash', 'value', e);
				return e;
			}
			function formatUint256(e) {
				if (!isHexString(e)) {
					throw new Error('invalid uint256');
				}
				return zeroPadValue(e, 32);
			}
			const De = object(
				{
					address: a.b,
					blockHash: formatHash,
					blockNumber: g.WZ,
					data: formatData,
					index: g.WZ,
					removed: allowNull(formatBoolean, false),
					topics: arrayOf(formatHash),
					transactionHash: formatHash,
					transactionIndex: g.WZ
				},
				{ index: ['logIndex'] }
			);
			function formatLog(e) {
				return De(e);
			}
			const Le = object(
				{
					hash: allowNull(formatHash),
					parentHash: formatHash,
					parentBeaconBlockRoot: allowNull(formatHash, null),
					number: g.WZ,
					timestamp: g.WZ,
					nonce: allowNull(formatData),
					difficulty: g.Ab,
					gasLimit: g.Ab,
					gasUsed: g.Ab,
					stateRoot: allowNull(formatHash, null),
					receiptsRoot: allowNull(formatHash, null),
					blobGasUsed: allowNull(g.Ab, null),
					excessBlobGas: allowNull(g.Ab, null),
					miner: allowNull(a.b),
					prevRandao: allowNull(formatHash, null),
					extraData: formatData,
					baseFeePerGas: allowNull(g.Ab)
				},
				{ prevRandao: ['mixHash'] }
			);
			function formatBlock(e) {
				const t = Le(e);
				t.transactions = e.transactions.map((e) => {
					if (typeof e === 'string') {
						return e;
					}
					return formatTransactionResponse(e);
				});
				return t;
			}
			const Ue = object(
				{
					transactionIndex: g.WZ,
					blockNumber: g.WZ,
					transactionHash: formatHash,
					address: a.b,
					topics: arrayOf(formatHash),
					data: formatData,
					index: g.WZ,
					blockHash: formatHash
				},
				{ index: ['logIndex'] }
			);
			function formatReceiptLog(e) {
				return Ue(e);
			}
			const je = object(
				{
					to: allowNull(a.b, null),
					from: allowNull(a.b, null),
					contractAddress: allowNull(a.b, null),
					index: g.WZ,
					root: allowNull(m.c$),
					gasUsed: g.Ab,
					blobGasUsed: allowNull(g.Ab, null),
					logsBloom: allowNull(formatData),
					blockHash: formatHash,
					hash: formatHash,
					logs: arrayOf(formatReceiptLog),
					blockNumber: g.WZ,
					cumulativeGasUsed: g.Ab,
					effectiveGasPrice: allowNull(g.Ab),
					blobGasPrice: allowNull(g.Ab, null),
					status: allowNull(g.WZ),
					type: allowNull(g.WZ, 0)
				},
				{ effectiveGasPrice: ['gasPrice'], hash: ['transactionHash'], index: ['transactionIndex'] }
			);
			function formatTransactionReceipt(e) {
				return je(e);
			}
			function formatTransactionResponse(e) {
				if (e.to && (0, g.Ab)(e.to) === Fe) {
					e.to = '0x0000000000000000000000000000000000000000';
				}
				const t = object(
					{
						hash: formatHash,
						index: allowNull(g.WZ, undefined),
						type: (e) => {
							if (e === '0x' || e == null) {
								return 0;
							}
							return (0, g.WZ)(e);
						},
						accessList: allowNull(u.$, null),
						blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),
						blockHash: allowNull(formatHash, null),
						blockNumber: allowNull(g.WZ, null),
						transactionIndex: allowNull(g.WZ, null),
						from: a.b,
						gasPrice: allowNull(g.Ab),
						maxPriorityFeePerGas: allowNull(g.Ab),
						maxFeePerGas: allowNull(g.Ab),
						maxFeePerBlobGas: allowNull(g.Ab, null),
						gasLimit: g.Ab,
						to: allowNull(a.b, null),
						value: g.Ab,
						nonce: g.WZ,
						data: formatData,
						creates: allowNull(a.b, null),
						chainId: allowNull(g.Ab, null)
					},
					{ data: ['input'], gasLimit: ['gas'], index: ['transactionIndex'] }
				)(e);
				if (t.to == null && t.creates == null) {
					t.creates = getCreateAddress(t);
				}
				if ((e.type === 1 || e.type === 2) && e.accessList == null) {
					t.accessList = [];
				}
				if (e.signature) {
					t.signature = Oe.t.from(e.signature);
				} else {
					t.signature = Oe.t.from(e);
				}
				if (t.chainId == null) {
					const e = t.signature.legacyChainId;
					if (e != null) {
						t.chainId = e;
					}
				}
				if (t.blockHash && (0, g.Ab)(t.blockHash) === Fe) {
					t.blockHash = null;
				}
				return t;
			}
			const He = '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e';
			class NetworkPlugin {
				name;
				constructor(e) {
					(0, l.n)(this, { name: e });
				}
				clone() {
					return new NetworkPlugin(this.name);
				}
			}
			class GasCostPlugin extends NetworkPlugin {
				effectiveBlock;
				txBase;
				txCreate;
				txDataZero;
				txDataNonzero;
				txAccessListStorageKey;
				txAccessListAddress;
				constructor(e, t) {
					if (e == null) {
						e = 0;
					}
					super(`org.ethers.network.plugins.GasCost#${e || 0}`);
					const r = { effectiveBlock: e };
					function set(e, i) {
						let a = (t || {})[e];
						if (a == null) {
							a = i;
						}
						(0, d.MR)(typeof a === 'number', `invalud value for ${e}`, 'costs', t);
						r[e] = a;
					}
					set('txBase', 21e3);
					set('txCreate', 32e3);
					set('txDataZero', 4);
					set('txDataNonzero', 16);
					set('txAccessListStorageKey', 1900);
					set('txAccessListAddress', 2400);
					(0, l.n)(this, r);
				}
				clone() {
					return new GasCostPlugin(this.effectiveBlock, this);
				}
			}
			class EnsPlugin extends NetworkPlugin {
				address;
				targetNetwork;
				constructor(e, t) {
					super('org.ethers.plugins.network.Ens');
					(0, l.n)(this, { address: e || He, targetNetwork: t == null ? 1 : t });
				}
				clone() {
					return new EnsPlugin(this.address, this.targetNetwork);
				}
			}
			class FeeDataNetworkPlugin extends NetworkPlugin {
				#se;
				get feeDataFunc() {
					return this.#se;
				}
				constructor(e) {
					super('org.ethers.plugins.network.FeeData');
					this.#se = e;
				}
				async getFeeData(e) {
					return await this.#se(e);
				}
				clone() {
					return new FeeDataNetworkPlugin(this.#se);
				}
			}
			class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {
				#j;
				#ae;
				get url() {
					return this.#j;
				}
				get processFunc() {
					return this.#ae;
				}
				constructor(e, t) {
					super('org.ethers.plugins.network.FetchUrlFeeDataPlugin');
					this.#j = e;
					this.#ae = t;
				}
				clone() {
					return this;
				}
			}
			const ze = new Map();
			class Network {
				#oe;
				#ce;
				#fe;
				constructor(e, t) {
					this.#oe = e;
					this.#ce = (0, g.Ab)(t);
					this.#fe = new Map();
				}
				toJSON() {
					return { name: this.name, chainId: String(this.chainId) };
				}
				get name() {
					return this.#oe;
				}
				set name(e) {
					this.#oe = e;
				}
				get chainId() {
					return this.#ce;
				}
				set chainId(e) {
					this.#ce = (0, g.Ab)(e, 'chainId');
				}
				matches(e) {
					if (e == null) {
						return false;
					}
					if (typeof e === 'string') {
						try {
							return this.chainId === (0, g.Ab)(e);
						} catch (e) {}
						return this.name === e;
					}
					if (typeof e === 'number' || typeof e === 'bigint') {
						try {
							return this.chainId === (0, g.Ab)(e);
						} catch (e) {}
						return false;
					}
					if (typeof e === 'object') {
						if (e.chainId != null) {
							try {
								return this.chainId === (0, g.Ab)(e.chainId);
							} catch (e) {}
							return false;
						}
						if (e.name != null) {
							return this.name === e.name;
						}
						return false;
					}
					return false;
				}
				get plugins() {
					return Array.from(this.#fe.values());
				}
				attachPlugin(e) {
					if (this.#fe.get(e.name)) {
						throw new Error(`cannot replace existing plugin: ${e.name} `);
					}
					this.#fe.set(e.name, e.clone());
					return this;
				}
				getPlugin(e) {
					return this.#fe.get(e) || null;
				}
				getPlugins(e) {
					return this.plugins.filter((t) => t.name.split('#')[0] === e);
				}
				clone() {
					const e = new Network(this.name, this.chainId);
					this.plugins.forEach((t) => {
						e.attachPlugin(t.clone());
					});
					return e;
				}
				computeIntrinsicGas(e) {
					const t = this.getPlugin('org.ethers.plugins.network.GasCost') || new GasCostPlugin();
					let r = t.txBase;
					if (e.to == null) {
						r += t.txCreate;
					}
					if (e.data) {
						for (let i = 2; i < e.data.length; i += 2) {
							if (e.data.substring(i, i + 2) === '00') {
								r += t.txDataZero;
							} else {
								r += t.txDataNonzero;
							}
						}
					}
					if (e.accessList) {
						const i = (0, u.$)(e.accessList);
						for (const e in i) {
							r += t.txAccessListAddress + t.txAccessListStorageKey * i[e].storageKeys.length;
						}
					}
					return r;
				}
				static from(e) {
					injectCommonNetworks();
					if (e == null) {
						return Network.from('mainnet');
					}
					if (typeof e === 'number') {
						e = BigInt(e);
					}
					if (typeof e === 'string' || typeof e === 'bigint') {
						const t = ze.get(e);
						if (t) {
							return t();
						}
						if (typeof e === 'bigint') {
							return new Network('unknown', e);
						}
						(0, d.MR)(false, 'unknown network', 'network', e);
					}
					if (typeof e.clone === 'function') {
						const t = e.clone();
						return t;
					}
					if (typeof e === 'object') {
						(0, d.MR)(
							typeof e.name === 'string' && typeof e.chainId === 'number',
							'invalid network object name or chainId',
							'network',
							e
						);
						const t = new Network(e.name, e.chainId);
						if (e.ensAddress || e.ensNetwork != null) {
							t.attachPlugin(new EnsPlugin(e.ensAddress, e.ensNetwork));
						}
						return t;
					}
					(0, d.MR)(false, 'invalid network', 'network', e);
				}
				static register(e, t) {
					if (typeof e === 'number') {
						e = BigInt(e);
					}
					const r = ze.get(e);
					if (r) {
						(0, d.MR)(
							false,
							`conflicting network for ${JSON.stringify(r.name)}`,
							'nameOrChainId',
							e
						);
					}
					ze.set(e, t);
				}
			}
			function parseUnits(e, t) {
				const r = String(e);
				if (!r.match(/^[0-9.]+$/)) {
					throw new Error(`invalid gwei value: ${e}`);
				}
				const i = r.split('.');
				if (i.length === 1) {
					i.push('');
				}
				if (i.length !== 2) {
					throw new Error(`invalid gwei value: ${e}`);
				}
				while (i[1].length < t) {
					i[1] += '0';
				}
				if (i[1].length > 9) {
					let e = BigInt(i[1].substring(0, 9));
					if (!i[1].substring(9).match(/^0+$/)) {
						e++;
					}
					i[1] = e.toString();
				}
				return BigInt(i[0] + i[1]);
			}
			function getGasStationPlugin(e) {
				return new FetchUrlFeeDataNetworkPlugin(e, async (e, t, r) => {
					r.setHeader('User-Agent', 'ethers');
					let i;
					try {
						const [t, a] = await Promise.all([r.send(), e()]);
						i = t;
						const o = i.bodyJson.standard;
						const c = {
							gasPrice: a.gasPrice,
							maxFeePerGas: parseUnits(o.maxFee, 9),
							maxPriorityFeePerGas: parseUnits(o.maxPriorityFee, 9)
						};
						return c;
					} catch (e) {
						(0, d.vA)(
							false,
							`error encountered with polygon gas station (${JSON.stringify(r.url)})`,
							'SERVER_ERROR',
							{ request: r, response: i, error: e }
						);
					}
				});
			}
			let $e = false;
			function injectCommonNetworks() {
				if ($e) {
					return;
				}
				$e = true;
				function registerEth(e, t, r) {
					const func = function () {
						const i = new Network(e, t);
						if (r.ensNetwork != null) {
							i.attachPlugin(new EnsPlugin(null, r.ensNetwork));
						}
						i.attachPlugin(new GasCostPlugin());
						(r.plugins || []).forEach((e) => {
							i.attachPlugin(e);
						});
						return i;
					};
					Network.register(e, func);
					Network.register(t, func);
					if (r.altNames) {
						r.altNames.forEach((e) => {
							Network.register(e, func);
						});
					}
				}
				registerEth('mainnet', 1, { ensNetwork: 1, altNames: ['homestead'] });
				registerEth('ropsten', 3, { ensNetwork: 3 });
				registerEth('rinkeby', 4, { ensNetwork: 4 });
				registerEth('goerli', 5, { ensNetwork: 5 });
				registerEth('kovan', 42, { ensNetwork: 42 });
				registerEth('sepolia', 11155111, { ensNetwork: 11155111 });
				registerEth('holesky', 17e3, { ensNetwork: 17e3 });
				registerEth('classic', 61, {});
				registerEth('classicKotti', 6, {});
				registerEth('arbitrum', 42161, { ensNetwork: 1 });
				registerEth('arbitrum-goerli', 421613, {});
				registerEth('arbitrum-sepolia', 421614, {});
				registerEth('base', 8453, { ensNetwork: 1 });
				registerEth('base-goerli', 84531, {});
				registerEth('base-sepolia', 84532, {});
				registerEth('bnb', 56, { ensNetwork: 1 });
				registerEth('bnbt', 97, {});
				registerEth('linea', 59144, { ensNetwork: 1 });
				registerEth('linea-goerli', 59140, {});
				registerEth('linea-sepolia', 59141, {});
				registerEth('matic', 137, {
					ensNetwork: 1,
					plugins: [getGasStationPlugin('https://gasstation.polygon.technology/v2')]
				});
				registerEth('matic-amoy', 80002, {});
				registerEth('matic-mumbai', 80001, {
					altNames: ['maticMumbai', 'maticmum'],
					plugins: [getGasStationPlugin('https://gasstation-testnet.polygon.technology/v2')]
				});
				registerEth('optimism', 10, { ensNetwork: 1, plugins: [] });
				registerEth('optimism-goerli', 420, {});
				registerEth('optimism-sepolia', 11155420, {});
				registerEth('xdai', 100, { ensNetwork: 1 });
			}
			var Ge = r(3679);
			function copy(e) {
				return JSON.parse(JSON.stringify(e));
			}
			function getPollingSubscriber(e, t) {
				if (t === 'block') {
					return new PollingBlockSubscriber(e);
				}
				if (isHexString(t, 32)) {
					return new PollingTransactionSubscriber(e, t);
				}
				assert(false, 'unsupported polling event', 'UNSUPPORTED_OPERATION', {
					operation: 'getPollingSubscriber',
					info: { event: t }
				});
			}
			class PollingBlockSubscriber {
				#ue;
				#le;
				#de;
				#he;
				constructor(e) {
					this.#ue = e;
					this.#le = null;
					this.#de = 4e3;
					this.#he = -2;
				}
				get pollingInterval() {
					return this.#de;
				}
				set pollingInterval(e) {
					this.#de = e;
				}
				async #pe() {
					try {
						const e = await this.#ue.getBlockNumber();
						if (this.#he === -2) {
							this.#he = e;
							return;
						}
						if (e !== this.#he) {
							for (let t = this.#he + 1; t <= e; t++) {
								if (this.#le == null) {
									return;
								}
								await this.#ue.emit('block', t);
							}
							this.#he = e;
						}
					} catch (e) {}
					if (this.#le == null) {
						return;
					}
					this.#le = this.#ue._setTimeout(this.#pe.bind(this), this.#de);
				}
				start() {
					if (this.#le) {
						return;
					}
					this.#le = this.#ue._setTimeout(this.#pe.bind(this), this.#de);
					this.#pe();
				}
				stop() {
					if (!this.#le) {
						return;
					}
					this.#ue._clearTimeout(this.#le);
					this.#le = null;
				}
				pause(e) {
					this.stop();
					if (e) {
						this.#he = -2;
					}
				}
				resume() {
					this.start();
				}
			}
			class OnBlockSubscriber {
				#ue;
				#pe;
				#me;
				constructor(e) {
					this.#ue = e;
					this.#me = false;
					this.#pe = (e) => {
						this._poll(e, this.#ue);
					};
				}
				async _poll(e, t) {
					throw new Error('sub-classes must override this');
				}
				start() {
					if (this.#me) {
						return;
					}
					this.#me = true;
					this.#pe(-2);
					this.#ue.on('block', this.#pe);
				}
				stop() {
					if (!this.#me) {
						return;
					}
					this.#me = false;
					this.#ue.off('block', this.#pe);
				}
				pause(e) {
					this.stop();
				}
				resume() {
					this.start();
				}
			}
			class PollingBlockTagSubscriber extends OnBlockSubscriber {
				#ge;
				#ve;
				constructor(e, t) {
					super(e);
					this.#ge = t;
					this.#ve = -2;
				}
				pause(e) {
					if (e) {
						this.#ve = -2;
					}
					super.pause(e);
				}
				async _poll(e, t) {
					const r = await t.getBlock(this.#ge);
					if (r == null) {
						return;
					}
					if (this.#ve === -2) {
						this.#ve = r.number;
					} else if (r.number > this.#ve) {
						t.emit(this.#ge, r.number);
						this.#ve = r.number;
					}
				}
			}
			class PollingOrphanSubscriber extends OnBlockSubscriber {
				#A;
				constructor(e, t) {
					super(e);
					this.#A = copy(t);
				}
				async _poll(e, t) {
					throw new Error('@TODO');
					console.log(this.#A);
				}
			}
			class PollingTransactionSubscriber extends OnBlockSubscriber {
				#ye;
				constructor(e, t) {
					super(e);
					this.#ye = t;
				}
				async _poll(e, t) {
					const r = await t.getTransactionReceipt(this.#ye);
					if (r) {
						t.emit(this.#ye, r);
					}
				}
			}
			class PollingEventSubscriber {
				#ue;
				#A;
				#le;
				#me;
				#he;
				constructor(e, t) {
					this.#ue = e;
					this.#A = copy(t);
					this.#le = this.#pe.bind(this);
					this.#me = false;
					this.#he = -2;
				}
				async #pe(e) {
					if (this.#he === -2) {
						return;
					}
					const t = copy(this.#A);
					t.fromBlock = this.#he + 1;
					t.toBlock = e;
					const r = await this.#ue.getLogs(t);
					if (r.length === 0) {
						if (this.#he < e - 60) {
							this.#he = e - 60;
						}
						return;
					}
					for (const e of r) {
						this.#ue.emit(this.#A, e);
						this.#he = e.blockNumber;
					}
				}
				start() {
					if (this.#me) {
						return;
					}
					this.#me = true;
					if (this.#he === -2) {
						this.#ue.getBlockNumber().then((e) => {
							this.#he = e;
						});
					}
					this.#ue.on('block', this.#le);
				}
				stop() {
					if (!this.#me) {
						return;
					}
					this.#me = false;
					this.#ue.off('block', this.#le);
				}
				pause(e) {
					this.stop();
					if (e) {
						this.#he = -2;
					}
				}
				resume() {
					this.start();
				}
			}
			const qe = BigInt(2);
			const Ve = 10;
			function isPromise(e) {
				return e && typeof e.then === 'function';
			}
			function getTag(e, t) {
				return (
					e +
					':' +
					JSON.stringify(t, (e, t) => {
						if (t == null) {
							return 'null';
						}
						if (typeof t === 'bigint') {
							return `bigint:${t.toString()}`;
						}
						if (typeof t === 'string') {
							return t.toLowerCase();
						}
						if (typeof t === 'object' && !Array.isArray(t)) {
							const e = Object.keys(t);
							e.sort();
							return e.reduce((e, r) => {
								e[r] = t[r];
								return e;
							}, {});
						}
						return t;
					})
				);
			}
			class UnmanagedSubscriber {
				name;
				constructor(e) {
					(0, l.n)(this, { name: e });
				}
				start() {}
				stop() {}
				pause(e) {}
				resume() {}
			}
			function abstract_provider_copy(e) {
				return JSON.parse(JSON.stringify(e));
			}
			function concisify(e) {
				e = Array.from(new Set(e).values());
				e.sort();
				return e;
			}
			async function getSubscription(e, t) {
				if (e == null) {
					throw new Error('invalid event');
				}
				if (Array.isArray(e)) {
					e = { topics: e };
				}
				if (typeof e === 'string') {
					switch (e) {
						case 'block':
						case 'debug':
						case 'error':
						case 'finalized':
						case 'network':
						case 'pending':
						case 'safe': {
							return { type: e, tag: e };
						}
					}
				}
				if ((0, m.Lo)(e, 32)) {
					const t = e.toLowerCase();
					return { type: 'transaction', tag: getTag('tx', { hash: t }), hash: t };
				}
				if (e.orphan) {
					const t = e;
					return { type: 'orphan', tag: getTag('orphan', t), filter: abstract_provider_copy(t) };
				}
				if (e.address || e.topics) {
					const r = e;
					const i = {
						topics: (r.topics || []).map((e) => {
							if (e == null) {
								return null;
							}
							if (Array.isArray(e)) {
								return concisify(e.map((e) => e.toLowerCase()));
							}
							return e.toLowerCase();
						})
					};
					if (r.address) {
						const e = [];
						const a = [];
						const addAddress = (r) => {
							if ((0, m.Lo)(r)) {
								e.push(r);
							} else {
								a.push(
									(async () => {
										e.push(await (0, o.tG)(r, t));
									})()
								);
							}
						};
						if (Array.isArray(r.address)) {
							r.address.forEach(addAddress);
						} else {
							addAddress(r.address);
						}
						if (a.length) {
							await Promise.all(a);
						}
						i.address = concisify(e.map((e) => e.toLowerCase()));
					}
					return { filter: i, tag: getTag('event', i), type: 'event' };
				}
				(0, d.MR)(false, 'unknown ProviderEvent', 'event', e);
			}
			function abstract_provider_getTime() {
				return new Date().getTime();
			}
			const Ke = { cacheTimeout: 250, pollingInterval: 4e3 };
			class AbstractProvider {
				#be;
				#fe;
				#we;
				#_e;
				#Ae;
				#Ee;
				#Se;
				#ke;
				#Ne;
				#Te;
				#xe;
				#w;
				constructor(e, t) {
					this.#w = Object.assign({}, Ke, t || {});
					if (e === 'any') {
						this.#Ee = true;
						this.#Ae = null;
					} else if (e) {
						const t = Network.from(e);
						this.#Ee = false;
						this.#Ae = Promise.resolve(t);
						setTimeout(() => {
							this.emit('network', t, null);
						}, 0);
					} else {
						this.#Ee = false;
						this.#Ae = null;
					}
					this.#ke = -1;
					this.#Se = new Map();
					this.#be = new Map();
					this.#fe = new Map();
					this.#we = null;
					this.#_e = false;
					this.#Ne = 1;
					this.#Te = new Map();
					this.#xe = false;
				}
				get pollingInterval() {
					return this.#w.pollingInterval;
				}
				get provider() {
					return this;
				}
				get plugins() {
					return Array.from(this.#fe.values());
				}
				attachPlugin(e) {
					if (this.#fe.get(e.name)) {
						throw new Error(`cannot replace existing plugin: ${e.name} `);
					}
					this.#fe.set(e.name, e.connect(this));
					return this;
				}
				getPlugin(e) {
					return this.#fe.get(e) || null;
				}
				get disableCcipRead() {
					return this.#xe;
				}
				set disableCcipRead(e) {
					this.#xe = !!e;
				}
				async #Be(e) {
					const t = this.#w.cacheTimeout;
					if (t < 0) {
						return await this._perform(e);
					}
					const r = getTag(e.method, e);
					let i = this.#Se.get(r);
					if (!i) {
						i = this._perform(e);
						this.#Se.set(r, i);
						setTimeout(() => {
							if (this.#Se.get(r) === i) {
								this.#Se.delete(r);
							}
						}, t);
					}
					return await i;
				}
				async ccipReadFetch(e, t, r) {
					if (this.disableCcipRead || r.length === 0 || e.to == null) {
						return null;
					}
					const i = e.to.toLowerCase();
					const a = t.toLowerCase();
					const o = [];
					for (let t = 0; t < r.length; t++) {
						const c = r[t];
						const u = c.replace('{sender}', i).replace('{data}', a);
						const l = new FetchRequest(u);
						if (c.indexOf('{data}') === -1) {
							l.body = { data: a, sender: i };
						}
						this.emit('debug', {
							action: 'sendCcipReadFetchRequest',
							request: l,
							index: t,
							urls: r
						});
						let p = 'unknown error';
						let m;
						try {
							m = await l.send();
						} catch (e) {
							o.push(e.message);
							this.emit('debug', {
								action: 'receiveCcipReadFetchError',
								request: l,
								result: { error: e }
							});
							continue;
						}
						try {
							const e = m.bodyJson;
							if (e.data) {
								this.emit('debug', { action: 'receiveCcipReadFetchResult', request: l, result: e });
								return e.data;
							}
							if (e.message) {
								p = e.message;
							}
							this.emit('debug', { action: 'receiveCcipReadFetchError', request: l, result: e });
						} catch (e) {}
						(0, d.vA)(
							m.statusCode < 400 || m.statusCode >= 500,
							`response not found during CCIP fetch: ${p}`,
							'OFFCHAIN_FAULT',
							{ reason: '404_MISSING_RESOURCE', transaction: e, info: { url: c, errorMessage: p } }
						);
						o.push(p);
					}
					(0, d.vA)(
						false,
						`error encountered during CCIP fetch: ${o.map((e) => JSON.stringify(e)).join(', ')}`,
						'OFFCHAIN_FAULT',
						{ reason: '500_SERVER_ERROR', transaction: e, info: { urls: r, errorMessages: o } }
					);
				}
				_wrapBlock(e, t) {
					return new Ge.eB(formatBlock(e), this);
				}
				_wrapLog(e, t) {
					return new Ge.tG(formatLog(e), this);
				}
				_wrapTransactionReceipt(e, t) {
					return new Ge.z5(formatTransactionReceipt(e), this);
				}
				_wrapTransactionResponse(e, t) {
					return new Ge.uI(formatTransactionResponse(e), this);
				}
				_detectNetwork() {
					(0, d.vA)(false, 'sub-classes must implement this', 'UNSUPPORTED_OPERATION', {
						operation: '_detectNetwork'
					});
				}
				async _perform(e) {
					(0, d.vA)(false, `unsupported method: ${e.method}`, 'UNSUPPORTED_OPERATION', {
						operation: e.method,
						info: e
					});
				}
				async getBlockNumber() {
					const e = (0, g.WZ)(await this.#Be({ method: 'getBlockNumber' }), '%response');
					if (this.#ke >= 0) {
						this.#ke = e;
					}
					return e;
				}
				_getAddress(e) {
					return (0, o.tG)(e, this);
				}
				_getBlockTag(e) {
					if (e == null) {
						return 'latest';
					}
					switch (e) {
						case 'earliest':
							return '0x0';
						case 'finalized':
						case 'latest':
						case 'pending':
						case 'safe':
							return e;
					}
					if ((0, m.Lo)(e)) {
						if ((0, m.Lo)(e, 32)) {
							return e;
						}
						return (0, g.nD)(e);
					}
					if (typeof e === 'bigint') {
						e = (0, g.WZ)(e, 'blockTag');
					}
					if (typeof e === 'number') {
						if (e >= 0) {
							return (0, g.nD)(e);
						}
						if (this.#ke >= 0) {
							return (0, g.nD)(this.#ke + e);
						}
						return this.getBlockNumber().then((t) => (0, g.nD)(t + e));
					}
					(0, d.MR)(false, 'invalid blockTag', 'blockTag', e);
				}
				_getFilter(e) {
					const t = (e.topics || []).map((e) => {
						if (e == null) {
							return null;
						}
						if (Array.isArray(e)) {
							return concisify(e.map((e) => e.toLowerCase()));
						}
						return e.toLowerCase();
					});
					const r = 'blockHash' in e ? e.blockHash : undefined;
					const resolve = (e, i, a) => {
						let o = undefined;
						switch (e.length) {
							case 0:
								break;
							case 1:
								o = e[0];
								break;
							default:
								e.sort();
								o = e;
						}
						if (r) {
							if (i != null || a != null) {
								throw new Error('invalid filter');
							}
						}
						const c = {};
						if (o) {
							c.address = o;
						}
						if (t.length) {
							c.topics = t;
						}
						if (i) {
							c.fromBlock = i;
						}
						if (a) {
							c.toBlock = a;
						}
						if (r) {
							c.blockHash = r;
						}
						return c;
					};
					let i = [];
					if (e.address) {
						if (Array.isArray(e.address)) {
							for (const t of e.address) {
								i.push(this._getAddress(t));
							}
						} else {
							i.push(this._getAddress(e.address));
						}
					}
					let a = undefined;
					if ('fromBlock' in e) {
						a = this._getBlockTag(e.fromBlock);
					}
					let o = undefined;
					if ('toBlock' in e) {
						o = this._getBlockTag(e.toBlock);
					}
					if (
						i.filter((e) => typeof e !== 'string').length ||
						(a != null && typeof a !== 'string') ||
						(o != null && typeof o !== 'string')
					) {
						return Promise.all([Promise.all(i), a, o]).then((e) => resolve(e[0], e[1], e[2]));
					}
					return resolve(i, a, o);
				}
				_getTransactionRequest(e) {
					const t = (0, Ge.VS)(e);
					const r = [];
					['to', 'from'].forEach((e) => {
						if (t[e] == null) {
							return;
						}
						const i = (0, o.tG)(t[e], this);
						if (isPromise(i)) {
							r.push(
								(async function () {
									t[e] = await i;
								})()
							);
						} else {
							t[e] = i;
						}
					});
					if (t.blockTag != null) {
						const e = this._getBlockTag(t.blockTag);
						if (isPromise(e)) {
							r.push(
								(async function () {
									t.blockTag = await e;
								})()
							);
						} else {
							t.blockTag = e;
						}
					}
					if (r.length) {
						return (async function () {
							await Promise.all(r);
							return t;
						})();
					}
					return t;
				}
				async getNetwork() {
					if (this.#Ae == null) {
						const e = (async () => {
							try {
								const e = await this._detectNetwork();
								this.emit('network', e, null);
								return e;
							} catch (t) {
								if (this.#Ae === e) {
									this.#Ae = null;
								}
								throw t;
							}
						})();
						this.#Ae = e;
						return (await e).clone();
					}
					const e = this.#Ae;
					const [t, r] = await Promise.all([e, this._detectNetwork()]);
					if (t.chainId !== r.chainId) {
						if (this.#Ee) {
							this.emit('network', r, t);
							if (this.#Ae === e) {
								this.#Ae = Promise.resolve(r);
							}
						} else {
							(0, d.vA)(false, `network changed: ${t.chainId} => ${r.chainId} `, 'NETWORK_ERROR', {
								event: 'changed'
							});
						}
					}
					return t.clone();
				}
				async getFeeData() {
					const e = await this.getNetwork();
					const getFeeDataFunc = async () => {
						const {
							_block: t,
							gasPrice: r,
							priorityFee: i
						} = await (0, l.k)({
							_block: this.#Re('latest', false),
							gasPrice: (async () => {
								try {
									const e = await this.#Be({ method: 'getGasPrice' });
									return (0, g.Ab)(e, '%response');
								} catch (e) {}
								return null;
							})(),
							priorityFee: (async () => {
								try {
									const e = await this.#Be({ method: 'getPriorityFee' });
									return (0, g.Ab)(e, '%response');
								} catch (e) {}
								return null;
							})()
						});
						let a = null;
						let o = null;
						const c = this._wrapBlock(t, e);
						if (c && c.baseFeePerGas) {
							o = i != null ? i : BigInt('1000000000');
							a = c.baseFeePerGas * qe + o;
						}
						return new Ge.J9(r, a, o);
					};
					const t = e.getPlugin('org.ethers.plugins.network.FetchUrlFeeDataPlugin');
					if (t) {
						const e = new FetchRequest(t.url);
						const r = await t.processFunc(getFeeDataFunc, this, e);
						return new Ge.J9(r.gasPrice, r.maxFeePerGas, r.maxPriorityFeePerGas);
					}
					return await getFeeDataFunc();
				}
				async estimateGas(e) {
					let t = this._getTransactionRequest(e);
					if (isPromise(t)) {
						t = await t;
					}
					return (0, g.Ab)(await this.#Be({ method: 'estimateGas', transaction: t }), '%response');
				}
				async #Pe(e, t, r) {
					(0, d.vA)(r < Ve, 'CCIP read exceeded maximum redirections', 'OFFCHAIN_FAULT', {
						reason: 'TOO_MANY_REDIRECTS',
						transaction: Object.assign({}, e, { blockTag: t, enableCcipRead: true })
					});
					const i = (0, Ge.VS)(e);
					try {
						return (0, m.c$)(await this._perform({ method: 'call', transaction: i, blockTag: t }));
					} catch (e) {
						if (
							!this.disableCcipRead &&
							(0, d.E)(e) &&
							e.data &&
							r >= 0 &&
							t === 'latest' &&
							i.to != null &&
							(0, m.ZG)(e.data, 0, 4) === '0x556f1830'
						) {
							const a = e.data;
							const c = await (0, o.tG)(i.to, this);
							let u;
							try {
								u = parseOffchainLookup((0, m.ZG)(e.data, 4));
							} catch (e) {
								(0, d.vA)(false, e.message, 'OFFCHAIN_FAULT', {
									reason: 'BAD_DATA',
									transaction: i,
									info: { data: a }
								});
							}
							(0, d.vA)(
								u.sender.toLowerCase() === c.toLowerCase(),
								'CCIP Read sender mismatch',
								'CALL_EXCEPTION',
								{
									action: 'call',
									data: a,
									reason: 'OffchainLookup',
									transaction: i,
									invocation: null,
									revert: {
										signature: 'OffchainLookup(address,string[],bytes,bytes4,bytes)',
										name: 'OffchainLookup',
										args: u.errorArgs
									}
								}
							);
							const l = await this.ccipReadFetch(i, u.calldata, u.urls);
							(0, d.vA)(l != null, 'CCIP Read failed to fetch data', 'OFFCHAIN_FAULT', {
								reason: 'FETCH_FAILED',
								transaction: i,
								info: { data: e.data, errorArgs: u.errorArgs }
							});
							const p = { to: c, data: (0, m.xW)([u.selector, encodeBytes([l, u.extraData])]) };
							this.emit('debug', { action: 'sendCcipReadCall', transaction: p });
							try {
								const e = await this.#Pe(p, t, r + 1);
								this.emit('debug', {
									action: 'receiveCcipReadCallResult',
									transaction: Object.assign({}, p),
									result: e
								});
								return e;
							} catch (e) {
								this.emit('debug', {
									action: 'receiveCcipReadCallError',
									transaction: Object.assign({}, p),
									error: e
								});
								throw e;
							}
						}
						throw e;
					}
				}
				async #Me(e) {
					const { value: t } = await (0, l.k)({ network: this.getNetwork(), value: e });
					return t;
				}
				async call(e) {
					const { tx: t, blockTag: r } = await (0, l.k)({
						tx: this._getTransactionRequest(e),
						blockTag: this._getBlockTag(e.blockTag)
					});
					return await this.#Me(this.#Pe(t, r, e.enableCcipRead ? 0 : -1));
				}
				async #Ce(e, t, r) {
					let i = this._getAddress(t);
					let a = this._getBlockTag(r);
					if (typeof i !== 'string' || typeof a !== 'string') {
						[i, a] = await Promise.all([i, a]);
					}
					return await this.#Me(this.#Be(Object.assign(e, { address: i, blockTag: a })));
				}
				async getBalance(e, t) {
					return (0, g.Ab)(await this.#Ce({ method: 'getBalance' }, e, t), '%response');
				}
				async getTransactionCount(e, t) {
					return (0, g.WZ)(await this.#Ce({ method: 'getTransactionCount' }, e, t), '%response');
				}
				async getCode(e, t) {
					return (0, m.c$)(await this.#Ce({ method: 'getCode' }, e, t));
				}
				async getStorage(e, t, r) {
					const i = (0, g.Ab)(t, 'position');
					return (0, m.c$)(await this.#Ce({ method: 'getStorage', position: i }, e, r));
				}
				async broadcastTransaction(e) {
					const {
						blockNumber: t,
						hash: r,
						network: i
					} = await (0, l.k)({
						blockNumber: this.getBlockNumber(),
						hash: this._perform({ method: 'broadcastTransaction', signedTransaction: e }),
						network: this.getNetwork()
					});
					const a = xe.Z.from(e);
					if (a.hash !== r) {
						throw new Error('@TODO: the returned hash did not match');
					}
					return this._wrapTransactionResponse(a, i).replaceableTransaction(t);
				}
				async #Re(e, t) {
					if ((0, m.Lo)(e, 32)) {
						return await this.#Be({ method: 'getBlock', blockHash: e, includeTransactions: t });
					}
					let r = this._getBlockTag(e);
					if (typeof r !== 'string') {
						r = await r;
					}
					return await this.#Be({ method: 'getBlock', blockTag: r, includeTransactions: t });
				}
				async getBlock(e, t) {
					const { network: r, params: i } = await (0, l.k)({
						network: this.getNetwork(),
						params: this.#Re(e, !!t)
					});
					if (i == null) {
						return null;
					}
					return this._wrapBlock(i, r);
				}
				async getTransaction(e) {
					const { network: t, params: r } = await (0, l.k)({
						network: this.getNetwork(),
						params: this.#Be({ method: 'getTransaction', hash: e })
					});
					if (r == null) {
						return null;
					}
					return this._wrapTransactionResponse(r, t);
				}
				async getTransactionReceipt(e) {
					const { network: t, params: r } = await (0, l.k)({
						network: this.getNetwork(),
						params: this.#Be({ method: 'getTransactionReceipt', hash: e })
					});
					if (r == null) {
						return null;
					}
					if (r.gasPrice == null && r.effectiveGasPrice == null) {
						const t = await this.#Be({ method: 'getTransaction', hash: e });
						if (t == null) {
							throw new Error('report this; could not find tx or effectiveGasPrice');
						}
						r.effectiveGasPrice = t.gasPrice;
					}
					return this._wrapTransactionReceipt(r, t);
				}
				async getTransactionResult(e) {
					const { result: t } = await (0, l.k)({
						network: this.getNetwork(),
						result: this.#Be({ method: 'getTransactionResult', hash: e })
					});
					if (t == null) {
						return null;
					}
					return (0, m.c$)(t);
				}
				async getLogs(e) {
					let t = this._getFilter(e);
					if (isPromise(t)) {
						t = await t;
					}
					const { network: r, params: i } = await (0, l.k)({
						network: this.getNetwork(),
						params: this.#Be({ method: 'getLogs', filter: t })
					});
					return i.map((e) => this._wrapLog(e, r));
				}
				_getProvider(e) {
					(0, d.vA)(false, 'provider cannot connect to target network', 'UNSUPPORTED_OPERATION', {
						operation: '_getProvider()'
					});
				}
				async getResolver(e) {
					return await EnsResolver.fromName(this, e);
				}
				async getAvatar(e) {
					const t = await this.getResolver(e);
					if (t) {
						return await t.getAvatar();
					}
					return null;
				}
				async resolveName(e) {
					const t = await this.getResolver(e);
					if (t) {
						return await t.getAddress();
					}
					return null;
				}
				async lookupAddress(e) {
					e = (0, a.b)(e);
					const t = namehash(e.substring(2).toLowerCase() + '.addr.reverse');
					try {
						const r = await EnsResolver.getEnsAddress(this);
						const i = new P.NZ(r, ['function resolver(bytes32) view returns (address)'], this);
						const a = await i.resolver(t);
						if (a == null || a === B.j) {
							return null;
						}
						const o = new P.NZ(a, ['function name(bytes32) view returns (string)'], this);
						const c = await o.name(t);
						const u = await this.resolveName(c);
						if (u !== e) {
							return null;
						}
						return c;
					} catch (e) {
						if ((0, d.bJ)(e, 'BAD_DATA') && e.value === '0x') {
							return null;
						}
						if ((0, d.bJ)(e, 'CALL_EXCEPTION')) {
							return null;
						}
						throw e;
					}
					return null;
				}
				async waitForTransaction(e, t, r) {
					const i = t != null ? t : 1;
					if (i === 0) {
						return this.getTransactionReceipt(e);
					}
					return new Promise(async (t, a) => {
						let o = null;
						const listener = async (r) => {
							try {
								const a = await this.getTransactionReceipt(e);
								if (a != null) {
									if (r - a.blockNumber + 1 >= i) {
										t(a);
										if (o) {
											clearTimeout(o);
											o = null;
										}
										return;
									}
								}
							} catch (e) {
								console.log('EEE', e);
							}
							this.once('block', listener);
						};
						if (r != null) {
							o = setTimeout(() => {
								if (o == null) {
									return;
								}
								o = null;
								this.off('block', listener);
								a((0, d.xz)('timeout', 'TIMEOUT', { reason: 'timeout' }));
							}, r);
						}
						listener(await this.getBlockNumber());
					});
				}
				async waitForBlock(e) {
					(0, d.vA)(false, 'not implemented yet', 'NOT_IMPLEMENTED', { operation: 'waitForBlock' });
				}
				_clearTimeout(e) {
					const t = this.#Te.get(e);
					if (!t) {
						return;
					}
					if (t.timer) {
						clearTimeout(t.timer);
					}
					this.#Te.delete(e);
				}
				_setTimeout(e, t) {
					if (t == null) {
						t = 0;
					}
					const r = this.#Ne++;
					const func = () => {
						this.#Te.delete(r);
						e();
					};
					if (this.paused) {
						this.#Te.set(r, { timer: null, func, time: t });
					} else {
						const e = setTimeout(func, t);
						this.#Te.set(r, { timer: e, func, time: abstract_provider_getTime() });
					}
					return r;
				}
				_forEachSubscriber(e) {
					for (const t of this.#be.values()) {
						e(t.subscriber);
					}
				}
				_getSubscriber(e) {
					switch (e.type) {
						case 'debug':
						case 'error':
						case 'network':
							return new UnmanagedSubscriber(e.type);
						case 'block': {
							const e = new PollingBlockSubscriber(this);
							e.pollingInterval = this.pollingInterval;
							return e;
						}
						case 'safe':
						case 'finalized':
							return new PollingBlockTagSubscriber(this, e.type);
						case 'event':
							return new PollingEventSubscriber(this, e.filter);
						case 'transaction':
							return new PollingTransactionSubscriber(this, e.hash);
						case 'orphan':
							return new PollingOrphanSubscriber(this, e.filter);
					}
					throw new Error(`unsupported event: ${e.type}`);
				}
				_recoverSubscriber(e, t) {
					for (const r of this.#be.values()) {
						if (r.subscriber === e) {
							if (r.started) {
								r.subscriber.stop();
							}
							r.subscriber = t;
							if (r.started) {
								t.start();
							}
							if (this.#we != null) {
								t.pause(this.#we);
							}
							break;
						}
					}
				}
				async #Ie(e, t) {
					let r = await getSubscription(e, this);
					if (r.type === 'event' && t && t.length > 0 && t[0].removed === true) {
						r = await getSubscription({ orphan: 'drop-log', log: t[0] }, this);
					}
					return this.#be.get(r.tag) || null;
				}
				async #Oe(e) {
					const t = await getSubscription(e, this);
					const r = t.tag;
					let i = this.#be.get(r);
					if (!i) {
						const e = this._getSubscriber(t);
						const a = new WeakMap();
						const o = new Map();
						i = {
							subscriber: e,
							tag: r,
							addressableMap: a,
							nameMap: o,
							started: false,
							listeners: []
						};
						this.#be.set(r, i);
					}
					return i;
				}
				async on(e, t) {
					const r = await this.#Oe(e);
					r.listeners.push({ listener: t, once: false });
					if (!r.started) {
						r.subscriber.start();
						r.started = true;
						if (this.#we != null) {
							r.subscriber.pause(this.#we);
						}
					}
					return this;
				}
				async once(e, t) {
					const r = await this.#Oe(e);
					r.listeners.push({ listener: t, once: true });
					if (!r.started) {
						r.subscriber.start();
						r.started = true;
						if (this.#we != null) {
							r.subscriber.pause(this.#we);
						}
					}
					return this;
				}
				async emit(e, ...t) {
					const r = await this.#Ie(e, t);
					if (!r || r.listeners.length === 0) {
						return false;
					}
					const i = r.listeners.length;
					r.listeners = r.listeners.filter(({ listener: r, once: i }) => {
						const a = new Be.z(this, i ? null : r, e);
						try {
							r.call(this, ...t, a);
						} catch (e) {}
						return !i;
					});
					if (r.listeners.length === 0) {
						if (r.started) {
							r.subscriber.stop();
						}
						this.#be.delete(r.tag);
					}
					return i > 0;
				}
				async listenerCount(e) {
					if (e) {
						const t = await this.#Ie(e);
						if (!t) {
							return 0;
						}
						return t.listeners.length;
					}
					let t = 0;
					for (const { listeners: e } of this.#be.values()) {
						t += e.length;
					}
					return t;
				}
				async listeners(e) {
					if (e) {
						const t = await this.#Ie(e);
						if (!t) {
							return [];
						}
						return t.listeners.map(({ listener: e }) => e);
					}
					let t = [];
					for (const { listeners: e } of this.#be.values()) {
						t = t.concat(e.map(({ listener: e }) => e));
					}
					return t;
				}
				async off(e, t) {
					const r = await this.#Ie(e);
					if (!r) {
						return this;
					}
					if (t) {
						const e = r.listeners.map(({ listener: e }) => e).indexOf(t);
						if (e >= 0) {
							r.listeners.splice(e, 1);
						}
					}
					if (!t || r.listeners.length === 0) {
						if (r.started) {
							r.subscriber.stop();
						}
						this.#be.delete(r.tag);
					}
					return this;
				}
				async removeAllListeners(e) {
					if (e) {
						const { tag: t, started: r, subscriber: i } = await this.#Oe(e);
						if (r) {
							i.stop();
						}
						this.#be.delete(t);
					} else {
						for (const [e, { started: t, subscriber: r }] of this.#be) {
							if (t) {
								r.stop();
							}
							this.#be.delete(e);
						}
					}
					return this;
				}
				async addListener(e, t) {
					return await this.on(e, t);
				}
				async removeListener(e, t) {
					return this.off(e, t);
				}
				get destroyed() {
					return this.#_e;
				}
				destroy() {
					this.removeAllListeners();
					for (const e of this.#Te.keys()) {
						this._clearTimeout(e);
					}
					this.#_e = true;
				}
				get paused() {
					return this.#we != null;
				}
				set paused(e) {
					if (!!e === this.paused) {
						return;
					}
					if (this.paused) {
						this.resume();
					} else {
						this.pause(false);
					}
				}
				pause(e) {
					this.#ke = -1;
					if (this.#we != null) {
						if (this.#we == !!e) {
							return;
						}
						(0, d.vA)(false, 'cannot change pause type; resume first', 'UNSUPPORTED_OPERATION', {
							operation: 'pause'
						});
					}
					this._forEachSubscriber((t) => t.pause(e));
					this.#we = !!e;
					for (const e of this.#Te.values()) {
						if (e.timer) {
							clearTimeout(e.timer);
						}
						e.time = abstract_provider_getTime() - e.time;
					}
				}
				resume() {
					if (this.#we == null) {
						return;
					}
					this._forEachSubscriber((e) => e.resume());
					this.#we = null;
					for (const e of this.#Te.values()) {
						let t = e.time;
						if (t < 0) {
							t = 0;
						}
						e.time = abstract_provider_getTime();
						setTimeout(e.func, t);
					}
				}
			}
			function _parseString(e, t) {
				try {
					const r = _parseBytes(e, t);
					if (r) {
						return (0, p._v)(r);
					}
				} catch (e) {}
				return null;
			}
			function _parseBytes(e, t) {
				if (e === '0x') {
					return null;
				}
				try {
					const r = (0, g.WZ)((0, m.ZG)(e, t, t + 32));
					const i = (0, g.WZ)((0, m.ZG)(e, r, r + 32));
					return (0, m.ZG)(e, r + 32, r + 32 + i);
				} catch (e) {}
				return null;
			}
			function numPad(e) {
				const t = (0, g.c4)(e);
				if (t.length > 32) {
					throw new Error('internal; should not happen');
				}
				const r = new Uint8Array(32);
				r.set(t, 32 - t.length);
				return r;
			}
			function bytesPad(e) {
				if (e.length % 32 === 0) {
					return e;
				}
				const t = new Uint8Array(Math.ceil(e.length / 32) * 32);
				t.set(e);
				return t;
			}
			const We = new Uint8Array([]);
			function encodeBytes(e) {
				const t = [];
				let r = 0;
				for (let i = 0; i < e.length; i++) {
					t.push(We);
					r += 32;
				}
				for (let i = 0; i < e.length; i++) {
					const a = (0, m.q5)(e[i]);
					t[i] = numPad(r);
					t.push(numPad(a.length));
					t.push(bytesPad(a));
					r += 32 + Math.ceil(a.length / 32) * 32;
				}
				return (0, m.xW)(t);
			}
			const Je = '0x0000000000000000000000000000000000000000000000000000000000000000';
			function parseOffchainLookup(e) {
				const t = {
					sender: '',
					urls: [],
					calldata: '',
					selector: '',
					extraData: '',
					errorArgs: []
				};
				(0, d.vA)((0, m.pO)(e) >= 5 * 32, 'insufficient OffchainLookup data', 'OFFCHAIN_FAULT', {
					reason: 'insufficient OffchainLookup data'
				});
				const r = (0, m.ZG)(e, 0, 32);
				(0, d.vA)(
					(0, m.ZG)(r, 0, 12) === (0, m.ZG)(Je, 0, 12),
					'corrupt OffchainLookup sender',
					'OFFCHAIN_FAULT',
					{ reason: 'corrupt OffchainLookup sender' }
				);
				t.sender = (0, m.ZG)(r, 12);
				try {
					const r = [];
					const i = (0, g.WZ)((0, m.ZG)(e, 32, 64));
					const a = (0, g.WZ)((0, m.ZG)(e, i, i + 32));
					const o = (0, m.ZG)(e, i + 32);
					for (let e = 0; e < a; e++) {
						const t = _parseString(o, e * 32);
						if (t == null) {
							throw new Error('abort');
						}
						r.push(t);
					}
					t.urls = r;
				} catch (e) {
					(0, d.vA)(false, 'corrupt OffchainLookup urls', 'OFFCHAIN_FAULT', {
						reason: 'corrupt OffchainLookup urls'
					});
				}
				try {
					const r = _parseBytes(e, 64);
					if (r == null) {
						throw new Error('abort');
					}
					t.calldata = r;
				} catch (e) {
					(0, d.vA)(false, 'corrupt OffchainLookup calldata', 'OFFCHAIN_FAULT', {
						reason: 'corrupt OffchainLookup calldata'
					});
				}
				(0, d.vA)(
					(0, m.ZG)(e, 100, 128) === (0, m.ZG)(Je, 0, 28),
					'corrupt OffchainLookup callbaackSelector',
					'OFFCHAIN_FAULT',
					{ reason: 'corrupt OffchainLookup callbaackSelector' }
				);
				t.selector = (0, m.ZG)(e, 96, 100);
				try {
					const r = _parseBytes(e, 128);
					if (r == null) {
						throw new Error('abort');
					}
					t.extraData = r;
				} catch (e) {
					(0, d.vA)(false, 'corrupt OffchainLookup extraData', 'OFFCHAIN_FAULT', {
						reason: 'corrupt OffchainLookup extraData'
					});
				}
				t.errorArgs = 'sender,urls,calldata,selector,extraData'.split(/,/).map((e) => t[e]);
				return t;
			}
			var Ze = r(6959);
			function subscriber_filterid_copy(e) {
				return JSON.parse(JSON.stringify(e));
			}
			class FilterIdSubscriber {
				#ue;
				#Fe;
				#le;
				#me;
				#De;
				#Le;
				constructor(e) {
					this.#ue = e;
					this.#Fe = null;
					this.#le = this.#pe.bind(this);
					this.#me = false;
					this.#De = null;
					this.#Le = false;
				}
				_subscribe(e) {
					throw new Error('subclasses must override this');
				}
				_emitResults(e, t) {
					throw new Error('subclasses must override this');
				}
				_recover(e) {
					throw new Error('subclasses must override this');
				}
				async #pe(e) {
					try {
						if (this.#Fe == null) {
							this.#Fe = this._subscribe(this.#ue);
						}
						let e = null;
						try {
							e = await this.#Fe;
						} catch (e) {
							if (!(0, d.bJ)(e, 'UNSUPPORTED_OPERATION') || e.operation !== 'eth_newFilter') {
								throw e;
							}
						}
						if (e == null) {
							this.#Fe = null;
							this.#ue._recoverSubscriber(this, this._recover(this.#ue));
							return;
						}
						const t = await this.#ue.getNetwork();
						if (!this.#De) {
							this.#De = t;
						}
						if (this.#De.chainId !== t.chainId) {
							throw new Error('chaid changed');
						}
						if (this.#Le) {
							return;
						}
						const r = await this.#ue.send('eth_getFilterChanges', [e]);
						await this._emitResults(this.#ue, r);
					} catch (e) {
						console.log('@TODO', e);
					}
					this.#ue.once('block', this.#le);
				}
				#Ue() {
					const e = this.#Fe;
					if (e) {
						this.#Fe = null;
						e.then((e) => {
							if (this.#ue.destroyed) {
								return;
							}
							this.#ue.send('eth_uninstallFilter', [e]);
						});
					}
				}
				start() {
					if (this.#me) {
						return;
					}
					this.#me = true;
					this.#pe(-2);
				}
				stop() {
					if (!this.#me) {
						return;
					}
					this.#me = false;
					this.#Le = true;
					this.#Ue();
					this.#ue.off('block', this.#le);
				}
				pause(e) {
					if (e) {
						this.#Ue();
					}
					this.#ue.off('block', this.#le);
				}
				resume() {
					this.start();
				}
			}
			class FilterIdEventSubscriber extends FilterIdSubscriber {
				#je;
				constructor(e, t) {
					super(e);
					this.#je = subscriber_filterid_copy(t);
				}
				_recover(e) {
					return new PollingEventSubscriber(e, this.#je);
				}
				async _subscribe(e) {
					const t = await e.send('eth_newFilter', [this.#je]);
					return t;
				}
				async _emitResults(e, t) {
					for (const r of t) {
						e.emit(this.#je, e._wrapLog(r, e._network));
					}
				}
			}
			class FilterIdPendingSubscriber extends FilterIdSubscriber {
				async _subscribe(e) {
					return await e.send('eth_newPendingTransactionFilter', []);
				}
				async _emitResults(e, t) {
					for (const r of t) {
						e.emit('pending', r);
					}
				}
			}
			const Qe = 'bigint,boolean,function,number,string,symbol'.split(/,/g);
			function deepCopy(e) {
				if (e == null || Qe.indexOf(typeof e) >= 0) {
					return e;
				}
				if (typeof e.getAddress === 'function') {
					return e;
				}
				if (Array.isArray(e)) {
					return e.map(deepCopy);
				}
				if (typeof e === 'object') {
					return Object.keys(e).reduce((t, r) => {
						t[r] = e[r];
						return t;
					}, {});
				}
				throw new Error(`should not happen: ${e} (${typeof e})`);
			}
			function stall(e) {
				return new Promise((t) => {
					setTimeout(t, e);
				});
			}
			function getLowerCase(e) {
				if (e) {
					return e.toLowerCase();
				}
				return e;
			}
			function isPollable(e) {
				return e && typeof e.pollingInterval === 'number';
			}
			const Ye = {
				polling: false,
				staticNetwork: null,
				batchStallTime: 10,
				batchMaxSize: 1 << 20,
				batchMaxCount: 100,
				cacheTimeout: 250,
				pollingInterval: 4e3
			};
			class JsonRpcSigner extends Ze.Z {
				address;
				constructor(e, t) {
					super(e);
					t = (0, a.b)(t);
					(0, l.n)(this, { address: t });
				}
				connect(e) {
					(0, d.vA)(false, 'cannot reconnect JsonRpcSigner', 'UNSUPPORTED_OPERATION', {
						operation: 'signer.connect'
					});
				}
				async getAddress() {
					return this.address;
				}
				async populateTransaction(e) {
					return await this.populateCall(e);
				}
				async sendUncheckedTransaction(e) {
					const t = deepCopy(e);
					const r = [];
					if (t.from) {
						const i = t.from;
						r.push(
							(async () => {
								const r = await (0, o.tG)(i, this.provider);
								(0, d.MR)(
									r != null && r.toLowerCase() === this.address.toLowerCase(),
									'from address mismatch',
									'transaction',
									e
								);
								t.from = r;
							})()
						);
					} else {
						t.from = this.address;
					}
					if (t.gasLimit == null) {
						r.push(
							(async () => {
								t.gasLimit = await this.provider.estimateGas({ ...t, from: this.address });
							})()
						);
					}
					if (t.to != null) {
						const e = t.to;
						r.push(
							(async () => {
								t.to = await (0, o.tG)(e, this.provider);
							})()
						);
					}
					if (r.length) {
						await Promise.all(r);
					}
					const i = this.provider.getRpcTransaction(t);
					return this.provider.send('eth_sendTransaction', [i]);
				}
				async sendTransaction(e) {
					const t = await this.provider.getBlockNumber();
					const r = await this.sendUncheckedTransaction(e);
					return await new Promise((e, i) => {
						const a = [1e3, 100];
						let o = 0;
						const checkTx = async () => {
							try {
								const i = await this.provider.getTransaction(r);
								if (i != null) {
									e(i.replaceableTransaction(t));
									return;
								}
							} catch (e) {
								if (
									(0, d.bJ)(e, 'CANCELLED') ||
									(0, d.bJ)(e, 'BAD_DATA') ||
									(0, d.bJ)(e, 'NETWORK_ERROR') ||
									(0, d.bJ)(e, 'UNSUPPORTED_OPERATION')
								) {
									if (e.info == null) {
										e.info = {};
									}
									e.info.sendTransactionHash = r;
									i(e);
									return;
								}
								if ((0, d.bJ)(e, 'INVALID_ARGUMENT')) {
									o++;
									if (e.info == null) {
										e.info = {};
									}
									e.info.sendTransactionHash = r;
									if (o > 10) {
										i(e);
										return;
									}
								}
								this.provider.emit(
									'error',
									(0, d.xz)(
										'failed to fetch transation after sending (will try again)',
										'UNKNOWN_ERROR',
										{ error: e }
									)
								);
							}
							this.provider._setTimeout(() => {
								checkTx();
							}, a.pop() || 4e3);
						};
						checkTx();
					});
				}
				async signTransaction(e) {
					const t = deepCopy(e);
					if (t.from) {
						const r = await (0, o.tG)(t.from, this.provider);
						(0, d.MR)(
							r != null && r.toLowerCase() === this.address.toLowerCase(),
							'from address mismatch',
							'transaction',
							e
						);
						t.from = r;
					} else {
						t.from = this.address;
					}
					const r = this.provider.getRpcTransaction(t);
					return await this.provider.send('eth_signTransaction', [r]);
				}
				async signMessage(e) {
					const t = typeof e === 'string' ? (0, p.YW)(e) : e;
					return await this.provider.send('personal_sign', [
						(0, m.c$)(t),
						this.address.toLowerCase()
					]);
				}
				async signTypedData(e, t, r) {
					const i = deepCopy(r);
					const a = await c.z.resolveNames(e, t, i, async (e) => {
						const t = await (0, o.tG)(e);
						(0, d.MR)(t != null, 'TypedData does not support null address', 'value', e);
						return t;
					});
					return await this.provider.send('eth_signTypedData_v4', [
						this.address.toLowerCase(),
						JSON.stringify(c.z.getPayload(a.domain, t, a.value))
					]);
				}
				async unlock(e) {
					return this.provider.send('personal_unlockAccount', [
						this.address.toLowerCase(),
						e,
						null
					]);
				}
				async _legacySignMessage(e) {
					const t = typeof e === 'string' ? (0, p.YW)(e) : e;
					return await this.provider.send('eth_sign', [this.address.toLowerCase(), (0, m.c$)(t)]);
				}
			}
			class JsonRpcApiProvider extends AbstractProvider {
				#w;
				#He;
				#ze;
				#$e;
				#Ge;
				#De;
				#qe;
				#Ve() {
					if (this.#$e) {
						return;
					}
					const e = this._getOption('batchMaxCount') === 1 ? 0 : this._getOption('batchStallTime');
					this.#$e = setTimeout(() => {
						this.#$e = null;
						const e = this.#ze;
						this.#ze = [];
						while (e.length) {
							const t = [e.shift()];
							while (e.length) {
								if (t.length === this.#w.batchMaxCount) {
									break;
								}
								t.push(e.shift());
								const r = JSON.stringify(t.map((e) => e.payload));
								if (r.length > this.#w.batchMaxSize) {
									e.unshift(t.pop());
									break;
								}
							}
							(async () => {
								const e = t.length === 1 ? t[0].payload : t.map((e) => e.payload);
								this.emit('debug', { action: 'sendRpcPayload', payload: e });
								try {
									const r = await this._send(e);
									this.emit('debug', { action: 'receiveRpcResult', result: r });
									for (const { resolve: e, reject: i, payload: a } of t) {
										if (this.destroyed) {
											i(
												(0, d.xz)(
													'provider destroyed; cancelled request',
													'UNSUPPORTED_OPERATION',
													{ operation: a.method }
												)
											);
											continue;
										}
										const t = r.filter((e) => e.id === a.id)[0];
										if (t == null) {
											const e = (0, d.xz)('missing response for request', 'BAD_DATA', {
												value: r,
												info: { payload: a }
											});
											this.emit('error', e);
											i(e);
											continue;
										}
										if ('error' in t) {
											i(this.getRpcError(a, t));
											continue;
										}
										e(t.result);
									}
								} catch (e) {
									this.emit('debug', { action: 'receiveRpcError', error: e });
									for (const { reject: r } of t) {
										r(e);
									}
								}
							})();
						}
					}, e);
				}
				constructor(e, t) {
					super(e, t);
					this.#He = 1;
					this.#w = Object.assign({}, Ye, t || {});
					this.#ze = [];
					this.#$e = null;
					this.#De = null;
					this.#qe = null;
					{
						let e = null;
						const t = new Promise((t) => {
							e = t;
						});
						this.#Ge = { promise: t, resolve: e };
					}
					const r = this._getOption('staticNetwork');
					if (typeof r === 'boolean') {
						(0, d.MR)(
							!r || e !== 'any',
							"staticNetwork cannot be used on special network 'any'",
							'options',
							t
						);
						if (r && e != null) {
							this.#De = Network.from(e);
						}
					} else if (r) {
						(0, d.MR)(
							e == null || r.matches(e),
							'staticNetwork MUST match network object',
							'options',
							t
						);
						this.#De = r;
					}
				}
				_getOption(e) {
					return this.#w[e];
				}
				get _network() {
					(0, d.vA)(this.#De, 'network is not available yet', 'NETWORK_ERROR');
					return this.#De;
				}
				async _perform(e) {
					if (e.method === 'call' || e.method === 'estimateGas') {
						let t = e.transaction;
						if (t && t.type != null && (0, g.Ab)(t.type)) {
							if (t.maxFeePerGas == null && t.maxPriorityFeePerGas == null) {
								const r = await this.getFeeData();
								if (r.maxFeePerGas == null && r.maxPriorityFeePerGas == null) {
									e = Object.assign({}, e, {
										transaction: Object.assign({}, t, { type: undefined })
									});
								}
							}
						}
					}
					const t = this.getRpcRequest(e);
					if (t != null) {
						return await this.send(t.method, t.args);
					}
					return super._perform(e);
				}
				async _detectNetwork() {
					const e = this._getOption('staticNetwork');
					if (e) {
						if (e === true) {
							if (this.#De) {
								return this.#De;
							}
						} else {
							return e;
						}
					}
					if (this.#qe) {
						return await this.#qe;
					}
					if (this.ready) {
						this.#qe = (async () => {
							try {
								const e = Network.from((0, g.Ab)(await this.send('eth_chainId', [])));
								this.#qe = null;
								return e;
							} catch (e) {
								this.#qe = null;
								throw e;
							}
						})();
						return await this.#qe;
					}
					this.#qe = (async () => {
						const e = { id: this.#He++, method: 'eth_chainId', params: [], jsonrpc: '2.0' };
						this.emit('debug', { action: 'sendRpcPayload', payload: e });
						let t;
						try {
							t = (await this._send(e))[0];
							this.#qe = null;
						} catch (e) {
							this.#qe = null;
							this.emit('debug', { action: 'receiveRpcError', error: e });
							throw e;
						}
						this.emit('debug', { action: 'receiveRpcResult', result: t });
						if ('result' in t) {
							return Network.from((0, g.Ab)(t.result));
						}
						throw this.getRpcError(e, t);
					})();
					return await this.#qe;
				}
				_start() {
					if (this.#Ge == null || this.#Ge.resolve == null) {
						return;
					}
					this.#Ge.resolve();
					this.#Ge = null;
					(async () => {
						while (this.#De == null && !this.destroyed) {
							try {
								this.#De = await this._detectNetwork();
							} catch (e) {
								if (this.destroyed) {
									break;
								}
								console.log(
									'JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)'
								);
								this.emit(
									'error',
									(0, d.xz)('failed to bootstrap network detection', 'NETWORK_ERROR', {
										event: 'initial-network-discovery',
										info: { error: e }
									})
								);
								await stall(1e3);
							}
						}
						this.#Ve();
					})();
				}
				async _waitUntilReady() {
					if (this.#Ge == null) {
						return;
					}
					return await this.#Ge.promise;
				}
				_getSubscriber(e) {
					if (e.type === 'pending') {
						return new FilterIdPendingSubscriber(this);
					}
					if (e.type === 'event') {
						if (this._getOption('polling')) {
							return new PollingEventSubscriber(this, e.filter);
						}
						return new FilterIdEventSubscriber(this, e.filter);
					}
					if (e.type === 'orphan' && e.filter.orphan === 'drop-log') {
						return new UnmanagedSubscriber('orphan');
					}
					return super._getSubscriber(e);
				}
				get ready() {
					return this.#Ge == null;
				}
				getRpcTransaction(e) {
					const t = {};
					[
						'chainId',
						'gasLimit',
						'gasPrice',
						'type',
						'maxFeePerGas',
						'maxPriorityFeePerGas',
						'nonce',
						'value'
					].forEach((r) => {
						if (e[r] == null) {
							return;
						}
						let i = r;
						if (r === 'gasLimit') {
							i = 'gas';
						}
						t[i] = (0, g.nD)((0, g.Ab)(e[r], `tx.${r}`));
					});
					['from', 'to', 'data'].forEach((r) => {
						if (e[r] == null) {
							return;
						}
						t[r] = (0, m.c$)(e[r]);
					});
					if (e.accessList) {
						t['accessList'] = (0, u.$)(e.accessList);
					}
					if (e.blobVersionedHashes) {
						t['blobVersionedHashes'] = e.blobVersionedHashes.map((e) => e.toLowerCase());
					}
					return t;
				}
				getRpcRequest(e) {
					switch (e.method) {
						case 'chainId':
							return { method: 'eth_chainId', args: [] };
						case 'getBlockNumber':
							return { method: 'eth_blockNumber', args: [] };
						case 'getGasPrice':
							return { method: 'eth_gasPrice', args: [] };
						case 'getPriorityFee':
							return { method: 'eth_maxPriorityFeePerGas', args: [] };
						case 'getBalance':
							return { method: 'eth_getBalance', args: [getLowerCase(e.address), e.blockTag] };
						case 'getTransactionCount':
							return {
								method: 'eth_getTransactionCount',
								args: [getLowerCase(e.address), e.blockTag]
							};
						case 'getCode':
							return { method: 'eth_getCode', args: [getLowerCase(e.address), e.blockTag] };
						case 'getStorage':
							return {
								method: 'eth_getStorageAt',
								args: [getLowerCase(e.address), '0x' + e.position.toString(16), e.blockTag]
							};
						case 'broadcastTransaction':
							return { method: 'eth_sendRawTransaction', args: [e.signedTransaction] };
						case 'getBlock':
							if ('blockTag' in e) {
								return {
									method: 'eth_getBlockByNumber',
									args: [e.blockTag, !!e.includeTransactions]
								};
							} else if ('blockHash' in e) {
								return {
									method: 'eth_getBlockByHash',
									args: [e.blockHash, !!e.includeTransactions]
								};
							}
							break;
						case 'getTransaction':
							return { method: 'eth_getTransactionByHash', args: [e.hash] };
						case 'getTransactionReceipt':
							return { method: 'eth_getTransactionReceipt', args: [e.hash] };
						case 'call':
							return {
								method: 'eth_call',
								args: [this.getRpcTransaction(e.transaction), e.blockTag]
							};
						case 'estimateGas': {
							return { method: 'eth_estimateGas', args: [this.getRpcTransaction(e.transaction)] };
						}
						case 'getLogs':
							if (e.filter && e.filter.address != null) {
								if (Array.isArray(e.filter.address)) {
									e.filter.address = e.filter.address.map(getLowerCase);
								} else {
									e.filter.address = getLowerCase(e.filter.address);
								}
							}
							return { method: 'eth_getLogs', args: [e.filter] };
					}
					return null;
				}
				getRpcError(e, t) {
					const { method: r } = e;
					const { error: a } = t;
					if (r === 'eth_estimateGas' && a.message) {
						const t = a.message;
						if (!t.match(/revert/i) && t.match(/insufficient funds/i)) {
							return (0, d.xz)('insufficient funds', 'INSUFFICIENT_FUNDS', {
								transaction: e.params[0],
								info: { payload: e, error: a }
							});
						}
					}
					if (r === 'eth_call' || r === 'eth_estimateGas') {
						const t = spelunkData(a);
						const o = i.y.getBuiltinCallException(
							r === 'eth_call' ? 'call' : 'estimateGas',
							e.params[0],
							t ? t.data : null
						);
						o.info = { error: a, payload: e };
						return o;
					}
					const o = JSON.stringify(spelunkMessage(a));
					if (typeof a.message === 'string' && a.message.match(/user denied|ethers-user-denied/i)) {
						const t = {
							eth_sign: 'signMessage',
							personal_sign: 'signMessage',
							eth_signTypedData_v4: 'signTypedData',
							eth_signTransaction: 'signTransaction',
							eth_sendTransaction: 'sendTransaction',
							eth_requestAccounts: 'requestAccess',
							wallet_requestAccounts: 'requestAccess'
						};
						return (0, d.xz)(`user rejected action`, 'ACTION_REJECTED', {
							action: t[r] || 'unknown',
							reason: 'rejected',
							info: { payload: e, error: a }
						});
					}
					if (r === 'eth_sendRawTransaction' || r === 'eth_sendTransaction') {
						const t = e.params[0];
						if (o.match(/insufficient funds|base fee exceeds gas limit/i)) {
							return (0, d.xz)(
								'insufficient funds for intrinsic transaction cost',
								'INSUFFICIENT_FUNDS',
								{ transaction: t, info: { error: a } }
							);
						}
						if (o.match(/nonce/i) && o.match(/too low/i)) {
							return (0, d.xz)('nonce has already been used', 'NONCE_EXPIRED', {
								transaction: t,
								info: { error: a }
							});
						}
						if (o.match(/replacement transaction/i) && o.match(/underpriced/i)) {
							return (0, d.xz)('replacement fee too low', 'REPLACEMENT_UNDERPRICED', {
								transaction: t,
								info: { error: a }
							});
						}
						if (o.match(/only replay-protected/i)) {
							return (0, d.xz)(
								'legacy pre-eip-155 transactions not supported',
								'UNSUPPORTED_OPERATION',
								{ operation: r, info: { transaction: t, info: { error: a } } }
							);
						}
					}
					let c = !!o.match(/the method .* does not exist/i);
					if (!c) {
						if (a && a.details && a.details.startsWith('Unauthorized method:')) {
							c = true;
						}
					}
					if (c) {
						return (0, d.xz)('unsupported operation', 'UNSUPPORTED_OPERATION', {
							operation: e.method,
							info: { error: a, payload: e }
						});
					}
					return (0, d.xz)('could not coalesce error', 'UNKNOWN_ERROR', { error: a, payload: e });
				}
				send(e, t) {
					if (this.destroyed) {
						return Promise.reject(
							(0, d.xz)('provider destroyed; cancelled request', 'UNSUPPORTED_OPERATION', {
								operation: e
							})
						);
					}
					const r = this.#He++;
					const i = new Promise((i, a) => {
						this.#ze.push({
							resolve: i,
							reject: a,
							payload: { method: e, params: t, id: r, jsonrpc: '2.0' }
						});
					});
					this.#Ve();
					return i;
				}
				async getSigner(e) {
					if (e == null) {
						e = 0;
					}
					const t = this.send('eth_accounts', []);
					if (typeof e === 'number') {
						const r = await t;
						if (e >= r.length) {
							throw new Error('no such account');
						}
						return new JsonRpcSigner(this, r[e]);
					}
					const { accounts: r } = await (0, l.k)({ network: this.getNetwork(), accounts: t });
					e = (0, a.b)(e);
					for (const t of r) {
						if ((0, a.b)(t) === e) {
							return new JsonRpcSigner(this, e);
						}
					}
					throw new Error('invalid account');
				}
				async listAccounts() {
					const e = await this.send('eth_accounts', []);
					return e.map((e) => new JsonRpcSigner(this, e));
				}
				destroy() {
					if (this.#$e) {
						clearTimeout(this.#$e);
						this.#$e = null;
					}
					for (const { payload: e, reject: t } of this.#ze) {
						t(
							(0, d.xz)('provider destroyed; cancelled request', 'UNSUPPORTED_OPERATION', {
								operation: e.method
							})
						);
					}
					this.#ze = [];
					super.destroy();
				}
			}
			class JsonRpcApiPollingProvider extends JsonRpcApiProvider {
				#Ke;
				constructor(e, t) {
					super(e, t);
					let r = this._getOption('pollingInterval');
					if (r == null) {
						r = Ye.pollingInterval;
					}
					this.#Ke = r;
				}
				_getSubscriber(e) {
					const t = super._getSubscriber(e);
					if (isPollable(t)) {
						t.pollingInterval = this.#Ke;
					}
					return t;
				}
				get pollingInterval() {
					return this.#Ke;
				}
				set pollingInterval(e) {
					if (!Number.isInteger(e) || e < 0) {
						throw new Error('invalid interval');
					}
					this.#Ke = e;
					this._forEachSubscriber((e) => {
						if (isPollable(e)) {
							e.pollingInterval = this.#Ke;
						}
					});
				}
			}
			class JsonRpcProvider extends JsonRpcApiPollingProvider {
				#We;
				constructor(e, t, r) {
					if (e == null) {
						e = 'http://localhost:8545';
					}
					super(t, r);
					if (typeof e === 'string') {
						this.#We = new FetchRequest(e);
					} else {
						this.#We = e.clone();
					}
				}
				_getConnection() {
					return this.#We.clone();
				}
				async send(e, t) {
					await this._start();
					return await super.send(e, t);
				}
				async _send(e) {
					const t = this._getConnection();
					t.body = JSON.stringify(e);
					t.setHeader('content-type', 'application/json');
					const r = await t.send();
					r.assertOk();
					let i = r.bodyJson;
					if (!Array.isArray(i)) {
						i = [i];
					}
					return i;
				}
			}
			function spelunkData(e) {
				if (e == null) {
					return null;
				}
				if (typeof e.message === 'string' && e.message.match(/revert/i) && (0, m.Lo)(e.data)) {
					return { message: e.message, data: e.data };
				}
				if (typeof e === 'object') {
					for (const t in e) {
						const r = spelunkData(e[t]);
						if (r) {
							return r;
						}
					}
					return null;
				}
				if (typeof e === 'string') {
					try {
						return spelunkData(JSON.parse(e));
					} catch (e) {}
				}
				return null;
			}
			function _spelunkMessage(e, t) {
				if (e == null) {
					return;
				}
				if (typeof e.message === 'string') {
					t.push(e.message);
				}
				if (typeof e === 'object') {
					for (const r in e) {
						_spelunkMessage(e[r], t);
					}
				}
				if (typeof e === 'string') {
					try {
						return _spelunkMessage(JSON.parse(e), t);
					} catch (e) {}
				}
			}
			function spelunkMessage(e) {
				const t = [];
				_spelunkMessage(e, t);
				return t;
			}
		},
		3679: (e, t, r) => {
			'use strict';
			r.d(t, {
				J9: () => FeeData,
				VS: () => copyRequest,
				eB: () => Block,
				tG: () => Log,
				uI: () => TransactionResponse,
				z5: () => TransactionReceipt
			});
			var i = r(4918);
			var a = r(6919);
			var o = r(572);
			var c = r(8492);
			var u = r(7486);
			const l = BigInt(0);
			function getValue(e) {
				if (e == null) {
					return null;
				}
				return e;
			}
			function toJson(e) {
				if (e == null) {
					return null;
				}
				return e.toString();
			}
			class FeeData {
				gasPrice;
				maxFeePerGas;
				maxPriorityFeePerGas;
				constructor(e, t, r) {
					(0, i.n)(this, {
						gasPrice: getValue(e),
						maxFeePerGas: getValue(t),
						maxPriorityFeePerGas: getValue(r)
					});
				}
				toJSON() {
					const { gasPrice: e, maxFeePerGas: t, maxPriorityFeePerGas: r } = this;
					return {
						_type: 'FeeData',
						gasPrice: toJson(e),
						maxFeePerGas: toJson(t),
						maxPriorityFeePerGas: toJson(r)
					};
				}
			}
			function copyRequest(e) {
				const t = {};
				if (e.to) {
					t.to = e.to;
				}
				if (e.from) {
					t.from = e.from;
				}
				if (e.data) {
					t.data = (0, a.c$)(e.data);
				}
				const r =
					'chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value'.split(
						/,/
					);
				for (const i of r) {
					if (!(i in e) || e[i] == null) {
						continue;
					}
					t[i] = (0, o.Ab)(e[i], `request.${i}`);
				}
				const i = 'type,nonce'.split(/,/);
				for (const r of i) {
					if (!(r in e) || e[r] == null) {
						continue;
					}
					t[r] = (0, o.WZ)(e[r], `request.${r}`);
				}
				if (e.accessList) {
					t.accessList = (0, u.$)(e.accessList);
				}
				if ('blockTag' in e) {
					t.blockTag = e.blockTag;
				}
				if ('enableCcipRead' in e) {
					t.enableCcipRead = !!e.enableCcipRead;
				}
				if ('customData' in e) {
					t.customData = e.customData;
				}
				if ('blobVersionedHashes' in e && e.blobVersionedHashes) {
					t.blobVersionedHashes = e.blobVersionedHashes.slice();
				}
				if ('kzg' in e) {
					t.kzg = e.kzg;
				}
				if ('blobs' in e && e.blobs) {
					t.blobs = e.blobs.map((e) => {
						if ((0, a.f)(e)) {
							return (0, a.c$)(e);
						}
						return Object.assign({}, e);
					});
				}
				return t;
			}
			class Block {
				provider;
				number;
				hash;
				timestamp;
				parentHash;
				parentBeaconBlockRoot;
				nonce;
				difficulty;
				gasLimit;
				gasUsed;
				stateRoot;
				receiptsRoot;
				blobGasUsed;
				excessBlobGas;
				miner;
				prevRandao;
				extraData;
				baseFeePerGas;
				#Je;
				constructor(e, t) {
					this.#Je = e.transactions.map((e) => {
						if (typeof e !== 'string') {
							return new TransactionResponse(e, t);
						}
						return e;
					});
					(0, i.n)(this, {
						provider: t,
						hash: getValue(e.hash),
						number: e.number,
						timestamp: e.timestamp,
						parentHash: e.parentHash,
						parentBeaconBlockRoot: e.parentBeaconBlockRoot,
						nonce: e.nonce,
						difficulty: e.difficulty,
						gasLimit: e.gasLimit,
						gasUsed: e.gasUsed,
						blobGasUsed: e.blobGasUsed,
						excessBlobGas: e.excessBlobGas,
						miner: e.miner,
						prevRandao: getValue(e.prevRandao),
						extraData: e.extraData,
						baseFeePerGas: getValue(e.baseFeePerGas),
						stateRoot: e.stateRoot,
						receiptsRoot: e.receiptsRoot
					});
				}
				get transactions() {
					return this.#Je.map((e) => {
						if (typeof e === 'string') {
							return e;
						}
						return e.hash;
					});
				}
				get prefetchedTransactions() {
					const e = this.#Je.slice();
					if (e.length === 0) {
						return [];
					}
					(0, c.vA)(
						typeof e[0] === 'object',
						'transactions were not prefetched with block request',
						'UNSUPPORTED_OPERATION',
						{ operation: 'transactionResponses()' }
					);
					return e;
				}
				toJSON() {
					const {
						baseFeePerGas: e,
						difficulty: t,
						extraData: r,
						gasLimit: i,
						gasUsed: a,
						hash: o,
						miner: c,
						prevRandao: u,
						nonce: l,
						number: d,
						parentHash: p,
						parentBeaconBlockRoot: m,
						stateRoot: g,
						receiptsRoot: v,
						timestamp: y,
						transactions: w
					} = this;
					return {
						_type: 'Block',
						baseFeePerGas: toJson(e),
						difficulty: toJson(t),
						extraData: r,
						gasLimit: toJson(i),
						gasUsed: toJson(a),
						blobGasUsed: toJson(this.blobGasUsed),
						excessBlobGas: toJson(this.excessBlobGas),
						hash: o,
						miner: c,
						prevRandao: u,
						nonce: l,
						number: d,
						parentHash: p,
						timestamp: y,
						parentBeaconBlockRoot: m,
						stateRoot: g,
						receiptsRoot: v,
						transactions: w
					};
				}
				[Symbol.iterator]() {
					let e = 0;
					const t = this.transactions;
					return {
						next: () => {
							if (e < this.length) {
								return { value: t[e++], done: false };
							}
							return { value: undefined, done: true };
						}
					};
				}
				get length() {
					return this.#Je.length;
				}
				get date() {
					if (this.timestamp == null) {
						return null;
					}
					return new Date(this.timestamp * 1e3);
				}
				async getTransaction(e) {
					let t = undefined;
					if (typeof e === 'number') {
						t = this.#Je[e];
					} else {
						const r = e.toLowerCase();
						for (const e of this.#Je) {
							if (typeof e === 'string') {
								if (e !== r) {
									continue;
								}
								t = e;
								break;
							} else {
								if (e.hash !== r) {
									continue;
								}
								t = e;
								break;
							}
						}
					}
					if (t == null) {
						throw new Error('no such tx');
					}
					if (typeof t === 'string') {
						return await this.provider.getTransaction(t);
					} else {
						return t;
					}
				}
				getPrefetchedTransaction(e) {
					const t = this.prefetchedTransactions;
					if (typeof e === 'number') {
						return t[e];
					}
					e = e.toLowerCase();
					for (const r of t) {
						if (r.hash === e) {
							return r;
						}
					}
					(0, c.MR)(false, 'no matching transaction', 'indexOrHash', e);
				}
				isMined() {
					return !!this.hash;
				}
				isLondon() {
					return !!this.baseFeePerGas;
				}
				orphanedEvent() {
					if (!this.isMined()) {
						throw new Error('');
					}
					return createOrphanedBlockFilter(this);
				}
			}
			class Log {
				provider;
				transactionHash;
				blockHash;
				blockNumber;
				removed;
				address;
				data;
				topics;
				index;
				transactionIndex;
				constructor(e, t) {
					this.provider = t;
					const r = Object.freeze(e.topics.slice());
					(0, i.n)(this, {
						transactionHash: e.transactionHash,
						blockHash: e.blockHash,
						blockNumber: e.blockNumber,
						removed: e.removed,
						address: e.address,
						data: e.data,
						topics: r,
						index: e.index,
						transactionIndex: e.transactionIndex
					});
				}
				toJSON() {
					const {
						address: e,
						blockHash: t,
						blockNumber: r,
						data: i,
						index: a,
						removed: o,
						topics: c,
						transactionHash: u,
						transactionIndex: l
					} = this;
					return {
						_type: 'log',
						address: e,
						blockHash: t,
						blockNumber: r,
						data: i,
						index: a,
						removed: o,
						topics: c,
						transactionHash: u,
						transactionIndex: l
					};
				}
				async getBlock() {
					const e = await this.provider.getBlock(this.blockHash);
					(0, c.vA)(!!e, 'failed to find transaction', 'UNKNOWN_ERROR', {});
					return e;
				}
				async getTransaction() {
					const e = await this.provider.getTransaction(this.transactionHash);
					(0, c.vA)(!!e, 'failed to find transaction', 'UNKNOWN_ERROR', {});
					return e;
				}
				async getTransactionReceipt() {
					const e = await this.provider.getTransactionReceipt(this.transactionHash);
					(0, c.vA)(!!e, 'failed to find transaction receipt', 'UNKNOWN_ERROR', {});
					return e;
				}
				removedEvent() {
					return createRemovedLogFilter(this);
				}
			}
			class TransactionReceipt {
				provider;
				to;
				from;
				contractAddress;
				hash;
				index;
				blockHash;
				blockNumber;
				logsBloom;
				gasUsed;
				blobGasUsed;
				cumulativeGasUsed;
				gasPrice;
				blobGasPrice;
				type;
				status;
				root;
				#Ze;
				constructor(e, t) {
					this.#Ze = Object.freeze(e.logs.map((e) => new Log(e, t)));
					let r = l;
					if (e.effectiveGasPrice != null) {
						r = e.effectiveGasPrice;
					} else if (e.gasPrice != null) {
						r = e.gasPrice;
					}
					(0, i.n)(this, {
						provider: t,
						to: e.to,
						from: e.from,
						contractAddress: e.contractAddress,
						hash: e.hash,
						index: e.index,
						blockHash: e.blockHash,
						blockNumber: e.blockNumber,
						logsBloom: e.logsBloom,
						gasUsed: e.gasUsed,
						cumulativeGasUsed: e.cumulativeGasUsed,
						blobGasUsed: e.blobGasUsed,
						gasPrice: r,
						blobGasPrice: e.blobGasPrice,
						type: e.type,
						status: e.status,
						root: e.root
					});
				}
				get logs() {
					return this.#Ze;
				}
				toJSON() {
					const {
						to: e,
						from: t,
						contractAddress: r,
						hash: i,
						index: a,
						blockHash: o,
						blockNumber: c,
						logsBloom: u,
						logs: l,
						status: d,
						root: p
					} = this;
					return {
						_type: 'TransactionReceipt',
						blockHash: o,
						blockNumber: c,
						contractAddress: r,
						cumulativeGasUsed: toJson(this.cumulativeGasUsed),
						from: t,
						gasPrice: toJson(this.gasPrice),
						blobGasUsed: toJson(this.blobGasUsed),
						blobGasPrice: toJson(this.blobGasPrice),
						gasUsed: toJson(this.gasUsed),
						hash: i,
						index: a,
						logs: l,
						logsBloom: u,
						root: p,
						status: d,
						to: e
					};
				}
				get length() {
					return this.logs.length;
				}
				[Symbol.iterator]() {
					let e = 0;
					return {
						next: () => {
							if (e < this.length) {
								return { value: this.logs[e++], done: false };
							}
							return { value: undefined, done: true };
						}
					};
				}
				get fee() {
					return this.gasUsed * this.gasPrice;
				}
				async getBlock() {
					const e = await this.provider.getBlock(this.blockHash);
					if (e == null) {
						throw new Error('TODO');
					}
					return e;
				}
				async getTransaction() {
					const e = await this.provider.getTransaction(this.hash);
					if (e == null) {
						throw new Error('TODO');
					}
					return e;
				}
				async getResult() {
					return await this.provider.getTransactionResult(this.hash);
				}
				async confirmations() {
					return (await this.provider.getBlockNumber()) - this.blockNumber + 1;
				}
				removedEvent() {
					return createRemovedTransactionFilter(this);
				}
				reorderedEvent(e) {
					(0, c.vA)(
						!e || e.isMined(),
						"unmined 'other' transction cannot be orphaned",
						'UNSUPPORTED_OPERATION',
						{ operation: 'reorderedEvent(other)' }
					);
					return createReorderedTransactionFilter(this, e);
				}
			}
			class TransactionResponse {
				provider;
				blockNumber;
				blockHash;
				index;
				hash;
				type;
				to;
				from;
				nonce;
				gasLimit;
				gasPrice;
				maxPriorityFeePerGas;
				maxFeePerGas;
				maxFeePerBlobGas;
				data;
				value;
				chainId;
				signature;
				accessList;
				blobVersionedHashes;
				#Qe;
				constructor(e, t) {
					this.provider = t;
					this.blockNumber = e.blockNumber != null ? e.blockNumber : null;
					this.blockHash = e.blockHash != null ? e.blockHash : null;
					this.hash = e.hash;
					this.index = e.index;
					this.type = e.type;
					this.from = e.from;
					this.to = e.to || null;
					this.gasLimit = e.gasLimit;
					this.nonce = e.nonce;
					this.data = e.data;
					this.value = e.value;
					this.gasPrice = e.gasPrice;
					this.maxPriorityFeePerGas =
						e.maxPriorityFeePerGas != null ? e.maxPriorityFeePerGas : null;
					this.maxFeePerGas = e.maxFeePerGas != null ? e.maxFeePerGas : null;
					this.maxFeePerBlobGas = e.maxFeePerBlobGas != null ? e.maxFeePerBlobGas : null;
					this.chainId = e.chainId;
					this.signature = e.signature;
					this.accessList = e.accessList != null ? e.accessList : null;
					this.blobVersionedHashes = e.blobVersionedHashes != null ? e.blobVersionedHashes : null;
					this.#Qe = -1;
				}
				toJSON() {
					const {
						blockNumber: e,
						blockHash: t,
						index: r,
						hash: i,
						type: a,
						to: o,
						from: c,
						nonce: u,
						data: l,
						signature: d,
						accessList: p,
						blobVersionedHashes: m
					} = this;
					return {
						_type: 'TransactionResponse',
						accessList: p,
						blockNumber: e,
						blockHash: t,
						blobVersionedHashes: m,
						chainId: toJson(this.chainId),
						data: l,
						from: c,
						gasLimit: toJson(this.gasLimit),
						gasPrice: toJson(this.gasPrice),
						hash: i,
						maxFeePerGas: toJson(this.maxFeePerGas),
						maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
						maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
						nonce: u,
						signature: d,
						to: o,
						index: r,
						type: a,
						value: toJson(this.value)
					};
				}
				async getBlock() {
					let e = this.blockNumber;
					if (e == null) {
						const t = await this.getTransaction();
						if (t) {
							e = t.blockNumber;
						}
					}
					if (e == null) {
						return null;
					}
					const t = this.provider.getBlock(e);
					if (t == null) {
						throw new Error('TODO');
					}
					return t;
				}
				async getTransaction() {
					return this.provider.getTransaction(this.hash);
				}
				async confirmations() {
					if (this.blockNumber == null) {
						const { tx: e, blockNumber: t } = await (0, i.k)({
							tx: this.getTransaction(),
							blockNumber: this.provider.getBlockNumber()
						});
						if (e == null || e.blockNumber == null) {
							return 0;
						}
						return t - e.blockNumber + 1;
					}
					const e = await this.provider.getBlockNumber();
					return e - this.blockNumber + 1;
				}
				async wait(e, t) {
					const r = e == null ? 1 : e;
					const a = t == null ? 0 : t;
					let o = this.#Qe;
					let u = -1;
					let d = o === -1 ? true : false;
					const checkReplacement = async () => {
						if (d) {
							return null;
						}
						const { blockNumber: e, nonce: t } = await (0, i.k)({
							blockNumber: this.provider.getBlockNumber(),
							nonce: this.provider.getTransactionCount(this.from)
						});
						if (t < this.nonce) {
							o = e;
							return;
						}
						if (d) {
							return null;
						}
						const a = await this.getTransaction();
						if (a && a.blockNumber != null) {
							return;
						}
						if (u === -1) {
							u = o - 3;
							if (u < this.#Qe) {
								u = this.#Qe;
							}
						}
						while (u <= e) {
							if (d) {
								return null;
							}
							const t = await this.provider.getBlock(u, true);
							if (t == null) {
								return;
							}
							for (const e of t) {
								if (e === this.hash) {
									return;
								}
							}
							for (let i = 0; i < t.length; i++) {
								const a = await t.getTransaction(i);
								if (a.from === this.from && a.nonce === this.nonce) {
									if (d) {
										return null;
									}
									const t = await this.provider.getTransactionReceipt(a.hash);
									if (t == null) {
										return;
									}
									if (e - t.blockNumber + 1 < r) {
										return;
									}
									let i = 'replaced';
									if (a.data === this.data && a.to === this.to && a.value === this.value) {
										i = 'repriced';
									} else if (a.data === '0x' && a.from === a.to && a.value === l) {
										i = 'cancelled';
									}
									(0, c.vA)(false, 'transaction was replaced', 'TRANSACTION_REPLACED', {
										cancelled: i === 'replaced' || i === 'cancelled',
										reason: i,
										replacement: a.replaceableTransaction(o),
										hash: a.hash,
										receipt: t
									});
								}
							}
							u++;
						}
						return;
					};
					const checkReceipt = (e) => {
						if (e == null || e.status !== 0) {
							return e;
						}
						(0, c.vA)(false, 'transaction execution reverted', 'CALL_EXCEPTION', {
							action: 'sendTransaction',
							data: null,
							reason: null,
							invocation: null,
							revert: null,
							transaction: { to: e.to, from: e.from, data: '' },
							receipt: e
						});
					};
					const p = await this.provider.getTransactionReceipt(this.hash);
					if (r === 0) {
						return checkReceipt(p);
					}
					if (p) {
						if ((await p.confirmations()) >= r) {
							return checkReceipt(p);
						}
					} else {
						await checkReplacement();
						if (r === 0) {
							return null;
						}
					}
					const m = new Promise((e, t) => {
						const i = [];
						const cancel = () => {
							i.forEach((e) => e());
						};
						i.push(() => {
							d = true;
						});
						if (a > 0) {
							const e = setTimeout(() => {
								cancel();
								t((0, c.xz)('wait for transaction timeout', 'TIMEOUT'));
							}, a);
							i.push(() => {
								clearTimeout(e);
							});
						}
						const txListener = async (i) => {
							if ((await i.confirmations()) >= r) {
								cancel();
								try {
									e(checkReceipt(i));
								} catch (e) {
									t(e);
								}
							}
						};
						i.push(() => {
							this.provider.off(this.hash, txListener);
						});
						this.provider.on(this.hash, txListener);
						if (o >= 0) {
							const replaceListener = async () => {
								try {
									await checkReplacement();
								} catch (e) {
									if ((0, c.bJ)(e, 'TRANSACTION_REPLACED')) {
										cancel();
										t(e);
										return;
									}
								}
								if (!d) {
									this.provider.once('block', replaceListener);
								}
							};
							i.push(() => {
								this.provider.off('block', replaceListener);
							});
							this.provider.once('block', replaceListener);
						}
					});
					return await m;
				}
				isMined() {
					return this.blockHash != null;
				}
				isLegacy() {
					return this.type === 0;
				}
				isBerlin() {
					return this.type === 1;
				}
				isLondon() {
					return this.type === 2;
				}
				isCancun() {
					return this.type === 3;
				}
				removedEvent() {
					(0, c.vA)(
						this.isMined(),
						'unmined transaction canot be orphaned',
						'UNSUPPORTED_OPERATION',
						{ operation: 'removeEvent()' }
					);
					return createRemovedTransactionFilter(this);
				}
				reorderedEvent(e) {
					(0, c.vA)(
						this.isMined(),
						'unmined transaction canot be orphaned',
						'UNSUPPORTED_OPERATION',
						{ operation: 'removeEvent()' }
					);
					(0, c.vA)(
						!e || e.isMined(),
						"unmined 'other' transaction canot be orphaned",
						'UNSUPPORTED_OPERATION',
						{ operation: 'removeEvent()' }
					);
					return createReorderedTransactionFilter(this, e);
				}
				replaceableTransaction(e) {
					(0, c.MR)(Number.isInteger(e) && e >= 0, 'invalid startBlock', 'startBlock', e);
					const t = new TransactionResponse(this, this.provider);
					t.#Qe = e;
					return t;
				}
			}
			function createOrphanedBlockFilter(e) {
				return { orphan: 'drop-block', hash: e.hash, number: e.number };
			}
			function createReorderedTransactionFilter(e, t) {
				return { orphan: 'reorder-transaction', tx: e, other: t };
			}
			function createRemovedTransactionFilter(e) {
				return { orphan: 'drop-transaction', tx: e };
			}
			function createRemovedLogFilter(e) {
				return {
					orphan: 'drop-log',
					log: {
						transactionHash: e.transactionHash,
						blockHash: e.blockHash,
						blockNumber: e.blockNumber,
						address: e.address,
						data: e.data,
						topics: Object.freeze(e.topics.slice()),
						index: e.index
					}
				};
			}
		},
		7486: (e, t, r) => {
			'use strict';
			r.d(t, { $: () => accessListify });
			var i = r(6686);
			var a = r(8492);
			var o = r(6919);
			function accessSetify(e, t) {
				return {
					address: (0, i.b)(e),
					storageKeys: t.map((e, t) => {
						(0, a.MR)((0, o.Lo)(e, 32), 'invalid slot', `storageKeys[${t}]`, e);
						return e.toLowerCase();
					})
				};
			}
			function accessListify(e) {
				if (Array.isArray(e)) {
					return e.map((t, r) => {
						if (Array.isArray(t)) {
							(0, a.MR)(t.length === 2, 'invalid slot set', `value[${r}]`, t);
							return accessSetify(t[0], t[1]);
						}
						(0, a.MR)(t != null && typeof t === 'object', 'invalid address-slot set', 'value', e);
						return accessSetify(t.address, t.storageKeys);
					});
				}
				(0, a.MR)(e != null && typeof e === 'object', 'invalid access list', 'value', e);
				const t = Object.keys(e).map((t) => {
					const r = e[t].reduce((e, t) => {
						e[t] = true;
						return e;
					}, {});
					return accessSetify(t, Object.keys(r).sort());
				});
				t.sort((e, t) => e.address.localeCompare(t.address));
				return t;
			}
		},
		5738: (e, t, r) => {
			'use strict';
			r.d(t, { K: () => computeAddress, x: () => recoverAddress });
			var i = r(6686);
			var a = r(6945);
			var o = r(822);
			function computeAddress(e) {
				let t;
				if (typeof e === 'string') {
					t = a.h.computePublicKey(e, false);
				} else {
					t = e.publicKey;
				}
				return (0, i.b)((0, o.S)('0x' + t.substring(4)).substring(26));
			}
			function recoverAddress(e, t) {
				return computeAddress(a.h.recoverPublicKey(e, t));
			}
		},
		7818: (e, t, r) => {
			'use strict';
			r.d(t, { Z: () => Transaction });
			var i = r(6686);
			var a = r(6935);
			var o = r(4931);
			var c = r(8249);
			var u = r(822);
			var l = r(6945);
			var d = r(8492);
			var p = r(572);
			var m = r(6919);
			function hexlifyByte(e) {
				let t = e.toString(16);
				while (t.length < 2) {
					t = '0' + t;
				}
				return '0x' + t;
			}
			function unarrayifyInteger(e, t, r) {
				let i = 0;
				for (let a = 0; a < r; a++) {
					i = i * 256 + e[t + a];
				}
				return i;
			}
			function _decodeChildren(e, t, r, i) {
				const a = [];
				while (r < t + 1 + i) {
					const o = _decode(e, r);
					a.push(o.result);
					r += o.consumed;
					(0, d.vA)(r <= t + 1 + i, 'child data too short', 'BUFFER_OVERRUN', {
						buffer: e,
						length: i,
						offset: t
					});
				}
				return { consumed: 1 + i, result: a };
			}
			function _decode(e, t) {
				(0, d.vA)(e.length !== 0, 'data too short', 'BUFFER_OVERRUN', {
					buffer: e,
					length: 0,
					offset: 1
				});
				const checkOffset = (t) => {
					(0, d.vA)(t <= e.length, 'data short segment too short', 'BUFFER_OVERRUN', {
						buffer: e,
						length: e.length,
						offset: t
					});
				};
				if (e[t] >= 248) {
					const r = e[t] - 247;
					checkOffset(t + 1 + r);
					const i = unarrayifyInteger(e, t + 1, r);
					checkOffset(t + 1 + r + i);
					return _decodeChildren(e, t, t + 1 + r, r + i);
				} else if (e[t] >= 192) {
					const r = e[t] - 192;
					checkOffset(t + 1 + r);
					return _decodeChildren(e, t, t + 1, r);
				} else if (e[t] >= 184) {
					const r = e[t] - 183;
					checkOffset(t + 1 + r);
					const i = unarrayifyInteger(e, t + 1, r);
					checkOffset(t + 1 + r + i);
					const a = (0, m.c$)(e.slice(t + 1 + r, t + 1 + r + i));
					return { consumed: 1 + r + i, result: a };
				} else if (e[t] >= 128) {
					const r = e[t] - 128;
					checkOffset(t + 1 + r);
					const i = (0, m.c$)(e.slice(t + 1, t + 1 + r));
					return { consumed: 1 + r, result: i };
				}
				return { consumed: 1, result: hexlifyByte(e[t]) };
			}
			function decodeRlp(e) {
				const t = (0, m.q5)(e, 'data');
				const r = _decode(t, 0);
				(0, d.MR)(r.consumed === t.length, 'unexpected junk after rlp payload', 'data', e);
				return r.result;
			}
			var g = r(3996);
			var v = r(7486);
			var y = r(5738);
			const w = BigInt(0);
			const _ = BigInt(2);
			const A = BigInt(27);
			const k = BigInt(28);
			const N = BigInt(35);
			const T = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
			const x = 4096 * 32;
			function getVersionedHash(e, t) {
				let r = e.toString(16);
				while (r.length < 2) {
					r = '0' + r;
				}
				r += (0, o.s)(t).substring(4);
				return '0x' + r;
			}
			function handleAddress(e) {
				if (e === '0x') {
					return null;
				}
				return (0, i.b)(e);
			}
			function handleAccessList(e, t) {
				try {
					return (0, v.$)(e);
				} catch (r) {
					(0, d.MR)(false, r.message, t, e);
				}
			}
			function handleNumber(e, t) {
				if (e === '0x') {
					return 0;
				}
				return (0, p.WZ)(e, t);
			}
			function handleUint(e, t) {
				if (e === '0x') {
					return w;
				}
				const r = (0, p.Ab)(e, t);
				(0, d.MR)(r <= T, 'value exceeds uint size', t, r);
				return r;
			}
			function formatNumber(e, t) {
				const r = (0, p.Ab)(e, 'value');
				const i = (0, p.c4)(r);
				(0, d.MR)(i.length <= 32, `value too large`, `tx.${t}`, r);
				return i;
			}
			function formatAccessList(e) {
				return (0, v.$)(e).map((e) => [e.address, e.storageKeys]);
			}
			function formatHashes(e, t) {
				(0, d.MR)(Array.isArray(e), `invalid ${t}`, 'value', e);
				for (let t = 0; t < e.length; t++) {
					(0, d.MR)((0, m.Lo)(e[t], 32), 'invalid ${ param } hash', `value[${t}]`, e[t]);
				}
				return e;
			}
			function _parseLegacy(e) {
				const t = decodeRlp(e);
				(0, d.MR)(
					Array.isArray(t) && (t.length === 9 || t.length === 6),
					'invalid field count for legacy transaction',
					'data',
					e
				);
				const r = {
					type: 0,
					nonce: handleNumber(t[0], 'nonce'),
					gasPrice: handleUint(t[1], 'gasPrice'),
					gasLimit: handleUint(t[2], 'gasLimit'),
					to: handleAddress(t[3]),
					value: handleUint(t[4], 'value'),
					data: (0, m.c$)(t[5]),
					chainId: w
				};
				if (t.length === 6) {
					return r;
				}
				const i = handleUint(t[6], 'v');
				const a = handleUint(t[7], 'r');
				const o = handleUint(t[8], 's');
				if (a === w && o === w) {
					r.chainId = i;
				} else {
					let e = (i - N) / _;
					if (e < w) {
						e = w;
					}
					r.chainId = e;
					(0, d.MR)(e !== w || i === A || i === k, 'non-canonical legacy v', 'v', t[6]);
					r.signature = c.t.from({ r: (0, m.nx)(t[7], 32), s: (0, m.nx)(t[8], 32), v: i });
				}
				return r;
			}
			function _serializeLegacy(e, t) {
				const r = [
					formatNumber(e.nonce, 'nonce'),
					formatNumber(e.gasPrice || 0, 'gasPrice'),
					formatNumber(e.gasLimit, 'gasLimit'),
					e.to || '0x',
					formatNumber(e.value, 'value'),
					e.data
				];
				let i = w;
				if (e.chainId != w) {
					i = (0, p.Ab)(e.chainId, 'tx.chainId');
					(0, d.MR)(
						!t || t.networkV == null || t.legacyChainId === i,
						'tx.chainId/sig.v mismatch',
						'sig',
						t
					);
				} else if (e.signature) {
					const t = e.signature.legacyChainId;
					if (t != null) {
						i = t;
					}
				}
				if (!t) {
					if (i !== w) {
						r.push((0, p.c4)(i));
						r.push('0x');
						r.push('0x');
					}
					return (0, g.R)(r);
				}
				let a = BigInt(27 + t.yParity);
				if (i !== w) {
					a = c.t.getChainIdV(i, t.v);
				} else if (BigInt(t.v) !== a) {
					(0, d.MR)(false, 'tx.chainId/sig.v mismatch', 'sig', t);
				}
				r.push((0, p.c4)(a));
				r.push((0, p.c4)(t.r));
				r.push((0, p.c4)(t.s));
				return (0, g.R)(r);
			}
			function _parseEipSignature(e, t) {
				let r;
				try {
					r = handleNumber(t[0], 'yParity');
					if (r !== 0 && r !== 1) {
						throw new Error('bad yParity');
					}
				} catch (e) {
					(0, d.MR)(false, 'invalid yParity', 'yParity', t[0]);
				}
				const i = (0, m.nx)(t[1], 32);
				const a = (0, m.nx)(t[2], 32);
				const o = c.t.from({ r: i, s: a, yParity: r });
				e.signature = o;
			}
			function _parseEip1559(e) {
				const t = decodeRlp((0, m.q5)(e).slice(1));
				(0, d.MR)(
					Array.isArray(t) && (t.length === 9 || t.length === 12),
					'invalid field count for transaction type: 2',
					'data',
					(0, m.c$)(e)
				);
				const r = {
					type: 2,
					chainId: handleUint(t[0], 'chainId'),
					nonce: handleNumber(t[1], 'nonce'),
					maxPriorityFeePerGas: handleUint(t[2], 'maxPriorityFeePerGas'),
					maxFeePerGas: handleUint(t[3], 'maxFeePerGas'),
					gasPrice: null,
					gasLimit: handleUint(t[4], 'gasLimit'),
					to: handleAddress(t[5]),
					value: handleUint(t[6], 'value'),
					data: (0, m.c$)(t[7]),
					accessList: handleAccessList(t[8], 'accessList')
				};
				if (t.length === 9) {
					return r;
				}
				_parseEipSignature(r, t.slice(9));
				return r;
			}
			function _serializeEip1559(e, t) {
				const r = [
					formatNumber(e.chainId, 'chainId'),
					formatNumber(e.nonce, 'nonce'),
					formatNumber(e.maxPriorityFeePerGas || 0, 'maxPriorityFeePerGas'),
					formatNumber(e.maxFeePerGas || 0, 'maxFeePerGas'),
					formatNumber(e.gasLimit, 'gasLimit'),
					e.to || '0x',
					formatNumber(e.value, 'value'),
					e.data,
					formatAccessList(e.accessList || [])
				];
				if (t) {
					r.push(formatNumber(t.yParity, 'yParity'));
					r.push((0, p.c4)(t.r));
					r.push((0, p.c4)(t.s));
				}
				return (0, m.xW)(['0x02', (0, g.R)(r)]);
			}
			function _parseEip2930(e) {
				const t = decodeRlp((0, m.q5)(e).slice(1));
				(0, d.MR)(
					Array.isArray(t) && (t.length === 8 || t.length === 11),
					'invalid field count for transaction type: 1',
					'data',
					(0, m.c$)(e)
				);
				const r = {
					type: 1,
					chainId: handleUint(t[0], 'chainId'),
					nonce: handleNumber(t[1], 'nonce'),
					gasPrice: handleUint(t[2], 'gasPrice'),
					gasLimit: handleUint(t[3], 'gasLimit'),
					to: handleAddress(t[4]),
					value: handleUint(t[5], 'value'),
					data: (0, m.c$)(t[6]),
					accessList: handleAccessList(t[7], 'accessList')
				};
				if (t.length === 8) {
					return r;
				}
				_parseEipSignature(r, t.slice(8));
				return r;
			}
			function _serializeEip2930(e, t) {
				const r = [
					formatNumber(e.chainId, 'chainId'),
					formatNumber(e.nonce, 'nonce'),
					formatNumber(e.gasPrice || 0, 'gasPrice'),
					formatNumber(e.gasLimit, 'gasLimit'),
					e.to || '0x',
					formatNumber(e.value, 'value'),
					e.data,
					formatAccessList(e.accessList || [])
				];
				if (t) {
					r.push(formatNumber(t.yParity, 'recoveryParam'));
					r.push((0, p.c4)(t.r));
					r.push((0, p.c4)(t.s));
				}
				return (0, m.xW)(['0x01', (0, g.R)(r)]);
			}
			function _parseEip4844(e) {
				let t = decodeRlp((0, m.q5)(e).slice(1));
				let r = '3';
				let i = null;
				if (t.length === 4 && Array.isArray(t[0])) {
					r = '3 (network format)';
					const e = t[1],
						a = t[2],
						o = t[3];
					(0, d.MR)(Array.isArray(e), 'invalid network format: blobs not an array', 'fields[1]', e);
					(0, d.MR)(
						Array.isArray(a),
						'invalid network format: commitments not an array',
						'fields[2]',
						a
					);
					(0, d.MR)(
						Array.isArray(o),
						'invalid network format: proofs not an array',
						'fields[3]',
						o
					);
					(0, d.MR)(
						e.length === a.length,
						'invalid network format: blobs/commitments length mismatch',
						'fields',
						t
					);
					(0, d.MR)(
						e.length === o.length,
						'invalid network format: blobs/proofs length mismatch',
						'fields',
						t
					);
					i = [];
					for (let r = 0; r < t[1].length; r++) {
						i.push({ data: e[r], commitment: a[r], proof: o[r] });
					}
					t = t[0];
				}
				(0, d.MR)(
					Array.isArray(t) && (t.length === 11 || t.length === 14),
					`invalid field count for transaction type: ${r}`,
					'data',
					(0, m.c$)(e)
				);
				const a = {
					type: 3,
					chainId: handleUint(t[0], 'chainId'),
					nonce: handleNumber(t[1], 'nonce'),
					maxPriorityFeePerGas: handleUint(t[2], 'maxPriorityFeePerGas'),
					maxFeePerGas: handleUint(t[3], 'maxFeePerGas'),
					gasPrice: null,
					gasLimit: handleUint(t[4], 'gasLimit'),
					to: handleAddress(t[5]),
					value: handleUint(t[6], 'value'),
					data: (0, m.c$)(t[7]),
					accessList: handleAccessList(t[8], 'accessList'),
					maxFeePerBlobGas: handleUint(t[9], 'maxFeePerBlobGas'),
					blobVersionedHashes: t[10]
				};
				if (i) {
					a.blobs = i;
				}
				(0, d.MR)(a.to != null, `invalid address for transaction type: ${r}`, 'data', e);
				(0, d.MR)(
					Array.isArray(a.blobVersionedHashes),
					'invalid blobVersionedHashes: must be an array',
					'data',
					e
				);
				for (let t = 0; t < a.blobVersionedHashes.length; t++) {
					(0, d.MR)(
						(0, m.Lo)(a.blobVersionedHashes[t], 32),
						`invalid blobVersionedHash at index ${t}: must be length 32`,
						'data',
						e
					);
				}
				if (t.length === 11) {
					return a;
				}
				_parseEipSignature(a, t.slice(11));
				return a;
			}
			function _serializeEip4844(e, t, r) {
				const i = [
					formatNumber(e.chainId, 'chainId'),
					formatNumber(e.nonce, 'nonce'),
					formatNumber(e.maxPriorityFeePerGas || 0, 'maxPriorityFeePerGas'),
					formatNumber(e.maxFeePerGas || 0, 'maxFeePerGas'),
					formatNumber(e.gasLimit, 'gasLimit'),
					e.to || a.j,
					formatNumber(e.value, 'value'),
					e.data,
					formatAccessList(e.accessList || []),
					formatNumber(e.maxFeePerBlobGas || 0, 'maxFeePerBlobGas'),
					formatHashes(e.blobVersionedHashes || [], 'blobVersionedHashes')
				];
				if (t) {
					i.push(formatNumber(t.yParity, 'yParity'));
					i.push((0, p.c4)(t.r));
					i.push((0, p.c4)(t.s));
					if (r) {
						return (0, m.xW)([
							'0x03',
							(0, g.R)([i, r.map((e) => e.data), r.map((e) => e.commitment), r.map((e) => e.proof)])
						]);
					}
				}
				return (0, m.xW)(['0x03', (0, g.R)(i)]);
			}
			class Transaction {
				#Ye;
				#Xe;
				#r;
				#et;
				#tt;
				#rt;
				#nt;
				#it;
				#st;
				#ce;
				#at;
				#ot;
				#ct;
				#ft;
				#ut;
				#lt;
				get type() {
					return this.#Ye;
				}
				set type(e) {
					switch (e) {
						case null:
							this.#Ye = null;
							break;
						case 0:
						case 'legacy':
							this.#Ye = 0;
							break;
						case 1:
						case 'berlin':
						case 'eip-2930':
							this.#Ye = 1;
							break;
						case 2:
						case 'london':
						case 'eip-1559':
							this.#Ye = 2;
							break;
						case 3:
						case 'cancun':
						case 'eip-4844':
							this.#Ye = 3;
							break;
						default:
							(0, d.MR)(false, 'unsupported transaction type', 'type', e);
					}
				}
				get typeName() {
					switch (this.type) {
						case 0:
							return 'legacy';
						case 1:
							return 'eip-2930';
						case 2:
							return 'eip-1559';
						case 3:
							return 'eip-4844';
					}
					return null;
				}
				get to() {
					const e = this.#Xe;
					if (e == null && this.type === 3) {
						return a.j;
					}
					return e;
				}
				set to(e) {
					this.#Xe = e == null ? null : (0, i.b)(e);
				}
				get nonce() {
					return this.#et;
				}
				set nonce(e) {
					this.#et = (0, p.WZ)(e, 'value');
				}
				get gasLimit() {
					return this.#tt;
				}
				set gasLimit(e) {
					this.#tt = (0, p.Ab)(e);
				}
				get gasPrice() {
					const e = this.#rt;
					if (e == null && (this.type === 0 || this.type === 1)) {
						return w;
					}
					return e;
				}
				set gasPrice(e) {
					this.#rt = e == null ? null : (0, p.Ab)(e, 'gasPrice');
				}
				get maxPriorityFeePerGas() {
					const e = this.#nt;
					if (e == null) {
						if (this.type === 2 || this.type === 3) {
							return w;
						}
						return null;
					}
					return e;
				}
				set maxPriorityFeePerGas(e) {
					this.#nt = e == null ? null : (0, p.Ab)(e, 'maxPriorityFeePerGas');
				}
				get maxFeePerGas() {
					const e = this.#it;
					if (e == null) {
						if (this.type === 2 || this.type === 3) {
							return w;
						}
						return null;
					}
					return e;
				}
				set maxFeePerGas(e) {
					this.#it = e == null ? null : (0, p.Ab)(e, 'maxFeePerGas');
				}
				get data() {
					return this.#r;
				}
				set data(e) {
					this.#r = (0, m.c$)(e);
				}
				get value() {
					return this.#st;
				}
				set value(e) {
					this.#st = (0, p.Ab)(e, 'value');
				}
				get chainId() {
					return this.#ce;
				}
				set chainId(e) {
					this.#ce = (0, p.Ab)(e);
				}
				get signature() {
					return this.#at || null;
				}
				set signature(e) {
					this.#at = e == null ? null : c.t.from(e);
				}
				get accessList() {
					const e = this.#ot || null;
					if (e == null) {
						if (this.type === 1 || this.type === 2 || this.type === 3) {
							return [];
						}
						return null;
					}
					return e;
				}
				set accessList(e) {
					this.#ot = e == null ? null : (0, v.$)(e);
				}
				get maxFeePerBlobGas() {
					const e = this.#ct;
					if (e == null && this.type === 3) {
						return w;
					}
					return e;
				}
				set maxFeePerBlobGas(e) {
					this.#ct = e == null ? null : (0, p.Ab)(e, 'maxFeePerBlobGas');
				}
				get blobVersionedHashes() {
					let e = this.#ft;
					if (e == null && this.type === 3) {
						return [];
					}
					return e;
				}
				set blobVersionedHashes(e) {
					if (e != null) {
						(0, d.MR)(Array.isArray(e), 'blobVersionedHashes must be an Array', 'value', e);
						e = e.slice();
						for (let t = 0; t < e.length; t++) {
							(0, d.MR)((0, m.Lo)(e[t], 32), 'invalid blobVersionedHash', `value[${t}]`, e[t]);
						}
					}
					this.#ft = e;
				}
				get blobs() {
					if (this.#lt == null) {
						return null;
					}
					return this.#lt.map((e) => Object.assign({}, e));
				}
				set blobs(e) {
					if (e == null) {
						this.#lt = null;
						return;
					}
					const t = [];
					const r = [];
					for (let i = 0; i < e.length; i++) {
						const a = e[i];
						if ((0, m.f)(a)) {
							(0, d.vA)(
								this.#ut,
								'adding a raw blob requires a KZG library',
								'UNSUPPORTED_OPERATION',
								{ operation: 'set blobs()' }
							);
							let e = (0, m.q5)(a);
							(0, d.MR)(e.length <= x, 'blob is too large', `blobs[${i}]`, a);
							if (e.length !== x) {
								const t = new Uint8Array(x);
								t.set(e);
								e = t;
							}
							const o = this.#ut.blobToKzgCommitment(e);
							const c = (0, m.c$)(this.#ut.computeBlobKzgProof(e, o));
							t.push({ data: (0, m.c$)(e), commitment: (0, m.c$)(o), proof: c });
							r.push(getVersionedHash(1, o));
						} else {
							const e = (0, m.c$)(a.commitment);
							t.push({ data: (0, m.c$)(a.data), commitment: e, proof: (0, m.c$)(a.proof) });
							r.push(getVersionedHash(1, e));
						}
					}
					this.#lt = t;
					this.#ft = r;
				}
				get kzg() {
					return this.#ut;
				}
				set kzg(e) {
					this.#ut = e;
				}
				constructor() {
					this.#Ye = null;
					this.#Xe = null;
					this.#et = 0;
					this.#tt = w;
					this.#rt = null;
					this.#nt = null;
					this.#it = null;
					this.#r = '0x';
					this.#st = w;
					this.#ce = w;
					this.#at = null;
					this.#ot = null;
					this.#ct = null;
					this.#ft = null;
					this.#lt = null;
					this.#ut = null;
				}
				get hash() {
					if (this.signature == null) {
						return null;
					}
					return (0, u.S)(this.#dt(true, false));
				}
				get unsignedHash() {
					return (0, u.S)(this.unsignedSerialized);
				}
				get from() {
					if (this.signature == null) {
						return null;
					}
					return (0, y.x)(this.unsignedHash, this.signature);
				}
				get fromPublicKey() {
					if (this.signature == null) {
						return null;
					}
					return l.h.recoverPublicKey(this.unsignedHash, this.signature);
				}
				isSigned() {
					return this.signature != null;
				}
				#dt(e, t) {
					(0, d.vA)(
						!e || this.signature != null,
						'cannot serialize unsigned transaction; maybe you meant .unsignedSerialized',
						'UNSUPPORTED_OPERATION',
						{ operation: '.serialized' }
					);
					const r = e ? this.signature : null;
					switch (this.inferType()) {
						case 0:
							return _serializeLegacy(this, r);
						case 1:
							return _serializeEip2930(this, r);
						case 2:
							return _serializeEip1559(this, r);
						case 3:
							return _serializeEip4844(this, r, t ? this.blobs : null);
					}
					(0, d.vA)(false, 'unsupported transaction type', 'UNSUPPORTED_OPERATION', {
						operation: '.serialized'
					});
				}
				get serialized() {
					return this.#dt(true, true);
				}
				get unsignedSerialized() {
					return this.#dt(false, false);
				}
				inferType() {
					const e = this.inferTypes();
					if (e.indexOf(2) >= 0) {
						return 2;
					}
					return e.pop();
				}
				inferTypes() {
					const e = this.gasPrice != null;
					const t = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
					const r = this.accessList != null;
					const i = this.#ct != null || this.#ft;
					if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
						(0, d.vA)(
							this.maxFeePerGas >= this.maxPriorityFeePerGas,
							'priorityFee cannot be more than maxFee',
							'BAD_DATA',
							{ value: this }
						);
					}
					(0, d.vA)(
						!t || (this.type !== 0 && this.type !== 1),
						'transaction type cannot have maxFeePerGas or maxPriorityFeePerGas',
						'BAD_DATA',
						{ value: this }
					);
					(0, d.vA)(
						this.type !== 0 || !r,
						'legacy transaction cannot have accessList',
						'BAD_DATA',
						{ value: this }
					);
					const a = [];
					if (this.type != null) {
						a.push(this.type);
					} else {
						if (t) {
							a.push(2);
						} else if (e) {
							a.push(1);
							if (!r) {
								a.push(0);
							}
						} else if (r) {
							a.push(1);
							a.push(2);
						} else if (i && this.to) {
							a.push(3);
						} else {
							a.push(0);
							a.push(1);
							a.push(2);
							a.push(3);
						}
					}
					a.sort();
					return a;
				}
				isLegacy() {
					return this.type === 0;
				}
				isBerlin() {
					return this.type === 1;
				}
				isLondon() {
					return this.type === 2;
				}
				isCancun() {
					return this.type === 3;
				}
				clone() {
					return Transaction.from(this);
				}
				toJSON() {
					const s = (e) => {
						if (e == null) {
							return null;
						}
						return e.toString();
					};
					return {
						type: this.type,
						to: this.to,
						data: this.data,
						nonce: this.nonce,
						gasLimit: s(this.gasLimit),
						gasPrice: s(this.gasPrice),
						maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
						maxFeePerGas: s(this.maxFeePerGas),
						value: s(this.value),
						chainId: s(this.chainId),
						sig: this.signature ? this.signature.toJSON() : null,
						accessList: this.accessList
					};
				}
				static from(e) {
					if (e == null) {
						return new Transaction();
					}
					if (typeof e === 'string') {
						const t = (0, m.q5)(e);
						if (t[0] >= 127) {
							return Transaction.from(_parseLegacy(t));
						}
						switch (t[0]) {
							case 1:
								return Transaction.from(_parseEip2930(t));
							case 2:
								return Transaction.from(_parseEip1559(t));
							case 3:
								return Transaction.from(_parseEip4844(t));
						}
						(0, d.vA)(false, 'unsupported transaction type', 'UNSUPPORTED_OPERATION', {
							operation: 'from'
						});
					}
					const t = new Transaction();
					if (e.type != null) {
						t.type = e.type;
					}
					if (e.to != null) {
						t.to = e.to;
					}
					if (e.nonce != null) {
						t.nonce = e.nonce;
					}
					if (e.gasLimit != null) {
						t.gasLimit = e.gasLimit;
					}
					if (e.gasPrice != null) {
						t.gasPrice = e.gasPrice;
					}
					if (e.maxPriorityFeePerGas != null) {
						t.maxPriorityFeePerGas = e.maxPriorityFeePerGas;
					}
					if (e.maxFeePerGas != null) {
						t.maxFeePerGas = e.maxFeePerGas;
					}
					if (e.maxFeePerBlobGas != null) {
						t.maxFeePerBlobGas = e.maxFeePerBlobGas;
					}
					if (e.data != null) {
						t.data = e.data;
					}
					if (e.value != null) {
						t.value = e.value;
					}
					if (e.chainId != null) {
						t.chainId = e.chainId;
					}
					if (e.signature != null) {
						t.signature = c.t.from(e.signature);
					}
					if (e.accessList != null) {
						t.accessList = e.accessList;
					}
					if (e.blobVersionedHashes != null) {
						t.blobVersionedHashes = e.blobVersionedHashes;
					}
					if (e.kzg != null) {
						t.kzg = e.kzg;
					}
					if (e.blobs != null) {
						t.blobs = e.blobs;
					}
					if (e.hash != null) {
						(0, d.MR)(t.isSigned(), "unsigned transaction cannot define '.hash'", 'tx', e);
						(0, d.MR)(t.hash === e.hash, 'hash mismatch', 'tx', e);
					}
					if (e.from != null) {
						(0, d.MR)(t.isSigned(), "unsigned transaction cannot define '.from'", 'tx', e);
						(0, d.MR)(
							t.from.toLowerCase() === (e.from || '').toLowerCase(),
							'from mismatch',
							'tx',
							e
						);
					}
					return t;
				}
			}
		},
		9735: (e, t, r) => {
			'use strict';
			r.d(t, { H: () => decodeBase58, R: () => encodeBase58 });
			var i = r(6919);
			var a = r(8492);
			var o = r(572);
			const c = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
			let u = null;
			function getAlpha(e) {
				if (u == null) {
					u = {};
					for (let e = 0; e < c.length; e++) {
						u[c[e]] = BigInt(e);
					}
				}
				const t = u[e];
				(0, a.MR)(t != null, `invalid base58 value`, 'letter', e);
				return t;
			}
			const l = BigInt(0);
			const d = BigInt(58);
			function encodeBase58(e) {
				const t = (0, i.q5)(e);
				let r = (0, o.Dg)(t);
				let a = '';
				while (r) {
					a = c[Number(r % d)] + a;
					r /= d;
				}
				for (let e = 0; e < t.length; e++) {
					if (t[e]) {
						break;
					}
					a = c[0] + a;
				}
				return a;
			}
			function decodeBase58(e) {
				let t = l;
				for (let r = 0; r < e.length; r++) {
					t *= d;
					t += getAlpha(e[r]);
				}
				return t;
			}
		},
		6919: (e, t, r) => {
			'use strict';
			r.d(t, {
				Lm: () => getBytesCopy,
				Lo: () => isHexString,
				X_: () => zeroPadBytes,
				ZG: () => dataSlice,
				c$: () => hexlify,
				f: () => isBytesLike,
				nx: () => zeroPadValue,
				pO: () => dataLength,
				q5: () => getBytes,
				xW: () => concat
			});
			var i = r(8492);
			function _getBytes(e, t, r) {
				if (e instanceof Uint8Array) {
					if (r) {
						return new Uint8Array(e);
					}
					return e;
				}
				if (typeof e === 'string' && e.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
					const t = new Uint8Array((e.length - 2) / 2);
					let r = 2;
					for (let i = 0; i < t.length; i++) {
						t[i] = parseInt(e.substring(r, r + 2), 16);
						r += 2;
					}
					return t;
				}
				(0, i.MR)(false, 'invalid BytesLike value', t || 'value', e);
			}
			function getBytes(e, t) {
				return _getBytes(e, t, false);
			}
			function getBytesCopy(e, t) {
				return _getBytes(e, t, true);
			}
			function isHexString(e, t) {
				if (typeof e !== 'string' || !e.match(/^0x[0-9A-Fa-f]*$/)) {
					return false;
				}
				if (typeof t === 'number' && e.length !== 2 + 2 * t) {
					return false;
				}
				if (t === true && e.length % 2 !== 0) {
					return false;
				}
				return true;
			}
			function isBytesLike(e) {
				return isHexString(e, true) || e instanceof Uint8Array;
			}
			const a = '0123456789abcdef';
			function hexlify(e) {
				const t = getBytes(e);
				let r = '0x';
				for (let e = 0; e < t.length; e++) {
					const i = t[e];
					r += a[(i & 240) >> 4] + a[i & 15];
				}
				return r;
			}
			function concat(e) {
				return '0x' + e.map((e) => hexlify(e).substring(2)).join('');
			}
			function dataLength(e) {
				if (isHexString(e, true)) {
					return (e.length - 2) / 2;
				}
				return getBytes(e).length;
			}
			function dataSlice(e, t, r) {
				const a = getBytes(e);
				if (r != null && r > a.length) {
					(0, i.vA)(false, 'cannot slice beyond data bounds', 'BUFFER_OVERRUN', {
						buffer: a,
						length: a.length,
						offset: r
					});
				}
				return hexlify(a.slice(t == null ? 0 : t, r == null ? a.length : r));
			}
			function stripZerosLeft(e) {
				let t = hexlify(e).substring(2);
				while (t.startsWith('00')) {
					t = t.substring(2);
				}
				return '0x' + t;
			}
			function zeroPad(e, t, r) {
				const a = getBytes(e);
				(0, i.vA)(t >= a.length, 'padding exceeds data length', 'BUFFER_OVERRUN', {
					buffer: new Uint8Array(a),
					length: t,
					offset: t + 1
				});
				const o = new Uint8Array(t);
				o.fill(0);
				if (r) {
					o.set(a, t - a.length);
				} else {
					o.set(a, 0);
				}
				return hexlify(o);
			}
			function zeroPadValue(e, t) {
				return zeroPad(e, t, true);
			}
			function zeroPadBytes(e, t) {
				return zeroPad(e, t, false);
			}
		},
		8492: (e, t, r) => {
			'use strict';
			r.d(t, {
				E: () => isCallException,
				MR: () => assertArgument,
				SP: () => assertNormalize,
				bJ: () => isError,
				dd: () => assertArgumentCount,
				gk: () => assertPrivate,
				vA: () => assert,
				xz: () => makeError
			});
			var i = r(2186);
			var a = r(4918);
			function stringify(e) {
				if (e == null) {
					return 'null';
				}
				if (Array.isArray(e)) {
					return '[ ' + e.map(stringify).join(', ') + ' ]';
				}
				if (e instanceof Uint8Array) {
					const t = '0123456789abcdef';
					let r = '0x';
					for (let i = 0; i < e.length; i++) {
						r += t[e[i] >> 4];
						r += t[e[i] & 15];
					}
					return r;
				}
				if (typeof e === 'object' && typeof e.toJSON === 'function') {
					return stringify(e.toJSON());
				}
				switch (typeof e) {
					case 'boolean':
					case 'symbol':
						return e.toString();
					case 'bigint':
						return BigInt(e).toString();
					case 'number':
						return e.toString();
					case 'string':
						return JSON.stringify(e);
					case 'object': {
						const t = Object.keys(e);
						t.sort();
						return '{ ' + t.map((t) => `${stringify(t)}: ${stringify(e[t])}`).join(', ') + ' }';
					}
				}
				return `[ COULD NOT SERIALIZE ]`;
			}
			function isError(e, t) {
				return e && e.code === t;
			}
			function isCallException(e) {
				return isError(e, 'CALL_EXCEPTION');
			}
			function makeError(e, t, r) {
				let o = e;
				{
					const a = [];
					if (r) {
						if ('message' in r || 'code' in r || 'name' in r) {
							throw new Error(`value will overwrite populated values: ${stringify(r)}`);
						}
						for (const e in r) {
							if (e === 'shortMessage') {
								continue;
							}
							const t = r[e];
							a.push(e + '=' + stringify(t));
						}
					}
					a.push(`code=${t}`);
					a.push(`version=${i.r}`);
					if (a.length) {
						e += ' (' + a.join(', ') + ')';
					}
				}
				let c;
				switch (t) {
					case 'INVALID_ARGUMENT':
						c = new TypeError(e);
						break;
					case 'NUMERIC_FAULT':
					case 'BUFFER_OVERRUN':
						c = new RangeError(e);
						break;
					default:
						c = new Error(e);
				}
				(0, a.n)(c, { code: t });
				if (r) {
					Object.assign(c, r);
				}
				if (c.shortMessage == null) {
					(0, a.n)(c, { shortMessage: o });
				}
				return c;
			}
			function assert(e, t, r, i) {
				if (!e) {
					throw makeError(t, r, i);
				}
			}
			function assertArgument(e, t, r, i) {
				assert(e, t, 'INVALID_ARGUMENT', { argument: r, value: i });
			}
			function assertArgumentCount(e, t, r) {
				if (r == null) {
					r = '';
				}
				if (r) {
					r = ': ' + r;
				}
				assert(e >= t, 'missing argument' + r, 'MISSING_ARGUMENT', { count: e, expectedCount: t });
				assert(e <= t, 'too many arguments' + r, 'UNEXPECTED_ARGUMENT', {
					count: e,
					expectedCount: t
				});
			}
			const o = ['NFD', 'NFC', 'NFKD', 'NFKC'].reduce((e, t) => {
				try {
					if ('test'.normalize(t) !== 'test') {
						throw new Error('bad');
					}
					if (t === 'NFD') {
						const e = String.fromCharCode(233).normalize('NFD');
						const t = String.fromCharCode(101, 769);
						if (e !== t) {
							throw new Error('broken');
						}
					}
					e.push(t);
				} catch (e) {}
				return e;
			}, []);
			function assertNormalize(e) {
				assert(
					o.indexOf(e) >= 0,
					'platform missing String.prototype.normalize',
					'UNSUPPORTED_OPERATION',
					{ operation: 'String.prototype.normalize', info: { form: e } }
				);
			}
			function assertPrivate(e, t, r) {
				if (r == null) {
					r = '';
				}
				if (e !== t) {
					let e = r,
						t = 'new';
					if (r) {
						e += '.';
						t += ' ' + r;
					}
					assert(false, `private constructor; use ${e}from* methods`, 'UNSUPPORTED_OPERATION', {
						operation: t
					});
				}
			}
		},
		5362: (e, t, r) => {
			'use strict';
			r.d(t, { z: () => EventPayload });
			var i = r(4918);
			class EventPayload {
				filter;
				emitter;
				#ht;
				constructor(e, t, r) {
					this.#ht = t;
					(0, i.n)(this, { emitter: e, filter: r });
				}
				async removeListener() {
					if (this.#ht == null) {
						return;
					}
					await this.emitter.off(this.filter, this.#ht);
				}
			}
		},
		572: (e, t, r) => {
			'use strict';
			r.d(t, {
				Ab: () => getBigInt,
				Dg: () => toBigInt,
				JJ: () => toTwos,
				Ro: () => toNumber,
				ST: () => fromTwos,
				WZ: () => getNumber,
				c4: () => toBeArray,
				dK: () => mask,
				nD: () => toQuantity,
				up: () => toBeHex
			});
			var i = r(6919);
			var a = r(8492);
			const o = BigInt(0);
			const c = BigInt(1);
			const u = 9007199254740991;
			function fromTwos(e, t) {
				const r = getUint(e, 'value');
				const i = BigInt(getNumber(t, 'width'));
				(0, a.vA)(r >> i === o, 'overflow', 'NUMERIC_FAULT', {
					operation: 'fromTwos',
					fault: 'overflow',
					value: e
				});
				if (r >> (i - c)) {
					const e = (c << i) - c;
					return -((~r & e) + c);
				}
				return r;
			}
			function toTwos(e, t) {
				let r = getBigInt(e, 'value');
				const i = BigInt(getNumber(t, 'width'));
				const u = c << (i - c);
				if (r < o) {
					r = -r;
					(0, a.vA)(r <= u, 'too low', 'NUMERIC_FAULT', {
						operation: 'toTwos',
						fault: 'overflow',
						value: e
					});
					const t = (c << i) - c;
					return (~r & t) + c;
				} else {
					(0, a.vA)(r < u, 'too high', 'NUMERIC_FAULT', {
						operation: 'toTwos',
						fault: 'overflow',
						value: e
					});
				}
				return r;
			}
			function mask(e, t) {
				const r = getUint(e, 'value');
				const i = BigInt(getNumber(t, 'bits'));
				return r & ((c << i) - c);
			}
			function getBigInt(e, t) {
				switch (typeof e) {
					case 'bigint':
						return e;
					case 'number':
						(0, a.MR)(Number.isInteger(e), 'underflow', t || 'value', e);
						(0, a.MR)(e >= -u && e <= u, 'overflow', t || 'value', e);
						return BigInt(e);
					case 'string':
						try {
							if (e === '') {
								throw new Error('empty string');
							}
							if (e[0] === '-' && e[1] !== '-') {
								return -BigInt(e.substring(1));
							}
							return BigInt(e);
						} catch (r) {
							(0, a.MR)(false, `invalid BigNumberish string: ${r.message}`, t || 'value', e);
						}
				}
				(0, a.MR)(false, 'invalid BigNumberish value', t || 'value', e);
			}
			function getUint(e, t) {
				const r = getBigInt(e, t);
				(0, a.vA)(r >= o, 'unsigned value cannot be negative', 'NUMERIC_FAULT', {
					fault: 'overflow',
					operation: 'getUint',
					value: e
				});
				return r;
			}
			const l = '0123456789abcdef';
			function toBigInt(e) {
				if (e instanceof Uint8Array) {
					let t = '0x0';
					for (const r of e) {
						t += l[r >> 4];
						t += l[r & 15];
					}
					return BigInt(t);
				}
				return getBigInt(e);
			}
			function getNumber(e, t) {
				switch (typeof e) {
					case 'bigint':
						(0, a.MR)(e >= -u && e <= u, 'overflow', t || 'value', e);
						return Number(e);
					case 'number':
						(0, a.MR)(Number.isInteger(e), 'underflow', t || 'value', e);
						(0, a.MR)(e >= -u && e <= u, 'overflow', t || 'value', e);
						return e;
					case 'string':
						try {
							if (e === '') {
								throw new Error('empty string');
							}
							return getNumber(BigInt(e), t);
						} catch (r) {
							(0, a.MR)(false, `invalid numeric string: ${r.message}`, t || 'value', e);
						}
				}
				(0, a.MR)(false, 'invalid numeric value', t || 'value', e);
			}
			function toNumber(e) {
				return getNumber(toBigInt(e));
			}
			function toBeHex(e, t) {
				const r = getUint(e, 'value');
				let i = r.toString(16);
				if (t == null) {
					if (i.length % 2) {
						i = '0' + i;
					}
				} else {
					const r = getNumber(t, 'width');
					(0, a.vA)(r * 2 >= i.length, `value exceeds width (${r} bytes)`, 'NUMERIC_FAULT', {
						operation: 'toBeHex',
						fault: 'overflow',
						value: e
					});
					while (i.length < r * 2) {
						i = '0' + i;
					}
				}
				return '0x' + i;
			}
			function toBeArray(e) {
				const t = getUint(e, 'value');
				if (t === o) {
					return new Uint8Array([]);
				}
				let r = t.toString(16);
				if (r.length % 2) {
					r = '0' + r;
				}
				const i = new Uint8Array(r.length / 2);
				for (let e = 0; e < i.length; e++) {
					const t = e * 2;
					i[e] = parseInt(r.substring(t, t + 2), 16);
				}
				return i;
			}
			function toQuantity(e) {
				let t = (0, i.c$)((0, i.f)(e) ? e : toBeArray(e)).substring(2);
				while (t.startsWith('0')) {
					t = t.substring(1);
				}
				if (t === '') {
					t = '0';
				}
				return '0x' + t;
			}
		},
		4918: (e, t, r) => {
			'use strict';
			r.d(t, { k: () => resolveProperties, n: () => defineProperties });
			function checkType(e, t, r) {
				const i = t.split('|').map((e) => e.trim());
				for (let r = 0; r < i.length; r++) {
					switch (t) {
						case 'any':
							return;
						case 'bigint':
						case 'boolean':
						case 'number':
						case 'string':
							if (typeof e === t) {
								return;
							}
					}
				}
				const a = new Error(`invalid value for type ${t}`);
				a.code = 'INVALID_ARGUMENT';
				a.argument = `value.${r}`;
				a.value = e;
				throw a;
			}
			async function resolveProperties(e) {
				const t = Object.keys(e);
				const r = await Promise.all(t.map((t) => Promise.resolve(e[t])));
				return r.reduce((e, r, i) => {
					e[t[i]] = r;
					return e;
				}, {});
			}
			function defineProperties(e, t, r) {
				for (let i in t) {
					let a = t[i];
					const o = r ? r[i] : null;
					if (o) {
						checkType(a, o, i);
					}
					Object.defineProperty(e, i, { enumerable: true, value: a, writable: false });
				}
			}
		},
		3996: (e, t, r) => {
			'use strict';
			r.d(t, { R: () => encodeRlp });
			var i = r(6919);
			function arrayifyInteger(e) {
				const t = [];
				while (e) {
					t.unshift(e & 255);
					e >>= 8;
				}
				return t;
			}
			function _encode(e) {
				if (Array.isArray(e)) {
					let t = [];
					e.forEach(function (e) {
						t = t.concat(_encode(e));
					});
					if (t.length <= 55) {
						t.unshift(192 + t.length);
						return t;
					}
					const r = arrayifyInteger(t.length);
					r.unshift(247 + r.length);
					return r.concat(t);
				}
				const t = Array.prototype.slice.call((0, i.q5)(e, 'object'));
				if (t.length === 1 && t[0] <= 127) {
					return t;
				} else if (t.length <= 55) {
					t.unshift(128 + t.length);
					return t;
				}
				const r = arrayifyInteger(t.length);
				r.unshift(183 + r.length);
				return r.concat(t);
			}
			const a = '0123456789abcdef';
			function encodeRlp(e) {
				let t = '0x';
				for (const r of _encode(e)) {
					t += a[r >> 4];
					t += a[r & 15];
				}
				return t;
			}
		},
		8069: (e, t, r) => {
			'use strict';
			r.d(t, { Js: () => formatUnits });
			var i = r(8492);
			var a = r(6919);
			var o = r(572);
			var c = r(4918);
			const u = BigInt(-1);
			const l = BigInt(0);
			const d = BigInt(1);
			const p = BigInt(5);
			const m = {};
			let g = '0000';
			while (g.length < 80) {
				g += g;
			}
			function getTens(e) {
				let t = g;
				while (t.length < e) {
					t += t;
				}
				return BigInt('1' + t.substring(0, e));
			}
			function checkValue(e, t, r) {
				const a = BigInt(t.width);
				if (t.signed) {
					const t = d << (a - d);
					(0, i.vA)(r == null || (e >= -t && e < t), 'overflow', 'NUMERIC_FAULT', {
						operation: r,
						fault: 'overflow',
						value: e
					});
					if (e > l) {
						e = (0, o.ST)((0, o.dK)(e, a), a);
					} else {
						e = -(0, o.ST)((0, o.dK)(-e, a), a);
					}
				} else {
					const t = d << a;
					(0, i.vA)(r == null || (e >= 0 && e < t), 'overflow', 'NUMERIC_FAULT', {
						operation: r,
						fault: 'overflow',
						value: e
					});
					e = ((e % t) + t) % t & (t - d);
				}
				return e;
			}
			function getFormat(e) {
				if (typeof e === 'number') {
					e = `fixed128x${e}`;
				}
				let t = true;
				let r = 128;
				let a = 18;
				if (typeof e === 'string') {
					if (e === 'fixed') {
					} else if (e === 'ufixed') {
						t = false;
					} else {
						const o = e.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
						(0, i.MR)(o, 'invalid fixed format', 'format', e);
						t = o[1] !== 'u';
						r = parseInt(o[2]);
						a = parseInt(o[3]);
					}
				} else if (e) {
					const o = e;
					const check = (e, t, r) => {
						if (o[e] == null) {
							return r;
						}
						(0, i.MR)(
							typeof o[e] === t,
							'invalid fixed format (' + e + ' not ' + t + ')',
							'format.' + e,
							o[e]
						);
						return o[e];
					};
					t = check('signed', 'boolean', t);
					r = check('width', 'number', r);
					a = check('decimals', 'number', a);
				}
				(0, i.MR)(r % 8 === 0, 'invalid FixedNumber width (not byte aligned)', 'format.width', r);
				(0, i.MR)(a <= 80, 'invalid FixedNumber decimals (too large)', 'format.decimals', a);
				const o = (t ? '' : 'u') + 'fixed' + String(r) + 'x' + String(a);
				return { signed: t, width: r, decimals: a, name: o };
			}
			function fixednumber_toString(e, t) {
				let r = '';
				if (e < l) {
					r = '-';
					e *= u;
				}
				let i = e.toString();
				if (t === 0) {
					return r + i;
				}
				while (i.length <= t) {
					i = g + i;
				}
				const a = i.length - t;
				i = i.substring(0, a) + '.' + i.substring(a);
				while (i[0] === '0' && i[1] !== '.') {
					i = i.substring(1);
				}
				while (i[i.length - 1] === '0' && i[i.length - 2] !== '.') {
					i = i.substring(0, i.length - 1);
				}
				return r + i;
			}
			class fixednumber_FixedNumber {
				format;
				#pt;
				#mt;
				#gt;
				_value;
				constructor(e, t, r) {
					(0, i.gk)(e, m, 'FixedNumber');
					this.#mt = t;
					this.#pt = r;
					const a = fixednumber_toString(t, r.decimals);
					(0, c.n)(this, { format: r.name, _value: a });
					this.#gt = getTens(r.decimals);
				}
				get signed() {
					return this.#pt.signed;
				}
				get width() {
					return this.#pt.width;
				}
				get decimals() {
					return this.#pt.decimals;
				}
				get value() {
					return this.#mt;
				}
				#vt(e) {
					(0, i.MR)(
						this.format === e.format,
						'incompatible format; use fixedNumber.toFormat',
						'other',
						e
					);
				}
				#yt(e, t) {
					e = checkValue(e, this.#pt, t);
					return new fixednumber_FixedNumber(m, e, this.#pt);
				}
				#bt(e, t) {
					this.#vt(e);
					return this.#yt(this.#mt + e.#mt, t);
				}
				addUnsafe(e) {
					return this.#bt(e);
				}
				add(e) {
					return this.#bt(e, 'add');
				}
				#wt(e, t) {
					this.#vt(e);
					return this.#yt(this.#mt - e.#mt, t);
				}
				subUnsafe(e) {
					return this.#wt(e);
				}
				sub(e) {
					return this.#wt(e, 'sub');
				}
				#_t(e, t) {
					this.#vt(e);
					return this.#yt((this.#mt * e.#mt) / this.#gt, t);
				}
				mulUnsafe(e) {
					return this.#_t(e);
				}
				mul(e) {
					return this.#_t(e, 'mul');
				}
				mulSignal(e) {
					this.#vt(e);
					const t = this.#mt * e.#mt;
					(0, i.vA)(t % this.#gt === l, 'precision lost during signalling mul', 'NUMERIC_FAULT', {
						operation: 'mulSignal',
						fault: 'underflow',
						value: this
					});
					return this.#yt(t / this.#gt, 'mulSignal');
				}
				#At(e, t) {
					(0, i.vA)(e.#mt !== l, 'division by zero', 'NUMERIC_FAULT', {
						operation: 'div',
						fault: 'divide-by-zero',
						value: this
					});
					this.#vt(e);
					return this.#yt((this.#mt * this.#gt) / e.#mt, t);
				}
				divUnsafe(e) {
					return this.#At(e);
				}
				div(e) {
					return this.#At(e, 'div');
				}
				divSignal(e) {
					(0, i.vA)(e.#mt !== l, 'division by zero', 'NUMERIC_FAULT', {
						operation: 'div',
						fault: 'divide-by-zero',
						value: this
					});
					this.#vt(e);
					const t = this.#mt * this.#gt;
					(0, i.vA)(t % e.#mt === l, 'precision lost during signalling div', 'NUMERIC_FAULT', {
						operation: 'divSignal',
						fault: 'underflow',
						value: this
					});
					return this.#yt(t / e.#mt, 'divSignal');
				}
				cmp(e) {
					let t = this.value,
						r = e.value;
					const i = this.decimals - e.decimals;
					if (i > 0) {
						r *= getTens(i);
					} else if (i < 0) {
						t *= getTens(-i);
					}
					if (t < r) {
						return -1;
					}
					if (t > r) {
						return 1;
					}
					return 0;
				}
				eq(e) {
					return this.cmp(e) === 0;
				}
				lt(e) {
					return this.cmp(e) < 0;
				}
				lte(e) {
					return this.cmp(e) <= 0;
				}
				gt(e) {
					return this.cmp(e) > 0;
				}
				gte(e) {
					return this.cmp(e) >= 0;
				}
				floor() {
					let e = this.#mt;
					if (this.#mt < l) {
						e -= this.#gt - d;
					}
					e = (this.#mt / this.#gt) * this.#gt;
					return this.#yt(e, 'floor');
				}
				ceiling() {
					let e = this.#mt;
					if (this.#mt > l) {
						e += this.#gt - d;
					}
					e = (this.#mt / this.#gt) * this.#gt;
					return this.#yt(e, 'ceiling');
				}
				round(e) {
					if (e == null) {
						e = 0;
					}
					if (e >= this.decimals) {
						return this;
					}
					const t = this.decimals - e;
					const r = p * getTens(t - 1);
					let i = this.value + r;
					const a = getTens(t);
					i = (i / a) * a;
					checkValue(i, this.#pt, 'round');
					return new fixednumber_FixedNumber(m, i, this.#pt);
				}
				isZero() {
					return this.#mt === l;
				}
				isNegative() {
					return this.#mt < l;
				}
				toString() {
					return this._value;
				}
				toUnsafeFloat() {
					return parseFloat(this.toString());
				}
				toFormat(e) {
					return fixednumber_FixedNumber.fromString(this.toString(), e);
				}
				static fromValue(e, t, r) {
					const a = t == null ? 0 : (0, o.WZ)(t);
					const c = getFormat(r);
					let u = (0, o.Ab)(e, 'value');
					const d = a - c.decimals;
					if (d > 0) {
						const t = getTens(d);
						(0, i.vA)(u % t === l, 'value loses precision for format', 'NUMERIC_FAULT', {
							operation: 'fromValue',
							fault: 'underflow',
							value: e
						});
						u /= t;
					} else if (d < 0) {
						u *= getTens(-d);
					}
					checkValue(u, c, 'fromValue');
					return new fixednumber_FixedNumber(m, u, c);
				}
				static fromString(e, t) {
					const r = e.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
					(0, i.MR)(
						r && r[2].length + r[3].length > 0,
						'invalid FixedNumber string value',
						'value',
						e
					);
					const a = getFormat(t);
					let o = r[2] || '0',
						c = r[3] || '';
					while (c.length < a.decimals) {
						c += g;
					}
					(0, i.vA)(
						c.substring(a.decimals).match(/^0*$/),
						'too many decimals for format',
						'NUMERIC_FAULT',
						{ operation: 'fromString', fault: 'underflow', value: e }
					);
					c = c.substring(0, a.decimals);
					const u = BigInt(r[1] + o + c);
					checkValue(u, a, 'fromString');
					return new fixednumber_FixedNumber(m, u, a);
				}
				static fromBytes(e, t) {
					let r = (0, o.Dg)((0, a.q5)(e, 'value'));
					const i = getFormat(t);
					if (i.signed) {
						r = (0, o.ST)(r, i.width);
					}
					checkValue(r, i, 'fromBytes');
					return new fixednumber_FixedNumber(m, r, i);
				}
			}
			const v = ['wei', 'kwei', 'mwei', 'gwei', 'szabo', 'finney', 'ether'];
			function formatUnits(e, t) {
				let r = 18;
				if (typeof t === 'string') {
					const e = v.indexOf(t);
					(0, i.MR)(e >= 0, 'invalid unit', 'unit', t);
					r = 3 * e;
				} else if (t != null) {
					r = (0, o.WZ)(t, 'unit');
				}
				return fixednumber_FixedNumber.fromValue(e, r, { decimals: r, width: 512 }).toString();
			}
			function parseUnits(e, t) {
				assertArgument(typeof e === 'string', 'value must be a string', 'value', e);
				let r = 18;
				if (typeof t === 'string') {
					const e = v.indexOf(t);
					assertArgument(e >= 0, 'invalid unit', 'unit', t);
					r = 3 * e;
				} else if (t != null) {
					r = getNumber(t, 'unit');
				}
				return FixedNumber.fromString(e, { decimals: r, width: 512 }).value;
			}
			function formatEther(e) {
				return formatUnits(e, 18);
			}
			function parseEther(e) {
				return parseUnits(e, 18);
			}
		},
		7756: (e, t, r) => {
			'use strict';
			r.d(t, { YW: () => toUtf8Bytes, _v: () => toUtf8String });
			var i = r(6919);
			var a = r(8492);
			function errorFunc(e, t, r, i, o) {
				(0, a.MR)(false, `invalid codepoint at offset ${t}; ${e}`, 'bytes', r);
			}
			function ignoreFunc(e, t, r, i, a) {
				if (e === 'BAD_PREFIX' || e === 'UNEXPECTED_CONTINUE') {
					let e = 0;
					for (let i = t + 1; i < r.length; i++) {
						if (r[i] >> 6 !== 2) {
							break;
						}
						e++;
					}
					return e;
				}
				if (e === 'OVERRUN') {
					return r.length - t - 1;
				}
				return 0;
			}
			function replaceFunc(e, t, r, i, o) {
				if (e === 'OVERLONG') {
					(0, a.MR)(
						typeof o === 'number',
						'invalid bad code point for replacement',
						'badCodepoint',
						o
					);
					i.push(o);
					return 0;
				}
				i.push(65533);
				return ignoreFunc(e, t, r, i, o);
			}
			const o = Object.freeze({ error: errorFunc, ignore: ignoreFunc, replace: replaceFunc });
			function getUtf8CodePoints(e, t) {
				if (t == null) {
					t = o.error;
				}
				const r = (0, i.q5)(e, 'bytes');
				const a = [];
				let c = 0;
				while (c < r.length) {
					const e = r[c++];
					if (e >> 7 === 0) {
						a.push(e);
						continue;
					}
					let i = null;
					let o = null;
					if ((e & 224) === 192) {
						i = 1;
						o = 127;
					} else if ((e & 240) === 224) {
						i = 2;
						o = 2047;
					} else if ((e & 248) === 240) {
						i = 3;
						o = 65535;
					} else {
						if ((e & 192) === 128) {
							c += t('UNEXPECTED_CONTINUE', c - 1, r, a);
						} else {
							c += t('BAD_PREFIX', c - 1, r, a);
						}
						continue;
					}
					if (c - 1 + i >= r.length) {
						c += t('OVERRUN', c - 1, r, a);
						continue;
					}
					let u = e & ((1 << (8 - i - 1)) - 1);
					for (let e = 0; e < i; e++) {
						let e = r[c];
						if ((e & 192) != 128) {
							c += t('MISSING_CONTINUE', c, r, a);
							u = null;
							break;
						}
						u = (u << 6) | (e & 63);
						c++;
					}
					if (u === null) {
						continue;
					}
					if (u > 1114111) {
						c += t('OUT_OF_RANGE', c - 1 - i, r, a, u);
						continue;
					}
					if (u >= 55296 && u <= 57343) {
						c += t('UTF16_SURROGATE', c - 1 - i, r, a, u);
						continue;
					}
					if (u <= o) {
						c += t('OVERLONG', c - 1 - i, r, a, u);
						continue;
					}
					a.push(u);
				}
				return a;
			}
			function toUtf8Bytes(e, t) {
				(0, a.MR)(typeof e === 'string', 'invalid string value', 'str', e);
				if (t != null) {
					(0, a.SP)(t);
					e = e.normalize(t);
				}
				let r = [];
				for (let t = 0; t < e.length; t++) {
					const i = e.charCodeAt(t);
					if (i < 128) {
						r.push(i);
					} else if (i < 2048) {
						r.push((i >> 6) | 192);
						r.push((i & 63) | 128);
					} else if ((i & 64512) == 55296) {
						t++;
						const o = e.charCodeAt(t);
						(0, a.MR)(t < e.length && (o & 64512) === 56320, 'invalid surrogate pair', 'str', e);
						const c = 65536 + ((i & 1023) << 10) + (o & 1023);
						r.push((c >> 18) | 240);
						r.push(((c >> 12) & 63) | 128);
						r.push(((c >> 6) & 63) | 128);
						r.push((c & 63) | 128);
					} else {
						r.push((i >> 12) | 224);
						r.push(((i >> 6) & 63) | 128);
						r.push((i & 63) | 128);
					}
				}
				return new Uint8Array(r);
			}
			function _toUtf8String(e) {
				return e
					.map((e) => {
						if (e <= 65535) {
							return String.fromCharCode(e);
						}
						e -= 65536;
						return String.fromCharCode(((e >> 10) & 1023) + 55296, (e & 1023) + 56320);
					})
					.join('');
			}
			function toUtf8String(e, t) {
				return _toUtf8String(getUtf8CodePoints(e, t));
			}
			function toUtf8CodePoints(e, t) {
				return getUtf8CodePoints(toUtf8Bytes(e, t));
			}
		},
		1418: (e, t, r) => {
			'use strict';
			r.d(t, { L: () => BaseWallet });
			var i = r(2857);
			var a = r(6686);
			var o = r(3944);
			var c = r(5647);
			var u = r(6959);
			var l = r(3679);
			var d = r(5738);
			var p = r(7818);
			var m = r(8492);
			var g = r(4918);
			class BaseWallet extends u.Z {
				address;
				#Et;
				constructor(e, t) {
					super(t);
					(0, m.MR)(
						e && typeof e.sign === 'function',
						'invalid private key',
						'privateKey',
						'[ REDACTED ]'
					);
					this.#Et = e;
					const r = (0, d.K)(this.signingKey.publicKey);
					(0, g.n)(this, { address: r });
				}
				get signingKey() {
					return this.#Et;
				}
				get privateKey() {
					return this.signingKey.privateKey;
				}
				async getAddress() {
					return this.address;
				}
				connect(e) {
					return new BaseWallet(this.#Et, e);
				}
				async signTransaction(e) {
					e = (0, l.VS)(e);
					const { to: t, from: r } = await (0, g.k)({
						to: e.to ? (0, i.tG)(e.to, this.provider) : undefined,
						from: e.from ? (0, i.tG)(e.from, this.provider) : undefined
					});
					if (t != null) {
						e.to = t;
					}
					if (r != null) {
						e.from = r;
					}
					if (e.from != null) {
						(0, m.MR)(
							(0, a.b)(e.from) === this.address,
							'transaction from address mismatch',
							'tx.from',
							e.from
						);
						delete e.from;
					}
					const o = p.Z.from(e);
					o.signature = this.signingKey.sign(o.unsignedHash);
					return o.serialized;
				}
				async signMessage(e) {
					return this.signMessageSync(e);
				}
				signMessageSync(e) {
					return this.signingKey.sign((0, o.A)(e)).serialized;
				}
				async signTypedData(e, t, r) {
					const i = await c.z.resolveNames(e, t, r, async (e) => {
						(0, m.vA)(
							this.provider != null,
							'cannot resolve ENS names without a provider',
							'UNSUPPORTED_OPERATION',
							{ operation: 'resolveName', info: { name: e } }
						);
						const t = await this.provider.resolveName(e);
						(0, m.vA)(t != null, 'unconfigured ENS name', 'UNCONFIGURED_NAME', { value: e });
						return t;
					});
					return this.signingKey.sign(c.z.hash(i.domain, t, i.value)).serialized;
				}
			}
		},
		7714: (e, t, r) => {
			'use strict';
			r.d(t, { QX: () => HDNodeWallet });
			var i = r(4931);
			var a = r(3042);
			var o = r(6919);
			let c = false;
			const _computeHmac = function (e, t, r) {
				return (0, a.Gz)(e, t).update(r).digest();
			};
			let u = _computeHmac;
			function computeHmac(e, t, r) {
				const i = (0, o.q5)(t, 'key');
				const a = (0, o.q5)(r, 'data');
				return (0, o.c$)(u(e, i, a));
			}
			computeHmac._ = _computeHmac;
			computeHmac.lock = function () {
				c = true;
			};
			computeHmac.register = function (e) {
				if (c) {
					throw new Error('computeHmac is locked');
				}
				u = e;
			};
			Object.freeze(computeHmac);
			var l = r(9496);
			var d = r(3067);
			const p = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
			const m = Uint8Array.from({ length: 16 }, (e, t) => t);
			const g = m.map((e) => (9 * e + 5) % 16);
			let v = [m];
			let y = [g];
			for (let e = 0; e < 4; e++) for (let t of [v, y]) t.push(t[e].map((e) => p[e]));
			const w = [
				[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
				[12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
				[13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
				[14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
				[15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
			].map((e) => new Uint8Array(e));
			const _ = v.map((e, t) => e.map((e) => w[t][e]));
			const A = y.map((e, t) => e.map((e) => w[t][e]));
			const k = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]);
			const N = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]);
			const rotl = (e, t) => (e << t) | (e >>> (32 - t));
			function f(e, t, r, i) {
				if (e === 0) return t ^ r ^ i;
				else if (e === 1) return (t & r) | (~t & i);
				else if (e === 2) return (t | ~r) ^ i;
				else if (e === 3) return (t & i) | (r & ~i);
				else return t ^ (r | ~i);
			}
			const T = new Uint32Array(16);
			class RIPEMD160 extends l.D {
				constructor() {
					super(64, 20, 8, true);
					this.h0 = 1732584193 | 0;
					this.h1 = 4023233417 | 0;
					this.h2 = 2562383102 | 0;
					this.h3 = 271733878 | 0;
					this.h4 = 3285377520 | 0;
				}
				get() {
					const { h0: e, h1: t, h2: r, h3: i, h4: a } = this;
					return [e, t, r, i, a];
				}
				set(e, t, r, i, a) {
					this.h0 = e | 0;
					this.h1 = t | 0;
					this.h2 = r | 0;
					this.h3 = i | 0;
					this.h4 = a | 0;
				}
				process(e, t) {
					for (let r = 0; r < 16; r++, t += 4) T[r] = e.getUint32(t, true);
					let r = this.h0 | 0,
						i = r,
						a = this.h1 | 0,
						o = a,
						c = this.h2 | 0,
						u = c,
						l = this.h3 | 0,
						d = l,
						p = this.h4 | 0,
						m = p;
					for (let e = 0; e < 5; e++) {
						const t = 4 - e;
						const g = k[e],
							w = N[e];
						const x = v[e],
							B = y[e];
						const P = _[e],
							M = A[e];
						for (let t = 0; t < 16; t++) {
							const i = (rotl(r + f(e, a, c, l) + T[x[t]] + g, P[t]) + p) | 0;
							(r = p), (p = l), (l = rotl(c, 10) | 0), (c = a), (a = i);
						}
						for (let e = 0; e < 16; e++) {
							const r = (rotl(i + f(t, o, u, d) + T[B[e]] + w, M[e]) + m) | 0;
							(i = m), (m = d), (d = rotl(u, 10) | 0), (u = o), (o = r);
						}
					}
					this.set(
						(this.h1 + c + d) | 0,
						(this.h2 + l + m) | 0,
						(this.h3 + p + i) | 0,
						(this.h4 + r + o) | 0,
						(this.h0 + a + u) | 0
					);
				}
				roundClean() {
					T.fill(0);
				}
				destroy() {
					this.destroyed = true;
					this.buffer.fill(0);
					this.set(0, 0, 0, 0, 0);
				}
			}
			const x = (0, d.ld)(() => new RIPEMD160());
			let B = false;
			const _ripemd160 = function (e) {
				return x(e);
			};
			let P = _ripemd160;
			function ripemd160_ripemd160(e) {
				const t = (0, o.q5)(e, 'data');
				return (0, o.c$)(P(t));
			}
			ripemd160_ripemd160._ = _ripemd160;
			ripemd160_ripemd160.lock = function () {
				B = true;
			};
			ripemd160_ripemd160.register = function (e) {
				if (B) {
					throw new TypeError('ripemd160 is locked');
				}
				P = e;
			};
			Object.freeze(ripemd160_ripemd160);
			var M = r(6945);
			var C = r(1396);
			var I = r(6959);
			var O = r(5738);
			var F = r(9735);
			var D = r(8492);
			var L = r(4918);
			var U = r(572);
			var j = r(6311);
			var H = r(1418);
			var z = r(1555);
			var $ = r(6869);
			const G = "m/44'/60'/0'/0/0";
			const q = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
			const V = 2147483648;
			const W = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
			const J = '0123456789abcdef';
			function zpad(e, t) {
				let r = '';
				while (e) {
					r = J[e % 16] + r;
					e = Math.trunc(e / 16);
				}
				while (r.length < t * 2) {
					r = '0' + r;
				}
				return '0x' + r;
			}
			function encodeBase58Check(e) {
				const t = (0, o.q5)(e);
				const r = (0, o.ZG)((0, i.s)((0, i.s)(t)), 0, 4);
				const a = (0, o.xW)([t, r]);
				return (0, F.R)(a);
			}
			const Z = {};
			function ser_I(e, t, r, i) {
				const a = new Uint8Array(37);
				if (e & V) {
					(0, D.vA)(i != null, 'cannot derive child of neutered node', 'UNSUPPORTED_OPERATION', {
						operation: 'deriveChild'
					});
					a.set((0, o.q5)(i), 1);
				} else {
					a.set((0, o.q5)(r));
				}
				for (let t = 24; t >= 0; t -= 8) {
					a[33 + (t >> 3)] = (e >> (24 - t)) & 255;
				}
				const c = (0, o.q5)(computeHmac('sha512', t, a));
				return { IL: c.slice(0, 32), IR: c.slice(32) };
			}
			function derivePath(e, t) {
				const r = t.split('/');
				(0, D.MR)(r.length > 0, 'invalid path', 'path', t);
				if (r[0] === 'm') {
					(0, D.MR)(
						e.depth === 0,
						`cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${e.depth}`,
						'path',
						t
					);
					r.shift();
				}
				let i = e;
				for (let e = 0; e < r.length; e++) {
					const t = r[e];
					if (t.match(/^[0-9]+'$/)) {
						const r = parseInt(t.substring(0, t.length - 1));
						(0, D.MR)(r < V, 'invalid path index', `path[${e}]`, t);
						i = i.deriveChild(V + r);
					} else if (t.match(/^[0-9]+$/)) {
						const r = parseInt(t);
						(0, D.MR)(r < V, 'invalid path index', `path[${e}]`, t);
						i = i.deriveChild(r);
					} else {
						(0, D.MR)(false, 'invalid path component', `path[${e}]`, t);
					}
				}
				return i;
			}
			class HDNodeWallet extends H.L {
				publicKey;
				fingerprint;
				parentFingerprint;
				mnemonic;
				chainCode;
				path;
				index;
				depth;
				constructor(e, t, r, a, c, u, l, d, p) {
					super(t, p);
					(0, D.gk)(e, Z, 'HDNodeWallet');
					(0, L.n)(this, { publicKey: t.compressedPublicKey });
					const m = (0, o.ZG)(ripemd160_ripemd160((0, i.s)(this.publicKey)), 0, 4);
					(0, L.n)(this, {
						parentFingerprint: r,
						fingerprint: m,
						chainCode: a,
						path: c,
						index: u,
						depth: l
					});
					(0, L.n)(this, { mnemonic: d });
				}
				connect(e) {
					return new HDNodeWallet(
						Z,
						this.signingKey,
						this.parentFingerprint,
						this.chainCode,
						this.path,
						this.index,
						this.depth,
						this.mnemonic,
						e
					);
				}
				#St() {
					const e = { address: this.address, privateKey: this.privateKey };
					const t = this.mnemonic;
					if (this.path && t && t.wordlist.locale === 'en' && t.password === '') {
						e.mnemonic = { path: this.path, locale: 'en', entropy: t.entropy };
					}
					return e;
				}
				async encrypt(e, t) {
					return await (0, $.Ej)(this.#St(), e, { progressCallback: t });
				}
				encryptSync(e) {
					return (0, $.pv)(this.#St(), e);
				}
				get extendedKey() {
					(0, D.vA)(this.depth < 256, 'Depth too deep', 'UNSUPPORTED_OPERATION', {
						operation: 'extendedKey'
					});
					return encodeBase58Check(
						(0, o.xW)([
							'0x0488ADE4',
							zpad(this.depth, 1),
							this.parentFingerprint,
							zpad(this.index, 4),
							this.chainCode,
							(0, o.xW)(['0x00', this.privateKey])
						])
					);
				}
				hasPath() {
					return this.path != null;
				}
				neuter() {
					return new HDNodeVoidWallet(
						Z,
						this.address,
						this.publicKey,
						this.parentFingerprint,
						this.chainCode,
						this.path,
						this.index,
						this.depth,
						this.provider
					);
				}
				deriveChild(e) {
					const t = (0, U.WZ)(e, 'index');
					(0, D.MR)(t <= 4294967295, 'invalid index', 'index', t);
					let r = this.path;
					if (r) {
						r += '/' + (t & ~V);
						if (t & V) {
							r += "'";
						}
					}
					const { IR: i, IL: a } = ser_I(t, this.chainCode, this.publicKey, this.privateKey);
					const c = new M.h((0, U.up)(((0, U.Dg)(a) + BigInt(this.privateKey)) % W, 32));
					return new HDNodeWallet(
						Z,
						c,
						this.fingerprint,
						(0, o.c$)(i),
						r,
						t,
						this.depth + 1,
						this.mnemonic,
						this.provider
					);
				}
				derivePath(e) {
					return derivePath(this, e);
				}
				static #kt(e, t) {
					(0, D.MR)((0, o.f)(e), 'invalid seed', 'seed', '[REDACTED]');
					const r = (0, o.q5)(e, 'seed');
					(0, D.MR)(r.length >= 16 && r.length <= 64, 'invalid seed', 'seed', '[REDACTED]');
					const i = (0, o.q5)(computeHmac('sha512', q, r));
					const a = new M.h((0, o.c$)(i.slice(0, 32)));
					return new HDNodeWallet(Z, a, '0x00000000', (0, o.c$)(i.slice(32)), 'm', 0, 0, t, null);
				}
				static fromExtendedKey(e) {
					const t = (0, U.c4)((0, F.H)(e));
					(0, D.MR)(
						t.length === 82 || encodeBase58Check(t.slice(0, 78)) === e,
						'invalid extended key',
						'extendedKey',
						'[ REDACTED ]'
					);
					const r = t[4];
					const i = (0, o.c$)(t.slice(5, 9));
					const a = parseInt((0, o.c$)(t.slice(9, 13)).substring(2), 16);
					const c = (0, o.c$)(t.slice(13, 45));
					const u = t.slice(45, 78);
					switch ((0, o.c$)(t.slice(0, 4))) {
						case '0x0488b21e':
						case '0x043587cf': {
							const e = (0, o.c$)(u);
							return new HDNodeVoidWallet(Z, (0, O.K)(e), e, i, c, null, a, r, null);
						}
						case '0x0488ade4':
						case '0x04358394 ':
							if (u[0] !== 0) {
								break;
							}
							return new HDNodeWallet(Z, new M.h(u.slice(1)), i, c, null, a, r, null, null);
					}
					(0, D.MR)(false, 'invalid extended key prefix', 'extendedKey', '[ REDACTED ]');
				}
				static createRandom(e, t, r) {
					if (e == null) {
						e = '';
					}
					if (t == null) {
						t = G;
					}
					if (r == null) {
						r = j.U.wordlist();
					}
					const i = z.v.fromEntropy((0, C.p)(16), e, r);
					return HDNodeWallet.#kt(i.computeSeed(), i).derivePath(t);
				}
				static fromMnemonic(e, t) {
					if (!t) {
						t = G;
					}
					return HDNodeWallet.#kt(e.computeSeed(), e).derivePath(t);
				}
				static fromPhrase(e, t, r, i) {
					if (t == null) {
						t = '';
					}
					if (r == null) {
						r = G;
					}
					if (i == null) {
						i = j.U.wordlist();
					}
					const a = z.v.fromPhrase(e, t, i);
					return HDNodeWallet.#kt(a.computeSeed(), a).derivePath(r);
				}
				static fromSeed(e) {
					return HDNodeWallet.#kt(e, null);
				}
			}
			class HDNodeVoidWallet extends I.J {
				publicKey;
				fingerprint;
				parentFingerprint;
				chainCode;
				path;
				index;
				depth;
				constructor(e, t, r, a, c, u, l, d, p) {
					super(t, p);
					(0, D.gk)(e, Z, 'HDNodeVoidWallet');
					(0, L.n)(this, { publicKey: r });
					const m = (0, o.ZG)(ripemd160_ripemd160((0, i.s)(r)), 0, 4);
					(0, L.n)(this, {
						publicKey: r,
						fingerprint: m,
						parentFingerprint: a,
						chainCode: c,
						path: u,
						index: l,
						depth: d
					});
				}
				connect(e) {
					return new HDNodeVoidWallet(
						Z,
						this.address,
						this.publicKey,
						this.parentFingerprint,
						this.chainCode,
						this.path,
						this.index,
						this.depth,
						e
					);
				}
				get extendedKey() {
					(0, D.vA)(this.depth < 256, 'Depth too deep', 'UNSUPPORTED_OPERATION', {
						operation: 'extendedKey'
					});
					return encodeBase58Check(
						(0, o.xW)([
							'0x0488B21E',
							zpad(this.depth, 1),
							this.parentFingerprint,
							zpad(this.index, 4),
							this.chainCode,
							this.publicKey
						])
					);
				}
				hasPath() {
					return this.path != null;
				}
				deriveChild(e) {
					const t = (0, U.WZ)(e, 'index');
					(0, D.MR)(t <= 4294967295, 'invalid index', 'index', t);
					let r = this.path;
					if (r) {
						r += '/' + (t & ~V);
						if (t & V) {
							r += "'";
						}
					}
					const { IR: i, IL: a } = ser_I(t, this.chainCode, this.publicKey, null);
					const c = M.h.addPoints(a, this.publicKey, true);
					const u = (0, O.K)(c);
					return new HDNodeVoidWallet(
						Z,
						u,
						c,
						this.fingerprint,
						(0, o.c$)(i),
						r,
						t,
						this.depth + 1,
						this.provider
					);
				}
				derivePath(e) {
					return derivePath(this, e);
				}
			}
			function getAccountPath(e) {
				const t = getNumber(e, 'index');
				assertArgument(t >= 0 && t < V, 'invalid account index', 'index', t);
				return `m/44'/60'/${t}'/0/0`;
			}
			function getIndexedAccountPath(e) {
				const t = getNumber(e, 'index');
				assertArgument(t >= 0 && t < V, 'invalid account index', 'index', t);
				return `m/44'/60'/0'/0/${t}`;
			}
		},
		6869: (e, t, r) => {
			'use strict';
			r.d(t, {
				wb: () => decryptKeystoreJson,
				NT: () => decryptKeystoreJsonSync,
				Ej: () => encryptKeystoreJson,
				pv: () => encryptKeystoreJsonSync,
				ze: () => isKeystoreJson
			});
			var i = r(4067);
			var a = r(6686);
			var o = r(822);
			var c = r(1950);
			var u = r(6638);
			var l = r(330);
			var d = r(9584);
			var p = r(3067);
			const rotl = (e, t) => (e << t) | (e >>> (32 - t));
			function XorAndSalsa(e, t, r, i, a, o) {
				let c = e[t++] ^ r[i++],
					u = e[t++] ^ r[i++];
				let l = e[t++] ^ r[i++],
					d = e[t++] ^ r[i++];
				let p = e[t++] ^ r[i++],
					m = e[t++] ^ r[i++];
				let g = e[t++] ^ r[i++],
					v = e[t++] ^ r[i++];
				let y = e[t++] ^ r[i++],
					w = e[t++] ^ r[i++];
				let _ = e[t++] ^ r[i++],
					A = e[t++] ^ r[i++];
				let k = e[t++] ^ r[i++],
					N = e[t++] ^ r[i++];
				let T = e[t++] ^ r[i++],
					x = e[t++] ^ r[i++];
				let B = c,
					P = u,
					M = l,
					C = d,
					I = p,
					O = m,
					F = g,
					D = v,
					L = y,
					U = w,
					j = _,
					H = A,
					z = k,
					$ = N,
					G = T,
					q = x;
				for (let e = 0; e < 8; e += 2) {
					I ^= rotl((B + z) | 0, 7);
					L ^= rotl((I + B) | 0, 9);
					z ^= rotl((L + I) | 0, 13);
					B ^= rotl((z + L) | 0, 18);
					U ^= rotl((O + P) | 0, 7);
					$ ^= rotl((U + O) | 0, 9);
					P ^= rotl(($ + U) | 0, 13);
					O ^= rotl((P + $) | 0, 18);
					G ^= rotl((j + F) | 0, 7);
					M ^= rotl((G + j) | 0, 9);
					F ^= rotl((M + G) | 0, 13);
					j ^= rotl((F + M) | 0, 18);
					C ^= rotl((q + H) | 0, 7);
					D ^= rotl((C + q) | 0, 9);
					H ^= rotl((D + C) | 0, 13);
					q ^= rotl((H + D) | 0, 18);
					P ^= rotl((B + C) | 0, 7);
					M ^= rotl((P + B) | 0, 9);
					C ^= rotl((M + P) | 0, 13);
					B ^= rotl((C + M) | 0, 18);
					F ^= rotl((O + I) | 0, 7);
					D ^= rotl((F + O) | 0, 9);
					I ^= rotl((D + F) | 0, 13);
					O ^= rotl((I + D) | 0, 18);
					H ^= rotl((j + U) | 0, 7);
					L ^= rotl((H + j) | 0, 9);
					U ^= rotl((L + H) | 0, 13);
					j ^= rotl((U + L) | 0, 18);
					z ^= rotl((q + G) | 0, 7);
					$ ^= rotl((z + q) | 0, 9);
					G ^= rotl(($ + z) | 0, 13);
					q ^= rotl((G + $) | 0, 18);
				}
				a[o++] = (c + B) | 0;
				a[o++] = (u + P) | 0;
				a[o++] = (l + M) | 0;
				a[o++] = (d + C) | 0;
				a[o++] = (p + I) | 0;
				a[o++] = (m + O) | 0;
				a[o++] = (g + F) | 0;
				a[o++] = (v + D) | 0;
				a[o++] = (y + L) | 0;
				a[o++] = (w + U) | 0;
				a[o++] = (_ + j) | 0;
				a[o++] = (A + H) | 0;
				a[o++] = (k + z) | 0;
				a[o++] = (N + $) | 0;
				a[o++] = (T + G) | 0;
				a[o++] = (x + q) | 0;
			}
			function BlockMix(e, t, r, i, a) {
				let o = i + 0;
				let c = i + 16 * a;
				for (let i = 0; i < 16; i++) r[c + i] = e[t + (2 * a - 1) * 16 + i];
				for (let i = 0; i < a; i++, o += 16, t += 16) {
					XorAndSalsa(r, c, e, t, r, o);
					if (i > 0) c += 16;
					XorAndSalsa(r, o, e, (t += 16), r, c);
				}
			}
			function scryptInit(e, t, r) {
				const i = (0, p.tY)({ dkLen: 32, asyncTick: 10, maxmem: 1024 ** 3 + 1024 }, r);
				const { N: a, r: o, p: c, dkLen: m, asyncTick: g, maxmem: v, onProgress: y } = i;
				(0, u.ai)(a);
				(0, u.ai)(o);
				(0, u.ai)(c);
				(0, u.ai)(m);
				(0, u.ai)(g);
				(0, u.ai)(v);
				if (y !== undefined && typeof y !== 'function')
					throw new Error('progressCb should be function');
				const w = 128 * o;
				const _ = w / 4;
				if (a <= 1 || (a & (a - 1)) !== 0 || a >= 2 ** (w / 8) || a > 2 ** 32) {
					throw new Error(
						'Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32'
					);
				}
				if (c < 0 || c > ((2 ** 32 - 1) * 32) / w) {
					throw new Error(
						'Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)'
					);
				}
				if (m < 0 || m > (2 ** 32 - 1) * 32) {
					throw new Error(
						'Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32'
					);
				}
				const A = w * (a + c);
				if (A > v) {
					throw new Error(`Scrypt: parameters too large, ${A} (128 * r * (N + p)) > ${v} (maxmem)`);
				}
				const k = (0, d.A)(l.s, e, t, { c: 1, dkLen: w * c });
				const N = (0, p.DH)(k);
				const T = (0, p.DH)(new Uint8Array(w * a));
				const x = (0, p.DH)(new Uint8Array(w));
				let blockMixCb = () => {};
				if (y) {
					const e = 2 * a * c;
					const t = Math.max(Math.floor(e / 1e4), 1);
					let r = 0;
					blockMixCb = () => {
						r++;
						if (y && (!(r % t) || r === e)) y(r / e);
					};
				}
				return {
					N: a,
					r: o,
					p: c,
					dkLen: m,
					blockSize32: _,
					V: T,
					B32: N,
					B: k,
					tmp: x,
					blockMixCb,
					asyncTick: g
				};
			}
			function scryptOutput(e, t, r, i, a) {
				const o = (0, d.A)(l.s, e, r, { c: 1, dkLen: t });
				r.fill(0);
				i.fill(0);
				a.fill(0);
				return o;
			}
			function scrypt(e, t, r) {
				const {
					N: i,
					r: a,
					p: o,
					dkLen: c,
					blockSize32: u,
					V: l,
					B32: d,
					B: p,
					tmp: m,
					blockMixCb: g
				} = scryptInit(e, t, r);
				for (let e = 0; e < o; e++) {
					const t = u * e;
					for (let e = 0; e < u; e++) l[e] = d[t + e];
					for (let e = 0, t = 0; e < i - 1; e++) {
						BlockMix(l, t, l, (t += u), a);
						g();
					}
					BlockMix(l, (i - 1) * u, d, t, a);
					g();
					for (let e = 0; e < i; e++) {
						const e = d[t + u - 16] % i;
						for (let r = 0; r < u; r++) m[r] = d[t + r] ^ l[e * u + r];
						BlockMix(m, 0, d, t, a);
						g();
					}
				}
				return scryptOutput(e, c, p, l, m);
			}
			async function scryptAsync(e, t, r) {
				const {
					N: i,
					r: a,
					p: o,
					dkLen: c,
					blockSize32: u,
					V: l,
					B32: d,
					B: m,
					tmp: g,
					blockMixCb: v,
					asyncTick: y
				} = scryptInit(e, t, r);
				for (let e = 0; e < o; e++) {
					const t = u * e;
					for (let e = 0; e < u; e++) l[e] = d[t + e];
					let r = 0;
					await (0, p.$h)(i - 1, y, () => {
						BlockMix(l, r, l, (r += u), a);
						v();
					});
					BlockMix(l, (i - 1) * u, d, t, a);
					v();
					await (0, p.$h)(i, y, () => {
						const e = d[t + u - 16] % i;
						for (let r = 0; r < u; r++) g[r] = d[t + r] ^ l[e * u + r];
						BlockMix(g, 0, d, t, a);
						v();
					});
				}
				return scryptOutput(e, c, m, l, g);
			}
			var m = r(6919);
			let g = false,
				v = false;
			const _scryptAsync = async function (e, t, r, i, a, o, c) {
				return await scryptAsync(e, t, { N: r, r: i, p: a, dkLen: o, onProgress: c });
			};
			const _scryptSync = function (e, t, r, i, a, o) {
				return scrypt(e, t, { N: r, r: i, p: a, dkLen: o });
			};
			let y = _scryptAsync;
			let w = _scryptSync;
			async function scrypt_scrypt(e, t, r, i, a, o, c) {
				const u = (0, m.q5)(e, 'passwd');
				const l = (0, m.q5)(t, 'salt');
				return (0, m.c$)(await y(u, l, r, i, a, o, c));
			}
			scrypt_scrypt._ = _scryptAsync;
			scrypt_scrypt.lock = function () {
				v = true;
			};
			scrypt_scrypt.register = function (e) {
				if (v) {
					throw new Error('scrypt is locked');
				}
				y = e;
			};
			Object.freeze(scrypt_scrypt);
			function scryptSync(e, t, r, i, a, o) {
				const c = (0, m.q5)(e, 'passwd');
				const u = (0, m.q5)(t, 'salt');
				return (0, m.c$)(w(c, u, r, i, a, o));
			}
			scryptSync._ = _scryptSync;
			scryptSync.lock = function () {
				g = true;
			};
			scryptSync.register = function (e) {
				if (g) {
					throw new Error('scryptSync is locked');
				}
				w = e;
			};
			Object.freeze(scryptSync);
			var _ = r(1396);
			var A = r(5738);
			var k = r(8492);
			function uuidV4(e) {
				const t = (0, m.q5)(e, 'randomBytes');
				t[6] = (t[6] & 15) | 64;
				t[8] = (t[8] & 63) | 128;
				const r = (0, m.c$)(t);
				return [
					r.substring(2, 10),
					r.substring(10, 14),
					r.substring(14, 18),
					r.substring(18, 22),
					r.substring(22, 34)
				].join('-');
			}
			var N = r(8442);
			var T = r(2186);
			const x = "m/44'/60'/0'/0/0";
			function isKeystoreJson(e) {
				try {
					const t = JSON.parse(e);
					const r = t.version != null ? parseInt(t.version) : 0;
					if (r === 3) {
						return true;
					}
				} catch (e) {}
				return false;
			}
			function decrypt(e, t, r) {
				const a = (0, N.F2)(e, 'crypto.cipher:string');
				if (a === 'aes-128-ctr') {
					const a = (0, N.F2)(e, 'crypto.cipherparams.iv:data!');
					const o = new i.cf(t, a);
					return (0, m.c$)(o.decrypt(r));
				}
				(0, k.vA)(false, 'unsupported cipher', 'UNSUPPORTED_OPERATION', { operation: 'decrypt' });
			}
			function getAccount(e, t) {
				const r = (0, m.q5)(t);
				const c = (0, N.F2)(e, 'crypto.ciphertext:data!');
				const u = (0, m.c$)((0, o.S)((0, m.xW)([r.slice(16, 32), c]))).substring(2);
				(0, k.MR)(
					u === (0, N.F2)(e, 'crypto.mac:string!').toLowerCase(),
					'incorrect password',
					'password',
					'[ REDACTED ]'
				);
				const l = decrypt(e, r.slice(0, 16), c);
				const d = (0, A.K)(l);
				if (e.address) {
					let t = e.address.toLowerCase();
					if (!t.startsWith('0x')) {
						t = '0x' + t;
					}
					(0, k.MR)(
						(0, a.b)(t) === d,
						'keystore address/privateKey mismatch',
						'address',
						e.address
					);
				}
				const p = { address: d, privateKey: l };
				const g = (0, N.F2)(e, 'x-ethers.version:string');
				if (g === '0.1') {
					const t = r.slice(32, 64);
					const a = (0, N.F2)(e, 'x-ethers.mnemonicCiphertext:data!');
					const o = (0, N.F2)(e, 'x-ethers.mnemonicCounter:data!');
					const c = new i.cf(t, o);
					p.mnemonic = {
						path: (0, N.F2)(e, 'x-ethers.path:string') || x,
						locale: (0, N.F2)(e, 'x-ethers.locale:string') || 'en',
						entropy: (0, m.c$)((0, m.q5)(c.decrypt(a)))
					};
				}
				return p;
			}
			function getDecryptKdfParams(e) {
				const t = (0, N.F2)(e, 'crypto.kdf:string');
				if (t && typeof t === 'string') {
					if (t.toLowerCase() === 'scrypt') {
						const r = (0, N.F2)(e, 'crypto.kdfparams.salt:data!');
						const i = (0, N.F2)(e, 'crypto.kdfparams.n:int!');
						const a = (0, N.F2)(e, 'crypto.kdfparams.r:int!');
						const o = (0, N.F2)(e, 'crypto.kdfparams.p:int!');
						(0, k.MR)(i > 0 && (i & (i - 1)) === 0, 'invalid kdf.N', 'kdf.N', i);
						(0, k.MR)(a > 0 && o > 0, 'invalid kdf', 'kdf', t);
						const c = (0, N.F2)(e, 'crypto.kdfparams.dklen:int!');
						(0, k.MR)(c === 32, 'invalid kdf.dklen', 'kdf.dflen', c);
						return { name: 'scrypt', salt: r, N: i, r: a, p: o, dkLen: 64 };
					} else if (t.toLowerCase() === 'pbkdf2') {
						const t = (0, N.F2)(e, 'crypto.kdfparams.salt:data!');
						const r = (0, N.F2)(e, 'crypto.kdfparams.prf:string!');
						const i = r.split('-').pop();
						(0, k.MR)(i === 'sha256' || i === 'sha512', 'invalid kdf.pdf', 'kdf.pdf', r);
						const a = (0, N.F2)(e, 'crypto.kdfparams.c:int!');
						const o = (0, N.F2)(e, 'crypto.kdfparams.dklen:int!');
						(0, k.MR)(o === 32, 'invalid kdf.dklen', 'kdf.dklen', o);
						return { name: 'pbkdf2', salt: t, count: a, dkLen: o, algorithm: i };
					}
				}
				(0, k.MR)(false, 'unsupported key-derivation function', 'kdf', t);
			}
			function decryptKeystoreJsonSync(e, t) {
				const r = JSON.parse(e);
				const i = (0, N.Qq)(t);
				const a = getDecryptKdfParams(r);
				if (a.name === 'pbkdf2') {
					const { salt: e, count: t, dkLen: o, algorithm: u } = a;
					const l = (0, c.A)(i, e, t, o, u);
					return getAccount(r, l);
				}
				(0, k.vA)(a.name === 'scrypt', 'cannot be reached', 'UNKNOWN_ERROR', { params: a });
				const { salt: o, N: u, r: l, p: d, dkLen: p } = a;
				const m = scryptSync(i, o, u, l, d, p);
				return getAccount(r, m);
			}
			function stall(e) {
				return new Promise((t) => {
					setTimeout(() => {
						t();
					}, e);
				});
			}
			async function decryptKeystoreJson(e, t, r) {
				const i = JSON.parse(e);
				const a = (0, N.Qq)(t);
				const o = getDecryptKdfParams(i);
				if (o.name === 'pbkdf2') {
					if (r) {
						r(0);
						await stall(0);
					}
					const { salt: e, count: t, dkLen: u, algorithm: l } = o;
					const d = (0, c.A)(a, e, t, u, l);
					if (r) {
						r(1);
						await stall(0);
					}
					return getAccount(i, d);
				}
				(0, k.vA)(o.name === 'scrypt', 'cannot be reached', 'UNKNOWN_ERROR', { params: o });
				const { salt: u, N: l, r: d, p, dkLen: m } = o;
				const g = await scrypt_scrypt(a, u, l, d, p, m, r);
				return getAccount(i, g);
			}
			function getEncryptKdfParams(e) {
				const t = e.salt != null ? (0, m.q5)(e.salt, 'options.salt') : (0, _.p)(32);
				let r = 1 << 17,
					i = 8,
					a = 1;
				if (e.scrypt) {
					if (e.scrypt.N) {
						r = e.scrypt.N;
					}
					if (e.scrypt.r) {
						i = e.scrypt.r;
					}
					if (e.scrypt.p) {
						a = e.scrypt.p;
					}
				}
				(0, k.MR)(
					typeof r === 'number' &&
						r > 0 &&
						Number.isSafeInteger(r) &&
						(BigInt(r) & BigInt(r - 1)) === BigInt(0),
					'invalid scrypt N parameter',
					'options.N',
					r
				);
				(0, k.MR)(
					typeof i === 'number' && i > 0 && Number.isSafeInteger(i),
					'invalid scrypt r parameter',
					'options.r',
					i
				);
				(0, k.MR)(
					typeof a === 'number' && a > 0 && Number.isSafeInteger(a),
					'invalid scrypt p parameter',
					'options.p',
					a
				);
				return { name: 'scrypt', dkLen: 32, salt: t, N: r, r: i, p: a };
			}
			function _encryptKeystore(e, t, r, a) {
				const c = (0, m.q5)(r.privateKey, 'privateKey');
				const u = a.iv != null ? (0, m.q5)(a.iv, 'options.iv') : (0, _.p)(16);
				(0, k.MR)(u.length === 16, 'invalid options.iv length', 'options.iv', a.iv);
				const l = a.uuid != null ? (0, m.q5)(a.uuid, 'options.uuid') : (0, _.p)(16);
				(0, k.MR)(l.length === 16, 'invalid options.uuid length', 'options.uuid', a.iv);
				const d = e.slice(0, 16);
				const p = e.slice(16, 32);
				const g = new i.cf(d, u);
				const v = (0, m.q5)(g.encrypt(c));
				const y = (0, o.S)((0, m.xW)([p, v]));
				const w = {
					address: r.address.substring(2).toLowerCase(),
					id: uuidV4(l),
					version: 3,
					Crypto: {
						cipher: 'aes-128-ctr',
						cipherparams: { iv: (0, m.c$)(u).substring(2) },
						ciphertext: (0, m.c$)(v).substring(2),
						kdf: 'scrypt',
						kdfparams: { salt: (0, m.c$)(t.salt).substring(2), n: t.N, dklen: 32, p: t.p, r: t.r },
						mac: y.substring(2)
					}
				};
				if (r.mnemonic) {
					const t = a.client != null ? a.client : `ethers/${T.r}`;
					const o = r.mnemonic.path || x;
					const c = r.mnemonic.locale || 'en';
					const u = e.slice(32, 64);
					const l = (0, m.q5)(r.mnemonic.entropy, 'account.mnemonic.entropy');
					const d = (0, _.p)(16);
					const p = new i.cf(u, d);
					const g = (0, m.q5)(p.encrypt(l));
					const v = new Date();
					const y =
						v.getUTCFullYear() +
						'-' +
						(0, N.Sp)(v.getUTCMonth() + 1, 2) +
						'-' +
						(0, N.Sp)(v.getUTCDate(), 2) +
						'T' +
						(0, N.Sp)(v.getUTCHours(), 2) +
						'-' +
						(0, N.Sp)(v.getUTCMinutes(), 2) +
						'-' +
						(0, N.Sp)(v.getUTCSeconds(), 2) +
						'.0Z';
					const A = 'UTC--' + y + '--' + w.address;
					w['x-ethers'] = {
						client: t,
						gethFilename: A,
						path: o,
						locale: c,
						mnemonicCounter: (0, m.c$)(d).substring(2),
						mnemonicCiphertext: (0, m.c$)(g).substring(2),
						version: '0.1'
					};
				}
				return JSON.stringify(w);
			}
			function encryptKeystoreJsonSync(e, t, r) {
				if (r == null) {
					r = {};
				}
				const i = (0, N.Qq)(t);
				const a = getEncryptKdfParams(r);
				const o = scryptSync(i, a.salt, a.N, a.r, a.p, 64);
				return _encryptKeystore((0, m.q5)(o), a, e, r);
			}
			async function encryptKeystoreJson(e, t, r) {
				if (r == null) {
					r = {};
				}
				const i = (0, N.Qq)(t);
				const a = getEncryptKdfParams(r);
				const o = await scrypt_scrypt(i, a.salt, a.N, a.r, a.p, 64, r.progressCallback);
				return _encryptKeystore((0, m.q5)(o), a, e, r);
			}
		},
		1555: (e, t, r) => {
			'use strict';
			r.d(t, { v: () => Mnemonic });
			var i = r(4931);
			var a = r(1950);
			var o = r(8492);
			var c = r(6919);
			var u = r(4918);
			var l = r(7756);
			var d = r(6311);
			function getUpperMask(e) {
				return (((1 << e) - 1) << (8 - e)) & 255;
			}
			function getLowerMask(e) {
				return ((1 << e) - 1) & 255;
			}
			function mnemonicToEntropy(e, t) {
				(0, o.SP)('NFKD');
				if (t == null) {
					t = d.U.wordlist();
				}
				const r = t.split(e);
				(0, o.MR)(
					r.length % 3 === 0 && r.length >= 12 && r.length <= 24,
					'invalid mnemonic length',
					'mnemonic',
					'[ REDACTED ]'
				);
				const a = new Uint8Array(Math.ceil((11 * r.length) / 8));
				let u = 0;
				for (let e = 0; e < r.length; e++) {
					let i = t.getWordIndex(r[e].normalize('NFKD'));
					(0, o.MR)(i >= 0, `invalid mnemonic word at index ${e}`, 'mnemonic', '[ REDACTED ]');
					for (let e = 0; e < 11; e++) {
						if (i & (1 << (10 - e))) {
							a[u >> 3] |= 1 << (7 - (u % 8));
						}
						u++;
					}
				}
				const l = (32 * r.length) / 3;
				const p = r.length / 3;
				const m = getUpperMask(p);
				const g = (0, c.q5)((0, i.s)(a.slice(0, l / 8)))[0] & m;
				(0, o.MR)(
					g === (a[a.length - 1] & m),
					'invalid mnemonic checksum',
					'mnemonic',
					'[ REDACTED ]'
				);
				return (0, c.c$)(a.slice(0, l / 8));
			}
			function entropyToMnemonic(e, t) {
				(0, o.MR)(
					e.length % 4 === 0 && e.length >= 16 && e.length <= 32,
					'invalid entropy size',
					'entropy',
					'[ REDACTED ]'
				);
				if (t == null) {
					t = d.U.wordlist();
				}
				const r = [0];
				let a = 11;
				for (let t = 0; t < e.length; t++) {
					if (a > 8) {
						r[r.length - 1] <<= 8;
						r[r.length - 1] |= e[t];
						a -= 8;
					} else {
						r[r.length - 1] <<= a;
						r[r.length - 1] |= e[t] >> (8 - a);
						r.push(e[t] & getLowerMask(8 - a));
						a += 3;
					}
				}
				const c = e.length / 4;
				const u = parseInt((0, i.s)(e).substring(2, 4), 16) & getUpperMask(c);
				r[r.length - 1] <<= c;
				r[r.length - 1] |= u >> (8 - c);
				return t.join(r.map((e) => t.getWord(e)));
			}
			const p = {};
			class Mnemonic {
				phrase;
				password;
				wordlist;
				entropy;
				constructor(e, t, r, i, a) {
					if (i == null) {
						i = '';
					}
					if (a == null) {
						a = d.U.wordlist();
					}
					(0, o.gk)(e, p, 'Mnemonic');
					(0, u.n)(this, { phrase: r, password: i, wordlist: a, entropy: t });
				}
				computeSeed() {
					const e = (0, l.YW)('mnemonic' + this.password, 'NFKD');
					return (0, a.A)((0, l.YW)(this.phrase, 'NFKD'), e, 2048, 64, 'sha512');
				}
				static fromPhrase(e, t, r) {
					const i = mnemonicToEntropy(e, r);
					e = entropyToMnemonic((0, c.q5)(i), r);
					return new Mnemonic(p, i, e, t, r);
				}
				static fromEntropy(e, t, r) {
					const i = (0, c.q5)(e, 'entropy');
					const a = entropyToMnemonic(i, r);
					return new Mnemonic(p, (0, c.c$)(i), a, t, r);
				}
				static entropyToPhrase(e, t) {
					const r = (0, c.q5)(e, 'entropy');
					return entropyToMnemonic(r, t);
				}
				static phraseToEntropy(e, t) {
					return mnemonicToEntropy(e, t);
				}
				static isValidMnemonic(e, t) {
					try {
						mnemonicToEntropy(e, t);
						return true;
					} catch (e) {}
					return false;
				}
			}
		},
		8442: (e, t, r) => {
			'use strict';
			r.d(t, { F2: () => spelunk, Qq: () => getPassword, Sp: () => zpad, m0: () => looseArrayify });
			var i = r(6919);
			var a = r(7756);
			var o = r(8492);
			function looseArrayify(e) {
				if (typeof e === 'string' && !e.startsWith('0x')) {
					e = '0x' + e;
				}
				return (0, i.Lm)(e);
			}
			function zpad(e, t) {
				e = String(e);
				while (e.length < t) {
					e = '0' + e;
				}
				return e;
			}
			function getPassword(e) {
				if (typeof e === 'string') {
					return (0, a.YW)(e, 'NFKC');
				}
				return (0, i.Lm)(e);
			}
			function spelunk(e, t) {
				const r = t.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
				(0, o.MR)(r != null, 'invalid path', 'path', t);
				const i = r[1];
				const a = r[3];
				const c = r[4] === '!';
				let u = e;
				for (const e of i.toLowerCase().split('.')) {
					if (Array.isArray(u)) {
						if (!e.match(/^[0-9]+$/)) {
							break;
						}
						u = u[parseInt(e)];
					} else if (typeof u === 'object') {
						let t = null;
						for (const r in u) {
							if (r.toLowerCase() === e) {
								t = u[r];
								break;
							}
						}
						u = t;
					} else {
						u = null;
					}
					if (u == null) {
						break;
					}
				}
				(0, o.MR)(!c || u != null, 'missing required value', 'path', i);
				if (a && u != null) {
					if (a === 'int') {
						if (typeof u === 'string' && u.match(/^-?[0-9]+$/)) {
							return parseInt(u);
						} else if (Number.isSafeInteger(u)) {
							return u;
						}
					}
					if (a === 'number') {
						if (typeof u === 'string' && u.match(/^-?[0-9.]*$/)) {
							return parseFloat(u);
						}
					}
					if (a === 'data') {
						if (typeof u === 'string') {
							return looseArrayify(u);
						}
					}
					if (a === 'array' && Array.isArray(u)) {
						return u;
					}
					if (a === typeof u) {
						return u;
					}
					(0, o.MR)(false, `wrong type found for ${a} `, 'path', i);
				}
				return u;
			}
		},
		6543: (e, t, r) => {
			'use strict';
			r.d(t, { u: () => Wallet });
			var i = r(6945);
			var a = r(8492);
			var o = r(1418);
			var c = r(7714);
			var u = r(4067);
			var l = r(6686);
			var d = r(1950);
			var p = r(8425);
			var m = r(6919);
			var g = r(8442);
			function isCrowdsaleJson(e) {
				try {
					const t = JSON.parse(e);
					if (t.encseed) {
						return true;
					}
				} catch (e) {}
				return false;
			}
			function decryptCrowdsaleJson(e, t) {
				const r = JSON.parse(e);
				const i = (0, g.Qq)(t);
				const o = (0, l.b)((0, g.F2)(r, 'ethaddr:string!'));
				const c = (0, g.m0)((0, g.F2)(r, 'encseed:string!'));
				(0, a.MR)(c && c.length % 16 === 0, 'invalid encseed', 'json', e);
				const v = (0, m.q5)((0, d.A)(i, i, 2e3, 32, 'sha256')).slice(0, 16);
				const y = c.slice(0, 16);
				const w = c.slice(16);
				const _ = new u.Xp(v, y);
				const A = (0, u.ny)((0, m.q5)(_.decrypt(w)));
				let k = '';
				for (let e = 0; e < A.length; e++) {
					k += String.fromCharCode(A[e]);
				}
				return { address: o, privateKey: (0, p.id)(k) };
			}
			var v = r(6869);
			var y = r(1555);
			function stall(e) {
				return new Promise((t) => {
					setTimeout(() => {
						t();
					}, e);
				});
			}
			class Wallet extends o.L {
				constructor(e, t) {
					if (typeof e === 'string' && !e.startsWith('0x')) {
						e = '0x' + e;
					}
					let r = typeof e === 'string' ? new i.h(e) : e;
					super(r, t);
				}
				connect(e) {
					return new Wallet(this.signingKey, e);
				}
				async encrypt(e, t) {
					const r = { address: this.address, privateKey: this.privateKey };
					return await (0, v.Ej)(r, e, { progressCallback: t });
				}
				encryptSync(e) {
					const t = { address: this.address, privateKey: this.privateKey };
					return (0, v.pv)(t, e);
				}
				static #Nt(e) {
					(0, a.MR)(e, 'invalid JSON wallet', 'json', '[ REDACTED ]');
					if ('mnemonic' in e && e.mnemonic && e.mnemonic.locale === 'en') {
						const t = y.v.fromEntropy(e.mnemonic.entropy);
						const r = c.QX.fromMnemonic(t, e.mnemonic.path);
						if (r.address === e.address && r.privateKey === e.privateKey) {
							return r;
						}
						console.log(
							'WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key'
						);
					}
					const t = new Wallet(e.privateKey);
					(0, a.MR)(t.address === e.address, 'address/privateKey mismatch', 'json', '[ REDACTED ]');
					return t;
				}
				static async fromEncryptedJson(e, t, r) {
					let i = null;
					if ((0, v.ze)(e)) {
						i = await (0, v.wb)(e, t, r);
					} else if (isCrowdsaleJson(e)) {
						if (r) {
							r(0);
							await stall(0);
						}
						i = decryptCrowdsaleJson(e, t);
						if (r) {
							r(1);
							await stall(0);
						}
					}
					return Wallet.#Nt(i);
				}
				static fromEncryptedJsonSync(e, t) {
					let r = null;
					if ((0, v.ze)(e)) {
						r = (0, v.NT)(e, t);
					} else if (isCrowdsaleJson(e)) {
						r = decryptCrowdsaleJson(e, t);
					} else {
						(0, a.MR)(false, 'invalid JSON wallet', 'json', '[ REDACTED ]');
					}
					return Wallet.#Nt(r);
				}
				static createRandom(e) {
					const t = c.QX.createRandom();
					if (e) {
						return t.connect(e);
					}
					return t;
				}
				static fromPhrase(e, t) {
					const r = c.QX.fromPhrase(e);
					if (t) {
						return r.connect(t);
					}
					return r;
				}
			}
		},
		6311: (e, t, r) => {
			'use strict';
			r.d(t, { U: () => LangEn });
			var i = r(8425);
			var a = r(8492);
			const o = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
			const c = /^[a-z]*$/i;
			function unfold(e, t) {
				let r = 97;
				return e.reduce((e, i) => {
					if (i === t) {
						r++;
					} else if (i.match(c)) {
						e.push(String.fromCharCode(r) + i);
					} else {
						r = 97;
						e.push(i);
					}
					return e;
				}, []);
			}
			function decode(e, t) {
				for (let r = o.length - 1; r >= 0; r--) {
					e = e.split(o[r]).join(t.substring(2 * r, 2 * r + 2));
				}
				const r = [];
				const i = e.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (e, t, i, a) => {
					if (i) {
						for (let e = parseInt(i); e >= 0; e--) {
							r.push(';');
						}
					} else {
						r.push(t.toLowerCase());
					}
					return '';
				});
				if (i) {
					throw new Error(`leftovers: ${JSON.stringify(i)}`);
				}
				return unfold(unfold(r, ';'), ':');
			}
			function decodeOwl(e) {
				(0, a.MR)(e[0] === '0', 'unsupported auwl data', 'data', e);
				return decode(e.substring(1 + 2 * o.length), e.substring(1, 1 + 2 * o.length));
			}
			var u = r(4918);
			class Wordlist {
				locale;
				constructor(e) {
					(0, u.n)(this, { locale: e });
				}
				split(e) {
					return e.toLowerCase().split(/\s+/g);
				}
				join(e) {
					return e.join(' ');
				}
			}
			class WordlistOwl extends Wordlist {
				#r;
				#Tt;
				constructor(e, t, r) {
					super(e);
					this.#r = t;
					this.#Tt = r;
					this.#xt = null;
				}
				get _data() {
					return this.#r;
				}
				_decodeWords() {
					return decodeOwl(this.#r);
				}
				#xt;
				#Bt() {
					if (this.#xt == null) {
						const e = this._decodeWords();
						const t = (0, i.id)(e.join('\n') + '\n');
						if (t !== this.#Tt) {
							throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
						}
						this.#xt = e;
					}
					return this.#xt;
				}
				getWord(e) {
					const t = this.#Bt();
					(0, a.MR)(e >= 0 && e < t.length, `invalid word index: ${e}`, 'index', e);
					return t[e];
				}
				getWordIndex(e) {
					return this.#Bt().indexOf(e);
				}
			}
			const l =
				"0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
			const d = '0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60';
			let p = null;
			class LangEn extends WordlistOwl {
				constructor() {
					super('en', l, d);
				}
				static wordlist() {
					if (p == null) {
						p = new LangEn();
					}
					return p;
				}
			}
		},
		4261: (e, t, r) => {
			'use strict';
			r.d(t, { A: () => g });
			function listCacheClear() {
				this.__data__ = [];
				this.size = 0;
			}
			const i = listCacheClear;
			var a = r(4336);
			function assocIndexOf(e, t) {
				var r = e.length;
				while (r--) {
					if ((0, a.A)(e[r][0], t)) {
						return r;
					}
				}
				return -1;
			}
			const o = assocIndexOf;
			var c = Array.prototype;
			var u = c.splice;
			function listCacheDelete(e) {
				var t = this.__data__,
					r = o(t, e);
				if (r < 0) {
					return false;
				}
				var i = t.length - 1;
				if (r == i) {
					t.pop();
				} else {
					u.call(t, r, 1);
				}
				--this.size;
				return true;
			}
			const l = listCacheDelete;
			function listCacheGet(e) {
				var t = this.__data__,
					r = o(t, e);
				return r < 0 ? undefined : t[r][1];
			}
			const d = listCacheGet;
			function listCacheHas(e) {
				return o(this.__data__, e) > -1;
			}
			const p = listCacheHas;
			function listCacheSet(e, t) {
				var r = this.__data__,
					i = o(r, e);
				if (i < 0) {
					++this.size;
					r.push([e, t]);
				} else {
					r[i][1] = t;
				}
				return this;
			}
			const m = listCacheSet;
			function ListCache(e) {
				var t = -1,
					r = e == null ? 0 : e.length;
				this.clear();
				while (++t < r) {
					var i = e[t];
					this.set(i[0], i[1]);
				}
			}
			ListCache.prototype.clear = i;
			ListCache.prototype['delete'] = l;
			ListCache.prototype.get = d;
			ListCache.prototype.has = p;
			ListCache.prototype.set = m;
			const g = ListCache;
		},
		2615: (e, t, r) => {
			'use strict';
			r.d(t, { A: () => c });
			var i = r(9130);
			var a = r(3077);
			var o = (0, i.A)(a.A, 'Map');
			const c = o;
		},
		4794: (e, t, r) => {
			'use strict';
			r.d(t, { A: () => O });
			var i = r(9130);
			var a = (0, i.A)(Object, 'create');
			const o = a;
			function hashClear() {
				this.__data__ = o ? o(null) : {};
				this.size = 0;
			}
			const c = hashClear;
			function hashDelete(e) {
				var t = this.has(e) && delete this.__data__[e];
				this.size -= t ? 1 : 0;
				return t;
			}
			const u = hashDelete;
			var l = '__lodash_hash_undefined__';
			var d = Object.prototype;
			var p = d.hasOwnProperty;
			function hashGet(e) {
				var t = this.__data__;
				if (o) {
					var r = t[e];
					return r === l ? undefined : r;
				}
				return p.call(t, e) ? t[e] : undefined;
			}
			const m = hashGet;
			var g = Object.prototype;
			var v = g.hasOwnProperty;
			function hashHas(e) {
				var t = this.__data__;
				return o ? t[e] !== undefined : v.call(t, e);
			}
			const y = hashHas;
			var w = '__lodash_hash_undefined__';
			function hashSet(e, t) {
				var r = this.__data__;
				this.size += this.has(e) ? 0 : 1;
				r[e] = o && t === undefined ? w : t;
				return this;
			}
			const _ = hashSet;
			function Hash(e) {
				var t = -1,
					r = e == null ? 0 : e.length;
				this.clear();
				while (++t < r) {
					var i = e[t];
					this.set(i[0], i[1]);
				}
			}
			Hash.prototype.clear = c;
			Hash.prototype['delete'] = u;
			Hash.prototype.get = m;
			Hash.prototype.has = y;
			Hash.prototype.set = _;
			const A = Hash;
			var k = r(4261);
			var N = r(2615);
			function mapCacheClear() {
				this.size = 0;
				this.__data__ = { hash: new A(), map: new (N.A || k.A)(), string: new A() };
			}
			const T = mapCacheClear;
			function isKeyable(e) {
				var t = typeof e;
				return t == 'string' || t == 'number' || t == 'symbol' || t == 'boolean'
					? e !== '__proto__'
					: e === null;
			}
			const x = isKeyable;
			function getMapData(e, t) {
				var r = e.__data__;
				return x(t) ? r[typeof t == 'string' ? 'string' : 'hash'] : r.map;
			}
			const B = getMapData;
			function mapCacheDelete(e) {
				var t = B(this, e)['delete'](e);
				this.size -= t ? 1 : 0;
				return t;
			}
			const P = mapCacheDelete;
			function mapCacheGet(e) {
				return B(this, e).get(e);
			}
			const M = mapCacheGet;
			function mapCacheHas(e) {
				return B(this, e).has(e);
			}
			const C = mapCacheHas;
			function mapCacheSet(e, t) {
				var r = B(this, e),
					i = r.size;
				r.set(e, t);
				this.size += r.size == i ? 0 : 1;
				return this;
			}
			const I = mapCacheSet;
			function MapCache(e) {
				var t = -1,
					r = e == null ? 0 : e.length;
				this.clear();
				while (++t < r) {
					var i = e[t];
					this.set(i[0], i[1]);
				}
			}
			MapCache.prototype.clear = T;
			MapCache.prototype['delete'] = P;
			MapCache.prototype.get = M;
			MapCache.prototype.has = C;
			MapCache.prototype.set = I;
			const O = MapCache;
		},
		4633: (e, t, r) => {
			'use strict';
			r.d(t, { A: () => o });
			var i = r(3077);
			var a = i.A.Symbol;
			const o = a;
		},
		4855: (e, t, r) => {
			'use strict';
			r.d(t, { A: () => w });
			var i = r(4633);
			var a = Object.prototype;
			var o = a.hasOwnProperty;
			var c = a.toString;
			var u = i.A ? i.A.toStringTag : undefined;
			function getRawTag(e) {
				var t = o.call(e, u),
					r = e[u];
				try {
					e[u] = undefined;
					var i = true;
				} catch (e) {}
				var a = c.call(e);
				if (i) {
					if (t) {
						e[u] = r;
					} else {
						delete e[u];
					}
				}
				return a;
			}
			const l = getRawTag;
			var d = Object.prototype;
			var p = d.toString;
			function objectToString(e) {
				return p.call(e);
			}
			const m = objectToString;
			var g = '[object Null]',
				v = '[object Undefined]';
			var y = i.A ? i.A.toStringTag : undefined;
			function baseGetTag(e) {
				if (e == null) {
					return e === undefined ? v : g;
				}
				return y && y in Object(e) ? l(e) : m(e);
			}
			const w = baseGetTag;
		},
		2752: (e, t, r) => {
			'use strict';
			r.d(t, { A: () => a });
			var i = typeof global == 'object' && global && global.Object === Object && global;
			const a = i;
		},
		9130: (e, t, r) => {
			'use strict';
			r.d(t, { A: () => T });
			var i = r(6770);
			var a = r(3077);
			var o = a.A['__core-js_shared__'];
			const c = o;
			var u = (function () {
				var e = /[^.]+$/.exec((c && c.keys && c.keys.IE_PROTO) || '');
				return e ? 'Symbol(src)_1.' + e : '';
			})();
			function isMasked(e) {
				return !!u && u in e;
			}
			const l = isMasked;
			var d = r(997);
			var p = r(1465);
			var m = /[\\^$.*+?()[\]{}|]/g;
			var g = /^\[object .+?Constructor\]$/;
			var v = Function.prototype,
				y = Object.prototype;
			var w = v.toString;
			var _ = y.hasOwnProperty;
			var A = RegExp(
				'^' +
					w
						.call(_)
						.replace(m, '\\$&')
						.replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
					'$'
			);
			function baseIsNative(e) {
				if (!(0, d.A)(e) || l(e)) {
					return false;
				}
				var t = (0, i.A)(e) ? A : g;
				return t.test((0, p.A)(e));
			}
			const k = baseIsNative;
			function getValue(e, t) {
				return e == null ? undefined : e[t];
			}
			const N = getValue;
			function getNative(e, t) {
				var r = N(e, t);
				return k(r) ? r : undefined;
			}
			const T = getNative;
		},
		3077: (e, t, r) => {
			'use strict';
			r.d(t, { A: () => c });
			var i = r(2752);
			var a = typeof self == 'object' && self && self.Object === Object && self;
			var o = i.A || a || Function('return this')();
			const c = o;
		},
		1465: (e, t, r) => {
			'use strict';
			r.d(t, { A: () => o });
			var i = Function.prototype;
			var a = i.toString;
			function toSource(e) {
				if (e != null) {
					try {
						return a.call(e);
					} catch (e) {}
					try {
						return e + '';
					} catch (e) {}
				}
				return '';
			}
			const o = toSource;
		},
		4336: (e, t, r) => {
			'use strict';
			r.d(t, { A: () => i });
			function eq(e, t) {
				return e === t || (e !== e && t !== t);
			}
			const i = eq;
		},
		6770: (e, t, r) => {
			'use strict';
			r.d(t, { A: () => d });
			var i = r(4855);
			var a = r(997);
			var o = '[object AsyncFunction]',
				c = '[object Function]',
				u = '[object GeneratorFunction]',
				l = '[object Proxy]';
			function isFunction(e) {
				if (!(0, a.A)(e)) {
					return false;
				}
				var t = (0, i.A)(e);
				return t == c || t == u || t == o || t == l;
			}
			const d = isFunction;
		},
		997: (e, t, r) => {
			'use strict';
			r.d(t, { A: () => i });
			function isObject(e) {
				var t = typeof e;
				return e != null && (t == 'object' || t == 'function');
			}
			const i = isObject;
		},
		5056: (e, t, r) => {
			'use strict';
			r.d(t, { A: () => o });
			var i = r(4794);
			var a = 'Expected a function';
			function memoize(e, t) {
				if (typeof e != 'function' || (t != null && typeof t != 'function')) {
					throw new TypeError(a);
				}
				var memoized = function () {
					var r = arguments,
						i = t ? t.apply(this, r) : r[0],
						a = memoized.cache;
					if (a.has(i)) {
						return a.get(i);
					}
					var o = e.apply(this, r);
					memoized.cache = a.set(i, o) || a;
					return o;
				};
				memoized.cache = new (memoize.Cache || i.A)();
				return memoized;
			}
			memoize.Cache = i.A;
			const o = memoize;
		},
		8940: (e, t, r) => {
			'use strict';
			r.d(t, {
				CD: () => k,
				Lc: () => T,
				UP: () => M,
				Uh: () => C,
				Ve: () => l,
				_b: () => g,
				kD: () => x,
				kI: () => p,
				uc: () => d,
				wP: () => m
			});
			const i = 1;
			const a = null && 1 << 1;
			const o = null && 1 << 2;
			const c = null && 1 << 3;
			const u = null && 1 << 4;
			const l = 1;
			const d = 1 << 1;
			const p = 1 << 2;
			const m = 1 << 3;
			const g = 1 << 4;
			const v = 1;
			const y = null && 1 << 1;
			const w = null && 1 << 2;
			const _ = 1;
			const A = null && 1 << 1;
			const k = '[';
			const N = '[!';
			const T = ']';
			const x = {};
			const B = 1;
			const P = null && 1 << 1;
			const M = Symbol();
			const C = Symbol('filename');
			const I = Symbol('hmr');
			const O = 'http://www.w3.org/2000/svg';
			const F = 'http://www.w3.org/1998/Math/MathML';
			const D = null && [
				'state_snapshot_uncloneable',
				'binding_property_non_reactive',
				'hydration_attribute_changed',
				'hydration_html_changed',
				'ownership_invalid_binding',
				'ownership_invalid_mutation'
			];
			const L = null && ['audio', 'datalist', 'dl', 'optgroup', 'select', 'video'];
		},
		6410: (e, t, r) => {
			'use strict';
			r.d(t, {
				$q: () => w,
				FV: () => l,
				L2: () => p,
				OG: () => N,
				PL: () => x,
				T1: () => T,
				XV: () => M,
				Zr: () => u,
				Zv: () => o,
				_N: () => m,
				ac: () => a,
				bp: () => d,
				ig: () => y,
				jm: () => v,
				kc: () => c,
				l3: () => C,
				lQ: () => k,
				mj: () => i,
				o5: () => _,
				vP: () => B,
				w_: () => g,
				wi: () => A,
				x3: () => P
			});
			const i = 1 << 1;
			const a = 1 << 2;
			const o = 1 << 3;
			const c = 1 << 4;
			const u = 1 << 5;
			const l = 1 << 6;
			const d = 1 << 7;
			const p = 1 << 8;
			const m = 1 << 9;
			const g = 1 << 10;
			const v = 1 << 11;
			const y = 1 << 12;
			const w = 1 << 13;
			const _ = 1 << 14;
			const A = 1 << 15;
			const k = 1 << 16;
			const N = 1 << 17;
			const T = 1 << 18;
			const x = 1 << 19;
			const B = 1 << 20;
			const P = Symbol('$state');
			const M = Symbol('$state metadata');
			const C = Symbol('legacy props');
			const I = Symbol('');
		},
		9543: (e, t, r) => {
			'use strict';
			r.d(t, { Ej: () => init_array_prototype_warnings });
			var i = r(2050);
			var a = r(2387);
			function init_array_prototype_warnings() {
				const e = Array.prototype;
				const t = Array.__svelte_cleanup;
				if (t) {
					t();
				}
				const { indexOf: r, lastIndexOf: o, includes: c } = e;
				e.indexOf = function (e, t) {
					const o = r.call(this, e, t);
					if (o === -1) {
						for (let r = t ?? 0; r < this.length; r += 1) {
							if ((0, a.N)(this[r]) === e) {
								i.ns('array.indexOf(...)');
								break;
							}
						}
					}
					return o;
				};
				e.lastIndexOf = function (e, t) {
					const r = o.call(this, e, t ?? this.length - 1);
					if (r === -1) {
						for (let r = 0; r <= (t ?? this.length - 1); r += 1) {
							if ((0, a.N)(this[r]) === e) {
								i.ns('array.lastIndexOf(...)');
								break;
							}
						}
					}
					return r;
				};
				e.includes = function (e, t) {
					const r = c.call(this, e, t);
					if (!r) {
						for (let t = 0; t < this.length; t += 1) {
							if ((0, a.N)(this[t]) === e) {
								i.ns('array.includes(...)');
								break;
							}
						}
					}
					return r;
				};
				Array.__svelte_cleanup = () => {
					e.indexOf = r;
					e.lastIndexOf = o;
					e.includes = c;
				};
			}
			function strict_equals(e, t, r = true) {
				try {
					if ((e === t) !== (get_proxied_value(e) === get_proxied_value(t))) {
						w.state_proxy_equality_mismatch(r ? '===' : '!==');
					}
				} catch {}
				return (e === t) === r;
			}
			function equals(e, t, r = true) {
				if ((e == t) !== (get_proxied_value(e) == get_proxied_value(t))) {
					w.state_proxy_equality_mismatch(r ? '==' : '!=');
				}
				return (e == t) === r;
			}
		},
		3546: (e, t, r) => {
			'use strict';
			r.d(t, { Pj: () => check_ownership, an: () => widen_ownership });
			var i = r(6410);
			var a = r(2522);
			var o = r(1951);
			var c = r(5372);
			var u = r(2050);
			var l = r(8940);
			const d = {};
			const p = /at (?:.+ \()?(.+):(\d+):(\d+)\)?$/;
			const m = /@(.+):(\d+):(\d+)$/;
			function get_stack() {
				const e = new Error().stack;
				if (!e) return null;
				const t = [];
				for (const r of e.split('\n')) {
					let e = p.exec(r) ?? m.exec(r);
					if (e) {
						t.push({ file: e[1], line: +e[2], column: +e[3] });
					}
				}
				return t;
			}
			function get_component() {
				const e = get_stack()?.slice(4);
				if (!e) return null;
				for (let t = 0; t < e.length; t++) {
					const r = e[t];
					const i = d[r.file];
					if (!i) {
						if (t === 0) return null;
						continue;
					}
					for (const e of i) {
						if (e.end == null) {
							return null;
						}
						if (e.start.line < r.line && e.end.line > r.line) {
							return e.component;
						}
					}
				}
				return null;
			}
			const g = Symbol('ADD_OWNER');
			function mark_module_start() {
				const e = get_stack()?.[2];
				if (e) {
					(d[e.file] ??= []).push({ start: e, end: null, component: null });
				}
			}
			function mark_module_end(e) {
				const t = get_stack()?.[2];
				if (t) {
					const r = d[t.file];
					const i = r[r.length - 1];
					i.end = t;
					i.component = e;
				}
			}
			function add_owner(e, t, r = false, i = false) {
				if (e && !r) {
					const r = dev_current_component_function;
					const a = e[STATE_SYMBOL_METADATA];
					if (a && !has_owner(a, r)) {
						let e = get_owner(a);
						if (t[FILENAME] !== r[FILENAME] && !i) {
							w.ownership_invalid_binding(r[FILENAME], t[FILENAME], e[FILENAME]);
						}
					}
				}
				add_owner_to_object(e, t, new Set());
			}
			function add_owner_effect(e, t, r = false) {
				user_pre_effect(() => {
					add_owner(e(), t, false, r);
				});
			}
			function widen_ownership(e, t) {
				if (t.owners === null) {
					return;
				}
				while (e) {
					if (e.owners === null) {
						t.owners = null;
						break;
					}
					for (const r of e.owners) {
						t.owners.add(r);
					}
					e = e.parent;
				}
			}
			function add_owner_to_object(e, t, r) {
				const i = e?.[STATE_SYMBOL_METADATA];
				if (i) {
					if ('owners' in i && i.owners != null) {
						i.owners.add(t);
					}
				} else if (e && typeof e === 'object') {
					if (r.has(e)) return;
					r.add(e);
					if (g in e && e[g]) {
						render_effect(() => {
							e[g](t);
						});
					} else {
						var a = get_prototype_of(e);
						if (a === Object.prototype) {
							for (const i in e) {
								add_owner_to_object(e[i], t, r);
							}
						} else if (a === Array.prototype) {
							for (let i = 0; i < e.length; i += 1) {
								add_owner_to_object(e[i], t, r);
							}
						}
					}
				}
			}
			function has_owner(e, t) {
				if (e.owners === null) {
					return true;
				}
				return e.owners.has(t) || (e.parent !== null && has_owner(e.parent, t));
			}
			function get_owner(e) {
				return e?.owners?.values().next().value ?? get_owner(e.parent);
			}
			let v = false;
			function skip_ownership_validation(e) {
				v = true;
				e();
				v = false;
			}
			function check_ownership(e) {
				if (v) return;
				const t = get_component();
				if (t && !has_owner(e, t)) {
					let r = get_owner(e);
					if (r[l.Uh] !== t[l.Uh]) {
						u.a6(t[l.Uh], r[l.Uh]);
					} else {
						u.a6();
					}
				}
			}
		},
		8969: (e, t, r) => {
			'use strict';
			r.d(t, { ho: () => d, sv: () => get_stack });
			var i = r(8940);
			var a = r(2508);
			var o = r(5372);
			var c = r(6410);
			var u = r(2522);
			var l = r(1951);
			let d = null;
			function log_entry(e, t) {
				const r = e.debug;
				const i = e.trace_need_increase ? e.trace_v : e.v;
				if (i === UNINITIALIZED) {
					return;
				}
				if (r) {
					var a = captured_signals;
					var o = new Set();
					set_captured_signals(o);
					try {
						untrack(() => {
							r();
						});
					} finally {
						set_captured_signals(a);
					}
					if (o.size > 0) {
						for (const e of o) {
							log_entry(e);
						}
						return;
					}
				}
				const c = (e.f & DERIVED) !== 0 ? '$derived' : '$state';
				const u = active_reaction;
				const l = e.wv > u.wv || u.wv === 0;
				console.groupCollapsed(
					`%c${c}`,
					l ? 'color: CornflowerBlue; font-weight: bold' : 'color: grey; font-weight: bold',
					typeof i === 'object' && i !== null && STATE_SYMBOL in i ? snapshot(i, true) : i
				);
				if (c === '$derived') {
					const t = new Set(e.deps);
					for (const e of t) {
						log_entry(e);
					}
				}
				if (e.created) {
					console.log(e.created);
				}
				if (e.updated) {
					console.log(e.updated);
				}
				const d = t?.read;
				if (d && d.length > 0) {
					for (var p of d) {
						console.log(p);
					}
				}
				console.groupEnd();
			}
			function trace(e, t) {
				var r = d;
				try {
					d = { entries: new Map(), reaction: active_reaction };
					var i = performance.now();
					var a = t();
					var o = (performance.now() - i).toFixed(2);
					if (!effect_tracking()) {
						console.log(`${e()} %cran outside of an effect (${o}ms)`, 'color: grey');
					} else if (d.entries.size === 0) {
						console.log(`${e()} %cno reactive dependencies (${o}ms)`, 'color: grey');
					} else {
						console.group(`${e()} %c(${o}ms)`, 'color: grey');
						var c = d.entries;
						d = null;
						for (const [e, t] of c) {
							log_entry(e, t);
						}
						console.groupEnd();
					}
					if (r !== null && d !== null) {
						for (const [e, t] of d.entries) {
							var u = r.get(e);
							if (u === undefined) {
								r.set(e, t);
							} else {
								u.read.push(...t.read);
							}
						}
					}
					return a;
				} finally {
					d = r;
				}
			}
			function get_stack(e) {
				let t = Error();
				const r = t.stack;
				if (r) {
					const i = r.split('\n');
					const a = ['\n'];
					for (let e = 0; e < i.length; e++) {
						const t = i[e];
						if (t === 'Error') {
							continue;
						}
						if (t.includes('validate_each_keys')) {
							return null;
						}
						if (t.includes('svelte/src/internal')) {
							continue;
						}
						a.push(t);
					}
					if (a.length === 1) {
						return null;
					}
					(0, o.Qu)(t, 'stack', { value: a.join('\n') });
					(0, o.Qu)(t, 'name', { value: `${e}Error` });
				}
				return t;
			}
		},
		3285: (t, r, i) => {
			'use strict';
			var a = i(6410);
			var o = i(2522);
			var c = i(1951);
			var u = i(7646);
			var l = i(992);
			var d = i(6836);
			var p = i(5372);
			function snippet(t, r, ...i) {
				var a = t;
				var o = noop;
				var c;
				block(() => {
					if (o === (o = r())) return;
					if (c) {
						destroy_effect(c);
						c = null;
					}
					if (DEV && o == null) {
						e.invalid_snippet();
					}
					c = branch(() => o(a, ...i));
				}, EFFECT_TRANSPARENT);
				if (hydrating) {
					a = hydrate_node;
				}
			}
			function wrap_snippet(e, t) {
				return (r, ...i) => {
					var a = dev_current_component_function;
					set_dev_current_component_function(e);
					try {
						return t(r, ...i);
					} finally {
						set_dev_current_component_function(a);
					}
				};
			}
			function createRawSnippet(e) {
				return (t, ...r) => {
					var i = e(...r);
					var a;
					if (hydrating) {
						a = hydrate_node;
						hydrate_next();
					} else {
						var o = i.render().trim();
						var c = create_fragment_from_html(o);
						a = get_first_child(c);
						if (DEV && (get_next_sibling(a) !== null || a.nodeType !== 1)) {
							w.invalid_raw_snippet_render();
						}
						t.before(a);
					}
					const u = i.setup?.(a);
					assign_nodes(a, a);
					if (typeof u === 'function') {
						teardown(u);
					}
				};
			}
		},
		6880: (e, t, r) => {
			'use strict';
			r.d(t, { j: () => reset_head_anchor });
			var i = r(7646);
			var a = r(6836);
			var o = r(2522);
			var c = r(6410);
			var u = r(8940);
			let l;
			function reset_head_anchor() {
				l = undefined;
			}
			function head(e) {
				let t = null;
				let r = hydrating;
				var i;
				if (hydrating) {
					t = hydrate_node;
					if (l === undefined) {
						l = get_first_child(document.head);
					}
					while (l !== null && (l.nodeType !== 8 || l.data !== HYDRATION_START)) {
						l = get_next_sibling(l);
					}
					if (l === null) {
						set_hydrating(false);
					} else {
						l = set_hydrate_node(get_next_sibling(l));
					}
				}
				if (!hydrating) {
					i = document.head.appendChild(create_text());
				}
				try {
					block(() => e(i), HEAD_EFFECT);
				} finally {
					if (r) {
						set_hydrating(true);
						l = hydrate_node;
						set_hydrate_node(t);
					}
				}
			}
		},
		9854: (e, t, r) => {
			'use strict';
			var i = r(2522);
			var a = r(1951);
			var o = r(6265);
			function listen(e, t, r, i = true) {
				if (i) {
					r();
				}
				for (var a of t) {
					e.addEventListener(a, r);
				}
				teardown(() => {
					for (var i of t) {
						e.removeEventListener(i, r);
					}
				});
			}
			function without_reactive_context(e) {
				var t = active_reaction;
				var r = active_effect;
				set_active_reaction(null);
				set_active_effect(null);
				try {
					return e();
				} finally {
					set_active_reaction(t);
					set_active_effect(r);
				}
			}
			function listen_to_event_and_reset_event(e, t, r, i = r) {
				e.addEventListener(t, () => without_reactive_context(r));
				const a = e.__on_r;
				if (a) {
					e.__on_r = () => {
						a();
						i(true);
					};
				} else {
					e.__on_r = () => i(true);
				}
				add_form_reset_listener();
			}
		},
		4623: (e, t, r) => {
			'use strict';
			r.d(t, { Sr: () => m, Ts: () => p, n7: () => handle_event_propagation });
			var i = r(2522);
			var a = r(5372);
			var o = r(7646);
			var c = r(2635);
			var u = r(8940);
			var l = r(1951);
			var d = r(9854);
			const p = new Set();
			const m = new Set();
			function replay_events(e) {
				if (!hydrating) return;
				if (e.onload) {
					e.removeAttribute('onload');
				}
				if (e.onerror) {
					e.removeAttribute('onerror');
				}
				const t = e.__e;
				if (t !== undefined) {
					e.__e = undefined;
					queueMicrotask(() => {
						if (e.isConnected) {
							e.dispatchEvent(t);
						}
					});
				}
			}
			function create_event(e, t, r, i) {
				function target_handler(e) {
					if (!i.capture) {
						handle_event_propagation.call(t, e);
					}
					if (!e.cancelBubble) {
						return without_reactive_context(() => r.call(this, e));
					}
				}
				if (e.startsWith('pointer') || e.startsWith('touch') || e === 'wheel') {
					queue_micro_task(() => {
						t.addEventListener(e, target_handler, i);
					});
				} else {
					t.addEventListener(e, target_handler, i);
				}
				return target_handler;
			}
			function on(e, t, r, i = {}) {
				var a = create_event(t, e, r, i);
				return () => {
					e.removeEventListener(t, a, i);
				};
			}
			function event(e, t, r, i, a) {
				var o = { capture: i, passive: a };
				var c = create_event(e, t, r, o);
				if (t === document.body || t === window || t === document) {
					teardown(() => {
						t.removeEventListener(e, c, o);
					});
				}
			}
			function delegate(e) {
				for (var t = 0; t < e.length; t++) {
					p.add(e[t]);
				}
				for (var r of m) {
					r(e);
				}
			}
			function handle_event_propagation(e) {
				var t = this;
				var r = t.ownerDocument;
				var i = e.type;
				var o = e.composedPath?.() || [];
				var c = o[0] || e.target;
				var u = 0;
				var d = e.__root;
				if (d) {
					var p = o.indexOf(d);
					if (p !== -1 && (t === document || t === window)) {
						e.__root = t;
						return;
					}
					var m = o.indexOf(t);
					if (m === -1) {
						return;
					}
					if (p <= m) {
						u = p;
					}
				}
				c = o[u] || e.target;
				if (c === t) return;
				(0, a.Qu)(e, 'currentTarget', {
					configurable: true,
					get() {
						return c || r;
					}
				});
				var g = l.hp;
				var v = l.Fg;
				(0, l.G0)(null);
				(0, l.gU)(null);
				try {
					var y;
					var w = [];
					while (c !== null) {
						var _ = c.assignedSlot || c.parentNode || c.host || null;
						try {
							var A = c['__' + i];
							if (A !== undefined && !c.disabled) {
								if ((0, a.PI)(A)) {
									var [k, ...N] = A;
									k.apply(c, [e, ...N]);
								} else {
									A.call(c, e);
								}
							}
						} catch (e) {
							if (y) {
								w.push(e);
							} else {
								y = e;
							}
						}
						if (e.cancelBubble || _ === t || _ === null) {
							break;
						}
						c = _;
					}
					if (y) {
						for (let e of w) {
							queueMicrotask(() => {
								throw e;
							});
						}
						throw y;
					}
				} finally {
					e.__root = t;
					delete e.currentTarget;
					(0, l.G0)(g);
					(0, l.gU)(v);
				}
			}
			function apply(e, t, r, i, a, o = false, c = false) {
				let u;
				let l;
				try {
					u = e();
				} catch (e) {
					l = e;
				}
				if (typeof u === 'function') {
					u.apply(t, r);
				} else if (o || u != null || l) {
					const e = i?.[FILENAME];
					const t = a ? ` at ${e}:${a[0]}:${a[1]}` : ` in ${e}`;
					const o = r[0].type;
					const u = `\`${o}\` handler${t}`;
					const d = c ? 'remove the trailing `()`' : 'add a leading `() =>`';
					w.event_handler_invalid(u, d);
					if (l) {
						throw l;
					}
				}
			}
		},
		6265: (e, t, r) => {
			'use strict';
			var i = r(7646);
			var a = r(6836);
			var o = r(2635);
			function autofocus(e, t) {
				if (t) {
					const t = document.body;
					e.autofocus = true;
					queue_micro_task(() => {
						if (document.activeElement === t) {
							e.focus();
						}
					});
				}
			}
			function remove_textarea_child(e) {
				if (hydrating && get_first_child(e) !== null) {
					clear_text_content(e);
				}
			}
			let c = false;
			function add_form_reset_listener() {
				if (!c) {
					c = true;
					document.addEventListener(
						'reset',
						(e) => {
							Promise.resolve().then(() => {
								if (!e.defaultPrevented) {
									for (const t of e.target.elements) {
										t.__on_r?.();
									}
								}
							});
						},
						{ capture: true }
					);
				}
			}
		},
		7646: (e, t, r) => {
			'use strict';
			r.d(t, {
				E$: () => hydrate_next,
				W0: () => set_hydrate_node,
				Xb: () => u,
				fE: () => c,
				mK: () => set_hydrating
			});
			var i = r(8940);
			var a = r(2050);
			var o = r(6836);
			let c = false;
			function set_hydrating(e) {
				c = e;
			}
			let u;
			function set_hydrate_node(e) {
				if (e === null) {
					a.eZ();
					throw i.kD;
				}
				return (u = e);
			}
			function hydrate_next() {
				return set_hydrate_node((0, o.M$)(u));
			}
			function reset(e) {
				if (!c) return;
				if (get_next_sibling(u) !== null) {
					w.hydration_mismatch();
					throw HYDRATION_ERROR;
				}
				u = e;
			}
			function hydrate_template(e) {
				if (c) {
					u = e.content;
				}
			}
			function next(e = 1) {
				if (c) {
					var t = e;
					var r = u;
					while (t--) {
						r = get_next_sibling(r);
					}
					u = r;
				}
			}
			function remove_nodes() {
				var e = 0;
				var t = u;
				while (true) {
					if (t.nodeType === 8) {
						var r = t.data;
						if (r === HYDRATION_END) {
							if (e === 0) return t;
							e -= 1;
						} else if (r === HYDRATION_START || r === HYDRATION_START_ELSE) {
							e += 1;
						}
					}
					var i = get_next_sibling(t);
					t.remove();
					t = i;
				}
			}
		},
		6836: (e, t, r) => {
			'use strict';
			r.d(t, {
				Ey: () => init_operations,
				M$: () => get_next_sibling,
				MC: () => clear_text_content,
				Pb: () => create_text,
				Zj: () => get_first_child
			});
			var i = r(7646);
			var a = r(235);
			var o = r(9543);
			var c = r(5372);
			var u;
			var l;
			var d;
			var p;
			function init_operations() {
				if (u !== undefined) {
					return;
				}
				u = window;
				l = document;
				var e = Element.prototype;
				var t = Node.prototype;
				d = (0, c.J8)(t, 'firstChild').get;
				p = (0, c.J8)(t, 'nextSibling').get;
				e.__click = undefined;
				e.__className = '';
				e.__attributes = null;
				e.__styles = null;
				e.__e = undefined;
				Text.prototype.__t = undefined;
				if (a.A) {
					e.__svelte_meta = null;
					(0, o.Ej)();
				}
			}
			function create_text(e = '') {
				return document.createTextNode(e);
			}
			function get_first_child(e) {
				return d.call(e);
			}
			function get_next_sibling(e) {
				return p.call(e);
			}
			function child(e, t) {
				if (!hydrating) {
					return get_first_child(e);
				}
				var r = get_first_child(hydrate_node);
				if (r === null) {
					r = hydrate_node.appendChild(create_text());
				} else if (t && r.nodeType !== 3) {
					var i = create_text();
					r?.before(i);
					set_hydrate_node(i);
					return i;
				}
				set_hydrate_node(r);
				return r;
			}
			function first_child(e, t) {
				if (!hydrating) {
					var r = get_first_child(e);
					if (r instanceof Comment && r.data === '') return get_next_sibling(r);
					return r;
				}
				if (t && hydrate_node?.nodeType !== 3) {
					var i = create_text();
					hydrate_node?.before(i);
					set_hydrate_node(i);
					return i;
				}
				return hydrate_node;
			}
			function sibling(e, t = 1, r = false) {
				let i = hydrating ? hydrate_node : e;
				var a;
				while (t--) {
					a = i;
					i = get_next_sibling(i);
				}
				if (!hydrating) {
					return i;
				}
				var o = i?.nodeType;
				if (r && o !== 3) {
					var c = create_text();
					if (i === null) {
						a?.after(c);
					} else {
						i.before(c);
					}
					set_hydrate_node(c);
					return c;
				}
				set_hydrate_node(i);
				return i;
			}
			function clear_text_content(e) {
				e.textContent = '';
			}
		},
		2635: (e, t, r) => {
			'use strict';
			r.d(t, { eo: () => flush_tasks });
			var i = r(5372);
			const a =
				typeof requestIdleCallback === 'undefined' ? (e) => setTimeout(e, 1) : requestIdleCallback;
			let o = false;
			let c = false;
			let u = [];
			let l = [];
			function process_micro_tasks() {
				o = false;
				const e = u.slice();
				u = [];
				(0, i.oO)(e);
			}
			function process_idle_tasks() {
				c = false;
				const e = l.slice();
				l = [];
				(0, i.oO)(e);
			}
			function queue_micro_task(e) {
				if (!o) {
					o = true;
					queueMicrotask(process_micro_tasks);
				}
				u.push(e);
			}
			function queue_idle_task(e) {
				if (!c) {
					c = true;
					a(process_idle_tasks);
				}
				l.push(e);
			}
			function flush_tasks() {
				if (o) {
					process_micro_tasks();
				}
				if (c) {
					process_idle_tasks();
				}
			}
		},
		992: (e, t, r) => {
			'use strict';
			r.d(t, { BC: () => append, mX: () => assign_nodes });
			var i = r(7646);
			var a = r(6836);
			var o = r(1951);
			var c = r(8940);
			function assign_nodes(e, t) {
				var r = o.Fg;
				if (r.nodes_start === null) {
					r.nodes_start = e;
					r.nodes_end = t;
				}
			}
			function template(e, t) {
				var r = (t & TEMPLATE_FRAGMENT) !== 0;
				var i = (t & TEMPLATE_USE_IMPORT_NODE) !== 0;
				var a;
				var o = !e.startsWith('<!>');
				return () => {
					if (hydrating) {
						assign_nodes(hydrate_node, null);
						return hydrate_node;
					}
					if (a === undefined) {
						a = create_fragment_from_html(o ? e : '<!>' + e);
						if (!r) a = get_first_child(a);
					}
					var t = i ? document.importNode(a, true) : a.cloneNode(true);
					if (r) {
						var c = get_first_child(t);
						var u = t.lastChild;
						assign_nodes(c, u);
					} else {
						assign_nodes(t, t);
					}
					return t;
				};
			}
			function template_with_script(e, t) {
				var r = template(e, t);
				return () => run_scripts(r());
			}
			function ns_template(e, t, r = 'svg') {
				var i = !e.startsWith('<!>');
				var a = (t & TEMPLATE_FRAGMENT) !== 0;
				var o = `<${r}>${i ? e : '<!>' + e}</${r}>`;
				var c;
				return () => {
					if (hydrating) {
						assign_nodes(hydrate_node, null);
						return hydrate_node;
					}
					if (!c) {
						var e = create_fragment_from_html(o);
						var t = get_first_child(e);
						if (a) {
							c = document.createDocumentFragment();
							while (get_first_child(t)) {
								c.appendChild(get_first_child(t));
							}
						} else {
							c = get_first_child(t);
						}
					}
					var r = c.cloneNode(true);
					if (a) {
						var i = get_first_child(r);
						var u = r.lastChild;
						assign_nodes(i, u);
					} else {
						assign_nodes(r, r);
					}
					return r;
				};
			}
			function svg_template_with_script(e, t) {
				var r = ns_template(e, t);
				return () => run_scripts(r());
			}
			function mathml_template(e, t) {
				return ns_template(e, t, 'math');
			}
			function run_scripts(e) {
				if (hydrating) return e;
				const t = e.nodeType === 11;
				const r = e.tagName === 'SCRIPT' ? [e] : e.querySelectorAll('script');
				const i = active_effect;
				for (const o of r) {
					const r = document.createElement('script');
					for (var a of o.attributes) {
						r.setAttribute(a.name, a.value);
					}
					r.textContent = o.textContent;
					if (t ? e.firstChild === o : e === o) {
						i.nodes_start = r;
					}
					if (t ? e.lastChild === o : e === o) {
						i.nodes_end = r;
					}
					o.replaceWith(r);
				}
				return e;
			}
			function text(e = '') {
				if (!hydrating) {
					var t = create_text(e + '');
					assign_nodes(t, t);
					return t;
				}
				var r = hydrate_node;
				if (r.nodeType !== 3) {
					r.before((r = create_text()));
					set_hydrate_node(r);
				}
				assign_nodes(r, r);
				return r;
			}
			function comment() {
				if (hydrating) {
					assign_nodes(hydrate_node, null);
					return hydrate_node;
				}
				var e = document.createDocumentFragment();
				var t = document.createComment('');
				var r = create_text();
				e.append(t, r);
				assign_nodes(t, r);
				return e;
			}
			function append(e, t) {
				if (i.fE) {
					o.Fg.nodes_end = i.Xb;
					(0, i.E$)();
					return;
				}
				if (e === null) {
					return;
				}
				e.before(t);
			}
		},
		8048: (e, t, r) => {
			'use strict';
			r.d(t, {
				$k: () => state_unsafe_local_read,
				Cl: () => effect_update_depth_exceeded,
				Uw: () => state_descriptors_fixed,
				Vv: () => hydration_failed,
				YY: () => state_prototype_fixed,
				cN: () => derived_references_self,
				js: () => props_rest_readonly,
				rZ: () => state_unsafe_mutation,
				vo: () => props_invalid_value,
				xU: () => rune_outside_svelte
			});
			var i = r(235);
			function bind_invalid_checkbox_value() {
				if (DEV) {
					const e = new Error(
						`bind_invalid_checkbox_value\nUsing \`bind:value\` together with a checkbox input is not allowed. Use \`bind:checked\` instead\nhttps://svelte.dev/e/bind_invalid_checkbox_value`
					);
					e.name = 'Svelte error';
					throw e;
				} else {
					throw new Error(`https://svelte.dev/e/bind_invalid_checkbox_value`);
				}
			}
			function bind_invalid_export(e, t, r) {
				if (DEV) {
					const i = new Error(
						`bind_invalid_export\nComponent ${e} has an export named \`${t}\` that a consumer component is trying to access using \`bind:${t}\`, which is disallowed. Instead, use \`bind:this\` (e.g. \`<${r} bind:this={component} />\`) and then access the property on the bound component instance (e.g. \`component.${t}\`)\nhttps://svelte.dev/e/bind_invalid_export`
					);
					i.name = 'Svelte error';
					throw i;
				} else {
					throw new Error(`https://svelte.dev/e/bind_invalid_export`);
				}
			}
			function bind_not_bindable(e, t, r) {
				if (DEV) {
					const i = new Error(
						`bind_not_bindable\nA component is attempting to bind to a non-bindable property \`${e}\` belonging to ${t} (i.e. \`<${r} bind:${e}={...}>\`). To mark a property as bindable: \`let { ${e} = $bindable() } = $props()\`\nhttps://svelte.dev/e/bind_not_bindable`
					);
					i.name = 'Svelte error';
					throw i;
				} else {
					throw new Error(`https://svelte.dev/e/bind_not_bindable`);
				}
			}
			function component_api_changed(e, t, r) {
				if (DEV) {
					const i = new Error(
						`component_api_changed\n${e} called \`${t}\` on an instance of ${r}, which is no longer valid in Svelte 5\nhttps://svelte.dev/e/component_api_changed`
					);
					i.name = 'Svelte error';
					throw i;
				} else {
					throw new Error(`https://svelte.dev/e/component_api_changed`);
				}
			}
			function component_api_invalid_new(e, t) {
				if (DEV) {
					const r = new Error(
						`component_api_invalid_new\nAttempted to instantiate ${e} with \`new ${t}\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \`compatibility.componentApi\` compiler option to \`4\` to keep it working.\nhttps://svelte.dev/e/component_api_invalid_new`
					);
					r.name = 'Svelte error';
					throw r;
				} else {
					throw new Error(`https://svelte.dev/e/component_api_invalid_new`);
				}
			}
			function derived_references_self() {
				if (i.A) {
					const e = new Error(
						`derived_references_self\nA derived value cannot reference itself recursively\nhttps://svelte.dev/e/derived_references_self`
					);
					e.name = 'Svelte error';
					throw e;
				} else {
					throw new Error(`https://svelte.dev/e/derived_references_self`);
				}
			}
			function each_key_duplicate(e, t, r) {
				if (DEV) {
					const i = new Error(
						`each_key_duplicate\n${r ? `Keyed each block has duplicate key \`${r}\` at indexes ${e} and ${t}` : `Keyed each block has duplicate key at indexes ${e} and ${t}`}\nhttps://svelte.dev/e/each_key_duplicate`
					);
					i.name = 'Svelte error';
					throw i;
				} else {
					throw new Error(`https://svelte.dev/e/each_key_duplicate`);
				}
			}
			function effect_in_teardown(e) {
				if (DEV) {
					const t = new Error(
						`effect_in_teardown\n\`${e}\` cannot be used inside an effect cleanup function\nhttps://svelte.dev/e/effect_in_teardown`
					);
					t.name = 'Svelte error';
					throw t;
				} else {
					throw new Error(`https://svelte.dev/e/effect_in_teardown`);
				}
			}
			function effect_in_unowned_derived() {
				if (DEV) {
					const e = new Error(
						`effect_in_unowned_derived\nEffect cannot be created inside a \`$derived\` value that was not itself created inside an effect\nhttps://svelte.dev/e/effect_in_unowned_derived`
					);
					e.name = 'Svelte error';
					throw e;
				} else {
					throw new Error(`https://svelte.dev/e/effect_in_unowned_derived`);
				}
			}
			function effect_orphan(e) {
				if (DEV) {
					const t = new Error(
						`effect_orphan\n\`${e}\` can only be used inside an effect (e.g. during component initialisation)\nhttps://svelte.dev/e/effect_orphan`
					);
					t.name = 'Svelte error';
					throw t;
				} else {
					throw new Error(`https://svelte.dev/e/effect_orphan`);
				}
			}
			function effect_update_depth_exceeded() {
				if (i.A) {
					const e = new Error(
						`effect_update_depth_exceeded\nMaximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops\nhttps://svelte.dev/e/effect_update_depth_exceeded`
					);
					e.name = 'Svelte error';
					throw e;
				} else {
					throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
				}
			}
			function hydration_failed() {
				if (i.A) {
					const e = new Error(
						`hydration_failed\nFailed to hydrate the application\nhttps://svelte.dev/e/hydration_failed`
					);
					e.name = 'Svelte error';
					throw e;
				} else {
					throw new Error(`https://svelte.dev/e/hydration_failed`);
				}
			}
			function invalid_snippet() {
				if (DEV) {
					const e = new Error(
						`invalid_snippet\nCould not \`{@render}\` snippet due to the expression being \`null\` or \`undefined\`. Consider using optional chaining \`{@render snippet?.()}\`\nhttps://svelte.dev/e/invalid_snippet`
					);
					e.name = 'Svelte error';
					throw e;
				} else {
					throw new Error(`https://svelte.dev/e/invalid_snippet`);
				}
			}
			function lifecycle_legacy_only(e) {
				if (DEV) {
					const t = new Error(
						`lifecycle_legacy_only\n\`${e}(...)\` cannot be used in runes mode\nhttps://svelte.dev/e/lifecycle_legacy_only`
					);
					t.name = 'Svelte error';
					throw t;
				} else {
					throw new Error(`https://svelte.dev/e/lifecycle_legacy_only`);
				}
			}
			function props_invalid_value(e) {
				if (i.A) {
					const t = new Error(
						`props_invalid_value\nCannot do \`bind:${e}={undefined}\` when \`${e}\` has a fallback value\nhttps://svelte.dev/e/props_invalid_value`
					);
					t.name = 'Svelte error';
					throw t;
				} else {
					throw new Error(`https://svelte.dev/e/props_invalid_value`);
				}
			}
			function props_rest_readonly(e) {
				if (i.A) {
					const t = new Error(
						`props_rest_readonly\nRest element properties of \`$props()\` such as \`${e}\` are readonly\nhttps://svelte.dev/e/props_rest_readonly`
					);
					t.name = 'Svelte error';
					throw t;
				} else {
					throw new Error(`https://svelte.dev/e/props_rest_readonly`);
				}
			}
			function rune_outside_svelte(e) {
				if (i.A) {
					const t = new Error(
						`rune_outside_svelte\nThe \`${e}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files\nhttps://svelte.dev/e/rune_outside_svelte`
					);
					t.name = 'Svelte error';
					throw t;
				} else {
					throw new Error(`https://svelte.dev/e/rune_outside_svelte`);
				}
			}
			function state_descriptors_fixed() {
				if (i.A) {
					const e = new Error(
						`state_descriptors_fixed\nProperty descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.\nhttps://svelte.dev/e/state_descriptors_fixed`
					);
					e.name = 'Svelte error';
					throw e;
				} else {
					throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
				}
			}
			function state_prototype_fixed() {
				if (i.A) {
					const e = new Error(
						`state_prototype_fixed\nCannot set prototype of \`$state\` object\nhttps://svelte.dev/e/state_prototype_fixed`
					);
					e.name = 'Svelte error';
					throw e;
				} else {
					throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
				}
			}
			function state_unsafe_local_read() {
				if (i.A) {
					const e = new Error(
						`state_unsafe_local_read\nReading state that was created inside the same derived is forbidden. Consider using \`untrack\` to read locally created state\nhttps://svelte.dev/e/state_unsafe_local_read`
					);
					e.name = 'Svelte error';
					throw e;
				} else {
					throw new Error(`https://svelte.dev/e/state_unsafe_local_read`);
				}
			}
			function state_unsafe_mutation() {
				if (i.A) {
					const e = new Error(
						`state_unsafe_mutation\nUpdating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`\nhttps://svelte.dev/e/state_unsafe_mutation`
					);
					e.name = 'Svelte error';
					throw e;
				} else {
					throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
				}
			}
		},
		4193: (t, r, i) => {
			'use strict';
			var a = i(8940);
			var o = i(2320);
			var c = i(1951);
			function compare(e, t, r, i) {
				if (e !== t) {
					w.assignment_value_stale(r, sanitize_location(i));
				}
				return e;
			}
			function assign_assign(e, t, r, i) {
				return compare(
					(e[t] = r),
					untrack(() => e[t]),
					t,
					i
				);
			}
			function assign_and(e, t, r, i) {
				return compare(
					(e[t] &&= r),
					untrack(() => e[t]),
					t,
					i
				);
			}
			function assign_or(e, t, r, i) {
				return compare(
					(e[t] ||= r),
					untrack(() => e[t]),
					t,
					i
				);
			}
			function assign_nullish(e, t, r, i) {
				return compare(
					(e[t] ??= r),
					untrack(() => e[t]),
					t,
					i
				);
			}
			var u = new Map();
			function css_register_style(e, t) {
				var r = u.get(e);
				if (!r) {
					r = new Set();
					u.set(e, r);
				}
				r.add(t);
			}
			function cleanup_styles(e) {
				var t = u.get(e);
				if (!t) return;
				for (const e of t) {
					e.remove();
				}
				u.delete(e);
			}
			var l = i(7646);
			function add_locations(e, t, r) {
				return (...i) => {
					const a = e(...i);
					var o = hydrating ? a : a.nodeType === 11 ? a.firstChild : a;
					assign_locations(o, t, r);
					return a;
				};
			}
			function assign_location(e, t, r) {
				e.__svelte_meta = { loc: { file: t, line: r[0], column: r[1] } };
				if (r[2]) {
					assign_locations(e.firstChild, t, r[2]);
				}
			}
			function assign_locations(e, t, r) {
				var i = 0;
				var a = 0;
				while (e && i < r.length) {
					if (hydrating && e.nodeType === 8) {
						var o = e;
						if (o.data === HYDRATION_START || o.data === HYDRATION_START_ELSE) a += 1;
						else if (o.data[0] === HYDRATION_END) a -= 1;
					}
					if (a === 0 && e.nodeType === 1) {
						assign_location(e, t, r[i++]);
					}
					e = e.nextSibling;
				}
			}
			var d = i(6410);
			var p = i(2522);
			var m = i(9246);
			var g = i(3091);
			function hmr(e, t) {
				function wrapper(e, r) {
					let i = {};
					let a;
					let o = false;
					block(() => {
						const c = t();
						const u = get(c);
						if (a) {
							for (var l in i) delete i[l];
							destroy_effect(a);
						}
						a = branch(() => {
							if (o) set_should_intro(false);
							Object.defineProperties(
								i,
								Object.getOwnPropertyDescriptors(new.target ? new u(e, r) : u(e, r))
							);
							if (o) set_should_intro(true);
						});
					}, EFFECT_TRANSPARENT);
					o = true;
					if (hydrating) {
						e = hydrate_node;
					}
					return i;
				}
				wrapper[FILENAME] = e[FILENAME];
				wrapper[HMR] = { original: e, source: source(e) };
				return wrapper;
			}
			var v = i(3546);
			function check_target(t) {
				if (t) {
					e.component_api_invalid_new(t[FILENAME] ?? 'a component', t.name);
				}
			}
			function legacy_api() {
				const t = component_context?.function;
				function error(r) {
					const i = get_component()?.[FILENAME] ?? 'Something';
					e.component_api_changed(i, r, t[FILENAME]);
				}
				return {
					$destroy: () => error('$destroy()'),
					$on: () => error('$on(...)'),
					$set: () => error('$set(...)')
				};
			}
			var y = i(8969);
			var _ = i(2508);
			function inspect(e, t = console.log) {
				validate_effect('$inspect');
				let r = true;
				inspect_effect(() => {
					var i = UNINITIALIZED;
					try {
						i = e();
					} catch (e) {
						console.error(e);
					}
					if (i !== UNINITIALIZED) {
						t(r ? 'init' : 'update', ...snapshot(i, true));
					}
					r = false;
				});
			}
			var A = i(5372);
			var k = i(2635);
			const N = 0;
			const T = 1;
			const x = 2;
			function await_block(e, t, r, i, a) {
				if (hydrating) {
					hydrate_next();
				}
				var o = e;
				var c = is_runes();
				var u = component_context;
				var l = DEV ? component_context?.function : null;
				var d = UNINITIALIZED;
				var p;
				var m;
				var g;
				var v = (c ? source : mutable_source)(undefined);
				var y = (c ? source : mutable_source)(undefined);
				var w = false;
				function update(e, t) {
					w = true;
					if (t) {
						set_active_effect(_);
						set_active_reaction(_);
						set_component_context(u);
						if (DEV) set_dev_current_component_function(l);
					}
					try {
						if (e === N && r) {
							if (p) resume_effect(p);
							else p = branch(() => r(o));
						}
						if (e === T && i) {
							if (m) resume_effect(m);
							else m = branch(() => i(o, v));
						}
						if (e === x && a) {
							if (g) resume_effect(g);
							else g = branch(() => a(o, y));
						}
						if (e !== N && p) {
							pause_effect(p, () => (p = null));
						}
						if (e !== T && m) {
							pause_effect(m, () => (m = null));
						}
						if (e !== x && g) {
							pause_effect(g, () => (g = null));
						}
					} finally {
						if (t) {
							if (DEV) set_dev_current_component_function(null);
							set_component_context(null);
							set_active_reaction(null);
							set_active_effect(null);
							flush_sync();
						}
					}
				}
				var _ = block(() => {
					if (d === (d = t())) return;
					if (is_promise(d)) {
						var e = d;
						w = false;
						e.then(
							(t) => {
								if (e !== d) return;
								internal_set(v, t);
								update(T, true);
							},
							(t) => {
								if (e !== d) return;
								internal_set(y, t);
								update(x, true);
								if (!a) {
									throw y.v;
								}
							}
						);
						if (hydrating) {
							if (r) {
								p = branch(() => r(o));
							}
						} else {
							queue_micro_task(() => {
								if (!w) update(N, true);
							});
						}
					} else {
						internal_set(v, d);
						update(T, false);
					}
					return () => (d = UNINITIALIZED);
				});
				if (hydrating) {
					o = hydrate_node;
				}
			}
			function if_block(e, t, r = false) {
				if (hydrating) {
					hydrate_next();
				}
				var i = e;
				var a = null;
				var o = null;
				var c = UNINITIALIZED;
				var u = r ? EFFECT_TRANSPARENT : 0;
				var l = false;
				const set_branch = (e, t = true) => {
					l = true;
					update_branch(t, e);
				};
				const update_branch = (e, t) => {
					if (c === (c = e)) return;
					let r = false;
					if (hydrating) {
						const e = i.data === HYDRATION_START_ELSE;
						if (!!c === e) {
							i = remove_nodes();
							set_hydrate_node(i);
							set_hydrating(false);
							r = true;
						}
					}
					if (c) {
						if (a) {
							resume_effect(a);
						} else if (t) {
							a = branch(() => t(i));
						}
						if (o) {
							pause_effect(o, () => {
								o = null;
							});
						}
					} else {
						if (o) {
							resume_effect(o);
						} else if (t) {
							o = branch(() => t(i));
						}
						if (a) {
							pause_effect(a, () => {
								a = null;
							});
						}
					}
					if (r) {
						set_hydrating(true);
					}
				};
				block(() => {
					l = false;
					t(set_branch);
					if (!l) {
						update_branch(null, null);
					}
				}, u);
				if (hydrating) {
					i = hydrate_node;
				}
			}
			function key_block(e, t, r) {
				if (hydrating) {
					hydrate_next();
				}
				var i = e;
				var a = UNINITIALIZED;
				var o;
				var c = is_runes() ? not_equal : safe_not_equal;
				block(() => {
					if (c(a, (a = t()))) {
						if (o) {
							pause_effect(o);
						}
						o = branch(() => r(i));
					}
				});
				if (hydrating) {
					i = hydrate_node;
				}
			}
			var B = i(6836);
			function css_props(e, t) {
				if (hydrating) {
					set_hydrate_node(get_first_child(e));
				}
				render_effect(() => {
					var r = t();
					for (var i in r) {
						var a = r[i];
						if (a) {
							e.style.setProperty(i, a);
						} else {
							e.style.removeProperty(i);
						}
					}
				});
				teardown(() => {
					e.remove();
				});
			}
			var P = i(656);
			let M = null;
			function each_set_current_each_item(e) {
				M = e;
			}
			function index(e, t) {
				return t;
			}
			function pause_effects(e, t, r, i) {
				var a = [];
				var o = t.length;
				for (var c = 0; c < o; c++) {
					pause_children(t[c].e, a, true);
				}
				var u = o > 0 && a.length === 0 && r !== null;
				if (u) {
					var l = r.parentNode;
					clear_text_content(l);
					l.append(r);
					i.clear();
					each_link(e, t[0].prev, t[o - 1].next);
				}
				run_out_transitions(a, () => {
					for (var r = 0; r < o; r++) {
						var a = t[r];
						if (!u) {
							i.delete(a.k);
							each_link(e, a.prev, a.next);
						}
						destroy_effect(a.e, !u);
					}
				});
			}
			function each(e, t, r, i, a, o = null) {
				var c = e;
				var u = { flags: t, items: new Map(), first: null };
				var l = (t & EACH_IS_CONTROLLED) !== 0;
				if (l) {
					var d = e;
					c = hydrating ? set_hydrate_node(get_first_child(d)) : d.appendChild(create_text());
				}
				if (hydrating) {
					hydrate_next();
				}
				var p = null;
				var m = false;
				var g = derived_safe_equal(() => {
					var e = r();
					return is_array(e) ? e : e == null ? [] : array_from(e);
				});
				block(() => {
					var e = get(g);
					var l = e.length;
					if (m && l === 0) {
						return;
					}
					m = l === 0;
					let d = false;
					if (hydrating) {
						var v = c.data === HYDRATION_START_ELSE;
						if (v !== (l === 0)) {
							c = remove_nodes();
							set_hydrate_node(c);
							set_hydrating(false);
							d = true;
						}
					}
					if (hydrating) {
						var y = null;
						var w;
						for (var _ = 0; _ < l; _++) {
							if (hydrate_node.nodeType === 8 && hydrate_node.data === HYDRATION_END) {
								c = hydrate_node;
								d = true;
								set_hydrating(false);
								break;
							}
							var A = e[_];
							var k = i(A, _);
							w = create_item(hydrate_node, u, y, null, A, k, _, a, t, r);
							u.items.set(k, w);
							y = w;
						}
						if (l > 0) {
							set_hydrate_node(remove_nodes());
						}
					}
					if (!hydrating) {
						var N = active_reaction;
						reconcile(e, u, c, a, t, (N.f & INERT) !== 0, i, r);
					}
					if (o !== null) {
						if (l === 0) {
							if (p) {
								resume_effect(p);
							} else {
								p = branch(() => o(c));
							}
						} else if (p !== null) {
							pause_effect(p, () => {
								p = null;
							});
						}
					}
					if (d) {
						set_hydrating(true);
					}
					get(g);
				});
				if (hydrating) {
					c = hydrate_node;
				}
			}
			function reconcile(e, t, r, i, a, o, c, u) {
				var l = (a & EACH_IS_ANIMATED) !== 0;
				var d = (a & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;
				var p = e.length;
				var m = t.items;
				var g = t.first;
				var v = g;
				var y;
				var w = null;
				var _;
				var A = [];
				var k = [];
				var N;
				var T;
				var x;
				var B;
				if (l) {
					for (B = 0; B < p; B += 1) {
						N = e[B];
						T = c(N, B);
						x = m.get(T);
						if (x !== undefined) {
							x.a?.measure();
							(_ ??= new Set()).add(x);
						}
					}
				}
				for (B = 0; B < p; B += 1) {
					N = e[B];
					T = c(N, B);
					x = m.get(T);
					if (x === undefined) {
						var P = v ? v.e.nodes_start : r;
						w = create_item(P, t, w, w === null ? t.first : w.next, N, T, B, i, a, u);
						m.set(T, w);
						A = [];
						k = [];
						v = w.next;
						continue;
					}
					if (d) {
						update_item(x, N, B, a);
					}
					if ((x.e.f & INERT) !== 0) {
						resume_effect(x.e);
						if (l) {
							x.a?.unfix();
							(_ ??= new Set()).delete(x);
						}
					}
					if (x !== v) {
						if (y !== undefined && y.has(x)) {
							if (A.length < k.length) {
								var M = k[0];
								var C;
								w = M.prev;
								var I = A[0];
								var O = A[A.length - 1];
								for (C = 0; C < A.length; C += 1) {
									move(A[C], M, r);
								}
								for (C = 0; C < k.length; C += 1) {
									y.delete(k[C]);
								}
								each_link(t, I.prev, O.next);
								each_link(t, w, I);
								each_link(t, O, M);
								v = M;
								w = O;
								B -= 1;
								A = [];
								k = [];
							} else {
								y.delete(x);
								move(x, v, r);
								each_link(t, x.prev, x.next);
								each_link(t, x, w === null ? t.first : w.next);
								each_link(t, w, x);
								w = x;
							}
							continue;
						}
						A = [];
						k = [];
						while (v !== null && v.k !== T) {
							if (o || (v.e.f & INERT) === 0) {
								(y ??= new Set()).add(v);
							}
							k.push(v);
							v = v.next;
						}
						if (v === null) {
							continue;
						}
						x = v;
					}
					A.push(x);
					w = x;
					v = x.next;
				}
				if (v !== null || y !== undefined) {
					var F = y === undefined ? [] : array_from(y);
					while (v !== null) {
						if (o || (v.e.f & INERT) === 0) {
							F.push(v);
						}
						v = v.next;
					}
					var D = F.length;
					if (D > 0) {
						var L = (a & EACH_IS_CONTROLLED) !== 0 && p === 0 ? r : null;
						if (l) {
							for (B = 0; B < D; B += 1) {
								F[B].a?.measure();
							}
							for (B = 0; B < D; B += 1) {
								F[B].a?.fix();
							}
						}
						pause_effects(t, F, L, m);
					}
				}
				if (l) {
					queue_micro_task(() => {
						if (_ === undefined) return;
						for (x of _) {
							x.a?.apply();
						}
					});
				}
				active_effect.first = t.first && t.first.e;
				active_effect.last = w && w.e;
			}
			function update_item(e, t, r, i) {
				if ((i & EACH_ITEM_REACTIVE) !== 0) {
					internal_set(e.v, t);
				}
				if ((i & EACH_INDEX_REACTIVE) !== 0) {
					internal_set(e.i, r);
				} else {
					e.i = r;
				}
			}
			function create_item(e, t, r, i, a, o, c, u, l, d) {
				var p = M;
				var m = (l & EACH_ITEM_REACTIVE) !== 0;
				var g = (l & EACH_ITEM_IMMUTABLE) === 0;
				var v = m ? (g ? mutable_source(a) : source(a)) : a;
				var y = (l & EACH_INDEX_REACTIVE) === 0 ? c : source(c);
				if (DEV && m) {
					v.debug = () => {
						var e = typeof y === 'number' ? c : y.v;
						d()[e];
					};
				}
				var w = { i: y, v, k: o, a: null, e: null, prev: r, next: i };
				M = w;
				try {
					w.e = branch(() => u(e, v, y), hydrating);
					w.e.prev = r && r.e;
					w.e.next = i && i.e;
					if (r === null) {
						t.first = w;
					} else {
						r.next = w;
						r.e.next = w.e;
					}
					if (i !== null) {
						i.prev = w;
						i.e.prev = w.e;
					}
					return w;
				} finally {
					M = p;
				}
			}
			function move(e, t, r) {
				var i = e.next ? e.next.e.nodes_start : r;
				var a = t ? t.e.nodes_start : r;
				var o = e.e.nodes_start;
				while (o !== i) {
					var c = get_next_sibling(o);
					a.before(o);
					o = c;
				}
			}
			function each_link(e, t, r) {
				if (t === null) {
					e.first = r;
				} else {
					t.next = r;
					t.e.next = r && r.e;
				}
				if (r !== null) {
					r.prev = t;
					r.e.prev = t && t.e;
				}
			}
			var C = i(992);
			function check_hash(e, t, r) {
				if (!t || t === hash(String(r ?? ''))) return;
				let i;
				const a = e.__svelte_meta?.loc;
				if (a) {
					i = `near ${a.file}:${a.line}:${a.column}`;
				} else if (dev_current_component_function?.[FILENAME]) {
					i = `in ${dev_current_component_function[FILENAME]}`;
				}
				w.hydration_html_changed(sanitize_location(i));
			}
			function html(e, t, r, i, a) {
				var o = e;
				var c = '';
				var u;
				block(() => {
					if (c === (c = t() ?? '')) {
						if (hydrating) {
							hydrate_next();
						}
						return;
					}
					if (u !== undefined) {
						destroy_effect(u);
						u = undefined;
					}
					if (c === '') return;
					u = branch(() => {
						if (hydrating) {
							var e = hydrate_node.data;
							var t = hydrate_next();
							var u = t;
							while (t !== null && (t.nodeType !== 8 || t.data !== '')) {
								u = t;
								t = get_next_sibling(t);
							}
							if (t === null) {
								w.hydration_mismatch();
								throw HYDRATION_ERROR;
							}
							if (DEV && !a) {
								check_hash(t.parentNode, e, c);
							}
							assign_nodes(hydrate_node, u);
							o = set_hydrate_node(t);
							return;
						}
						var l = c + '';
						if (r) l = `<svg>${l}</svg>`;
						else if (i) l = `<math>${l}</math>`;
						var d = create_fragment_from_html(l);
						if (r || i) {
							d = get_first_child(d);
						}
						assign_nodes(get_first_child(d), d.lastChild);
						if (r || i) {
							while (get_first_child(d)) {
								o.before(get_first_child(d));
							}
						} else {
							o.before(d);
						}
					});
				});
			}
			function slot(e, t, r, i, a) {
				if (hydrating) {
					hydrate_next();
				}
				var o = t.$$slots?.[r];
				var c = false;
				if (o === true) {
					o = t[r === 'default' ? 'children' : r];
					c = true;
				}
				if (o === undefined) {
					if (a !== null) {
						a(e);
					}
				} else {
					o(e, c ? () => i : i);
				}
			}
			function sanitize_slots(e) {
				const t = {};
				if (e.children) t.default = true;
				for (const r in e.$$slots) {
					t[r] = true;
				}
				return t;
			}
			var I = i(3285);
			function component(e, t, r) {
				if (hydrating) {
					hydrate_next();
				}
				var i = e;
				var a;
				var o;
				block(() => {
					if (a === (a = t())) return;
					if (o) {
						pause_effect(o);
						o = null;
					}
					if (a) {
						o = branch(() => r(i, a));
					}
				}, EFFECT_TRANSPARENT);
				if (hydrating) {
					i = hydrate_node;
				}
			}
			function svelte_element_element(e, t, r, i, a, o) {
				let c = hydrating;
				if (hydrating) {
					hydrate_next();
				}
				var u = DEV && o && component_context?.function[FILENAME];
				var l;
				var d;
				var p = null;
				if (hydrating && hydrate_node.nodeType === 1) {
					p = hydrate_node;
					hydrate_next();
				}
				var m = hydrating ? hydrate_node : e;
				var g;
				var v = current_each_item;
				block(() => {
					const e = t() || null;
					var c = a ? a() : r || e === 'svg' ? NAMESPACE_SVG : null;
					if (e === l) return;
					var y = current_each_item;
					set_current_each_item(v);
					if (g) {
						if (e === null) {
							pause_effect(g, () => {
								g = null;
								d = null;
							});
						} else if (e === d) {
							resume_effect(g);
						} else {
							destroy_effect(g);
							set_should_intro(false);
						}
					}
					if (e && e !== d) {
						g = branch(() => {
							p = hydrating ? p : c ? document.createElementNS(c, e) : document.createElement(e);
							if (DEV && o) {
								p.__svelte_meta = { loc: { file: u, line: o[0], column: o[1] } };
							}
							assign_nodes(p, p);
							if (i) {
								if (hydrating && is_raw_text_element(e)) {
									p.append(document.createComment(''));
								}
								var t = hydrating ? get_first_child(p) : p.appendChild(create_text());
								if (hydrating) {
									if (t === null) {
										set_hydrating(false);
									} else {
										set_hydrate_node(t);
									}
								}
								i(p, t);
							}
							active_effect.nodes_end = p;
							m.before(p);
						});
					}
					l = e;
					if (l) d = l;
					set_should_intro(true);
					set_current_each_item(y);
				}, EFFECT_TRANSPARENT);
				if (c) {
					set_hydrating(true);
					set_hydrate_node(m);
				}
			}
			var O = i(6880);
			function append_styles(e, t) {
				queue_micro_task(() => {
					var r = e.getRootNode();
					var i = r.host ? r : (r.head ?? r.ownerDocument.head);
					if (!i.querySelector('#' + t.hash)) {
						const e = document.createElement('style');
						e.id = t.hash;
						e.textContent = t.code;
						i.appendChild(e);
						if (DEV) {
							register_style(t.hash, e);
						}
					}
				});
			}
			function action(e, t, r) {
				effect(() => {
					var i = untrack(() => t(e, r?.()) || {});
					if (r && i?.update) {
						var a = false;
						var o = {};
						render_effect(() => {
							var e = r();
							deep_read_state(e);
							if (a && safe_not_equal(o, e)) {
								o = e;
								i.update(e);
							}
						});
						a = true;
					}
					if (i?.destroy) {
						return () => i.destroy();
					}
				});
			}
			var F = i(4623);
			var D = i(6265);
			const L = {
				translate: new Map([
					[true, 'yes'],
					[false, 'no']
				])
			};
			function attr(e, t, r = false) {
				if (t == null || (!t && r) || (t === '' && e === 'class')) return '';
				const i = (e in L && L[e].get(t)) || t;
				const a = r ? '' : `="${escape_html(i, true)}"`;
				return ` ${e}${a}`;
			}
			function attributes_clsx(e) {
				if (typeof e === 'object') {
					return _clsx(e);
				} else {
					return e ?? '';
				}
			}
			function remove_input_defaults(e) {
				if (!hydrating) return;
				var t = false;
				var remove_defaults = () => {
					if (t) return;
					t = true;
					if (e.hasAttribute('value')) {
						var r = e.value;
						set_attribute(e, 'value', null);
						e.value = r;
					}
					if (e.hasAttribute('checked')) {
						var i = e.checked;
						set_attribute(e, 'checked', null);
						e.checked = i;
					}
				};
				e.__on_r = remove_defaults;
				queue_idle_task(remove_defaults);
				add_form_reset_listener();
			}
			function set_value(e, t) {
				var r = (e.__attributes ??= {});
				if (
					r.value === (r.value = t ?? undefined) ||
					(e.value === t && (t !== 0 || e.nodeName !== 'PROGRESS'))
				) {
					return;
				}
				e.value = t;
			}
			function set_checked(e, t) {
				var r = (e.__attributes ??= {});
				if (r.checked === (r.checked = t ?? undefined)) {
					return;
				}
				e.checked = t;
			}
			function set_selected(e, t) {
				if (t) {
					if (!e.hasAttribute('selected')) {
						e.setAttribute('selected', '');
					}
				} else {
					e.removeAttribute('selected');
				}
			}
			function set_default_checked(e, t) {
				const r = e.checked;
				e.defaultChecked = t;
				e.checked = r;
			}
			function set_default_value(e, t) {
				const r = e.value;
				e.defaultValue = t;
				e.value = r;
			}
			function set_attribute(e, t, r, i) {
				var a = (e.__attributes ??= {});
				if (hydrating) {
					a[t] = e.getAttribute(t);
					if (t === 'src' || t === 'srcset' || (t === 'href' && e.nodeName === 'LINK')) {
						if (!i) {
							check_src_in_dev_hydration(e, t, r ?? '');
						}
						return;
					}
				}
				if (a[t] === (a[t] = r)) return;
				if (t === 'style' && '__styles' in e) {
					e.__styles = {};
				}
				if (t === 'loading') {
					e[LOADING_ATTR_SYMBOL] = r;
				}
				if (r == null) {
					e.removeAttribute(t);
				} else if (typeof r !== 'string' && get_setters(e).includes(t)) {
					e[t] = r;
				} else {
					e.setAttribute(t, r);
				}
			}
			function set_xlink_attribute(e, t, r) {
				e.setAttributeNS('http://www.w3.org/1999/xlink', t, r);
			}
			function set_custom_element_data(e, t, r) {
				var i = active_reaction;
				var a = active_effect;
				set_active_reaction(null);
				set_active_effect(null);
				try {
					if (
						U.has(e.nodeName) || !customElements || customElements.get(e.tagName.toLowerCase())
							? get_setters(e).includes(t)
							: r && typeof r === 'object'
					) {
						e[t] = r;
					} else {
						set_attribute(e, t, r == null ? r : String(r));
					}
				} finally {
					set_active_reaction(i);
					set_active_effect(a);
				}
			}
			function set_attributes(e, t, r, i, a = false, o = false, c = false) {
				var u = t || {};
				var l = e.tagName === 'OPTION';
				for (var d in t) {
					if (!(d in r)) {
						r[d] = null;
					}
				}
				if (r.class) {
					r.class = clsx(r.class);
				}
				if (i !== undefined) {
					r.class = r.class ? r.class + ' ' + i : i;
				}
				var p = get_setters(e);
				var m = (e.__attributes ??= {});
				for (const A in r) {
					let k = r[A];
					if (l && A === 'value' && k == null) {
						e.value = e.__value = '';
						u[A] = k;
						continue;
					}
					var g = u[A];
					if (k === g) continue;
					u[A] = k;
					var v = A[0] + A[1];
					if (v === '$$') continue;
					if (v === 'on') {
						const N = {};
						const T = '$$' + A;
						let x = A.slice(2);
						var y = is_delegated(x);
						if (is_capture_event(x)) {
							x = x.slice(0, -7);
							N.capture = true;
						}
						if (!y && g) {
							if (k != null) continue;
							e.removeEventListener(x, u[T], N);
							u[T] = null;
						}
						if (k != null) {
							if (!y) {
								function handle(e) {
									u[A].call(this, e);
								}
								u[T] = create_event(x, e, handle, N);
							} else {
								e[`__${x}`] = k;
								delegate([x]);
							}
						} else if (y) {
							e[`__${x}`] = undefined;
						}
					} else if (A === 'style' && k != null) {
						e.style.cssText = k + '';
					} else if (A === 'autofocus') {
						autofocus(e, Boolean(k));
					} else if (A === '__value' || (A === 'value' && k != null)) {
						e.value = e[A] = e.__value = k;
					} else if (A === 'selected' && l) {
						set_selected(e, k);
					} else {
						var w = A;
						if (!a) {
							w = normalize_attribute(w);
						}
						var _ = w === 'defaultValue' || w === 'defaultChecked';
						if (k == null && !o && !_) {
							m[A] = null;
							if (w === 'value' || w === 'checked') {
								let B = e;
								if (w === 'value') {
									let P = B.defaultValue;
									B.removeAttribute(w);
									B.defaultValue = P;
								} else {
									let M = B.defaultChecked;
									B.removeAttribute(w);
									B.defaultChecked = M;
								}
							} else {
								e.removeAttribute(A);
							}
						} else if (_ || (p.includes(w) && (o || typeof k !== 'string'))) {
							e[w] = k;
						} else if (typeof k !== 'function') {
							if (hydrating && (w === 'src' || w === 'href' || w === 'srcset')) {
								if (!c) check_src_in_dev_hydration(e, w, k ?? '');
							} else {
								set_attribute(e, w, k);
							}
						}
					}
					if (A === 'style' && '__styles' in e) {
						e.__styles = {};
					}
				}
				return u;
			}
			var U = new Map();
			function get_setters(e) {
				var t = U.get(e.nodeName);
				if (t) return t;
				U.set(e.nodeName, (t = []));
				var r;
				var i = e;
				var a = Element.prototype;
				while (a !== i) {
					r = get_descriptors(i);
					for (var o in r) {
						if (r[o].set) {
							t.push(o);
						}
					}
					i = get_prototype_of(i);
				}
				return t;
			}
			function check_src_in_dev_hydration(e, t, r) {
				if (!DEV) return;
				if (t === 'srcset' && srcset_url_equal(e, r)) return;
				if (src_url_equal(e.getAttribute(t) ?? '', r)) return;
				w.hydration_attribute_changed(
					t,
					e.outerHTML.replace(e.innerHTML, e.innerHTML && '...'),
					String(r)
				);
			}
			function src_url_equal(e, t) {
				if (e === t) return true;
				return new URL(e, document.baseURI).href === new URL(t, document.baseURI).href;
			}
			function split_srcset(e) {
				return e.split(',').map((e) => e.trim().split(' ').filter(Boolean));
			}
			function srcset_url_equal(e, t) {
				var r = split_srcset(e.srcset);
				var i = split_srcset(t);
				return (
					i.length === r.length &&
					i.every(
						([e, t], i) => t === r[i][1] && (src_url_equal(r[i][0], e) || src_url_equal(e, r[i][0]))
					)
				);
			}
			function handle_lazy_img(e) {
				if (!hydrating && e.loading === 'lazy') {
					var t = e.src;
					e[LOADING_ATTR_SYMBOL] = null;
					e.loading = 'eager';
					e.removeAttribute('src');
					requestAnimationFrame(() => {
						if (e[LOADING_ATTR_SYMBOL] !== 'eager') {
							e.loading = 'lazy';
						}
						e.src = t;
					});
				}
			}
			function set_svg_class(e, t, r) {
				var i = e.__className;
				var a = to_class(t, r);
				if (hydrating && e.getAttribute('class') === a) {
					e.__className = a;
				} else if (i !== a || (hydrating && e.getAttribute('class') !== a)) {
					if (a === '') {
						e.removeAttribute('class');
					} else {
						e.setAttribute('class', a);
					}
					e.__className = a;
				}
			}
			function set_mathml_class(e, t, r) {
				var i = e.__className;
				var a = to_class(t, r);
				if (hydrating && e.getAttribute('class') === a) {
					e.__className = a;
				} else if (i !== a || (hydrating && e.getAttribute('class') !== a)) {
					if (a === '') {
						e.removeAttribute('class');
					} else {
						e.setAttribute('class', a);
					}
					e.__className = a;
				}
			}
			function set_class(e, t, r) {
				var i = e.__className;
				var a = to_class(t, r);
				if (hydrating && e.className === a) {
					e.__className = a;
				} else if (i !== a || (hydrating && e.className !== a)) {
					if (t == null && !r) {
						e.removeAttribute('class');
					} else {
						e.className = a;
					}
					e.__className = a;
				}
			}
			function to_class(e, t) {
				return (e == null ? '' : e) + (t ? ' ' + t : '');
			}
			function toggle_class(e, t, r) {
				if (r) {
					if (e.classList.contains(t)) return;
					e.classList.add(t);
				} else {
					if (!e.classList.contains(t)) return;
					e.classList.remove(t);
				}
			}
			const j = true;
			const H = j ? () => performance.now() : () => Date.now();
			const z = {
				tick: (e) => (j ? requestAnimationFrame : A.lQ)(e),
				now: () => H(),
				tasks: new Set()
			};
			function run_tasks() {
				const e = raf.now();
				raf.tasks.forEach((t) => {
					if (!t.c(e)) {
						raf.tasks.delete(t);
						t.f();
					}
				});
				if (raf.tasks.size !== 0) {
					raf.tick(run_tasks);
				}
			}
			function loop_loop(e) {
				let t;
				if (raf.tasks.size === 0) {
					raf.tick(run_tasks);
				}
				return {
					promise: new Promise((r) => {
						raf.tasks.add((t = { c: e, f: r }));
					}),
					abort() {
						raf.tasks.delete(t);
					}
				};
			}
			function dispatch_event(e, t) {
				e.dispatchEvent(new CustomEvent(t));
			}
			function css_property_to_camelcase(e) {
				if (e === 'float') return 'cssFloat';
				if (e === 'offset') return 'cssOffset';
				if (e.startsWith('--')) return e;
				const t = e.split('-');
				if (t.length === 1) return t[0];
				return (
					t[0] +
					t
						.slice(1)
						.map((e) => e[0].toUpperCase() + e.slice(1))
						.join('')
				);
			}
			function css_to_keyframe(e) {
				const t = {};
				const r = e.split(';');
				for (const e of r) {
					const [r, i] = e.split(':');
					if (!r || i === undefined) break;
					const a = css_property_to_camelcase(r.trim());
					t[a] = i.trim();
				}
				return t;
			}
			const linear = (e) => e;
			function animation(e, t, r) {
				var i = current_each_item;
				var a;
				var o;
				var c;
				var u = null;
				i.a ??= {
					element: e,
					measure() {
						a = this.element.getBoundingClientRect();
					},
					apply() {
						c?.abort();
						o = this.element.getBoundingClientRect();
						if (
							a.left !== o.left ||
							a.right !== o.right ||
							a.top !== o.top ||
							a.bottom !== o.bottom
						) {
							const e = t()(this.element, { from: a, to: o }, r?.());
							c = animate(this.element, e, undefined, 1, () => {
								c?.abort();
								c = undefined;
							});
						}
					},
					fix() {
						if (e.getAnimations().length) return;
						var { position: t, width: r, height: i } = getComputedStyle(e);
						if (t !== 'absolute' && t !== 'fixed') {
							var o = e.style;
							u = {
								position: o.position,
								width: o.width,
								height: o.height,
								transform: o.transform
							};
							o.position = 'absolute';
							o.width = r;
							o.height = i;
							var c = e.getBoundingClientRect();
							if (a.left !== c.left || a.top !== c.top) {
								var l = `translate(${a.left - c.left}px, ${a.top - c.top}px)`;
								o.transform = o.transform ? `${o.transform} ${l}` : l;
							}
						}
					},
					unfix() {
						if (u) {
							var t = e.style;
							t.position = u.position;
							t.width = u.width;
							t.height = u.height;
							t.transform = u.transform;
						}
					}
				};
				i.a.element = e;
			}
			function transition(e, t, r, i) {
				var a = (e & TRANSITION_IN) !== 0;
				var o = (e & TRANSITION_OUT) !== 0;
				var c = a && o;
				var u = (e & TRANSITION_GLOBAL) !== 0;
				var l = c ? 'both' : a ? 'in' : 'out';
				var d;
				var p = t.inert;
				var m = t.style.overflow;
				var g;
				var v;
				function get_options() {
					var e = active_reaction;
					var a = active_effect;
					set_active_reaction(null);
					set_active_effect(null);
					try {
						return (d ??= r()(t, i?.() ?? {}, { direction: l }));
					} finally {
						set_active_reaction(e);
						set_active_effect(a);
					}
				}
				var y = {
					is_global: u,
					in() {
						t.inert = p;
						if (!a) {
							v?.abort();
							v?.reset?.();
							return;
						}
						if (!o) {
							g?.abort();
						}
						dispatch_event(t, 'introstart');
						g = animate(t, get_options(), v, 1, () => {
							dispatch_event(t, 'introend');
							g?.abort();
							g = d = undefined;
							t.style.overflow = m;
						});
					},
					out(e) {
						if (!o) {
							e?.();
							d = undefined;
							return;
						}
						t.inert = true;
						dispatch_event(t, 'outrostart');
						v = animate(t, get_options(), g, 0, () => {
							dispatch_event(t, 'outroend');
							e?.();
						});
					},
					stop: () => {
						g?.abort();
						v?.abort();
					}
				};
				var w = active_effect;
				(w.transitions ??= []).push(y);
				if (a && should_intro) {
					var _ = u;
					if (!_) {
						var A = w.parent;
						while (A && (A.f & EFFECT_TRANSPARENT) !== 0) {
							while ((A = A.parent)) {
								if ((A.f & BLOCK_EFFECT) !== 0) break;
							}
						}
						_ = !A || (A.f & EFFECT_RAN) !== 0;
					}
					if (_) {
						effect(() => {
							untrack(() => y.in());
						});
					}
				}
			}
			function animate(e, t, r, i, a) {
				var o = i === 1;
				if (is_function(t)) {
					var c;
					var u = false;
					queue_micro_task(() => {
						if (u) return;
						var l = t({ direction: o ? 'in' : 'out' });
						c = animate(e, l, r, i, a);
					});
					return {
						abort: () => {
							u = true;
							c?.abort();
						},
						deactivate: () => c.deactivate(),
						reset: () => c.reset(),
						t: () => c.t()
					};
				}
				r?.deactivate();
				if (!t?.duration) {
					a();
					return { abort: noop, deactivate: noop, reset: noop, t: () => i };
				}
				const { delay: l = 0, css: d, tick: p, easing: m = linear } = t;
				var g = [];
				if (o && r === undefined) {
					if (p) {
						p(0, 1);
					}
					if (d) {
						var v = css_to_keyframe(d(0, 1));
						g.push(v, v);
					}
				}
				var get_t = () => 1 - i;
				var y = e.animate(g, { duration: l });
				y.onfinish = () => {
					var o = r?.t() ?? 1 - i;
					r?.abort();
					var c = i - o;
					var u = t.duration * Math.abs(c);
					var l = [];
					if (u > 0) {
						var g = false;
						if (d) {
							var v = Math.ceil(u / (1e3 / 60));
							for (var w = 0; w <= v; w += 1) {
								var _ = o + c * m(w / v);
								var A = css_to_keyframe(d(_, 1 - _));
								l.push(A);
								g ||= A.overflow === 'hidden';
							}
						}
						if (g) {
							e.style.overflow = 'hidden';
						}
						get_t = () => {
							var e = y.currentTime;
							return o + c * m(e / u);
						};
						if (p) {
							loop(() => {
								if (y.playState !== 'running') return false;
								var e = get_t();
								p(e, 1 - e);
								return true;
							});
						}
					}
					y = e.animate(l, { duration: u, fill: 'forwards' });
					y.onfinish = () => {
						get_t = () => i;
						p?.(i, 1 - i);
						a();
					};
				};
				return {
					abort: () => {
						if (y) {
							y.cancel();
							y.effect = null;
							y.onfinish = noop;
						}
					},
					deactivate: () => {
						a = noop;
					},
					reset: () => {
						if (i === 0) {
							p?.(1, 0);
						}
					},
					t: () => get_t()
				};
			}
			var $ = i(9854);
			function bind_active_element(e) {
				listen(document, ['focusin', 'focusout'], (t) => {
					if (t && t.type === 'focusout' && t.relatedTarget) {
						return;
					}
					e(document.activeElement);
				});
			}
			var G = i(2387);
			function bind_value(t, r, i = r) {
				var a = is_runes();
				listen_to_event_and_reset_event(t, 'input', (o) => {
					if (DEV && t.type === 'checkbox') {
						e.bind_invalid_checkbox_value();
					}
					var c = o ? t.defaultValue : t.value;
					c = is_numberlike_input(t) ? to_number(c) : c;
					i(c);
					if (a && c !== (c = r())) {
						var u = t.selectionStart;
						var l = t.selectionEnd;
						t.value = c ?? '';
						if (l !== null) {
							t.selectionStart = u;
							t.selectionEnd = Math.min(l, t.value.length);
						}
					}
				});
				if ((hydrating && t.defaultValue !== t.value) || (untrack(r) == null && t.value)) {
					i(is_numberlike_input(t) ? to_number(t.value) : t.value);
				}
				render_effect(() => {
					if (DEV && t.type === 'checkbox') {
						e.bind_invalid_checkbox_value();
					}
					var i = r();
					if (is_numberlike_input(t) && i === to_number(t.value)) {
						return;
					}
					if (t.type === 'date' && !i && !t.value) {
						return;
					}
					if (i !== t.value) {
						t.value = i ?? '';
					}
				});
			}
			const q = new Set();
			function bind_group(e, t, r, i, a = i) {
				var o = r.getAttribute('type') === 'checkbox';
				var c = e;
				let u = false;
				if (t !== null) {
					for (var l of t) {
						c = c[l] ??= [];
					}
				}
				c.push(r);
				listen_to_event_and_reset_event(
					r,
					'change',
					() => {
						var e = r.__value;
						if (o) {
							e = get_binding_group_value(c, e, r.checked);
						}
						a(e);
					},
					() => a(o ? [] : null)
				);
				render_effect(() => {
					var e = i();
					if (hydrating && r.defaultChecked !== r.checked) {
						u = true;
						return;
					}
					if (o) {
						e = e || [];
						r.checked = e.includes(r.__value);
					} else {
						r.checked = is(r.__value, e);
					}
				});
				teardown(() => {
					var e = c.indexOf(r);
					if (e !== -1) {
						c.splice(e, 1);
					}
				});
				if (!q.has(c)) {
					q.add(c);
					queue_micro_task(() => {
						c.sort((e, t) => (e.compareDocumentPosition(t) === 4 ? -1 : 1));
						q.delete(c);
					});
				}
				queue_micro_task(() => {
					if (u) {
						var e;
						if (o) {
							e = get_binding_group_value(c, e, r.checked);
						} else {
							var t = c.find((e) => e.checked);
							e = t?.__value;
						}
						a(e);
					}
				});
			}
			function bind_checked(e, t, r = t) {
				listen_to_event_and_reset_event(e, 'change', (t) => {
					var i = t ? e.defaultChecked : e.checked;
					r(i);
				});
				if ((hydrating && e.defaultChecked !== e.checked) || untrack(t) == null) {
					r(e.checked);
				}
				render_effect(() => {
					var r = t();
					e.checked = Boolean(r);
				});
			}
			function get_binding_group_value(e, t, r) {
				var i = new Set();
				for (var a = 0; a < e.length; a += 1) {
					if (e[a].checked) {
						i.add(e[a].__value);
					}
				}
				if (!r) {
					i.delete(t);
				}
				return Array.from(i);
			}
			function is_numberlike_input(e) {
				var t = e.type;
				return t === 'number' || t === 'range';
			}
			function to_number(e) {
				return e === '' ? null : +e;
			}
			function bind_files(e, t, r = t) {
				listen_to_event_and_reset_event(e, 'change', () => {
					r(e.files);
				});
				render_effect(() => {
					e.files = t();
				});
			}
			function time_ranges_to_array(e) {
				var t = [];
				for (var r = 0; r < e.length; r += 1) {
					t.push({ start: e.start(r), end: e.end(r) });
				}
				return t;
			}
			function bind_current_time(e, t, r = t) {
				var i;
				var a;
				var callback = () => {
					cancelAnimationFrame(i);
					if (!e.paused) {
						i = requestAnimationFrame(callback);
					}
					var t = e.currentTime;
					if (a !== t) {
						r((a = t));
					}
				};
				i = requestAnimationFrame(callback);
				e.addEventListener('timeupdate', callback);
				render_effect(() => {
					var r = Number(t());
					if (a !== r && !isNaN(r)) {
						e.currentTime = a = r;
					}
				});
				teardown(() => {
					cancelAnimationFrame(i);
					e.removeEventListener('timeupdate', callback);
				});
			}
			function bind_buffered(e, t) {
				listen(e, ['loadedmetadata', 'progress'], () => t(time_ranges_to_array(e.buffered)));
			}
			function bind_seekable(e, t) {
				listen(e, ['loadedmetadata'], () => t(time_ranges_to_array(e.seekable)));
			}
			function bind_played(e, t) {
				listen(e, ['timeupdate'], () => t(time_ranges_to_array(e.played)));
			}
			function bind_seeking(e, t) {
				listen(e, ['seeking', 'seeked'], () => t(e.seeking));
			}
			function bind_ended(e, t) {
				listen(e, ['timeupdate', 'ended'], () => t(e.ended));
			}
			function bind_ready_state(e, t) {
				listen(
					e,
					[
						'loadedmetadata',
						'loadeddata',
						'canplay',
						'canplaythrough',
						'playing',
						'waiting',
						'emptied'
					],
					() => t(e.readyState)
				);
			}
			function bind_playback_rate(e, t, r = t) {
				effect(() => {
					var r = Number(t());
					if (r !== e.playbackRate && !isNaN(r)) {
						e.playbackRate = r;
					}
				});
				effect(() => {
					listen(e, ['ratechange'], () => {
						r(e.playbackRate);
					});
				});
			}
			function bind_paused(e, t, r = t) {
				var i = t();
				var update = () => {
					if (i !== e.paused) {
						r((i = e.paused));
					}
				};
				listen(e, ['play', 'pause', 'canplay'], update, i == null);
				effect(() => {
					if ((i = !!t()) !== e.paused) {
						if (i) {
							e.pause();
						} else {
							e.play().catch(() => {
								r((i = true));
							});
						}
					}
				});
			}
			function bind_volume(e, t, r = t) {
				var callback = () => {
					r(e.volume);
				};
				if (t() == null) {
					callback();
				}
				listen(e, ['volumechange'], callback, false);
				render_effect(() => {
					var r = Number(t());
					if (r !== e.volume && !isNaN(r)) {
						e.volume = r;
					}
				});
			}
			function bind_muted(e, t, r = t) {
				var callback = () => {
					r(e.muted);
				};
				if (t() == null) {
					callback();
				}
				listen(e, ['volumechange'], callback, false);
				render_effect(() => {
					var r = !!t();
					if (e.muted !== r) e.muted = r;
				});
			}
			function bind_online(e) {
				listen(window, ['online', 'offline'], () => {
					e(navigator.onLine);
				});
			}
			function bind_prop(e, t, r) {
				var i = get_descriptor(e, t);
				if (i && i.set) {
					e[t] = r;
					teardown(() => {
						e[t] = null;
					});
				}
			}
			function select_option(e, t, r) {
				if (e.multiple) {
					return select_options(e, t);
				}
				for (var i of e.options) {
					var a = get_option_value(i);
					if (is(a, t)) {
						i.selected = true;
						return;
					}
				}
				if (!r || t !== undefined) {
					e.selectedIndex = -1;
				}
			}
			function init_select(e, t) {
				let r = true;
				effect(() => {
					if (t) {
						select_option(e, untrack(t), r);
					}
					r = false;
					var i = new MutationObserver(() => {
						var t = e.__value;
						select_option(e, t);
					});
					i.observe(e, {
						childList: true,
						subtree: true,
						attributes: true,
						attributeFilter: ['value']
					});
					return () => {
						i.disconnect();
					};
				});
			}
			function bind_select_value(e, t, r = t) {
				var i = true;
				listen_to_event_and_reset_event(e, 'change', (t) => {
					var i = t ? '[selected]' : ':checked';
					var a;
					if (e.multiple) {
						a = [].map.call(e.querySelectorAll(i), get_option_value);
					} else {
						var o = e.querySelector(i) ?? e.querySelector('option:not([disabled])');
						a = o && get_option_value(o);
					}
					r(a);
				});
				effect(() => {
					var a = t();
					select_option(e, a, i);
					if (i && a === undefined) {
						var o = e.querySelector(':checked');
						if (o !== null) {
							a = get_option_value(o);
							r(a);
						}
					}
					e.__value = a;
					i = false;
				});
				init_select(e);
			}
			function select_options(e, t) {
				for (var r of e.options) {
					r.selected = ~t.indexOf(get_option_value(r));
				}
			}
			function get_option_value(e) {
				if ('__value' in e) {
					return e.__value;
				} else {
					return e.value;
				}
			}
			class ResizeObserverSingleton {
				#C = new WeakMap();
				#Rt;
				#w;
				static entries = new WeakMap();
				constructor(e) {
					this.#w = e;
				}
				observe(e, t) {
					var r = this.#C.get(e) || new Set();
					r.add(t);
					this.#C.set(e, r);
					this.#Pt().observe(e, this.#w);
					return () => {
						var r = this.#C.get(e);
						r.delete(t);
						if (r.size === 0) {
							this.#C.delete(e);
							this.#Rt.unobserve(e);
						}
					};
				}
				#Pt() {
					return (
						this.#Rt ??
						(this.#Rt = new ResizeObserver((e) => {
							for (var t of e) {
								ResizeObserverSingleton.entries.set(t.target, t);
								for (var r of this.#C.get(t.target) || []) {
									r(t);
								}
							}
						}))
					);
				}
			}
			var V = new ResizeObserverSingleton({ box: 'content-box' });
			var W = new ResizeObserverSingleton({ box: 'border-box' });
			var J = new ResizeObserverSingleton({ box: 'device-pixel-content-box' });
			function bind_resize_observer(e, t, r) {
				var i = t === 'contentRect' || t === 'contentBoxSize' ? V : t === 'borderBoxSize' ? W : J;
				var a = i.observe(e, (e) => r(e[t]));
				teardown(a);
			}
			function bind_element_size(e, t, r) {
				var i = W.observe(e, () => r(e[t]));
				effect(() => {
					untrack(() => r(e[t]));
					return i;
				});
			}
			function is_bound_this(e, t) {
				return e === t || e?.[STATE_SYMBOL] === t;
			}
			function bind_this(e = {}, t, r, i) {
				effect(() => {
					var a;
					var o;
					render_effect(() => {
						a = o;
						o = i?.() || [];
						untrack(() => {
							if (e !== r(...o)) {
								t(e, ...o);
								if (a && is_bound_this(r(...a), e)) {
									t(null, ...a);
								}
							}
						});
					});
					return () => {
						queue_micro_task(() => {
							if (o && is_bound_this(r(...o), e)) {
								t(null, ...o);
							}
						});
					};
				});
				return e;
			}
			function bind_content_editable(e, t, r, i = r) {
				t.addEventListener('input', () => {
					i(t[e]);
				});
				render_effect(() => {
					var a = r();
					if (t[e] !== a) {
						if (a == null) {
							var o = t[e];
							i(o);
						} else {
							t[e] = a + '';
						}
					}
				});
			}
			function bind_property(e, t, r, i, a) {
				var handler = () => {
					i(r[e]);
				};
				r.addEventListener(t, handler);
				if (a) {
					render_effect(() => {
						r[e] = a();
					});
				} else {
					handler();
				}
				if (r === document.body || r === window || r === document) {
					teardown(() => {
						r.removeEventListener(t, handler);
					});
				}
			}
			function bind_focused(e, t) {
				listen(e, ['focus', 'blur'], () => {
					t(e === document.activeElement);
				});
			}
			function bind_window_scroll(e, t, r = t) {
				var i = e === 'x';
				var target_handler = () =>
					without_reactive_context(() => {
						a = true;
						clearTimeout(o);
						o = setTimeout(clear, 100);
						r(window[i ? 'scrollX' : 'scrollY']);
					});
				addEventListener('scroll', target_handler, { passive: true });
				var a = false;
				var o;
				var clear = () => {
					a = false;
				};
				var c = true;
				render_effect(() => {
					var e = t();
					if (c) {
						c = false;
					} else if (!a && e != null) {
						a = true;
						clearTimeout(o);
						if (i) {
							scrollTo(e, window.scrollY);
						} else {
							scrollTo(window.scrollX, e);
						}
						o = setTimeout(clear, 100);
					}
				});
				effect(target_handler);
				teardown(() => {
					removeEventListener('scroll', target_handler);
				});
			}
			function bind_window_size(e, t) {
				listen(window, ['resize'], () => without_reactive_context(() => t(window[e])));
			}
			function trusted(e) {
				return function (...t) {
					var r = t[0];
					if (r.isTrusted) {
						e?.apply(this, t);
					}
				};
			}
			function event_modifiers_self(e) {
				return function (...t) {
					var r = t[0];
					if (r.target === this) {
						e?.apply(this, t);
					}
				};
			}
			function stopPropagation(e) {
				return function (...t) {
					var r = t[0];
					r.stopPropagation();
					return e?.apply(this, t);
				};
			}
			function once(e) {
				var t = false;
				return function (...r) {
					if (t) return;
					t = true;
					return e?.apply(this, r);
				};
			}
			function stopImmediatePropagation(e) {
				return function (...t) {
					var r = t[0];
					r.stopImmediatePropagation();
					return e?.apply(this, t);
				};
			}
			function preventDefault(e) {
				return function (...t) {
					var r = t[0];
					r.preventDefault();
					return e?.apply(this, t);
				};
			}
			function passive(e, [t, r]) {
				user_pre_effect(() => on(e, t, r() ?? noop, { passive: true }));
			}
			function nonpassive(e, [t, r]) {
				user_pre_effect(() => on(e, t, r() ?? noop, { passive: false }));
			}
			function init(e = false) {
				const t = component_context;
				const r = t.l.u;
				if (!r) return;
				let props = () => deep_read_state(t.s);
				if (e) {
					let e = 0;
					let r = {};
					const i = derived(() => {
						let i = false;
						const a = t.s;
						for (const e in a) {
							if (a[e] !== r[e]) {
								r[e] = a[e];
								i = true;
							}
						}
						if (i) e++;
						return e;
					});
					props = () => get(i);
				}
				if (r.b.length) {
					user_pre_effect(() => {
						observe_all(t, props);
						run_all(r.b);
					});
				}
				user_effect(() => {
					const e = untrack(() => r.m.map(run));
					return () => {
						for (const t of e) {
							if (typeof t === 'function') {
								t();
							}
						}
					};
				});
				if (r.a.length) {
					user_effect(() => {
						observe_all(t, props);
						run_all(r.a);
					});
				}
			}
			function observe_all(e, t) {
				if (e.l.s) {
					for (const t of e.l.s) get(t);
				}
				t();
			}
			function reactive_import(e) {
				var t = source(0);
				return function () {
					if (arguments.length === 1) {
						set(t, get(t) + 1);
						return arguments[0];
					} else {
						get(t);
						return e();
					}
				};
			}
			function bubble_event(e, t) {
				var r = e.$$events?.[t.type];
				var i = is_array(r) ? r.slice() : r == null ? [] : [r];
				for (var a of i) {
					a.call(this, t);
				}
			}
			function add_legacy_event_listener(e, t, r) {
				e.$$events ||= {};
				e.$$events[t] ||= [];
				e.$$events[t].push(r);
			}
			function update_legacy_props(e) {
				for (var t in e) {
					if (t in this) {
						this[t] = e[t];
					}
				}
			}
			var Z = i(235);
			var Q = i(2190);
			var Y = i(8048);
			var X = i(3370);
			var ee = i(3757);
			let te = false;
			let re = Symbol();
			function store_get(e, t, r) {
				const i = (r[t] ??= { store: null, source: mutable_source(undefined), unsubscribe: noop });
				if (i.store !== e && !(re in r)) {
					i.unsubscribe();
					i.store = e ?? null;
					if (e == null) {
						i.source.v = undefined;
						i.unsubscribe = noop;
					} else {
						var a = true;
						i.unsubscribe = subscribe_to_store(e, (e) => {
							if (a) {
								i.source.v = e;
							} else {
								set(i.source, e);
							}
						});
						a = false;
					}
				}
				if (e && re in r) {
					return get_store(e);
				}
				return get(i.source);
			}
			function store_unsub(e, t, r) {
				let i = r[t];
				if (i && i.store !== e) {
					i.unsubscribe();
					i.unsubscribe = noop;
				}
				return e;
			}
			function store_set(e, t) {
				e.set(t);
				return t;
			}
			function invalidate_store(e, t) {
				var r = e[t];
				if (r.store !== null) {
					store_set(r.store, r.source.v);
				}
			}
			function setup_stores() {
				const e = {};
				function cleanup() {
					teardown(() => {
						for (var t in e) {
							const r = e[t];
							r.unsubscribe();
						}
						define_property(e, re, { enumerable: false, value: true });
					});
				}
				return [e, cleanup];
			}
			function store_mutate(e, t, r) {
				e.set(r);
				return t;
			}
			function update_store(e, t, r = 1) {
				e.set(t + r);
				return t;
			}
			function update_pre_store(e, t, r = 1) {
				const i = t + r;
				e.set(i);
				return i;
			}
			function mark_store_binding() {
				te = true;
			}
			function store_capture_store_binding(e) {
				var t = te;
				try {
					te = false;
					return [e(), te];
				} finally {
					te = t;
				}
			}
			var ne = i(1779);
			function update_prop(e, t = 1) {
				const r = e();
				e(r + t);
				return r;
			}
			function update_pre_prop(e, t = 1) {
				const r = e() + t;
				e(r);
				return r;
			}
			const ie = {
				get(e, t) {
					if (e.exclude.includes(t)) return;
					return e.props[t];
				},
				set(e, t) {
					if (Z.A) {
						Y.js(`${e.name}.${String(t)}`);
					}
					return false;
				},
				getOwnPropertyDescriptor(e, t) {
					if (e.exclude.includes(t)) return;
					if (t in e.props) {
						return { enumerable: true, configurable: true, value: e.props[t] };
					}
				},
				has(e, t) {
					if (e.exclude.includes(t)) return false;
					return t in e.props;
				},
				ownKeys(e) {
					return Reflect.ownKeys(e.props).filter((t) => !e.exclude.includes(t));
				}
			};
			function rest_props(e, t, r) {
				return new Proxy(
					DEV
						? { props: e, exclude: t, name: r, other: {}, to_proxy: [] }
						: { props: e, exclude: t },
					ie
				);
			}
			const se = {
				get(e, t) {
					if (e.exclude.includes(t)) return;
					(0, c.Jt)(e.version);
					return t in e.special ? e.special[t]() : e.props[t];
				},
				set(e, t, r) {
					if (!(t in e.special)) {
						e.special[t] = prop(
							{
								get [t]() {
									return e.props[t];
								}
							},
							t,
							a.kI
						);
					}
					e.special[t](r);
					(0, c.yo)(e.version);
					return true;
				},
				getOwnPropertyDescriptor(e, t) {
					if (e.exclude.includes(t)) return;
					if (t in e.props) {
						return { enumerable: true, configurable: true, value: e.props[t] };
					}
				},
				deleteProperty(e, t) {
					if (e.exclude.includes(t)) return true;
					e.exclude.push(t);
					(0, c.yo)(e.version);
					return true;
				},
				has(e, t) {
					if (e.exclude.includes(t)) return false;
					return t in e.props;
				},
				ownKeys(e) {
					return Reflect.ownKeys(e.props).filter((t) => !e.exclude.includes(t));
				}
			};
			function legacy_rest_props(e, t) {
				return new Proxy({ props: e, exclude: t, special: {}, version: source(0) }, se);
			}
			const ae = {
				get(e, t) {
					let r = e.props.length;
					while (r--) {
						let i = e.props[r];
						if ((0, A.Qk)(i)) i = i();
						if (typeof i === 'object' && i !== null && t in i) return i[t];
					}
				},
				set(e, t, r) {
					let i = e.props.length;
					while (i--) {
						let a = e.props[i];
						if ((0, A.Qk)(a)) a = a();
						const o = (0, A.J8)(a, t);
						if (o && o.set) {
							o.set(r);
							return true;
						}
					}
					return false;
				},
				getOwnPropertyDescriptor(e, t) {
					let r = e.props.length;
					while (r--) {
						let i = e.props[r];
						if ((0, A.Qk)(i)) i = i();
						if (typeof i === 'object' && i !== null && t in i) {
							const e = (0, A.J8)(i, t);
							if (e && !e.configurable) {
								e.configurable = true;
							}
							return e;
						}
					}
				},
				has(e, t) {
					if (t === d.x3 || t === d.l3) return false;
					for (let r of e.props) {
						if ((0, A.Qk)(r)) r = r();
						if (r != null && t in r) return true;
					}
					return false;
				},
				ownKeys(e) {
					const t = [];
					for (let r of e.props) {
						if ((0, A.Qk)(r)) r = r();
						for (const e in r) {
							if (!t.includes(e)) t.push(e);
						}
					}
					return t;
				}
			};
			function spread_props(...e) {
				return new Proxy({ props: e }, ae);
			}
			function with_parent_branch(e) {
				var t = c.Fg;
				var r = c.Fg;
				while (t !== null && (t.f & (d.Zr | d.FV)) === 0) {
					t = t.parent;
				}
				try {
					(0, c.gU)(t);
					return e();
				} finally {
					(0, c.gU)(r);
				}
			}
			function prop(e, t, r, i) {
				var o = (r & a.Ve) !== 0;
				var u = !ne.LM || (r & a.uc) !== 0;
				var l = (r & a.wP) !== 0;
				var p = (r & a._b) !== 0;
				var g = false;
				var v;
				if (l) {
					[v, g] = store_capture_store_binding(() => e[t]);
				} else {
					v = e[t];
				}
				var y = d.x3 in e || d.l3 in e;
				var w = (l && ((0, A.J8)(e, t)?.set ?? (y && t in e && ((r) => (e[t] = r))))) || undefined;
				var _ = i;
				var k = true;
				var N = false;
				var get_fallback = () => {
					N = true;
					if (k) {
						k = false;
						if (p) {
							_ = (0, c.vz)(i);
						} else {
							_ = i;
						}
					}
					return _;
				};
				if (v === undefined && i !== undefined) {
					if (w && u) {
						Y.vo(t);
					}
					v = get_fallback();
					if (w) w(v);
				}
				var T;
				if (u) {
					T = () => {
						var r = e[t];
						if (r === undefined) return get_fallback();
						k = true;
						N = false;
						return r;
					};
				} else {
					var x = with_parent_branch(() => (o ? P.un : P.Xd)(() => e[t]));
					x.f |= d.OG;
					T = () => {
						var e = (0, c.Jt)(x);
						if (e !== undefined) _ = undefined;
						return e === undefined ? _ : e;
					};
				}
				if ((r & a.kI) === 0) {
					return T;
				}
				if (w) {
					var B = e.$$legacy;
					return function (e, t) {
						if (arguments.length > 0) {
							if (!u || !t || B || g) {
								w(t ? T() : e);
							}
							return e;
						} else {
							return T();
						}
					};
				}
				var M = false;
				var C = false;
				var I = (0, m.zg)(v);
				var O = with_parent_branch(() =>
					(0, P.un)(() => {
						var e = T();
						var t = (0, c.Jt)(I);
						if (M) {
							M = false;
							C = true;
							return t;
						}
						C = false;
						return (I.v = e);
					})
				);
				if (!o) O.equals = Q.Og;
				return function (e, t) {
					if (c.JY !== null) {
						M = C;
						T();
						(0, c.Jt)(I);
					}
					if (arguments.length > 0) {
						const r = t ? (0, c.Jt)(O) : u && l ? (0, G.B)(e) : e;
						if (!O.equals(r)) {
							M = true;
							(0, m.hZ)(I, r);
							if (N && _ !== undefined) {
								_ = r;
							}
							(0, c.vz)(() => (0, c.Jt)(O));
						}
						return e;
					}
					return (0, c.Jt)(O);
				};
			}
			function with_boundary(e, t) {
				var r = active_effect;
				var i = active_reaction;
				var a = component_context;
				set_active_effect(e);
				set_active_reaction(e);
				set_component_context(e.ctx);
				try {
					t();
				} finally {
					set_active_effect(r);
					set_active_reaction(i);
					set_component_context(a);
				}
			}
			function boundary(e, t, r) {
				var i = e;
				var a;
				block(() => {
					var e = active_effect;
					var o = hydrate_node;
					var c = false;
					e.fn = (u) => {
						var l = t.onerror;
						let d = t.failed;
						if ((!l && !d) || c) {
							throw u;
						}
						var reset = () => {
							pause_effect(a);
							with_boundary(e, () => {
								c = false;
								a = branch(() => r(i));
								reset_is_throwing_error();
							});
						};
						l?.(u, reset);
						if (a) {
							destroy_effect(a);
						} else if (hydrating) {
							set_hydrate_node(o);
							next();
							set_hydrate_node(remove_nodes());
						}
						if (d) {
							queue_micro_task(() => {
								with_boundary(e, () => {
									c = true;
									try {
										a = branch(() => {
											d(
												i,
												() => u,
												() => reset
											);
										});
									} catch (t) {
										handle_error(t, e, null, e.ctx);
									}
									reset_is_throwing_error();
									c = false;
								});
							});
						}
					};
					if (hydrating) {
						hydrate_next();
					}
					a = branch(() => r(i));
					reset_is_throwing_error();
				}, EFFECT_TRANSPARENT | BOUNDARY_EFFECT);
				if (hydrating) {
					i = hydrate_node;
				}
			}
			function validate_each_keys(t, r) {
				render_effect(() => {
					const i = new Map();
					const a = t();
					const o = is_array(a) ? a : a == null ? [] : Array.from(a);
					const c = o.length;
					for (let t = 0; t < c; t++) {
						const a = r(o[t], t);
						if (i.has(a)) {
							const r = String(i.get(a));
							const o = String(t);
							let c = String(a);
							if (c.startsWith('[object ')) c = null;
							e.each_key_duplicate(r, o, c);
						}
						i.set(a, t);
					}
				});
			}
			function validate_binding(e, t, r, i, a) {
				var o = false;
				var c = dev_current_component_function?.[FILENAME];
				render_effect(() => {
					if (o) return;
					var [u, l] = capture_store_binding(t);
					if (l) return;
					var d = r();
					var p = false;
					var m = render_effect(() => {
						if (p) return;
						u[d];
					});
					p = true;
					if (m.deps === null) {
						var g = `${c}:${i}:${a}`;
						w.binding_property_non_reactive(e, g);
						o = true;
					}
				});
			}
			function createClassComponent(e) {
				return new Svelte4Component(e);
			}
			function asClassComponent(e) {
				return class extends Svelte4Component {
					constructor(t) {
						super({ component: e, ...t });
					}
				};
			}
			class Svelte4Component {
				#m;
				#Mt;
				constructor(e) {
					var t = new Map();
					var add_source = (e, r) => {
						var i = (0, m.zg)(r);
						t.set(e, i);
						return i;
					};
					const r = new Proxy(
						{ ...(e.props || {}), $$events: {} },
						{
							get(e, r) {
								return (0, c.Jt)(t.get(r) ?? add_source(r, Reflect.get(e, r)));
							},
							has(e, r) {
								if (r === d.l3) return true;
								(0, c.Jt)(t.get(r) ?? add_source(r, Reflect.get(e, r)));
								return Reflect.has(e, r);
							},
							set(e, r, i) {
								(0, m.hZ)(t.get(r) ?? add_source(r, i), i);
								return Reflect.set(e, r, i);
							}
						}
					);
					this.#Mt = (e.hydrate ? g.Qv : g.Or)(e.component, {
						target: e.target,
						anchor: e.anchor,
						props: r,
						context: e.context,
						intro: e.intro ?? false,
						recover: e.recover
					});
					if (!e?.props?.$$host || e.sync === false) {
						(0, c.DB)();
					}
					this.#m = r.$$events;
					for (const e of Object.keys(this.#Mt)) {
						if (e === '$set' || e === '$destroy' || e === '$on') continue;
						(0, A.Qu)(this, e, {
							get() {
								return this.#Mt[e];
							},
							set(t) {
								this.#Mt[e] = t;
							},
							enumerable: true
						});
					}
					this.#Mt.$set = (e) => {
						Object.assign(r, e);
					};
					this.#Mt.$destroy = () => {
						(0, g.vs)(this.#Mt);
					};
				}
				$set(e) {
					this.#Mt.$set(e);
				}
				$on(e, t) {
					this.#m[e] = this.#m[e] || [];
					const cb = (...e) => t.call(this, ...e);
					this.#m[e].push(cb);
					return () => {
						this.#m[e] = this.#m[e].filter((e) => e !== cb);
					};
				}
				$destroy() {
					this.#Mt.$destroy();
				}
			}
			function legacy_client_run(e) {
				user_pre_effect(() => {
					e();
					var t = active_effect;
					if ((t.f & DIRTY) !== 0) {
						let e = "a file (we can't know which one)";
						if (DEV) {
							e = dev_current_component_function?.[FILENAME] ?? e;
						}
						w.legacy_recursive_reactive_block(e);
						set_signal_status(t, MAYBE_DIRTY);
					}
				});
			}
			function handlers(...e) {
				return function (t) {
					const { stopImmediatePropagation: r } = t;
					let i = false;
					t.stopImmediatePropagation = () => {
						i = true;
						r.call(t);
					};
					const a = [];
					for (const r of e) {
						try {
							r?.call(this, t);
						} catch (e) {
							a.push(e);
						}
						if (i) {
							break;
						}
					}
					for (let e of a) {
						queueMicrotask(() => {
							throw e;
						});
					}
				};
			}
			function createBubbler() {
				const e = component_context;
				if (e === null) {
					lifecycle_outside_component('createBubbler');
				}
				return (t) => (r) => {
					const i = e.s.$$events?.[t];
					if (i) {
						const t = is_array(i) ? i.slice() : [i];
						for (const i of t) {
							i.call(e.x, r);
						}
						return !r.defaultPrevented;
					}
					return true;
				};
			}
			let oe;
			if (typeof HTMLElement === 'function') {
				oe = class extends HTMLElement {
					$$ctor;
					$$s;
					$$c;
					$$cn = false;
					$$d = {};
					$$r = false;
					$$p_d = {};
					$$l = {};
					$$l_u = new Map();
					$$me;
					constructor(e, t, r) {
						super();
						this.$$ctor = e;
						this.$$s = t;
						if (r) {
							this.attachShadow({ mode: 'open' });
						}
					}
					addEventListener(e, t, r) {
						this.$$l[e] = this.$$l[e] || [];
						this.$$l[e].push(t);
						if (this.$$c) {
							const r = this.$$c.$on(e, t);
							this.$$l_u.set(t, r);
						}
						super.addEventListener(e, t, r);
					}
					removeEventListener(e, t, r) {
						super.removeEventListener(e, t, r);
						if (this.$$c) {
							const e = this.$$l_u.get(t);
							if (e) {
								e();
								this.$$l_u.delete(t);
							}
						}
					}
					async connectedCallback() {
						this.$$cn = true;
						if (!this.$$c) {
							await Promise.resolve();
							if (!this.$$cn || this.$$c) {
								return;
							}
							function create_slot(e) {
								return (t) => {
									const r = document.createElement('slot');
									if (e !== 'default') r.name = e;
									(0, C.BC)(t, r);
								};
							}
							const e = {};
							const t = get_custom_elements_slots(this);
							for (const r of this.$$s) {
								if (r in t) {
									if (r === 'default' && !this.$$d.children) {
										this.$$d.children = create_slot(r);
										e.default = true;
									} else {
										e[r] = create_slot(r);
									}
								}
							}
							for (const i of this.attributes) {
								const a = this.$$g_p(i.name);
								if (!(a in this.$$d)) {
									this.$$d[a] = get_custom_element_value(a, i.value, this.$$p_d, 'toProp');
								}
							}
							for (const o in this.$$p_d) {
								if (!(o in this.$$d) && this[o] !== undefined) {
									this.$$d[o] = this[o];
									delete this[o];
								}
							}
							this.$$c = createClassComponent({
								component: this.$$ctor,
								target: this.shadowRoot || this,
								props: { ...this.$$d, $$slots: e, $$host: this }
							});
							this.$$me = (0, p.Fc)(() => {
								(0, p.VB)(() => {
									this.$$r = true;
									for (const e of (0, A.d$)(this.$$c)) {
										if (!this.$$p_d[e]?.reflect) continue;
										this.$$d[e] = this.$$c[e];
										const t = get_custom_element_value(e, this.$$d[e], this.$$p_d, 'toAttribute');
										if (t == null) {
											this.removeAttribute(this.$$p_d[e].attribute || e);
										} else {
											this.setAttribute(this.$$p_d[e].attribute || e, t);
										}
									}
									this.$$r = false;
								});
							});
							for (const c in this.$$l) {
								for (const u of this.$$l[c]) {
									const l = this.$$c.$on(c, u);
									this.$$l_u.set(u, l);
								}
							}
							this.$$l = {};
						}
					}
					attributeChangedCallback(e, t, r) {
						if (this.$$r) return;
						e = this.$$g_p(e);
						this.$$d[e] = get_custom_element_value(e, r, this.$$p_d, 'toProp');
						this.$$c?.$set({ [e]: this.$$d[e] });
					}
					disconnectedCallback() {
						this.$$cn = false;
						Promise.resolve().then(() => {
							if (!this.$$cn && this.$$c) {
								this.$$c.$destroy();
								this.$$me();
								this.$$c = undefined;
							}
						});
					}
					$$g_p(e) {
						return (
							(0, A.d$)(this.$$p_d).find(
								(t) =>
									this.$$p_d[t].attribute === e ||
									(!this.$$p_d[t].attribute && t.toLowerCase() === e)
							) || e
						);
					}
				};
			}
			function get_custom_element_value(e, t, r, i) {
				const a = r[e]?.type;
				t = a === 'Boolean' && typeof t !== 'boolean' ? t != null : t;
				if (!i || !r[e]) {
					return t;
				} else if (i === 'toAttribute') {
					switch (a) {
						case 'Object':
						case 'Array':
							return t == null ? null : JSON.stringify(t);
						case 'Boolean':
							return t ? '' : null;
						case 'Number':
							return t == null ? null : t;
						default:
							return t;
					}
				} else {
					switch (a) {
						case 'Object':
						case 'Array':
							return t && JSON.parse(t);
						case 'Boolean':
							return t;
						case 'Number':
							return t != null ? +t : t;
						default:
							return t;
					}
				}
			}
			function get_custom_elements_slots(e) {
				const t = {};
				e.childNodes.forEach((e) => {
					t[e.slot || 'default'] = true;
				});
				return t;
			}
			function create_custom_element(e, t, r, i, a, o) {
				let c = class extends oe {
					constructor() {
						super(e, r, a);
						this.$$p_d = t;
					}
					static get observedAttributes() {
						return object_keys(t).map((e) => (t[e].attribute || e).toLowerCase());
					}
				};
				object_keys(t).forEach((e) => {
					define_property(c.prototype, e, {
						get() {
							return this.$$c && e in this.$$c ? this.$$c[e] : this.$$d[e];
						},
						set(r) {
							r = get_custom_element_value(e, r, t);
							this.$$d[e] = r;
							var i = this.$$c;
							if (i) {
								var a = get_descriptor(i, e)?.get;
								if (a) {
									i[e] = r;
								} else {
									i.$set({ [e]: r });
								}
							}
						}
					});
				});
				i.forEach((e) => {
					define_property(c.prototype, e, {
						get() {
							return this.$$c?.[e];
						}
					});
				});
				if (o) {
					c = o(c);
				}
				e.element = c;
				return c;
			}
			function validate_void_dynamic_element(e) {
				const t = e();
				if (t && is_void(t)) {
					w.dynamic_void_element_content(t);
				}
			}
			function validate_dynamic_element_tag(t) {
				const r = t();
				const i = typeof r === 'string';
				if (r && !i) {
					e.svelte_element_invalid_this_value();
				}
			}
			function validate_store(t, r) {
				if (t != null && typeof t.subscribe !== 'function') {
					e.store_invalid_shape(r);
				}
			}
			var ce = i(9543);
			function log_if_contains_state(e, ...t) {
				untrack(() => {
					try {
						let r = false;
						const i = [];
						for (const e of t) {
							if (e && typeof e === 'object' && STATE_SYMBOL in e) {
								i.push(snapshot(e, true));
								r = true;
							} else {
								i.push(e);
							}
						}
						if (r) {
							w.console_log_state(e);
							console.log('%c[snapshot]', 'color: grey', ...i);
						}
					} catch {}
				});
				return t;
			}
		},
		2387: (e, t, r) => {
			'use strict';
			r.d(t, { B: () => proxy, N: () => get_proxied_value });
			var i = r(235);
			var a = r(1951);
			var o = r(5372);
			var c = r(3546);
			var u = r(9246);
			var l = r(6410);
			var d = r(8940);
			var p = r(8048);
			var m = r(8969);
			var g = r(1779);
			function proxy(e, t = null, r) {
				var v = null;
				if (i.A && g._G) {
					v = (0, m.sv)('CreatedAt');
				}
				if (typeof e !== 'object' || e === null || l.x3 in e) {
					return e;
				}
				const y = (0, o.Oh)(e);
				if (y !== o.N7 && y !== o.ve) {
					return e;
				}
				var w = new Map();
				var _ = (0, o.PI)(e);
				var A = (0, u.sP)(0);
				if (_) {
					w.set('length', (0, u.sP)(e.length, v));
				}
				var k;
				if (i.A) {
					k = { parent: t, owners: null };
					if (r) {
						const e = r.v?.[l.XV]?.owners;
						k.owners = e ? new Set(e) : null;
					} else {
						k.owners = t === null ? (a.UL !== null ? new Set([a.UL.function]) : null) : new Set();
					}
				}
				return new Proxy(e, {
					defineProperty(e, t, r) {
						if (
							!('value' in r) ||
							r.configurable === false ||
							r.enumerable === false ||
							r.writable === false
						) {
							p.Uw();
						}
						var i = w.get(t);
						if (i === undefined) {
							i = (0, u.sP)(r.value, v);
							w.set(t, i);
						} else {
							(0, u.hZ)(i, proxy(r.value, k));
						}
						return true;
					},
					deleteProperty(e, t) {
						var r = w.get(t);
						if (r === undefined) {
							if (t in e) {
								w.set(t, (0, u.sP)(d.UP, v));
							}
						} else {
							if (_ && typeof t === 'string') {
								var i = w.get('length');
								var a = Number(t);
								if (Number.isInteger(a) && a < i.v) {
									(0, u.hZ)(i, a);
								}
							}
							(0, u.hZ)(r, d.UP);
							update_version(A);
						}
						return true;
					},
					get(t, r, p) {
						if (i.A && r === l.XV) {
							return k;
						}
						if (r === l.x3) {
							return e;
						}
						var m = w.get(r);
						var g = r in t;
						if (m === undefined && (!g || (0, o.J8)(t, r)?.writable)) {
							m = (0, u.sP)(proxy(g ? t[r] : d.UP, k), v);
							w.set(r, m);
						}
						if (m !== undefined) {
							var y = (0, a.Jt)(m);
							if (i.A) {
								var _ = y?.[l.XV];
								if (_ && _?.parent !== k) {
									(0, c.an)(k, _);
								}
							}
							return y === d.UP ? undefined : y;
						}
						return Reflect.get(t, r, p);
					},
					getOwnPropertyDescriptor(e, t) {
						var r = Reflect.getOwnPropertyDescriptor(e, t);
						if (r && 'value' in r) {
							var i = w.get(t);
							if (i) r.value = (0, a.Jt)(i);
						} else if (r === undefined) {
							var o = w.get(t);
							var c = o?.v;
							if (o !== undefined && c !== d.UP) {
								return { enumerable: true, configurable: true, value: c, writable: true };
							}
						}
						return r;
					},
					has(e, t) {
						if (i.A && t === l.XV) {
							return true;
						}
						if (t === l.x3) {
							return true;
						}
						var r = w.get(t);
						var c = (r !== undefined && r.v !== d.UP) || Reflect.has(e, t);
						if (r !== undefined || (a.Fg !== null && (!c || (0, o.J8)(e, t)?.writable))) {
							if (r === undefined) {
								r = (0, u.sP)(c ? proxy(e[t], k) : d.UP, v);
								w.set(t, r);
							}
							var p = (0, a.Jt)(r);
							if (p === d.UP) {
								return false;
							}
						}
						return c;
					},
					set(e, t, r, a) {
						var p = w.get(t);
						var m = t in e;
						if (_ && t === 'length') {
							for (var g = r; g < p.v; g += 1) {
								var y = w.get(g + '');
								if (y !== undefined) {
									(0, u.hZ)(y, d.UP);
								} else if (g in e) {
									y = (0, u.sP)(d.UP, v);
									w.set(g + '', y);
								}
							}
						}
						if (p === undefined) {
							if (!m || (0, o.J8)(e, t)?.writable) {
								p = (0, u.sP)(undefined, v);
								(0, u.hZ)(p, proxy(r, k));
								w.set(t, p);
							}
						} else {
							m = p.v !== d.UP;
							(0, u.hZ)(p, proxy(r, k));
						}
						if (i.A) {
							var N = r?.[l.XV];
							if (N && N?.parent !== k) {
								(0, c.an)(k, N);
							}
							(0, c.Pj)(k);
						}
						var T = Reflect.getOwnPropertyDescriptor(e, t);
						if (T?.set) {
							T.set.call(a, r);
						}
						if (!m) {
							if (_ && typeof t === 'string') {
								var x = w.get('length');
								var B = Number(t);
								if (Number.isInteger(B) && B >= x.v) {
									(0, u.hZ)(x, B + 1);
								}
							}
							update_version(A);
						}
						return true;
					},
					ownKeys(e) {
						(0, a.Jt)(A);
						var t = Reflect.ownKeys(e).filter((e) => {
							var t = w.get(e);
							return t === undefined || t.v !== d.UP;
						});
						for (var [r, i] of w) {
							if (i.v !== d.UP && !(r in e)) {
								t.push(r);
							}
						}
						return t;
					},
					setPrototypeOf() {
						p.YY();
					}
				});
			}
			function update_version(e, t = 1) {
				(0, u.hZ)(e, e.v + t);
			}
			function get_proxied_value(e) {
				if (e !== null && typeof e === 'object' && l.x3 in e) {
					return e[l.x3];
				}
				return e;
			}
			function is(e, t) {
				return Object.is(get_proxied_value(e), get_proxied_value(t));
			}
		},
		656: (e, t, r) => {
			'use strict';
			r.d(t, {
				JX: () => destroy_derived,
				Xd: () => derived_safe_equal,
				c2: () => update_derived,
				un: () => derived,
				w6: () => execute_derived
			});
			var i = r(235);
			var a = r(6410);
			var o = r(1951);
			var c = r(2190);
			var u = r(8048);
			var l = r(2522);
			var d = r(9246);
			var p = r(8969);
			var m = r(1779);
			function derived(e) {
				var t = a.mj | a.jm;
				if (o.Fg === null) {
					t |= a.L2;
				} else {
					o.Fg.f |= a.vP;
				}
				var r = o.hp !== null && (o.hp.f & a.mj) !== 0 ? o.hp : null;
				const u = {
					children: null,
					ctx: o.UL,
					deps: null,
					equals: c.aI,
					f: t,
					fn: e,
					reactions: null,
					rv: 0,
					v: null,
					wv: 0,
					parent: r ?? o.Fg
				};
				if (i.A && m._G) {
					u.created = (0, p.sv)('CreatedAt');
				}
				if (r !== null) {
					(r.children ??= []).push(u);
				}
				return u;
			}
			function derived_safe_equal(e) {
				const t = derived(e);
				t.equals = c.Og;
				return t;
			}
			function destroy_derived_children(e) {
				var t = e.children;
				if (t !== null) {
					e.children = null;
					for (var r = 0; r < t.length; r += 1) {
						var i = t[r];
						if ((i.f & a.mj) !== 0) {
							destroy_derived(i);
						} else {
							(0, l.DI)(i);
						}
					}
				}
			}
			let g = [];
			function get_derived_parent_effect(e) {
				var t = e.parent;
				while (t !== null) {
					if ((t.f & a.mj) === 0) {
						return t;
					}
					t = t.parent;
				}
				return null;
			}
			function execute_derived(e) {
				var t;
				var r = o.Fg;
				(0, o.gU)(get_derived_parent_effect(e));
				if (i.A) {
					let i = d.MU;
					(0, d.JY)(new Set());
					try {
						if (g.includes(e)) {
							u.cN();
						}
						g.push(e);
						destroy_derived_children(e);
						t = (0, o.mj)(e);
					} finally {
						(0, o.gU)(r);
						(0, d.JY)(i);
						g.pop();
					}
				} else {
					try {
						destroy_derived_children(e);
						t = (0, o.mj)(e);
					} finally {
						(0, o.gU)(r);
					}
				}
				return t;
			}
			function update_derived(e) {
				var t = execute_derived(e);
				var r = (o.U9 || (e.f & a.L2) !== 0) && e.deps !== null ? a.ig : a.w_;
				(0, o.TC)(e, r);
				if (!e.equals(t)) {
					e.v = t;
					e.wv = (0, o.Fq)();
				}
			}
			function destroy_derived(e) {
				destroy_derived_children(e);
				(0, o.yR)(e, 0);
				(0, o.TC)(e, a.o5);
				e.v = e.children = e.deps = e.ctx = e.reactions = null;
			}
		},
		2522: (t, r, i) => {
			'use strict';
			i.d(r, {
				DI: () => destroy_effect,
				F3: () => destroy_effect_children,
				Fc: () => effect_root,
				Nq: () => execute_effect_teardown,
				QZ: () => effect,
				VB: () => render_effect,
				pk: () => destroy_block_effect_children,
				q5: () => destroy_effect_deriveds,
				qX: () => unlink_effect,
				tk: () => branch,
				x4: () => component_root
			});
			var a = i(1951);
			var o = i(6410);
			var c = i(9246);
			var u = i(235);
			var l = i(5372);
			var d = i(6836);
			var p = i(656);
			function validate_effect(t) {
				if (active_effect === null && active_reaction === null) {
					e.effect_orphan(t);
				}
				if (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0) {
					e.effect_in_unowned_derived();
				}
				if (is_destroying_effect) {
					e.effect_in_teardown(t);
				}
			}
			function push_effect(e, t) {
				var r = t.last;
				if (r === null) {
					t.last = t.first = e;
				} else {
					r.next = e;
					e.prev = r;
					t.last = e;
				}
			}
			function create_effect(e, t, r, i = true) {
				var c = (e & o.FV) !== 0;
				var l = a.Fg;
				if (u.A) {
					while (l !== null && (l.f & o.T1) !== 0) {
						l = l.parent;
					}
				}
				var d = {
					ctx: a.UL,
					deps: null,
					deriveds: null,
					nodes_start: null,
					nodes_end: null,
					f: e | o.jm,
					first: null,
					fn: t,
					last: null,
					next: null,
					parent: c ? null : l,
					prev: null,
					teardown: null,
					transitions: null,
					wv: 0
				};
				if (u.A) {
					d.component_function = a.DE;
				}
				if (r) {
					var p = a.Gs;
					try {
						(0, a.Vw)(true);
						(0, a.gJ)(d);
						d.f |= o.wi;
					} catch (e) {
						destroy_effect(d);
						throw e;
					} finally {
						(0, a.Vw)(p);
					}
				} else if (t !== null) {
					(0, a.ec)(d);
				}
				var m =
					r &&
					d.deps === null &&
					d.first === null &&
					d.nodes_start === null &&
					d.teardown === null &&
					(d.f & (o.vP | o.bp)) === 0;
				if (!m && !c && i) {
					if (l !== null) {
						push_effect(d, l);
					}
					if (a.hp !== null && (a.hp.f & o.mj) !== 0) {
						var g = a.hp;
						(g.children ??= []).push(d);
					}
				}
				return d;
			}
			function effect_tracking() {
				if (active_reaction === null) {
					return false;
				}
				return !skip_reaction;
			}
			function teardown(e) {
				const t = create_effect(RENDER_EFFECT, null, false);
				set_signal_status(t, CLEAN);
				t.teardown = e;
				return t;
			}
			function user_effect(e) {
				validate_effect('$effect');
				var t =
					active_effect !== null &&
					(active_effect.f & BRANCH_EFFECT) !== 0 &&
					component_context !== null &&
					!component_context.m;
				if (DEV) {
					define_property(e, 'name', { value: '$effect' });
				}
				if (t) {
					var r = component_context;
					(r.e ??= []).push({ fn: e, effect: active_effect, reaction: active_reaction });
				} else {
					var i = effect(e);
					return i;
				}
			}
			function user_pre_effect(e) {
				validate_effect('$effect.pre');
				if (DEV) {
					define_property(e, 'name', { value: '$effect.pre' });
				}
				return render_effect(e);
			}
			function inspect_effect(e) {
				return create_effect(INSPECT_EFFECT, e, true);
			}
			function effect_root(e) {
				const t = create_effect(o.FV, e, true);
				return () => {
					destroy_effect(t);
				};
			}
			function component_root(e) {
				const t = create_effect(o.FV, e, true);
				return (e = {}) =>
					new Promise((r) => {
						if (e.outro) {
							pause_effect(t, () => {
								destroy_effect(t);
								r(undefined);
							});
						} else {
							destroy_effect(t);
							r(undefined);
						}
					});
			}
			function effect(e) {
				return create_effect(o.ac, e, false);
			}
			function legacy_pre_effect(e, t) {
				var r = component_context;
				var i = { effect: null, ran: false };
				r.l.r1.push(i);
				i.effect = render_effect(() => {
					e();
					if (i.ran) return;
					i.ran = true;
					set(r.l.r2, true);
					untrack(t);
				});
			}
			function legacy_pre_effect_reset() {
				var e = component_context;
				render_effect(() => {
					if (!get(e.l.r2)) return;
					for (var t of e.l.r1) {
						var r = t.effect;
						if ((r.f & CLEAN) !== 0) {
							set_signal_status(r, MAYBE_DIRTY);
						}
						if (check_dirtiness(r)) {
							update_effect(r);
						}
						t.ran = false;
					}
					e.l.r2.v = false;
				});
			}
			function render_effect(e) {
				return create_effect(o.Zv, e, true);
			}
			function template_effect(e) {
				if (DEV) {
					define_property(e, 'name', { value: '{expression}' });
				}
				return block(e);
			}
			function block(e, t = 0) {
				return create_effect(RENDER_EFFECT | BLOCK_EFFECT | t, e, true);
			}
			function branch(e, t = true) {
				return create_effect(o.Zv | o.Zr, e, true, t);
			}
			function execute_effect_teardown(e) {
				var t = e.teardown;
				if (t !== null) {
					const e = a.WI;
					const r = a.hp;
					(0, a.fT)(true);
					(0, a.G0)(null);
					try {
						t.call(null);
					} finally {
						(0, a.fT)(e);
						(0, a.G0)(r);
					}
				}
			}
			function destroy_effect_deriveds(e) {
				var t = e.deriveds;
				if (t !== null) {
					e.deriveds = null;
					for (var r = 0; r < t.length; r += 1) {
						(0, p.JX)(t[r]);
					}
				}
			}
			function destroy_effect_children(e, t = false) {
				var r = e.first;
				e.first = e.last = null;
				while (r !== null) {
					var i = r.next;
					destroy_effect(r, t);
					r = i;
				}
			}
			function destroy_block_effect_children(e) {
				var t = e.first;
				while (t !== null) {
					var r = t.next;
					if ((t.f & o.Zr) === 0) {
						destroy_effect(t);
					}
					t = r;
				}
			}
			function destroy_effect(e, t = true) {
				var r = false;
				if ((t || (e.f & o.PL) !== 0) && e.nodes_start !== null) {
					var i = e.nodes_start;
					var c = e.nodes_end;
					while (i !== null) {
						var l = i === c ? null : (0, d.M$)(i);
						i.remove();
						i = l;
					}
					r = true;
				}
				destroy_effect_children(e, t && !r);
				destroy_effect_deriveds(e);
				(0, a.yR)(e, 0);
				(0, a.TC)(e, o.o5);
				var p = e.transitions;
				if (p !== null) {
					for (const e of p) {
						e.stop();
					}
				}
				execute_effect_teardown(e);
				var m = e.parent;
				if (m !== null && m.first !== null) {
					unlink_effect(e);
				}
				if (u.A) {
					e.component_function = null;
				}
				e.next = e.prev = e.teardown = e.ctx = e.deps = e.fn = e.nodes_start = e.nodes_end = null;
			}
			function unlink_effect(e) {
				var t = e.parent;
				var r = e.prev;
				var i = e.next;
				if (r !== null) r.next = i;
				if (i !== null) i.prev = r;
				if (t !== null) {
					if (t.first === e) t.first = i;
					if (t.last === e) t.last = r;
				}
			}
			function pause_effect(e, t) {
				var r = [];
				pause_children(e, r, true);
				run_out_transitions(r, () => {
					destroy_effect(e);
					if (t) t();
				});
			}
			function run_out_transitions(e, t) {
				var r = e.length;
				if (r > 0) {
					var check = () => --r || t();
					for (var i of e) {
						i.out(check);
					}
				} else {
					t();
				}
			}
			function pause_children(e, t, r) {
				if ((e.f & o.$q) !== 0) return;
				e.f ^= o.$q;
				if (e.transitions !== null) {
					for (const i of e.transitions) {
						if (i.is_global || r) {
							t.push(i);
						}
					}
				}
				var i = e.first;
				while (i !== null) {
					var a = i.next;
					var c = (i.f & o.lQ) !== 0 || (i.f & o.Zr) !== 0;
					pause_children(i, t, c ? r : false);
					i = a;
				}
			}
			function resume_effect(e) {
				resume_children(e, true);
			}
			function resume_children(e, t) {
				if ((e.f & INERT) === 0) return;
				e.f ^= INERT;
				if ((e.f & CLEAN) === 0) {
					e.f ^= CLEAN;
				}
				if (check_dirtiness(e)) {
					set_signal_status(e, DIRTY);
					schedule_effect(e);
				}
				var r = e.first;
				while (r !== null) {
					var i = r.next;
					var a = (r.f & EFFECT_TRANSPARENT) !== 0 || (r.f & BRANCH_EFFECT) !== 0;
					resume_children(r, a ? t : false);
					r = i;
				}
				if (e.transitions !== null) {
					for (const r of e.transitions) {
						if (r.is_global || t) {
							r.in();
						}
					}
				}
			}
		},
		2190: (e, t, r) => {
			'use strict';
			r.d(t, { Og: () => safe_equals, aI: () => equals, jX: () => safe_not_equal });
			function equals(e) {
				return e === this.v;
			}
			function safe_not_equal(e, t) {
				return e != e
					? t == t
					: e !== t || (e !== null && typeof e === 'object') || typeof e === 'function';
			}
			function not_equal(e, t) {
				return e !== t;
			}
			function safe_equals(e) {
				return !safe_not_equal(e, this.v);
			}
		},
		9246: (e, t, r) => {
			'use strict';
			r.d(t, {
				JY: () => set_inspect_effects,
				MU: () => p,
				hZ: () => set,
				sP: () => source,
				zg: () => mutable_source
			});
			var i = r(235);
			var a = r(1951);
			var o = r(2190);
			var c = r(6410);
			var u = r(8048);
			var l = r(1779);
			var d = r(8969);
			let p = new Set();
			function set_inspect_effects(e) {
				p = e;
			}
			function source(e, t) {
				var r = { f: 0, v: e, reactions: null, equals: o.aI, rv: 0, wv: 0 };
				if (i.A && l._G) {
					r.created = t ?? (0, d.sv)('CreatedAt');
					r.debug = null;
				}
				return r;
			}
			function state(e) {
				return push_derived_source(source(e));
			}
			function mutable_source(e, t = false) {
				const r = source(e);
				if (!t) {
					r.equals = o.Og;
				}
				if (l.LM && a.UL !== null && a.UL.l !== null) {
					(a.UL.l.s ??= []).push(r);
				}
				return r;
			}
			function mutable_state(e, t = false) {
				return push_derived_source(mutable_source(e, t));
			}
			function push_derived_source(e) {
				if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
					if (derived_sources === null) {
						set_derived_sources([e]);
					} else {
						derived_sources.push(e);
					}
				}
				return e;
			}
			function mutate(e, t) {
				set(
					e,
					untrack(() => get(e))
				);
				return t;
			}
			function set(e, t) {
				if (
					a.hp !== null &&
					(0, a.hH)() &&
					(a.hp.f & (c.mj | c.kc)) !== 0 &&
					(a.zA === null || !a.zA.includes(e))
				) {
					u.rZ();
				}
				return internal_set(e, t);
			}
			function internal_set(e, t) {
				if (!e.equals(t)) {
					var r = e.v;
					e.v = t;
					e.wv = (0, a.Fq)();
					if (i.A && l._G) {
						e.updated = (0, d.sv)('UpdatedAt');
						if (a.Fg != null) {
							e.trace_need_increase = true;
							e.trace_v ??= r;
						}
					}
					mark_reactions(e, c.jm);
					if (
						(0, a.hH)() &&
						a.Fg !== null &&
						(a.Fg.f & c.w_) !== 0 &&
						(a.Fg.f & (c.Zr | c.FV)) === 0
					) {
						if (a.l_ === null) {
							(0, a.S0)([e]);
						} else {
							a.l_.push(e);
						}
					}
					if (i.A && p.size > 0) {
						const e = Array.from(p);
						var o = a.Gs;
						(0, a.Vw)(true);
						try {
							for (const t of e) {
								if ((t.f & c.w_) !== 0) {
									(0, a.TC)(t, c.ig);
								}
								if ((0, a.hl)(t)) {
									(0, a.gJ)(t);
								}
							}
						} finally {
							(0, a.Vw)(o);
						}
						p.clear();
					}
				}
				return t;
			}
			function mark_reactions(e, t) {
				var r = e.reactions;
				if (r === null) return;
				var o = (0, a.hH)();
				var u = r.length;
				for (var l = 0; l < u; l++) {
					var d = r[l];
					var m = d.f;
					if ((m & c.jm) !== 0) continue;
					if (!o && d === a.Fg) continue;
					if (i.A && (m & c.T1) !== 0) {
						p.add(d);
						continue;
					}
					(0, a.TC)(d, t);
					if ((m & (c.w_ | c.L2)) !== 0) {
						if ((m & c.mj) !== 0) {
							mark_reactions(d, c.ig);
						} else {
							(0, a.ec)(d);
						}
					}
				}
			}
		},
		3091: (e, t, r) => {
			'use strict';
			r.d(t, { Or: () => mount, Qv: () => hydrate, vs: () => unmount });
			var i = r(235);
			var a = r(6836);
			var o = r(8940);
			var c = r(1951);
			var u = r(2522);
			var l = r(7646);
			var d = r(5372);
			var p = r(4623);
			var m = r(6880);
			var g = r(2050);
			var v = r(8048);
			var y = r(992);
			var w = r(2320);
			let _ = true;
			function set_should_intro(e) {
				_ = e;
			}
			function set_text(e, t) {
				var r = t == null ? '' : typeof t === 'object' ? t + '' : t;
				if (r !== (e.__t ??= e.nodeValue)) {
					e.__t = r;
					e.nodeValue = r == null ? '' : r + '';
				}
			}
			function mount(e, t) {
				return _mount(e, t);
			}
			function hydrate(e, t) {
				(0, a.Ey)();
				t.intro = t.intro ?? false;
				const r = t.target;
				const i = l.fE;
				const c = l.Xb;
				try {
					var u = (0, a.Zj)(r);
					while (u && (u.nodeType !== 8 || u.data !== o.CD)) {
						u = (0, a.M$)(u);
					}
					if (!u) {
						throw o.kD;
					}
					(0, l.mK)(true);
					(0, l.W0)(u);
					(0, l.E$)();
					const i = _mount(e, { ...t, anchor: u });
					if (l.Xb === null || l.Xb.nodeType !== 8 || l.Xb.data !== o.Lc) {
						g.eZ();
						throw o.kD;
					}
					(0, l.mK)(false);
					return i;
				} catch (i) {
					if (i === o.kD) {
						if (t.recover === false) {
							v.Vv();
						}
						(0, a.Ey)();
						(0, a.MC)(r);
						(0, l.mK)(false);
						return mount(e, t);
					}
					throw i;
				} finally {
					(0, l.mK)(i);
					(0, l.W0)(c);
					(0, m.j)();
				}
			}
			const A = new Map();
			function _mount(
				e,
				{ target: t, anchor: r, props: i = {}, events: o, context: m, intro: g = true }
			) {
				(0, a.Ey)();
				var v = new Set();
				var event_handle = (e) => {
					for (var r = 0; r < e.length; r++) {
						var i = e[r];
						if (v.has(i)) continue;
						v.add(i);
						var a = (0, w.GY)(i);
						t.addEventListener(i, p.n7, { passive: a });
						var o = A.get(i);
						if (o === undefined) {
							document.addEventListener(i, p.n7, { passive: a });
							A.set(i, 1);
						} else {
							A.set(i, o + 1);
						}
					}
				};
				event_handle((0, d.bg)(p.Ts));
				p.Sr.add(event_handle);
				var N = undefined;
				var T = (0, u.x4)(() => {
					var d = r ?? t.appendChild((0, a.Pb)());
					(0, u.tk)(() => {
						if (m) {
							(0, c.VC)({});
							var t = c.UL;
							t.c = m;
						}
						if (o) {
							i.$$events = o;
						}
						if (l.fE) {
							(0, y.mX)(d, null);
						}
						_ = g;
						N = e(d, i) || {};
						_ = true;
						if (l.fE) {
							c.Fg.nodes_end = l.Xb;
						}
						if (m) {
							(0, c.uY)();
						}
					});
					return () => {
						for (var e of v) {
							t.removeEventListener(e, p.n7);
							var i = A.get(e);
							if (--i === 0) {
								document.removeEventListener(e, p.n7);
								A.delete(e);
							} else {
								A.set(e, i);
							}
						}
						p.Sr.delete(event_handle);
						if (d !== r) {
							d.parentNode?.removeChild(d);
						}
					};
				});
				k.set(N, T);
				return N;
			}
			let k = new WeakMap();
			function unmount(e, t) {
				const r = k.get(e);
				if (r) {
					k.delete(e);
					return r(t);
				}
				if (i.A) {
					g.YY();
				}
				return Promise.resolve();
			}
		},
		1951: (e, t, r) => {
			'use strict';
			r.d(t, {
				DB: () => flush_sync,
				DE: () => V,
				Fg: () => F,
				Fq: () => increment_write_version,
				G0: () => set_active_reaction,
				Gs: () => B,
				JY: () => G,
				Jt: () => get,
				S0: () => set_untracked_writes,
				TC: () => set_signal_status,
				U9: () => $,
				UL: () => q,
				VC: () => push,
				Vw: () => set_is_flushing_effect,
				WI: () => P,
				ec: () => schedule_effect,
				fT: () => set_is_destroying_effect,
				gJ: () => update_effect,
				gU: () => set_active_effect,
				hH: () => is_runes,
				hl: () => check_dirtiness,
				hp: () => O,
				l_: () => j,
				mj: () => update_reaction,
				uY: () => pop,
				vz: () => untrack,
				yR: () => remove_reactions,
				yo: () => update,
				zA: () => D
			});
			var i = r(235);
			var a = r(5372);
			var o = r(2522);
			var c = r(6410);
			var u = r(2635);
			var l = r(3546);
			var d = r(9246);
			var p = r(656);
			var m = r(8048);
			var g = r(8940);
			var v = r(1779);
			var y = r(8969);
			const w = 0;
			const _ = 1;
			const A = new WeakSet();
			let k = false;
			let N = w;
			let T = false;
			let x = null;
			let B = false;
			let P = false;
			function set_is_flushing_effect(e) {
				B = e;
			}
			function set_is_destroying_effect(e) {
				P = e;
			}
			let M = [];
			let C = 0;
			let I = [];
			let O = null;
			function set_active_reaction(e) {
				O = e;
			}
			let F = null;
			function set_active_effect(e) {
				F = e;
			}
			let D = null;
			function set_derived_sources(e) {
				D = e;
			}
			let L = null;
			let U = 0;
			let j = null;
			function set_untracked_writes(e) {
				j = e;
			}
			let H = 1;
			let z = 0;
			let $ = false;
			let G = null;
			function set_captured_signals(e) {
				G = e;
			}
			let q = null;
			function set_component_context(e) {
				q = e;
			}
			let V = null;
			function set_dev_current_component_function(e) {
				V = e;
			}
			function increment_write_version() {
				return ++H;
			}
			function is_runes() {
				return !v.LM || (q !== null && q.l === null);
			}
			function check_dirtiness(e) {
				var t = e.f;
				if ((t & c.jm) !== 0) {
					return true;
				}
				if ((t & c.ig) !== 0) {
					var r = e.deps;
					var i = (t & c.L2) !== 0;
					if (r !== null) {
						var a;
						var o;
						var u = (t & c._N) !== 0;
						var l = i && F !== null && !$;
						var d = r.length;
						if (u || l) {
							for (a = 0; a < d; a++) {
								o = r[a];
								if (u || !o?.reactions?.includes(e)) {
									(o.reactions ??= []).push(e);
								}
							}
							if (u) {
								e.f ^= c._N;
							}
						}
						for (a = 0; a < d; a++) {
							o = r[a];
							if (check_dirtiness(o)) {
								(0, p.c2)(o);
							}
							if (o.wv > e.wv) {
								return true;
							}
						}
					}
					if (!i || (F !== null && !$)) {
						set_signal_status(e, c.w_);
					}
				}
				return false;
			}
			function propagate_error(e, t) {
				var r = t;
				while (r !== null) {
					if ((r.f & c.bp) !== 0) {
						try {
							r.fn(e);
							return;
						} catch {
							r.f ^= c.bp;
						}
					}
					r = r.parent;
				}
				k = false;
				throw e;
			}
			function should_rethrow_error(e) {
				return (e.f & c.o5) === 0 && (e.parent === null || (e.parent.f & c.bp) === 0);
			}
			function reset_is_throwing_error() {
				k = false;
			}
			function handle_error(e, t, r, o) {
				if (k) {
					if (r === null) {
						k = false;
					}
					if (should_rethrow_error(t)) {
						throw e;
					}
					return;
				}
				if (r !== null) {
					k = true;
				}
				if (!i.A || o === null || !(e instanceof Error) || A.has(e)) {
					propagate_error(e, t);
					return;
				}
				A.add(e);
				const c = [];
				const u = t.fn?.name;
				if (u) {
					c.push(u);
				}
				let l = o;
				while (l !== null) {
					if (i.A) {
						var d = l.function?.[g.Uh];
						if (d) {
							const e = d.split('/').pop();
							c.push(e);
						}
					}
					l = l.p;
				}
				const p = /Firefox/.test(navigator.userAgent) ? '  ' : '\t';
				(0, a.Qu)(e, 'message', {
					value: e.message + `\n${c.map((e) => `\n${p}in ${e}`).join('')}\n`
				});
				(0, a.Qu)(e, 'component_stack', { value: c });
				const m = e.stack;
				if (m) {
					const t = m.split('\n');
					const r = [];
					for (let e = 0; e < t.length; e++) {
						const i = t[e];
						if (i.includes('svelte/src/internal')) {
							continue;
						}
						r.push(i);
					}
					(0, a.Qu)(e, 'stack', { value: r.join('\n') });
				}
				propagate_error(e, t);
				if (should_rethrow_error(t)) {
					throw e;
				}
			}
			function schedule_possible_effect_self_invalidation(e, t, r = 0) {
				var i = e.reactions;
				if (i === null) return;
				for (var a = 0; a < i.length; a++) {
					var o = i[a];
					if ((o.f & c.mj) !== 0) {
						schedule_possible_effect_self_invalidation(o, t, r + 1);
					} else if (t === o) {
						if (r === 0) {
							set_signal_status(o, c.jm);
						} else if ((o.f & c.w_) !== 0) {
							set_signal_status(o, c.ig);
						}
						schedule_effect(o);
					}
				}
			}
			function update_reaction(e) {
				var t = L;
				var r = U;
				var i = j;
				var a = O;
				var o = $;
				var u = D;
				var l = q;
				var d = e.f;
				L = null;
				U = 0;
				j = null;
				O = (d & (c.Zr | c.FV)) === 0 ? e : null;
				$ = !B && (d & c.L2) !== 0;
				D = null;
				q = e.ctx;
				z++;
				try {
					var p = (0, e.fn)();
					var m = e.deps;
					if (L !== null) {
						var g;
						remove_reactions(e, U);
						if (m !== null && U > 0) {
							m.length = U + L.length;
							for (g = 0; g < L.length; g++) {
								m[U + g] = L[g];
							}
						} else {
							e.deps = m = L;
						}
						if (!$) {
							for (g = U; g < m.length; g++) {
								(m[g].reactions ??= []).push(e);
							}
						}
					} else if (m !== null && U < m.length) {
						remove_reactions(e, U);
						m.length = U;
					}
					if (is_runes() && j !== null && (e.f & (c.mj | c.ig | c.jm)) === 0) {
						for (g = 0; g < j.length; g++) {
							schedule_possible_effect_self_invalidation(j[g], e);
						}
					}
					if (a !== null) {
						z++;
					}
					return p;
				} finally {
					L = t;
					U = r;
					j = i;
					O = a;
					$ = o;
					D = u;
					q = l;
				}
			}
			function remove_reaction(e, t) {
				let r = t.reactions;
				if (r !== null) {
					var i = a.lc.call(r, e);
					if (i !== -1) {
						var o = r.length - 1;
						if (o === 0) {
							r = t.reactions = null;
						} else {
							r[i] = r[o];
							r.pop();
						}
					}
				}
				if (r === null && (t.f & c.mj) !== 0 && (L === null || !L.includes(t))) {
					set_signal_status(t, c.ig);
					if ((t.f & (c.L2 | c._N)) === 0) {
						t.f ^= c._N;
					}
					remove_reactions(t, 0);
				}
			}
			function remove_reactions(e, t) {
				var r = e.deps;
				if (r === null) return;
				for (var i = t; i < r.length; i++) {
					remove_reaction(e, r[i]);
				}
			}
			function update_effect(e) {
				var t = e.f;
				if ((t & c.o5) !== 0) {
					return;
				}
				set_signal_status(e, c.w_);
				var r = F;
				var a = q;
				F = e;
				if (i.A) {
					var u = V;
					V = e.component_function;
				}
				try {
					if ((t & c.kc) !== 0) {
						(0, o.pk)(e);
					} else {
						(0, o.F3)(e);
					}
					(0, o.q5)(e);
					(0, o.Nq)(e);
					var l = update_reaction(e);
					e.teardown = typeof l === 'function' ? l : null;
					e.wv = H;
					var d = e.deps;
					if (i.A && v._G && (e.f & c.jm) !== 0 && d !== null) {
						for (let e = 0; e < d.length; e++) {
							var p = d[e];
							if (p.trace_need_increase) {
								p.wv = increment_write_version();
								p.trace_need_increase = undefined;
								p.trace_v = undefined;
							}
						}
					}
					if (i.A) {
						I.push(e);
					}
				} catch (t) {
					handle_error(t, e, r, a || e.ctx);
				} finally {
					F = r;
					if (i.A) {
						V = u;
					}
				}
			}
			function log_effect_stack() {
				console.error(
					'Last ten effects were: ',
					I.slice(-10).map((e) => e.fn)
				);
				I = [];
			}
			function infinite_loop_guard() {
				if (C > 1e3) {
					C = 0;
					try {
						m.Cl();
					} catch (e) {
						if (i.A) {
							(0, a.Qu)(e, 'stack', { value: '' });
						}
						if (x !== null) {
							if (i.A) {
								try {
									handle_error(e, x, null, null);
								} catch (e) {
									log_effect_stack();
									throw e;
								}
							} else {
								handle_error(e, x, null, null);
							}
						} else {
							if (i.A) {
								log_effect_stack();
							}
							throw e;
						}
					}
				}
				C++;
			}
			function flush_queued_root_effects(e) {
				var t = e.length;
				if (t === 0) {
					return;
				}
				infinite_loop_guard();
				var r = B;
				B = true;
				try {
					for (var i = 0; i < t; i++) {
						var a = e[i];
						if ((a.f & c.w_) === 0) {
							a.f ^= c.w_;
						}
						var o = [];
						process_effects(a, o);
						flush_queued_effects(o);
					}
				} finally {
					B = r;
				}
			}
			function flush_queued_effects(e) {
				var t = e.length;
				if (t === 0) return;
				for (var r = 0; r < t; r++) {
					var i = e[r];
					if ((i.f & (c.o5 | c.$q)) === 0) {
						try {
							if (check_dirtiness(i)) {
								update_effect(i);
								if (i.deps === null && i.first === null && i.nodes_start === null) {
									if (i.teardown === null) {
										(0, o.qX)(i);
									} else {
										i.fn = null;
									}
								}
							}
						} catch (e) {
							handle_error(e, i, null, i.ctx);
						}
					}
				}
			}
			function process_deferred() {
				T = false;
				if (C > 1001) {
					return;
				}
				const e = M;
				M = [];
				flush_queued_root_effects(e);
				if (!T) {
					C = 0;
					x = null;
					if (i.A) {
						I = [];
					}
				}
			}
			function schedule_effect(e) {
				if (N === w) {
					if (!T) {
						T = true;
						queueMicrotask(process_deferred);
					}
				}
				x = e;
				var t = e;
				while (t.parent !== null) {
					t = t.parent;
					var r = t.f;
					if ((r & (c.FV | c.Zr)) !== 0) {
						if ((r & c.w_) === 0) return;
						t.f ^= c.w_;
					}
				}
				M.push(t);
			}
			function process_effects(e, t) {
				var r = e.first;
				var i = [];
				e: while (r !== null) {
					var a = r.f;
					var o = (a & c.Zr) !== 0;
					var u = o && (a & c.w_) !== 0;
					var l = r.next;
					if (!u && (a & c.$q) === 0) {
						if ((a & c.Zv) !== 0) {
							if (o) {
								r.f ^= c.w_;
							} else {
								try {
									if (check_dirtiness(r)) {
										update_effect(r);
									}
								} catch (e) {
									handle_error(e, r, null, r.ctx);
								}
							}
							var d = r.first;
							if (d !== null) {
								r = d;
								continue;
							}
						} else if ((a & c.ac) !== 0) {
							i.push(r);
						}
					}
					if (l === null) {
						let t = r.parent;
						while (t !== null) {
							if (e === t) {
								break e;
							}
							var p = t.next;
							if (p !== null) {
								r = p;
								continue e;
							}
							t = t.parent;
						}
					}
					r = l;
				}
				for (var m = 0; m < i.length; m++) {
					d = i[m];
					t.push(d);
					process_effects(d, t);
				}
			}
			function flush_sync(e) {
				var t = N;
				var r = M;
				try {
					infinite_loop_guard();
					const t = [];
					N = _;
					M = t;
					T = false;
					flush_queued_root_effects(r);
					var a = e?.();
					(0, u.eo)();
					if (M.length > 0 || t.length > 0) {
						flush_sync();
					}
					C = 0;
					x = null;
					if (i.A) {
						I = [];
					}
					return a;
				} finally {
					N = t;
					M = r;
				}
			}
			async function tick() {
				await Promise.resolve();
				flush_sync();
			}
			function get(e) {
				var t = e.f;
				var r = (t & c.mj) !== 0;
				if (r && (t & c.o5) !== 0) {
					var a = (0, p.w6)(e);
					(0, p.JX)(e);
					return a;
				}
				if (G !== null) {
					G.add(e);
				}
				if (O !== null) {
					if (D !== null && D.includes(e)) {
						m.$k();
					}
					var o = O.deps;
					if (e.rv < z) {
						e.rv = z;
						if (L === null && o !== null && o[U] === e) {
							U++;
						} else if (L === null) {
							L = [e];
						} else {
							L.push(e);
						}
					}
				} else if (r && e.deps === null) {
					var u = e;
					var l = u.parent;
					var d = u;
					while (l !== null) {
						if ((l.f & c.mj) !== 0) {
							var g = l;
							d = g;
							l = g.parent;
						} else {
							var w = l;
							if (!w.deriveds?.includes(d)) {
								(w.deriveds ??= []).push(d);
							}
							break;
						}
					}
				}
				if (r) {
					u = e;
					if (check_dirtiness(u)) {
						(0, p.c2)(u);
					}
				}
				if (i.A && v._G && y.ho !== null && O !== null && y.ho.reaction === O) {
					if (e.debug) {
						e.debug();
					} else if (e.created) {
						var _ = y.ho.entries.get(e);
						if (_ === undefined) {
							_ = { read: [] };
							y.ho.entries.set(e, _);
						}
						_.read.push((0, y.sv)('TracedAt'));
					}
				}
				return e.v;
			}
			function safe_get(e) {
				return e && get(e);
			}
			function capture_signals(e) {
				var t = G;
				G = new Set();
				var r = G;
				var i;
				try {
					untrack(e);
					if (t !== null) {
						for (i of G) {
							t.add(i);
						}
					}
				} finally {
					G = t;
				}
				return r;
			}
			function invalidate_inner_signals(e) {
				var t = capture_signals(() => untrack(e));
				for (var r of t) {
					if ((r.f & LEGACY_DERIVED_PROP) !== 0) {
						for (const e of r.deps || []) {
							if ((e.f & DERIVED) === 0) {
								internal_set(e, e.v);
							}
						}
					} else {
						internal_set(r, r.v);
					}
				}
			}
			function untrack(e) {
				const t = O;
				try {
					O = null;
					return e();
				} finally {
					O = t;
				}
			}
			const W = ~(c.jm | c.ig | c.w_);
			function set_signal_status(e, t) {
				e.f = (e.f & W) | t;
			}
			function getContext(e) {
				const t = get_or_init_context_map('getContext');
				const r = t.get(e);
				if (DEV) {
					const e = q.function;
					if (e) {
						add_owner(r, e, true);
					}
				}
				return r;
			}
			function setContext(e, t) {
				const r = get_or_init_context_map('setContext');
				r.set(e, t);
				return t;
			}
			function hasContext(e) {
				const t = get_or_init_context_map('hasContext');
				return t.has(e);
			}
			function getAllContexts() {
				const e = get_or_init_context_map('getAllContexts');
				if (DEV) {
					const t = q?.function;
					if (t) {
						for (const r of e.values()) {
							add_owner(r, t, true);
						}
					}
				}
				return e;
			}
			function get_or_init_context_map(e) {
				if (q === null) {
					lifecycle_outside_component(e);
				}
				return (q.c ??= new Map(get_parent_context(q) || undefined));
			}
			function get_parent_context(e) {
				let t = e.p;
				while (t !== null) {
					const e = t.c;
					if (e !== null) {
						return e;
					}
					t = t.p;
				}
				return null;
			}
			function update(e, t = 1) {
				var r = get(e);
				var i = t === 1 ? r++ : r--;
				(0, d.hZ)(e, r);
				return i;
			}
			function update_pre(e, t = 1) {
				var r = get(e);
				return set(e, t === 1 ? ++r : --r);
			}
			function exclude_from_object(e, t) {
				var r = {};
				for (var i in e) {
					if (!t.includes(i)) {
						r[i] = e[i];
					}
				}
				return r;
			}
			function push(e, t = false, r) {
				q = { p: q, c: null, e: null, m: false, s: e, x: null, l: null };
				if (v.LM && !t) {
					q.l = { s: null, u: null, r1: [], r2: (0, d.sP)(false) };
				}
				if (i.A) {
					q.function = r;
					V = r;
				}
			}
			function pop(e) {
				const t = q;
				if (t !== null) {
					if (e !== undefined) {
						t.x = e;
					}
					const l = t.e;
					if (l !== null) {
						var r = F;
						var a = O;
						t.e = null;
						try {
							for (var c = 0; c < l.length; c++) {
								var u = l[c];
								set_active_effect(u.effect);
								set_active_reaction(u.reaction);
								(0, o.QZ)(u.fn);
							}
						} finally {
							set_active_effect(r);
							set_active_reaction(a);
						}
					}
					q = t.p;
					if (i.A) {
						V = t.p?.function ?? null;
					}
					t.m = true;
				}
				return e || {};
			}
			function deep_read_state(e) {
				if (typeof e !== 'object' || !e || e instanceof EventTarget) {
					return;
				}
				if (STATE_SYMBOL in e) {
					deep_read(e);
				} else if (!Array.isArray(e)) {
					for (let t in e) {
						const r = e[t];
						if (typeof r === 'object' && r && STATE_SYMBOL in r) {
							deep_read(r);
						}
					}
				}
			}
			function deep_read(e, t = new Set()) {
				if (typeof e === 'object' && e !== null && !(e instanceof EventTarget) && !t.has(e)) {
					t.add(e);
					if (e instanceof Date) {
						e.getTime();
					}
					for (let r in e) {
						try {
							deep_read(e[r], t);
						} catch (e) {}
					}
					const r = get_prototype_of(e);
					if (
						r !== Object.prototype &&
						r !== Array.prototype &&
						r !== Map.prototype &&
						r !== Set.prototype &&
						r !== Date.prototype
					) {
						const t = get_descriptors(r);
						for (let r in t) {
							const i = t[r].get;
							if (i) {
								try {
									i.call(e);
								} catch (e) {}
							}
						}
					}
				}
			}
			if (i.A) {
				function throw_rune_error(e) {
					if (!(e in globalThis)) {
						let t;
						Object.defineProperty(globalThis, e, {
							configurable: true,
							get: () => {
								if (t !== undefined) {
									return t;
								}
								m.xU(e);
							},
							set: (e) => {
								t = e;
							}
						});
					}
				}
				throw_rune_error('$state');
				throw_rune_error('$effect');
				throw_rune_error('$derived');
				throw_rune_error('$inspect');
				throw_rune_error('$props');
				throw_rune_error('$bindable');
			}
		},
		2050: (e, t, r) => {
			'use strict';
			r.d(t, {
				YY: () => lifecycle_double_unmount,
				a6: () => ownership_invalid_mutation,
				eZ: () => hydration_mismatch,
				ns: () => state_proxy_equality_mismatch
			});
			var i = r(235);
			var a = 'font-weight: bold';
			var o = 'font-weight: normal';
			function assignment_value_stale(e, t) {
				if (DEV) {
					console.warn(
						`%c[svelte] assignment_value_stale\n%cAssignment to \`${e}\` property (${t}) will evaluate to the right-hand side, not the value of \`${e}\` following the assignment. This may result in unexpected behaviour.\nhttps://svelte.dev/e/assignment_value_stale`,
						a,
						o
					);
				} else {
					console.warn(`https://svelte.dev/e/assignment_value_stale`);
				}
			}
			function binding_property_non_reactive(e, t) {
				if (DEV) {
					console.warn(
						`%c[svelte] binding_property_non_reactive\n%c${t ? `\`${e}\` (${t}) is binding to a non-reactive property` : `\`${e}\` is binding to a non-reactive property`}\nhttps://svelte.dev/e/binding_property_non_reactive`,
						a,
						o
					);
				} else {
					console.warn(`https://svelte.dev/e/binding_property_non_reactive`);
				}
			}
			function console_log_state(e) {
				if (DEV) {
					console.warn(
						`%c[svelte] console_log_state\n%cYour \`console.${e}\` contained \`$state\` proxies. Consider using \`$inspect(...)\` or \`$state.snapshot(...)\` instead\nhttps://svelte.dev/e/console_log_state`,
						a,
						o
					);
				} else {
					console.warn(`https://svelte.dev/e/console_log_state`);
				}
			}
			function event_handler_invalid(e, t) {
				if (DEV) {
					console.warn(
						`%c[svelte] event_handler_invalid\n%c${e} should be a function. Did you mean to ${t}?\nhttps://svelte.dev/e/event_handler_invalid`,
						a,
						o
					);
				} else {
					console.warn(`https://svelte.dev/e/event_handler_invalid`);
				}
			}
			function hydration_attribute_changed(e, t, r) {
				if (DEV) {
					console.warn(
						`%c[svelte] hydration_attribute_changed\n%cThe \`${e}\` attribute on \`${t}\` changed its value between server and client renders. The client value, \`${r}\`, will be ignored in favour of the server value\nhttps://svelte.dev/e/hydration_attribute_changed`,
						a,
						o
					);
				} else {
					console.warn(`https://svelte.dev/e/hydration_attribute_changed`);
				}
			}
			function hydration_html_changed(e) {
				if (DEV) {
					console.warn(
						`%c[svelte] hydration_html_changed\n%c${e ? `The value of an \`{@html ...}\` block ${e} changed between server and client renders. The client value will be ignored in favour of the server value` : 'The value of an `{@html ...}` block changed between server and client renders. The client value will be ignored in favour of the server value'}\nhttps://svelte.dev/e/hydration_html_changed`,
						a,
						o
					);
				} else {
					console.warn(`https://svelte.dev/e/hydration_html_changed`);
				}
			}
			function hydration_mismatch(e) {
				if (i.A) {
					console.warn(
						`%c[svelte] hydration_mismatch\n%c${e ? `Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${e}` : 'Hydration failed because the initial UI does not match what was rendered on the server'}\nhttps://svelte.dev/e/hydration_mismatch`,
						a,
						o
					);
				} else {
					console.warn(`https://svelte.dev/e/hydration_mismatch`);
				}
			}
			function invalid_raw_snippet_render() {
				if (DEV) {
					console.warn(
						`%c[svelte] invalid_raw_snippet_render\n%cThe \`render\` function passed to \`createRawSnippet\` should return HTML for a single element\nhttps://svelte.dev/e/invalid_raw_snippet_render`,
						a,
						o
					);
				} else {
					console.warn(`https://svelte.dev/e/invalid_raw_snippet_render`);
				}
			}
			function legacy_recursive_reactive_block(e) {
				if (DEV) {
					console.warn(
						`%c[svelte] legacy_recursive_reactive_block\n%cDetected a migrated \`$:\` reactive block in \`${e}\` that both accesses and updates the same reactive value. This may cause recursive updates when converted to an \`$effect\`.\nhttps://svelte.dev/e/legacy_recursive_reactive_block`,
						a,
						o
					);
				} else {
					console.warn(`https://svelte.dev/e/legacy_recursive_reactive_block`);
				}
			}
			function lifecycle_double_unmount() {
				if (i.A) {
					console.warn(
						`%c[svelte] lifecycle_double_unmount\n%cTried to unmount a component that was not mounted\nhttps://svelte.dev/e/lifecycle_double_unmount`,
						a,
						o
					);
				} else {
					console.warn(`https://svelte.dev/e/lifecycle_double_unmount`);
				}
			}
			function ownership_invalid_binding(e, t, r) {
				if (DEV) {
					console.warn(
						`%c[svelte] ownership_invalid_binding\n%c${e} passed a value to ${t} with \`bind:\`, but the value is owned by ${r}. Consider creating a binding between ${r} and ${e}\nhttps://svelte.dev/e/ownership_invalid_binding`,
						a,
						o
					);
				} else {
					console.warn(`https://svelte.dev/e/ownership_invalid_binding`);
				}
			}
			function ownership_invalid_mutation(e, t) {
				if (i.A) {
					console.warn(
						`%c[svelte] ownership_invalid_mutation\n%c${e ? `${e} mutated a value owned by ${t}. This is strongly discouraged. Consider passing values to child components with \`bind:\`, or use a callback instead` : 'Mutating a value outside the component that created it is strongly discouraged. Consider passing values to child components with `bind:`, or use a callback instead'}\nhttps://svelte.dev/e/ownership_invalid_mutation`,
						a,
						o
					);
				} else {
					console.warn(`https://svelte.dev/e/ownership_invalid_mutation`);
				}
			}
			function state_proxy_equality_mismatch(e) {
				if (i.A) {
					console.warn(
						`%c[svelte] state_proxy_equality_mismatch\n%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${e}\` will produce unexpected results\nhttps://svelte.dev/e/state_proxy_equality_mismatch`,
						a,
						o
					);
				} else {
					console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`);
				}
			}
			function transition_slide_display(e) {
				if (DEV) {
					console.warn(
						`%c[svelte] transition_slide_display\n%cThe \`slide\` transition does not work correctly for elements with \`display: ${e}\`\nhttps://svelte.dev/e/transition_slide_display`,
						a,
						o
					);
				} else {
					console.warn(`https://svelte.dev/e/transition_slide_display`);
				}
			}
		},
		1779: (e, t, r) => {
			'use strict';
			r.d(t, { LM: () => i, _G: () => a });
			let i = false;
			let a = false;
			function enable_legacy_mode_flag() {
				i = true;
			}
			function enable_tracing_mode_flag() {
				a = true;
			}
		},
		2508: (e, t, r) => {
			'use strict';
			var i = r(5372);
			const a = null && [];
			function snapshot(e, t = false) {
				if (DEV && !t) {
					const t = [];
					const r = clone(e, new Map(), '', t);
					if (t.length === 1 && t[0] === '') {
						w.state_snapshot_uncloneable();
					} else if (t.length > 0) {
						const e = t.length > 10 ? t.slice(0, 7) : t.slice(0, 10);
						const r = t.length - e.length;
						let i = e.map((e) => `- <value>${e}`).join('\n');
						if (r > 0) i += `\n- ...and ${r} more`;
						w.state_snapshot_uncloneable(i);
					}
					return r;
				}
				return clone(e, new Map(), '', a);
			}
			function clone(e, t, r, i, a = null) {
				if (typeof e === 'object' && e !== null) {
					var o = t.get(e);
					if (o !== undefined) return o;
					if (e instanceof Map) return new Map(e);
					if (e instanceof Set) return new Set(e);
					if (is_array(e)) {
						var c = Array(e.length);
						t.set(e, c);
						if (a !== null) {
							t.set(a, c);
						}
						for (var u = 0; u < e.length; u += 1) {
							var l = e[u];
							if (u in e) {
								c[u] = clone(l, t, DEV ? `${r}[${u}]` : r, i);
							}
						}
						return c;
					}
					if (get_prototype_of(e) === object_prototype) {
						c = {};
						t.set(e, c);
						if (a !== null) {
							t.set(a, c);
						}
						for (var d in e) {
							c[d] = clone(e[d], t, DEV ? `${r}.${d}` : r, i);
						}
						return c;
					}
					if (e instanceof Date) {
						return structuredClone(e);
					}
					if (typeof e.toJSON === 'function') {
						return clone(e.toJSON(), t, DEV ? `${r}.toJSON()` : r, i, e);
					}
				}
				if (e instanceof EventTarget) {
					return e;
				}
				try {
					return structuredClone(e);
				} catch (t) {
					if (DEV) {
						i.push(r);
					}
					return e;
				}
			}
		},
		5372: (e, t, r) => {
			'use strict';
			r.d(t, {
				J8: () => l,
				N7: () => p,
				Oh: () => g,
				PI: () => i,
				Qk: () => is_function,
				Qu: () => u,
				bg: () => o,
				d$: () => c,
				lQ: () => noop,
				lc: () => a,
				oO: () => run_all,
				ve: () => m
			});
			var i = Array.isArray;
			var a = Array.prototype.indexOf;
			var o = Array.from;
			var c = Object.keys;
			var u = Object.defineProperty;
			var l = Object.getOwnPropertyDescriptor;
			var d = Object.getOwnPropertyDescriptors;
			var p = Object.prototype;
			var m = Array.prototype;
			var g = Object.getPrototypeOf;
			function is_function(e) {
				return typeof e === 'function';
			}
			const noop = () => {};
			function is_promise(e) {
				return typeof e?.then === 'function';
			}
			function run(e) {
				return e();
			}
			function run_all(e) {
				for (var t = 0; t < e.length; t++) {
					e[t]();
				}
			}
			function deferred() {
				var e;
				var t;
				var r = new Promise((r, i) => {
					e = r;
					t = i;
				});
				return { promise: r, resolve: e, reject: t };
			}
			function fallback(e, t, r = false) {
				return e === undefined ? (r ? t() : t) : e;
			}
		},
		6681: (e, t, r) => {
			'use strict';
			var i = r(1951);
			var a = r(2522);
			var o = r(9246);
			function utils_increment(e) {
				set(e, e.v + 1);
			}
			function createSubscriber(e) {
				let t = 0;
				let r = source(0);
				let i;
				return () => {
					if (effect_tracking()) {
						get(r);
						render_effect(() => {
							if (t === 0) {
								i = untrack(() => e(() => increment(r)));
							}
							t += 1;
							return () => {
								tick().then(() => {
									t -= 1;
									if (t === 0) {
										i?.();
										i = undefined;
									}
								});
							};
						});
					}
				};
			}
		},
		2320: (e, t, r) => {
			'use strict';
			r.d(t, { GY: () => is_passive_event });
			const i = /\r/g;
			function hash(e) {
				e = e.replace(i, '');
				let t = 5381;
				let r = e.length;
				while (r--) t = ((t << 5) - t) ^ e.charCodeAt(r);
				return (t >>> 0).toString(36);
			}
			const a = null && [
				'area',
				'base',
				'br',
				'col',
				'command',
				'embed',
				'hr',
				'img',
				'input',
				'keygen',
				'link',
				'meta',
				'param',
				'source',
				'track',
				'wbr'
			];
			function is_void(e) {
				return a.includes(e) || e.toLowerCase() === '!doctype';
			}
			const o = null && [
				'arguments',
				'await',
				'break',
				'case',
				'catch',
				'class',
				'const',
				'continue',
				'debugger',
				'default',
				'delete',
				'do',
				'else',
				'enum',
				'eval',
				'export',
				'extends',
				'false',
				'finally',
				'for',
				'function',
				'if',
				'implements',
				'import',
				'in',
				'instanceof',
				'interface',
				'let',
				'new',
				'null',
				'package',
				'private',
				'protected',
				'public',
				'return',
				'static',
				'super',
				'switch',
				'this',
				'throw',
				'true',
				'try',
				'typeof',
				'var',
				'void',
				'while',
				'with',
				'yield'
			];
			function is_reserved(e) {
				return o.includes(e);
			}
			function is_capture_event(e) {
				return e.endsWith('capture') && e !== 'gotpointercapture' && e !== 'lostpointercapture';
			}
			const c = null && [
				'beforeinput',
				'click',
				'change',
				'dblclick',
				'contextmenu',
				'focusin',
				'focusout',
				'input',
				'keydown',
				'keyup',
				'mousedown',
				'mousemove',
				'mouseout',
				'mouseover',
				'mouseup',
				'pointerdown',
				'pointermove',
				'pointerout',
				'pointerover',
				'pointerup',
				'touchend',
				'touchmove',
				'touchstart'
			];
			function is_delegated(e) {
				return c.includes(e);
			}
			const u = [
				'allowfullscreen',
				'async',
				'autofocus',
				'autoplay',
				'checked',
				'controls',
				'default',
				'disabled',
				'formnovalidate',
				'hidden',
				'indeterminate',
				'inert',
				'ismap',
				'loop',
				'multiple',
				'muted',
				'nomodule',
				'novalidate',
				'open',
				'playsinline',
				'readonly',
				'required',
				'reversed',
				'seamless',
				'selected',
				'webkitdirectory'
			];
			function is_boolean_attribute(e) {
				return u.includes(e);
			}
			const l = {
				formnovalidate: 'formNoValidate',
				ismap: 'isMap',
				nomodule: 'noModule',
				playsinline: 'playsInline',
				readonly: 'readOnly',
				defaultvalue: 'defaultValue',
				defaultchecked: 'defaultChecked',
				srcobject: 'srcObject'
			};
			function normalize_attribute(e) {
				e = e.toLowerCase();
				return l[e] ?? e;
			}
			const d = [
				...u,
				'formNoValidate',
				'isMap',
				'noModule',
				'playsInline',
				'readOnly',
				'value',
				'volume',
				'defaultValue',
				'defaultChecked',
				'srcObject'
			];
			function is_dom_property(e) {
				return d.includes(e);
			}
			const p = null && ['autofocus', 'muted', 'defaultValue', 'defaultChecked'];
			function cannot_be_set_statically(e) {
				return p.includes(e);
			}
			const m = ['touchstart', 'touchmove'];
			function is_passive_event(e) {
				return m.includes(e);
			}
			const g = null && ['textContent', 'innerHTML', 'innerText'];
			function is_content_editable_binding(e) {
				return g.includes(e);
			}
			const v = null && [
				'body',
				'embed',
				'iframe',
				'img',
				'link',
				'object',
				'script',
				'style',
				'track'
			];
			function is_load_error_element(e) {
				return v.includes(e);
			}
			const y = null && [
				'altGlyph',
				'altGlyphDef',
				'altGlyphItem',
				'animate',
				'animateColor',
				'animateMotion',
				'animateTransform',
				'circle',
				'clipPath',
				'color-profile',
				'cursor',
				'defs',
				'desc',
				'discard',
				'ellipse',
				'feBlend',
				'feColorMatrix',
				'feComponentTransfer',
				'feComposite',
				'feConvolveMatrix',
				'feDiffuseLighting',
				'feDisplacementMap',
				'feDistantLight',
				'feDropShadow',
				'feFlood',
				'feFuncA',
				'feFuncB',
				'feFuncG',
				'feFuncR',
				'feGaussianBlur',
				'feImage',
				'feMerge',
				'feMergeNode',
				'feMorphology',
				'feOffset',
				'fePointLight',
				'feSpecularLighting',
				'feSpotLight',
				'feTile',
				'feTurbulence',
				'filter',
				'font',
				'font-face',
				'font-face-format',
				'font-face-name',
				'font-face-src',
				'font-face-uri',
				'foreignObject',
				'g',
				'glyph',
				'glyphRef',
				'hatch',
				'hatchpath',
				'hkern',
				'image',
				'line',
				'linearGradient',
				'marker',
				'mask',
				'mesh',
				'meshgradient',
				'meshpatch',
				'meshrow',
				'metadata',
				'missing-glyph',
				'mpath',
				'path',
				'pattern',
				'polygon',
				'polyline',
				'radialGradient',
				'rect',
				'set',
				'solidcolor',
				'stop',
				'svg',
				'switch',
				'symbol',
				'text',
				'textPath',
				'tref',
				'tspan',
				'unknown',
				'use',
				'view',
				'vkern'
			];
			function is_svg(e) {
				return y.includes(e);
			}
			const w = null && [
				'annotation',
				'annotation-xml',
				'maction',
				'math',
				'merror',
				'mfrac',
				'mi',
				'mmultiscripts',
				'mn',
				'mo',
				'mover',
				'mpadded',
				'mphantom',
				'mprescripts',
				'mroot',
				'mrow',
				'ms',
				'mspace',
				'msqrt',
				'mstyle',
				'msub',
				'msubsup',
				'msup',
				'mtable',
				'mtd',
				'mtext',
				'mtr',
				'munder',
				'munderover',
				'semantics'
			];
			function is_mathml(e) {
				return w.includes(e);
			}
			const _ = null && [
				'$state',
				'$state.raw',
				'$state.snapshot',
				'$props',
				'$bindable',
				'$derived',
				'$derived.by',
				'$effect',
				'$effect.pre',
				'$effect.tracking',
				'$effect.root',
				'$inspect',
				'$inspect().with',
				'$inspect.trace',
				'$host'
			];
			function is_rune(e) {
				return _.includes(e);
			}
			const A = null && ['textarea', 'script', 'style', 'title'];
			function is_raw_text_element(e) {
				return A.includes(e);
			}
			function sanitize_location(e) {
				return e?.replace(/\//g, '/');
			}
		},
		3349: (e) => {
			'use strict';
			e.exports = JSON.parse(
				'{"aes-128-ecb":{"cipher":"AES","key":128,"iv":0,"mode":"ECB","type":"block"},"aes-192-ecb":{"cipher":"AES","key":192,"iv":0,"mode":"ECB","type":"block"},"aes-256-ecb":{"cipher":"AES","key":256,"iv":0,"mode":"ECB","type":"block"},"aes-128-cbc":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes-192-cbc":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes-256-cbc":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes128":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes192":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes256":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes-128-cfb":{"cipher":"AES","key":128,"iv":16,"mode":"CFB","type":"stream"},"aes-192-cfb":{"cipher":"AES","key":192,"iv":16,"mode":"CFB","type":"stream"},"aes-256-cfb":{"cipher":"AES","key":256,"iv":16,"mode":"CFB","type":"stream"},"aes-128-cfb8":{"cipher":"AES","key":128,"iv":16,"mode":"CFB8","type":"stream"},"aes-192-cfb8":{"cipher":"AES","key":192,"iv":16,"mode":"CFB8","type":"stream"},"aes-256-cfb8":{"cipher":"AES","key":256,"iv":16,"mode":"CFB8","type":"stream"},"aes-128-cfb1":{"cipher":"AES","key":128,"iv":16,"mode":"CFB1","type":"stream"},"aes-192-cfb1":{"cipher":"AES","key":192,"iv":16,"mode":"CFB1","type":"stream"},"aes-256-cfb1":{"cipher":"AES","key":256,"iv":16,"mode":"CFB1","type":"stream"},"aes-128-ofb":{"cipher":"AES","key":128,"iv":16,"mode":"OFB","type":"stream"},"aes-192-ofb":{"cipher":"AES","key":192,"iv":16,"mode":"OFB","type":"stream"},"aes-256-ofb":{"cipher":"AES","key":256,"iv":16,"mode":"OFB","type":"stream"},"aes-128-ctr":{"cipher":"AES","key":128,"iv":16,"mode":"CTR","type":"stream"},"aes-192-ctr":{"cipher":"AES","key":192,"iv":16,"mode":"CTR","type":"stream"},"aes-256-ctr":{"cipher":"AES","key":256,"iv":16,"mode":"CTR","type":"stream"},"aes-128-gcm":{"cipher":"AES","key":128,"iv":12,"mode":"GCM","type":"auth"},"aes-192-gcm":{"cipher":"AES","key":192,"iv":12,"mode":"GCM","type":"auth"},"aes-256-gcm":{"cipher":"AES","key":256,"iv":12,"mode":"GCM","type":"auth"}}'
			);
		},
		7595: (e) => {
			'use strict';
			e.exports = JSON.parse(
				'{"sha224WithRSAEncryption":{"sign":"rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"RSA-SHA224":{"sign":"ecdsa/rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"sha256WithRSAEncryption":{"sign":"rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"RSA-SHA256":{"sign":"ecdsa/rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"sha384WithRSAEncryption":{"sign":"rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"RSA-SHA384":{"sign":"ecdsa/rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"sha512WithRSAEncryption":{"sign":"rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA512":{"sign":"ecdsa/rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA1":{"sign":"rsa","hash":"sha1","id":"3021300906052b0e03021a05000414"},"ecdsa-with-SHA1":{"sign":"ecdsa","hash":"sha1","id":""},"sha256":{"sign":"ecdsa","hash":"sha256","id":""},"sha224":{"sign":"ecdsa","hash":"sha224","id":""},"sha384":{"sign":"ecdsa","hash":"sha384","id":""},"sha512":{"sign":"ecdsa","hash":"sha512","id":""},"DSA-SHA":{"sign":"dsa","hash":"sha1","id":""},"DSA-SHA1":{"sign":"dsa","hash":"sha1","id":""},"DSA":{"sign":"dsa","hash":"sha1","id":""},"DSA-WITH-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-WITH-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-WITH-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-WITH-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-RIPEMD160":{"sign":"dsa","hash":"rmd160","id":""},"ripemd160WithRSA":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"RSA-RIPEMD160":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"md5WithRSAEncryption":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"},"RSA-MD5":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"}}'
			);
		},
		9729: (e) => {
			'use strict';
			e.exports = JSON.parse(
				'{"1.3.132.0.10":"secp256k1","1.3.132.0.33":"p224","1.2.840.10045.3.1.1":"p192","1.2.840.10045.3.1.7":"p256","1.3.132.0.34":"p384","1.3.132.0.35":"p521"}'
			);
		},
		7821: (e) => {
			'use strict';
			e.exports = JSON.parse(
				'{"modp1":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"},"modp2":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"},"modp5":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"},"modp14":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"},"modp15":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"},"modp16":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"},"modp17":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"},"modp18":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"}}'
			);
		},
		3718: (e) => {
			'use strict';
			e.exports = { rE: '6.6.1' };
		},
		482: (e) => {
			'use strict';
			e.exports = JSON.parse(
				'{"2.16.840.1.101.3.4.1.1":"aes-128-ecb","2.16.840.1.101.3.4.1.2":"aes-128-cbc","2.16.840.1.101.3.4.1.3":"aes-128-ofb","2.16.840.1.101.3.4.1.4":"aes-128-cfb","2.16.840.1.101.3.4.1.21":"aes-192-ecb","2.16.840.1.101.3.4.1.22":"aes-192-cbc","2.16.840.1.101.3.4.1.23":"aes-192-ofb","2.16.840.1.101.3.4.1.24":"aes-192-cfb","2.16.840.1.101.3.4.1.41":"aes-256-ecb","2.16.840.1.101.3.4.1.42":"aes-256-cbc","2.16.840.1.101.3.4.1.43":"aes-256-ofb","2.16.840.1.101.3.4.1.44":"aes-256-cfb"}'
			);
		}
	}
]);
