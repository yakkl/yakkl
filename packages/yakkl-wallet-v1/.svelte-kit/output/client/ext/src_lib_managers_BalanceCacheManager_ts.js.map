{"version":3,"file":"src_lib_managers_BalanceCacheManager_ts.js","mappings":"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","sources":["webpack://yakkl-wallet/./src/lib/managers/BalanceCacheManager.ts"],"sourcesContent":["import { log } from '$lib/managers/Logger';\nexport class BalanceCacheManager {\n    static instance = null;\n    CACHE_KEY = 'yakkl_balance_cache';\n    CACHE_DURATION = 15 * 60 * 1000; // 15 minutes (increased from 5 to reduce API calls)\n    STALE_DURATION = 10 * 60 * 1000; // 10 minutes (increased from 2 to reduce background refreshes)\n    cache = new Map();\n    constructor() {\n        this.loadFromStorage();\n    }\n    static getInstance() {\n        if (!BalanceCacheManager.instance) {\n            BalanceCacheManager.instance = new BalanceCacheManager();\n        }\n        return BalanceCacheManager.instance;\n    }\n    /**\n     * Get cached balance data for an address\n     */\n    getCachedBalance(address) {\n        const cached = this.cache.get(address.toLowerCase());\n        if (!cached)\n            return null;\n        // Check if cache is expired\n        const age = Date.now() - cached.timestamp;\n        if (age > this.CACHE_DURATION) {\n            this.cache.delete(address.toLowerCase());\n            this.saveToStorage();\n            return null;\n        }\n        return cached;\n    }\n    /**\n     * Check if cached data is stale (older than 2 minutes)\n     */\n    isStale(address) {\n        const cached = this.cache.get(address.toLowerCase());\n        if (!cached)\n            return false;\n        const age = Date.now() - cached.timestamp;\n        return age > this.STALE_DURATION;\n    }\n    /**\n     * Set balance data in cache\n     */\n    setCachedBalance(address, balance, price) {\n        const cacheData = {\n            address: address.toLowerCase(),\n            balance,\n            timestamp: Date.now(),\n            price\n        };\n        this.cache.set(address.toLowerCase(), cacheData);\n        this.saveToStorage();\n        log.debug('[BalanceCacheManager] Cached balance for address:', false, {\n            address: address.toLowerCase(),\n            balance: balance.toString(),\n            price\n        });\n    }\n    /**\n     * Clear all cached data\n     */\n    clearCache() {\n        this.cache.clear();\n        localStorage.removeItem(this.CACHE_KEY);\n        log.info('[BalanceCacheManager] Cache cleared');\n    }\n    /**\n     * Clear cached data for specific address\n     */\n    clearCachedBalance(address) {\n        this.cache.delete(address.toLowerCase());\n        this.saveToStorage();\n    }\n    /**\n     * Update price for all cached entries (called when price changes)\n     */\n    updatePriceForAllEntries(newPrice) {\n        let updated = 0;\n        for (const [address, data] of this.cache.entries()) {\n            // Only update if price actually changed\n            if (data.price !== newPrice) {\n                this.cache.set(address, {\n                    ...data,\n                    price: newPrice,\n                    timestamp: Date.now() // Refresh timestamp since value changed\n                });\n                updated++;\n            }\n        }\n        if (updated > 0) {\n            this.saveToStorage();\n            log.info(`[BalanceCacheManager] Updated price for ${updated} cached entries to ${newPrice}`);\n        }\n    }\n    /**\n     * Get all cached addresses\n     */\n    getCachedAddresses() {\n        return Array.from(this.cache.keys());\n    }\n    /**\n     * Clean up expired entries\n     */\n    cleanupExpired() {\n        const now = Date.now();\n        let cleaned = 0;\n        for (const [address, data] of this.cache.entries()) {\n            if (now - data.timestamp > this.CACHE_DURATION) {\n                this.cache.delete(address);\n                cleaned++;\n            }\n        }\n        if (cleaned > 0) {\n            this.saveToStorage();\n            log.info(`[BalanceCacheManager] Cleaned up ${cleaned} expired entries`);\n        }\n    }\n    /**\n     * Preload balances for given addresses (returns cached data immediately)\n     */\n    preloadBalances(addresses) {\n        const preloaded = new Map();\n        for (const address of addresses) {\n            const cached = this.getCachedBalance(address);\n            if (cached) {\n                preloaded.set(address.toLowerCase(), cached);\n            }\n        }\n        log.debug(`[BalanceCacheManager] Preloaded ${preloaded.size}/${addresses.length} balances from cache`);\n        return preloaded;\n    }\n    /**\n     * Load cache from localStorage\n     */\n    loadFromStorage() {\n        try {\n            const stored = localStorage.getItem(this.CACHE_KEY);\n            if (stored) {\n                const parsed = JSON.parse(stored);\n                this.cache = new Map(Object.entries(parsed).map(([address, data]) => [\n                    address,\n                    {\n                        ...data,\n                        balance: BigInt(data.balance) // Convert balance back to BigInt\n                    }\n                ]));\n                // Clean up expired entries on load\n                this.cleanupExpired();\n                log.debug(`[BalanceCacheManager] Loaded ${this.cache.size} entries from storage`);\n            }\n        }\n        catch (error) {\n            log.warn('[BalanceCacheManager] Failed to load cache from storage:', false, error);\n            this.cache = new Map();\n        }\n    }\n    /**\n     * Save cache to localStorage\n     */\n    saveToStorage() {\n        try {\n            const serializable = Object.fromEntries(Array.from(this.cache.entries()).map(([address, data]) => [\n                address,\n                {\n                    ...data,\n                    balance: data.balance.toString() // Convert BigInt to string for JSON\n                }\n            ]));\n            localStorage.setItem(this.CACHE_KEY, JSON.stringify(serializable));\n        }\n        catch (error) {\n            log.warn('[BalanceCacheManager] Failed to save cache to storage:', false, error);\n        }\n    }\n    /**\n     * Get cache statistics\n     */\n    getCacheStats() {\n        const now = Date.now();\n        let fresh = 0;\n        let stale = 0;\n        let expired = 0;\n        for (const data of this.cache.values()) {\n            const age = now - data.timestamp;\n            if (age > this.CACHE_DURATION) {\n                expired++;\n            }\n            else if (age > this.STALE_DURATION) {\n                stale++;\n            }\n            else {\n                fresh++;\n            }\n        }\n        return {\n            totalEntries: this.cache.size,\n            freshEntries: fresh,\n            staleEntries: stale,\n            expiredEntries: expired\n        };\n    }\n}\n// Export singleton instance\nexport const balanceCacheManager = BalanceCacheManager.getInstance();\n"],"names":["BalanceCacheManager","static","CACHE_KEY","CACHE_DURATION","STALE_DURATION","cache","Map","constructor","this","loadFromStorage","getInstance","instance","getCachedBalance","address","cached","get","toLowerCase","age","Date","now","timestamp","delete","saveToStorage","isStale","setCachedBalance","balance","price","cacheData","set","log","debug","toString","clearCache","clear","localStorage","removeItem","info","clearCachedBalance","updatePriceForAllEntries","newPrice","updated","data","entries","getCachedAddresses","Array","from","keys","cleanupExpired","cleaned","preloadBalances","addresses","preloaded","size","length","stored","getItem","parsed","JSON","parse","Object","map","BigInt","error","warn","serializable","fromEntries","setItem","stringify","getCacheStats","fresh","stale","expired","values","totalEntries","freshEntries","staleEntries","expiredEntries","balanceCacheManager"],"sourceRoot":""}