/*! For license information please see node_modules_pnpm_readable-stream_4_7_0_node_modules_readable-stream_lib_ours_browser_js.js.LICENSE.txt */
(self['webpackChunkyakkl_wallet'] = self['webpackChunkyakkl_wallet'] || []).push([
	['node_modules_pnpm_readable-stream_4_7_0_node_modules_readable-stream_lib_ours_browser_js'],
	{
		'../../node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller/browser.js': (
			e
		) => {
			'use strict';
			const { AbortController: t, AbortSignal: r } =
				typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : undefined;
			e.exports = t;
			e.exports.AbortSignal = r;
			e.exports['default'] = t;
		},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js':
			(e, t, r) => {
				'use strict';
				const { SymbolDispose: n } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				);
				const { AbortError: a, codes: o } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/errors.js'
				);
				const {
					isNodeStream: s,
					isWebStream: i,
					kControllerErrorFunction: l
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/utils.js'
				);
				const d = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/end-of-stream.js'
				);
				const { ERR_INVALID_ARG_TYPE: u } = o;
				let f;
				const validateAbortSignal = (e, t) => {
					if (typeof e !== 'object' || !('aborted' in e)) {
						throw new u(t, 'AbortSignal', e);
					}
				};
				e.exports.addAbortSignal = function addAbortSignal(t, r) {
					validateAbortSignal(t, 'signal');
					if (!s(r) && !i(r)) {
						throw new u('stream', ['ReadableStream', 'WritableStream', 'Stream'], r);
					}
					return e.exports.addAbortSignalNoValidate(t, r);
				};
				e.exports.addAbortSignalNoValidate = function (e, t) {
					if (typeof e !== 'object' || !('aborted' in e)) {
						return t;
					}
					const o = s(t)
						? () => {
								t.destroy(new a(undefined, { cause: e.reason }));
							}
						: () => {
								t[l](new a(undefined, { cause: e.reason }));
							};
					if (e.aborted) {
						o();
					} else {
						f =
							f ||
							r(
								'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util.js'
							).addAbortListener;
						const a = f(e, o);
						d(t, a[n]);
					}
					return t;
				};
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/buffer_list.js':
			(e, t, r) => {
				'use strict';
				const {
					StringPrototypeSlice: n,
					SymbolIterator: a,
					TypedArrayPrototypeSet: o,
					Uint8Array: s
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				);
				const { Buffer: i } = r(
					'../../node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js'
				);
				const { inspect: l } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util.js'
				);
				e.exports = class BufferList {
					constructor() {
						this.head = null;
						this.tail = null;
						this.length = 0;
					}
					push(e) {
						const t = { data: e, next: null };
						if (this.length > 0) this.tail.next = t;
						else this.head = t;
						this.tail = t;
						++this.length;
					}
					unshift(e) {
						const t = { data: e, next: this.head };
						if (this.length === 0) this.tail = t;
						this.head = t;
						++this.length;
					}
					shift() {
						if (this.length === 0) return;
						const e = this.head.data;
						if (this.length === 1) this.head = this.tail = null;
						else this.head = this.head.next;
						--this.length;
						return e;
					}
					clear() {
						this.head = this.tail = null;
						this.length = 0;
					}
					join(e) {
						if (this.length === 0) return '';
						let t = this.head;
						let r = '' + t.data;
						while ((t = t.next) !== null) r += e + t.data;
						return r;
					}
					concat(e) {
						if (this.length === 0) return i.alloc(0);
						const t = i.allocUnsafe(e >>> 0);
						let r = this.head;
						let n = 0;
						while (r) {
							o(t, r.data, n);
							n += r.data.length;
							r = r.next;
						}
						return t;
					}
					consume(e, t) {
						const r = this.head.data;
						if (e < r.length) {
							const t = r.slice(0, e);
							this.head.data = r.slice(e);
							return t;
						}
						if (e === r.length) {
							return this.shift();
						}
						return t ? this._getString(e) : this._getBuffer(e);
					}
					first() {
						return this.head.data;
					}
					*[a]() {
						for (let e = this.head; e; e = e.next) {
							yield e.data;
						}
					}
					_getString(e) {
						let t = '';
						let r = this.head;
						let a = 0;
						do {
							const o = r.data;
							if (e > o.length) {
								t += o;
								e -= o.length;
							} else {
								if (e === o.length) {
									t += o;
									++a;
									if (r.next) this.head = r.next;
									else this.head = this.tail = null;
								} else {
									t += n(o, 0, e);
									this.head = r;
									r.data = n(o, e);
								}
								break;
							}
							++a;
						} while ((r = r.next) !== null);
						this.length -= a;
						return t;
					}
					_getBuffer(e) {
						const t = i.allocUnsafe(e);
						const r = e;
						let n = this.head;
						let a = 0;
						do {
							const i = n.data;
							if (e > i.length) {
								o(t, i, r - e);
								e -= i.length;
							} else {
								if (e === i.length) {
									o(t, i, r - e);
									++a;
									if (n.next) this.head = n.next;
									else this.head = this.tail = null;
								} else {
									o(t, new s(i.buffer, i.byteOffset, e), r - e);
									this.head = n;
									n.data = i.slice(e);
								}
								break;
							}
							++a;
						} while ((n = n.next) !== null);
						this.length -= a;
						return t;
					}
					[Symbol.for('nodejs.util.inspect.custom')](e, t) {
						return l(this, { ...t, depth: 0, customInspect: false });
					}
				};
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/compose.js':
			(e, t, r) => {
				'use strict';
				const { pipeline: n } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/pipeline.js'
				);
				const a = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/duplex.js'
				);
				const { destroyer: o } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/destroy.js'
				);
				const {
					isNodeStream: s,
					isReadable: i,
					isWritable: l,
					isWebStream: d,
					isTransformStream: u,
					isWritableStream: f,
					isReadableStream: c
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/utils.js'
				);
				const {
					AbortError: b,
					codes: { ERR_INVALID_ARG_VALUE: m, ERR_MISSING_ARGS: p }
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/errors.js'
				);
				const h = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/end-of-stream.js'
				);
				e.exports = function compose(...e) {
					if (e.length === 0) {
						throw new p('streams');
					}
					if (e.length === 1) {
						return a.from(e[0]);
					}
					const t = [...e];
					if (typeof e[0] === 'function') {
						e[0] = a.from(e[0]);
					}
					if (typeof e[e.length - 1] === 'function') {
						const t = e.length - 1;
						e[t] = a.from(e[t]);
					}
					for (let r = 0; r < e.length; ++r) {
						if (!s(e[r]) && !d(e[r])) {
							continue;
						}
						if (r < e.length - 1 && !(i(e[r]) || c(e[r]) || u(e[r]))) {
							throw new m(`streams[${r}]`, t[r], 'must be readable');
						}
						if (r > 0 && !(l(e[r]) || f(e[r]) || u(e[r]))) {
							throw new m(`streams[${r}]`, t[r], 'must be writable');
						}
					}
					let r;
					let _;
					let y;
					let g;
					let w;
					function onfinished(e) {
						const t = g;
						g = null;
						if (t) {
							t(e);
						} else if (e) {
							w.destroy(e);
						} else if (!j && !A) {
							w.destroy();
						}
					}
					const S = e[0];
					const R = n(e, onfinished);
					const A = !!(l(S) || f(S) || u(S));
					const j = !!(i(R) || c(R) || u(R));
					w = new a({
						writableObjectMode: !!(S !== null && S !== undefined && S.writableObjectMode),
						readableObjectMode: !!(R !== null && R !== undefined && R.readableObjectMode),
						writable: A,
						readable: j
					});
					if (A) {
						if (s(S)) {
							w._write = function (e, t, n) {
								if (S.write(e, t)) {
									n();
								} else {
									r = n;
								}
							};
							w._final = function (e) {
								S.end();
								_ = e;
							};
							S.on('drain', function () {
								if (r) {
									const e = r;
									r = null;
									e();
								}
							});
						} else if (d(S)) {
							const e = u(S) ? S.writable : S;
							const t = e.getWriter();
							w._write = async function (e, r, n) {
								try {
									await t.ready;
									t.write(e).catch(() => {});
									n();
								} catch (e) {
									n(e);
								}
							};
							w._final = async function (e) {
								try {
									await t.ready;
									t.close().catch(() => {});
									_ = e;
								} catch (t) {
									e(t);
								}
							};
						}
						const e = u(R) ? R.readable : R;
						h(e, () => {
							if (_) {
								const e = _;
								_ = null;
								e();
							}
						});
					}
					if (j) {
						if (s(R)) {
							R.on('readable', function () {
								if (y) {
									const e = y;
									y = null;
									e();
								}
							});
							R.on('end', function () {
								w.push(null);
							});
							w._read = function () {
								while (true) {
									const e = R.read();
									if (e === null) {
										y = w._read;
										return;
									}
									if (!w.push(e)) {
										return;
									}
								}
							};
						} else if (d(R)) {
							const e = u(R) ? R.readable : R;
							const t = e.getReader();
							w._read = async function () {
								while (true) {
									try {
										const { value: e, done: r } = await t.read();
										if (!w.push(e)) {
											return;
										}
										if (r) {
											w.push(null);
											return;
										}
									} catch {
										return;
									}
								}
							};
						}
					}
					w._destroy = function (e, t) {
						if (!e && g !== null) {
							e = new b();
						}
						y = null;
						r = null;
						_ = null;
						if (g === null) {
							t(e);
						} else {
							g = t;
							if (s(R)) {
								o(R, e);
							}
						}
					};
					return w;
				};
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/destroy.js':
			(e, t, r) => {
				'use strict';
				const n = r('../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js');
				const {
					aggregateTwoErrors: a,
					codes: { ERR_MULTIPLE_CALLBACK: o },
					AbortError: s
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/errors.js'
				);
				const { Symbol: i } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				);
				const {
					kIsDestroyed: l,
					isDestroyed: d,
					isFinished: u,
					isServerRequest: f
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/utils.js'
				);
				const c = i('kDestroy');
				const b = i('kConstruct');
				function checkError(e, t, r) {
					if (e) {
						e.stack;
						if (t && !t.errored) {
							t.errored = e;
						}
						if (r && !r.errored) {
							r.errored = e;
						}
					}
				}
				function destroy(e, t) {
					const r = this._readableState;
					const n = this._writableState;
					const o = n || r;
					if (
						(n !== null && n !== undefined && n.destroyed) ||
						(r !== null && r !== undefined && r.destroyed)
					) {
						if (typeof t === 'function') {
							t();
						}
						return this;
					}
					checkError(e, n, r);
					if (n) {
						n.destroyed = true;
					}
					if (r) {
						r.destroyed = true;
					}
					if (!o.constructed) {
						this.once(c, function (r) {
							_destroy(this, a(r, e), t);
						});
					} else {
						_destroy(this, e, t);
					}
					return this;
				}
				function _destroy(e, t, r) {
					let a = false;
					function onDestroy(t) {
						if (a) {
							return;
						}
						a = true;
						const o = e._readableState;
						const s = e._writableState;
						checkError(t, s, o);
						if (s) {
							s.closed = true;
						}
						if (o) {
							o.closed = true;
						}
						if (typeof r === 'function') {
							r(t);
						}
						if (t) {
							n.nextTick(emitErrorCloseNT, e, t);
						} else {
							n.nextTick(emitCloseNT, e);
						}
					}
					try {
						e._destroy(t || null, onDestroy);
					} catch (t) {
						onDestroy(t);
					}
				}
				function emitErrorCloseNT(e, t) {
					emitErrorNT(e, t);
					emitCloseNT(e);
				}
				function emitCloseNT(e) {
					const t = e._readableState;
					const r = e._writableState;
					if (r) {
						r.closeEmitted = true;
					}
					if (t) {
						t.closeEmitted = true;
					}
					if (
						(r !== null && r !== undefined && r.emitClose) ||
						(t !== null && t !== undefined && t.emitClose)
					) {
						e.emit('close');
					}
				}
				function emitErrorNT(e, t) {
					const r = e._readableState;
					const n = e._writableState;
					if (
						(n !== null && n !== undefined && n.errorEmitted) ||
						(r !== null && r !== undefined && r.errorEmitted)
					) {
						return;
					}
					if (n) {
						n.errorEmitted = true;
					}
					if (r) {
						r.errorEmitted = true;
					}
					e.emit('error', t);
				}
				function undestroy() {
					const e = this._readableState;
					const t = this._writableState;
					if (e) {
						e.constructed = true;
						e.closed = false;
						e.closeEmitted = false;
						e.destroyed = false;
						e.errored = null;
						e.errorEmitted = false;
						e.reading = false;
						e.ended = e.readable === false;
						e.endEmitted = e.readable === false;
					}
					if (t) {
						t.constructed = true;
						t.destroyed = false;
						t.closed = false;
						t.closeEmitted = false;
						t.errored = null;
						t.errorEmitted = false;
						t.finalCalled = false;
						t.prefinished = false;
						t.ended = t.writable === false;
						t.ending = t.writable === false;
						t.finished = t.writable === false;
					}
				}
				function errorOrDestroy(e, t, r) {
					const a = e._readableState;
					const o = e._writableState;
					if (
						(o !== null && o !== undefined && o.destroyed) ||
						(a !== null && a !== undefined && a.destroyed)
					) {
						return this;
					}
					if (
						(a !== null && a !== undefined && a.autoDestroy) ||
						(o !== null && o !== undefined && o.autoDestroy)
					)
						e.destroy(t);
					else if (t) {
						t.stack;
						if (o && !o.errored) {
							o.errored = t;
						}
						if (a && !a.errored) {
							a.errored = t;
						}
						if (r) {
							n.nextTick(emitErrorNT, e, t);
						} else {
							emitErrorNT(e, t);
						}
					}
				}
				function construct(e, t) {
					if (typeof e._construct !== 'function') {
						return;
					}
					const r = e._readableState;
					const a = e._writableState;
					if (r) {
						r.constructed = false;
					}
					if (a) {
						a.constructed = false;
					}
					e.once(b, t);
					if (e.listenerCount(b) > 1) {
						return;
					}
					n.nextTick(constructNT, e);
				}
				function constructNT(e) {
					let t = false;
					function onConstruct(r) {
						if (t) {
							errorOrDestroy(e, r !== null && r !== undefined ? r : new o());
							return;
						}
						t = true;
						const a = e._readableState;
						const s = e._writableState;
						const i = s || a;
						if (a) {
							a.constructed = true;
						}
						if (s) {
							s.constructed = true;
						}
						if (i.destroyed) {
							e.emit(c, r);
						} else if (r) {
							errorOrDestroy(e, r, true);
						} else {
							n.nextTick(emitConstructNT, e);
						}
					}
					try {
						e._construct((e) => {
							n.nextTick(onConstruct, e);
						});
					} catch (e) {
						n.nextTick(onConstruct, e);
					}
				}
				function emitConstructNT(e) {
					e.emit(b);
				}
				function isRequest(e) {
					return (
						(e === null || e === undefined ? undefined : e.setHeader) &&
						typeof e.abort === 'function'
					);
				}
				function emitCloseLegacy(e) {
					e.emit('close');
				}
				function emitErrorCloseLegacy(e, t) {
					e.emit('error', t);
					n.nextTick(emitCloseLegacy, e);
				}
				function destroyer(e, t) {
					if (!e || d(e)) {
						return;
					}
					if (!t && !u(e)) {
						t = new s();
					}
					if (f(e)) {
						e.socket = null;
						e.destroy(t);
					} else if (isRequest(e)) {
						e.abort();
					} else if (isRequest(e.req)) {
						e.req.abort();
					} else if (typeof e.destroy === 'function') {
						e.destroy(t);
					} else if (typeof e.close === 'function') {
						e.close();
					} else if (t) {
						n.nextTick(emitErrorCloseLegacy, e, t);
					} else {
						n.nextTick(emitCloseLegacy, e);
					}
					if (!e.destroyed) {
						e[l] = true;
					}
				}
				e.exports = { construct, destroyer, destroy, undestroy, errorOrDestroy };
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/duplex.js':
			(e, t, r) => {
				'use strict';
				const {
					ObjectDefineProperties: n,
					ObjectGetOwnPropertyDescriptor: a,
					ObjectKeys: o,
					ObjectSetPrototypeOf: s
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				);
				e.exports = Duplex;
				const i = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/readable.js'
				);
				const l = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/writable.js'
				);
				s(Duplex.prototype, i.prototype);
				s(Duplex, i);
				{
					const e = o(l.prototype);
					for (let t = 0; t < e.length; t++) {
						const r = e[t];
						if (!Duplex.prototype[r]) Duplex.prototype[r] = l.prototype[r];
					}
				}
				function Duplex(e) {
					if (!(this instanceof Duplex)) return new Duplex(e);
					i.call(this, e);
					l.call(this, e);
					if (e) {
						this.allowHalfOpen = e.allowHalfOpen !== false;
						if (e.readable === false) {
							this._readableState.readable = false;
							this._readableState.ended = true;
							this._readableState.endEmitted = true;
						}
						if (e.writable === false) {
							this._writableState.writable = false;
							this._writableState.ending = true;
							this._writableState.ended = true;
							this._writableState.finished = true;
						}
					} else {
						this.allowHalfOpen = true;
					}
				}
				n(Duplex.prototype, {
					writable: { __proto__: null, ...a(l.prototype, 'writable') },
					writableHighWaterMark: { __proto__: null, ...a(l.prototype, 'writableHighWaterMark') },
					writableObjectMode: { __proto__: null, ...a(l.prototype, 'writableObjectMode') },
					writableBuffer: { __proto__: null, ...a(l.prototype, 'writableBuffer') },
					writableLength: { __proto__: null, ...a(l.prototype, 'writableLength') },
					writableFinished: { __proto__: null, ...a(l.prototype, 'writableFinished') },
					writableCorked: { __proto__: null, ...a(l.prototype, 'writableCorked') },
					writableEnded: { __proto__: null, ...a(l.prototype, 'writableEnded') },
					writableNeedDrain: { __proto__: null, ...a(l.prototype, 'writableNeedDrain') },
					destroyed: {
						__proto__: null,
						get() {
							if (this._readableState === undefined || this._writableState === undefined) {
								return false;
							}
							return this._readableState.destroyed && this._writableState.destroyed;
						},
						set(e) {
							if (this._readableState && this._writableState) {
								this._readableState.destroyed = e;
								this._writableState.destroyed = e;
							}
						}
					}
				});
				let d;
				function lazyWebStreams() {
					if (d === undefined) d = {};
					return d;
				}
				Duplex.fromWeb = function (e, t) {
					return lazyWebStreams().newStreamDuplexFromReadableWritablePair(e, t);
				};
				Duplex.toWeb = function (e) {
					return lazyWebStreams().newReadableWritablePairFromDuplex(e);
				};
				let u;
				Duplex.from = function (e) {
					if (!u) {
						u = r(
							'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/duplexify.js'
						);
					}
					return u(e, 'body');
				};
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/duplexify.js':
			(e, t, r) => {
				const n = r('../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js');
				('use strict');
				const a = r('../../node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js');
				const {
					isReadable: o,
					isWritable: s,
					isIterable: i,
					isNodeStream: l,
					isReadableNodeStream: d,
					isWritableNodeStream: u,
					isDuplexNodeStream: f,
					isReadableStream: c,
					isWritableStream: b
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/utils.js'
				);
				const m = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/end-of-stream.js'
				);
				const {
					AbortError: p,
					codes: { ERR_INVALID_ARG_TYPE: h, ERR_INVALID_RETURN_VALUE: _ }
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/errors.js'
				);
				const { destroyer: y } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/destroy.js'
				);
				const g = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/duplex.js'
				);
				const w = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/readable.js'
				);
				const S = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/writable.js'
				);
				const { createDeferredPromise: R } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util.js'
				);
				const A = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/from.js'
				);
				const j = globalThis.Blob || a.Blob;
				const T =
					typeof j !== 'undefined'
						? function isBlob(e) {
								return e instanceof j;
							}
						: function isBlob(e) {
								return false;
							};
				const k =
					globalThis.AbortController ||
					r(
						'../../node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller/browser.js'
					).AbortController;
				const { FunctionPrototypeCall: v } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				);
				class Duplexify extends g {
					constructor(e) {
						super(e);
						if ((e === null || e === undefined ? undefined : e.readable) === false) {
							this._readableState.readable = false;
							this._readableState.ended = true;
							this._readableState.endEmitted = true;
						}
						if ((e === null || e === undefined ? undefined : e.writable) === false) {
							this._writableState.writable = false;
							this._writableState.ending = true;
							this._writableState.ended = true;
							this._writableState.finished = true;
						}
					}
				}
				e.exports = function duplexify(e, t) {
					if (f(e)) {
						return e;
					}
					if (d(e)) {
						return _duplexify({ readable: e });
					}
					if (u(e)) {
						return _duplexify({ writable: e });
					}
					if (l(e)) {
						return _duplexify({ writable: false, readable: false });
					}
					if (c(e)) {
						return _duplexify({ readable: w.fromWeb(e) });
					}
					if (b(e)) {
						return _duplexify({ writable: S.fromWeb(e) });
					}
					if (typeof e === 'function') {
						const { value: r, write: a, final: o, destroy: s } = fromAsyncGen(e);
						if (i(r)) {
							return A(Duplexify, r, { objectMode: true, write: a, final: o, destroy: s });
						}
						const l = r === null || r === undefined ? undefined : r.then;
						if (typeof l === 'function') {
							let e;
							const t = v(
								l,
								r,
								(e) => {
									if (e != null) {
										throw new _('nully', 'body', e);
									}
								},
								(t) => {
									y(e, t);
								}
							);
							return (e = new Duplexify({
								objectMode: true,
								readable: false,
								write: a,
								final(e) {
									o(async () => {
										try {
											await t;
											n.nextTick(e, null);
										} catch (t) {
											n.nextTick(e, t);
										}
									});
								},
								destroy: s
							}));
						}
						throw new _('Iterable, AsyncIterable or AsyncFunction', t, r);
					}
					if (T(e)) {
						return duplexify(e.arrayBuffer());
					}
					if (i(e)) {
						return A(Duplexify, e, { objectMode: true, writable: false });
					}
					if (
						c(e === null || e === undefined ? undefined : e.readable) &&
						b(e === null || e === undefined ? undefined : e.writable)
					) {
						return Duplexify.fromWeb(e);
					}
					if (
						typeof (e === null || e === undefined ? undefined : e.writable) === 'object' ||
						typeof (e === null || e === undefined ? undefined : e.readable) === 'object'
					) {
						const t =
							e !== null && e !== undefined && e.readable
								? d(e === null || e === undefined ? undefined : e.readable)
									? e === null || e === undefined
										? undefined
										: e.readable
									: duplexify(e.readable)
								: undefined;
						const r =
							e !== null && e !== undefined && e.writable
								? u(e === null || e === undefined ? undefined : e.writable)
									? e === null || e === undefined
										? undefined
										: e.writable
									: duplexify(e.writable)
								: undefined;
						return _duplexify({ readable: t, writable: r });
					}
					const r = e === null || e === undefined ? undefined : e.then;
					if (typeof r === 'function') {
						let t;
						v(
							r,
							e,
							(e) => {
								if (e != null) {
									t.push(e);
								}
								t.push(null);
							},
							(e) => {
								y(t, e);
							}
						);
						return (t = new Duplexify({ objectMode: true, writable: false, read() {} }));
					}
					throw new h(
						t,
						[
							'Blob',
							'ReadableStream',
							'WritableStream',
							'Stream',
							'Iterable',
							'AsyncIterable',
							'Function',
							'{ readable, writable } pair',
							'Promise'
						],
						e
					);
				};
				function fromAsyncGen(e) {
					let { promise: t, resolve: r } = R();
					const a = new k();
					const o = a.signal;
					const s = e(
						(async function* () {
							while (true) {
								const e = t;
								t = null;
								const { chunk: a, done: s, cb: i } = await e;
								n.nextTick(i);
								if (s) return;
								if (o.aborted) throw new p(undefined, { cause: o.reason });
								({ promise: t, resolve: r } = R());
								yield a;
							}
						})(),
						{ signal: o }
					);
					return {
						value: s,
						write(e, t, n) {
							const a = r;
							r = null;
							a({ chunk: e, done: false, cb: n });
						},
						final(e) {
							const t = r;
							r = null;
							t({ done: true, cb: e });
						},
						destroy(e, t) {
							a.abort();
							t(e);
						}
					};
				}
				function _duplexify(e) {
					const t =
						e.readable && typeof e.readable.read !== 'function' ? w.wrap(e.readable) : e.readable;
					const r = e.writable;
					let n = !!o(t);
					let a = !!s(r);
					let i;
					let l;
					let d;
					let u;
					let f;
					function onfinished(e) {
						const t = u;
						u = null;
						if (t) {
							t(e);
						} else if (e) {
							f.destroy(e);
						}
					}
					f = new Duplexify({
						readableObjectMode: !!(t !== null && t !== undefined && t.readableObjectMode),
						writableObjectMode: !!(r !== null && r !== undefined && r.writableObjectMode),
						readable: n,
						writable: a
					});
					if (a) {
						m(r, (e) => {
							a = false;
							if (e) {
								y(t, e);
							}
							onfinished(e);
						});
						f._write = function (e, t, n) {
							if (r.write(e, t)) {
								n();
							} else {
								i = n;
							}
						};
						f._final = function (e) {
							r.end();
							l = e;
						};
						r.on('drain', function () {
							if (i) {
								const e = i;
								i = null;
								e();
							}
						});
						r.on('finish', function () {
							if (l) {
								const e = l;
								l = null;
								e();
							}
						});
					}
					if (n) {
						m(t, (e) => {
							n = false;
							if (e) {
								y(t, e);
							}
							onfinished(e);
						});
						t.on('readable', function () {
							if (d) {
								const e = d;
								d = null;
								e();
							}
						});
						t.on('end', function () {
							f.push(null);
						});
						f._read = function () {
							while (true) {
								const e = t.read();
								if (e === null) {
									d = f._read;
									return;
								}
								if (!f.push(e)) {
									return;
								}
							}
						};
					}
					f._destroy = function (e, n) {
						if (!e && u !== null) {
							e = new p();
						}
						d = null;
						i = null;
						l = null;
						if (u === null) {
							n(e);
						} else {
							u = n;
							y(r, e);
							y(t, e);
						}
					};
					return f;
				}
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/end-of-stream.js':
			(e, t, r) => {
				'use strict';
				const n = r('../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js');
				const { AbortError: a, codes: o } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/errors.js'
				);
				const { ERR_INVALID_ARG_TYPE: s, ERR_STREAM_PREMATURE_CLOSE: i } = o;
				const { kEmptyObject: l, once: d } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util.js'
				);
				const {
					validateAbortSignal: u,
					validateFunction: f,
					validateObject: c,
					validateBoolean: b
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/validators.js'
				);
				const {
					Promise: m,
					PromisePrototypeThen: p,
					SymbolDispose: h
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				);
				const {
					isClosed: _,
					isReadable: y,
					isReadableNodeStream: g,
					isReadableStream: w,
					isReadableFinished: S,
					isReadableErrored: R,
					isWritable: A,
					isWritableNodeStream: j,
					isWritableStream: T,
					isWritableFinished: k,
					isWritableErrored: v,
					isNodeStream: D,
					willEmitClose: N,
					kIsClosedPromise: M
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/utils.js'
				);
				let W;
				function isRequest(e) {
					return e.setHeader && typeof e.abort === 'function';
				}
				const nop = () => {};
				function eos(e, t, o) {
					var b, m;
					if (arguments.length === 2) {
						o = t;
						t = l;
					} else if (t == null) {
						t = l;
					} else {
						c(t, 'options');
					}
					f(o, 'callback');
					u(t.signal, 'options.signal');
					o = d(o);
					if (w(e) || T(e)) {
						return eosWeb(e, t, o);
					}
					if (!D(e)) {
						throw new s('stream', ['ReadableStream', 'WritableStream', 'Stream'], e);
					}
					const p = (b = t.readable) !== null && b !== undefined ? b : g(e);
					const M = (m = t.writable) !== null && m !== undefined ? m : j(e);
					const I = e._writableState;
					const x = e._readableState;
					const onlegacyfinish = () => {
						if (!e.writable) {
							onfinish();
						}
					};
					let P = N(e) && g(e) === p && j(e) === M;
					let O = k(e, false);
					const onfinish = () => {
						O = true;
						if (e.destroyed) {
							P = false;
						}
						if (P && (!e.readable || p)) {
							return;
						}
						if (!p || L) {
							o.call(e);
						}
					};
					let L = S(e, false);
					const onend = () => {
						L = true;
						if (e.destroyed) {
							P = false;
						}
						if (P && (!e.writable || M)) {
							return;
						}
						if (!M || O) {
							o.call(e);
						}
					};
					const onerror = (t) => {
						o.call(e, t);
					};
					let C = _(e);
					const onclose = () => {
						C = true;
						const t = v(e) || R(e);
						if (t && typeof t !== 'boolean') {
							return o.call(e, t);
						}
						if (p && !L && g(e, true)) {
							if (!S(e, false)) return o.call(e, new i());
						}
						if (M && !O) {
							if (!k(e, false)) return o.call(e, new i());
						}
						o.call(e);
					};
					const onclosed = () => {
						C = true;
						const t = v(e) || R(e);
						if (t && typeof t !== 'boolean') {
							return o.call(e, t);
						}
						o.call(e);
					};
					const onrequest = () => {
						e.req.on('finish', onfinish);
					};
					if (isRequest(e)) {
						e.on('complete', onfinish);
						if (!P) {
							e.on('abort', onclose);
						}
						if (e.req) {
							onrequest();
						} else {
							e.on('request', onrequest);
						}
					} else if (M && !I) {
						e.on('end', onlegacyfinish);
						e.on('close', onlegacyfinish);
					}
					if (!P && typeof e.aborted === 'boolean') {
						e.on('aborted', onclose);
					}
					e.on('end', onend);
					e.on('finish', onfinish);
					if (t.error !== false) {
						e.on('error', onerror);
					}
					e.on('close', onclose);
					if (C) {
						n.nextTick(onclose);
					} else if (
						(I !== null && I !== undefined && I.errorEmitted) ||
						(x !== null && x !== undefined && x.errorEmitted)
					) {
						if (!P) {
							n.nextTick(onclosed);
						}
					} else if (!p && (!P || y(e)) && (O || A(e) === false)) {
						n.nextTick(onclosed);
					} else if (!M && (!P || A(e)) && (L || y(e) === false)) {
						n.nextTick(onclosed);
					} else if (x && e.req && e.aborted) {
						n.nextTick(onclosed);
					}
					const cleanup = () => {
						o = nop;
						e.removeListener('aborted', onclose);
						e.removeListener('complete', onfinish);
						e.removeListener('abort', onclose);
						e.removeListener('request', onrequest);
						if (e.req) e.req.removeListener('finish', onfinish);
						e.removeListener('end', onlegacyfinish);
						e.removeListener('close', onlegacyfinish);
						e.removeListener('finish', onfinish);
						e.removeListener('end', onend);
						e.removeListener('error', onerror);
						e.removeListener('close', onclose);
					};
					if (t.signal && !C) {
						const abort = () => {
							const r = o;
							cleanup();
							r.call(e, new a(undefined, { cause: t.signal.reason }));
						};
						if (t.signal.aborted) {
							n.nextTick(abort);
						} else {
							W =
								W ||
								r(
									'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util.js'
								).addAbortListener;
							const n = W(t.signal, abort);
							const a = o;
							o = d((...t) => {
								n[h]();
								a.apply(e, t);
							});
						}
					}
					return cleanup;
				}
				function eosWeb(e, t, o) {
					let s = false;
					let i = nop;
					if (t.signal) {
						i = () => {
							s = true;
							o.call(e, new a(undefined, { cause: t.signal.reason }));
						};
						if (t.signal.aborted) {
							n.nextTick(i);
						} else {
							W =
								W ||
								r(
									'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util.js'
								).addAbortListener;
							const n = W(t.signal, i);
							const a = o;
							o = d((...t) => {
								n[h]();
								a.apply(e, t);
							});
						}
					}
					const resolverFn = (...t) => {
						if (!s) {
							n.nextTick(() => o.apply(e, t));
						}
					};
					p(e[M].promise, resolverFn, resolverFn);
					return nop;
				}
				function finished(e, t) {
					var r;
					let n = false;
					if (t === null) {
						t = l;
					}
					if ((r = t) !== null && r !== undefined && r.cleanup) {
						b(t.cleanup, 'cleanup');
						n = t.cleanup;
					}
					return new m((r, a) => {
						const o = eos(e, t, (e) => {
							if (n) {
								o();
							}
							if (e) {
								a(e);
							} else {
								r();
							}
						});
					});
				}
				e.exports = eos;
				e.exports.finished = finished;
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/from.js':
			(e, t, r) => {
				'use strict';
				const n = r('../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js');
				const {
					PromisePrototypeThen: a,
					SymbolAsyncIterator: o,
					SymbolIterator: s
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				);
				const { Buffer: i } = r(
					'../../node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js'
				);
				const { ERR_INVALID_ARG_TYPE: l, ERR_STREAM_NULL_VALUES: d } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/errors.js'
				).codes;
				function from(e, t, r) {
					let u;
					if (typeof t === 'string' || t instanceof i) {
						return new e({
							objectMode: true,
							...r,
							read() {
								this.push(t);
								this.push(null);
							}
						});
					}
					let f;
					if (t && t[o]) {
						f = true;
						u = t[o]();
					} else if (t && t[s]) {
						f = false;
						u = t[s]();
					} else {
						throw new l('iterable', ['Iterable'], t);
					}
					const c = new e({ objectMode: true, highWaterMark: 1, ...r });
					let b = false;
					c._read = function () {
						if (!b) {
							b = true;
							next();
						}
					};
					c._destroy = function (e, t) {
						a(
							close(e),
							() => n.nextTick(t, e),
							(r) => n.nextTick(t, r || e)
						);
					};
					async function close(e) {
						const t = e !== undefined && e !== null;
						const r = typeof u.throw === 'function';
						if (t && r) {
							const { value: t, done: r } = await u.throw(e);
							await t;
							if (r) {
								return;
							}
						}
						if (typeof u.return === 'function') {
							const { value: e } = await u.return();
							await e;
						}
					}
					async function next() {
						for (;;) {
							try {
								const { value: e, done: t } = f ? await u.next() : u.next();
								if (t) {
									c.push(null);
								} else {
									const t = e && typeof e.then === 'function' ? await e : e;
									if (t === null) {
										b = false;
										throw new d();
									} else if (c.push(t)) {
										continue;
									} else {
										b = false;
									}
								}
							} catch (e) {
								c.destroy(e);
							}
							break;
						}
					}
					return c;
				}
				e.exports = from;
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/legacy.js':
			(e, t, r) => {
				'use strict';
				const { ArrayIsArray: n, ObjectSetPrototypeOf: a } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				);
				const { EventEmitter: o } = r(
					'../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js'
				);
				function Stream(e) {
					o.call(this, e);
				}
				a(Stream.prototype, o.prototype);
				a(Stream, o);
				Stream.prototype.pipe = function (e, t) {
					const r = this;
					function ondata(t) {
						if (e.writable && e.write(t) === false && r.pause) {
							r.pause();
						}
					}
					r.on('data', ondata);
					function ondrain() {
						if (r.readable && r.resume) {
							r.resume();
						}
					}
					e.on('drain', ondrain);
					if (!e._isStdio && (!t || t.end !== false)) {
						r.on('end', onend);
						r.on('close', onclose);
					}
					let n = false;
					function onend() {
						if (n) return;
						n = true;
						e.end();
					}
					function onclose() {
						if (n) return;
						n = true;
						if (typeof e.destroy === 'function') e.destroy();
					}
					function onerror(e) {
						cleanup();
						if (o.listenerCount(this, 'error') === 0) {
							this.emit('error', e);
						}
					}
					prependListener(r, 'error', onerror);
					prependListener(e, 'error', onerror);
					function cleanup() {
						r.removeListener('data', ondata);
						e.removeListener('drain', ondrain);
						r.removeListener('end', onend);
						r.removeListener('close', onclose);
						r.removeListener('error', onerror);
						e.removeListener('error', onerror);
						r.removeListener('end', cleanup);
						r.removeListener('close', cleanup);
						e.removeListener('close', cleanup);
					}
					r.on('end', cleanup);
					r.on('close', cleanup);
					e.on('close', cleanup);
					e.emit('pipe', r);
					return e;
				};
				function prependListener(e, t, r) {
					if (typeof e.prependListener === 'function') return e.prependListener(t, r);
					if (!e._events || !e._events[t]) e.on(t, r);
					else if (n(e._events[t])) e._events[t].unshift(r);
					else e._events[t] = [r, e._events[t]];
				}
				e.exports = { Stream, prependListener };
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/operators.js':
			(e, t, r) => {
				'use strict';
				const n =
					globalThis.AbortController ||
					r(
						'../../node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller/browser.js'
					).AbortController;
				const {
					codes: {
						ERR_INVALID_ARG_VALUE: a,
						ERR_INVALID_ARG_TYPE: o,
						ERR_MISSING_ARGS: s,
						ERR_OUT_OF_RANGE: i
					},
					AbortError: l
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/errors.js'
				);
				const {
					validateAbortSignal: d,
					validateInteger: u,
					validateObject: f
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/validators.js'
				);
				const c = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				).Symbol('kWeak');
				const b = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				).Symbol('kResistStopPropagation');
				const { finished: m } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/end-of-stream.js'
				);
				const p = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/compose.js'
				);
				const { addAbortSignalNoValidate: h } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js'
				);
				const { isWritable: _, isNodeStream: y } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/utils.js'
				);
				const { deprecate: g } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util.js'
				);
				const {
					ArrayPrototypePush: w,
					Boolean: S,
					MathFloor: R,
					Number: A,
					NumberIsNaN: j,
					Promise: T,
					PromiseReject: k,
					PromiseResolve: v,
					PromisePrototypeThen: D,
					Symbol: N
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				);
				const M = N('kEmpty');
				const W = N('kEof');
				function compose(e, t) {
					if (t != null) {
						f(t, 'options');
					}
					if ((t === null || t === undefined ? undefined : t.signal) != null) {
						d(t.signal, 'options.signal');
					}
					if (y(e) && !_(e)) {
						throw new a('stream', e, 'must be writable');
					}
					const r = p(this, e);
					if (t !== null && t !== undefined && t.signal) {
						h(t.signal, r);
					}
					return r;
				}
				function map(e, t) {
					if (typeof e !== 'function') {
						throw new o('fn', ['Function', 'AsyncFunction'], e);
					}
					if (t != null) {
						f(t, 'options');
					}
					if ((t === null || t === undefined ? undefined : t.signal) != null) {
						d(t.signal, 'options.signal');
					}
					let n = 1;
					if ((t === null || t === undefined ? undefined : t.concurrency) != null) {
						n = R(t.concurrency);
					}
					let a = n - 1;
					if ((t === null || t === undefined ? undefined : t.highWaterMark) != null) {
						a = R(t.highWaterMark);
					}
					u(n, 'options.concurrency', 1);
					u(a, 'options.highWaterMark', 0);
					a += n;
					return async function* map() {
						const o = r(
							'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util.js'
						).AbortSignalAny([t === null || t === undefined ? undefined : t.signal].filter(S));
						const s = this;
						const i = [];
						const d = { signal: o };
						let u;
						let f;
						let c = false;
						let b = 0;
						function onCatch() {
							c = true;
							afterItemProcessed();
						}
						function afterItemProcessed() {
							b -= 1;
							maybeResume();
						}
						function maybeResume() {
							if (f && !c && b < n && i.length < a) {
								f();
								f = null;
							}
						}
						async function pump() {
							try {
								for await (let t of s) {
									if (c) {
										return;
									}
									if (o.aborted) {
										throw new l();
									}
									try {
										t = e(t, d);
										if (t === M) {
											continue;
										}
										t = v(t);
									} catch (e) {
										t = k(e);
									}
									b += 1;
									D(t, afterItemProcessed, onCatch);
									i.push(t);
									if (u) {
										u();
										u = null;
									}
									if (!c && (i.length >= a || b >= n)) {
										await new T((e) => {
											f = e;
										});
									}
								}
								i.push(W);
							} catch (e) {
								const t = k(e);
								D(t, afterItemProcessed, onCatch);
								i.push(t);
							} finally {
								c = true;
								if (u) {
									u();
									u = null;
								}
							}
						}
						pump();
						try {
							while (true) {
								while (i.length > 0) {
									const e = await i[0];
									if (e === W) {
										return;
									}
									if (o.aborted) {
										throw new l();
									}
									if (e !== M) {
										yield e;
									}
									i.shift();
									maybeResume();
								}
								await new T((e) => {
									u = e;
								});
							}
						} finally {
							c = true;
							if (f) {
								f();
								f = null;
							}
						}
					}.call(this);
				}
				function asIndexedPairs(e = undefined) {
					if (e != null) {
						f(e, 'options');
					}
					if ((e === null || e === undefined ? undefined : e.signal) != null) {
						d(e.signal, 'options.signal');
					}
					return async function* asIndexedPairs() {
						let t = 0;
						for await (const n of this) {
							var r;
							if (
								e !== null &&
								e !== undefined &&
								(r = e.signal) !== null &&
								r !== undefined &&
								r.aborted
							) {
								throw new l({ cause: e.signal.reason });
							}
							yield [t++, n];
						}
					}.call(this);
				}
				async function some(e, t = undefined) {
					for await (const r of filter.call(this, e, t)) {
						return true;
					}
					return false;
				}
				async function every(e, t = undefined) {
					if (typeof e !== 'function') {
						throw new o('fn', ['Function', 'AsyncFunction'], e);
					}
					return !(await some.call(this, async (...t) => !(await e(...t)), t));
				}
				async function find(e, t) {
					for await (const r of filter.call(this, e, t)) {
						return r;
					}
					return undefined;
				}
				async function forEach(e, t) {
					if (typeof e !== 'function') {
						throw new o('fn', ['Function', 'AsyncFunction'], e);
					}
					async function forEachFn(t, r) {
						await e(t, r);
						return M;
					}
					for await (const e of map.call(this, forEachFn, t));
				}
				function filter(e, t) {
					if (typeof e !== 'function') {
						throw new o('fn', ['Function', 'AsyncFunction'], e);
					}
					async function filterFn(t, r) {
						if (await e(t, r)) {
							return t;
						}
						return M;
					}
					return map.call(this, filterFn, t);
				}
				class ReduceAwareErrMissingArgs extends s {
					constructor() {
						super('reduce');
						this.message = 'Reduce of an empty stream requires an initial value';
					}
				}
				async function reduce(e, t, r) {
					var a;
					if (typeof e !== 'function') {
						throw new o('reducer', ['Function', 'AsyncFunction'], e);
					}
					if (r != null) {
						f(r, 'options');
					}
					if ((r === null || r === undefined ? undefined : r.signal) != null) {
						d(r.signal, 'options.signal');
					}
					let s = arguments.length > 1;
					if (
						r !== null &&
						r !== undefined &&
						(a = r.signal) !== null &&
						a !== undefined &&
						a.aborted
					) {
						const e = new l(undefined, { cause: r.signal.reason });
						this.once('error', () => {});
						await m(this.destroy(e));
						throw e;
					}
					const i = new n();
					const u = i.signal;
					if (r !== null && r !== undefined && r.signal) {
						const e = { once: true, [c]: this, [b]: true };
						r.signal.addEventListener('abort', () => i.abort(), e);
					}
					let p = false;
					try {
						for await (const n of this) {
							var h;
							p = true;
							if (
								r !== null &&
								r !== undefined &&
								(h = r.signal) !== null &&
								h !== undefined &&
								h.aborted
							) {
								throw new l();
							}
							if (!s) {
								t = n;
								s = true;
							} else {
								t = await e(t, n, { signal: u });
							}
						}
						if (!p && !s) {
							throw new ReduceAwareErrMissingArgs();
						}
					} finally {
						i.abort();
					}
					return t;
				}
				async function toArray(e) {
					if (e != null) {
						f(e, 'options');
					}
					if ((e === null || e === undefined ? undefined : e.signal) != null) {
						d(e.signal, 'options.signal');
					}
					const t = [];
					for await (const n of this) {
						var r;
						if (
							e !== null &&
							e !== undefined &&
							(r = e.signal) !== null &&
							r !== undefined &&
							r.aborted
						) {
							throw new l(undefined, { cause: e.signal.reason });
						}
						w(t, n);
					}
					return t;
				}
				function flatMap(e, t) {
					const r = map.call(this, e, t);
					return async function* flatMap() {
						for await (const e of r) {
							yield* e;
						}
					}.call(this);
				}
				function toIntegerOrInfinity(e) {
					e = A(e);
					if (j(e)) {
						return 0;
					}
					if (e < 0) {
						throw new i('number', '>= 0', e);
					}
					return e;
				}
				function drop(e, t = undefined) {
					if (t != null) {
						f(t, 'options');
					}
					if ((t === null || t === undefined ? undefined : t.signal) != null) {
						d(t.signal, 'options.signal');
					}
					e = toIntegerOrInfinity(e);
					return async function* drop() {
						var r;
						if (
							t !== null &&
							t !== undefined &&
							(r = t.signal) !== null &&
							r !== undefined &&
							r.aborted
						) {
							throw new l();
						}
						for await (const r of this) {
							var n;
							if (
								t !== null &&
								t !== undefined &&
								(n = t.signal) !== null &&
								n !== undefined &&
								n.aborted
							) {
								throw new l();
							}
							if (e-- <= 0) {
								yield r;
							}
						}
					}.call(this);
				}
				function take(e, t = undefined) {
					if (t != null) {
						f(t, 'options');
					}
					if ((t === null || t === undefined ? undefined : t.signal) != null) {
						d(t.signal, 'options.signal');
					}
					e = toIntegerOrInfinity(e);
					return async function* take() {
						var r;
						if (
							t !== null &&
							t !== undefined &&
							(r = t.signal) !== null &&
							r !== undefined &&
							r.aborted
						) {
							throw new l();
						}
						for await (const r of this) {
							var n;
							if (
								t !== null &&
								t !== undefined &&
								(n = t.signal) !== null &&
								n !== undefined &&
								n.aborted
							) {
								throw new l();
							}
							if (e-- > 0) {
								yield r;
							}
							if (e <= 0) {
								return;
							}
						}
					}.call(this);
				}
				e.exports.streamReturningOperators = {
					asIndexedPairs: g(
						asIndexedPairs,
						'readable.asIndexedPairs will be removed in a future version.'
					),
					drop,
					filter,
					flatMap,
					map,
					take,
					compose
				};
				e.exports.promiseReturningOperators = { every, forEach, reduce, toArray, some, find };
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/passthrough.js':
			(e, t, r) => {
				'use strict';
				const { ObjectSetPrototypeOf: n } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				);
				e.exports = PassThrough;
				const a = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/transform.js'
				);
				n(PassThrough.prototype, a.prototype);
				n(PassThrough, a);
				function PassThrough(e) {
					if (!(this instanceof PassThrough)) return new PassThrough(e);
					a.call(this, e);
				}
				PassThrough.prototype._transform = function (e, t, r) {
					r(null, e);
				};
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/pipeline.js':
			(e, t, r) => {
				const n = r('../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js');
				('use strict');
				const {
					ArrayIsArray: a,
					Promise: o,
					SymbolAsyncIterator: s,
					SymbolDispose: i
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				);
				const l = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/end-of-stream.js'
				);
				const { once: d } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util.js'
				);
				const u = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/destroy.js'
				);
				const f = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/duplex.js'
				);
				const {
					aggregateTwoErrors: c,
					codes: {
						ERR_INVALID_ARG_TYPE: b,
						ERR_INVALID_RETURN_VALUE: m,
						ERR_MISSING_ARGS: p,
						ERR_STREAM_DESTROYED: h,
						ERR_STREAM_PREMATURE_CLOSE: _
					},
					AbortError: y
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/errors.js'
				);
				const { validateFunction: g, validateAbortSignal: w } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/validators.js'
				);
				const {
					isIterable: S,
					isReadable: R,
					isReadableNodeStream: A,
					isNodeStream: j,
					isTransformStream: T,
					isWebStream: k,
					isReadableStream: v,
					isReadableFinished: D
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/utils.js'
				);
				const N =
					globalThis.AbortController ||
					r(
						'../../node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller/browser.js'
					).AbortController;
				let M;
				let W;
				let I;
				function destroyer(e, t, r) {
					let n = false;
					e.on('close', () => {
						n = true;
					});
					const a = l(e, { readable: t, writable: r }, (e) => {
						n = !e;
					});
					return {
						destroy: (t) => {
							if (n) return;
							n = true;
							u.destroyer(e, t || new h('pipe'));
						},
						cleanup: a
					};
				}
				function popCallback(e) {
					g(e[e.length - 1], 'streams[stream.length - 1]');
					return e.pop();
				}
				function makeAsyncIterable(e) {
					if (S(e)) {
						return e;
					} else if (A(e)) {
						return fromReadable(e);
					}
					throw new b('val', ['Readable', 'Iterable', 'AsyncIterable'], e);
				}
				async function* fromReadable(e) {
					if (!W) {
						W = r(
							'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/readable.js'
						);
					}
					yield* W.prototype[s].call(e);
				}
				async function pumpToNode(e, t, r, { end: n }) {
					let a;
					let s = null;
					const resume = (e) => {
						if (e) {
							a = e;
						}
						if (s) {
							const e = s;
							s = null;
							e();
						}
					};
					const wait = () =>
						new o((e, t) => {
							if (a) {
								t(a);
							} else {
								s = () => {
									if (a) {
										t(a);
									} else {
										e();
									}
								};
							}
						});
					t.on('drain', resume);
					const i = l(t, { readable: false }, resume);
					try {
						if (t.writableNeedDrain) {
							await wait();
						}
						for await (const r of e) {
							if (!t.write(r)) {
								await wait();
							}
						}
						if (n) {
							t.end();
							await wait();
						}
						r();
					} catch (e) {
						r(a !== e ? c(a, e) : e);
					} finally {
						i();
						t.off('drain', resume);
					}
				}
				async function pumpToWeb(e, t, r, { end: n }) {
					if (T(t)) {
						t = t.writable;
					}
					const a = t.getWriter();
					try {
						for await (const t of e) {
							await a.ready;
							a.write(t).catch(() => {});
						}
						await a.ready;
						if (n) {
							await a.close();
						}
						r();
					} catch (e) {
						try {
							await a.abort(e);
							r(e);
						} catch (e) {
							r(e);
						}
					}
				}
				function pipeline(...e) {
					return pipelineImpl(e, d(popCallback(e)));
				}
				function pipelineImpl(e, t, o) {
					if (e.length === 1 && a(e[0])) {
						e = e[0];
					}
					if (e.length < 2) {
						throw new p('streams');
					}
					const s = new N();
					const l = s.signal;
					const d = o === null || o === undefined ? undefined : o.signal;
					const u = [];
					w(d, 'options.signal');
					function abort() {
						finishImpl(new y());
					}
					I =
						I ||
						r(
							'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util.js'
						).addAbortListener;
					let c;
					if (d) {
						c = I(d, abort);
					}
					let h;
					let _;
					const g = [];
					let D = 0;
					function finish(e) {
						finishImpl(e, --D === 0);
					}
					function finishImpl(e, r) {
						var a;
						if (e && (!h || h.code === 'ERR_STREAM_PREMATURE_CLOSE')) {
							h = e;
						}
						if (!h && !r) {
							return;
						}
						while (g.length) {
							g.shift()(h);
						}
						(a = c) === null || a === undefined ? undefined : a[i]();
						s.abort();
						if (r) {
							if (!h) {
								u.forEach((e) => e());
							}
							n.nextTick(t, h, _);
						}
					}
					let W;
					for (let O = 0; O < e.length; O++) {
						const L = e[O];
						const C = O < e.length - 1;
						const F = O > 0;
						const B = C || (o === null || o === undefined ? undefined : o.end) !== false;
						const $ = O === e.length - 1;
						if (j(L)) {
							if (B) {
								const { destroy: U, cleanup: H } = destroyer(L, C, F);
								g.push(U);
								if (R(L) && $) {
									u.push(H);
								}
							}
							function onError(e) {
								if (e && e.name !== 'AbortError' && e.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
									finish(e);
								}
							}
							L.on('error', onError);
							if (R(L) && $) {
								u.push(() => {
									L.removeListener('error', onError);
								});
							}
						}
						if (O === 0) {
							if (typeof L === 'function') {
								W = L({ signal: l });
								if (!S(W)) {
									throw new m('Iterable, AsyncIterable or Stream', 'source', W);
								}
							} else if (S(L) || A(L) || T(L)) {
								W = L;
							} else {
								W = f.from(L);
							}
						} else if (typeof L === 'function') {
							if (T(W)) {
								var x;
								W = makeAsyncIterable((x = W) === null || x === undefined ? undefined : x.readable);
							} else {
								W = makeAsyncIterable(W);
							}
							W = L(W, { signal: l });
							if (C) {
								if (!S(W, true)) {
									throw new m('AsyncIterable', `transform[${O - 1}]`, W);
								}
							} else {
								var P;
								if (!M) {
									M = r(
										'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/passthrough.js'
									);
								}
								const V = new M({ objectMode: true });
								const G = (P = W) === null || P === undefined ? undefined : P.then;
								if (typeof G === 'function') {
									D++;
									G.call(
										W,
										(e) => {
											_ = e;
											if (e != null) {
												V.write(e);
											}
											if (B) {
												V.end();
											}
											n.nextTick(finish);
										},
										(e) => {
											V.destroy(e);
											n.nextTick(finish, e);
										}
									);
								} else if (S(W, true)) {
									D++;
									pumpToNode(W, V, finish, { end: B });
								} else if (v(W) || T(W)) {
									const z = W.readable || W;
									D++;
									pumpToNode(z, V, finish, { end: B });
								} else {
									throw new m('AsyncIterable or Promise', 'destination', W);
								}
								W = V;
								const { destroy: q, cleanup: Y } = destroyer(W, false, true);
								g.push(q);
								if ($) {
									u.push(Y);
								}
							}
						} else if (j(L)) {
							if (A(W)) {
								D += 2;
								const K = pipe(W, L, finish, { end: B });
								if (R(L) && $) {
									u.push(K);
								}
							} else if (T(W) || v(W)) {
								const J = W.readable || W;
								D++;
								pumpToNode(J, L, finish, { end: B });
							} else if (S(W)) {
								D++;
								pumpToNode(W, L, finish, { end: B });
							} else {
								throw new b(
									'val',
									['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],
									W
								);
							}
							W = L;
						} else if (k(L)) {
							if (A(W)) {
								D++;
								pumpToWeb(makeAsyncIterable(W), L, finish, { end: B });
							} else if (v(W) || S(W)) {
								D++;
								pumpToWeb(W, L, finish, { end: B });
							} else if (T(W)) {
								D++;
								pumpToWeb(W.readable, L, finish, { end: B });
							} else {
								throw new b(
									'val',
									['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],
									W
								);
							}
							W = L;
						} else {
							W = f.from(L);
						}
					}
					if (
						(l !== null && l !== undefined && l.aborted) ||
						(d !== null && d !== undefined && d.aborted)
					) {
						n.nextTick(abort);
					}
					return W;
				}
				function pipe(e, t, r, { end: a }) {
					let o = false;
					t.on('close', () => {
						if (!o) {
							r(new _());
						}
					});
					e.pipe(t, { end: false });
					if (a) {
						function endFn() {
							o = true;
							t.end();
						}
						if (D(e)) {
							n.nextTick(endFn);
						} else {
							e.once('end', endFn);
						}
					} else {
						r();
					}
					l(e, { readable: true, writable: false }, (t) => {
						const n = e._readableState;
						if (
							t &&
							t.code === 'ERR_STREAM_PREMATURE_CLOSE' &&
							n &&
							n.ended &&
							!n.errored &&
							!n.errorEmitted
						) {
							e.once('end', r).once('error', r);
						} else {
							r(t);
						}
					});
					return l(t, { readable: false, writable: true }, r);
				}
				e.exports = { pipelineImpl, pipeline };
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/readable.js':
			(e, t, r) => {
				'use strict';
				const n = r('../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js');
				const {
					ArrayPrototypeIndexOf: a,
					NumberIsInteger: o,
					NumberIsNaN: s,
					NumberParseInt: i,
					ObjectDefineProperties: l,
					ObjectKeys: d,
					ObjectSetPrototypeOf: u,
					Promise: f,
					SafeSet: c,
					SymbolAsyncDispose: b,
					SymbolAsyncIterator: m,
					Symbol: p
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				);
				e.exports = Readable;
				Readable.ReadableState = ReadableState;
				const { EventEmitter: h } = r(
					'../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js'
				);
				const { Stream: _, prependListener: y } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/legacy.js'
				);
				const { Buffer: g } = r(
					'../../node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js'
				);
				const { addAbortSignal: w } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js'
				);
				const S = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/end-of-stream.js'
				);
				let R = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util.js'
				).debuglog('stream', (e) => {
					R = e;
				});
				const A = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/buffer_list.js'
				);
				const j = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/destroy.js'
				);
				const { getHighWaterMark: T, getDefaultHighWaterMark: k } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/state.js'
				);
				const {
					aggregateTwoErrors: v,
					codes: {
						ERR_INVALID_ARG_TYPE: D,
						ERR_METHOD_NOT_IMPLEMENTED: N,
						ERR_OUT_OF_RANGE: M,
						ERR_STREAM_PUSH_AFTER_EOF: W,
						ERR_STREAM_UNSHIFT_AFTER_END_EVENT: I
					},
					AbortError: x
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/errors.js'
				);
				const { validateObject: P } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/validators.js'
				);
				const O = p('kPaused');
				const { StringDecoder: L } = r(
					'../../node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js'
				);
				const C = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/from.js'
				);
				u(Readable.prototype, _.prototype);
				u(Readable, _);
				const nop = () => {};
				const { errorOrDestroy: F } = j;
				const B = 1 << 0;
				const $ = 1 << 1;
				const U = 1 << 2;
				const H = 1 << 3;
				const V = 1 << 4;
				const G = 1 << 5;
				const q = 1 << 6;
				const Y = 1 << 7;
				const z = 1 << 8;
				const K = 1 << 9;
				const J = 1 << 10;
				const X = 1 << 11;
				const Z = 1 << 12;
				const Q = 1 << 13;
				const ee = 1 << 14;
				const te = 1 << 15;
				const re = 1 << 16;
				const ne = 1 << 17;
				const ae = 1 << 18;
				function makeBitMapDescriptor(e) {
					return {
						enumerable: false,
						get() {
							return (this.state & e) !== 0;
						},
						set(t) {
							if (t) this.state |= e;
							else this.state &= ~e;
						}
					};
				}
				l(ReadableState.prototype, {
					objectMode: makeBitMapDescriptor(B),
					ended: makeBitMapDescriptor($),
					endEmitted: makeBitMapDescriptor(U),
					reading: makeBitMapDescriptor(H),
					constructed: makeBitMapDescriptor(V),
					sync: makeBitMapDescriptor(G),
					needReadable: makeBitMapDescriptor(q),
					emittedReadable: makeBitMapDescriptor(Y),
					readableListening: makeBitMapDescriptor(z),
					resumeScheduled: makeBitMapDescriptor(K),
					errorEmitted: makeBitMapDescriptor(J),
					emitClose: makeBitMapDescriptor(X),
					autoDestroy: makeBitMapDescriptor(Z),
					destroyed: makeBitMapDescriptor(Q),
					closed: makeBitMapDescriptor(ee),
					closeEmitted: makeBitMapDescriptor(te),
					multiAwaitDrain: makeBitMapDescriptor(re),
					readingMore: makeBitMapDescriptor(ne),
					dataEmitted: makeBitMapDescriptor(ae)
				});
				function ReadableState(e, t, n) {
					if (typeof n !== 'boolean')
						n =
							t instanceof
							r(
								'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/duplex.js'
							);
					this.state = X | Z | V | G;
					if (e && e.objectMode) this.state |= B;
					if (n && e && e.readableObjectMode) this.state |= B;
					this.highWaterMark = e ? T(this, e, 'readableHighWaterMark', n) : k(false);
					this.buffer = new A();
					this.length = 0;
					this.pipes = [];
					this.flowing = null;
					this[O] = null;
					if (e && e.emitClose === false) this.state &= ~X;
					if (e && e.autoDestroy === false) this.state &= ~Z;
					this.errored = null;
					this.defaultEncoding = (e && e.defaultEncoding) || 'utf8';
					this.awaitDrainWriters = null;
					this.decoder = null;
					this.encoding = null;
					if (e && e.encoding) {
						this.decoder = new L(e.encoding);
						this.encoding = e.encoding;
					}
				}
				function Readable(e) {
					if (!(this instanceof Readable)) return new Readable(e);
					const t =
						this instanceof
						r(
							'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/duplex.js'
						);
					this._readableState = new ReadableState(e, this, t);
					if (e) {
						if (typeof e.read === 'function') this._read = e.read;
						if (typeof e.destroy === 'function') this._destroy = e.destroy;
						if (typeof e.construct === 'function') this._construct = e.construct;
						if (e.signal && !t) w(e.signal, this);
					}
					_.call(this, e);
					j.construct(this, () => {
						if (this._readableState.needReadable) {
							maybeReadMore(this, this._readableState);
						}
					});
				}
				Readable.prototype.destroy = j.destroy;
				Readable.prototype._undestroy = j.undestroy;
				Readable.prototype._destroy = function (e, t) {
					t(e);
				};
				Readable.prototype[h.captureRejectionSymbol] = function (e) {
					this.destroy(e);
				};
				Readable.prototype[b] = function () {
					let e;
					if (!this.destroyed) {
						e = this.readableEnded ? null : new x();
						this.destroy(e);
					}
					return new f((t, r) => S(this, (n) => (n && n !== e ? r(n) : t(null))));
				};
				Readable.prototype.push = function (e, t) {
					return readableAddChunk(this, e, t, false);
				};
				Readable.prototype.unshift = function (e, t) {
					return readableAddChunk(this, e, t, true);
				};
				function readableAddChunk(e, t, r, n) {
					R('readableAddChunk', t);
					const a = e._readableState;
					let o;
					if ((a.state & B) === 0) {
						if (typeof t === 'string') {
							r = r || a.defaultEncoding;
							if (a.encoding !== r) {
								if (n && a.encoding) {
									t = g.from(t, r).toString(a.encoding);
								} else {
									t = g.from(t, r);
									r = '';
								}
							}
						} else if (t instanceof g) {
							r = '';
						} else if (_._isUint8Array(t)) {
							t = _._uint8ArrayToBuffer(t);
							r = '';
						} else if (t != null) {
							o = new D('chunk', ['string', 'Buffer', 'Uint8Array'], t);
						}
					}
					if (o) {
						F(e, o);
					} else if (t === null) {
						a.state &= ~H;
						onEofChunk(e, a);
					} else if ((a.state & B) !== 0 || (t && t.length > 0)) {
						if (n) {
							if ((a.state & U) !== 0) F(e, new I());
							else if (a.destroyed || a.errored) return false;
							else addChunk(e, a, t, true);
						} else if (a.ended) {
							F(e, new W());
						} else if (a.destroyed || a.errored) {
							return false;
						} else {
							a.state &= ~H;
							if (a.decoder && !r) {
								t = a.decoder.write(t);
								if (a.objectMode || t.length !== 0) addChunk(e, a, t, false);
								else maybeReadMore(e, a);
							} else {
								addChunk(e, a, t, false);
							}
						}
					} else if (!n) {
						a.state &= ~H;
						maybeReadMore(e, a);
					}
					return !a.ended && (a.length < a.highWaterMark || a.length === 0);
				}
				function addChunk(e, t, r, n) {
					if (t.flowing && t.length === 0 && !t.sync && e.listenerCount('data') > 0) {
						if ((t.state & re) !== 0) {
							t.awaitDrainWriters.clear();
						} else {
							t.awaitDrainWriters = null;
						}
						t.dataEmitted = true;
						e.emit('data', r);
					} else {
						t.length += t.objectMode ? 1 : r.length;
						if (n) t.buffer.unshift(r);
						else t.buffer.push(r);
						if ((t.state & q) !== 0) emitReadable(e);
					}
					maybeReadMore(e, t);
				}
				Readable.prototype.isPaused = function () {
					const e = this._readableState;
					return e[O] === true || e.flowing === false;
				};
				Readable.prototype.setEncoding = function (e) {
					const t = new L(e);
					this._readableState.decoder = t;
					this._readableState.encoding = this._readableState.decoder.encoding;
					const r = this._readableState.buffer;
					let n = '';
					for (const e of r) {
						n += t.write(e);
					}
					r.clear();
					if (n !== '') r.push(n);
					this._readableState.length = n.length;
					return this;
				};
				const oe = 1073741824;
				function computeNewHighWaterMark(e) {
					if (e > oe) {
						throw new M('size', '<= 1GiB', e);
					} else {
						e--;
						e |= e >>> 1;
						e |= e >>> 2;
						e |= e >>> 4;
						e |= e >>> 8;
						e |= e >>> 16;
						e++;
					}
					return e;
				}
				function howMuchToRead(e, t) {
					if (e <= 0 || (t.length === 0 && t.ended)) return 0;
					if ((t.state & B) !== 0) return 1;
					if (s(e)) {
						if (t.flowing && t.length) return t.buffer.first().length;
						return t.length;
					}
					if (e <= t.length) return e;
					return t.ended ? t.length : 0;
				}
				Readable.prototype.read = function (e) {
					R('read', e);
					if (e === undefined) {
						e = NaN;
					} else if (!o(e)) {
						e = i(e, 10);
					}
					const t = this._readableState;
					const r = e;
					if (e > t.highWaterMark) t.highWaterMark = computeNewHighWaterMark(e);
					if (e !== 0) t.state &= ~Y;
					if (
						e === 0 &&
						t.needReadable &&
						((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended)
					) {
						R('read: emitReadable', t.length, t.ended);
						if (t.length === 0 && t.ended) endReadable(this);
						else emitReadable(this);
						return null;
					}
					e = howMuchToRead(e, t);
					if (e === 0 && t.ended) {
						if (t.length === 0) endReadable(this);
						return null;
					}
					let n = (t.state & q) !== 0;
					R('need readable', n);
					if (t.length === 0 || t.length - e < t.highWaterMark) {
						n = true;
						R('length less than watermark', n);
					}
					if (t.ended || t.reading || t.destroyed || t.errored || !t.constructed) {
						n = false;
						R('reading, ended or constructing', n);
					} else if (n) {
						R('do read');
						t.state |= H | G;
						if (t.length === 0) t.state |= q;
						try {
							this._read(t.highWaterMark);
						} catch (e) {
							F(this, e);
						}
						t.state &= ~G;
						if (!t.reading) e = howMuchToRead(r, t);
					}
					let a;
					if (e > 0) a = fromList(e, t);
					else a = null;
					if (a === null) {
						t.needReadable = t.length <= t.highWaterMark;
						e = 0;
					} else {
						t.length -= e;
						if (t.multiAwaitDrain) {
							t.awaitDrainWriters.clear();
						} else {
							t.awaitDrainWriters = null;
						}
					}
					if (t.length === 0) {
						if (!t.ended) t.needReadable = true;
						if (r !== e && t.ended) endReadable(this);
					}
					if (a !== null && !t.errorEmitted && !t.closeEmitted) {
						t.dataEmitted = true;
						this.emit('data', a);
					}
					return a;
				};
				function onEofChunk(e, t) {
					R('onEofChunk');
					if (t.ended) return;
					if (t.decoder) {
						const e = t.decoder.end();
						if (e && e.length) {
							t.buffer.push(e);
							t.length += t.objectMode ? 1 : e.length;
						}
					}
					t.ended = true;
					if (t.sync) {
						emitReadable(e);
					} else {
						t.needReadable = false;
						t.emittedReadable = true;
						emitReadable_(e);
					}
				}
				function emitReadable(e) {
					const t = e._readableState;
					R('emitReadable', t.needReadable, t.emittedReadable);
					t.needReadable = false;
					if (!t.emittedReadable) {
						R('emitReadable', t.flowing);
						t.emittedReadable = true;
						n.nextTick(emitReadable_, e);
					}
				}
				function emitReadable_(e) {
					const t = e._readableState;
					R('emitReadable_', t.destroyed, t.length, t.ended);
					if (!t.destroyed && !t.errored && (t.length || t.ended)) {
						e.emit('readable');
						t.emittedReadable = false;
					}
					t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark;
					flow(e);
				}
				function maybeReadMore(e, t) {
					if (!t.readingMore && t.constructed) {
						t.readingMore = true;
						n.nextTick(maybeReadMore_, e, t);
					}
				}
				function maybeReadMore_(e, t) {
					while (
						!t.reading &&
						!t.ended &&
						(t.length < t.highWaterMark || (t.flowing && t.length === 0))
					) {
						const r = t.length;
						R('maybeReadMore read 0');
						e.read(0);
						if (r === t.length) break;
					}
					t.readingMore = false;
				}
				Readable.prototype._read = function (e) {
					throw new N('_read()');
				};
				Readable.prototype.pipe = function (e, t) {
					const r = this;
					const a = this._readableState;
					if (a.pipes.length === 1) {
						if (!a.multiAwaitDrain) {
							a.multiAwaitDrain = true;
							a.awaitDrainWriters = new c(a.awaitDrainWriters ? [a.awaitDrainWriters] : []);
						}
					}
					a.pipes.push(e);
					R('pipe count=%d opts=%j', a.pipes.length, t);
					const o = (!t || t.end !== false) && e !== n.stdout && e !== n.stderr;
					const s = o ? onend : unpipe;
					if (a.endEmitted) n.nextTick(s);
					else r.once('end', s);
					e.on('unpipe', onunpipe);
					function onunpipe(e, t) {
						R('onunpipe');
						if (e === r) {
							if (t && t.hasUnpiped === false) {
								t.hasUnpiped = true;
								cleanup();
							}
						}
					}
					function onend() {
						R('onend');
						e.end();
					}
					let i;
					let l = false;
					function cleanup() {
						R('cleanup');
						e.removeListener('close', onclose);
						e.removeListener('finish', onfinish);
						if (i) {
							e.removeListener('drain', i);
						}
						e.removeListener('error', onerror);
						e.removeListener('unpipe', onunpipe);
						r.removeListener('end', onend);
						r.removeListener('end', unpipe);
						r.removeListener('data', ondata);
						l = true;
						if (i && a.awaitDrainWriters && (!e._writableState || e._writableState.needDrain)) i();
					}
					function pause() {
						if (!l) {
							if (a.pipes.length === 1 && a.pipes[0] === e) {
								R('false write response, pause', 0);
								a.awaitDrainWriters = e;
								a.multiAwaitDrain = false;
							} else if (a.pipes.length > 1 && a.pipes.includes(e)) {
								R('false write response, pause', a.awaitDrainWriters.size);
								a.awaitDrainWriters.add(e);
							}
							r.pause();
						}
						if (!i) {
							i = pipeOnDrain(r, e);
							e.on('drain', i);
						}
					}
					r.on('data', ondata);
					function ondata(t) {
						R('ondata');
						const r = e.write(t);
						R('dest.write', r);
						if (r === false) {
							pause();
						}
					}
					function onerror(t) {
						R('onerror', t);
						unpipe();
						e.removeListener('error', onerror);
						if (e.listenerCount('error') === 0) {
							const r = e._writableState || e._readableState;
							if (r && !r.errorEmitted) {
								F(e, t);
							} else {
								e.emit('error', t);
							}
						}
					}
					y(e, 'error', onerror);
					function onclose() {
						e.removeListener('finish', onfinish);
						unpipe();
					}
					e.once('close', onclose);
					function onfinish() {
						R('onfinish');
						e.removeListener('close', onclose);
						unpipe();
					}
					e.once('finish', onfinish);
					function unpipe() {
						R('unpipe');
						r.unpipe(e);
					}
					e.emit('pipe', r);
					if (e.writableNeedDrain === true) {
						pause();
					} else if (!a.flowing) {
						R('pipe resume');
						r.resume();
					}
					return e;
				};
				function pipeOnDrain(e, t) {
					return function pipeOnDrainFunctionResult() {
						const r = e._readableState;
						if (r.awaitDrainWriters === t) {
							R('pipeOnDrain', 1);
							r.awaitDrainWriters = null;
						} else if (r.multiAwaitDrain) {
							R('pipeOnDrain', r.awaitDrainWriters.size);
							r.awaitDrainWriters.delete(t);
						}
						if (
							(!r.awaitDrainWriters || r.awaitDrainWriters.size === 0) &&
							e.listenerCount('data')
						) {
							e.resume();
						}
					};
				}
				Readable.prototype.unpipe = function (e) {
					const t = this._readableState;
					const r = { hasUnpiped: false };
					if (t.pipes.length === 0) return this;
					if (!e) {
						const e = t.pipes;
						t.pipes = [];
						this.pause();
						for (let t = 0; t < e.length; t++) e[t].emit('unpipe', this, { hasUnpiped: false });
						return this;
					}
					const n = a(t.pipes, e);
					if (n === -1) return this;
					t.pipes.splice(n, 1);
					if (t.pipes.length === 0) this.pause();
					e.emit('unpipe', this, r);
					return this;
				};
				Readable.prototype.on = function (e, t) {
					const r = _.prototype.on.call(this, e, t);
					const a = this._readableState;
					if (e === 'data') {
						a.readableListening = this.listenerCount('readable') > 0;
						if (a.flowing !== false) this.resume();
					} else if (e === 'readable') {
						if (!a.endEmitted && !a.readableListening) {
							a.readableListening = a.needReadable = true;
							a.flowing = false;
							a.emittedReadable = false;
							R('on readable', a.length, a.reading);
							if (a.length) {
								emitReadable(this);
							} else if (!a.reading) {
								n.nextTick(nReadingNextTick, this);
							}
						}
					}
					return r;
				};
				Readable.prototype.addListener = Readable.prototype.on;
				Readable.prototype.removeListener = function (e, t) {
					const r = _.prototype.removeListener.call(this, e, t);
					if (e === 'readable') {
						n.nextTick(updateReadableListening, this);
					}
					return r;
				};
				Readable.prototype.off = Readable.prototype.removeListener;
				Readable.prototype.removeAllListeners = function (e) {
					const t = _.prototype.removeAllListeners.apply(this, arguments);
					if (e === 'readable' || e === undefined) {
						n.nextTick(updateReadableListening, this);
					}
					return t;
				};
				function updateReadableListening(e) {
					const t = e._readableState;
					t.readableListening = e.listenerCount('readable') > 0;
					if (t.resumeScheduled && t[O] === false) {
						t.flowing = true;
					} else if (e.listenerCount('data') > 0) {
						e.resume();
					} else if (!t.readableListening) {
						t.flowing = null;
					}
				}
				function nReadingNextTick(e) {
					R('readable nexttick read 0');
					e.read(0);
				}
				Readable.prototype.resume = function () {
					const e = this._readableState;
					if (!e.flowing) {
						R('resume');
						e.flowing = !e.readableListening;
						resume(this, e);
					}
					e[O] = false;
					return this;
				};
				function resume(e, t) {
					if (!t.resumeScheduled) {
						t.resumeScheduled = true;
						n.nextTick(resume_, e, t);
					}
				}
				function resume_(e, t) {
					R('resume', t.reading);
					if (!t.reading) {
						e.read(0);
					}
					t.resumeScheduled = false;
					e.emit('resume');
					flow(e);
					if (t.flowing && !t.reading) e.read(0);
				}
				Readable.prototype.pause = function () {
					R('call pause flowing=%j', this._readableState.flowing);
					if (this._readableState.flowing !== false) {
						R('pause');
						this._readableState.flowing = false;
						this.emit('pause');
					}
					this._readableState[O] = true;
					return this;
				};
				function flow(e) {
					const t = e._readableState;
					R('flow', t.flowing);
					while (t.flowing && e.read() !== null);
				}
				Readable.prototype.wrap = function (e) {
					let t = false;
					e.on('data', (r) => {
						if (!this.push(r) && e.pause) {
							t = true;
							e.pause();
						}
					});
					e.on('end', () => {
						this.push(null);
					});
					e.on('error', (e) => {
						F(this, e);
					});
					e.on('close', () => {
						this.destroy();
					});
					e.on('destroy', () => {
						this.destroy();
					});
					this._read = () => {
						if (t && e.resume) {
							t = false;
							e.resume();
						}
					};
					const r = d(e);
					for (let t = 1; t < r.length; t++) {
						const n = r[t];
						if (this[n] === undefined && typeof e[n] === 'function') {
							this[n] = e[n].bind(e);
						}
					}
					return this;
				};
				Readable.prototype[m] = function () {
					return streamToAsyncIterator(this);
				};
				Readable.prototype.iterator = function (e) {
					if (e !== undefined) {
						P(e, 'options');
					}
					return streamToAsyncIterator(this, e);
				};
				function streamToAsyncIterator(e, t) {
					if (typeof e.read !== 'function') {
						e = Readable.wrap(e, { objectMode: true });
					}
					const r = createAsyncIterator(e, t);
					r.stream = e;
					return r;
				}
				async function* createAsyncIterator(e, t) {
					let r = nop;
					function next(t) {
						if (this === e) {
							r();
							r = nop;
						} else {
							r = t;
						}
					}
					e.on('readable', next);
					let n;
					const a = S(e, { writable: false }, (e) => {
						n = e ? v(n, e) : null;
						r();
						r = nop;
					});
					try {
						while (true) {
							const t = e.destroyed ? null : e.read();
							if (t !== null) {
								yield t;
							} else if (n) {
								throw n;
							} else if (n === null) {
								return;
							} else {
								await new f(next);
							}
						}
					} catch (e) {
						n = v(n, e);
						throw n;
					} finally {
						if (
							(n || (t === null || t === undefined ? undefined : t.destroyOnReturn) !== false) &&
							(n === undefined || e._readableState.autoDestroy)
						) {
							j.destroyer(e, null);
						} else {
							e.off('readable', next);
							a();
						}
					}
				}
				l(Readable.prototype, {
					readable: {
						__proto__: null,
						get() {
							const e = this._readableState;
							return (
								!!e && e.readable !== false && !e.destroyed && !e.errorEmitted && !e.endEmitted
							);
						},
						set(e) {
							if (this._readableState) {
								this._readableState.readable = !!e;
							}
						}
					},
					readableDidRead: {
						__proto__: null,
						enumerable: false,
						get: function () {
							return this._readableState.dataEmitted;
						}
					},
					readableAborted: {
						__proto__: null,
						enumerable: false,
						get: function () {
							return !!(
								this._readableState.readable !== false &&
								(this._readableState.destroyed || this._readableState.errored) &&
								!this._readableState.endEmitted
							);
						}
					},
					readableHighWaterMark: {
						__proto__: null,
						enumerable: false,
						get: function () {
							return this._readableState.highWaterMark;
						}
					},
					readableBuffer: {
						__proto__: null,
						enumerable: false,
						get: function () {
							return this._readableState && this._readableState.buffer;
						}
					},
					readableFlowing: {
						__proto__: null,
						enumerable: false,
						get: function () {
							return this._readableState.flowing;
						},
						set: function (e) {
							if (this._readableState) {
								this._readableState.flowing = e;
							}
						}
					},
					readableLength: {
						__proto__: null,
						enumerable: false,
						get() {
							return this._readableState.length;
						}
					},
					readableObjectMode: {
						__proto__: null,
						enumerable: false,
						get() {
							return this._readableState ? this._readableState.objectMode : false;
						}
					},
					readableEncoding: {
						__proto__: null,
						enumerable: false,
						get() {
							return this._readableState ? this._readableState.encoding : null;
						}
					},
					errored: {
						__proto__: null,
						enumerable: false,
						get() {
							return this._readableState ? this._readableState.errored : null;
						}
					},
					closed: {
						__proto__: null,
						get() {
							return this._readableState ? this._readableState.closed : false;
						}
					},
					destroyed: {
						__proto__: null,
						enumerable: false,
						get() {
							return this._readableState ? this._readableState.destroyed : false;
						},
						set(e) {
							if (!this._readableState) {
								return;
							}
							this._readableState.destroyed = e;
						}
					},
					readableEnded: {
						__proto__: null,
						enumerable: false,
						get() {
							return this._readableState ? this._readableState.endEmitted : false;
						}
					}
				});
				l(ReadableState.prototype, {
					pipesCount: {
						__proto__: null,
						get() {
							return this.pipes.length;
						}
					},
					paused: {
						__proto__: null,
						get() {
							return this[O] !== false;
						},
						set(e) {
							this[O] = !!e;
						}
					}
				});
				Readable._fromList = fromList;
				function fromList(e, t) {
					if (t.length === 0) return null;
					let r;
					if (t.objectMode) r = t.buffer.shift();
					else if (!e || e >= t.length) {
						if (t.decoder) r = t.buffer.join('');
						else if (t.buffer.length === 1) r = t.buffer.first();
						else r = t.buffer.concat(t.length);
						t.buffer.clear();
					} else {
						r = t.buffer.consume(e, t.decoder);
					}
					return r;
				}
				function endReadable(e) {
					const t = e._readableState;
					R('endReadable', t.endEmitted);
					if (!t.endEmitted) {
						t.ended = true;
						n.nextTick(endReadableNT, t, e);
					}
				}
				function endReadableNT(e, t) {
					R('endReadableNT', e.endEmitted, e.length);
					if (!e.errored && !e.closeEmitted && !e.endEmitted && e.length === 0) {
						e.endEmitted = true;
						t.emit('end');
						if (t.writable && t.allowHalfOpen === false) {
							n.nextTick(endWritableNT, t);
						} else if (e.autoDestroy) {
							const e = t._writableState;
							const r = !e || (e.autoDestroy && (e.finished || e.writable === false));
							if (r) {
								t.destroy();
							}
						}
					}
				}
				function endWritableNT(e) {
					const t = e.writable && !e.writableEnded && !e.destroyed;
					if (t) {
						e.end();
					}
				}
				Readable.from = function (e, t) {
					return C(Readable, e, t);
				};
				let se;
				function lazyWebStreams() {
					if (se === undefined) se = {};
					return se;
				}
				Readable.fromWeb = function (e, t) {
					return lazyWebStreams().newStreamReadableFromReadableStream(e, t);
				};
				Readable.toWeb = function (e, t) {
					return lazyWebStreams().newReadableStreamFromStreamReadable(e, t);
				};
				Readable.wrap = function (e, t) {
					var r, n;
					return new Readable({
						objectMode:
							(r = (n = e.readableObjectMode) !== null && n !== undefined ? n : e.objectMode) !==
								null && r !== undefined
								? r
								: true,
						...t,
						destroy(t, r) {
							j.destroyer(e, t);
							r(t);
						}
					}).wrap(e);
				};
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/state.js':
			(e, t, r) => {
				'use strict';
				const { MathFloor: n, NumberIsInteger: a } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				);
				const { validateInteger: o } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/validators.js'
				);
				const { ERR_INVALID_ARG_VALUE: s } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/errors.js'
				).codes;
				let i = 16 * 1024;
				let l = 16;
				function highWaterMarkFrom(e, t, r) {
					return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
				}
				function getDefaultHighWaterMark(e) {
					return e ? l : i;
				}
				function setDefaultHighWaterMark(e, t) {
					o(t, 'value', 0);
					if (e) {
						l = t;
					} else {
						i = t;
					}
				}
				function getHighWaterMark(e, t, r, o) {
					const i = highWaterMarkFrom(t, o, r);
					if (i != null) {
						if (!a(i) || i < 0) {
							const e = o ? `options.${r}` : 'options.highWaterMark';
							throw new s(e, i);
						}
						return n(i);
					}
					return getDefaultHighWaterMark(e.objectMode);
				}
				e.exports = { getHighWaterMark, getDefaultHighWaterMark, setDefaultHighWaterMark };
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/transform.js':
			(e, t, r) => {
				'use strict';
				const { ObjectSetPrototypeOf: n, Symbol: a } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				);
				e.exports = Transform;
				const { ERR_METHOD_NOT_IMPLEMENTED: o } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/errors.js'
				).codes;
				const s = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/duplex.js'
				);
				const { getHighWaterMark: i } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/state.js'
				);
				n(Transform.prototype, s.prototype);
				n(Transform, s);
				const l = a('kCallback');
				function Transform(e) {
					if (!(this instanceof Transform)) return new Transform(e);
					const t = e ? i(this, e, 'readableHighWaterMark', true) : null;
					if (t === 0) {
						e = {
							...e,
							highWaterMark: null,
							readableHighWaterMark: t,
							writableHighWaterMark: e.writableHighWaterMark || 0
						};
					}
					s.call(this, e);
					this._readableState.sync = false;
					this[l] = null;
					if (e) {
						if (typeof e.transform === 'function') this._transform = e.transform;
						if (typeof e.flush === 'function') this._flush = e.flush;
					}
					this.on('prefinish', prefinish);
				}
				function final(e) {
					if (typeof this._flush === 'function' && !this.destroyed) {
						this._flush((t, r) => {
							if (t) {
								if (e) {
									e(t);
								} else {
									this.destroy(t);
								}
								return;
							}
							if (r != null) {
								this.push(r);
							}
							this.push(null);
							if (e) {
								e();
							}
						});
					} else {
						this.push(null);
						if (e) {
							e();
						}
					}
				}
				function prefinish() {
					if (this._final !== final) {
						final.call(this);
					}
				}
				Transform.prototype._final = final;
				Transform.prototype._transform = function (e, t, r) {
					throw new o('_transform()');
				};
				Transform.prototype._write = function (e, t, r) {
					const n = this._readableState;
					const a = this._writableState;
					const o = n.length;
					this._transform(e, t, (e, t) => {
						if (e) {
							r(e);
							return;
						}
						if (t != null) {
							this.push(t);
						}
						if (a.ended || o === n.length || n.length < n.highWaterMark) {
							r();
						} else {
							this[l] = r;
						}
					});
				};
				Transform.prototype._read = function () {
					if (this[l]) {
						const e = this[l];
						this[l] = null;
						e();
					}
				};
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/utils.js':
			(e, t, r) => {
				'use strict';
				const {
					SymbolAsyncIterator: n,
					SymbolIterator: a,
					SymbolFor: o
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				);
				const s = o('nodejs.stream.destroyed');
				const i = o('nodejs.stream.errored');
				const l = o('nodejs.stream.readable');
				const d = o('nodejs.stream.writable');
				const u = o('nodejs.stream.disturbed');
				const f = o('nodejs.webstream.isClosedPromise');
				const c = o('nodejs.webstream.controllerErrorFunction');
				function isReadableNodeStream(e, t = false) {
					var r;
					return !!(
						e &&
						typeof e.pipe === 'function' &&
						typeof e.on === 'function' &&
						(!t || (typeof e.pause === 'function' && typeof e.resume === 'function')) &&
						(!e._writableState ||
							((r = e._readableState) === null || r === undefined ? undefined : r.readable) !==
								false) &&
						(!e._writableState || e._readableState)
					);
				}
				function isWritableNodeStream(e) {
					var t;
					return !!(
						e &&
						typeof e.write === 'function' &&
						typeof e.on === 'function' &&
						(!e._readableState ||
							((t = e._writableState) === null || t === undefined ? undefined : t.writable) !==
								false)
					);
				}
				function isDuplexNodeStream(e) {
					return !!(
						e &&
						typeof e.pipe === 'function' &&
						e._readableState &&
						typeof e.on === 'function' &&
						typeof e.write === 'function'
					);
				}
				function isNodeStream(e) {
					return (
						e &&
						(e._readableState ||
							e._writableState ||
							(typeof e.write === 'function' && typeof e.on === 'function') ||
							(typeof e.pipe === 'function' && typeof e.on === 'function'))
					);
				}
				function isReadableStream(e) {
					return !!(
						e &&
						!isNodeStream(e) &&
						typeof e.pipeThrough === 'function' &&
						typeof e.getReader === 'function' &&
						typeof e.cancel === 'function'
					);
				}
				function isWritableStream(e) {
					return !!(
						e &&
						!isNodeStream(e) &&
						typeof e.getWriter === 'function' &&
						typeof e.abort === 'function'
					);
				}
				function isTransformStream(e) {
					return !!(
						e &&
						!isNodeStream(e) &&
						typeof e.readable === 'object' &&
						typeof e.writable === 'object'
					);
				}
				function isWebStream(e) {
					return isReadableStream(e) || isWritableStream(e) || isTransformStream(e);
				}
				function isIterable(e, t) {
					if (e == null) return false;
					if (t === true) return typeof e[n] === 'function';
					if (t === false) return typeof e[a] === 'function';
					return typeof e[n] === 'function' || typeof e[a] === 'function';
				}
				function isDestroyed(e) {
					if (!isNodeStream(e)) return null;
					const t = e._writableState;
					const r = e._readableState;
					const n = t || r;
					return !!(e.destroyed || e[s] || (n !== null && n !== undefined && n.destroyed));
				}
				function isWritableEnded(e) {
					if (!isWritableNodeStream(e)) return null;
					if (e.writableEnded === true) return true;
					const t = e._writableState;
					if (t !== null && t !== undefined && t.errored) return false;
					if (typeof (t === null || t === undefined ? undefined : t.ended) !== 'boolean')
						return null;
					return t.ended;
				}
				function isWritableFinished(e, t) {
					if (!isWritableNodeStream(e)) return null;
					if (e.writableFinished === true) return true;
					const r = e._writableState;
					if (r !== null && r !== undefined && r.errored) return false;
					if (typeof (r === null || r === undefined ? undefined : r.finished) !== 'boolean')
						return null;
					return !!(r.finished || (t === false && r.ended === true && r.length === 0));
				}
				function isReadableEnded(e) {
					if (!isReadableNodeStream(e)) return null;
					if (e.readableEnded === true) return true;
					const t = e._readableState;
					if (!t || t.errored) return false;
					if (typeof (t === null || t === undefined ? undefined : t.ended) !== 'boolean')
						return null;
					return t.ended;
				}
				function isReadableFinished(e, t) {
					if (!isReadableNodeStream(e)) return null;
					const r = e._readableState;
					if (r !== null && r !== undefined && r.errored) return false;
					if (typeof (r === null || r === undefined ? undefined : r.endEmitted) !== 'boolean')
						return null;
					return !!(r.endEmitted || (t === false && r.ended === true && r.length === 0));
				}
				function isReadable(e) {
					if (e && e[l] != null) return e[l];
					if (typeof (e === null || e === undefined ? undefined : e.readable) !== 'boolean')
						return null;
					if (isDestroyed(e)) return false;
					return isReadableNodeStream(e) && e.readable && !isReadableFinished(e);
				}
				function isWritable(e) {
					if (e && e[d] != null) return e[d];
					if (typeof (e === null || e === undefined ? undefined : e.writable) !== 'boolean')
						return null;
					if (isDestroyed(e)) return false;
					return isWritableNodeStream(e) && e.writable && !isWritableEnded(e);
				}
				function isFinished(e, t) {
					if (!isNodeStream(e)) {
						return null;
					}
					if (isDestroyed(e)) {
						return true;
					}
					if ((t === null || t === undefined ? undefined : t.readable) !== false && isReadable(e)) {
						return false;
					}
					if ((t === null || t === undefined ? undefined : t.writable) !== false && isWritable(e)) {
						return false;
					}
					return true;
				}
				function isWritableErrored(e) {
					var t, r;
					if (!isNodeStream(e)) {
						return null;
					}
					if (e.writableErrored) {
						return e.writableErrored;
					}
					return (t =
						(r = e._writableState) === null || r === undefined ? undefined : r.errored) !== null &&
						t !== undefined
						? t
						: null;
				}
				function isReadableErrored(e) {
					var t, r;
					if (!isNodeStream(e)) {
						return null;
					}
					if (e.readableErrored) {
						return e.readableErrored;
					}
					return (t =
						(r = e._readableState) === null || r === undefined ? undefined : r.errored) !== null &&
						t !== undefined
						? t
						: null;
				}
				function isClosed(e) {
					if (!isNodeStream(e)) {
						return null;
					}
					if (typeof e.closed === 'boolean') {
						return e.closed;
					}
					const t = e._writableState;
					const r = e._readableState;
					if (
						typeof (t === null || t === undefined ? undefined : t.closed) === 'boolean' ||
						typeof (r === null || r === undefined ? undefined : r.closed) === 'boolean'
					) {
						return (
							(t === null || t === undefined ? undefined : t.closed) ||
							(r === null || r === undefined ? undefined : r.closed)
						);
					}
					if (typeof e._closed === 'boolean' && isOutgoingMessage(e)) {
						return e._closed;
					}
					return null;
				}
				function isOutgoingMessage(e) {
					return (
						typeof e._closed === 'boolean' &&
						typeof e._defaultKeepAlive === 'boolean' &&
						typeof e._removedConnection === 'boolean' &&
						typeof e._removedContLen === 'boolean'
					);
				}
				function isServerResponse(e) {
					return typeof e._sent100 === 'boolean' && isOutgoingMessage(e);
				}
				function isServerRequest(e) {
					var t;
					return (
						typeof e._consuming === 'boolean' &&
						typeof e._dumped === 'boolean' &&
						((t = e.req) === null || t === undefined ? undefined : t.upgradeOrConnect) === undefined
					);
				}
				function willEmitClose(e) {
					if (!isNodeStream(e)) return null;
					const t = e._writableState;
					const r = e._readableState;
					const n = t || r;
					return (
						(!n && isServerResponse(e)) ||
						!!(n && n.autoDestroy && n.emitClose && n.closed === false)
					);
				}
				function isDisturbed(e) {
					var t;
					return !!(
						e &&
						((t = e[u]) !== null && t !== undefined ? t : e.readableDidRead || e.readableAborted)
					);
				}
				function isErrored(e) {
					var t, r, n, a, o, s, l, d, u, f;
					return !!(
						e &&
						((t =
							(r =
								(n =
									(a =
										(o = (s = e[i]) !== null && s !== undefined ? s : e.readableErrored) !== null &&
										o !== undefined
											? o
											: e.writableErrored) !== null && a !== undefined
										? a
										: (l = e._readableState) === null || l === undefined
											? undefined
											: l.errorEmitted) !== null && n !== undefined
									? n
									: (d = e._writableState) === null || d === undefined
										? undefined
										: d.errorEmitted) !== null && r !== undefined
								? r
								: (u = e._readableState) === null || u === undefined
									? undefined
									: u.errored) !== null && t !== undefined
							? t
							: (f = e._writableState) === null || f === undefined
								? undefined
								: f.errored)
					);
				}
				e.exports = {
					isDestroyed,
					kIsDestroyed: s,
					isDisturbed,
					kIsDisturbed: u,
					isErrored,
					kIsErrored: i,
					isReadable,
					kIsReadable: l,
					kIsClosedPromise: f,
					kControllerErrorFunction: c,
					kIsWritable: d,
					isClosed,
					isDuplexNodeStream,
					isFinished,
					isIterable,
					isReadableNodeStream,
					isReadableStream,
					isReadableEnded,
					isReadableFinished,
					isReadableErrored,
					isNodeStream,
					isWebStream,
					isWritable,
					isWritableNodeStream,
					isWritableStream,
					isWritableEnded,
					isWritableFinished,
					isWritableErrored,
					isServerRequest,
					isServerResponse,
					willEmitClose,
					isTransformStream
				};
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/writable.js':
			(e, t, r) => {
				'use strict';
				const n = r('../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js');
				const {
					ArrayPrototypeSlice: a,
					Error: o,
					FunctionPrototypeSymbolHasInstance: s,
					ObjectDefineProperty: i,
					ObjectDefineProperties: l,
					ObjectSetPrototypeOf: d,
					StringPrototypeToLowerCase: u,
					Symbol: f,
					SymbolHasInstance: c
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				);
				e.exports = Writable;
				Writable.WritableState = WritableState;
				const { EventEmitter: b } = r(
					'../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js'
				);
				const m = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/legacy.js'
				).Stream;
				const { Buffer: p } = r(
					'../../node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js'
				);
				const h = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/destroy.js'
				);
				const { addAbortSignal: _ } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js'
				);
				const { getHighWaterMark: y, getDefaultHighWaterMark: g } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/state.js'
				);
				const {
					ERR_INVALID_ARG_TYPE: w,
					ERR_METHOD_NOT_IMPLEMENTED: S,
					ERR_MULTIPLE_CALLBACK: R,
					ERR_STREAM_CANNOT_PIPE: A,
					ERR_STREAM_DESTROYED: j,
					ERR_STREAM_ALREADY_FINISHED: T,
					ERR_STREAM_NULL_VALUES: k,
					ERR_STREAM_WRITE_AFTER_END: v,
					ERR_UNKNOWN_ENCODING: D
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/errors.js'
				).codes;
				const { errorOrDestroy: N } = h;
				d(Writable.prototype, m.prototype);
				d(Writable, m);
				function nop() {}
				const M = f('kOnFinished');
				function WritableState(e, t, n) {
					if (typeof n !== 'boolean')
						n =
							t instanceof
							r(
								'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/duplex.js'
							);
					this.objectMode = !!(e && e.objectMode);
					if (n) this.objectMode = this.objectMode || !!(e && e.writableObjectMode);
					this.highWaterMark = e ? y(this, e, 'writableHighWaterMark', n) : g(false);
					this.finalCalled = false;
					this.needDrain = false;
					this.ending = false;
					this.ended = false;
					this.finished = false;
					this.destroyed = false;
					const a = !!(e && e.decodeStrings === false);
					this.decodeStrings = !a;
					this.defaultEncoding = (e && e.defaultEncoding) || 'utf8';
					this.length = 0;
					this.writing = false;
					this.corked = 0;
					this.sync = true;
					this.bufferProcessing = false;
					this.onwrite = onwrite.bind(undefined, t);
					this.writecb = null;
					this.writelen = 0;
					this.afterWriteTickInfo = null;
					resetBuffer(this);
					this.pendingcb = 0;
					this.constructed = true;
					this.prefinished = false;
					this.errorEmitted = false;
					this.emitClose = !e || e.emitClose !== false;
					this.autoDestroy = !e || e.autoDestroy !== false;
					this.errored = null;
					this.closed = false;
					this.closeEmitted = false;
					this[M] = [];
				}
				function resetBuffer(e) {
					e.buffered = [];
					e.bufferedIndex = 0;
					e.allBuffers = true;
					e.allNoop = true;
				}
				WritableState.prototype.getBuffer = function getBuffer() {
					return a(this.buffered, this.bufferedIndex);
				};
				i(WritableState.prototype, 'bufferedRequestCount', {
					__proto__: null,
					get() {
						return this.buffered.length - this.bufferedIndex;
					}
				});
				function Writable(e) {
					const t =
						this instanceof
						r(
							'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/duplex.js'
						);
					if (!t && !s(Writable, this)) return new Writable(e);
					this._writableState = new WritableState(e, this, t);
					if (e) {
						if (typeof e.write === 'function') this._write = e.write;
						if (typeof e.writev === 'function') this._writev = e.writev;
						if (typeof e.destroy === 'function') this._destroy = e.destroy;
						if (typeof e.final === 'function') this._final = e.final;
						if (typeof e.construct === 'function') this._construct = e.construct;
						if (e.signal) _(e.signal, this);
					}
					m.call(this, e);
					h.construct(this, () => {
						const e = this._writableState;
						if (!e.writing) {
							clearBuffer(this, e);
						}
						finishMaybe(this, e);
					});
				}
				i(Writable, c, {
					__proto__: null,
					value: function (e) {
						if (s(this, e)) return true;
						if (this !== Writable) return false;
						return e && e._writableState instanceof WritableState;
					}
				});
				Writable.prototype.pipe = function () {
					N(this, new A());
				};
				function _write(e, t, r, a) {
					const o = e._writableState;
					if (typeof r === 'function') {
						a = r;
						r = o.defaultEncoding;
					} else {
						if (!r) r = o.defaultEncoding;
						else if (r !== 'buffer' && !p.isEncoding(r)) throw new D(r);
						if (typeof a !== 'function') a = nop;
					}
					if (t === null) {
						throw new k();
					} else if (!o.objectMode) {
						if (typeof t === 'string') {
							if (o.decodeStrings !== false) {
								t = p.from(t, r);
								r = 'buffer';
							}
						} else if (t instanceof p) {
							r = 'buffer';
						} else if (m._isUint8Array(t)) {
							t = m._uint8ArrayToBuffer(t);
							r = 'buffer';
						} else {
							throw new w('chunk', ['string', 'Buffer', 'Uint8Array'], t);
						}
					}
					let s;
					if (o.ending) {
						s = new v();
					} else if (o.destroyed) {
						s = new j('write');
					}
					if (s) {
						n.nextTick(a, s);
						N(e, s, true);
						return s;
					}
					o.pendingcb++;
					return writeOrBuffer(e, o, t, r, a);
				}
				Writable.prototype.write = function (e, t, r) {
					return _write(this, e, t, r) === true;
				};
				Writable.prototype.cork = function () {
					this._writableState.corked++;
				};
				Writable.prototype.uncork = function () {
					const e = this._writableState;
					if (e.corked) {
						e.corked--;
						if (!e.writing) clearBuffer(this, e);
					}
				};
				Writable.prototype.setDefaultEncoding = function setDefaultEncoding(e) {
					if (typeof e === 'string') e = u(e);
					if (!p.isEncoding(e)) throw new D(e);
					this._writableState.defaultEncoding = e;
					return this;
				};
				function writeOrBuffer(e, t, r, n, a) {
					const o = t.objectMode ? 1 : r.length;
					t.length += o;
					const s = t.length < t.highWaterMark;
					if (!s) t.needDrain = true;
					if (t.writing || t.corked || t.errored || !t.constructed) {
						t.buffered.push({ chunk: r, encoding: n, callback: a });
						if (t.allBuffers && n !== 'buffer') {
							t.allBuffers = false;
						}
						if (t.allNoop && a !== nop) {
							t.allNoop = false;
						}
					} else {
						t.writelen = o;
						t.writecb = a;
						t.writing = true;
						t.sync = true;
						e._write(r, n, t.onwrite);
						t.sync = false;
					}
					return s && !t.errored && !t.destroyed;
				}
				function doWrite(e, t, r, n, a, o, s) {
					t.writelen = n;
					t.writecb = s;
					t.writing = true;
					t.sync = true;
					if (t.destroyed) t.onwrite(new j('write'));
					else if (r) e._writev(a, t.onwrite);
					else e._write(a, o, t.onwrite);
					t.sync = false;
				}
				function onwriteError(e, t, r, n) {
					--t.pendingcb;
					n(r);
					errorBuffer(t);
					N(e, r);
				}
				function onwrite(e, t) {
					const r = e._writableState;
					const a = r.sync;
					const o = r.writecb;
					if (typeof o !== 'function') {
						N(e, new R());
						return;
					}
					r.writing = false;
					r.writecb = null;
					r.length -= r.writelen;
					r.writelen = 0;
					if (t) {
						t.stack;
						if (!r.errored) {
							r.errored = t;
						}
						if (e._readableState && !e._readableState.errored) {
							e._readableState.errored = t;
						}
						if (a) {
							n.nextTick(onwriteError, e, r, t, o);
						} else {
							onwriteError(e, r, t, o);
						}
					} else {
						if (r.buffered.length > r.bufferedIndex) {
							clearBuffer(e, r);
						}
						if (a) {
							if (r.afterWriteTickInfo !== null && r.afterWriteTickInfo.cb === o) {
								r.afterWriteTickInfo.count++;
							} else {
								r.afterWriteTickInfo = { count: 1, cb: o, stream: e, state: r };
								n.nextTick(afterWriteTick, r.afterWriteTickInfo);
							}
						} else {
							afterWrite(e, r, 1, o);
						}
					}
				}
				function afterWriteTick({ stream: e, state: t, count: r, cb: n }) {
					t.afterWriteTickInfo = null;
					return afterWrite(e, t, r, n);
				}
				function afterWrite(e, t, r, n) {
					const a = !t.ending && !e.destroyed && t.length === 0 && t.needDrain;
					if (a) {
						t.needDrain = false;
						e.emit('drain');
					}
					while (r-- > 0) {
						t.pendingcb--;
						n();
					}
					if (t.destroyed) {
						errorBuffer(t);
					}
					finishMaybe(e, t);
				}
				function errorBuffer(e) {
					if (e.writing) {
						return;
					}
					for (let r = e.bufferedIndex; r < e.buffered.length; ++r) {
						var t;
						const { chunk: n, callback: a } = e.buffered[r];
						const o = e.objectMode ? 1 : n.length;
						e.length -= o;
						a((t = e.errored) !== null && t !== undefined ? t : new j('write'));
					}
					const r = e[M].splice(0);
					for (let t = 0; t < r.length; t++) {
						var n;
						r[t]((n = e.errored) !== null && n !== undefined ? n : new j('end'));
					}
					resetBuffer(e);
				}
				function clearBuffer(e, t) {
					if (t.corked || t.bufferProcessing || t.destroyed || !t.constructed) {
						return;
					}
					const { buffered: r, bufferedIndex: n, objectMode: o } = t;
					const s = r.length - n;
					if (!s) {
						return;
					}
					let i = n;
					t.bufferProcessing = true;
					if (s > 1 && e._writev) {
						t.pendingcb -= s - 1;
						const n = t.allNoop
							? nop
							: (e) => {
									for (let t = i; t < r.length; ++t) {
										r[t].callback(e);
									}
								};
						const o = t.allNoop && i === 0 ? r : a(r, i);
						o.allBuffers = t.allBuffers;
						doWrite(e, t, true, t.length, o, '', n);
						resetBuffer(t);
					} else {
						do {
							const { chunk: n, encoding: a, callback: s } = r[i];
							r[i++] = null;
							const l = o ? 1 : n.length;
							doWrite(e, t, false, l, n, a, s);
						} while (i < r.length && !t.writing);
						if (i === r.length) {
							resetBuffer(t);
						} else if (i > 256) {
							r.splice(0, i);
							t.bufferedIndex = 0;
						} else {
							t.bufferedIndex = i;
						}
					}
					t.bufferProcessing = false;
				}
				Writable.prototype._write = function (e, t, r) {
					if (this._writev) {
						this._writev([{ chunk: e, encoding: t }], r);
					} else {
						throw new S('_write()');
					}
				};
				Writable.prototype._writev = null;
				Writable.prototype.end = function (e, t, r) {
					const a = this._writableState;
					if (typeof e === 'function') {
						r = e;
						e = null;
						t = null;
					} else if (typeof t === 'function') {
						r = t;
						t = null;
					}
					let s;
					if (e !== null && e !== undefined) {
						const r = _write(this, e, t);
						if (r instanceof o) {
							s = r;
						}
					}
					if (a.corked) {
						a.corked = 1;
						this.uncork();
					}
					if (s) {
					} else if (!a.errored && !a.ending) {
						a.ending = true;
						finishMaybe(this, a, true);
						a.ended = true;
					} else if (a.finished) {
						s = new T('end');
					} else if (a.destroyed) {
						s = new j('end');
					}
					if (typeof r === 'function') {
						if (s || a.finished) {
							n.nextTick(r, s);
						} else {
							a[M].push(r);
						}
					}
					return this;
				};
				function needFinish(e) {
					return (
						e.ending &&
						!e.destroyed &&
						e.constructed &&
						e.length === 0 &&
						!e.errored &&
						e.buffered.length === 0 &&
						!e.finished &&
						!e.writing &&
						!e.errorEmitted &&
						!e.closeEmitted
					);
				}
				function callFinal(e, t) {
					let r = false;
					function onFinish(a) {
						if (r) {
							N(e, a !== null && a !== undefined ? a : R());
							return;
						}
						r = true;
						t.pendingcb--;
						if (a) {
							const r = t[M].splice(0);
							for (let e = 0; e < r.length; e++) {
								r[e](a);
							}
							N(e, a, t.sync);
						} else if (needFinish(t)) {
							t.prefinished = true;
							e.emit('prefinish');
							t.pendingcb++;
							n.nextTick(finish, e, t);
						}
					}
					t.sync = true;
					t.pendingcb++;
					try {
						e._final(onFinish);
					} catch (e) {
						onFinish(e);
					}
					t.sync = false;
				}
				function prefinish(e, t) {
					if (!t.prefinished && !t.finalCalled) {
						if (typeof e._final === 'function' && !t.destroyed) {
							t.finalCalled = true;
							callFinal(e, t);
						} else {
							t.prefinished = true;
							e.emit('prefinish');
						}
					}
				}
				function finishMaybe(e, t, r) {
					if (needFinish(t)) {
						prefinish(e, t);
						if (t.pendingcb === 0) {
							if (r) {
								t.pendingcb++;
								n.nextTick(
									(e, t) => {
										if (needFinish(t)) {
											finish(e, t);
										} else {
											t.pendingcb--;
										}
									},
									e,
									t
								);
							} else if (needFinish(t)) {
								t.pendingcb++;
								finish(e, t);
							}
						}
					}
				}
				function finish(e, t) {
					t.pendingcb--;
					t.finished = true;
					const r = t[M].splice(0);
					for (let e = 0; e < r.length; e++) {
						r[e]();
					}
					e.emit('finish');
					if (t.autoDestroy) {
						const t = e._readableState;
						const r = !t || (t.autoDestroy && (t.endEmitted || t.readable === false));
						if (r) {
							e.destroy();
						}
					}
				}
				l(Writable.prototype, {
					closed: {
						__proto__: null,
						get() {
							return this._writableState ? this._writableState.closed : false;
						}
					},
					destroyed: {
						__proto__: null,
						get() {
							return this._writableState ? this._writableState.destroyed : false;
						},
						set(e) {
							if (this._writableState) {
								this._writableState.destroyed = e;
							}
						}
					},
					writable: {
						__proto__: null,
						get() {
							const e = this._writableState;
							return (
								!!e && e.writable !== false && !e.destroyed && !e.errored && !e.ending && !e.ended
							);
						},
						set(e) {
							if (this._writableState) {
								this._writableState.writable = !!e;
							}
						}
					},
					writableFinished: {
						__proto__: null,
						get() {
							return this._writableState ? this._writableState.finished : false;
						}
					},
					writableObjectMode: {
						__proto__: null,
						get() {
							return this._writableState ? this._writableState.objectMode : false;
						}
					},
					writableBuffer: {
						__proto__: null,
						get() {
							return this._writableState && this._writableState.getBuffer();
						}
					},
					writableEnded: {
						__proto__: null,
						get() {
							return this._writableState ? this._writableState.ending : false;
						}
					},
					writableNeedDrain: {
						__proto__: null,
						get() {
							const e = this._writableState;
							if (!e) return false;
							return !e.destroyed && !e.ending && e.needDrain;
						}
					},
					writableHighWaterMark: {
						__proto__: null,
						get() {
							return this._writableState && this._writableState.highWaterMark;
						}
					},
					writableCorked: {
						__proto__: null,
						get() {
							return this._writableState ? this._writableState.corked : 0;
						}
					},
					writableLength: {
						__proto__: null,
						get() {
							return this._writableState && this._writableState.length;
						}
					},
					errored: {
						__proto__: null,
						enumerable: false,
						get() {
							return this._writableState ? this._writableState.errored : null;
						}
					},
					writableAborted: {
						__proto__: null,
						enumerable: false,
						get: function () {
							return !!(
								this._writableState.writable !== false &&
								(this._writableState.destroyed || this._writableState.errored) &&
								!this._writableState.finished
							);
						}
					}
				});
				const W = h.destroy;
				Writable.prototype.destroy = function (e, t) {
					const r = this._writableState;
					if (!r.destroyed && (r.bufferedIndex < r.buffered.length || r[M].length)) {
						n.nextTick(errorBuffer, r);
					}
					W.call(this, e, t);
					return this;
				};
				Writable.prototype._undestroy = h.undestroy;
				Writable.prototype._destroy = function (e, t) {
					t(e);
				};
				Writable.prototype[b.captureRejectionSymbol] = function (e) {
					this.destroy(e);
				};
				let I;
				function lazyWebStreams() {
					if (I === undefined) I = {};
					return I;
				}
				Writable.fromWeb = function (e, t) {
					return lazyWebStreams().newStreamWritableFromWritableStream(e, t);
				};
				Writable.toWeb = function (e) {
					return lazyWebStreams().newWritableStreamFromStreamWritable(e);
				};
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/validators.js':
			(e, t, r) => {
				'use strict';
				const {
					ArrayIsArray: n,
					ArrayPrototypeIncludes: a,
					ArrayPrototypeJoin: o,
					ArrayPrototypeMap: s,
					NumberIsInteger: i,
					NumberIsNaN: l,
					NumberMAX_SAFE_INTEGER: d,
					NumberMIN_SAFE_INTEGER: u,
					NumberParseInt: f,
					ObjectPrototypeHasOwnProperty: c,
					RegExpPrototypeExec: b,
					String: m,
					StringPrototypeToUpperCase: p,
					StringPrototypeTrim: h
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				);
				const {
					hideStackFrames: _,
					codes: {
						ERR_SOCKET_BAD_PORT: y,
						ERR_INVALID_ARG_TYPE: g,
						ERR_INVALID_ARG_VALUE: w,
						ERR_OUT_OF_RANGE: S,
						ERR_UNKNOWN_SIGNAL: R
					}
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/errors.js'
				);
				const { normalizeEncoding: A } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util.js'
				);
				const { isAsyncFunction: j, isArrayBufferView: T } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util.js'
				).types;
				const k = {};
				function isInt32(e) {
					return e === (e | 0);
				}
				function isUint32(e) {
					return e === e >>> 0;
				}
				const v = /^[0-7]+$/;
				const D = 'must be a 32-bit unsigned integer or an octal string';
				function parseFileMode(e, t, r) {
					if (typeof e === 'undefined') {
						e = r;
					}
					if (typeof e === 'string') {
						if (b(v, e) === null) {
							throw new w(t, e, D);
						}
						e = f(e, 8);
					}
					W(e, t);
					return e;
				}
				const N = _((e, t, r = u, n = d) => {
					if (typeof e !== 'number') throw new g(t, 'number', e);
					if (!i(e)) throw new S(t, 'an integer', e);
					if (e < r || e > n) throw new S(t, `>= ${r} && <= ${n}`, e);
				});
				const M = _((e, t, r = -2147483648, n = 2147483647) => {
					if (typeof e !== 'number') {
						throw new g(t, 'number', e);
					}
					if (!i(e)) {
						throw new S(t, 'an integer', e);
					}
					if (e < r || e > n) {
						throw new S(t, `>= ${r} && <= ${n}`, e);
					}
				});
				const W = _((e, t, r = false) => {
					if (typeof e !== 'number') {
						throw new g(t, 'number', e);
					}
					if (!i(e)) {
						throw new S(t, 'an integer', e);
					}
					const n = r ? 1 : 0;
					const a = 4294967295;
					if (e < n || e > a) {
						throw new S(t, `>= ${n} && <= ${a}`, e);
					}
				});
				function validateString(e, t) {
					if (typeof e !== 'string') throw new g(t, 'string', e);
				}
				function validateNumber(e, t, r = undefined, n) {
					if (typeof e !== 'number') throw new g(t, 'number', e);
					if ((r != null && e < r) || (n != null && e > n) || ((r != null || n != null) && l(e))) {
						throw new S(
							t,
							`${r != null ? `>= ${r}` : ''}${r != null && n != null ? ' && ' : ''}${n != null ? `<= ${n}` : ''}`,
							e
						);
					}
				}
				const I = _((e, t, r) => {
					if (!a(r, e)) {
						const n = o(
							s(r, (e) => (typeof e === 'string' ? `'${e}'` : m(e))),
							', '
						);
						const a = 'must be one of: ' + n;
						throw new w(t, e, a);
					}
				});
				function validateBoolean(e, t) {
					if (typeof e !== 'boolean') throw new g(t, 'boolean', e);
				}
				function getOwnPropertyValueOrDefault(e, t, r) {
					return e == null || !c(e, t) ? r : e[t];
				}
				const x = _((e, t, r = null) => {
					const a = getOwnPropertyValueOrDefault(r, 'allowArray', false);
					const o = getOwnPropertyValueOrDefault(r, 'allowFunction', false);
					const s = getOwnPropertyValueOrDefault(r, 'nullable', false);
					if (
						(!s && e === null) ||
						(!a && n(e)) ||
						(typeof e !== 'object' && (!o || typeof e !== 'function'))
					) {
						throw new g(t, 'Object', e);
					}
				});
				const P = _((e, t) => {
					if (e != null && typeof e !== 'object' && typeof e !== 'function') {
						throw new g(t, 'a dictionary', e);
					}
				});
				const O = _((e, t, r = 0) => {
					if (!n(e)) {
						throw new g(t, 'Array', e);
					}
					if (e.length < r) {
						const n = `must be longer than ${r}`;
						throw new w(t, e, n);
					}
				});
				function validateStringArray(e, t) {
					O(e, t);
					for (let r = 0; r < e.length; r++) {
						validateString(e[r], `${t}[${r}]`);
					}
				}
				function validateBooleanArray(e, t) {
					O(e, t);
					for (let r = 0; r < e.length; r++) {
						validateBoolean(e[r], `${t}[${r}]`);
					}
				}
				function validateAbortSignalArray(e, t) {
					O(e, t);
					for (let r = 0; r < e.length; r++) {
						const n = e[r];
						const a = `${t}[${r}]`;
						if (n == null) {
							throw new g(a, 'AbortSignal', n);
						}
						C(n, a);
					}
				}
				function validateSignalName(e, t = 'signal') {
					validateString(e, t);
					if (k[e] === undefined) {
						if (k[p(e)] !== undefined) {
							throw new R(e + ' (signals must use all capital letters)');
						}
						throw new R(e);
					}
				}
				const L = _((e, t = 'buffer') => {
					if (!T(e)) {
						throw new g(t, ['Buffer', 'TypedArray', 'DataView'], e);
					}
				});
				function validateEncoding(e, t) {
					const r = A(t);
					const n = e.length;
					if (r === 'hex' && n % 2 !== 0) {
						throw new w('encoding', t, `is invalid for data of length ${n}`);
					}
				}
				function validatePort(e, t = 'Port', r = true) {
					if (
						(typeof e !== 'number' && typeof e !== 'string') ||
						(typeof e === 'string' && h(e).length === 0) ||
						+e !== +e >>> 0 ||
						e > 65535 ||
						(e === 0 && !r)
					) {
						throw new y(t, e, r);
					}
					return e | 0;
				}
				const C = _((e, t) => {
					if (e !== undefined && (e === null || typeof e !== 'object' || !('aborted' in e))) {
						throw new g(t, 'AbortSignal', e);
					}
				});
				const F = _((e, t) => {
					if (typeof e !== 'function') throw new g(t, 'Function', e);
				});
				const B = _((e, t) => {
					if (typeof e !== 'function' || j(e)) throw new g(t, 'Function', e);
				});
				const $ = _((e, t) => {
					if (e !== undefined) throw new g(t, 'undefined', e);
				});
				function validateUnion(e, t, r) {
					if (!a(r, e)) {
						throw new g(t, `('${o(r, '|')}')`, e);
					}
				}
				const U = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
				function validateLinkHeaderFormat(e, t) {
					if (typeof e === 'undefined' || !b(U, e)) {
						throw new w(
							t,
							e,
							'must be an array or string of format "</styles.css>; rel=preload; as=style"'
						);
					}
				}
				function validateLinkHeaderValue(e) {
					if (typeof e === 'string') {
						validateLinkHeaderFormat(e, 'hints');
						return e;
					} else if (n(e)) {
						const t = e.length;
						let r = '';
						if (t === 0) {
							return r;
						}
						for (let n = 0; n < t; n++) {
							const a = e[n];
							validateLinkHeaderFormat(a, 'hints');
							r += a;
							if (n !== t - 1) {
								r += ', ';
							}
						}
						return r;
					}
					throw new w(
						'hints',
						e,
						'must be an array or string of format "</styles.css>; rel=preload; as=style"'
					);
				}
				e.exports = {
					isInt32,
					isUint32,
					parseFileMode,
					validateArray: O,
					validateStringArray,
					validateBooleanArray,
					validateAbortSignalArray,
					validateBoolean,
					validateBuffer: L,
					validateDictionary: P,
					validateEncoding,
					validateFunction: F,
					validateInt32: M,
					validateInteger: N,
					validateNumber,
					validateObject: x,
					validateOneOf: I,
					validatePlainFunction: B,
					validatePort,
					validateSignalName,
					validateString,
					validateUint32: W,
					validateUndefined: $,
					validateUnion,
					validateAbortSignal: C,
					validateLinkHeaderValue
				};
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/browser.js':
			(e, t, r) => {
				'use strict';
				const n = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/stream.js'
				);
				const a = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/stream/promises.js'
				);
				const o = n.Readable.destroy;
				e.exports = n.Readable;
				e.exports._uint8ArrayToBuffer = n._uint8ArrayToBuffer;
				e.exports._isUint8Array = n._isUint8Array;
				e.exports.isDisturbed = n.isDisturbed;
				e.exports.isErrored = n.isErrored;
				e.exports.isReadable = n.isReadable;
				e.exports.Readable = n.Readable;
				e.exports.Writable = n.Writable;
				e.exports.Duplex = n.Duplex;
				e.exports.Transform = n.Transform;
				e.exports.PassThrough = n.PassThrough;
				e.exports.addAbortSignal = n.addAbortSignal;
				e.exports.finished = n.finished;
				e.exports.destroy = n.destroy;
				e.exports.destroy = o;
				e.exports.pipeline = n.pipeline;
				e.exports.compose = n.compose;
				Object.defineProperty(n, 'promises', {
					configurable: true,
					enumerable: true,
					get() {
						return a;
					}
				});
				e.exports.Stream = n.Stream;
				e.exports['default'] = e.exports;
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/errors.js':
			(e, t, r) => {
				'use strict';
				const { format: n, inspect: a } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util/inspect.js'
				);
				const { AggregateError: o } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				);
				const s = globalThis.AggregateError || o;
				const i = Symbol('kIsNodeError');
				const l = [
					'string',
					'function',
					'number',
					'object',
					'Function',
					'Object',
					'boolean',
					'bigint',
					'symbol'
				];
				const d = /^([A-Z][a-z0-9]*)+$/;
				const u = '__node_internal_';
				const f = {};
				function assert(e, t) {
					if (!e) {
						throw new f.ERR_INTERNAL_ASSERTION(t);
					}
				}
				function addNumericalSeparator(e) {
					let t = '';
					let r = e.length;
					const n = e[0] === '-' ? 1 : 0;
					for (; r >= n + 4; r -= 3) {
						t = `_${e.slice(r - 3, r)}${t}`;
					}
					return `${e.slice(0, r)}${t}`;
				}
				function getMessage(e, t, r) {
					if (typeof t === 'function') {
						assert(
							t.length <= r.length,
							`Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${t.length}).`
						);
						return t(...r);
					}
					const a = (t.match(/%[dfijoOs]/g) || []).length;
					assert(
						a === r.length,
						`Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${a}).`
					);
					if (r.length === 0) {
						return t;
					}
					return n(t, ...r);
				}
				function E(e, t, r) {
					if (!r) {
						r = Error;
					}
					class NodeError extends r {
						constructor(...r) {
							super(getMessage(e, t, r));
						}
						toString() {
							return `${this.name} [${e}]: ${this.message}`;
						}
					}
					Object.defineProperties(NodeError.prototype, {
						name: { value: r.name, writable: true, enumerable: false, configurable: true },
						toString: {
							value() {
								return `${this.name} [${e}]: ${this.message}`;
							},
							writable: true,
							enumerable: false,
							configurable: true
						}
					});
					NodeError.prototype.code = e;
					NodeError.prototype[i] = true;
					f[e] = NodeError;
				}
				function hideStackFrames(e) {
					const t = u + e.name;
					Object.defineProperty(e, 'name', { value: t });
					return e;
				}
				function aggregateTwoErrors(e, t) {
					if (e && t && e !== t) {
						if (Array.isArray(t.errors)) {
							t.errors.push(e);
							return t;
						}
						const r = new s([t, e], t.message);
						r.code = t.code;
						return r;
					}
					return e || t;
				}
				class AbortError extends Error {
					constructor(e = 'The operation was aborted', t = undefined) {
						if (t !== undefined && typeof t !== 'object') {
							throw new f.ERR_INVALID_ARG_TYPE('options', 'Object', t);
						}
						super(e, t);
						this.code = 'ABORT_ERR';
						this.name = 'AbortError';
					}
				}
				E('ERR_ASSERTION', '%s', Error);
				E(
					'ERR_INVALID_ARG_TYPE',
					(e, t, r) => {
						assert(typeof e === 'string', "'name' must be a string");
						if (!Array.isArray(t)) {
							t = [t];
						}
						let n = 'The ';
						if (e.endsWith(' argument')) {
							n += `${e} `;
						} else {
							n += `"${e}" ${e.includes('.') ? 'property' : 'argument'} `;
						}
						n += 'must be ';
						const o = [];
						const s = [];
						const i = [];
						for (const e of t) {
							assert(typeof e === 'string', 'All expected entries have to be of type string');
							if (l.includes(e)) {
								o.push(e.toLowerCase());
							} else if (d.test(e)) {
								s.push(e);
							} else {
								assert(e !== 'object', 'The value "object" should be written as "Object"');
								i.push(e);
							}
						}
						if (s.length > 0) {
							const e = o.indexOf('object');
							if (e !== -1) {
								o.splice(o, e, 1);
								s.push('Object');
							}
						}
						if (o.length > 0) {
							switch (o.length) {
								case 1:
									n += `of type ${o[0]}`;
									break;
								case 2:
									n += `one of type ${o[0]} or ${o[1]}`;
									break;
								default: {
									const e = o.pop();
									n += `one of type ${o.join(', ')}, or ${e}`;
								}
							}
							if (s.length > 0 || i.length > 0) {
								n += ' or ';
							}
						}
						if (s.length > 0) {
							switch (s.length) {
								case 1:
									n += `an instance of ${s[0]}`;
									break;
								case 2:
									n += `an instance of ${s[0]} or ${s[1]}`;
									break;
								default: {
									const e = s.pop();
									n += `an instance of ${s.join(', ')}, or ${e}`;
								}
							}
							if (i.length > 0) {
								n += ' or ';
							}
						}
						switch (i.length) {
							case 0:
								break;
							case 1:
								if (i[0].toLowerCase() !== i[0]) {
									n += 'an ';
								}
								n += `${i[0]}`;
								break;
							case 2:
								n += `one of ${i[0]} or ${i[1]}`;
								break;
							default: {
								const e = i.pop();
								n += `one of ${i.join(', ')}, or ${e}`;
							}
						}
						if (r == null) {
							n += `. Received ${r}`;
						} else if (typeof r === 'function' && r.name) {
							n += `. Received function ${r.name}`;
						} else if (typeof r === 'object') {
							var u;
							if ((u = r.constructor) !== null && u !== undefined && u.name) {
								n += `. Received an instance of ${r.constructor.name}`;
							} else {
								const e = a(r, { depth: -1 });
								n += `. Received ${e}`;
							}
						} else {
							let e = a(r, { colors: false });
							if (e.length > 25) {
								e = `${e.slice(0, 25)}...`;
							}
							n += `. Received type ${typeof r} (${e})`;
						}
						return n;
					},
					TypeError
				);
				E(
					'ERR_INVALID_ARG_VALUE',
					(e, t, r = 'is invalid') => {
						let n = a(t);
						if (n.length > 128) {
							n = n.slice(0, 128) + '...';
						}
						const o = e.includes('.') ? 'property' : 'argument';
						return `The ${o} '${e}' ${r}. Received ${n}`;
					},
					TypeError
				);
				E(
					'ERR_INVALID_RETURN_VALUE',
					(e, t, r) => {
						var n;
						const a =
							r !== null &&
							r !== undefined &&
							(n = r.constructor) !== null &&
							n !== undefined &&
							n.name
								? `instance of ${r.constructor.name}`
								: `type ${typeof r}`;
						return `Expected ${e} to be returned from the "${t}"` + ` function but got ${a}.`;
					},
					TypeError
				);
				E(
					'ERR_MISSING_ARGS',
					(...e) => {
						assert(e.length > 0, 'At least one arg needs to be specified');
						let t;
						const r = e.length;
						e = (Array.isArray(e) ? e : [e]).map((e) => `"${e}"`).join(' or ');
						switch (r) {
							case 1:
								t += `The ${e[0]} argument`;
								break;
							case 2:
								t += `The ${e[0]} and ${e[1]} arguments`;
								break;
							default:
								{
									const r = e.pop();
									t += `The ${e.join(', ')}, and ${r} arguments`;
								}
								break;
						}
						return `${t} must be specified`;
					},
					TypeError
				);
				E(
					'ERR_OUT_OF_RANGE',
					(e, t, r) => {
						assert(t, 'Missing "range" argument');
						let n;
						if (Number.isInteger(r) && Math.abs(r) > 2 ** 32) {
							n = addNumericalSeparator(String(r));
						} else if (typeof r === 'bigint') {
							n = String(r);
							const e = BigInt(2) ** BigInt(32);
							if (r > e || r < -e) {
								n = addNumericalSeparator(n);
							}
							n += 'n';
						} else {
							n = a(r);
						}
						return `The value of "${e}" is out of range. It must be ${t}. Received ${n}`;
					},
					RangeError
				);
				E('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times', Error);
				E('ERR_METHOD_NOT_IMPLEMENTED', 'The %s method is not implemented', Error);
				E('ERR_STREAM_ALREADY_FINISHED', 'Cannot call %s after a stream was finished', Error);
				E('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable', Error);
				E('ERR_STREAM_DESTROYED', 'Cannot call %s after a stream was destroyed', Error);
				E('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
				E('ERR_STREAM_PREMATURE_CLOSE', 'Premature close', Error);
				E('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF', Error);
				E('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event', Error);
				E('ERR_STREAM_WRITE_AFTER_END', 'write after end', Error);
				E('ERR_UNKNOWN_ENCODING', 'Unknown encoding: %s', TypeError);
				e.exports = {
					AbortError,
					aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
					hideStackFrames,
					codes: f
				};
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js':
			(e) => {
				'use strict';
				class AggregateError extends Error {
					constructor(e) {
						if (!Array.isArray(e)) {
							throw new TypeError(`Expected input to be an Array, got ${typeof e}`);
						}
						let t = '';
						for (let r = 0; r < e.length; r++) {
							t += `    ${e[r].stack}\n`;
						}
						super(t);
						this.name = 'AggregateError';
						this.errors = e;
					}
				}
				e.exports = {
					AggregateError,
					ArrayIsArray(e) {
						return Array.isArray(e);
					},
					ArrayPrototypeIncludes(e, t) {
						return e.includes(t);
					},
					ArrayPrototypeIndexOf(e, t) {
						return e.indexOf(t);
					},
					ArrayPrototypeJoin(e, t) {
						return e.join(t);
					},
					ArrayPrototypeMap(e, t) {
						return e.map(t);
					},
					ArrayPrototypePop(e, t) {
						return e.pop(t);
					},
					ArrayPrototypePush(e, t) {
						return e.push(t);
					},
					ArrayPrototypeSlice(e, t, r) {
						return e.slice(t, r);
					},
					Error,
					FunctionPrototypeCall(e, t, ...r) {
						return e.call(t, ...r);
					},
					FunctionPrototypeSymbolHasInstance(e, t) {
						return Function.prototype[Symbol.hasInstance].call(e, t);
					},
					MathFloor: Math.floor,
					Number,
					NumberIsInteger: Number.isInteger,
					NumberIsNaN: Number.isNaN,
					NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
					NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
					NumberParseInt: Number.parseInt,
					ObjectDefineProperties(e, t) {
						return Object.defineProperties(e, t);
					},
					ObjectDefineProperty(e, t, r) {
						return Object.defineProperty(e, t, r);
					},
					ObjectGetOwnPropertyDescriptor(e, t) {
						return Object.getOwnPropertyDescriptor(e, t);
					},
					ObjectKeys(e) {
						return Object.keys(e);
					},
					ObjectSetPrototypeOf(e, t) {
						return Object.setPrototypeOf(e, t);
					},
					Promise,
					PromisePrototypeCatch(e, t) {
						return e.catch(t);
					},
					PromisePrototypeThen(e, t, r) {
						return e.then(t, r);
					},
					PromiseReject(e) {
						return Promise.reject(e);
					},
					PromiseResolve(e) {
						return Promise.resolve(e);
					},
					ReflectApply: Reflect.apply,
					RegExpPrototypeTest(e, t) {
						return e.test(t);
					},
					SafeSet: Set,
					String,
					StringPrototypeSlice(e, t, r) {
						return e.slice(t, r);
					},
					StringPrototypeToLowerCase(e) {
						return e.toLowerCase();
					},
					StringPrototypeToUpperCase(e) {
						return e.toUpperCase();
					},
					StringPrototypeTrim(e) {
						return e.trim();
					},
					Symbol,
					SymbolFor: Symbol.for,
					SymbolAsyncIterator: Symbol.asyncIterator,
					SymbolHasInstance: Symbol.hasInstance,
					SymbolIterator: Symbol.iterator,
					SymbolDispose: Symbol.dispose || Symbol('Symbol.dispose'),
					SymbolAsyncDispose: Symbol.asyncDispose || Symbol('Symbol.asyncDispose'),
					TypedArrayPrototypeSet(e, t, r) {
						return e.set(t, r);
					},
					Boolean,
					Uint8Array
				};
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util.js':
			(e, t, r) => {
				'use strict';
				const n = r('../../node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js');
				const { format: a, inspect: o } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util/inspect.js'
				);
				const {
					codes: { ERR_INVALID_ARG_TYPE: s }
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/errors.js'
				);
				const {
					kResistStopPropagation: i,
					AggregateError: l,
					SymbolDispose: d
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				);
				const u =
					globalThis.AbortSignal ||
					r(
						'../../node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller/browser.js'
					).AbortSignal;
				const f =
					globalThis.AbortController ||
					r(
						'../../node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller/browser.js'
					).AbortController;
				const c = Object.getPrototypeOf(async function () {}).constructor;
				const b = globalThis.Blob || n.Blob;
				const m =
					typeof b !== 'undefined'
						? function isBlob(e) {
								return e instanceof b;
							}
						: function isBlob(e) {
								return false;
							};
				const validateAbortSignal = (e, t) => {
					if (e !== undefined && (e === null || typeof e !== 'object' || !('aborted' in e))) {
						throw new s(t, 'AbortSignal', e);
					}
				};
				const validateFunction = (e, t) => {
					if (typeof e !== 'function') {
						throw new s(t, 'Function', e);
					}
				};
				e.exports = {
					AggregateError: l,
					kEmptyObject: Object.freeze({}),
					once(e) {
						let t = false;
						return function (...r) {
							if (t) {
								return;
							}
							t = true;
							e.apply(this, r);
						};
					},
					createDeferredPromise: function () {
						let e;
						let t;
						const r = new Promise((r, n) => {
							e = r;
							t = n;
						});
						return { promise: r, resolve: e, reject: t };
					},
					promisify(e) {
						return new Promise((t, r) => {
							e((e, ...n) => {
								if (e) {
									return r(e);
								}
								return t(...n);
							});
						});
					},
					debuglog() {
						return function () {};
					},
					format: a,
					inspect: o,
					types: {
						isAsyncFunction(e) {
							return e instanceof c;
						},
						isArrayBufferView(e) {
							return ArrayBuffer.isView(e);
						}
					},
					isBlob: m,
					deprecate(e, t) {
						return e;
					},
					addAbortListener:
						r('../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js')
							.addAbortListener ||
						function addAbortListener(e, t) {
							if (e === undefined) {
								throw new s('signal', 'AbortSignal', e);
							}
							validateAbortSignal(e, 'signal');
							validateFunction(t, 'listener');
							let r;
							if (e.aborted) {
								queueMicrotask(() => t());
							} else {
								e.addEventListener('abort', t, { __proto__: null, once: true, [i]: true });
								r = () => {
									e.removeEventListener('abort', t);
								};
							}
							return {
								__proto__: null,
								[d]() {
									var e;
									(e = r) === null || e === undefined ? undefined : e();
								}
							};
						},
					AbortSignalAny:
						u.any ||
						function AbortSignalAny(e) {
							if (e.length === 1) {
								return e[0];
							}
							const t = new f();
							const abort = () => t.abort();
							e.forEach((e) => {
								validateAbortSignal(e, 'signals');
								e.addEventListener('abort', abort, { once: true });
							});
							t.signal.addEventListener(
								'abort',
								() => {
									e.forEach((e) => e.removeEventListener('abort', abort));
								},
								{ once: true }
							);
							return t.signal;
						}
				};
				e.exports.promisify.custom = Symbol.for('nodejs.util.promisify.custom');
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util/inspect.js':
			(e) => {
				'use strict';
				e.exports = {
					format(e, ...t) {
						return e.replace(/%([sdifj])/g, function (...[e, r]) {
							const n = t.shift();
							if (r === 'f') {
								return n.toFixed(6);
							} else if (r === 'j') {
								return JSON.stringify(n);
							} else if (r === 's' && typeof n === 'object') {
								const e = n.constructor !== Object ? n.constructor.name : '';
								return `${e} {}`.trim();
							} else {
								return n.toString();
							}
						});
					},
					inspect(e) {
						switch (typeof e) {
							case 'string':
								if (e.includes("'")) {
									if (!e.includes('"')) {
										return `"${e}"`;
									} else if (!e.includes('`') && !e.includes('${')) {
										return `\`${e}\``;
									}
								}
								return `'${e}'`;
							case 'number':
								if (isNaN(e)) {
									return 'NaN';
								} else if (Object.is(e, -0)) {
									return String(e);
								}
								return e;
							case 'bigint':
								return `${String(e)}n`;
							case 'boolean':
							case 'undefined':
								return String(e);
							case 'object':
								return '{}';
						}
					}
				};
			},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/stream.js': (
			e,
			t,
			r
		) => {
			'use strict';
			const { Buffer: n } = r('../../node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js');
			const {
				ObjectDefineProperty: a,
				ObjectKeys: o,
				ReflectApply: s
			} = r(
				'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
			);
			const {
				promisify: { custom: i }
			} = r(
				'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util.js'
			);
			const { streamReturningOperators: l, promiseReturningOperators: d } = r(
				'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/operators.js'
			);
			const {
				codes: { ERR_ILLEGAL_CONSTRUCTOR: u }
			} = r(
				'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/errors.js'
			);
			const f = r(
				'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/compose.js'
			);
			const { setDefaultHighWaterMark: c, getDefaultHighWaterMark: b } = r(
				'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/state.js'
			);
			const { pipeline: m } = r(
				'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/pipeline.js'
			);
			const { destroyer: p } = r(
				'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/destroy.js'
			);
			const h = r(
				'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/end-of-stream.js'
			);
			const _ = {};
			const y = r(
				'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/stream/promises.js'
			);
			const g = r(
				'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/utils.js'
			);
			const w = (e.exports = r(
				'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/legacy.js'
			).Stream);
			w.isDestroyed = g.isDestroyed;
			w.isDisturbed = g.isDisturbed;
			w.isErrored = g.isErrored;
			w.isReadable = g.isReadable;
			w.isWritable = g.isWritable;
			w.Readable = r(
				'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/readable.js'
			);
			for (const R of o(l)) {
				const A = l[R];
				function fn(...e) {
					if (new.target) {
						throw u();
					}
					return w.Readable.from(s(A, this, e));
				}
				a(fn, 'name', { __proto__: null, value: A.name });
				a(fn, 'length', { __proto__: null, value: A.length });
				a(w.Readable.prototype, R, {
					__proto__: null,
					value: fn,
					enumerable: false,
					configurable: true,
					writable: true
				});
			}
			for (const j of o(d)) {
				const T = d[j];
				function fn(...e) {
					if (new.target) {
						throw u();
					}
					return s(T, this, e);
				}
				a(fn, 'name', { __proto__: null, value: T.name });
				a(fn, 'length', { __proto__: null, value: T.length });
				a(w.Readable.prototype, j, {
					__proto__: null,
					value: fn,
					enumerable: false,
					configurable: true,
					writable: true
				});
			}
			w.Writable = r(
				'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/writable.js'
			);
			w.Duplex = r(
				'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/duplex.js'
			);
			w.Transform = r(
				'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/transform.js'
			);
			w.PassThrough = r(
				'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/passthrough.js'
			);
			w.pipeline = m;
			const { addAbortSignal: S } = r(
				'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js'
			);
			w.addAbortSignal = S;
			w.finished = h;
			w.destroy = p;
			w.compose = f;
			w.setDefaultHighWaterMark = c;
			w.getDefaultHighWaterMark = b;
			a(w, 'promises', {
				__proto__: null,
				configurable: true,
				enumerable: true,
				get() {
					return y;
				}
			});
			a(m, i, {
				__proto__: null,
				enumerable: true,
				get() {
					return y.pipeline;
				}
			});
			a(h, i, {
				__proto__: null,
				enumerable: true,
				get() {
					return y.finished;
				}
			});
			w.Stream = w;
			w._isUint8Array = function isUint8Array(e) {
				return e instanceof Uint8Array;
			};
			w._uint8ArrayToBuffer = function _uint8ArrayToBuffer(e) {
				return n.from(e.buffer, e.byteOffset, e.byteLength);
			};
		},
		'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/stream/promises.js':
			(e, t, r) => {
				'use strict';
				const { ArrayPrototypePop: n, Promise: a } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js'
				);
				const {
					isIterable: o,
					isNodeStream: s,
					isWebStream: i
				} = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/utils.js'
				);
				const { pipelineImpl: l } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/pipeline.js'
				);
				const { finished: d } = r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/end-of-stream.js'
				);
				r(
					'../../node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/stream.js'
				);
				function pipeline(...e) {
					return new a((t, r) => {
						let a;
						let d;
						const u = e[e.length - 1];
						if (u && typeof u === 'object' && !s(u) && !o(u) && !i(u)) {
							const t = n(e);
							a = t.signal;
							d = t.end;
						}
						l(
							e,
							(e, n) => {
								if (e) {
									r(e);
								} else {
									t(n);
								}
							},
							{ signal: a, end: d }
						);
					});
				}
				e.exports = { finished: d, pipeline };
			}
	}
]);
