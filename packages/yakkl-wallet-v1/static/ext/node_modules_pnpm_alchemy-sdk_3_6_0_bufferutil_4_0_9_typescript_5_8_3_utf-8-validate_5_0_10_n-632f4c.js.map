{"version":3,"file":"node_modules_pnpm_alchemy-sdk_3_6_0_bufferutil_4_0_9_typescript_5_8_3_utf-8-validate_5_0_10_n-632f4c.js","mappings":"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","sources":["webpack://yakkl-wallet/../../node_modules/.pnpm/@ethersproject+base64@5.7.0/node_modules/@ethersproject/base64/lib.esm/base64.js","webpack://yakkl-wallet/../../node_modules/.pnpm/@ethersproject+basex@5.7.0/node_modules/@ethersproject/basex/lib.esm/index.js","webpack://yakkl-wallet/../../node_modules/.pnpm/@ethersproject+constants@5.7.0/node_modules/@ethersproject/constants/lib.esm/addresses.js","webpack://yakkl-wallet/../../node_modules/.pnpm/@ethersproject+constants@5.7.0/node_modules/@ethersproject/constants/lib.esm/hashes.js","webpack://yakkl-wallet/../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js","webpack://yakkl-wallet/../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js","webpack://yakkl-wallet/../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js","webpack://yakkl-wallet/../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/namehash.js","webpack://yakkl-wallet/../../node_modules/.pnpm/@ethersproject+networks@5.7.1/node_modules/@ethersproject/networks/lib.esm/_version.js","webpack://yakkl-wallet/../../node_modules/.pnpm/@ethersproject+networks@5.7.1/node_modules/@ethersproject/networks/lib.esm/index.js","webpack://yakkl-wallet/../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/_version.js","webpack://yakkl-wallet/../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/base-provider.js","webpack://yakkl-wallet/../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/formatter.js","webpack://yakkl-wallet/../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js","webpack://yakkl-wallet/../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js","webpack://yakkl-wallet/../../node_modules/.pnpm/@ethersproject+providers@5.7.2_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@ethersproject/providers/lib.esm/ws.js","webpack://yakkl-wallet/../../node_modules/.pnpm/@ethersproject+sha2@5.7.0/node_modules/@ethersproject/sha2/lib.esm/_version.js","webpack://yakkl-wallet/../../node_modules/.pnpm/@ethersproject+sha2@5.7.0/node_modules/@ethersproject/sha2/lib.esm/sha2.js","webpack://yakkl-wallet/../../node_modules/.pnpm/@ethersproject+sha2@5.7.0/node_modules/@ethersproject/sha2/lib.esm/types.js","webpack://yakkl-wallet/../../node_modules/.pnpm/alchemy-sdk@3.6.0_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10/node_modules/alchemy-sdk/dist/esm/alchemy-provider-0066b792.js","webpack://yakkl-wallet/../../node_modules/.pnpm/alchemy-sdk@3.6.0_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10/node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-98da5bb0.js","webpack://yakkl-wallet/../../node_modules/.pnpm/bech32@1.1.4/node_modules/bech32/index.js","webpack://yakkl-wallet/../../node_modules/.pnpm/es5-ext@0.10.64/node_modules/es5-ext/global.js","webpack://yakkl-wallet/../../node_modules/.pnpm/sturdy-websocket@0.2.1/node_modules/sturdy-websocket/dist/index.js","webpack://yakkl-wallet/../../node_modules/.pnpm/websocket@1.0.35/node_modules/websocket/lib/browser.js","webpack://yakkl-wallet/../../node_modules/.pnpm/websocket@1.0.35/node_modules/websocket/lib/version.js"],"sourcesContent":["\"use strict\";\nimport { arrayify } from \"@ethersproject/bytes\";\nexport function decode(textData) {\n    textData = atob(textData);\n    const data = [];\n    for (let i = 0; i < textData.length; i++) {\n        data.push(textData.charCodeAt(i));\n    }\n    return arrayify(data);\n}\nexport function encode(data) {\n    data = arrayify(data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n//# sourceMappingURL=base64.js.map","/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\nimport { arrayify } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nexport class BaseX {\n    constructor(alphabet) {\n        defineReadOnly(this, \"alphabet\", alphabet);\n        defineReadOnly(this, \"base\", alphabet.length);\n        defineReadOnly(this, \"_alphabetMap\", {});\n        defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n    encode(value) {\n        let source = arrayify(value);\n        if (source.length === 0) {\n            return \"\";\n        }\n        let digits = [0];\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n        let string = \"\";\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n        return string;\n    }\n    decode(value) {\n        if (typeof (value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        let bytes = [];\n        if (value.length === 0) {\n            return new Uint8Array(bytes);\n        }\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0);\n        }\n        return arrayify(new Uint8Array(bytes.reverse()));\n    }\n}\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\nexport { Base32, Base58 };\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n//# sourceMappingURL=index.js.map","export const AddressZero = \"0x0000000000000000000000000000000000000000\";\n//# sourceMappingURL=addresses.js.map","export const HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n//# sourceMappingURL=hashes.js.map","/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n// https://github.com/behnammodi/polyfill/blob/master/array.polyfill.js\nfunction flat(array, depth) {\n    if (depth == null) {\n        depth = 1;\n    }\n    const result = [];\n    const forEach = result.forEach;\n    const flatDeep = function (arr, depth) {\n        forEach.call(arr, function (val) {\n            if (depth > 0 && Array.isArray(val)) {\n                flatDeep(val, depth - 1);\n            }\n            else {\n                result.push(val);\n            }\n        });\n    };\n    flatDeep(array, depth);\n    return result;\n}\nfunction fromEntries(array) {\n    const result = {};\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i];\n        result[value[0]] = value[1];\n    }\n    return result;\n}\nexport function decode_arithmetic(bytes) {\n    let pos = 0;\n    function u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\n    // decode the frequency table\n    let symbol_count = u16();\n    let total = 1;\n    let acc = [0, 1]; // first symbol has frequency 1\n    for (let i = 1; i < symbol_count; i++) {\n        acc.push(total += u16());\n    }\n    // skip the sized-payload that the last 3 symbols index into\n    let skip = u16();\n    let pos_payload = pos;\n    pos += skip;\n    let read_width = 0;\n    let read_buffer = 0;\n    function read_bit() {\n        if (read_width == 0) {\n            // this will read beyond end of buffer\n            // but (undefined|0) => zero pad\n            read_buffer = (read_buffer << 8) | bytes[pos++];\n            read_width = 8;\n        }\n        return (read_buffer >> --read_width) & 1;\n    }\n    const N = 31;\n    const FULL = Math.pow(2, N);\n    const HALF = FULL >>> 1;\n    const QRTR = HALF >> 1;\n    const MASK = FULL - 1;\n    // fill register\n    let register = 0;\n    for (let i = 0; i < N; i++)\n        register = (register << 1) | read_bit();\n    let symbols = [];\n    let low = 0;\n    let range = FULL; // treat like a float\n    while (true) {\n        let value = Math.floor((((register - low + 1) * total) - 1) / range);\n        let start = 0;\n        let end = symbol_count;\n        while (end - start > 1) { // binary search\n            let mid = (start + end) >>> 1;\n            if (value < acc[mid]) {\n                end = mid;\n            }\n            else {\n                start = mid;\n            }\n        }\n        if (start == 0)\n            break; // first symbol is end mark\n        symbols.push(start);\n        let a = low + Math.floor(range * acc[start] / total);\n        let b = low + Math.floor(range * acc[start + 1] / total) - 1;\n        while (((a ^ b) & HALF) == 0) {\n            register = (register << 1) & MASK | read_bit();\n            a = (a << 1) & MASK;\n            b = (b << 1) & MASK | 1;\n        }\n        while (a & ~b & QRTR) {\n            register = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\n            a = (a << 1) ^ HALF;\n            b = ((b ^ HALF) << 1) | HALF | 1;\n        }\n        low = a;\n        range = 1 + b - a;\n    }\n    let offset = symbol_count - 4;\n    return symbols.map(x => {\n        switch (x - offset) {\n            case 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\n            case 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\n            case 1: return offset + bytes[pos_payload++];\n            default: return x - 1;\n        }\n    });\n}\n// returns an iterator which returns the next symbol\nexport function read_payload(v) {\n    let pos = 0;\n    return () => v[pos++];\n}\nexport function read_compressed_payload(bytes) {\n    return read_payload(decode_arithmetic(bytes));\n}\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nexport function signed(i) {\n    return (i & 1) ? (~i >> 1) : (i >> 1);\n}\nfunction read_counts(n, next) {\n    let v = Array(n);\n    for (let i = 0; i < n; i++)\n        v[i] = 1 + next();\n    return v;\n}\nfunction read_ascending(n, next) {\n    let v = Array(n);\n    for (let i = 0, x = -1; i < n; i++)\n        v[i] = x += 1 + next();\n    return v;\n}\nfunction read_deltas(n, next) {\n    let v = Array(n);\n    for (let i = 0, x = 0; i < n; i++)\n        v[i] = x += signed(next());\n    return v;\n}\nexport function read_member_array(next, lookup) {\n    let v = read_ascending(next(), next);\n    let n = next();\n    let vX = read_ascending(n, next);\n    let vN = read_counts(n, next);\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < vN[i]; j++) {\n            v.push(vX[i] + j);\n        }\n    }\n    return lookup ? v.map(x => lookup[x]) : v;\n}\n// returns array of \n// [x, ys] => single replacement rule\n// [x, ys, n, dx, dx] => linear map\nexport function read_mapped_map(next) {\n    let ret = [];\n    while (true) {\n        let w = next();\n        if (w == 0)\n            break;\n        ret.push(read_linear_table(w, next));\n    }\n    while (true) {\n        let w = next() - 1;\n        if (w < 0)\n            break;\n        ret.push(read_replacement_table(w, next));\n    }\n    return fromEntries(flat(ret));\n}\nexport function read_zero_terminated_array(next) {\n    let v = [];\n    while (true) {\n        let i = next();\n        if (i == 0)\n            break;\n        v.push(i);\n    }\n    return v;\n}\nfunction read_transposed(n, w, next) {\n    let m = Array(n).fill(undefined).map(() => []);\n    for (let i = 0; i < w; i++) {\n        read_deltas(n, next).forEach((x, j) => m[j].push(x));\n    }\n    return m;\n}\nfunction read_linear_table(w, next) {\n    let dx = 1 + next();\n    let dy = next();\n    let vN = read_zero_terminated_array(next);\n    let m = read_transposed(vN.length, 1 + w, next);\n    return flat(m.map((v, i) => {\n        const x = v[0], ys = v.slice(1);\n        //let [x, ...ys] = v;\n        //return Array(vN[i]).fill().map((_, j) => {\n        return Array(vN[i]).fill(undefined).map((_, j) => {\n            let j_dy = j * dy;\n            return [x + j * dx, ys.map(y => y + j_dy)];\n        });\n    }));\n}\nfunction read_replacement_table(w, next) {\n    let n = 1 + next();\n    let m = read_transposed(n, 1 + w, next);\n    return m.map(v => [v[0], v.slice(1)]);\n}\nexport function read_emoji_trie(next) {\n    let sorted = read_member_array(next).sort((a, b) => a - b);\n    return read();\n    function read() {\n        let branches = [];\n        while (true) {\n            let keys = read_member_array(next, sorted);\n            if (keys.length == 0)\n                break;\n            branches.push({ set: new Set(keys), node: read() });\n        }\n        branches.sort((a, b) => b.set.size - a.set.size); // sort by likelihood\n        let temp = next();\n        let valid = temp % 3;\n        temp = (temp / 3) | 0;\n        let fe0f = !!(temp & 1);\n        temp >>= 1;\n        let save = temp == 1;\n        let check = temp == 2;\n        return { branches, valid, fe0f, save, check };\n    }\n}\n//# sourceMappingURL=decoder.js.map","/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\nimport { decode } from \"@ethersproject/base64\";\nimport { read_compressed_payload } from './decoder.js';\nexport function getData() {\n    return read_compressed_payload(decode('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'));\n}\n//# sourceMappingURL=include.js.map","/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\nimport { toUtf8CodePoints } from \"@ethersproject/strings\";\nimport { getData } from './include.js';\nconst r = getData();\nimport { read_member_array, read_mapped_map, read_emoji_trie } from './decoder.js';\n// @TODO: This should be lazily loaded\nconst VALID = new Set(read_member_array(r));\nconst IGNORED = new Set(read_member_array(r));\nconst MAPPED = read_mapped_map(r);\nconst EMOJI_ROOT = read_emoji_trie(r);\n//const NFC_CHECK = new Set(read_member_array(r, Array.from(VALID.values()).sort((a, b) => a - b)));\n//const STOP = 0x2E;\nconst HYPHEN = 0x2D;\nconst UNDERSCORE = 0x5F;\nfunction explode_cp(name) {\n    return toUtf8CodePoints(name);\n}\nfunction filter_fe0f(cps) {\n    return cps.filter(cp => cp != 0xFE0F);\n}\nexport function ens_normalize_post_check(name) {\n    for (let label of name.split('.')) {\n        let cps = explode_cp(label);\n        try {\n            for (let i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) {\n                if (cps[i] !== UNDERSCORE) {\n                    throw new Error(`underscore only allowed at start`);\n                }\n            }\n            if (cps.length >= 4 && cps.every(cp => cp < 0x80) && cps[2] === HYPHEN && cps[3] === HYPHEN) {\n                throw new Error(`invalid label extension`);\n            }\n        }\n        catch (err) {\n            throw new Error(`Invalid label \"${label}\": ${err.message}`);\n        }\n    }\n    return name;\n}\nexport function ens_normalize(name) {\n    return ens_normalize_post_check(normalize(name, filter_fe0f));\n}\nfunction normalize(name, emoji_filter) {\n    let input = explode_cp(name).reverse(); // flip for pop\n    let output = [];\n    while (input.length) {\n        let emoji = consume_emoji_reversed(input);\n        if (emoji) {\n            output.push(...emoji_filter(emoji));\n            continue;\n        }\n        let cp = input.pop();\n        if (VALID.has(cp)) {\n            output.push(cp);\n            continue;\n        }\n        if (IGNORED.has(cp)) {\n            continue;\n        }\n        let cps = MAPPED[cp];\n        if (cps) {\n            output.push(...cps);\n            continue;\n        }\n        throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);\n    }\n    return ens_normalize_post_check(nfc(String.fromCodePoint(...output)));\n}\nfunction nfc(s) {\n    return s.normalize('NFC');\n}\nfunction consume_emoji_reversed(cps, eaten) {\n    var _a;\n    let node = EMOJI_ROOT;\n    let emoji;\n    let saved;\n    let stack = [];\n    let pos = cps.length;\n    if (eaten)\n        eaten.length = 0; // clear input buffer (if needed)\n    while (pos) {\n        let cp = cps[--pos];\n        node = (_a = node.branches.find(x => x.set.has(cp))) === null || _a === void 0 ? void 0 : _a.node;\n        if (!node)\n            break;\n        if (node.save) { // remember\n            saved = cp;\n        }\n        else if (node.check) { // check exclusion\n            if (cp === saved)\n                break;\n        }\n        stack.push(cp);\n        if (node.fe0f) {\n            stack.push(0xFE0F);\n            if (pos > 0 && cps[pos - 1] == 0xFE0F)\n                pos--; // consume optional FE0F\n        }\n        if (node.valid) { // this is a valid emoji (so far)\n            emoji = stack.slice(); // copy stack\n            if (node.valid == 2)\n                emoji.splice(1, 1); // delete FE0F at position 1 (RGI ZWJ don't follow spec!)\n            if (eaten)\n                eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)\n            cps.length = pos; // truncate\n        }\n    }\n    return emoji;\n}\n//# sourceMappingURL=lib.js.map","import { concat, hexlify } from \"@ethersproject/bytes\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { ens_normalize } from \"./ens-normalize/lib\";\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n    if (comp.length === 0) {\n        throw new Error(\"invalid ENS name; empty component\");\n    }\n    return comp;\n}\nfunction ensNameSplit(name) {\n    const bytes = toUtf8Bytes(ens_normalize(name));\n    const comps = [];\n    if (name.length === 0) {\n        return comps;\n    }\n    let last = 0;\n    for (let i = 0; i < bytes.length; i++) {\n        const d = bytes[i];\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n    // There was a stray separator at the end of the name\n    if (last >= bytes.length) {\n        throw new Error(\"invalid ENS name; empty component\");\n    }\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\nexport function ensNormalize(name) {\n    return ensNameSplit(name).map((comp) => toUtf8String(comp)).join(\".\");\n}\nexport function isValidName(name) {\n    try {\n        return (ensNameSplit(name).length !== 0);\n    }\n    catch (error) { }\n    return false;\n}\nexport function namehash(name) {\n    /* istanbul ignore if */\n    if (typeof (name) !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n    let result = Zeros;\n    const comps = ensNameSplit(name);\n    while (comps.length) {\n        result = keccak256(concat([result, keccak256(comps.pop())]));\n    }\n    return hexlify(result);\n}\nexport function dnsEncode(name) {\n    return hexlify(concat(ensNameSplit(name).map((comp) => {\n        // DNS does not allow components over 63 bytes in length\n        if (comp.length > 63) {\n            throw new Error(\"invalid DNS encoded entry; length exceeds 63 bytes\");\n        }\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n}\n//# sourceMappingURL=namehash.js.map","export const version = \"networks/5.7.1\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n;\nfunction isRenetworkable(value) {\n    return (value && typeof (value.renetwork) === \"function\");\n}\nfunction ethDefaultProvider(network) {\n    const func = function (providers, options) {\n        if (options == null) {\n            options = {};\n        }\n        const providerList = [];\n        if (providers.InfuraProvider && options.infura !== \"-\") {\n            try {\n                providerList.push(new providers.InfuraProvider(network, options.infura));\n            }\n            catch (error) { }\n        }\n        if (providers.EtherscanProvider && options.etherscan !== \"-\") {\n            try {\n                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n            }\n            catch (error) { }\n        }\n        if (providers.AlchemyProvider && options.alchemy !== \"-\") {\n            try {\n                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n            }\n            catch (error) { }\n        }\n        if (providers.PocketProvider && options.pocket !== \"-\") {\n            // These networks are currently faulty on Pocket as their\n            // network does not handle the Berlin hardfork, which is\n            // live on these ones.\n            // @TODO: This goes away once Pocket has upgraded their nodes\n            const skip = [\"goerli\", \"ropsten\", \"rinkeby\", \"sepolia\"];\n            try {\n                const provider = new providers.PocketProvider(network, options.pocket);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            }\n            catch (error) { }\n        }\n        if (providers.CloudflareProvider && options.cloudflare !== \"-\") {\n            try {\n                providerList.push(new providers.CloudflareProvider(network));\n            }\n            catch (error) { }\n        }\n        if (providers.AnkrProvider && options.ankr !== \"-\") {\n            try {\n                const skip = [\"ropsten\"];\n                const provider = new providers.AnkrProvider(network, options.ankr);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            }\n            catch (error) { }\n        }\n        if (providerList.length === 0) {\n            return null;\n        }\n        if (providers.FallbackProvider) {\n            let quorum = 1;\n            if (options.quorum != null) {\n                quorum = options.quorum;\n            }\n            else if (network === \"homestead\") {\n                quorum = 2;\n            }\n            return new providers.FallbackProvider(providerList, quorum);\n        }\n        return providerList[0];\n    };\n    func.renetwork = function (network) {\n        return ethDefaultProvider(network);\n    };\n    return func;\n}\nfunction etcDefaultProvider(url, network) {\n    const func = function (providers, options) {\n        if (providers.JsonRpcProvider) {\n            return new providers.JsonRpcProvider(url, network);\n        }\n        return null;\n    };\n    func.renetwork = function (network) {\n        return etcDefaultProvider(url, network);\n    };\n    return func;\n}\nconst homestead = {\n    chainId: 1,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"homestead\",\n    _defaultProvider: ethDefaultProvider(\"homestead\")\n};\nconst ropsten = {\n    chainId: 3,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"ropsten\",\n    _defaultProvider: ethDefaultProvider(\"ropsten\")\n};\nconst classicMordor = {\n    chainId: 63,\n    name: \"classicMordor\",\n    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n};\n// See: https://chainlist.org\nconst networks = {\n    unspecified: { chainId: 0, name: \"unspecified\" },\n    homestead: homestead,\n    mainnet: homestead,\n    morden: { chainId: 2, name: \"morden\" },\n    ropsten: ropsten,\n    testnet: ropsten,\n    rinkeby: {\n        chainId: 4,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"rinkeby\",\n        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n    },\n    kovan: {\n        chainId: 42,\n        name: \"kovan\",\n        _defaultProvider: ethDefaultProvider(\"kovan\")\n    },\n    goerli: {\n        chainId: 5,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"goerli\",\n        _defaultProvider: ethDefaultProvider(\"goerli\")\n    },\n    kintsugi: { chainId: 1337702, name: \"kintsugi\" },\n    sepolia: {\n        chainId: 11155111,\n        name: \"sepolia\",\n        _defaultProvider: ethDefaultProvider(\"sepolia\")\n    },\n    // ETC (See: #351)\n    classic: {\n        chainId: 61,\n        name: \"classic\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/etc\", \"classic\")\n    },\n    classicMorden: { chainId: 62, name: \"classicMorden\" },\n    classicMordor: classicMordor,\n    classicTestnet: classicMordor,\n    classicKotti: {\n        chainId: 6,\n        name: \"classicKotti\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/kotti\", \"classicKotti\")\n    },\n    xdai: { chainId: 100, name: \"xdai\" },\n    matic: {\n        chainId: 137,\n        name: \"matic\",\n        _defaultProvider: ethDefaultProvider(\"matic\")\n    },\n    maticmum: { chainId: 80001, name: \"maticmum\" },\n    optimism: {\n        chainId: 10,\n        name: \"optimism\",\n        _defaultProvider: ethDefaultProvider(\"optimism\")\n    },\n    \"optimism-kovan\": { chainId: 69, name: \"optimism-kovan\" },\n    \"optimism-goerli\": { chainId: 420, name: \"optimism-goerli\" },\n    arbitrum: { chainId: 42161, name: \"arbitrum\" },\n    \"arbitrum-rinkeby\": { chainId: 421611, name: \"arbitrum-rinkeby\" },\n    \"arbitrum-goerli\": { chainId: 421613, name: \"arbitrum-goerli\" },\n    bnb: { chainId: 56, name: \"bnb\" },\n    bnbt: { chainId: 97, name: \"bnbt\" },\n};\n/**\n *  getNetwork\n *\n *  Converts a named common networks or chain ID (network ID) to a Network\n *  and verifies a network is a valid Network..\n */\nexport function getNetwork(network) {\n    // No network (null)\n    if (network == null) {\n        return null;\n    }\n    if (typeof (network) === \"number\") {\n        for (const name in networks) {\n            const standard = networks[name];\n            if (standard.chainId === network) {\n                return {\n                    name: standard.name,\n                    chainId: standard.chainId,\n                    ensAddress: (standard.ensAddress || null),\n                    _defaultProvider: (standard._defaultProvider || null)\n                };\n            }\n        }\n        return {\n            chainId: network,\n            name: \"unknown\"\n        };\n    }\n    if (typeof (network) === \"string\") {\n        const standard = networks[network];\n        if (standard == null) {\n            return null;\n        }\n        return {\n            name: standard.name,\n            chainId: standard.chainId,\n            ensAddress: standard.ensAddress,\n            _defaultProvider: (standard._defaultProvider || null)\n        };\n    }\n    const standard = networks[network.name];\n    // Not a standard network; check that it is a valid network in general\n    if (!standard) {\n        if (typeof (network.chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n        }\n        return network;\n    }\n    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n        logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n    }\n    // @TODO: In the next major version add an attach function to a defaultProvider\n    // class and move the _defaultProvider internal to this file (extend Network)\n    let defaultProvider = network._defaultProvider || null;\n    if (defaultProvider == null && standard._defaultProvider) {\n        if (isRenetworkable(standard._defaultProvider)) {\n            defaultProvider = standard._defaultProvider.renetwork(network);\n        }\n        else {\n            defaultProvider = standard._defaultProvider;\n        }\n    }\n    // Standard Network (allow overriding the ENS address)\n    return {\n        name: network.name,\n        chainId: standard.chainId,\n        ensAddress: (network.ensAddress || standard.ensAddress || null),\n        _defaultProvider: defaultProvider\n    };\n}\n//# sourceMappingURL=index.js.map","export const version = \"providers/5.7.2\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ForkEvent, Provider } from \"@ethersproject/abstract-provider\";\nimport { encode as base64Encode } from \"@ethersproject/base64\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexConcat, hexDataLength, hexDataSlice, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { HashZero } from \"@ethersproject/constants\";\nimport { dnsEncode, namehash } from \"@ethersproject/hash\";\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { defineReadOnly, getStatic, resolveProperties } from \"@ethersproject/properties\";\nimport { sha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\nimport bech32 from \"bech32\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { Formatter } from \"./formatter\";\nconst MAX_CCIP_REDIRECTS = 10;\n//////////////////////////////\n// Event Serializeing\nfunction checkTopic(topic) {\n    if (topic == null) {\n        return \"null\";\n    }\n    if (hexDataLength(topic) !== 32) {\n        logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n    }\n    return topic.toLowerCase();\n}\nfunction serializeTopics(topics) {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) {\n        topics.pop();\n    }\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            // Only track unique OR-topics\n            const unique = {};\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n            return sorted.join(\"|\");\n        }\n        else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\nfunction deserializeTopics(data) {\n    if (data === \"\") {\n        return [];\n    }\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") {\n            return [];\n        }\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null : topic);\n        });\n        return ((comps.length === 1) ? comps[0] : comps);\n    });\n}\nfunction getEventTag(eventName) {\n    if (typeof (eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n    }\n    else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n    }\n    else if (ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n    }\n    else if (eventName && typeof (eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n    throw new Error(\"invalid event - \" + eventName);\n}\n//////////////////////////////\n// Helper Object\nfunction getTime() {\n    return (new Date()).getTime();\n}\nfunction stall(duration) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n//////////////////////////////\n// Provider Object\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\nconst PollableEvents = [\"block\", \"network\", \"pending\", \"poll\"];\nexport class Event {\n    constructor(tag, listener, once) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n        this._lastBlockNumber = -2;\n        this._inflight = false;\n    }\n    get event() {\n        switch (this.type) {\n            case \"tx\":\n                return this.hash;\n            case \"filter\":\n                return this.filter;\n        }\n        return this.tag;\n    }\n    get type() {\n        return this.tag.split(\":\")[0];\n    }\n    get hash() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") {\n            return null;\n        }\n        return comps[1];\n    }\n    get filter() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") {\n            return null;\n        }\n        const address = comps[1];\n        const topics = deserializeTopics(comps[2]);\n        const filter = {};\n        if (topics.length > 0) {\n            filter.topics = topics;\n        }\n        if (address && address !== \"*\") {\n            filter.address = address;\n        }\n        return filter;\n    }\n    pollable() {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n;\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos = {\n    \"0\": { symbol: \"btc\", p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\": { symbol: \"ltc\", p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\": { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\": { symbol: \"eth\", ilk: \"eth\" },\n    \"61\": { symbol: \"etc\", ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\nfunction bytes32ify(value) {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data) {\n    return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));\n}\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\nfunction _parseString(result, start) {\n    try {\n        return toUtf8String(_parseBytes(result, start));\n    }\n    catch (error) { }\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();\n    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n    return hexDataSlice(result, offset + 32, offset + 32 + length);\n}\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    }\n    else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    }\n    else {\n        logger.throwArgumentError(\"unsupported IPFS format\", \"link\", link);\n    }\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\nfunction numPad(value) {\n    const result = arrayify(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if ((value.length % 32) === 0) {\n        return value;\n    }\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    const result = [];\n    let byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for (let i = 0; i < datas.length; i++) {\n        result.push(null);\n        byteCount += 32;\n    }\n    for (let i = 0; i < datas.length; i++) {\n        const data = arrayify(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return hexConcat(result);\n}\nexport class Resolver {\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider, address, name, resolvedAddress) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n        defineReadOnly(this, \"_resolvedAddress\", resolvedAddress);\n    }\n    supportsWildcard() {\n        if (!this._supportsEip2544) {\n            // supportsInterface(bytes4 = selector(\"resolve(bytes,bytes)\"))\n            this._supportsEip2544 = this.provider.call({\n                to: this.address,\n                data: \"0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000\"\n            }).then((result) => {\n                return BigNumber.from(result).eq(1);\n            }).catch((error) => {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return false;\n                }\n                // Rethrow the error: link is down, etc. Let future attempts retry.\n                this._supportsEip2544 = null;\n                throw error;\n            });\n        }\n        return this._supportsEip2544;\n    }\n    _fetch(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // e.g. keccak256(\"addr(bytes32,uint256)\")\n            const tx = {\n                to: this.address,\n                ccipReadEnabled: true,\n                data: hexConcat([selector, namehash(this.name), (parameters || \"0x\")])\n            };\n            // Wildcard support; use EIP-2544 to resolve the request\n            let parseBytes = false;\n            if (yield this.supportsWildcard()) {\n                parseBytes = true;\n                // selector(\"resolve(bytes,bytes)\")\n                tx.data = hexConcat([\"0x9061b923\", encodeBytes([dnsEncode(this.name), tx.data])]);\n            }\n            try {\n                let result = yield this.provider.call(tx);\n                if ((arrayify(result).length % 32) === 4) {\n                    logger.throwError(\"resolver threw error\", Logger.errors.CALL_EXCEPTION, {\n                        transaction: tx, data: result\n                    });\n                }\n                if (parseBytes) {\n                    result = _parseBytes(result, 0);\n                }\n                return result;\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                throw error;\n            }\n        });\n    }\n    _fetchBytes(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield this._fetch(selector, parameters);\n            if (result != null) {\n                return _parseBytes(result, 0);\n            }\n            return null;\n        });\n    }\n    _getAddress(coinType, hexBytes) {\n        const coinInfo = coinInfos[String(coinType)];\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${coinType})`\n            });\n        }\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n        const bytes = arrayify(hexBytes);\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2pkh], (\"0x\" + p2pkh[2])]));\n                }\n            }\n        }\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2sh], (\"0x\" + p2sh[2])]));\n                }\n            }\n        }\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            }\n            else {\n                version = -1;\n            }\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32.toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32.encode(coinInfo.prefix, words);\n            }\n        }\n        return null;\n    }\n    getAddress(coinType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (coinType == null) {\n                coinType = 60;\n            }\n            // If Ethereum, use the standard `addr(bytes32)`\n            if (coinType === 60) {\n                try {\n                    // keccak256(\"addr(bytes32)\")\n                    const result = yield this._fetch(\"0x3b3b57de\");\n                    // No address\n                    if (result === \"0x\" || result === HashZero) {\n                        return null;\n                    }\n                    return this.provider.formatter.callAddress(result);\n                }\n                catch (error) {\n                    if (error.code === Logger.errors.CALL_EXCEPTION) {\n                        return null;\n                    }\n                    throw error;\n                }\n            }\n            // keccak256(\"addr(bytes32,uint256\")\n            const hexBytes = yield this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n            // No address\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // Compute the address\n            const address = this._getAddress(coinType, hexBytes);\n            if (address == null) {\n                logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `getAddress(${coinType})`,\n                    coinType: coinType,\n                    data: hexBytes\n                });\n            }\n            return address;\n        });\n    }\n    getAvatar() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const linkage = [{ type: \"name\", content: this.name }];\n            try {\n                // test data for ricmoo.eth\n                //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n                const avatar = yield this.getText(\"avatar\");\n                if (avatar == null) {\n                    return null;\n                }\n                for (let i = 0; i < matchers.length; i++) {\n                    const match = avatar.match(matchers[i]);\n                    if (match == null) {\n                        continue;\n                    }\n                    const scheme = match[1].toLowerCase();\n                    switch (scheme) {\n                        case \"https\":\n                            linkage.push({ type: \"url\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"data\":\n                            linkage.push({ type: \"data\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"ipfs\":\n                            linkage.push({ type: \"ipfs\", content: avatar });\n                            return { linkage, url: getIpfsLink(avatar) };\n                        case \"erc721\":\n                        case \"erc1155\": {\n                            // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                            const selector = (scheme === \"erc721\") ? \"0xc87b56dd\" : \"0x0e89341c\";\n                            linkage.push({ type: scheme, content: avatar });\n                            // The owner of this name\n                            const owner = (this._resolvedAddress || (yield this.getAddress()));\n                            const comps = (match[2] || \"\").split(\"/\");\n                            if (comps.length !== 2) {\n                                return null;\n                            }\n                            const addr = yield this.provider.formatter.address(comps[0]);\n                            const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);\n                            // Check that this account owns the token\n                            if (scheme === \"erc721\") {\n                                // ownerOf(uint256 tokenId)\n                                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({\n                                    to: addr, data: hexConcat([\"0x6352211e\", tokenId])\n                                }));\n                                if (owner !== tokenOwner) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"owner\", content: tokenOwner });\n                            }\n                            else if (scheme === \"erc1155\") {\n                                // balanceOf(address owner, uint256 tokenId)\n                                const balance = BigNumber.from(yield this.provider.call({\n                                    to: addr, data: hexConcat([\"0x00fdd58e\", hexZeroPad(owner, 32), tokenId])\n                                }));\n                                if (balance.isZero()) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"balance\", content: balance.toString() });\n                            }\n                            // Call the token contract for the metadata URL\n                            const tx = {\n                                to: this.provider.formatter.address(comps[0]),\n                                data: hexConcat([selector, tokenId])\n                            };\n                            let metadataUrl = _parseString(yield this.provider.call(tx), 0);\n                            if (metadataUrl == null) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata-url-base\", content: metadataUrl });\n                            // ERC-1155 allows a generic {id} in the URL\n                            if (scheme === \"erc1155\") {\n                                metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                                linkage.push({ type: \"metadata-url-expanded\", content: metadataUrl });\n                            }\n                            // Transform IPFS metadata links\n                            if (metadataUrl.match(/^ipfs:/i)) {\n                                metadataUrl = getIpfsLink(metadataUrl);\n                            }\n                            linkage.push({ type: \"metadata-url\", content: metadataUrl });\n                            // Get the token metadata\n                            const metadata = yield fetchJson(metadataUrl);\n                            if (!metadata) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n                            // Pull the image URL out\n                            let imageUrl = metadata.image;\n                            if (typeof (imageUrl) !== \"string\") {\n                                return null;\n                            }\n                            if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                                // Allow\n                            }\n                            else {\n                                // Transform IPFS link to gateway\n                                const ipfs = imageUrl.match(matcherIpfs);\n                                if (ipfs == null) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"url-ipfs\", content: imageUrl });\n                                imageUrl = getIpfsLink(imageUrl);\n                            }\n                            linkage.push({ type: \"url\", content: imageUrl });\n                            return { linkage, url: imageUrl };\n                        }\n                    }\n                }\n            }\n            catch (error) { }\n            return null;\n        });\n    }\n    getContentHash() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // keccak256(\"contenthash()\")\n            const hexBytes = yield this._fetchBytes(\"0xbc1c58d1\");\n            // No contenthash\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // IPFS (CID: 1, Type: DAG-PB)\n            const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipfs) {\n                const length = parseInt(ipfs[3], 16);\n                if (ipfs[4].length === length * 2) {\n                    return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n                }\n            }\n            // IPNS (CID: 1, Type: libp2p-key)\n            const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipns) {\n                const length = parseInt(ipns[3], 16);\n                if (ipns[4].length === length * 2) {\n                    return \"ipns:/\\/\" + Base58.encode(\"0x\" + ipns[1]);\n                }\n            }\n            // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n            const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n            if (swarm) {\n                if (swarm[1].length === (32 * 2)) {\n                    return \"bzz:/\\/\" + swarm[1];\n                }\n            }\n            const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);\n            if (skynet) {\n                if (skynet[1].length === (34 * 2)) {\n                    // URL Safe base64; https://datatracker.ietf.org/doc/html/rfc4648#section-5\n                    const urlSafe = { \"=\": \"\", \"+\": \"-\", \"/\": \"_\" };\n                    const hash = base64Encode(\"0x\" + skynet[1]).replace(/[=+\\/]/g, (a) => (urlSafe[a]));\n                    return \"sia:/\\/\" + hash;\n                }\n            }\n            return logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"getContentHash()\",\n                data: hexBytes\n            });\n        });\n    }\n    getText(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // The key encoded as parameter to fetchBytes\n            let keyBytes = toUtf8Bytes(key);\n            // The nodehash consumes the first slot, so the string pointer targets\n            // offset 64, with the length at offset 64 and data starting at offset 96\n            keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);\n            // Pad to word-size (32 bytes)\n            if ((keyBytes.length % 32) !== 0) {\n                keyBytes = concat([keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32))]);\n            }\n            const hexBytes = yield this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            return toUtf8String(hexBytes);\n        });\n    }\n}\nlet defaultFormatter = null;\nlet nextPollId = 1;\nexport class BaseProvider extends Provider {\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n    constructor(network) {\n        super();\n        // Events being listened to\n        this._events = [];\n        this._emitted = { block: -2 };\n        this.disableCcipRead = false;\n        this.formatter = new.target.getFormatter();\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) {\n            network = this.detectNetwork();\n        }\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n        }\n        else {\n            const knownNetwork = getStatic(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n            }\n            else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n        this._maxInternalBlockNumber = -1024;\n        this._lastBlockNumber = -2;\n        this._maxFilterBlockRange = 10;\n        this._pollingInterval = 4000;\n        this._fastQueryDate = 0;\n    }\n    _ready() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._network == null) {\n                let network = null;\n                if (this._networkPromise) {\n                    try {\n                        network = yield this._networkPromise;\n                    }\n                    catch (error) { }\n                }\n                // Try the Provider's network detection (this MUST throw if it cannot)\n                if (network == null) {\n                    network = yield this.detectNetwork();\n                }\n                // This should never happen; every Provider sub-class should have\n                // suggested a network by here (or have thrown).\n                if (!network) {\n                    logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // Possible this call stacked so do not call defineReadOnly again\n                if (this._network == null) {\n                    if (this.anyNetwork) {\n                        this._network = network;\n                    }\n                    else {\n                        defineReadOnly(this, \"_network\", network);\n                    }\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return this._network;\n        });\n    }\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready() {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter() {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network) {\n        return getNetwork((network == null) ? \"homestead\" : network);\n    }\n    ccipReadFetch(tx, calldata, urls) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.disableCcipRead || urls.length === 0) {\n                return null;\n            }\n            const sender = tx.to.toLowerCase();\n            const data = calldata.toLowerCase();\n            const errorMessages = [];\n            for (let i = 0; i < urls.length; i++) {\n                const url = urls[i];\n                // URL expansion\n                const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n                // If no {data} is present, use POST; otherwise GET\n                const json = (url.indexOf(\"{data}\") >= 0) ? null : JSON.stringify({ data, sender });\n                const result = yield fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n                    value.status = response.statusCode;\n                    return value;\n                });\n                if (result.data) {\n                    return result.data;\n                }\n                const errorMessage = (result.message || \"unknown error\");\n                // 4xx indicates the result is not present; stop\n                if (result.status >= 400 && result.status < 500) {\n                    return logger.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger.errors.SERVER_ERROR, { url, errorMessage });\n                }\n                // 5xx indicates server issue; try the next url\n                errorMessages.push(errorMessage);\n            }\n            return logger.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(\", \")}`, Logger.errors.SERVER_ERROR, {\n                urls, errorMessages\n            });\n        });\n    }\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    _getInternalBlockNumber(maxAge) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._ready();\n            // Allowing stale data up to maxAge old\n            if (maxAge > 0) {\n                // While there are pending internal block requests...\n                while (this._internalBlockNumber) {\n                    // ...\"remember\" which fetch we started with\n                    const internalBlockNumber = this._internalBlockNumber;\n                    try {\n                        // Check the result is not too stale\n                        const result = yield internalBlockNumber;\n                        if ((getTime() - result.respTime) <= maxAge) {\n                            return result.blockNumber;\n                        }\n                        // Too old; fetch a new value\n                        break;\n                    }\n                    catch (error) {\n                        // The fetch rejected; if we are the first to get the\n                        // rejection, drop through so we replace it with a new\n                        // fetch; all others blocked will then get that fetch\n                        // which won't match the one they \"remembered\" and loop\n                        if (this._internalBlockNumber === internalBlockNumber) {\n                            break;\n                        }\n                    }\n                }\n            }\n            const reqTime = getTime();\n            const checkInternalBlockNumber = resolveProperties({\n                blockNumber: this.perform(\"getBlockNumber\", {}),\n                networkError: this.getNetwork().then((network) => (null), (error) => (error))\n            }).then(({ blockNumber, networkError }) => {\n                if (networkError) {\n                    // Unremember this bad internal block number\n                    if (this._internalBlockNumber === checkInternalBlockNumber) {\n                        this._internalBlockNumber = null;\n                    }\n                    throw networkError;\n                }\n                const respTime = getTime();\n                blockNumber = BigNumber.from(blockNumber).toNumber();\n                if (blockNumber < this._maxInternalBlockNumber) {\n                    blockNumber = this._maxInternalBlockNumber;\n                }\n                this._maxInternalBlockNumber = blockNumber;\n                this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n                return { blockNumber, reqTime, respTime };\n            });\n            this._internalBlockNumber = checkInternalBlockNumber;\n            // Swallow unhandled exceptions; if needed they are handled else where\n            checkInternalBlockNumber.catch((error) => {\n                // Don't null the dead (rejected) fetch, if it has already been updated\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n            });\n            return (yield checkInternalBlockNumber).blockNumber;\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const pollId = nextPollId++;\n            // Track all running promises, so we can trigger a post-poll once they are complete\n            const runners = [];\n            let blockNumber = null;\n            try {\n                blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n            }\n            catch (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this._setFastBlockNumber(blockNumber);\n            // Emit a poll event after we have the latest (fast) block number\n            this.emit(\"poll\", pollId, blockNumber);\n            // If the block has not changed, meh.\n            if (blockNumber === this._lastBlockNumber) {\n                this.emit(\"didPoll\", pollId);\n                return;\n            }\n            // First polling cycle, trigger a \"block\" events\n            if (this._emitted.block === -2) {\n                this._emitted.block = blockNumber - 1;\n            }\n            if (Math.abs((this._emitted.block) - blockNumber) > 1000) {\n                logger.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);\n                this.emit(\"error\", logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                    blockNumber: blockNumber,\n                    event: \"blockSkew\",\n                    previousBlockNumber: this._emitted.block\n                }));\n                this.emit(\"block\", blockNumber);\n            }\n            else {\n                // Notify all listener for each block that has passed\n                for (let i = this._emitted.block + 1; i <= blockNumber; i++) {\n                    this.emit(\"block\", i);\n                }\n            }\n            // The emitted block was updated, check for obsolete events\n            if (this._emitted.block !== blockNumber) {\n                this._emitted.block = blockNumber;\n                Object.keys(this._emitted).forEach((key) => {\n                    // The block event does not expire\n                    if (key === \"block\") {\n                        return;\n                    }\n                    // The block we were at when we emitted this event\n                    const eventBlockNumber = this._emitted[key];\n                    // We cannot garbage collect pending transactions or blocks here\n                    // They should be garbage collected by the Provider when setting\n                    // \"pending\" events\n                    if (eventBlockNumber === \"pending\") {\n                        return;\n                    }\n                    // Evict any transaction hashes or block hashes over 12 blocks\n                    // old, since they should not return null anyways\n                    if (blockNumber - eventBlockNumber > 12) {\n                        delete this._emitted[key];\n                    }\n                });\n            }\n            // First polling cycle\n            if (this._lastBlockNumber === -2) {\n                this._lastBlockNumber = blockNumber - 1;\n            }\n            // Find all transaction hashes we are waiting on\n            this._events.forEach((event) => {\n                switch (event.type) {\n                    case \"tx\": {\n                        const hash = event.hash;\n                        let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                            if (!receipt || receipt.blockNumber == null) {\n                                return null;\n                            }\n                            this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                            this.emit(hash, receipt);\n                            return null;\n                        }).catch((error) => { this.emit(\"error\", error); });\n                        runners.push(runner);\n                        break;\n                    }\n                    case \"filter\": {\n                        // We only allow a single getLogs to be in-flight at a time\n                        if (!event._inflight) {\n                            event._inflight = true;\n                            // This is the first filter for this event, so we want to\n                            // restrict events to events that happened no earlier than now\n                            if (event._lastBlockNumber === -2) {\n                                event._lastBlockNumber = blockNumber - 1;\n                            }\n                            // Filter from the last *known* event; due to load-balancing\n                            // and some nodes returning updated block numbers before\n                            // indexing events, a logs result with 0 entries cannot be\n                            // trusted and we must retry a range which includes it again\n                            const filter = event.filter;\n                            filter.fromBlock = event._lastBlockNumber + 1;\n                            filter.toBlock = blockNumber;\n                            // Prevent fitler ranges from growing too wild, since it is quite\n                            // likely there just haven't been any events to move the lastBlockNumber.\n                            const minFromBlock = filter.toBlock - this._maxFilterBlockRange;\n                            if (minFromBlock > filter.fromBlock) {\n                                filter.fromBlock = minFromBlock;\n                            }\n                            if (filter.fromBlock < 0) {\n                                filter.fromBlock = 0;\n                            }\n                            const runner = this.getLogs(filter).then((logs) => {\n                                // Allow the next getLogs\n                                event._inflight = false;\n                                if (logs.length === 0) {\n                                    return;\n                                }\n                                logs.forEach((log) => {\n                                    // Only when we get an event for a given block number\n                                    // can we trust the events are indexed\n                                    if (log.blockNumber > event._lastBlockNumber) {\n                                        event._lastBlockNumber = log.blockNumber;\n                                    }\n                                    // Make sure we stall requests to fetch blocks and txs\n                                    this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                    this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                                    this.emit(filter, log);\n                                });\n                            }).catch((error) => {\n                                this.emit(\"error\", error);\n                                // Allow another getLogs (the range was not updated)\n                                event._inflight = false;\n                            });\n                            runners.push(runner);\n                        }\n                        break;\n                    }\n                }\n            });\n            this._lastBlockNumber = blockNumber;\n            // Once all events for this loop have been processed, emit \"didPoll\"\n            Promise.all(runners).then(() => {\n                this.emit(\"didPoll\", pollId);\n            }).catch((error) => { this.emit(\"error\", error); });\n            return;\n        });\n    }\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber) {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) {\n            this.poll();\n        }\n    }\n    get network() {\n        return this._network;\n    }\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"provider.detectNetwork\"\n            });\n        });\n    }\n    getNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const network = yield this._ready();\n            // Make sure we are still connected to the same network; this is\n            // only an external call for backends which can have the underlying\n            // network change spontaneously\n            const currentNetwork = yield this.detectNetwork();\n            if (network.chainId !== currentNetwork.chainId) {\n                // We are allowing network changes, things can get complex fast;\n                // make sure you know what you are doing if you use \"any\"\n                if (this.anyNetwork) {\n                    this._network = currentNetwork;\n                    // Reset all internal block number guards and caches\n                    this._lastBlockNumber = -2;\n                    this._fastBlockNumber = null;\n                    this._fastBlockNumberPromise = null;\n                    this._fastQueryDate = 0;\n                    this._emitted.block = -2;\n                    this._maxInternalBlockNumber = -1024;\n                    this._internalBlockNumber = null;\n                    // The \"network\" event MUST happen before this method resolves\n                    // so any events have a chance to unregister, so we stall an\n                    // additional event loop before returning from /this/ call\n                    this.emit(\"network\", currentNetwork, network);\n                    yield stall(0);\n                    return this._network;\n                }\n                const error = logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                    event: \"changed\",\n                    network: network,\n                    detectedNetwork: currentNetwork\n                });\n                this.emit(\"error\", error);\n                throw error;\n            }\n            return network;\n        });\n    }\n    get blockNumber() {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber : -1;\n    }\n    get polling() {\n        return (this._poller != null);\n    }\n    set polling(value) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) {\n                            this.poll();\n                        }\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n        }\n        else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n    get pollingInterval() {\n        return this._pollingInterval;\n    }\n    set pollingInterval(value) {\n        if (typeof (value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n        this._pollingInterval = value;\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n    _getFastBlockNumber() {\n        const now = getTime();\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n        return this._fastBlockNumberPromise;\n    }\n    _setFastBlockNumber(blockNumber) {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n            return;\n        }\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n    waitForTransaction(transactionHash, confirmations, timeout) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._waitForTransaction(transactionHash, (confirmations == null) ? 1 : confirmations, timeout || 0, null);\n        });\n    }\n    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const receipt = yield this.getTransactionReceipt(transactionHash);\n            // Receipt is already good\n            if ((receipt ? receipt.confirmations : 0) >= confirmations) {\n                return receipt;\n            }\n            // Poll until the receipt is good...\n            return new Promise((resolve, reject) => {\n                const cancelFuncs = [];\n                let done = false;\n                const alreadyDone = function () {\n                    if (done) {\n                        return true;\n                    }\n                    done = true;\n                    cancelFuncs.forEach((func) => { func(); });\n                    return false;\n                };\n                const minedHandler = (receipt) => {\n                    if (receipt.confirmations < confirmations) {\n                        return;\n                    }\n                    if (alreadyDone()) {\n                        return;\n                    }\n                    resolve(receipt);\n                };\n                this.on(transactionHash, minedHandler);\n                cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n                if (replaceable) {\n                    let lastBlockNumber = replaceable.startBlock;\n                    let scannedBlock = null;\n                    const replaceHandler = (blockNumber) => __awaiter(this, void 0, void 0, function* () {\n                        if (done) {\n                            return;\n                        }\n                        // Wait 1 second; this is only used in the case of a fault, so\n                        // we will trade off a little bit of latency for more consistent\n                        // results and fewer JSON-RPC calls\n                        yield stall(1000);\n                        this.getTransactionCount(replaceable.from).then((nonce) => __awaiter(this, void 0, void 0, function* () {\n                            if (done) {\n                                return;\n                            }\n                            if (nonce <= replaceable.nonce) {\n                                lastBlockNumber = blockNumber;\n                            }\n                            else {\n                                // First check if the transaction was mined\n                                {\n                                    const mined = yield this.getTransaction(transactionHash);\n                                    if (mined && mined.blockNumber != null) {\n                                        return;\n                                    }\n                                }\n                                // First time scanning. We start a little earlier for some\n                                // wiggle room here to handle the eventually consistent nature\n                                // of blockchain (e.g. the getTransactionCount was for a\n                                // different block)\n                                if (scannedBlock == null) {\n                                    scannedBlock = lastBlockNumber - 3;\n                                    if (scannedBlock < replaceable.startBlock) {\n                                        scannedBlock = replaceable.startBlock;\n                                    }\n                                }\n                                while (scannedBlock <= blockNumber) {\n                                    if (done) {\n                                        return;\n                                    }\n                                    const block = yield this.getBlockWithTransactions(scannedBlock);\n                                    for (let ti = 0; ti < block.transactions.length; ti++) {\n                                        const tx = block.transactions[ti];\n                                        // Successfully mined!\n                                        if (tx.hash === transactionHash) {\n                                            return;\n                                        }\n                                        // Matches our transaction from and nonce; its a replacement\n                                        if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                            if (done) {\n                                                return;\n                                            }\n                                            // Get the receipt of the replacement\n                                            const receipt = yield this.waitForTransaction(tx.hash, confirmations);\n                                            // Already resolved or rejected (prolly a timeout)\n                                            if (alreadyDone()) {\n                                                return;\n                                            }\n                                            // The reason we were replaced\n                                            let reason = \"replaced\";\n                                            if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                                reason = \"repriced\";\n                                            }\n                                            else if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                                reason = \"cancelled\";\n                                            }\n                                            // Explain why we were replaced\n                                            reject(logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                                cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                                reason,\n                                                replacement: this._wrapTransaction(tx),\n                                                hash: transactionHash,\n                                                receipt\n                                            }));\n                                            return;\n                                        }\n                                    }\n                                    scannedBlock++;\n                                }\n                            }\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        }), (error) => {\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        });\n                    });\n                    if (done) {\n                        return;\n                    }\n                    this.once(\"block\", replaceHandler);\n                    cancelFuncs.push(() => {\n                        this.removeListener(\"block\", replaceHandler);\n                    });\n                }\n                if (typeof (timeout) === \"number\" && timeout > 0) {\n                    const timer = setTimeout(() => {\n                        if (alreadyDone()) {\n                            return;\n                        }\n                        reject(logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                    }, timeout);\n                    if (timer.unref) {\n                        timer.unref();\n                    }\n                    cancelFuncs.push(() => { clearTimeout(timer); });\n                }\n            });\n        });\n    }\n    getBlockNumber() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._getInternalBlockNumber(0);\n        });\n    }\n    getGasPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const result = yield this.perform(\"getGasPrice\", {});\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getGasPrice\",\n                    result, error\n                });\n            }\n        });\n    }\n    getBalance(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getBalance\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getBalance\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getTransactionCount(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getTransactionCount\", params);\n            try {\n                return BigNumber.from(result).toNumber();\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getTransactionCount\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getCode(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getCode\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getCode\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getStorageAt(addressOrName, position, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag),\n                position: Promise.resolve(position).then((p) => hexValue(p))\n            });\n            const result = yield this.perform(\"getStorageAt\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getStorageAt\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx, hash, startBlock) {\n        if (hash != null && hexDataLength(hash) !== 32) {\n            throw new Error(\"invalid response - sendTransaction\");\n        }\n        const result = tx;\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n        result.wait = (confirms, timeout) => __awaiter(this, void 0, void 0, function* () {\n            if (confirms == null) {\n                confirms = 1;\n            }\n            if (timeout == null) {\n                timeout = 0;\n            }\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n            const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) {\n                return null;\n            }\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n            if (receipt.status === 0) {\n                logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        });\n        return result;\n    }\n    sendTransaction(signedTransaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const hexTx = yield Promise.resolve(signedTransaction).then(t => hexlify(t));\n            const tx = this.formatter.transaction(signedTransaction);\n            if (tx.confirmations == null) {\n                tx.confirmations = 0;\n            }\n            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            try {\n                const hash = yield this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n                return this._wrapTransaction(tx, hash, blockNumber);\n            }\n            catch (error) {\n                error.transaction = tx;\n                error.transactionHash = tx.hash;\n                throw error;\n            }\n        });\n    }\n    _getTransactionRequest(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const values = yield transaction;\n            const tx = {};\n            [\"from\", \"to\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v) : null));\n            });\n            [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v) : null));\n            });\n            [\"type\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v : null));\n            });\n            if (values.accessList) {\n                tx.accessList = this.formatter.accessList(values.accessList);\n            }\n            [\"data\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v) : null));\n            });\n            return this.formatter.transactionRequest(yield resolveProperties(tx));\n        });\n    }\n    _getFilter(filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            filter = yield filter;\n            const result = {};\n            if (filter.address != null) {\n                result.address = this._getAddress(filter.address);\n            }\n            [\"blockHash\", \"topics\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = filter[key];\n            });\n            [\"fromBlock\", \"toBlock\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = this._getBlockTag(filter[key]);\n            });\n            return this.formatter.filter(yield resolveProperties(result));\n        });\n    }\n    _call(transaction, blockTag, attempt) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (attempt >= MAX_CCIP_REDIRECTS) {\n                logger.throwError(\"CCIP read exceeded maximum redirections\", Logger.errors.SERVER_ERROR, {\n                    redirects: attempt, transaction\n                });\n            }\n            const txSender = transaction.to;\n            const result = yield this.perform(\"call\", { transaction, blockTag });\n            // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)\n            if (attempt >= 0 && blockTag === \"latest\" && txSender != null && result.substring(0, 10) === \"0x556f1830\" && (hexDataLength(result) % 32 === 4)) {\n                try {\n                    const data = hexDataSlice(result, 4);\n                    // Check the sender of the OffchainLookup matches the transaction\n                    const sender = hexDataSlice(data, 0, 32);\n                    if (!BigNumber.from(sender).eq(txSender)) {\n                        logger.throwError(\"CCIP Read sender did not match\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    // Read the URLs from the response\n                    const urls = [];\n                    const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();\n                    const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();\n                    const urlsData = hexDataSlice(data, urlsOffset + 32);\n                    for (let u = 0; u < urlsLength; u++) {\n                        const url = _parseString(urlsData, u * 32);\n                        if (url == null) {\n                            logger.throwError(\"CCIP Read contained corrupt URL string\", Logger.errors.CALL_EXCEPTION, {\n                                name: \"OffchainLookup\",\n                                signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                                transaction, data: result\n                            });\n                        }\n                        urls.push(url);\n                    }\n                    // Get the CCIP calldata to forward\n                    const calldata = _parseBytes(data, 64);\n                    // Get the callbackSelector (bytes4)\n                    if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {\n                        logger.throwError(\"CCIP Read callback selector included junk\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    const callbackSelector = hexDataSlice(data, 96, 100);\n                    // Get the extra data to send back to the contract as context\n                    const extraData = _parseBytes(data, 128);\n                    const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);\n                    if (ccipResult == null) {\n                        logger.throwError(\"CCIP Read disabled or provided no URLs\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    const tx = {\n                        to: txSender,\n                        data: hexConcat([callbackSelector, encodeBytes([ccipResult, extraData])])\n                    };\n                    return this._call(tx, blockTag, attempt + 1);\n                }\n                catch (error) {\n                    if (error.code === Logger.errors.SERVER_ERROR) {\n                        throw error;\n                    }\n                }\n            }\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"call\",\n                    params: { transaction, blockTag }, result, error\n                });\n            }\n        });\n    }\n    call(transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const resolved = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction),\n                blockTag: this._getBlockTag(blockTag),\n                ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)\n            });\n            return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);\n        });\n    }\n    estimateGas(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction)\n            });\n            const result = yield this.perform(\"estimateGas\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"estimateGas\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    _getAddress(addressOrName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            addressOrName = yield addressOrName;\n            if (typeof (addressOrName) !== \"string\") {\n                logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n            }\n            const address = yield this.resolveName(addressOrName);\n            if (address == null) {\n                logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `resolveName(${JSON.stringify(addressOrName)})`\n                });\n            }\n            return address;\n        });\n    }\n    _getBlock(blockHashOrBlockTag, includeTransactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            blockHashOrBlockTag = yield blockHashOrBlockTag;\n            // If blockTag is a number (not \"latest\", etc), this is the block number\n            let blockNumber = -128;\n            const params = {\n                includeTransactions: !!includeTransactions\n            };\n            if (isHexString(blockHashOrBlockTag, 32)) {\n                params.blockHash = blockHashOrBlockTag;\n            }\n            else {\n                try {\n                    params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);\n                    if (isHexString(params.blockTag)) {\n                        blockNumber = parseInt(params.blockTag.substring(2), 16);\n                    }\n                }\n                catch (error) {\n                    logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n                }\n            }\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const block = yield this.perform(\"getBlock\", params);\n                // Block was not found\n                if (block == null) {\n                    // For blockhashes, if we didn't say it existed, that blockhash may\n                    // not exist. If we did see it though, perhaps from a log, we know\n                    // it exists, and this node is just not caught up yet.\n                    if (params.blockHash != null) {\n                        if (this._emitted[\"b:\" + params.blockHash] == null) {\n                            return null;\n                        }\n                    }\n                    // For block tags, if we are asking for a future block, we return null\n                    if (params.blockTag != null) {\n                        if (blockNumber > this._emitted.block) {\n                            return null;\n                        }\n                    }\n                    // Retry on the next block\n                    return undefined;\n                }\n                // Add transactions\n                if (includeTransactions) {\n                    let blockNumber = null;\n                    for (let i = 0; i < block.transactions.length; i++) {\n                        const tx = block.transactions[i];\n                        if (tx.blockNumber == null) {\n                            tx.confirmations = 0;\n                        }\n                        else if (tx.confirmations == null) {\n                            if (blockNumber == null) {\n                                blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                            }\n                            // Add the confirmations using the fast block number (pessimistic)\n                            let confirmations = (blockNumber - tx.blockNumber) + 1;\n                            if (confirmations <= 0) {\n                                confirmations = 1;\n                            }\n                            tx.confirmations = confirmations;\n                        }\n                    }\n                    const blockWithTxs = this.formatter.blockWithTransactions(block);\n                    blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));\n                    return blockWithTxs;\n                }\n                return this.formatter.block(block);\n            }), { oncePoll: this });\n        });\n    }\n    getBlock(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, false));\n    }\n    getBlockWithTransactions(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, true));\n    }\n    getTransaction(transactionHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransaction\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                const tx = this.formatter.transactionResponse(result);\n                if (tx.blockNumber == null) {\n                    tx.confirmations = 0;\n                }\n                else if (tx.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - tx.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    tx.confirmations = confirmations;\n                }\n                return this._wrapTransaction(tx);\n            }), { oncePoll: this });\n        });\n    }\n    getTransactionReceipt(transactionHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransactionReceipt\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                // \"geth-etc\" returns receipts before they are ready\n                if (result.blockHash == null) {\n                    return undefined;\n                }\n                const receipt = this.formatter.receipt(result);\n                if (receipt.blockNumber == null) {\n                    receipt.confirmations = 0;\n                }\n                else if (receipt.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    receipt.confirmations = confirmations;\n                }\n                return receipt;\n            }), { oncePoll: this });\n        });\n    }\n    getLogs(filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({ filter: this._getFilter(filter) });\n            const logs = yield this.perform(\"getLogs\", params);\n            logs.forEach((log) => {\n                if (log.removed == null) {\n                    log.removed = false;\n                }\n            });\n            return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n        });\n    }\n    getEtherPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            return this.perform(\"getEtherPrice\", {});\n        });\n    }\n    _getBlockTag(blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            blockTag = yield blockTag;\n            if (typeof (blockTag) === \"number\" && blockTag < 0) {\n                if (blockTag % 1) {\n                    logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n                }\n                let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                blockNumber += blockTag;\n                if (blockNumber < 0) {\n                    blockNumber = 0;\n                }\n                return this.formatter.blockTag(blockNumber);\n            }\n            return this.formatter.blockTag(blockTag);\n        });\n    }\n    getResolver(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let currentName = name;\n            while (true) {\n                if (currentName === \"\" || currentName === \".\") {\n                    return null;\n                }\n                // Optimization since the eth node cannot change and does\n                // not have a wildcard resolver\n                if (name !== \"eth\" && currentName === \"eth\") {\n                    return null;\n                }\n                // Check the current node for a resolver\n                const addr = yield this._getResolver(currentName, \"getResolver\");\n                // Found a resolver!\n                if (addr != null) {\n                    const resolver = new Resolver(this, addr, name);\n                    // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                    if (currentName !== name && !(yield resolver.supportsWildcard())) {\n                        return null;\n                    }\n                    return resolver;\n                }\n                // Get the parent node\n                currentName = currentName.split(\".\").slice(1).join(\".\");\n            }\n        });\n    }\n    _getResolver(name, operation) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (operation == null) {\n                operation = \"ENS\";\n            }\n            const network = yield this.getNetwork();\n            // No ENS...\n            if (!network.ensAddress) {\n                logger.throwError(\"network does not support ENS\", Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });\n            }\n            try {\n                // keccak256(\"resolver(bytes32)\")\n                const addrData = yield this.call({\n                    to: network.ensAddress,\n                    data: (\"0x0178b8bf\" + namehash(name).substring(2))\n                });\n                return this.formatter.callAddress(addrData);\n            }\n            catch (error) {\n                // ENS registry cannot throw errors on resolver(bytes32)\n            }\n            return null;\n        });\n    }\n    resolveName(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            name = yield name;\n            // If it is already an address, nothing to resolve\n            try {\n                return Promise.resolve(this.formatter.address(name));\n            }\n            catch (error) {\n                // If is is a hexstring, the address is bad (See #694)\n                if (isHexString(name)) {\n                    throw error;\n                }\n            }\n            if (typeof (name) !== \"string\") {\n                logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n            }\n            // Get the addr from the resolver\n            const resolver = yield this.getResolver(name);\n            if (!resolver) {\n                return null;\n            }\n            return yield resolver.getAddress();\n        });\n    }\n    lookupAddress(address) {\n        return __awaiter(this, void 0, void 0, function* () {\n            address = yield address;\n            address = this.formatter.address(address);\n            const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n            const resolverAddr = yield this._getResolver(node, \"lookupAddress\");\n            if (resolverAddr == null) {\n                return null;\n            }\n            // keccak(\"name(bytes32)\")\n            const name = _parseString(yield this.call({\n                to: resolverAddr,\n                data: (\"0x691f3431\" + namehash(node).substring(2))\n            }), 0);\n            const addr = yield this.resolveName(name);\n            if (addr != address) {\n                return null;\n            }\n            return name;\n        });\n    }\n    getAvatar(nameOrAddress) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let resolver = null;\n            if (isHexString(nameOrAddress)) {\n                // Address; reverse lookup\n                const address = this.formatter.address(nameOrAddress);\n                const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n                const resolverAddress = yield this._getResolver(node, \"getAvatar\");\n                if (!resolverAddress) {\n                    return null;\n                }\n                // Try resolving the avatar against the addr.reverse resolver\n                resolver = new Resolver(this, resolverAddress, node);\n                try {\n                    const avatar = yield resolver.getAvatar();\n                    if (avatar) {\n                        return avatar.url;\n                    }\n                }\n                catch (error) {\n                    if (error.code !== Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                }\n                // Try getting the name and performing forward lookup; allowing wildcards\n                try {\n                    // keccak(\"name(bytes32)\")\n                    const name = _parseString(yield this.call({\n                        to: resolverAddress,\n                        data: (\"0x691f3431\" + namehash(node).substring(2))\n                    }), 0);\n                    resolver = yield this.getResolver(name);\n                }\n                catch (error) {\n                    if (error.code !== Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                    return null;\n                }\n            }\n            else {\n                // ENS name; forward lookup with wildcard\n                resolver = yield this.getResolver(nameOrAddress);\n                if (!resolver) {\n                    return null;\n                }\n            }\n            const avatar = yield resolver.getAvatar();\n            if (avatar == null) {\n                return null;\n            }\n            return avatar.url;\n        });\n    }\n    perform(method, params) {\n        return logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n    _startEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _stopEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _addEventListener(eventName, listener, once) {\n        const event = new Event(getEventTag(eventName), listener, once);\n        this._events.push(event);\n        this._startEvent(event);\n        return this;\n    }\n    on(eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    }\n    once(eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    }\n    emit(eventName, ...args) {\n        let result = false;\n        let stopped = [];\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) {\n                return true;\n            }\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n            result = true;\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n            return true;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!eventName) {\n            return this._events.length;\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n    listeners(eventName) {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n    off(eventName, listener) {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n        const stopped = [];\n        let found = false;\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) {\n                return true;\n            }\n            if (found) {\n                return true;\n            }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n    removeAllListeners(eventName) {\n        let stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        }\n        else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n}\n//# sourceMappingURL=base-provider.js.map","\"use strict\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexDataLength, hexDataSlice, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { accessListify, parse as parseTransaction } from \"@ethersproject/transactions\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport class Formatter {\n    constructor() {\n        this.formats = this.getDefaultFormats();\n    }\n    getDefaultFormats() {\n        const formats = ({});\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n        const strictData = (v) => { return this.data(v, true); };\n        formats.transaction = {\n            hash: hash,\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n            confirmations: Formatter.allowNull(number, null),\n            from: address,\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n            creates: Formatter.allowNull(address, null),\n            raw: Formatter.allowNull(data),\n        };\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n        formats.block = {\n            hash: Formatter.allowNull(hash),\n            parentHash: hash,\n            number: number,\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n            miner: Formatter.allowNull(address),\n            extraData: data,\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n            topics: Formatter.arrayOf(hash),\n            transactionHash: hash,\n            logIndex: number,\n        };\n        return formats;\n    }\n    accessList(accessList) {\n        return accessListify(accessList || []);\n    }\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number) {\n        if (number === \"0x\") {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    type(number) {\n        if (number === \"0x\" || number == null) {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    // Strict! Used on input.\n    bigNumber(value) {\n        return BigNumber.from(value);\n    }\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value) {\n        if (typeof (value) === \"boolean\") {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") {\n                return true;\n            }\n            if (value === \"false\") {\n                return false;\n            }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n    hex(value, strict) {\n        if (typeof (value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") {\n                value = \"0x\" + value;\n            }\n            if (isHexString(value)) {\n                return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n    data(value, strict) {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n    // Requires an address\n    // Strict! Used on input.\n    address(value) {\n        return getAddress(value);\n    }\n    callAddress(value) {\n        if (!isHexString(value, 32)) {\n            return null;\n        }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null : address;\n    }\n    contractAddress(value) {\n        return getContractAddress(value);\n    }\n    // Strict! Used on input.\n    blockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        if (blockTag === \"earliest\") {\n            return \"0x0\";\n        }\n        switch (blockTag) {\n            case \"earliest\": return \"0x0\";\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n            case \"finalized\":\n                return blockTag;\n        }\n        if (typeof (blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(blockTag);\n        }\n        throw new Error(\"invalid blockTag\");\n    }\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value, strict) {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value) {\n        if (value == null) {\n            return null;\n        }\n        const v = BigNumber.from(value);\n        try {\n            return v.toNumber();\n        }\n        catch (error) { }\n        return null;\n    }\n    uint256(value) {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n    _block(value, format) {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty : value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null : BigNumber.from(difficulty));\n        return result;\n    }\n    block(value) {\n        return this._block(value, this.formats.block);\n    }\n    blockWithTransactions(value) {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n    // Strict! Used on input.\n    transactionRequest(value) {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n    transactionResponse(transaction) {\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {\n            transaction.accessList = [];\n        }\n        const result = Formatter.check(this.formats.transaction, transaction);\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            result.chainId = chainId;\n        }\n        else {\n            let chainId = transaction.networkId;\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            if (typeof (chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) {\n                    chainId = 0;\n                }\n                chainId = parseInt(chainId);\n            }\n            if (typeof (chainId) !== \"number\") {\n                chainId = 0;\n            }\n            result.chainId = chainId;\n        }\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n        return result;\n    }\n    transaction(value) {\n        return parseTransaction(value);\n    }\n    receiptLog(value) {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n    receipt(value) {\n        const result = Formatter.check(this.formats.receipt, value);\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                }\n                else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            }\n            else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n        return result;\n    }\n    topics(value) {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n        }\n        else if (value != null) {\n            return this.hash(value, true);\n        }\n        return null;\n    }\n    filter(value) {\n        return Formatter.check(this.formats.filter, value);\n    }\n    filterLog(value) {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n    static check(format, object) {\n        const result = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) {\n                    result[key] = value;\n                }\n            }\n            catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n    // if value is null-ish, nullValue is returned\n    static allowNull(format, nullValue) {\n        return (function (value) {\n            if (value == null) {\n                return nullValue;\n            }\n            return format(value);\n        });\n    }\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format, replaceValue) {\n        return (function (value) {\n            if (!value) {\n                return replaceValue;\n            }\n            return format(value);\n        });\n    }\n    // Requires an Array satisfying check\n    static arrayOf(format) {\n        return (function (array) {\n            if (!Array.isArray(array)) {\n                throw new Error(\"not an array\");\n            }\n            const result = [];\n            array.forEach(function (value) {\n                result.push(format(value));\n            });\n            return result;\n        });\n    }\n}\nexport function isCommunityResourcable(value) {\n    return (value && typeof (value.isCommunityResource) === \"function\");\n}\nexport function isCommunityResource(value) {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n// Show the throttle message only once\nlet throttleMessage = false;\nexport function showThrottleMessage() {\n    if (throttleMessage) {\n        return;\n    }\n    throttleMessage = true;\n    console.log(\"========= NOTICE =========\");\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n//# sourceMappingURL=formatter.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Signer } from \"@ethersproject/abstract-signer\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { checkProperties, deepCopy, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BaseProvider } from \"./base-provider\";\nconst errorGas = [\"call\", \"estimateGas\"];\nfunction spelunk(value, requireData) {\n    if (value == null) {\n        return null;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof (value.message) === \"string\" && value.message.match(\"reverted\")) {\n        const data = isHexString(value.data) ? value.data : null;\n        if (!requireData || data) {\n            return { message: value.message, data };\n        }\n    }\n    // Spelunk further...\n    if (typeof (value) === \"object\") {\n        for (const key in value) {\n            const result = spelunk(value[key], requireData);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof (value) === \"string\") {\n        try {\n            return spelunk(JSON.parse(value), requireData);\n        }\n        catch (error) { }\n    }\n    return null;\n}\nfunction checkError(method, error, params) {\n    const transaction = params.transaction || params.signedTransaction;\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\") {\n        const result = spelunk(error, true);\n        if (result) {\n            return result.data;\n        }\n        // Nothing descriptive..\n        logger.throwError(\"missing revert data in call exception; Transaction reverted without a reason string\", Logger.errors.CALL_EXCEPTION, {\n            data: \"0x\", transaction, error\n        });\n    }\n    if (method === \"estimateGas\") {\n        // Try to find something, with a preference on SERVER_ERROR body\n        let result = spelunk(error.body, false);\n        if (result == null) {\n            result = spelunk(error, false);\n        }\n        // Found \"reverted\", this is a CALL_EXCEPTION\n        if (result) {\n            logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                reason: result.message, method, transaction, error\n            });\n        }\n    }\n    // @TODO: Should we spelunk for message too?\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof (error.error.message) === \"string\") {\n        message = error.error.message;\n    }\n    else if (typeof (error.body) === \"string\") {\n        message = error.body;\n    }\n    else if (typeof (error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n    // \"nonce too low\"\n    if (message.match(/nonce (is )?too low/i)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/i)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n    throw error;\n}\nfunction timer(timeout) {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\nfunction getResult(payload) {\n    if (payload.error) {\n        // @TODO: not any\n        const error = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n    return payload.result;\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nconst _constructorGuard = {};\nexport class JsonRpcSigner extends Signer {\n    constructor(constructorGuard, provider, addressOrIndex) {\n        super();\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n        defineReadOnly(this, \"provider\", provider);\n        if (addressOrIndex == null) {\n            addressOrIndex = 0;\n        }\n        if (typeof (addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n        }\n        else if (typeof (addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n        }\n        else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n    connect(provider) {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n    connectUnchecked() {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n    getAddress() {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index]);\n        });\n    }\n    sendUncheckedTransaction(transaction) {\n        transaction = shallowCopy(transaction);\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) {\n                address = address.toLowerCase();\n            }\n            return address;\n        });\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter(this, void 0, void 0, function* () {\n                if (to == null) {\n                    return null;\n                }\n                const address = yield this.provider.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            }));\n        }\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            }\n            else {\n                tx.from = sender;\n            }\n            const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });\n            return this.provider.send(\"eth_sendTransaction\", [hexTx]).then((hash) => {\n                return hash;\n            }, (error) => {\n                if (typeof (error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected transaction\", Logger.errors.ACTION_REJECTED, {\n                        action: \"sendTransaction\",\n                        transaction: tx\n                    });\n                }\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n    signTransaction(transaction) {\n        return logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // This cannot be mined any earlier than any recent block\n            const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n            // Send the transaction\n            const hash = yield this.sendUncheckedTransaction(transaction);\n            try {\n                // Unfortunately, JSON-RPC only provides and opaque transaction hash\n                // for a response, and we need the actual transaction, so we poll\n                // for it; it should show up very quickly\n                return yield poll(() => __awaiter(this, void 0, void 0, function* () {\n                    const tx = yield this.provider.getTransaction(hash);\n                    if (tx === null) {\n                        return undefined;\n                    }\n                    return this.provider._wrapTransaction(tx, hash, blockNumber);\n                }), { oncePoll: this.provider });\n            }\n            catch (error) {\n                error.transactionHash = hash;\n                throw error;\n            }\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? toUtf8Bytes(message) : message);\n            const address = yield this.getAddress();\n            try {\n                return yield this.provider.send(\"personal_sign\", [hexlify(data), address.toLowerCase()]);\n            }\n            catch (error) {\n                if (typeof (error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                        action: \"signMessage\",\n                        from: address,\n                        messageData: message\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    _legacySignMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? toUtf8Bytes(message) : message);\n            const address = yield this.getAddress();\n            try {\n                // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n                return yield this.provider.send(\"eth_sign\", [address.toLowerCase(), hexlify(data)]);\n            }\n            catch (error) {\n                if (typeof (error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                        action: \"_legacySignMessage\",\n                        from: address,\n                        messageData: message\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    _signTypedData(domain, types, value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Populate any ENS names (in-place)\n            const populated = yield _TypedDataEncoder.resolveNames(domain, types, value, (name) => {\n                return this.provider.resolveName(name);\n            });\n            const address = yield this.getAddress();\n            try {\n                return yield this.provider.send(\"eth_signTypedData_v4\", [\n                    address.toLowerCase(),\n                    JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n                ]);\n            }\n            catch (error) {\n                if (typeof (error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                        action: \"_signTypedData\",\n                        from: address,\n                        messageData: { domain: populated.domain, types, value: populated.value }\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    unlock(password) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const provider = this.provider;\n            const address = yield this.getAddress();\n            return provider.send(\"personal_unlockAccount\", [address.toLowerCase(), password, null]);\n        });\n    }\n}\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction) {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return {\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\nconst allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n};\nexport class JsonRpcProvider extends BaseProvider {\n    constructor(url, network) {\n        let networkOrReady = network;\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Default URL\n        if (!url) {\n            url = getStatic(this.constructor, \"defaultUrl\")();\n        }\n        if (typeof (url) === \"string\") {\n            defineReadOnly(this, \"connection\", Object.freeze({\n                url: url\n            }));\n        }\n        else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n        this._nextId = 42;\n    }\n    get _cache() {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = {};\n        }\n        return this._eventLoopCache;\n    }\n    static defaultUrl() {\n        return \"http:/\\/localhost:8545\";\n    }\n    detectNetwork() {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n    _uncachedDetectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield timer(0);\n            let chainId = null;\n            try {\n                chainId = yield this.send(\"eth_chainId\", []);\n            }\n            catch (error) {\n                try {\n                    chainId = yield this.send(\"net_version\", []);\n                }\n                catch (error) { }\n            }\n            if (chainId != null) {\n                const getNetwork = getStatic(this.constructor, \"getNetwork\");\n                try {\n                    return getNetwork(BigNumber.from(chainId).toNumber());\n                }\n                catch (error) {\n                    return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                        chainId: chainId,\n                        event: \"invalidNetwork\",\n                        serverError: error\n                    });\n                }\n            }\n            return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                event: \"noNetwork\"\n            });\n        });\n    }\n    getSigner(addressOrIndex) {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n    getUncheckedSigner(addressOrIndex) {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n    listAccounts() {\n        return this.send(\"eth_accounts\", []).then((accounts) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([\"eth_chainId\", \"eth_blockNumber\"].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n            return result;\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n            throw error;\n        });\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n        return result;\n    }\n    prepareRequest(method, params) {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [\"eth_blockNumber\", []];\n            case \"getGasPrice\":\n                return [\"eth_gasPrice\", []];\n            case \"getBalance\":\n                return [\"eth_getBalance\", [getLowerCase(params.address), params.blockTag]];\n            case \"getTransactionCount\":\n                return [\"eth_getTransactionCount\", [getLowerCase(params.address), params.blockTag]];\n            case \"getCode\":\n                return [\"eth_getCode\", [getLowerCase(params.address), params.blockTag]];\n            case \"getStorageAt\":\n                return [\"eth_getStorageAt\", [getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag]];\n            case \"sendTransaction\":\n                return [\"eth_sendRawTransaction\", [params.signedTransaction]];\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [\"eth_getBlockByNumber\", [params.blockTag, !!params.includeTransactions]];\n                }\n                else if (params.blockHash) {\n                    return [\"eth_getBlockByHash\", [params.blockHash, !!params.includeTransactions]];\n                }\n                return null;\n            case \"getTransaction\":\n                return [\"eth_getTransactionByHash\", [params.transactionHash]];\n            case \"getTransactionReceipt\":\n                return [\"eth_getTransactionReceipt\", [params.transactionHash]];\n            case \"call\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_call\", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];\n            }\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_estimateGas\", [hexlifyTransaction(params.transaction, { from: true })]];\n            }\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [\"eth_getLogs\", [params.filter]];\n            default:\n                break;\n        }\n        return null;\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Legacy networks do not like the type field being passed along (which\n            // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n            if (method === \"call\" || method === \"estimateGas\") {\n                const tx = params.transaction;\n                if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                    // If there are no EIP-1559 properties, it might be non-EIP-1559\n                    if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                        const feeData = yield this.getFeeData();\n                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                            // Network doesn't know about EIP-1559 (and hence type)\n                            params = shallowCopy(params);\n                            params.transaction = shallowCopy(tx);\n                            delete params.transaction.type;\n                        }\n                    }\n                }\n            }\n            const args = this.prepareRequest(method, params);\n            if (args == null) {\n                logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n            }\n            try {\n                return yield this.send(args[0], args[1]);\n            }\n            catch (error) {\n                return checkError(method, error, params);\n            }\n        });\n    }\n    _startEvent(event) {\n        if (event.tag === \"pending\") {\n            this._startPending();\n        }\n        super._startEvent(event);\n    }\n    _startPending() {\n        if (this._pendingFilter != null) {\n            return;\n        }\n        const self = this;\n        const pendingFilter = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n        pendingFilter.then(function (filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [filterId]).then(function (hashes) {\n                    if (self._pendingFilter != pendingFilter) {\n                        return null;\n                    }\n                    let seq = Promise.resolve();\n                    hashes.forEach(function (hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function () {\n                            return self.getTransaction(hash).then(function (tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n                    return seq.then(function () {\n                        return timer(1000);\n                    });\n                }).then(function () {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [filterId]);\n                        return;\n                    }\n                    setTimeout(function () { poll(); }, 0);\n                    return null;\n                }).catch((error) => { });\n            }\n            poll();\n            return filterId;\n        }).catch((error) => { });\n    }\n    _stopEvent(event) {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction, allowExtra) {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) {\n                    allowed[key] = true;\n                }\n            }\n        }\n        checkProperties(transaction, allowed);\n        const result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            const value = hexValue(BigNumber.from(transaction[key]));\n            if (key === \"gasLimit\") {\n                key = \"gas\";\n            }\n            result[key] = value;\n        });\n        [\"from\", \"to\", \"data\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            result[key] = hexlify(transaction[key]);\n        });\n        if (transaction.accessList) {\n            result[\"accessList\"] = accessListify(transaction.accessList);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=json-rpc-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\nlet NextId = 1;\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\nexport class WebSocketProvider extends JsonRpcProvider {\n    constructor(url, network) {\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n        if (typeof (url) === \"string\") {\n            super(url, network);\n        }\n        else {\n            super(\"_websocket\", network);\n        }\n        this._pollingInterval = -1;\n        this._wsReady = false;\n        if (typeof (url) === \"string\") {\n            defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        }\n        else {\n            defineReadOnly(this, \"_websocket\", url);\n        }\n        defineReadOnly(this, \"_requests\", {});\n        defineReadOnly(this, \"_subs\", {});\n        defineReadOnly(this, \"_subIds\", {});\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n        // Stall sending requests until the socket is open...\n        this.websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this.websocket.send(this._requests[id].payload);\n            });\n        };\n        this.websocket.onmessage = (messageEvent) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n                }\n                else {\n                    let error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(error, \"code\", result.error.code || null);\n                        defineReadOnly(error, \"response\", data);\n                    }\n                    else {\n                        error = new Error(\"unknown error\");\n                    }\n                    request.callback(error, undefined);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n                }\n            }\n            else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result);\n                }\n            }\n            else {\n                console.warn(\"this should not happen\");\n            }\n        };\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) {\n            fauxPoll.unref();\n        }\n    }\n    // Cannot narrow the type of _websocket, as that is not backwards compatible\n    // so we add a getter and let the WebSocket be a public API.\n    get websocket() { return this._websocket; }\n    detectNetwork() {\n        return this._detectNetwork;\n    }\n    get pollingInterval() {\n        return 0;\n    }\n    resetEventsBlock(blockNumber) {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n    set pollingInterval(value) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return null;\n        });\n    }\n    set polling(value) {\n        if (!value) {\n            return;\n        }\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n    send(method, params) {\n        const rid = NextId++;\n        return new Promise((resolve, reject) => {\n            function callback(error, result) {\n                if (error) {\n                    return reject(error);\n                }\n                return resolve(result);\n            }\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n            this._requests[String(rid)] = { callback, payload };\n            if (this._wsReady) {\n                this.websocket.send(payload);\n            }\n        });\n    }\n    static defaultUrl() {\n        return \"ws:/\\/localhost:8546\";\n    }\n    _subscribe(tag, param, processFunc) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let subIdPromise = this._subIds[tag];\n            if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then((param) => {\n                    return this.send(\"eth_subscribe\", param);\n                });\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            this._subs[subId] = { tag, processFunc };\n        });\n    }\n    _startEvent(event) {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [\"newHeads\"], (result) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n            case \"pending\":\n                this._subscribe(\"pending\", [\"newPendingTransactions\"], (result) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n            case \"filter\":\n                this._subscribe(event.tag, [\"logs\", this._getFilter(event.filter)], (result) => {\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n            case \"tx\": {\n                const emitReceipt = (event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) {\n                            return;\n                        }\n                        this.emit(hash, receipt);\n                    });\n                };\n                // In case it is already mined\n                emitReceipt(event);\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [\"newHeads\"], (result) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n    _stopEvent(event) {\n        let tag = event.tag;\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        }\n        else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        const subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        subId.then((subId) => {\n            if (!this._subs[subId]) {\n                return;\n            }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [subId]);\n        });\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Wait until we have connected before trying to disconnect\n            if (this.websocket.readyState === WebSocket.CONNECTING) {\n                yield (new Promise((resolve) => {\n                    this.websocket.onopen = function () {\n                        resolve(true);\n                    };\n                    this.websocket.onerror = function () {\n                        resolve(false);\n                    };\n                }));\n            }\n            // Hangup\n            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n            this.websocket.close(1000);\n        });\n    }\n}\n//# sourceMappingURL=websocket-provider.js.map","\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nlet WS = null;\ntry {\n    WS = WebSocket;\n    if (WS == null) {\n        throw new Error(\"inject please\");\n    }\n}\ncatch (error) {\n    const logger = new Logger(version);\n    WS = function () {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    };\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n//# sourceMappingURL=ws.js.map","export const version = \"sha2/5.7.0\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nimport hash from \"hash.js\";\n//const _ripemd160 = _hash.ripemd160;\nimport { arrayify } from \"@ethersproject/bytes\";\nimport { SupportedAlgorithm } from \"./types\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport function ripemd160(data) {\n    return \"0x\" + (hash.ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\nexport function sha256(data) {\n    return \"0x\" + (hash.sha256().update(arrayify(data)).digest(\"hex\"));\n}\nexport function sha512(data) {\n    return \"0x\" + (hash.sha512().update(arrayify(data)).digest(\"hex\"));\n}\nexport function computeHmac(algorithm, key, data) {\n    if (!SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n    return \"0x\" + hash.hmac(hash[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n//# sourceMappingURL=sha2.js.map","export var SupportedAlgorithm;\n(function (SupportedAlgorithm) {\n    SupportedAlgorithm[\"sha256\"] = \"sha256\";\n    SupportedAlgorithm[\"sha512\"] = \"sha512\";\n})(SupportedAlgorithm || (SupportedAlgorithm = {}));\n;\n//# sourceMappingURL=types.js.map","import { _ as __awaiter, D as DEFAULT_ALCHEMY_API_KEY, C as CustomNetworks, a as DEFAULT_NETWORK, N as Network, I as IS_BROWSER, V as VERSION, l as logWarn, d as deepCopy, E as EthersNetwork, g as getAlchemyHttpUrl, b as getAlchemyWsUrl } from './index-643dc9bc.js';\nimport { getNetwork } from '@ethersproject/networks';\nimport { JsonRpcProvider } from '@ethersproject/providers';\nimport { fetchJson } from '@ethersproject/web';\nimport './api/utils';\nimport '@ethersproject/bignumber';\nimport 'axios';\nimport '@ethersproject/abstract-provider';\nimport '@ethersproject/wallet';\nimport '@ethersproject/contracts';\n\n/** Maximum size of a batch on the rpc provider. */\r\nconst DEFAULT_MAX_REQUEST_BATCH_SIZE = 100;\r\n/** Timeout interval before the pending batch is sent. */\r\nconst DEFAULT_REQUEST_BATCH_DELAY_MS = 10;\r\n/**\r\n * Internal class to enqueue requests and automatically send/process batches.\r\n *\r\n * The underlying batching mechanism is loosely based on ethers.js's\r\n * `JsonRpcBatchProvider`.\r\n *\r\n * @internal\r\n */\r\nclass RequestBatcher {\r\n    constructor(sendBatchFn, maxBatchSize = DEFAULT_MAX_REQUEST_BATCH_SIZE) {\r\n        this.sendBatchFn = sendBatchFn;\r\n        this.maxBatchSize = maxBatchSize;\r\n        /**\r\n         * Array of enqueued requests along with the constructed promise handlers for\r\n         * each request.\r\n         */\r\n        this.pendingBatch = [];\r\n    }\r\n    /**\r\n     * Enqueues the provided request. The batch is immediately sent if the maximum\r\n     * batch size is reached. Otherwise, the request is enqueued onto a batch that\r\n     * is sent after 10ms.\r\n     *\r\n     * Returns a promise that resolves with the result of the request.\r\n     */\r\n    enqueueRequest(request) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const inflightRequest = {\r\n                request,\r\n                resolve: undefined,\r\n                reject: undefined\r\n            };\r\n            const promise = new Promise((resolve, reject) => {\r\n                inflightRequest.resolve = resolve;\r\n                inflightRequest.reject = reject;\r\n            });\r\n            this.pendingBatch.push(inflightRequest);\r\n            if (this.pendingBatch.length === this.maxBatchSize) {\r\n                // Send batch immediately if we are at the maximum batch size.\r\n                void this.sendBatchRequest();\r\n            }\r\n            else if (!this.pendingBatchTimer) {\r\n                // Schedule batch for next event loop + short duration\r\n                this.pendingBatchTimer = setTimeout(() => this.sendBatchRequest(), DEFAULT_REQUEST_BATCH_DELAY_MS);\r\n            }\r\n            return promise;\r\n        });\r\n    }\r\n    /**\r\n     * Sends the currently queued batches and resets the batch and timer. Processes\r\n     * the batched response results back to the original promises.\r\n     */\r\n    sendBatchRequest() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Get the current batch and clear it, so new requests\r\n            // go into the next batch\r\n            const batch = this.pendingBatch;\r\n            this.pendingBatch = [];\r\n            if (this.pendingBatchTimer) {\r\n                clearTimeout(this.pendingBatchTimer);\r\n                this.pendingBatchTimer = undefined;\r\n            }\r\n            // Get the request as an array of requests\r\n            const request = batch.map(inflight => inflight.request);\r\n            return this.sendBatchFn(request).then(result => {\r\n                // For each result, feed it to the correct Promise, depending\r\n                // on whether it was a success or error\r\n                batch.forEach((inflightRequest, index) => {\r\n                    const payload = result[index];\r\n                    if (payload.error) {\r\n                        const error = new Error(payload.error.message);\r\n                        error.code = payload.error.code;\r\n                        error.data = payload.error.data;\r\n                        inflightRequest.reject(error);\r\n                    }\r\n                    else {\r\n                        inflightRequest.resolve(payload.result);\r\n                    }\r\n                });\r\n            }, error => {\r\n                batch.forEach(inflightRequest => {\r\n                    inflightRequest.reject(error);\r\n                });\r\n            });\r\n        });\r\n    }\r\n}\n\n/**\r\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getProvider()}.\r\n *\r\n * @public\r\n */\r\nclass AlchemyProvider extends JsonRpcProvider {\r\n    /** @internal */\r\n    constructor(config) {\r\n        // Normalize the API Key to a string.\r\n        const apiKey = AlchemyProvider.getApiKey(config.apiKey);\r\n        // Generate our own connection info with the correct endpoint URLs.\r\n        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\r\n        let connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'http');\r\n        // If a hardcoded url was specified in the config, use that instead of the\r\n        // provided apiKey or network.\r\n        if (config.url !== undefined) {\r\n            connection.url = config.url;\r\n        }\r\n        connection.throttleLimit = config.maxRetries;\r\n        // Add user provided overrides if they exist.\r\n        if (config.connectionInfoOverrides) {\r\n            connection = Object.assign(Object.assign({}, connection), config.connectionInfoOverrides);\r\n        }\r\n        // Normalize the Alchemy named network input to the network names used by\r\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\r\n        // correctly set the network.\r\n        const ethersNetwork = EthersNetwork[alchemyNetwork];\r\n        if (!ethersNetwork) {\r\n            throw new Error(`Unsupported network: ${alchemyNetwork}`);\r\n        }\r\n        super(connection, ethersNetwork);\r\n        this.apiKey = config.apiKey;\r\n        this.maxRetries = config.maxRetries;\r\n        this.batchRequests = config.batchRequests;\r\n        // TODO: support individual headers when calling batch\r\n        const batcherConnection = Object.assign(Object.assign({}, this.connection), { headers: Object.assign(Object.assign({}, this.connection.headers), { 'Alchemy-Ethers-Sdk-Method': 'batchSend' }) });\r\n        const sendBatchFn = (requests) => {\r\n            return fetchJson(batcherConnection, JSON.stringify(requests));\r\n        };\r\n        this.batcher = new RequestBatcher(sendBatchFn);\r\n        this.modifyFormatter();\r\n    }\r\n    /**\r\n     * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\r\n     * ethers.js. Returns the API key for an Alchemy provider.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getApiKey(apiKey) {\r\n        if (apiKey == null) {\r\n            return DEFAULT_ALCHEMY_API_KEY;\r\n        }\r\n        if (apiKey && typeof apiKey !== 'string') {\r\n            throw new Error(`Invalid apiKey '${apiKey}' provided. apiKey must be a string.`);\r\n        }\r\n        return apiKey;\r\n    }\r\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getNetwork(network) {\r\n        if (typeof network === 'string' && network in CustomNetworks) {\r\n            return CustomNetworks[network];\r\n        }\r\n        // Call the standard ethers.js getNetwork method for other networks.\r\n        return getNetwork(network);\r\n    }\r\n    /**\r\n     * Converts the `Networkish` input to the network enum used by Alchemy.\r\n     *\r\n     * @internal\r\n     */\r\n    static getAlchemyNetwork(network) {\r\n        if (network === undefined) {\r\n            return DEFAULT_NETWORK;\r\n        }\r\n        if (typeof network === 'number') {\r\n            throw new Error(`Invalid network '${network}' provided. Network must be a string.`);\r\n        }\r\n        // Guaranteed that `typeof network === 'string`.\r\n        const isValidNetwork = Object.values(Network).includes(network);\r\n        if (!isValidNetwork) {\r\n            throw new Error(`Invalid network '${network}' provided. Network must be one of: ` +\r\n                `${Object.values(Network).join(', ')}.`);\r\n        }\r\n        return network;\r\n    }\r\n    /**\r\n     * Returns a {@link ConnectionInfo} object compatible with ethers that contains\r\n     * the correct URLs for Alchemy.\r\n     *\r\n     * @internal\r\n     */\r\n    static getAlchemyConnectionInfo(network, apiKey, type) {\r\n        const url = type === 'http'\r\n            ? getAlchemyHttpUrl(network, apiKey)\r\n            : getAlchemyWsUrl(network, apiKey);\r\n        return {\r\n            headers: IS_BROWSER\r\n                ? {\r\n                    'Alchemy-Ethers-Sdk-Version': VERSION\r\n                }\r\n                : {\r\n                    'Alchemy-Ethers-Sdk-Version': VERSION,\r\n                    'Accept-Encoding': 'gzip'\r\n                },\r\n            allowGzip: true,\r\n            url\r\n        };\r\n    }\r\n    /**\r\n     * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\r\n     * method is called when calling methods on the parent class `BaseProvider`.\r\n     *\r\n     * @override\r\n     */\r\n    detectNetwork() {\r\n        const _super = Object.create(null, {\r\n            detectNetwork: { get: () => super.detectNetwork }\r\n        });\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let network = this.network;\r\n            if (network == null) {\r\n                network = yield _super.detectNetwork.call(this);\r\n                if (!network) {\r\n                    throw new Error('No network detected');\r\n                }\r\n            }\r\n            return network;\r\n        });\r\n    }\r\n    _startPending() {\r\n        logWarn('WARNING: Alchemy Provider does not support pending filters');\r\n    }\r\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\r\n    isCommunityResource() {\r\n        return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\r\n    }\r\n    /**\r\n     * Overrides the base {@link JsonRpcProvider.send} method to implement custom\r\n     * logic for sending requests to Alchemy.\r\n     *\r\n     * @param method The method name to use for the request.\r\n     * @param params The parameters to use for the request.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Add headers for `perform()` override.\r\n    send(method, params) {\r\n        return this._send(method, params, 'send');\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `JsonRpcProvider.send()`.\r\n     *\r\n     * This method is copied over directly in order to implement custom headers\r\n     *\r\n     * @internal\r\n     */\r\n    _send(method, params, methodName) {\r\n        const request = {\r\n            method,\r\n            params,\r\n            id: this._nextId++,\r\n            jsonrpc: '2.0'\r\n        };\r\n        // START MODIFIED CODE\r\n        const connection = Object.assign({}, this.connection);\r\n        connection.headers['Alchemy-Ethers-Sdk-Method'] = methodName;\r\n        if (this.batchRequests) {\r\n            return this.batcher.enqueueRequest(request);\r\n        }\r\n        // END MODIFIED CODE\r\n        this.emit('debug', {\r\n            action: 'request',\r\n            request: deepCopy(request),\r\n            provider: this\r\n        });\r\n        // We can expand this in the future to any call, but for now these\r\n        // are the biggest wins and do not require any serializing parameters.\r\n        const cache = ['eth_chainId', 'eth_blockNumber'].indexOf(method) >= 0;\r\n        if (cache && this._cache[method]) {\r\n            return this._cache[method];\r\n        }\r\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then(result => {\r\n            this.emit('debug', {\r\n                action: 'response',\r\n                request,\r\n                response: result,\r\n                provider: this\r\n            });\r\n            return result;\r\n        }, error => {\r\n            this.emit('debug', {\r\n                action: 'response',\r\n                error,\r\n                request,\r\n                provider: this\r\n            });\r\n            throw error;\r\n        });\r\n        // Cache the fetch, but clear it on the next event loop\r\n        if (cache) {\r\n            this._cache[method] = result;\r\n            setTimeout(() => {\r\n                // @ts-ignore - This is done by ethers.\r\n                this._cache[method] = null;\r\n            }, 0);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Overrides the base `Formatter` class inherited from ethers to support\r\n     * returning custom fields in Ethers response types.\r\n     *\r\n     * For context, ethers has a `Formatter` class that is used to format the\r\n     * response from a JSON-RPC request. Any fields that are not defined in the\r\n     * `Formatter` class are removed from the returned response. By modifying the\r\n     * `Formatter` class in this method, we can add support for fields that are\r\n     * not defined in ethers.\r\n     */\r\n    modifyFormatter() {\r\n        this.formatter.formats['receiptLog']['removed'] = val => {\r\n            if (typeof val === 'boolean') {\r\n                return val;\r\n            }\r\n            return undefined;\r\n        };\r\n    }\r\n}\r\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * Original code copied over from ether.js's\r\n * `@ethersproject/web/src.ts/index.ts`. Used to support\r\n * {@link AlchemyProvider._send}, which is also copied over.\r\n */\r\nfunction getResult(payload) {\r\n    if (payload.error) {\r\n        const error = new Error(payload.error.message);\r\n        error.code = payload.error.code;\r\n        error.data = payload.error.data;\r\n        throw error;\r\n    }\r\n    return payload.result;\r\n}\n\nexport { AlchemyProvider };\n//# sourceMappingURL=alchemy-provider-0066b792.js.map\n","import { _ as __awaiter, f as fromHex, t as toHex, n as noop, C as CustomNetworks, i as isAlchemyEvent, v as verifyAlchemyEventName, c as EthersEvent, e as getAlchemyEventTag, D as DEFAULT_ALCHEMY_API_KEY, A as ALCHEMY_EVENT_TYPES, h as ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE, j as AlchemySubscription, k as ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE, V as VERSION, E as EthersNetwork } from './index-643dc9bc.js';\nimport SturdyWebSocket from 'sturdy-websocket';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { getNetwork } from '@ethersproject/networks';\nimport { WebSocketProvider } from '@ethersproject/providers';\nimport { AlchemyProvider } from './alchemy-provider-0066b792.js';\nimport './api/utils';\nimport 'axios';\nimport '@ethersproject/abstract-provider';\nimport '@ethersproject/wallet';\nimport '@ethersproject/contracts';\nimport '@ethersproject/web';\n\n/**\r\n * The maximum number of blocks to backfill. If more than this many blocks have\r\n * been missed, then we'll sadly miss data, but we want to make sure we don't\r\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\r\n */\r\nconst MAX_BACKFILL_BLOCKS = 120;\r\n/**\r\n * The WebsocketBackfiller fetches events that were sent since a provided block\r\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\r\n * events that were transmitted while the websocket connection was down.\r\n *\r\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\r\n *\r\n * @internal\r\n */\r\nclass WebsocketBackfiller {\r\n    constructor(provider) {\r\n        this.provider = provider;\r\n        // TODO: Use HTTP provider to do backfill.\r\n        this.maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\r\n    }\r\n    /**\r\n     * Runs backfill for `newHeads` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param previousHeads Previous head requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     * @returns A list of `newHeads` events that were sent since the last backfill.\r\n     */\r\n    getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous heads to fetch, return new heads since\r\n            // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\r\n            if (previousHeads.length === 0) {\r\n                return this.getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted event is too far back in the past, there's no need\r\n            // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\r\n            // new heads.\r\n            const lastSeenBlockNumber = fromHex(previousHeads[previousHeads.length - 1].number);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber <= minBlockNumber) {\r\n                return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // To capture all `newHeads` events, return all head events from the last\r\n            // seen block number to current + any of the previous heads that were re-orged.\r\n            const reorgHeads = yield this.getReorgHeads(isCancelled, previousHeads);\r\n            throwIfCancelled(isCancelled);\r\n            const intermediateHeads = yield this.getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1);\r\n            throwIfCancelled(isCancelled);\r\n            return [...reorgHeads, ...intermediateHeads];\r\n        });\r\n    }\r\n    /**\r\n     * Runs backfill for `logs` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param filter The filter object that accompanies a logs subscription.\r\n     * @param previousLogs Previous log requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     */\r\n    getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous logs to fetch, return new logs since\r\n            // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\r\n            if (previousLogs.length === 0) {\r\n                return this.getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted log is too far back in the past, there's no need\r\n            // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\r\n            // worth of logs.\r\n            const lastSeenBlockNumber = fromHex(previousLogs[previousLogs.length - 1].blockNumber);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber < minBlockNumber) {\r\n                return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // Return all log events that have happened along with log events that have\r\n            // been removed due to a chain reorg.\r\n            const commonAncestor = yield this.getCommonAncestor(isCancelled, previousLogs);\r\n            throwIfCancelled(isCancelled);\r\n            // All previous logs with a block number greater than the common ancestor\r\n            // were part of a re-org, so mark them as such.\r\n            const removedLogs = previousLogs\r\n                .filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber)\r\n                .map(log => (Object.assign(Object.assign({}, log), { removed: true })));\r\n            // If no common ancestor was found, start backfill from the oldest log's\r\n            // block number.\r\n            const fromBlockInclusive = commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\r\n                ? fromHex(previousLogs[0].blockNumber)\r\n                : commonAncestor.blockNumber;\r\n            let addedLogs = yield this.getLogsInRange(filter, fromBlockInclusive, toBlockNumber + 1);\r\n            // De-dupe any logs that were already emitted.\r\n            addedLogs = addedLogs.filter(log => log &&\r\n                (fromHex(log.blockNumber) > commonAncestor.blockNumber ||\r\n                    fromHex(log.logIndex) > commonAncestor.logIndex));\r\n            throwIfCancelled(isCancelled);\r\n            return [...removedLogs, ...addedLogs];\r\n        });\r\n    }\r\n    /**\r\n     * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */\r\n    setMaxBackfillBlock(newMax) {\r\n        this.maxBackfillBlocks = newMax;\r\n    }\r\n    /**\r\n     * Gets the current block number as a number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockNumber() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const blockNumberHex = yield this.provider.send('eth_blockNumber');\r\n            return fromHex(blockNumberHex);\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `newHead` events in the provided range. Note that the returned\r\n     * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\r\n     * that were part of a re-org.\r\n     *\r\n     * @private\r\n     */\r\n    getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const batchParts = [];\r\n            for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\r\n                batchParts.push({\r\n                    method: 'eth_getBlockByNumber',\r\n                    params: [toHex(i), false]\r\n                });\r\n            }\r\n            // TODO: handle errors\r\n            const blockHeads = yield this.provider.sendBatch(batchParts);\r\n            return blockHeads.map(toNewHeadsEvent);\r\n        });\r\n    }\r\n    /**\r\n     * Returns all heads that were part of a reorg event.\r\n     *\r\n     * @private\r\n     */\r\n    getReorgHeads(isCancelled, previousHeads) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const result = [];\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            for (let i = previousHeads.length - 1; i >= 0; i--) {\r\n                const oldEvent = previousHeads[i];\r\n                const blockHead = yield this.getBlockByNumber(fromHex(oldEvent.number));\r\n                throwIfCancelled(isCancelled);\r\n                // If the hashes match, then current head in the iteration was not re-orged.\r\n                if (oldEvent.hash === blockHead.hash) {\r\n                    break;\r\n                }\r\n                result.push(toNewHeadsEvent(blockHead));\r\n            }\r\n            return result.reverse();\r\n        });\r\n    }\r\n    /**\r\n     * Simple wrapper around `eth_getBlockByNumber` that returns the complete\r\n     * block information for the provided block number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockByNumber(blockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this.provider.send('eth_getBlockByNumber', [\r\n                toHex(blockNumber),\r\n                false\r\n            ]);\r\n        });\r\n    }\r\n    /**\r\n     * Given a list of previous log events, finds the common block number from the\r\n     * logs that matches the block head.\r\n     *\r\n     * This can be used to identify which logs are part of a re-org.\r\n     *\r\n     * Returns 1 less than the oldest log's block number if no common ancestor was found.\r\n     *\r\n     * @private\r\n     */\r\n    getCommonAncestor(isCancelled, previousLogs) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            let blockHead = yield this.getBlockByNumber(fromHex(previousLogs[previousLogs.length - 1].blockNumber));\r\n            throwIfCancelled(isCancelled);\r\n            for (let i = previousLogs.length - 1; i >= 0; i--) {\r\n                const oldLog = previousLogs[i];\r\n                // Ensure that updated blocks are fetched every time the log's block number\r\n                // changes.\r\n                if (oldLog.blockNumber !== blockHead.number) {\r\n                    blockHead = yield this.getBlockByNumber(fromHex(oldLog.blockNumber));\r\n                }\r\n                // Since logs are ordered in ascending order, the first log that matches\r\n                // the hash should be the largest logIndex.\r\n                if (oldLog.blockHash === blockHead.hash) {\r\n                    return {\r\n                        blockNumber: fromHex(oldLog.blockNumber),\r\n                        logIndex: fromHex(oldLog.logIndex)\r\n                    };\r\n                }\r\n            }\r\n            return {\r\n                blockNumber: Number.NEGATIVE_INFINITY,\r\n                logIndex: Number.NEGATIVE_INFINITY\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `logs` events in the provided range. Note that the returned logs\r\n     * do not include removed logs.\r\n     *\r\n     * @private\r\n     */ getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const rangeFilter = Object.assign(Object.assign({}, filter), { fromBlock: toHex(fromBlockInclusive), toBlock: toHex(toBlockExclusive - 1) });\r\n            return this.provider.send('eth_getLogs', [rangeFilter]);\r\n        });\r\n    }\r\n}\r\nfunction toNewHeadsEvent(head) {\r\n    const result = Object.assign({}, head);\r\n    delete result.totalDifficulty;\r\n    delete result.transactions;\r\n    delete result.uncles;\r\n    return result;\r\n}\r\nfunction dedupeNewHeads(events) {\r\n    return dedupe(events, event => event.hash);\r\n}\r\nfunction dedupeLogs(events) {\r\n    return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\r\n}\r\nfunction dedupe(items, getKey) {\r\n    const keysSeen = new Set();\r\n    const result = [];\r\n    items.forEach(item => {\r\n        const key = getKey(item);\r\n        if (!keysSeen.has(key)) {\r\n            keysSeen.add(key);\r\n            result.push(item);\r\n        }\r\n    });\r\n    return result;\r\n}\r\nconst CANCELLED = new Error('Cancelled');\r\nfunction throwIfCancelled(isCancelled) {\r\n    if (isCancelled()) {\r\n        throw CANCELLED;\r\n    }\r\n}\n\nconst HEARTBEAT_INTERVAL = 30000;\r\nconst HEARTBEAT_WAIT_TIME = 10000;\r\nconst BACKFILL_TIMEOUT = 60000;\r\nconst BACKFILL_RETRIES = 5;\r\n/**\r\n * Subscriptions have a memory of recent events they have sent so that in the\r\n * event that they disconnect and need to backfill, they can detect re-orgs.\r\n * Keep a buffer that goes back at least these many blocks, the maximum amount\r\n * at which we might conceivably see a re-org.\r\n *\r\n * Note that while our buffer goes back this many blocks, it may contain more\r\n * than this many elements, since in the case of logs subscriptions more than\r\n * one event may be emitted for a block.\r\n */\r\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\r\n/**\r\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\r\n *\r\n * @public\r\n */\r\nclass AlchemyWebSocketProvider extends WebSocketProvider {\r\n    /** @internal */\r\n    constructor(config, wsConstructor) {\r\n        var _a;\r\n        // Normalize the API Key to a string.\r\n        const apiKey = AlchemyProvider.getApiKey(config.apiKey);\r\n        // Generate our own connection info with the correct endpoint URLs.\r\n        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\r\n        const connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'wss');\r\n        const protocol = `alchemy-sdk-${VERSION}`;\r\n        // Use the provided config URL override if it exists, otherwise use the created one.\r\n        const ws = new SturdyWebSocket((_a = config.url) !== null && _a !== void 0 ? _a : connection.url, protocol, {\r\n            wsConstructor: wsConstructor !== null && wsConstructor !== void 0 ? wsConstructor : getWebsocketConstructor()\r\n        });\r\n        // Normalize the Alchemy named network input to the network names used by\r\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\r\n        // correctly set the network.\r\n        const ethersNetwork = EthersNetwork[alchemyNetwork];\r\n        super(ws, ethersNetwork !== null && ethersNetwork !== void 0 ? ethersNetwork : undefined);\r\n        this._events = [];\r\n        // In the case of a WebSocket reconnection, all subscriptions are lost and we\r\n        // create new ones to replace them, but we want to create the illusion that\r\n        // the original subscriptions persist. Thus, maintain a mapping from the\r\n        // \"virtual\" subscription ids which are visible to the consumer to the\r\n        // \"physical\" subscription ids of the actual connections. This terminology is\r\n        // borrowed from virtual and physical memory, which has a similar mapping.\r\n        /** @internal */\r\n        this.virtualSubscriptionsById = new Map();\r\n        /** @internal */\r\n        this.virtualIdsByPhysicalId = new Map();\r\n        /**\r\n         * The underlying ethers {@link WebSocketProvider} already handles and emits\r\n         * messages. To allow backfilling, track all messages that are emitted.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleMessage = (event) => {\r\n            const message = JSON.parse(event.data);\r\n            if (!isSubscriptionEvent(message)) {\r\n                return;\r\n            }\r\n            const physicalId = message.params.subscription;\r\n            const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\r\n            if (!virtualId) {\r\n                return;\r\n            }\r\n            const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n            if (subscription.method !== 'eth_subscribe') {\r\n                return;\r\n            }\r\n            switch (subscription.params[0]) {\r\n                case 'newHeads': {\r\n                    const newHeadsSubscription = subscription;\r\n                    const newHeadsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = newHeadsSubscription;\r\n                    const { result } = newHeadsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToNewHeadsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    else {\r\n                        // Ethers subscription mapping will emit the event, just store it.\r\n                        this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                case 'logs': {\r\n                    const logsSubscription = subscription;\r\n                    const logsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = logsSubscription;\r\n                    const { result } = logsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToLogsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (virtualId !== physicalId) {\r\n                        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    else {\r\n                        this.rememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        const { result } = message.params;\r\n                        this.emitEvent(virtualId, result);\r\n                    }\r\n            }\r\n        };\r\n        /**\r\n         * When the websocket connection reopens:\r\n         *\r\n         * 1. Resubscribe to all existing subscriptions and start backfilling\r\n         * 2. Restart heart beat.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleReopen = () => {\r\n            this.virtualIdsByPhysicalId.clear();\r\n            const { cancel, isCancelled } = makeCancelToken();\r\n            this.cancelBackfill = cancel;\r\n            for (const subscription of this.virtualSubscriptionsById.values()) {\r\n                void (() => __awaiter(this, void 0, void 0, function* () {\r\n                    try {\r\n                        yield this.resubscribeAndBackfill(isCancelled, subscription);\r\n                    }\r\n                    catch (error) {\r\n                        if (!isCancelled()) {\r\n                            console.error(`Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`, error);\r\n                        }\r\n                    }\r\n                }))();\r\n            }\r\n            this.startHeartbeat();\r\n        };\r\n        /**\r\n         * Cancels the heartbeat and any pending backfills being performed. This is\r\n         * called when the websocket connection goes down or is disconnected.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.stopHeartbeatAndBackfill = () => {\r\n            if (this.heartbeatIntervalId != null) {\r\n                clearInterval(this.heartbeatIntervalId);\r\n                this.heartbeatIntervalId = undefined;\r\n            }\r\n            this.cancelBackfill();\r\n        };\r\n        this.apiKey = apiKey;\r\n        // Start heartbeat and backfiller for the websocket connection.\r\n        this.backfiller = new WebsocketBackfiller(this);\r\n        this.addSocketListeners();\r\n        this.startHeartbeat();\r\n        this.cancelBackfill = noop;\r\n    }\r\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getNetwork(network) {\r\n        if (typeof network === 'string' && network in CustomNetworks) {\r\n            return CustomNetworks[network];\r\n        }\r\n        // Call the standard ethers.js getNetwork method for other networks.\r\n        return getNetwork(network);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based subscriptions.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    on(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, false);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based\r\n     * subscriptions. Adds a listener to the triggered for only the next\r\n     * {@link eventName} event, after which it will be removed.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    once(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, true);\r\n    }\r\n    /**\r\n     * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n     * listener is provided, all listeners for the event will be removed.\r\n     *\r\n     * @param eventName Event to unlisten to.\r\n     * @param listener The listener function to remove.\r\n     * @override\r\n     * @public\r\n     */\r\n    off(eventName, listener) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            return this._off(eventName, listener);\r\n        }\r\n        else {\r\n            return super.off(eventName, listener);\r\n        }\r\n    }\r\n    /**\r\n     * Remove all listeners for the provided {@link eventName} event. If no event\r\n     * is provided, all events and their listeners are removed.\r\n     *\r\n     * @param eventName The event to remove all listeners for.\r\n     * @override\r\n     * @public\r\n     */\r\n    removeAllListeners(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._removeAllListeners(eventName);\r\n        }\r\n        else {\r\n            return super.removeAllListeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the number of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, the total number of listeners for all events is returned.\r\n     *\r\n     * @param eventName The event to get the number of listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listenerCount(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._listenerCount(eventName);\r\n        }\r\n        else {\r\n            return super.listenerCount(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns an array of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, all listeners will be included.\r\n     *\r\n     * @param eventName The event to get the listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listeners(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._listeners(eventName);\r\n        }\r\n        else {\r\n            return super.listeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the method in `BaseProvider` in order to properly format the\r\n     * Alchemy subscription events.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _addEventListener(eventName, listener, once) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            verifyAlchemyEventName(eventName);\r\n            const event = new EthersEvent(getAlchemyEventTag(eventName), listener, once);\r\n            this._events.push(event);\r\n            this._startEvent(event);\r\n            return this;\r\n        }\r\n        else {\r\n            return super._addEventListener(eventName, listener, once);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the `_startEvent()` method in ethers.js's\r\n     * {@link WebSocketProvider} to include additional alchemy methods.\r\n     *\r\n     * @param event\r\n     * @override\r\n     * @internal\r\n     */\r\n    _startEvent(event) {\r\n        // Check if the event type is a custom Alchemy subscription.\r\n        const customLogicTypes = [...ALCHEMY_EVENT_TYPES, 'block', 'filter'];\r\n        if (customLogicTypes.includes(event.type)) {\r\n            this.customStartEvent(event);\r\n        }\r\n        else {\r\n            super._startEvent(event);\r\n        }\r\n    }\r\n    /**\r\n     * Overridden from ethers.js's {@link WebSocketProvider}\r\n     *\r\n     * Modified in order to add mappings for backfilling.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _subscribe(tag, param, processFunc, event) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let subIdPromise = this._subIds[tag];\r\n            // BEGIN MODIFIED CODE\r\n            const startingBlockNumber = yield this.getBlockNumber();\r\n            // END MODIFIED CODE\r\n            if (subIdPromise == null) {\r\n                subIdPromise = Promise.all(param).then(param => {\r\n                    return this.send('eth_subscribe', param);\r\n                });\r\n                this._subIds[tag] = subIdPromise;\r\n            }\r\n            const subId = yield subIdPromise;\r\n            // BEGIN MODIFIED CODE\r\n            const resolvedParams = yield Promise.all(param);\r\n            this.virtualSubscriptionsById.set(subId, {\r\n                event: event,\r\n                method: 'eth_subscribe',\r\n                params: resolvedParams,\r\n                startingBlockNumber,\r\n                virtualId: subId,\r\n                physicalId: subId,\r\n                sentEvents: [],\r\n                isBackfilling: false,\r\n                backfillBuffer: []\r\n            });\r\n            this.virtualIdsByPhysicalId.set(subId, subId);\r\n            // END MODIFIED CODE\r\n            this._subs[subId] = { tag, processFunc };\r\n        });\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    emit(eventName, ...args) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            let result = false;\r\n            const stopped = [];\r\n            // This line is the only modified line from the original method.\r\n            const eventTag = getAlchemyEventTag(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                setTimeout(() => {\r\n                    event.listener.apply(this, args);\r\n                }, 0);\r\n                result = true;\r\n                if (event.once) {\r\n                    stopped.push(event);\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n            stopped.forEach(event => {\r\n                this._stopEvent(event);\r\n            });\r\n            return result;\r\n        }\r\n        else {\r\n            return super.emit(eventName, ...args);\r\n        }\r\n    }\r\n    /** @internal */\r\n    sendBatch(parts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let nextId = 0;\r\n            const payload = parts.map(({ method, params }) => {\r\n                return {\r\n                    method,\r\n                    params,\r\n                    jsonrpc: '2.0',\r\n                    id: `alchemy-sdk:${nextId++}`\r\n                };\r\n            });\r\n            return this.sendBatchConcurrently(payload);\r\n        });\r\n    }\r\n    /** @override */\r\n    destroy() {\r\n        this.removeSocketListeners();\r\n        this.stopHeartbeatAndBackfill();\r\n        return super.destroy();\r\n    }\r\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\r\n    isCommunityResource() {\r\n        return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\r\n     *\r\n     * This method is copied over directly in order to support Alchemy's\r\n     * subscription type by allowing the provider to properly stop Alchemy's\r\n     * subscription events.\r\n     *\r\n     * @internal\r\n     */\r\n    _stopEvent(event) {\r\n        let tag = event.tag;\r\n        // START MODIFIED CODE\r\n        if (ALCHEMY_EVENT_TYPES.includes(event.type)) {\r\n            // There are remaining pending transaction listeners.\r\n            if (this._events.filter(e => ALCHEMY_EVENT_TYPES.includes(e.type)).length) {\r\n                return;\r\n            }\r\n            // END MODIFIED CODE\r\n        }\r\n        else if (event.type === 'tx') {\r\n            // There are remaining transaction event listeners\r\n            if (this._events.filter(e => e.type === 'tx').length) {\r\n                return;\r\n            }\r\n            tag = 'tx';\r\n        }\r\n        else if (this.listenerCount(event.event)) {\r\n            // There are remaining event listeners\r\n            return;\r\n        }\r\n        const subId = this._subIds[tag];\r\n        if (!subId) {\r\n            return;\r\n        }\r\n        delete this._subIds[tag];\r\n        void subId.then(subId => {\r\n            if (!this._subs[subId]) {\r\n                return;\r\n            }\r\n            delete this._subs[subId];\r\n            void this.send('eth_unsubscribe', [subId]);\r\n        });\r\n    }\r\n    /** @internal */\r\n    addSocketListeners() {\r\n        this._websocket.addEventListener('message', this.handleMessage);\r\n        this._websocket.addEventListener('reopen', this.handleReopen);\r\n        this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /** @internal */\r\n    removeSocketListeners() {\r\n        this._websocket.removeEventListener('message', this.handleMessage);\r\n        this._websocket.removeEventListener('reopen', this.handleReopen);\r\n        this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /**\r\n     * Reopens the backfill based on\r\n     *\r\n     * @param isCancelled\r\n     * @param subscription\r\n     * @internal\r\n     */\r\n    resubscribeAndBackfill(isCancelled, subscription) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { virtualId, method, params, sentEvents, backfillBuffer, startingBlockNumber } = subscription;\r\n            subscription.isBackfilling = true;\r\n            backfillBuffer.length = 0;\r\n            try {\r\n                const physicalId = yield this.send(method, params);\r\n                throwIfCancelled(isCancelled);\r\n                subscription.physicalId = physicalId;\r\n                this.virtualIdsByPhysicalId.set(physicalId, virtualId);\r\n                switch (params[0]) {\r\n                    case 'newHeads': {\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    case 'logs': {\r\n                        const filter = params[1] || {};\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getLogsBackfill(isCancelled, filter, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitLogsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n            finally {\r\n                subscription.isBackfilling = false;\r\n                backfillBuffer.length = 0;\r\n            }\r\n        });\r\n    }\r\n    /** @internal */\r\n    emitNewHeadsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitLogsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n    }\r\n    /**\r\n     * Emits an event to consumers, but also remembers it in its subscriptions's\r\n     * `sentEvents` buffer so that we can detect re-orgs if the connection drops\r\n     * and needs to be reconnected.\r\n     *\r\n     * @internal\r\n     */\r\n    emitAndRememberEvent(virtualId, result, getBlockNumber) {\r\n        this.rememberEvent(virtualId, result, getBlockNumber);\r\n        this.emitEvent(virtualId, result);\r\n    }\r\n    emitEvent(virtualId, result) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        this.emitGenericEvent(subscription, result);\r\n    }\r\n    /** @internal */\r\n    rememberEvent(virtualId, result, getBlockNumber) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        // Web3 modifies these event objects once we pass them on (changing hex\r\n        // numbers to numbers). We want the original event, so make a defensive\r\n        // copy.\r\n        addToPastEventsBuffer(subscription.sentEvents, Object.assign({}, result), getBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitGenericEvent(subscription, result) {\r\n        const emitFunction = this.emitProcessFn(subscription.event);\r\n        emitFunction(result);\r\n    }\r\n    /**\r\n     * Starts a heartbeat that pings the websocket server periodically to ensure\r\n     * that the connection stays open.\r\n     *\r\n     * @internal\r\n     */\r\n    startHeartbeat() {\r\n        if (this.heartbeatIntervalId != null) {\r\n            return;\r\n        }\r\n        this.heartbeatIntervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                yield withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\r\n            }\r\n            catch (_a) {\r\n                this._websocket.reconnect();\r\n            }\r\n        }), HEARTBEAT_INTERVAL);\r\n    }\r\n    /**\r\n     * This method sends the batch concurrently as individual requests rather than\r\n     * as a batch, which was the original implementation. The original batch logic\r\n     * is preserved in this implementation in order for faster porting.\r\n     *\r\n     * @param payload\r\n     * @internal\r\n     */\r\n    // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\r\n    // TODO(errors): Use allSettled() once we have more error handling.\r\n    sendBatchConcurrently(payload) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return Promise.all(payload.map(req => this.send(req.method, req.params)));\r\n        });\r\n    }\r\n    /** @internal */\r\n    customStartEvent(event) {\r\n        if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\r\n            const { fromAddress, toAddress, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                AlchemySubscription.PENDING_TRANSACTIONS,\r\n                { fromAddress, toAddress, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\r\n            const { addresses, includeRemoved, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                AlchemySubscription.MINED_TRANSACTIONS,\r\n                { addresses, includeRemoved, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'block') {\r\n            void this._subscribe('block', ['newHeads'], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'filter') {\r\n            void this._subscribe(event.tag, ['logs', this._getFilter(event.filter)], this.emitProcessFn(event), event);\r\n        }\r\n    }\r\n    /** @internal */\r\n    emitProcessFn(event) {\r\n        switch (event.type) {\r\n            case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\r\n                return result => this.emit({\r\n                    method: AlchemySubscription.PENDING_TRANSACTIONS,\r\n                    fromAddress: event.fromAddress,\r\n                    toAddress: event.toAddress,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\r\n                return result => this.emit({\r\n                    method: AlchemySubscription.MINED_TRANSACTIONS,\r\n                    addresses: event.addresses,\r\n                    includeRemoved: event.includeRemoved,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case 'block':\r\n                return result => {\r\n                    const blockNumber = BigNumber.from(result.number).toNumber();\r\n                    this._emitted.block = blockNumber;\r\n                    this.emit('block', blockNumber);\r\n                };\r\n            case 'filter':\r\n                return result => {\r\n                    if (result.removed == null) {\r\n                        result.removed = false;\r\n                    }\r\n                    this.emit(event.filter, this.formatter.filterLog(result));\r\n                };\r\n            default:\r\n                throw new Error('Invalid event type to `emitProcessFn()`');\r\n        }\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.off()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _off(eventName, listener) {\r\n        if (listener == null) {\r\n            return this.removeAllListeners(eventName);\r\n        }\r\n        const stopped = [];\r\n        let found = false;\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        this._events = this._events.filter(event => {\r\n            if (event.tag !== eventTag || event.listener != listener) {\r\n                return true;\r\n            }\r\n            if (found) {\r\n                return true;\r\n            }\r\n            found = true;\r\n            stopped.push(event);\r\n            return false;\r\n        });\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _removeAllListeners(eventName) {\r\n        let stopped = [];\r\n        if (eventName == null) {\r\n            stopped = this._events;\r\n            this._events = [];\r\n        }\r\n        else {\r\n            const eventTag = getAlchemyEventTag(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                stopped.push(event);\r\n                return false;\r\n            });\r\n        }\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listenerCount(eventName) {\r\n        if (!eventName) {\r\n            return this._events.length;\r\n        }\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        return this._events.filter(event => {\r\n            return event.tag === eventTag;\r\n        }).length;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listeners(eventName) {\r\n        if (eventName == null) {\r\n            return this._events.map(event => event.listener);\r\n        }\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        return this._events\r\n            .filter(event => event.tag === eventTag)\r\n            .map(event => event.listener);\r\n    }\r\n}\r\nfunction getWebsocketConstructor() {\r\n    return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\r\n}\r\nfunction isNodeEnvironment() {\r\n    return (typeof process !== 'undefined' &&\r\n        process != null &&\r\n        process.versions != null &&\r\n        process.versions.node != null);\r\n}\r\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\r\nfunction makeCancelToken() {\r\n    let cancelled = false;\r\n    return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\r\n}\r\n// TODO(cleanup): replace with SDK's backoff implementation\r\nconst MIN_RETRY_DELAY = 1000;\r\nconst RETRY_BACKOFF_FACTOR = 2;\r\nconst MAX_RETRY_DELAY = 30000;\r\nfunction withBackoffRetries(f, retryCount, shouldRetry = () => true) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let nextWaitTime = 0;\r\n        let i = 0;\r\n        while (true) {\r\n            try {\r\n                return yield f();\r\n            }\r\n            catch (error) {\r\n                i++;\r\n                if (i >= retryCount || !shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                yield delay(nextWaitTime);\r\n                if (!shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                nextWaitTime =\r\n                    nextWaitTime === 0\r\n                        ? MIN_RETRY_DELAY\r\n                        : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction delay(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\nfunction withTimeout(promise, ms) {\r\n    return Promise.race([\r\n        promise,\r\n        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), ms))\r\n    ]);\r\n}\r\nfunction getNewHeadsBlockNumber(event) {\r\n    return fromHex(event.number);\r\n}\r\nfunction getLogsBlockNumber(event) {\r\n    return fromHex(event.blockNumber);\r\n}\r\nfunction isResponse(message) {\r\n    return (Array.isArray(message) ||\r\n        (message.jsonrpc === '2.0' && message.id !== undefined));\r\n}\r\nfunction isSubscriptionEvent(message) {\r\n    return !isResponse(message);\r\n}\r\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\r\n}\r\nfunction addToLogsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\r\n}\r\n/**\r\n * Adds a new event to an array of events, evicting any events which are so old\r\n * that they will no longer feasibly be part of a reorg.\r\n */\r\nfunction addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\r\n    const currentBlockNumber = getBlockNumber(event);\r\n    // Find first index of an event recent enough to retain, then drop everything\r\n    // at a lower index.\r\n    const firstGoodIndex = pastEvents.findIndex(e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT);\r\n    if (firstGoodIndex === -1) {\r\n        pastEvents.length = 0;\r\n    }\r\n    else {\r\n        pastEvents.splice(0, firstGoodIndex);\r\n    }\r\n    pastEvents.push(event);\r\n}\n\nexport { AlchemyWebSocketProvider };\n//# sourceMappingURL=alchemy-websocket-provider-98da5bb0.js.map\n","'use strict'\nvar ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'\n\n// pre-compute lookup table\nvar ALPHABET_MAP = {}\nfor (var z = 0; z < ALPHABET.length; z++) {\n  var x = ALPHABET.charAt(z)\n\n  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')\n  ALPHABET_MAP[x] = z\n}\n\nfunction polymodStep (pre) {\n  var b = pre >> 25\n  return ((pre & 0x1FFFFFF) << 5) ^\n    (-((b >> 0) & 1) & 0x3b6a57b2) ^\n    (-((b >> 1) & 1) & 0x26508e6d) ^\n    (-((b >> 2) & 1) & 0x1ea119fa) ^\n    (-((b >> 3) & 1) & 0x3d4233dd) ^\n    (-((b >> 4) & 1) & 0x2a1462b3)\n}\n\nfunction prefixChk (prefix) {\n  var chk = 1\n  for (var i = 0; i < prefix.length; ++i) {\n    var c = prefix.charCodeAt(i)\n    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'\n\n    chk = polymodStep(chk) ^ (c >> 5)\n  }\n  chk = polymodStep(chk)\n\n  for (i = 0; i < prefix.length; ++i) {\n    var v = prefix.charCodeAt(i)\n    chk = polymodStep(chk) ^ (v & 0x1f)\n  }\n  return chk\n}\n\nfunction encode (prefix, words, LIMIT) {\n  LIMIT = LIMIT || 90\n  if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')\n\n  prefix = prefix.toLowerCase()\n\n  // determine chk mod\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') throw new Error(chk)\n\n  var result = prefix + '1'\n  for (var i = 0; i < words.length; ++i) {\n    var x = words[i]\n    if ((x >> 5) !== 0) throw new Error('Non 5-bit word')\n\n    chk = polymodStep(chk) ^ x\n    result += ALPHABET.charAt(x)\n  }\n\n  for (i = 0; i < 6; ++i) {\n    chk = polymodStep(chk)\n  }\n  chk ^= 1\n\n  for (i = 0; i < 6; ++i) {\n    var v = (chk >> ((5 - i) * 5)) & 0x1f\n    result += ALPHABET.charAt(v)\n  }\n\n  return result\n}\n\nfunction __decode (str, LIMIT) {\n  LIMIT = LIMIT || 90\n  if (str.length < 8) return str + ' too short'\n  if (str.length > LIMIT) return 'Exceeds length limit'\n\n  // don't allow mixed case\n  var lowered = str.toLowerCase()\n  var uppered = str.toUpperCase()\n  if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str\n  str = lowered\n\n  var split = str.lastIndexOf('1')\n  if (split === -1) return 'No separator character for ' + str\n  if (split === 0) return 'Missing prefix for ' + str\n\n  var prefix = str.slice(0, split)\n  var wordChars = str.slice(split + 1)\n  if (wordChars.length < 6) return 'Data too short'\n\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') return chk\n\n  var words = []\n  for (var i = 0; i < wordChars.length; ++i) {\n    var c = wordChars.charAt(i)\n    var v = ALPHABET_MAP[c]\n    if (v === undefined) return 'Unknown character ' + c\n    chk = polymodStep(chk) ^ v\n\n    // not in the checksum?\n    if (i + 6 >= wordChars.length) continue\n    words.push(v)\n  }\n\n  if (chk !== 1) return 'Invalid checksum for ' + str\n  return { prefix: prefix, words: words }\n}\n\nfunction decodeUnsafe () {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n}\n\nfunction decode (str) {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n\n  throw new Error(res)\n}\n\nfunction convert (data, inBits, outBits, pad) {\n  var value = 0\n  var bits = 0\n  var maxV = (1 << outBits) - 1\n\n  var result = []\n  for (var i = 0; i < data.length; ++i) {\n    value = (value << inBits) | data[i]\n    bits += inBits\n\n    while (bits >= outBits) {\n      bits -= outBits\n      result.push((value >> bits) & maxV)\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push((value << (outBits - bits)) & maxV)\n    }\n  } else {\n    if (bits >= inBits) return 'Excess padding'\n    if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'\n  }\n\n  return result\n}\n\nfunction toWordsUnsafe (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n}\n\nfunction toWords (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nfunction fromWordsUnsafe (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n}\n\nfunction fromWords (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nmodule.exports = {\n  decodeUnsafe: decodeUnsafe,\n  decode: decode,\n  encode: encode,\n  toWordsUnsafe: toWordsUnsafe,\n  toWords: toWords,\n  fromWordsUnsafe: fromWordsUnsafe,\n  fromWords: fromWords\n}\n","var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Fallback to standard globalThis if available\n\tif (typeof globalThis === \"object\" && globalThis) return globalThis;\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of updates to Object.prototype being restricted\n\t\t// via preventExtensions, seal or freeze\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ works, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\nvar SturdyWebSocket = /** @class */ (function () {\n    function SturdyWebSocket(url, protocolsOrOptions, options) {\n        if (options === void 0) { options = {}; }\n        this.url = url;\n        this.onclose = null;\n        this.onerror = null;\n        this.onmessage = null;\n        this.onopen = null;\n        this.ondown = null;\n        this.onreopen = null;\n        this.CONNECTING = SturdyWebSocket.CONNECTING;\n        this.OPEN = SturdyWebSocket.OPEN;\n        this.CLOSING = SturdyWebSocket.CLOSING;\n        this.CLOSED = SturdyWebSocket.CLOSED;\n        this.hasBeenOpened = false;\n        this.isClosed = false;\n        this.messageBuffer = [];\n        this.nextRetryTime = 0;\n        this.reconnectCount = 0;\n        this.lastKnownExtensions = \"\";\n        this.lastKnownProtocol = \"\";\n        this.listeners = {};\n        if (protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)) {\n            this.protocols = protocolsOrOptions;\n        }\n        else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            }\n            else {\n                throw new Error(\"WebSocket not present in global scope and no \" +\n                    \"wsConstructor option was provided.\");\n            }\n        }\n        this.openNewWebSocket();\n    }\n    Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n        get: function () {\n            return this.binaryTypeInternal || \"blob\";\n        },\n        set: function (binaryType) {\n            this.binaryTypeInternal = binaryType;\n            if (this.ws) {\n                this.ws.binaryType = binaryType;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n        get: function () {\n            var sum = this.ws ? this.ws.bufferedAmount : 0;\n            var hasUnknownAmount = false;\n            this.messageBuffer.forEach(function (data) {\n                var byteLength = getDataByteLength(data);\n                if (byteLength != null) {\n                    sum += byteLength;\n                }\n                else {\n                    hasUnknownAmount = true;\n                }\n            });\n            if (hasUnknownAmount) {\n                this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\");\n            }\n            return sum;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n        get: function () {\n            return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n        get: function () {\n            return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n        get: function () {\n            return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SturdyWebSocket.prototype.close = function (code, reason) {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    };\n    SturdyWebSocket.prototype.send = function (data) {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        }\n        else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        }\n        else {\n            this.messageBuffer.push(data);\n        }\n    };\n    SturdyWebSocket.prototype.reconnect = function () {\n        if (this.isClosed) {\n            throw new Error(\"Cannot call reconnect() on socket which is permanently closed.\");\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    };\n    SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    };\n    SturdyWebSocket.prototype.dispatchEvent = function (event) {\n        return this.dispatchEventOfType(event.type, event);\n    };\n    SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(function (l) { return l !== listener; });\n        }\n    };\n    SturdyWebSocket.prototype.openNewWebSocket = function () {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, connectTimeout = _a.connectTimeout, wsConstructor = _a.wsConstructor;\n        this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n        var ws = new wsConstructor(this.url, this.protocols);\n        ws.onclose = function (event) { return _this.handleClose(event); };\n        ws.onerror = function (event) { return _this.handleError(event); };\n        ws.onmessage = function (event) { return _this.handleMessage(event); };\n        ws.onopen = function (event) { return _this.handleOpen(event); };\n        this.connectTimeoutId = setTimeout(function () {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            _this.clearConnectTimeout();\n            _this.disposeSocket();\n            _this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    };\n    SturdyWebSocket.prototype.handleOpen = function (event) {\n        var _this = this;\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        var allClearResetTime = this.options.allClearResetTime;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        }\n        else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        }\n        else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(function (message) { return _this.send(message); });\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(function () {\n            _this.clearAllClearTimeout();\n            _this.nextRetryTime = 0;\n            _this.reconnectCount = 0;\n            var openTime = (allClearResetTime / 1000) | 0;\n            _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" +\n                \" retry time and count.\");\n        }, allClearResetTime);\n    };\n    SturdyWebSocket.prototype.handleMessage = function (event) {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    };\n    SturdyWebSocket.prototype.handleClose = function (event) {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, maxReconnectAttempts = _a.maxReconnectAttempts, shouldReconnect = _a.shouldReconnect;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n            return;\n        }\n        var willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n        }\n        else {\n            willReconnect.then(function (willReconnectResolved) {\n                if (_this.isClosed) {\n                    return;\n                }\n                _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n            });\n        }\n    };\n    SturdyWebSocket.prototype.handleError = function (event) {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    };\n    SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n        if (willReconnect) {\n            this.reestablishConnection();\n        }\n        else {\n            this.stopReconnecting(event, denialReason);\n        }\n    };\n    SturdyWebSocket.prototype.reestablishConnection = function () {\n        var _this = this;\n        var _a = this.options, minReconnectDelay = _a.minReconnectDelay, maxReconnectDelay = _a.maxReconnectDelay, reconnectBackoffFactor = _a.reconnectBackoffFactor;\n        this.reconnectCount++;\n        var retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n        setTimeout(function () { return _this.openNewWebSocket(); }, retryTime);\n        var retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n    };\n    SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    };\n    SturdyWebSocket.prototype.shutdown = function () {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    };\n    SturdyWebSocket.prototype.disposeSocket = function (closeCode, reason) {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    };\n    SturdyWebSocket.prototype.clearAllTimeouts = function () {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    };\n    SturdyWebSocket.prototype.clearConnectTimeout = function () {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n        var _this = this;\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(function (listener) { return _this.callListener(listener, event); });\n        }\n        return !event || !event.defaultPrevented;\n    };\n    SturdyWebSocket.prototype.callListener = function (listener, event) {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        }\n        else {\n            listener.handleEvent.call(this, event);\n        }\n    };\n    SturdyWebSocket.prototype.debugLog = function (message) {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    };\n    SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n        var maxReconnectAttempts = this.options.maxReconnectAttempts;\n        return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n    };\n    SturdyWebSocket.DEFAULT_OPTIONS = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: function () { return true; },\n        wsConstructor: undefined,\n    };\n    SturdyWebSocket.CONNECTING = 0;\n    SturdyWebSocket.OPEN = 1;\n    SturdyWebSocket.CLOSING = 2;\n    SturdyWebSocket.CLOSED = 3;\n    return SturdyWebSocket;\n}());\nexports.default = SturdyWebSocket;\nfunction applyDefaultOptions(options) {\n    var result = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(function (key) {\n        var value = options[key];\n        result[key] =\n            value === undefined\n                ? SturdyWebSocket.DEFAULT_OPTIONS[key]\n                : value;\n    });\n    return result;\n}\nfunction getDataByteLength(data) {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    }\n    else if (data instanceof Blob) {\n        return data.size;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction pluralize(s, n) {\n    return n === 1 ? s : s + \"s\";\n}\nfunction noop() {\n    // Nothing.\n}\n//# sourceMappingURL=index.js.map","var _globalThis;\nif (typeof globalThis === 'object') {\n\t_globalThis = globalThis;\n} else {\n\ttry {\n\t\t_globalThis = require('es5-ext/global');\n\t} catch (error) {\n\t} finally {\n\t\tif (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }\n\t\tif (!_globalThis) { throw new Error('Could not determine global this'); }\n\t}\n}\n\nvar NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\nvar websocket_version = require('./version');\n\n\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */\nfunction W3CWebSocket(uri, protocols) {\n\tvar native_instance;\n\n\tif (protocols) {\n\t\tnative_instance = new NativeWebSocket(uri, protocols);\n\t}\n\telse {\n\t\tnative_instance = new NativeWebSocket(uri);\n\t}\n\n\t/**\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t * class). Since it is an Object it will be returned as it is when creating an\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t *\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t */\n\treturn native_instance;\n}\nif (NativeWebSocket) {\n\t['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {\n\t\tObject.defineProperty(W3CWebSocket, prop, {\n\t\t\tget: function() { return NativeWebSocket[prop]; }\n\t\t});\n\t});\n}\n\n/**\n * Module exports.\n */\nmodule.exports = {\n    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,\n    'version'      : websocket_version\n};\n","module.exports = require('../package.json').version;\n"],"names":["decode","textData","atob","data","i","length","push","charCodeAt","arrayify","encode","String","fromCharCode","btoa","BaseX","constructor","alphabet","defineReadOnly","this","charAt","_alphabetMap","value","source","digits","carry","j","base","string","k","_leader","q","TypeError","bytes","Uint8Array","byte","undefined","Error","reverse","Base32","Base58","AddressZero","HashZero","flat","array","depth","result","forEach","flatDeep","arr","call","val","Array","isArray","fromEntries","decode_arithmetic","pos","u16","symbol_count","total","acc","skip","pos_payload","read_width","read_buffer","read_bit","N","FULL","Math","pow","HALF","QRTR","MASK","register","symbols","low","range","floor","start","end","mid","a","b","offset","map","x","read_payload","v","read_compressed_payload","signed","read_counts","n","next","read_ascending","read_deltas","read_member_array","lookup","vX","vN","read_mapped_map","ret","w","read_linear_table","read_replacement_table","read_zero_terminated_array","read_transposed","m","fill","dx","dy","ys","slice","_","j_dy","y","read_emoji_trie","sorted","sort","read","branches","keys","set","Set","node","size","temp","valid","fe0f","save","check","getData","r","VALID","IGNORED","MAPPED","EMOJI_ROOT","HYPHEN","UNDERSCORE","explode_cp","name","toUtf8CodePoints","filter_fe0f","cps","filter","cp","ens_normalize_post_check","label","split","lastIndexOf","every","err","message","ens_normalize","normalize","emoji_filter","input","output","emoji","consume_emoji_reversed","pop","has","toString","toUpperCase","nfc","fromCodePoint","s","eaten","_a","saved","stack","find","splice","logger","Logger","version","Zeros","checkComponent","comp","ensNameSplit","toUtf8Bytes","comps","last","d","ensNormalize","toUtf8String","join","isValidName","error","namehash","throwArgumentError","keccak256","concat","hexlify","dnsEncode","isRenetworkable","ethDefaultProvider","network","func","providers","options","providerList","InfuraProvider","infura","EtherscanProvider","etherscan","AlchemyProvider","alchemy","PocketProvider","pocket","provider","indexOf","CloudflareProvider","cloudflare","AnkrProvider","ankr","FallbackProvider","quorum","renetwork","etcDefaultProvider","url","JsonRpcProvider","homestead","chainId","ensAddress","_defaultProvider","ropsten","classicMordor","networks","unspecified","mainnet","morden","testnet","rinkeby","kovan","goerli","kintsugi","sepolia","classic","classicMorden","classicTestnet","classicKotti","xdai","matic","maticmum","optimism","arbitrum","bnb","bnbt","getNetwork","standard","defaultProvider","__awaiter","thisArg","_arguments","P","generator","adopt","resolve","Promise","reject","fulfilled","step","e","rejected","done","then","apply","MAX_CCIP_REDIRECTS","checkTopic","topic","hexDataLength","toLowerCase","serializeTopics","topics","unique","Object","deserializeTopics","getEventTag","eventName","ForkEvent","isForkEvent","warn","address","getTime","Date","stall","duration","setTimeout","PollableEvents","Event","tag","listener","once","_lastBlockNumber","_inflight","event","type","hash","pollable","coinInfos","symbol","p2pkh","p2sh","prefix","ilk","bytes32ify","hexZeroPad","BigNumber","from","toHexString","base58Encode","hexDataSlice","sha256","matcherIpfs","RegExp","matchers","_parseString","_parseBytes","toNumber","getIpfsLink","link","match","substring","numPad","padded","bytesPad","ceil","encodeBytes","datas","byteCount","hexConcat","Resolver","resolvedAddress","formatter","supportsWildcard","_supportsEip2544","to","eq","catch","code","errors","CALL_EXCEPTION","_fetch","selector","parameters","tx","ccipReadEnabled","parseBytes","throwError","transaction","_fetchBytes","_getAddress","coinType","hexBytes","coinInfo","UNSUPPORTED_OPERATION","operation","parseInt","words","unshift","getAddress","callAddress","getAvatar","linkage","content","avatar","getText","scheme","owner","_resolvedAddress","addr","tokenId","tokenOwner","balance","isZero","metadataUrl","replace","metadata","fetchJson","JSON","stringify","imageUrl","image","ipfs","getContentHash","ipns","swarm","skynet","urlSafe","key","keyBytes","defaultFormatter","nextPollId","BaseProvider","Provider","super","_events","_emitted","block","disableCcipRead","getFormatter","anyNetwork","detectNetwork","_networkPromise","_ready","knownNetwork","getStatic","emit","_maxInternalBlockNumber","_maxFilterBlockRange","_pollingInterval","_fastQueryDate","_network","UNKNOWN_ERROR","ready","poll","NETWORK_ERROR","Formatter","ccipReadFetch","calldata","urls","sender","errorMessages","href","json","errorPassThrough","response","status","statusCode","errorMessage","SERVER_ERROR","_getInternalBlockNumber","maxAge","_internalBlockNumber","internalBlockNumber","respTime","blockNumber","reqTime","checkInternalBlockNumber","resolveProperties","perform","networkError","_setFastBlockNumber","pollId","runners","pollingInterval","abs","makeError","previousBlockNumber","eventBlockNumber","runner","getTransactionReceipt","receipt","fromBlock","toBlock","minFromBlock","getLogs","logs","log","blockHash","transactionHash","all","resetEventsBlock","polling","currentNetwork","_fastBlockNumber","_fastBlockNumberPromise","detectedNetwork","_poller","setInterval","_bootstrapPoll","clearInterval","_getFastBlockNumber","now","getBlockNumber","waitForTransaction","confirmations","timeout","_waitForTransaction","replaceable","cancelFuncs","alreadyDone","minedHandler","on","removeListener","lastBlockNumber","startBlock","scannedBlock","replaceHandler","getTransactionCount","nonce","mined","getTransaction","getBlockWithTransactions","ti","transactions","reason","TRANSACTION_REPLACED","cancelled","replacement","_wrapTransaction","timer","TIMEOUT","unref","clearTimeout","getGasPrice","method","getBalance","addressOrName","blockTag","params","_getBlockTag","getCode","getStorageAt","position","p","hexValue","expectedHash","returnedHash","wait","confirms","sendTransaction","signedTransaction","hexTx","t","_getTransactionRequest","values","accessList","transactionRequest","_getFilter","_call","attempt","redirects","txSender","signature","urlsOffset","urlsLength","urlsData","u","callbackSelector","extraData","ccipResult","resolved","estimateGas","resolveName","_getBlock","blockHashOrBlockTag","includeTransactions","isHexString","blockWithTxs","blockWithTransactions","oncePoll","getBlock","transactionResponse","removed","arrayOf","filterLog","bind","getEtherPrice","getResolver","currentName","_getResolver","resolver","addrData","lookupAddress","resolverAddr","nameOrAddress","resolverAddress","NOT_IMPLEMENTED","_startEvent","_stopEvent","_addEventListener","args","stopped","eventTag","listenerCount","listeners","off","removeAllListeners","found","formats","getDefaultFormats","bigNumber","hex","number","strictData","allowNull","transactionIndex","gasPrice","maxPriorityFeePerGas","maxFeePerGas","gasLimit","uint256","creates","raw","receiptLog","logIndex","contractAddress","root","gasUsed","logsBloom","cumulativeGasUsed","effectiveGasPrice","parentHash","timestamp","difficulty","miner","baseFeePerGas","shallowCopy","boolean","allowFalsish","accessListify","strict","getContractAddress","_block","format","author","_difficulty","gas","networkId","parse","byzantium","object","checkKey","checkValue","nullValue","replaceValue","isCommunityResourcable","isCommunityResource","throttleMessage","showThrottleMessage","console","errorGas","spelunk","requireData","checkError","body","UNPREDICTABLE_GAS_LIMIT","responseText","INSUFFICIENT_FUNDS","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","getResult","payload","getLowerCase","_constructorGuard","JsonRpcSigner","Signer","constructorGuard","addressOrIndex","connect","connectUnchecked","UncheckedJsonRpcSigner","_address","_index","send","accounts","sendUncheckedTransaction","fromAddress","estimate","hexlifyTransaction","ACTION_REJECTED","action","signTransaction","signMessage","messageData","_legacySignMessage","_signTypedData","domain","types","populated","resolveNames","getPayload","unlock","password","allowedTransactionKeys","networkOrReady","freeze","_nextId","_cache","_eventLoopCache","defaultUrl","_uncachedDetectNetwork","serverError","getSigner","getUncheckedSigner","listAccounts","request","id","jsonrpc","deepCopy","cache","connection","prepareRequest","feeData","getFeeData","_startPending","_pendingFilter","self","pendingFilter","filterId","hashes","seq","allowExtra","allowed","checkProperties","NextId","WebSocketProvider","_wsReady","WebSocket","websocket","onopen","_requests","onmessage","messageEvent","callback","sub","_subs","subscription","processFunc","fauxPoll","_websocket","_detectNetwork","rid","_subscribe","param","subIdPromise","_subIds","subId","emitReceipt","destroy","readyState","CONNECTING","onerror","close","WS","ripemd160","update","digest","sha512","computeHmac","algorithm","SupportedAlgorithm","DEFAULT_MAX_REQUEST_BATCH_SIZE","DEFAULT_REQUEST_BATCH_DELAY_MS","RequestBatcher","sendBatchFn","maxBatchSize","pendingBatch","enqueueRequest","inflightRequest","promise","sendBatchRequest","pendingBatchTimer","batch","inflight","index","config","apiKey","getApiKey","alchemyNetwork","getAlchemyNetwork","getAlchemyConnectionInfo","throttleLimit","maxRetries","connectionInfoOverrides","assign","ethersNetwork","E","batchRequests","batcherConnection","headers","requests","batcher","modifyFormatter","D","C","isValidNetwork","includes","g","I","V","allowGzip","_super","create","get","l","_send","methodName","MAX_BACKFILL_BLOCKS","WebsocketBackfiller","maxBackfillBlocks","getNewHeadsBackfill","isCancelled","previousHeads","fromBlockNumber","throwIfCancelled","toBlockNumber","getHeadEventsInRange","max","lastSeenBlockNumber","f","minBlockNumber","reorgHeads","getReorgHeads","intermediateHeads","getLogsBackfill","previousLogs","getLogsInRange","commonAncestor","getCommonAncestor","removedLogs","fromBlockInclusive","Number","NEGATIVE_INFINITY","addedLogs","setMaxBackfillBlock","newMax","blockNumberHex","toBlockExclusive","batchParts","blockHeads","sendBatch","toNewHeadsEvent","oldEvent","blockHead","getBlockByNumber","oldLog","rangeFilter","head","totalDifficulty","uncles","dedupeNewHeads","events","dedupe","dedupeLogs","items","getKey","keysSeen","item","add","CANCELLED","HEARTBEAT_INTERVAL","HEARTBEAT_WAIT_TIME","BACKFILL_TIMEOUT","BACKFILL_RETRIES","RETAINED_EVENT_BLOCK_COUNT","AlchemyWebSocketProvider","wsConstructor","protocol","ws","getWebsocketConstructor","virtualSubscriptionsById","Map","virtualIdsByPhysicalId","handleMessage","isSubscriptionEvent","physicalId","virtualId","newHeadsSubscription","newHeadsMessage","isBackfilling","backfillBuffer","addToNewHeadsEventsBuffer","emitAndRememberEvent","getNewHeadsBlockNumber","rememberEvent","logsSubscription","logsMessage","addToLogsEventsBuffer","getLogsBlockNumber","emitEvent","handleReopen","clear","cancel","makeCancelToken","cancelBackfill","resubscribeAndBackfill","startHeartbeat","stopHeartbeatAndBackfill","heartbeatIntervalId","backfiller","addSocketListeners","_off","_removeAllListeners","_listenerCount","_listeners","customLogicTypes","A","customStartEvent","startingBlockNumber","resolvedParams","sentEvents","parts","nextId","sendBatchConcurrently","removeSocketListeners","addEventListener","removeEventListener","backfillEvents","withBackoffRetries","withTimeout","emitNewHeadsEvent","emitLogsEvent","emitGenericEvent","addToPastEventsBuffer","emitFunction","emitProcessFn","reconnect","req","toAddress","hashesOnly","PENDING_TRANSACTIONS","addresses","includeRemoved","MINED_TRANSACTIONS","isNodeEnvironment","process","versions","MIN_RETRY_DELAY","RETRY_BACKOFF_FACTOR","MAX_RETRY_DELAY","retryCount","shouldRetry","nextWaitTime","delay","min","ms","race","isResponse","pastEvents","currentBlockNumber","firstGoodIndex","findIndex","ALPHABET","ALPHABET_MAP","z","polymodStep","pre","prefixChk","chk","c","LIMIT","__decode","str","lowered","uppered","wordChars","decodeUnsafe","res","arguments","convert","inBits","outBits","pad","bits","maxV","toWordsUnsafe","toWords","fromWordsUnsafe","fromWords","module","exports","naiveFallback","window","globalThis","defineProperty","prototype","configurable","__global__","SHOULD_RECONNECT_FALSE_MESSAGE","SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE","SturdyWebSocket","protocolsOrOptions","onclose","ondown","onreopen","OPEN","CLOSING","CLOSED","hasBeenOpened","isClosed","messageBuffer","nextRetryTime","reconnectCount","lastKnownExtensions","lastKnownProtocol","protocols","applyDefaultOptions","openNewWebSocket","binaryTypeInternal","binaryType","enumerable","sum","bufferedAmount","hasUnknownAmount","byteLength","getDataByteLength","debugLog","extensions","disposeSocket","shutdown","handleClose","dispatchEvent","dispatchEventOfType","_this","connectTimeout","handleError","handleOpen","connectTimeoutId","clearConnectTimeout","allClearResetTime","allClearTimeoutId","clearAllClearTimeout","openTime","maxReconnectAttempts","shouldReconnect","stopReconnecting","getTooManyFailedReconnectsMessage","willReconnect","handleWillReconnect","willReconnectResolved","denialReason","reestablishConnection","minReconnectDelay","maxReconnectDelay","reconnectBackoffFactor","retryTime","retryTimeSeconds","debugReason","clearAllTimeouts","closeCode","noop","callListener","defaultPrevented","handleEvent","debug","pluralize","DEFAULT_OPTIONS","POSITIVE_INFINITY","ArrayBuffer","Blob","_globalThis","NativeWebSocket","MozWebSocket","websocket_version","W3CWebSocket","uri","native_instance","prop"],"sourceRoot":""}