{"version":3,"file":"IntegrationAPI-BrnntV9A.mjs","sources":["../src/engine/AccountManager.ts","../src/engine/NetworkManager.ts","../src/engine/TransactionManager.ts","../src/engine/WalletEngine.ts","../src/apis/EmbeddedAPI.ts","../src/apis/RemoteAPI.ts","../src/apis/IntegrationAPI.ts"],"sourcesContent":["/**\n * AccountManager - Manages wallet accounts and their lifecycle\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport { ethers } from 'ethers';\nimport type { WalletEngine } from './WalletEngine';\nimport type { Account, AccountType } from './types';\n\nexport interface AccountManagerEvents {\n  'account:created': (account: Account) => void;\n  'account:updated': (account: Account) => void;\n  'account:removed': (accountId: string) => void;\n  'account:selected': (account: Account) => void;\n}\n\nexport class AccountManager extends EventEmitter<AccountManagerEvents> {\n  private engine: WalletEngine;\n  private accounts = new Map<string, Account>();\n  private currentAccountId: string | null = null;\n  private initialized = false;\n\n  constructor(engine: WalletEngine) {\n    super();\n    this.engine = engine;\n  }\n\n  /**\n   * Initialize the account manager\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    try {\n      // Load existing accounts from storage\n      await this.loadAccounts();\n      \n      // Load current account selection\n      await this.loadCurrentAccount();\n      \n      this.initialized = true;\n    } catch (error) {\n      throw new Error(`Failed to initialize AccountManager: ${error}`);\n    }\n  }\n\n  /**\n   * Create a new account\n   */\n  async create(name?: string): Promise<Account> {\n    this.ensureInitialized();\n\n    try {\n      // Generate new wallet\n      const wallet = ethers.Wallet.createRandom();\n      \n      // Create account object\n      const account: Account = {\n        id: this.generateId(),\n        address: wallet.address,\n        name: name || `Account ${this.accounts.size + 1}`,\n        type: 'eoa',\n        publicKey: wallet.signingKey.publicKey,\n        derivationPath: undefined, // For random wallets\n        ens: undefined,\n        username: undefined,\n        avatar: undefined,\n        createdAt: new Date(),\n        lastUsed: new Date(),\n        metadata: {\n          isHardware: false,\n          isImported: false,\n          isWatchOnly: false\n        }\n      };\n\n      // Store the account\n      this.accounts.set(account.id, account);\n      \n      // Store encrypted private key\n      await this.storePrivateKey(account.id, wallet.privateKey);\n      \n      // Save to storage\n      await this.saveAccounts();\n      \n      // Emit event\n      this.emit('account:created', account);\n      \n      // Select if first account\n      if (this.accounts.size === 1) {\n        await this.select(account.id);\n      }\n      \n      return account;\n    } catch (error) {\n      throw new Error(`Failed to create account: ${error}`);\n    }\n  }\n\n  /**\n   * Import account from private key\n   */\n  async importFromPrivateKey(privateKey: string, name?: string): Promise<Account> {\n    this.ensureInitialized();\n\n    try {\n      // Create wallet from private key\n      const wallet = new ethers.Wallet(privateKey);\n      \n      // Check if account already exists\n      const existing = Array.from(this.accounts.values())\n        .find(acc => acc.address.toLowerCase() === wallet.address.toLowerCase());\n      \n      if (existing) {\n        throw new Error('Account already exists');\n      }\n      \n      // Create account object\n      const account: Account = {\n        id: this.generateId(),\n        address: wallet.address,\n        name: name || `Imported Account`,\n        type: 'eoa',\n        publicKey: wallet.signingKey.publicKey,\n        derivationPath: undefined,\n        ens: undefined,\n        username: undefined,\n        avatar: undefined,\n        createdAt: new Date(),\n        lastUsed: new Date(),\n        metadata: {\n          isHardware: false,\n          isImported: true,\n          isWatchOnly: false\n        }\n      };\n\n      // Store the account\n      this.accounts.set(account.id, account);\n      \n      // Store encrypted private key\n      await this.storePrivateKey(account.id, privateKey);\n      \n      // Save to storage\n      await this.saveAccounts();\n      \n      // Emit event\n      this.emit('account:created', account);\n      \n      return account;\n    } catch (error) {\n      throw new Error(`Failed to import account: ${error}`);\n    }\n  }\n\n  /**\n   * Add watch-only account\n   */\n  async addWatchOnly(address: string, name?: string): Promise<Account> {\n    this.ensureInitialized();\n\n    try {\n      // Validate address\n      if (!ethers.isAddress(address)) {\n        throw new Error('Invalid address');\n      }\n\n      // Check if account already exists\n      const existing = Array.from(this.accounts.values())\n        .find(acc => acc.address.toLowerCase() === address.toLowerCase());\n      \n      if (existing) {\n        throw new Error('Account already exists');\n      }\n      \n      // Create account object\n      const account: Account = {\n        id: this.generateId(),\n        address: ethers.getAddress(address), // Checksum address\n        name: name || `Watch-Only Account`,\n        type: 'watched',\n        publicKey: '', // Not available for watch-only\n        derivationPath: undefined,\n        ens: undefined,\n        username: undefined,\n        avatar: undefined,\n        createdAt: new Date(),\n        lastUsed: new Date(),\n        metadata: {\n          isHardware: false,\n          isImported: false,\n          isWatchOnly: true\n        }\n      };\n\n      // Store the account\n      this.accounts.set(account.id, account);\n      \n      // Save to storage\n      await this.saveAccounts();\n      \n      // Emit event\n      this.emit('account:created', account);\n      \n      return account;\n    } catch (error) {\n      throw new Error(`Failed to add watch-only account: ${error}`);\n    }\n  }\n\n  /**\n   * Update account information\n   */\n  async update(accountId: string, updates: Partial<Account>): Promise<Account> {\n    this.ensureInitialized();\n\n    const account = this.accounts.get(accountId);\n    if (!account) {\n      throw new Error('Account not found');\n    }\n\n    // Update account\n    const updatedAccount = {\n      ...account,\n      ...updates,\n      id: account.id, // Prevent ID changes\n      address: account.address, // Prevent address changes\n      lastUsed: new Date()\n    };\n\n    this.accounts.set(accountId, updatedAccount);\n    await this.saveAccounts();\n    \n    this.emit('account:updated', updatedAccount);\n    return updatedAccount;\n  }\n\n  /**\n   * Remove an account\n   */\n  async remove(accountId: string): Promise<void> {\n    this.ensureInitialized();\n\n    const account = this.accounts.get(accountId);\n    if (!account) {\n      throw new Error('Account not found');\n    }\n\n    // Can't remove the last account\n    if (this.accounts.size === 1) {\n      throw new Error('Cannot remove the last account');\n    }\n\n    // Remove from storage\n    this.accounts.delete(accountId);\n    await this.removePrivateKey(accountId);\n    await this.saveAccounts();\n\n    // Select another account if this was current\n    if (this.currentAccountId === accountId) {\n      const firstAccount = Array.from(this.accounts.values())[0];\n      await this.select(firstAccount.id);\n    }\n\n    this.emit('account:removed', accountId);\n  }\n\n  /**\n   * Select an account as current\n   */\n  async select(accountId: string): Promise<Account> {\n    this.ensureInitialized();\n\n    const account = this.accounts.get(accountId);\n    if (!account) {\n      throw new Error('Account not found');\n    }\n\n    // Update last used\n    const updatedAccount = {\n      ...account,\n      lastUsed: new Date()\n    };\n    \n    this.accounts.set(accountId, updatedAccount);\n    this.currentAccountId = accountId;\n    \n    // Save current account selection\n    await this.saveCurrentAccount();\n    await this.saveAccounts();\n\n    this.emit('account:selected', updatedAccount);\n    return updatedAccount;\n  }\n\n  /**\n   * Get all accounts\n   */\n  getAll(): Account[] {\n    return Array.from(this.accounts.values())\n      .sort((a, b) => b.lastUsed.getTime() - a.lastUsed.getTime());\n  }\n\n  /**\n   * Get account by ID\n   */\n  get(accountId: string): Account | null {\n    return this.accounts.get(accountId) || null;\n  }\n\n  /**\n   * Get account by address\n   */\n  async getByAddress(address: string): Promise<Account | null> {\n    const normalizedAddress = address.toLowerCase();\n    return Array.from(this.accounts.values())\n      .find(acc => acc.address.toLowerCase() === normalizedAddress) || null;\n  }\n\n  /**\n   * Get current account\n   */\n  getCurrent(): Account | null {\n    if (!this.currentAccountId) return null;\n    return this.accounts.get(this.currentAccountId) || null;\n  }\n\n  /**\n   * Get private key for account (if available)\n   */\n  async getPrivateKey(accountId: string): Promise<string> {\n    this.ensureInitialized();\n\n    const account = this.accounts.get(accountId);\n    if (!account) {\n      throw new Error('Account not found');\n    }\n\n    if (account.type === 'watched') {\n      throw new Error('Watch-only accounts have no private key');\n    }\n\n    return this.loadPrivateKey(accountId);\n  }\n\n  /**\n   * Sign a message with account\n   */\n  async signMessage(accountId: string, message: string): Promise<string> {\n    const privateKey = await this.getPrivateKey(accountId);\n    const wallet = new ethers.Wallet(privateKey);\n    return wallet.signMessage(message);\n  }\n\n  /**\n   * Destroy the account manager\n   */\n  async destroy(): Promise<void> {\n    this.accounts.clear();\n    this.currentAccountId = null;\n    this.initialized = false;\n    this.removeAllListeners();\n  }\n\n  /**\n   * Private methods\n   */\n  private generateId(): string {\n    return `acc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private async loadAccounts(): Promise<void> {\n    try {\n      // In a real implementation, this would load from encrypted storage\n      // For now, use localStorage as a simple example\n      const stored = localStorage.getItem('yakkl:accounts');\n      if (stored) {\n        const accountsData = JSON.parse(stored);\n        for (const acc of accountsData) {\n          // Convert date strings back to Date objects\n          acc.createdAt = new Date(acc.createdAt);\n          acc.lastUsed = new Date(acc.lastUsed);\n          this.accounts.set(acc.id, acc);\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to load accounts:', error);\n    }\n  }\n\n  private async saveAccounts(): Promise<void> {\n    try {\n      const accountsData = Array.from(this.accounts.values());\n      localStorage.setItem('yakkl:accounts', JSON.stringify(accountsData));\n    } catch (error) {\n      console.error('Failed to save accounts:', error);\n      throw error;\n    }\n  }\n\n  private async loadCurrentAccount(): Promise<void> {\n    try {\n      const stored = localStorage.getItem('yakkl:currentAccount');\n      if (stored && this.accounts.has(stored)) {\n        this.currentAccountId = stored;\n      } else if (this.accounts.size > 0) {\n        // Select first account if no current account set\n        this.currentAccountId = Array.from(this.accounts.keys())[0];\n      }\n    } catch (error) {\n      console.warn('Failed to load current account:', error);\n    }\n  }\n\n  private async saveCurrentAccount(): Promise<void> {\n    try {\n      if (this.currentAccountId) {\n        localStorage.setItem('yakkl:currentAccount', this.currentAccountId);\n      }\n    } catch (error) {\n      console.error('Failed to save current account:', error);\n    }\n  }\n\n  private async storePrivateKey(accountId: string, privateKey: string): Promise<void> {\n    // In production, this should be encrypted with user's password\n    // For now, store in localStorage (NOT SECURE - just for development)\n    try {\n      localStorage.setItem(`yakkl:pk:${accountId}`, privateKey);\n    } catch (error) {\n      console.error('Failed to store private key:', error);\n      throw error;\n    }\n  }\n\n  private async loadPrivateKey(accountId: string): Promise<string> {\n    try {\n      const privateKey = localStorage.getItem(`yakkl:pk:${accountId}`);\n      if (!privateKey) {\n        throw new Error('Private key not found');\n      }\n      return privateKey;\n    } catch (error) {\n      console.error('Failed to load private key:', error);\n      throw error;\n    }\n  }\n\n  private async removePrivateKey(accountId: string): Promise<void> {\n    try {\n      localStorage.removeItem(`yakkl:pk:${accountId}`);\n    } catch (error) {\n      console.error('Failed to remove private key:', error);\n    }\n  }\n\n  private ensureInitialized(): void {\n    if (!this.initialized) {\n      throw new Error('AccountManager not initialized');\n    }\n  }\n}","/**\n * NetworkManager - Manages blockchain networks and connections\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport { ethers } from 'ethers';\nimport type { WalletEngine } from './WalletEngine';\nimport type { Network, NetworkFeature } from './types';\n\nexport interface NetworkManagerEvents {\n  'network:added': (network: Network) => void;\n  'network:updated': (network: Network) => void;\n  'network:removed': (networkId: string) => void;\n  'network:switched': (network: Network) => void;\n  'network:connected': (network: Network) => void;\n  'network:disconnected': (network: Network) => void;\n}\n\nexport class NetworkManager extends EventEmitter<NetworkManagerEvents> {\n  private engine: WalletEngine;\n  private networks = new Map<string, Network>();\n  private providers = new Map<string, ethers.JsonRpcProvider>();\n  private currentNetworkId: string | null = null;\n  private initialized = false;\n\n  constructor(engine: WalletEngine) {\n    super();\n    this.engine = engine;\n  }\n\n  /**\n   * Initialize the network manager\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    try {\n      // Load default networks\n      await this.loadDefaultNetworks();\n      \n      // Load custom networks from storage\n      await this.loadCustomNetworks();\n      \n      // Load current network selection\n      await this.loadCurrentNetwork();\n      \n      this.initialized = true;\n    } catch (error) {\n      throw new Error(`Failed to initialize NetworkManager: ${error}`);\n    }\n  }\n\n  /**\n   * Get all supported networks\n   */\n  getSupported(): Network[] {\n    return Array.from(this.networks.values())\n      .sort((a, b) => {\n        // Sort by: mainnet first, then testnet, then custom\n        if (a.isMainnet && !b.isMainnet) return -1;\n        if (!a.isMainnet && b.isMainnet) return 1;\n        if (!a.isTestnet && b.isTestnet) return -1;\n        if (a.isTestnet && !b.isTestnet) return 1;\n        return a.name.localeCompare(b.name);\n      });\n  }\n\n  /**\n   * Get network by ID\n   */\n  get(networkId: string): Network | null {\n    return this.networks.get(networkId) || null;\n  }\n\n  /**\n   * Get current network\n   */\n  getCurrent(): Network | null {\n    if (!this.currentNetworkId) return null;\n    return this.networks.get(this.currentNetworkId) || null;\n  }\n\n  /**\n   * Switch to a different network\n   */\n  async switch(networkId: string): Promise<Network> {\n    this.ensureInitialized();\n\n    const network = this.networks.get(networkId);\n    if (!network) {\n      throw new Error('Network not found');\n    }\n\n    // Test connection to network\n    await this.testConnection(network);\n\n    // Update current network\n    this.currentNetworkId = networkId;\n    await this.saveCurrentNetwork();\n\n    this.emit('network:switched', network);\n    return network;\n  }\n\n  /**\n   * Add a custom network\n   */\n  async add(networkConfig: Omit<Network, 'id' | 'isCustom'>): Promise<Network> {\n    this.ensureInitialized();\n\n    // Validate network configuration\n    await this.validateNetworkConfig(networkConfig);\n\n    // Check if network already exists\n    const existing = Array.from(this.networks.values())\n      .find(n => n.chainId === networkConfig.chainId);\n    \n    if (existing) {\n      throw new Error('Network with this chain ID already exists');\n    }\n\n    // Create network\n    const network: Network = {\n      id: this.generateNetworkId(),\n      ...networkConfig,\n      isCustom: true\n    };\n\n    // Store network\n    this.networks.set(network.id, network);\n    await this.saveCustomNetworks();\n\n    this.emit('network:added', network);\n    return network;\n  }\n\n  /**\n   * Update a custom network\n   */\n  async update(networkId: string, updates: Partial<Network>): Promise<Network> {\n    this.ensureInitialized();\n\n    const network = this.networks.get(networkId);\n    if (!network) {\n      throw new Error('Network not found');\n    }\n\n    if (!network.isCustom) {\n      throw new Error('Cannot update built-in networks');\n    }\n\n    // Update network\n    const updatedNetwork = {\n      ...network,\n      ...updates,\n      id: network.id, // Prevent ID changes\n      isCustom: true // Ensure it stays custom\n    };\n\n    // Validate updated configuration\n    await this.validateNetworkConfig(updatedNetwork);\n\n    this.networks.set(networkId, updatedNetwork);\n    await this.saveCustomNetworks();\n\n    this.emit('network:updated', updatedNetwork);\n    return updatedNetwork;\n  }\n\n  /**\n   * Remove a custom network\n   */\n  async remove(networkId: string): Promise<void> {\n    this.ensureInitialized();\n\n    const network = this.networks.get(networkId);\n    if (!network) {\n      throw new Error('Network not found');\n    }\n\n    if (!network.isCustom) {\n      throw new Error('Cannot remove built-in networks');\n    }\n\n    // Remove provider if exists\n    const provider = this.providers.get(networkId);\n    if (provider) {\n      provider.destroy();\n      this.providers.delete(networkId);\n    }\n\n    // Remove network\n    this.networks.delete(networkId);\n    await this.saveCustomNetworks();\n\n    // Switch to default network if this was current\n    if (this.currentNetworkId === networkId) {\n      const defaultNetwork = Array.from(this.networks.values())\n        .find(n => n.isMainnet && !n.isCustom);\n      if (defaultNetwork) {\n        await this.switch(defaultNetwork.id);\n      }\n    }\n\n    this.emit('network:removed', networkId);\n  }\n\n  /**\n   * Get provider for network\n   */\n  getProvider(networkId?: string): ethers.JsonRpcProvider | null {\n    const id = networkId || this.currentNetworkId;\n    if (!id) return null;\n\n    // Return existing provider if available\n    if (this.providers.has(id)) {\n      return this.providers.get(id)!;\n    }\n\n    // Create new provider\n    const network = this.networks.get(id);\n    if (!network) return null;\n\n    try {\n      const provider = new ethers.JsonRpcProvider(network.rpcUrl);\n      this.providers.set(id, provider);\n      return provider;\n    } catch (error) {\n      console.error(`Failed to create provider for network ${id}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Test connection to a network\n   */\n  async testConnection(network: Network): Promise<boolean> {\n    try {\n      const provider = new ethers.JsonRpcProvider(network.rpcUrl);\n      const chainId = await provider.getNetwork();\n      \n      // Verify chain ID matches\n      if (Number(chainId.chainId) !== network.chainId) {\n        throw new Error('Chain ID mismatch');\n      }\n\n      return true;\n    } catch (error) {\n      throw new Error(`Network connection failed: ${error}`);\n    }\n  }\n\n  /**\n   * Get network statistics\n   */\n  async getNetworkStats(networkId?: string): Promise<{\n    blockNumber: number;\n    gasPrice: bigint;\n    chainId: number;\n  }> {\n    const provider = this.getProvider(networkId);\n    if (!provider) {\n      throw new Error('No provider available');\n    }\n\n    try {\n      const [blockNumber, feeData, network] = await Promise.all([\n        provider.getBlockNumber(),\n        provider.getFeeData(),\n        provider.getNetwork()\n      ]);\n\n      return {\n        blockNumber,\n        gasPrice: feeData.gasPrice || 0n,\n        chainId: Number(network.chainId)\n      };\n    } catch (error) {\n      throw new Error(`Failed to get network stats: ${error}`);\n    }\n  }\n\n  /**\n   * Destroy the network manager\n   */\n  async destroy(): Promise<void> {\n    // Destroy all providers\n    for (const provider of this.providers.values()) {\n      provider.destroy();\n    }\n    \n    this.networks.clear();\n    this.providers.clear();\n    this.currentNetworkId = null;\n    this.initialized = false;\n    this.removeAllListeners();\n  }\n\n  /**\n   * Private methods\n   */\n  private async loadDefaultNetworks(): Promise<void> {\n    const defaultNetworks: Network[] = [\n      // Ethereum Mainnet\n      {\n        id: 'ethereum',\n        name: 'Ethereum',\n        chainId: 1,\n        symbol: 'ETH',\n        rpcUrl: 'https://eth.llamarpc.com',\n        blockExplorerUrl: 'https://etherscan.io',\n        isTestnet: false,\n        isMainnet: true,\n        isCustom: false,\n        iconUrl: '/networks/ethereum.png',\n        gasToken: {\n          address: '0x0000000000000000000000000000000000000000',\n          symbol: 'ETH',\n          name: 'Ethereum',\n          decimals: 18,\n          chainId: 1,\n          isNative: true,\n          isStable: false\n        },\n        supportedFeatures: ['eip1559', 'eip2930', 'contracts', 'tokens', 'nft', 'defi', 'staking']\n      },\n      // Polygon\n      {\n        id: 'polygon',\n        name: 'Polygon',\n        chainId: 137,\n        symbol: 'MATIC',\n        rpcUrl: 'https://polygon-rpc.com',\n        blockExplorerUrl: 'https://polygonscan.com',\n        isTestnet: false,\n        isMainnet: true,\n        isCustom: false,\n        iconUrl: '/networks/polygon.png',\n        gasToken: {\n          address: '0x0000000000000000000000000000000000000000',\n          symbol: 'MATIC',\n          name: 'Polygon',\n          decimals: 18,\n          chainId: 137,\n          isNative: true,\n          isStable: false\n        },\n        supportedFeatures: ['eip1559', 'eip2930', 'contracts', 'tokens', 'nft', 'defi', 'bridges']\n      },\n      // Arbitrum One\n      {\n        id: 'arbitrum',\n        name: 'Arbitrum One',\n        chainId: 42161,\n        symbol: 'ETH',\n        rpcUrl: 'https://arb1.arbitrum.io/rpc',\n        blockExplorerUrl: 'https://arbiscan.io',\n        isTestnet: false,\n        isMainnet: true,\n        isCustom: false,\n        iconUrl: '/networks/arbitrum.png',\n        gasToken: {\n          address: '0x0000000000000000000000000000000000000000',\n          symbol: 'ETH',\n          name: 'Ethereum',\n          decimals: 18,\n          chainId: 42161,\n          isNative: true,\n          isStable: false\n        },\n        supportedFeatures: ['contracts', 'tokens', 'nft', 'defi', 'bridges']\n      },\n      // Sepolia Testnet\n      {\n        id: 'sepolia',\n        name: 'Sepolia',\n        chainId: 11155111,\n        symbol: 'ETH',\n        rpcUrl: 'https://rpc.sepolia.org',\n        blockExplorerUrl: 'https://sepolia.etherscan.io',\n        isTestnet: true,\n        isMainnet: false,\n        isCustom: false,\n        iconUrl: '/networks/ethereum.png',\n        gasToken: {\n          address: '0x0000000000000000000000000000000000000000',\n          symbol: 'ETH',\n          name: 'Ethereum',\n          decimals: 18,\n          chainId: 11155111,\n          isNative: true,\n          isStable: false\n        },\n        supportedFeatures: ['eip1559', 'eip2930', 'contracts', 'tokens', 'nft']\n      }\n    ];\n\n    for (const network of defaultNetworks) {\n      this.networks.set(network.id, network);\n    }\n  }\n\n  private async loadCustomNetworks(): Promise<void> {\n    try {\n      const stored = localStorage.getItem('yakkl:customNetworks');\n      if (stored) {\n        const customNetworks = JSON.parse(stored);\n        for (const network of customNetworks) {\n          this.networks.set(network.id, network);\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to load custom networks:', error);\n    }\n  }\n\n  private async saveCustomNetworks(): Promise<void> {\n    try {\n      const customNetworks = Array.from(this.networks.values())\n        .filter(n => n.isCustom);\n      localStorage.setItem('yakkl:customNetworks', JSON.stringify(customNetworks));\n    } catch (error) {\n      console.error('Failed to save custom networks:', error);\n      throw error;\n    }\n  }\n\n  private async loadCurrentNetwork(): Promise<void> {\n    try {\n      const stored = localStorage.getItem('yakkl:currentNetwork');\n      if (stored && this.networks.has(stored)) {\n        this.currentNetworkId = stored;\n      } else {\n        // Default to Ethereum mainnet\n        const ethereum = Array.from(this.networks.values())\n          .find(n => n.chainId === 1);\n        if (ethereum) {\n          this.currentNetworkId = ethereum.id;\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to load current network:', error);\n    }\n  }\n\n  private async saveCurrentNetwork(): Promise<void> {\n    try {\n      if (this.currentNetworkId) {\n        localStorage.setItem('yakkl:currentNetwork', this.currentNetworkId);\n      }\n    } catch (error) {\n      console.error('Failed to save current network:', error);\n    }\n  }\n\n  private async validateNetworkConfig(config: Partial<Network>): Promise<void> {\n    if (!config.name || !config.chainId || !config.rpcUrl) {\n      throw new Error('Network name, chainId, and rpcUrl are required');\n    }\n\n    if (config.chainId <= 0) {\n      throw new Error('Chain ID must be positive');\n    }\n\n    try {\n      new URL(config.rpcUrl);\n    } catch {\n      throw new Error('Invalid RPC URL');\n    }\n\n    if (config.blockExplorerUrl) {\n      try {\n        new URL(config.blockExplorerUrl);\n      } catch {\n        throw new Error('Invalid block explorer URL');\n      }\n    }\n  }\n\n  private generateNetworkId(): string {\n    return `net_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private ensureInitialized(): void {\n    if (!this.initialized) {\n      throw new Error('NetworkManager not initialized');\n    }\n  }\n}","/**\n * TransactionManager - Handles transaction signing, sending, and tracking\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport { ethers } from 'ethers';\nimport type { WalletEngine } from './WalletEngine';\nimport type { \n  Transaction, \n  SignedTransaction, \n  Balance, \n  TokenBalance, \n  NFTBalance,\n  TransactionHistory,\n  TransactionStatus,\n  TransactionHistoryType\n} from './types';\n\nexport interface TransactionManagerEvents {\n  'transaction:signed': (signedTx: SignedTransaction) => void;\n  'transaction:sent': (hash: string, transaction: Transaction) => void;\n  'transaction:confirmed': (hash: string, receipt: any) => void;\n  'transaction:failed': (hash: string, error: Error) => void;\n  'balance:updated': (address: string, balance: Balance) => void;\n}\n\nexport class TransactionManager extends EventEmitter<TransactionManagerEvents> {\n  private engine: WalletEngine;\n  private pendingTransactions = new Map<string, Transaction>();\n  private transactionHistory = new Map<string, TransactionHistory[]>();\n  private balanceCache = new Map<string, Balance>();\n  private initialized = false;\n\n  constructor(engine: WalletEngine) {\n    super();\n    this.engine = engine;\n  }\n\n  /**\n   * Initialize the transaction manager\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    try {\n      // Load transaction history from storage\n      await this.loadTransactionHistory();\n      \n      // Load pending transactions\n      await this.loadPendingTransactions();\n      \n      this.initialized = true;\n    } catch (error) {\n      throw new Error(`Failed to initialize TransactionManager: ${error}`);\n    }\n  }\n\n  /**\n   * Sign a transaction\n   */\n  async sign(transaction: Transaction): Promise<SignedTransaction> {\n    this.ensureInitialized();\n\n    try {\n      // Get current account\n      const currentAccount = this.engine.getCurrentAccount();\n      if (!currentAccount) {\n        throw new Error('No account selected');\n      }\n\n      // Get account private key\n      const privateKey = await this.engine.accounts.getPrivateKey(currentAccount.id);\n      const wallet = new ethers.Wallet(privateKey);\n\n      // Get current network provider\n      const provider = this.engine.networks.getProvider();\n      if (!provider) {\n        throw new Error('No network provider available');\n      }\n\n      const connectedWallet = wallet.connect(provider);\n\n      // Prepare transaction\n      const txRequest: ethers.TransactionRequest = {\n        to: transaction.to,\n        value: transaction.value,\n        data: transaction.data,\n        gasLimit: transaction.gasLimit,\n        gasPrice: transaction.gasPrice,\n        maxFeePerGas: transaction.maxFeePerGas,\n        maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,\n        nonce: transaction.nonce,\n        type: transaction.type\n      };\n\n      // Fill in missing fields\n      const populatedTx = await connectedWallet.populateTransaction(txRequest);\n\n      // Sign the transaction\n      const signedTxResponse = await connectedWallet.signTransaction(populatedTx);\n\n      // Parse the signed transaction\n      const parsedTx = ethers.Transaction.from(signedTxResponse);\n\n      const signedTransaction: SignedTransaction = {\n        transaction: {\n          ...transaction,\n          gasLimit: populatedTx.gasLimit?.toString(),\n          gasPrice: populatedTx.gasPrice?.toString(),\n          maxFeePerGas: populatedTx.maxFeePerGas?.toString(),\n          maxPriorityFeePerGas: populatedTx.maxPriorityFeePerGas?.toString(),\n          nonce: populatedTx.nonce || 0\n        },\n        signature: {\n          r: parsedTx.signature!.r,\n          s: parsedTx.signature!.s,\n          v: parsedTx.signature!.v || 0\n        },\n        hash: parsedTx.hash!,\n        serialized: signedTxResponse\n      };\n\n      this.emit('transaction:signed', signedTransaction);\n      return signedTransaction;\n    } catch (error) {\n      throw new Error(`Failed to sign transaction: ${error}`);\n    }\n  }\n\n  /**\n   * Send a transaction\n   */\n  async send(transaction: Transaction): Promise<string> {\n    this.ensureInitialized();\n\n    try {\n      // Sign the transaction first\n      const signedTx = await this.sign(transaction);\n\n      // Get provider\n      const provider = this.engine.networks.getProvider();\n      if (!provider) {\n        throw new Error('No network provider available');\n      }\n\n      // Send the transaction\n      const txResponse = await provider.broadcastTransaction(signedTx.serialized);\n      const hash = txResponse.hash;\n\n      // Store as pending\n      this.pendingTransactions.set(hash, transaction);\n      await this.savePendingTransactions();\n\n      // Start monitoring\n      this.monitorTransaction(hash, txResponse);\n\n      this.emit('transaction:sent', hash, transaction);\n      return hash;\n    } catch (error) {\n      throw new Error(`Failed to send transaction: ${error}`);\n    }\n  }\n\n  /**\n   * Get balance for an address\n   */\n  async getBalance(address: string): Promise<Balance> {\n    this.ensureInitialized();\n\n    try {\n      // Check cache first (with TTL)\n      const cached = this.balanceCache.get(address);\n      if (cached && this.isBalanceCacheValid(cached)) {\n        return cached;\n      }\n\n      // Get current network\n      const network = this.engine.networks.getCurrent();\n      if (!network) {\n        throw new Error('No network selected');\n      }\n\n      // Get provider\n      const provider = this.engine.networks.getProvider();\n      if (!provider) {\n        throw new Error('No network provider available');\n      }\n\n      // Get native balance\n      const nativeBalance = await provider.getBalance(address);\n\n      // Create balance object\n      const balance: Balance = {\n        address,\n        chainId: network.chainId,\n        native: {\n          token: network.gasToken,\n          balance: nativeBalance.toString(),\n          value: '0', // Would calculate USD value in production\n          price: '0'\n        },\n        tokens: [], // Would load ERC-20 tokens in production\n        nfts: [], // Would load NFTs in production\n        totalValue: '0', // Would calculate total USD value\n        lastUpdated: new Date()\n      };\n\n      // Cache the result\n      this.balanceCache.set(address, balance);\n\n      this.emit('balance:updated', address, balance);\n      return balance;\n    } catch (error) {\n      throw new Error(`Failed to get balance: ${error}`);\n    }\n  }\n\n  /**\n   * Get transaction history for an address\n   */\n  async getHistory(address: string, limit = 50): Promise<TransactionHistory[]> {\n    this.ensureInitialized();\n\n    const history = this.transactionHistory.get(address) || [];\n    return history.slice(0, limit);\n  }\n\n  /**\n   * Estimate gas for a transaction\n   */\n  async estimateGas(transaction: Partial<Transaction>): Promise<string> {\n    this.ensureInitialized();\n\n    try {\n      const provider = this.engine.networks.getProvider();\n      if (!provider) {\n        throw new Error('No network provider available');\n      }\n\n      const gasEstimate = await provider.estimateGas({\n        to: transaction.to,\n        value: transaction.value,\n        data: transaction.data\n      });\n\n      return gasEstimate.toString();\n    } catch (error) {\n      throw new Error(`Failed to estimate gas: ${error}`);\n    }\n  }\n\n  /**\n   * Get current gas prices\n   */\n  async getGasPrices(): Promise<{\n    slow: string;\n    standard: string;\n    fast: string;\n    maxFeePerGas?: string;\n    maxPriorityFeePerGas?: string;\n  }> {\n    this.ensureInitialized();\n\n    try {\n      const provider = this.engine.networks.getProvider();\n      if (!provider) {\n        throw new Error('No network provider available');\n      }\n\n      const feeData = await provider.getFeeData();\n\n      // For EIP-1559 networks\n      if (feeData.maxFeePerGas && feeData.maxPriorityFeePerGas) {\n        const baseFee = feeData.maxFeePerGas - feeData.maxPriorityFeePerGas;\n        const slowPriority = feeData.maxPriorityFeePerGas / 2n;\n        const fastPriority = feeData.maxPriorityFeePerGas * 2n;\n\n        return {\n          slow: (baseFee + slowPriority).toString(),\n          standard: feeData.maxFeePerGas.toString(),\n          fast: (baseFee + fastPriority).toString(),\n          maxFeePerGas: feeData.maxFeePerGas.toString(),\n          maxPriorityFeePerGas: feeData.maxPriorityFeePerGas.toString()\n        };\n      }\n\n      // For legacy networks\n      const gasPrice = feeData.gasPrice || 0n;\n      return {\n        slow: (gasPrice * 8n / 10n).toString(), // 80% of current\n        standard: gasPrice.toString(),\n        fast: (gasPrice * 12n / 10n).toString() // 120% of current\n      };\n    } catch (error) {\n      throw new Error(`Failed to get gas prices: ${error}`);\n    }\n  }\n\n  /**\n   * Refresh balance for an address\n   */\n  async refreshBalance(address: string): Promise<Balance> {\n    // Clear cache and fetch fresh balance\n    this.balanceCache.delete(address);\n    return this.getBalance(address);\n  }\n\n  /**\n   * Cancel a pending transaction (if possible)\n   */\n  async cancelTransaction(hash: string): Promise<string> {\n    this.ensureInitialized();\n\n    const pendingTx = this.pendingTransactions.get(hash);\n    if (!pendingTx) {\n      throw new Error('Transaction not found or already confirmed');\n    }\n\n    try {\n      // Create cancellation transaction (send 0 ETH to self with higher gas)\n      const currentAccount = this.engine.getCurrentAccount();\n      if (!currentAccount) {\n        throw new Error('No account selected');\n      }\n\n      const gasPrices = await this.getGasPrices();\n      const cancelTx: Transaction = {\n        to: currentAccount.address,\n        value: '0',\n        chainId: pendingTx.chainId,\n        nonce: pendingTx.nonce,\n        gasLimit: '21000',\n        // Use higher gas price to prioritize cancellation\n        gasPrice: (BigInt(gasPrices.fast) * 11n / 10n).toString() // 110% of fast\n      };\n\n      return this.send(cancelTx);\n    } catch (error) {\n      throw new Error(`Failed to cancel transaction: ${error}`);\n    }\n  }\n\n  /**\n   * Destroy the transaction manager\n   */\n  async destroy(): Promise<void> {\n    this.pendingTransactions.clear();\n    this.transactionHistory.clear();\n    this.balanceCache.clear();\n    this.initialized = false;\n    this.removeAllListeners();\n  }\n\n  /**\n   * Private methods\n   */\n  private async monitorTransaction(hash: string, txResponse: any): Promise<void> {\n    try {\n      const receipt = await txResponse.wait();\n      \n      // Remove from pending\n      this.pendingTransactions.delete(hash);\n      await this.savePendingTransactions();\n\n      // Add to history\n      await this.addToHistory(hash, receipt);\n\n      if (receipt.status === 1) {\n        this.emit('transaction:confirmed', hash, receipt);\n      } else {\n        this.emit('transaction:failed', hash, new Error('Transaction reverted'));\n      }\n    } catch (error) {\n      this.emit('transaction:failed', hash, error as Error);\n    }\n  }\n\n  private async addToHistory(hash: string, receipt: any): Promise<void> {\n    try {\n      const currentAccount = this.engine.getCurrentAccount();\n      if (!currentAccount) return;\n\n      const provider = this.engine.networks.getProvider();\n      if (!provider) return;\n\n      const tx = await provider.getTransaction(hash);\n      if (!tx) return;\n\n      const block = await provider.getBlock(receipt.blockNumber);\n      \n      const historyItem: TransactionHistory = {\n        hash: hash,\n        blockNumber: receipt.blockNumber,\n        timestamp: new Date(block!.timestamp * 1000),\n        from: tx.from || '',\n        to: tx.to || '',\n        value: tx.value.toString(),\n        gasUsed: receipt.gasUsed.toString(),\n        gasPrice: tx.gasPrice?.toString() || '0',\n        status: receipt.status === 1 ? 'confirmed' : 'failed',\n        type: this.determineTransactionType(tx),\n        metadata: {\n          blockHash: receipt.blockHash,\n          transactionIndex: receipt.transactionIndex,\n          logs: receipt.logs\n        }\n      };\n\n      // Add to history for the account\n      const address = currentAccount.address;\n      const existing = this.transactionHistory.get(address) || [];\n      existing.unshift(historyItem); // Add to beginning\n      \n      // Keep only last 1000 transactions\n      if (existing.length > 1000) {\n        existing.splice(1000);\n      }\n      \n      this.transactionHistory.set(address, existing);\n      await this.saveTransactionHistory();\n    } catch (error) {\n      console.error('Failed to add transaction to history:', error);\n    }\n  }\n\n  private determineTransactionType(tx: any): TransactionHistoryType {\n    if (tx.data && tx.data !== '0x') {\n      // Has data, likely a contract interaction\n      return 'contract';\n    }\n    \n    if (tx.value && BigInt(tx.value) > 0) {\n      // Has value, it's a transfer\n      return 'send'; // Could be 'receive' depending on perspective\n    }\n    \n    return 'send';\n  }\n\n  private isBalanceCacheValid(balance: Balance): boolean {\n    const now = new Date();\n    const age = now.getTime() - balance.lastUpdated.getTime();\n    return age < 30000; // 30 seconds cache\n  }\n\n  private async loadTransactionHistory(): Promise<void> {\n    try {\n      const stored = localStorage.getItem('yakkl:transactionHistory');\n      if (stored) {\n        const data = JSON.parse(stored);\n        for (const [address, history] of Object.entries(data)) {\n          // Convert date strings back to Date objects\n          const typedHistory = (history as any[]).map(item => ({\n            ...item,\n            timestamp: new Date(item.timestamp)\n          }));\n          this.transactionHistory.set(address, typedHistory);\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to load transaction history:', error);\n    }\n  }\n\n  private async saveTransactionHistory(): Promise<void> {\n    try {\n      const data = Object.fromEntries(this.transactionHistory);\n      localStorage.setItem('yakkl:transactionHistory', JSON.stringify(data));\n    } catch (error) {\n      console.error('Failed to save transaction history:', error);\n    }\n  }\n\n  private async loadPendingTransactions(): Promise<void> {\n    try {\n      const stored = localStorage.getItem('yakkl:pendingTransactions');\n      if (stored) {\n        const data = JSON.parse(stored);\n        this.pendingTransactions = new Map(Object.entries(data));\n      }\n    } catch (error) {\n      console.warn('Failed to load pending transactions:', error);\n    }\n  }\n\n  private async savePendingTransactions(): Promise<void> {\n    try {\n      const data = Object.fromEntries(this.pendingTransactions);\n      localStorage.setItem('yakkl:pendingTransactions', JSON.stringify(data));\n    } catch (error) {\n      console.error('Failed to save pending transactions:', error);\n    }\n  }\n\n  private ensureInitialized(): void {\n    if (!this.initialized) {\n      throw new Error('TransactionManager not initialized');\n    }\n  }\n}","/**\n * YAKKL Wallet Engine - Core wallet functionality\n * \n * This is the heart of all YAKKL products. Everything builds on this foundation.\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport { ModRegistry } from '../mods/ModRegistry';\nimport { DiscoveryProtocol } from '../mods/DiscoveryProtocol';\nimport { AccountManager } from './AccountManager';\nimport { NetworkManager } from './NetworkManager';\nimport { TransactionManager } from './TransactionManager';\nimport type { \n  WalletConfig, \n  Account, \n  Network, \n  Transaction, \n  SignedTransaction, \n  Balance \n} from './types';\nimport type { Mod } from '../mods/types';\n\nexport interface WalletEngineEvents {\n  'account:created': (account: Account) => void;\n  'account:selected': (account: Account) => void;\n  'transaction:signed': (tx: SignedTransaction) => void;\n  'mod:loaded': (mod: Mod) => void;\n  'mod:discovered': (mods: Mod[]) => void;\n  'network:changed': (network: Network) => void;\n}\n\nexport class WalletEngine extends EventEmitter<WalletEngineEvents> {\n  private config: WalletConfig;\n  private mods: ModRegistry;\n  private discovery: DiscoveryProtocol;\n  public accounts: AccountManager;\n  public networks: NetworkManager;\n  public transactions: TransactionManager;\n  private initialized = false;\n\n  constructor(config: Partial<WalletConfig> = {}) {\n    super();\n    \n    this.config = {\n      name: 'YAKKL Wallet',\n      version: '1.0.0',\n      embedded: false,\n      restrictions: [],\n      modDiscovery: true,\n      ...config\n    };\n\n    // Initialize core managers\n    this.accounts = new AccountManager(this);\n    this.networks = new NetworkManager(this);\n    this.transactions = new TransactionManager(this);\n    \n    // Initialize mod system\n    this.mods = new ModRegistry(this);\n    this.discovery = new DiscoveryProtocol(this);\n  }\n\n  /**\n   * Initialize the wallet engine\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    try {\n      // Initialize core systems\n      await this.accounts.initialize();\n      await this.networks.initialize();\n      await this.transactions.initialize();\n\n      // Initialize mod system\n      await this.mods.initialize();\n      \n      // Start discovery if enabled\n      if (this.config.modDiscovery) {\n        await this.discovery.start();\n      }\n\n      this.initialized = true;\n    } catch (error) {\n      throw new Error(`Failed to initialize wallet engine: ${error}`);\n    }\n  }\n\n  /**\n   * Get wallet configuration\n   */\n  getConfig(): WalletConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Core Account Management\n   */\n  async createAccount(name?: string): Promise<Account> {\n    this.ensureInitialized();\n    const account = await this.accounts.create(name);\n    this.emit('account:created', account);\n    return account;\n  }\n\n  async getAccounts(): Promise<Account[]> {\n    this.ensureInitialized();\n    return this.accounts.getAll();\n  }\n\n  async selectAccount(accountId: string): Promise<void> {\n    this.ensureInitialized();\n    const account = await this.accounts.select(accountId);\n    this.emit('account:selected', account);\n  }\n\n  getCurrentAccount(): Account | null {\n    return this.accounts.getCurrent();\n  }\n\n  /**\n   * Core Network Management\n   */\n  async getSupportedNetworks(): Promise<Network[]> {\n    this.ensureInitialized();\n    return this.networks.getSupported();\n  }\n\n  async switchNetwork(networkId: string): Promise<void> {\n    this.ensureInitialized();\n    const network = await this.networks.switch(networkId);\n    this.emit('network:changed', network);\n  }\n\n  getCurrentNetwork(): Network | null {\n    return this.networks.getCurrent();\n  }\n\n  /**\n   * Core Transaction Management\n   */\n  async signTransaction(transaction: Transaction): Promise<SignedTransaction> {\n    this.ensureInitialized();\n    const signedTx = await this.transactions.sign(transaction);\n    this.emit('transaction:signed', signedTx);\n    return signedTx;\n  }\n\n  async sendTransaction(transaction: Transaction): Promise<string> {\n    this.ensureInitialized();\n    return this.transactions.send(transaction);\n  }\n\n  async getBalance(address?: string): Promise<Balance> {\n    this.ensureInitialized();\n    const account = address ? \n      await this.accounts.getByAddress(address) : \n      this.getCurrentAccount();\n    \n    if (!account) {\n      throw new Error('No account specified or selected');\n    }\n\n    return this.transactions.getBalance(account.address);\n  }\n\n  /**\n   * Mod Management\n   */\n  async loadMod(id: string): Promise<Mod> {\n    this.ensureInitialized();\n    const mod = await this.mods.load(id);\n    this.emit('mod:loaded', mod);\n    return mod;\n  }\n\n  async getLoadedMods(): Promise<Mod[]> {\n    return this.mods.getLoaded();\n  }\n\n  async discoverMods(): Promise<Mod[]> {\n    this.ensureInitialized();\n    const discovered = await this.discovery.scan();\n    this.emit('mod:discovered', discovered);\n    return discovered;\n  }\n\n  /**\n   * Integration APIs\n   */\n  getEmbeddedAPI() {\n    // Will be implemented when we create the embedded API\n    return null;\n  }\n\n  getRemoteAPI() {\n    // Will be implemented when we create the remote API\n    return null;\n  }\n\n  /**\n   * Utility Methods\n   */\n  isInitialized(): boolean {\n    return this.initialized;\n  }\n\n  async destroy(): Promise<void> {\n    await this.discovery.stop();\n    await this.mods.destroy();\n    await this.transactions.destroy();\n    await this.networks.destroy();\n    await this.accounts.destroy();\n    \n    this.removeAllListeners();\n    this.initialized = false;\n  }\n\n  private ensureInitialized(): void {\n    if (!this.initialized) {\n      throw new Error('Wallet engine not initialized. Call initialize() first.');\n    }\n  }\n}","/**\n * EmbeddedAPI - API for embedded wallet implementations\n */\n\nimport { WalletEngine } from '../engine/WalletEngine';\nimport type { Account, Network, Transaction } from '../engine/types';\n\nexport class EmbeddedAPI {\n  private engine: WalletEngine;\n\n  constructor(engine: WalletEngine) {\n    this.engine = engine;\n  }\n\n  /**\n   * Get wallet information\n   */\n  async getWalletInfo() {\n    return {\n      version: '0.1.0',\n      accounts: this.engine.accounts.getAll().length,\n      currentNetwork: this.engine.networks.getCurrent()?.name,\n      isLocked: false // Would check actual lock state\n    };\n  }\n\n  /**\n   * Get current account\n   */\n  async getCurrentAccount(): Promise<Account | null> {\n    return this.engine.getCurrentAccount();\n  }\n\n  /**\n   * Get all accounts\n   */\n  async getAccounts(): Promise<Account[]> {\n    return this.engine.accounts.getAll();\n  }\n\n  /**\n   * Get current network\n   */\n  async getCurrentNetwork(): Promise<Network | null> {\n    return this.engine.networks.getCurrent();\n  }\n\n  /**\n   * Get supported networks\n   */\n  async getSupportedNetworks(): Promise<Network[]> {\n    return this.engine.networks.getSupported();\n  }\n\n  /**\n   * Request account connection\n   */\n  async connect(): Promise<Account[]> {\n    // In embedded mode, return current accounts\n    return this.engine.accounts.getAll();\n  }\n\n  /**\n   * Sign a transaction\n   */\n  async signTransaction(transaction: Transaction): Promise<string> {\n    const signed = await this.engine.transactions.sign(transaction);\n    return signed.serialized;\n  }\n\n  /**\n   * Send a transaction\n   */\n  async sendTransaction(transaction: Transaction): Promise<string> {\n    return this.engine.transactions.send(transaction);\n  }\n\n  /**\n   * Sign a message\n   */\n  async signMessage(message: string): Promise<string> {\n    const currentAccount = this.engine.getCurrentAccount();\n    if (!currentAccount) {\n      throw new Error('No account selected');\n    }\n\n    return this.engine.accounts.signMessage(currentAccount.id, message);\n  }\n}","/**\n * RemoteAPI - API for remote wallet connections\n */\n\nimport { EventEmitter } from 'eventemitter3';\n\nexport interface RemoteWalletEvents {\n  'connected': () => void;\n  'disconnected': () => void;\n  'accountsChanged': (accounts: string[]) => void;\n  'chainChanged': (chainId: string) => void;\n}\n\nexport class RemoteAPI extends EventEmitter<RemoteWalletEvents> {\n  private connected = false;\n  private accounts: string[] = [];\n  private chainId: string | null = null;\n\n  /**\n   * Connect to remote wallet\n   */\n  async connect(): Promise<string[]> {\n    // Simulate connection to external wallet\n    this.connected = true;\n    this.accounts = []; // Would get from remote wallet\n    this.emit('connected');\n    return this.accounts;\n  }\n\n  /**\n   * Disconnect from remote wallet\n   */\n  async disconnect(): Promise<void> {\n    this.connected = false;\n    this.accounts = [];\n    this.chainId = null;\n    this.emit('disconnected');\n  }\n\n  /**\n   * Check if connected\n   */\n  isConnected(): boolean {\n    return this.connected;\n  }\n\n  /**\n   * Get connected accounts\n   */\n  getAccounts(): string[] {\n    return this.accounts;\n  }\n\n  /**\n   * Get current chain ID\n   */\n  getChainId(): string | null {\n    return this.chainId;\n  }\n\n  /**\n   * Request account access\n   */\n  async requestAccounts(): Promise<string[]> {\n    if (!this.connected) {\n      throw new Error('Not connected to remote wallet');\n    }\n    \n    // Would request from remote wallet\n    return this.accounts;\n  }\n\n  /**\n   * Switch network\n   */\n  async switchNetwork(chainId: string): Promise<void> {\n    if (!this.connected) {\n      throw new Error('Not connected to remote wallet');\n    }\n\n    // Would request network switch from remote wallet\n    this.chainId = chainId;\n    this.emit('chainChanged', chainId);\n  }\n}","/**\n * IntegrationAPI - API for third-party integrations\n */\n\nimport { WalletEngine } from '../engine/WalletEngine';\nimport type { WalletConfig } from '../engine/types';\n\nexport interface IntegrationConfig {\n  apiKey?: string;\n  appName: string;\n  appVersion: string;\n  permissions: string[];\n}\n\nexport class IntegrationAPI {\n  private engine: WalletEngine | null = null;\n  private config: IntegrationConfig;\n\n  constructor(config: IntegrationConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Initialize the integration\n   */\n  async initialize(walletConfig?: Partial<WalletConfig>): Promise<void> {\n    const config: WalletConfig = {\n      name: 'YAKKL Integration',\n      version: '1.0.0',\n      embedded: true,\n      restrictions: [],\n      modDiscovery: false,\n      enableMods: true,\n      enableDiscovery: false, // Disable discovery for integrations\n      storagePrefix: `integration:${this.config.appName}`,\n      logLevel: 'warn',\n      ...walletConfig\n    };\n\n    this.engine = new WalletEngine(config);\n    await this.engine.initialize();\n  }\n\n  /**\n   * Get the wallet engine\n   */\n  getEngine(): WalletEngine {\n    if (!this.engine) {\n      throw new Error('Integration not initialized');\n    }\n    return this.engine;\n  }\n\n  /**\n   * Check if a permission is granted\n   */\n  hasPermission(permission: string): boolean {\n    return this.config.permissions.includes(permission);\n  }\n\n  /**\n   * Request additional permissions\n   */\n  async requestPermissions(permissions: string[]): Promise<boolean> {\n    // In a real implementation, this would show a permission dialog\n    // For now, just add to the config\n    for (const permission of permissions) {\n      if (!this.config.permissions.includes(permission)) {\n        this.config.permissions.push(permission);\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Get integration info\n   */\n  getInfo() {\n    return {\n      appName: this.config.appName,\n      appVersion: this.config.appVersion,\n      permissions: this.config.permissions,\n      isInitialized: this.engine !== null\n    };\n  }\n\n  /**\n   * Destroy the integration\n   */\n  async destroy(): Promise<void> {\n    if (this.engine) {\n      await this.engine.destroy();\n      this.engine = null;\n    }\n  }\n}"],"names":["AccountManager","EventEmitter","engine","error","name","wallet","ethers","account","privateKey","acc","address","accountId","updates","updatedAccount","firstAccount","a","b","normalizedAddress","message","stored","accountsData","NetworkManager","networkId","network","networkConfig","n","updatedNetwork","provider","defaultNetwork","id","chainId","blockNumber","feeData","defaultNetworks","customNetworks","ethereum","config","TransactionManager","transaction","currentAccount","connectedWallet","txRequest","populatedTx","signedTxResponse","parsedTx","signedTransaction","signedTx","txResponse","hash","cached","nativeBalance","balance","limit","baseFee","slowPriority","fastPriority","gasPrice","pendingTx","gasPrices","cancelTx","receipt","tx","block","historyItem","existing","data","history","typedHistory","item","WalletEngine","ModRegistry","DiscoveryProtocol","mod","discovered","EmbeddedAPI","RemoteAPI","IntegrationAPI","walletConfig","permission","permissions"],"mappings":"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"}