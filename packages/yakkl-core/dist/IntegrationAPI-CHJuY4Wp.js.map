{"version":3,"file":"IntegrationAPI-CHJuY4Wp.js","sources":["../src/engine/AccountManager.ts","../src/engine/NetworkManager.ts","../src/engine/TransactionManager.ts","../src/engine/WalletEngine.ts","../src/apis/EmbeddedAPI.ts","../src/apis/RemoteAPI.ts","../src/apis/IntegrationAPI.ts"],"sourcesContent":["/**\n * AccountManager - Manages wallet accounts and their lifecycle\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport { ethers } from 'ethers';\nimport type { WalletEngine } from './WalletEngine';\nimport type { Account, AccountType } from './types';\n\nexport interface AccountManagerEvents {\n  'account:created': (account: Account) => void;\n  'account:updated': (account: Account) => void;\n  'account:removed': (accountId: string) => void;\n  'account:selected': (account: Account) => void;\n}\n\nexport class AccountManager extends EventEmitter<AccountManagerEvents> {\n  private engine: WalletEngine;\n  private accounts = new Map<string, Account>();\n  private currentAccountId: string | null = null;\n  private initialized = false;\n\n  constructor(engine: WalletEngine) {\n    super();\n    this.engine = engine;\n  }\n\n  /**\n   * Initialize the account manager\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    try {\n      // Load existing accounts from storage\n      await this.loadAccounts();\n      \n      // Load current account selection\n      await this.loadCurrentAccount();\n      \n      this.initialized = true;\n    } catch (error) {\n      throw new Error(`Failed to initialize AccountManager: ${error}`);\n    }\n  }\n\n  /**\n   * Create a new account\n   */\n  async create(name?: string): Promise<Account> {\n    this.ensureInitialized();\n\n    try {\n      // Generate new wallet\n      const wallet = ethers.Wallet.createRandom();\n      \n      // Create account object\n      const account: Account = {\n        id: this.generateId(),\n        address: wallet.address,\n        name: name || `Account ${this.accounts.size + 1}`,\n        type: 'eoa',\n        publicKey: wallet.signingKey.publicKey,\n        derivationPath: undefined, // For random wallets\n        ens: undefined,\n        username: undefined,\n        avatar: undefined,\n        createdAt: new Date(),\n        lastUsed: new Date(),\n        metadata: {\n          isHardware: false,\n          isImported: false,\n          isWatchOnly: false\n        }\n      };\n\n      // Store the account\n      this.accounts.set(account.id, account);\n      \n      // Store encrypted private key\n      await this.storePrivateKey(account.id, wallet.privateKey);\n      \n      // Save to storage\n      await this.saveAccounts();\n      \n      // Emit event\n      this.emit('account:created', account);\n      \n      // Select if first account\n      if (this.accounts.size === 1) {\n        await this.select(account.id);\n      }\n      \n      return account;\n    } catch (error) {\n      throw new Error(`Failed to create account: ${error}`);\n    }\n  }\n\n  /**\n   * Import account from private key\n   */\n  async importFromPrivateKey(privateKey: string, name?: string): Promise<Account> {\n    this.ensureInitialized();\n\n    try {\n      // Create wallet from private key\n      const wallet = new ethers.Wallet(privateKey);\n      \n      // Check if account already exists\n      const existing = Array.from(this.accounts.values())\n        .find(acc => acc.address.toLowerCase() === wallet.address.toLowerCase());\n      \n      if (existing) {\n        throw new Error('Account already exists');\n      }\n      \n      // Create account object\n      const account: Account = {\n        id: this.generateId(),\n        address: wallet.address,\n        name: name || `Imported Account`,\n        type: 'eoa',\n        publicKey: wallet.signingKey.publicKey,\n        derivationPath: undefined,\n        ens: undefined,\n        username: undefined,\n        avatar: undefined,\n        createdAt: new Date(),\n        lastUsed: new Date(),\n        metadata: {\n          isHardware: false,\n          isImported: true,\n          isWatchOnly: false\n        }\n      };\n\n      // Store the account\n      this.accounts.set(account.id, account);\n      \n      // Store encrypted private key\n      await this.storePrivateKey(account.id, privateKey);\n      \n      // Save to storage\n      await this.saveAccounts();\n      \n      // Emit event\n      this.emit('account:created', account);\n      \n      return account;\n    } catch (error) {\n      throw new Error(`Failed to import account: ${error}`);\n    }\n  }\n\n  /**\n   * Add watch-only account\n   */\n  async addWatchOnly(address: string, name?: string): Promise<Account> {\n    this.ensureInitialized();\n\n    try {\n      // Validate address\n      if (!ethers.isAddress(address)) {\n        throw new Error('Invalid address');\n      }\n\n      // Check if account already exists\n      const existing = Array.from(this.accounts.values())\n        .find(acc => acc.address.toLowerCase() === address.toLowerCase());\n      \n      if (existing) {\n        throw new Error('Account already exists');\n      }\n      \n      // Create account object\n      const account: Account = {\n        id: this.generateId(),\n        address: ethers.getAddress(address), // Checksum address\n        name: name || `Watch-Only Account`,\n        type: 'watched',\n        publicKey: '', // Not available for watch-only\n        derivationPath: undefined,\n        ens: undefined,\n        username: undefined,\n        avatar: undefined,\n        createdAt: new Date(),\n        lastUsed: new Date(),\n        metadata: {\n          isHardware: false,\n          isImported: false,\n          isWatchOnly: true\n        }\n      };\n\n      // Store the account\n      this.accounts.set(account.id, account);\n      \n      // Save to storage\n      await this.saveAccounts();\n      \n      // Emit event\n      this.emit('account:created', account);\n      \n      return account;\n    } catch (error) {\n      throw new Error(`Failed to add watch-only account: ${error}`);\n    }\n  }\n\n  /**\n   * Update account information\n   */\n  async update(accountId: string, updates: Partial<Account>): Promise<Account> {\n    this.ensureInitialized();\n\n    const account = this.accounts.get(accountId);\n    if (!account) {\n      throw new Error('Account not found');\n    }\n\n    // Update account\n    const updatedAccount = {\n      ...account,\n      ...updates,\n      id: account.id, // Prevent ID changes\n      address: account.address, // Prevent address changes\n      lastUsed: new Date()\n    };\n\n    this.accounts.set(accountId, updatedAccount);\n    await this.saveAccounts();\n    \n    this.emit('account:updated', updatedAccount);\n    return updatedAccount;\n  }\n\n  /**\n   * Remove an account\n   */\n  async remove(accountId: string): Promise<void> {\n    this.ensureInitialized();\n\n    const account = this.accounts.get(accountId);\n    if (!account) {\n      throw new Error('Account not found');\n    }\n\n    // Can't remove the last account\n    if (this.accounts.size === 1) {\n      throw new Error('Cannot remove the last account');\n    }\n\n    // Remove from storage\n    this.accounts.delete(accountId);\n    await this.removePrivateKey(accountId);\n    await this.saveAccounts();\n\n    // Select another account if this was current\n    if (this.currentAccountId === accountId) {\n      const firstAccount = Array.from(this.accounts.values())[0];\n      await this.select(firstAccount.id);\n    }\n\n    this.emit('account:removed', accountId);\n  }\n\n  /**\n   * Select an account as current\n   */\n  async select(accountId: string): Promise<Account> {\n    this.ensureInitialized();\n\n    const account = this.accounts.get(accountId);\n    if (!account) {\n      throw new Error('Account not found');\n    }\n\n    // Update last used\n    const updatedAccount = {\n      ...account,\n      lastUsed: new Date()\n    };\n    \n    this.accounts.set(accountId, updatedAccount);\n    this.currentAccountId = accountId;\n    \n    // Save current account selection\n    await this.saveCurrentAccount();\n    await this.saveAccounts();\n\n    this.emit('account:selected', updatedAccount);\n    return updatedAccount;\n  }\n\n  /**\n   * Get all accounts\n   */\n  getAll(): Account[] {\n    return Array.from(this.accounts.values())\n      .sort((a, b) => b.lastUsed.getTime() - a.lastUsed.getTime());\n  }\n\n  /**\n   * Get account by ID\n   */\n  get(accountId: string): Account | null {\n    return this.accounts.get(accountId) || null;\n  }\n\n  /**\n   * Get account by address\n   */\n  async getByAddress(address: string): Promise<Account | null> {\n    const normalizedAddress = address.toLowerCase();\n    return Array.from(this.accounts.values())\n      .find(acc => acc.address.toLowerCase() === normalizedAddress) || null;\n  }\n\n  /**\n   * Get current account\n   */\n  getCurrent(): Account | null {\n    if (!this.currentAccountId) return null;\n    return this.accounts.get(this.currentAccountId) || null;\n  }\n\n  /**\n   * Get private key for account (if available)\n   */\n  async getPrivateKey(accountId: string): Promise<string> {\n    this.ensureInitialized();\n\n    const account = this.accounts.get(accountId);\n    if (!account) {\n      throw new Error('Account not found');\n    }\n\n    if (account.type === 'watched') {\n      throw new Error('Watch-only accounts have no private key');\n    }\n\n    return this.loadPrivateKey(accountId);\n  }\n\n  /**\n   * Sign a message with account\n   */\n  async signMessage(accountId: string, message: string): Promise<string> {\n    const privateKey = await this.getPrivateKey(accountId);\n    const wallet = new ethers.Wallet(privateKey);\n    return wallet.signMessage(message);\n  }\n\n  /**\n   * Destroy the account manager\n   */\n  async destroy(): Promise<void> {\n    this.accounts.clear();\n    this.currentAccountId = null;\n    this.initialized = false;\n    this.removeAllListeners();\n  }\n\n  /**\n   * Private methods\n   */\n  private generateId(): string {\n    return `acc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private async loadAccounts(): Promise<void> {\n    try {\n      // In a real implementation, this would load from encrypted storage\n      // For now, use localStorage as a simple example\n      const stored = localStorage.getItem('yakkl:accounts');\n      if (stored) {\n        const accountsData = JSON.parse(stored);\n        for (const acc of accountsData) {\n          // Convert date strings back to Date objects\n          acc.createdAt = new Date(acc.createdAt);\n          acc.lastUsed = new Date(acc.lastUsed);\n          this.accounts.set(acc.id, acc);\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to load accounts:', error);\n    }\n  }\n\n  private async saveAccounts(): Promise<void> {\n    try {\n      const accountsData = Array.from(this.accounts.values());\n      localStorage.setItem('yakkl:accounts', JSON.stringify(accountsData));\n    } catch (error) {\n      console.error('Failed to save accounts:', error);\n      throw error;\n    }\n  }\n\n  private async loadCurrentAccount(): Promise<void> {\n    try {\n      const stored = localStorage.getItem('yakkl:currentAccount');\n      if (stored && this.accounts.has(stored)) {\n        this.currentAccountId = stored;\n      } else if (this.accounts.size > 0) {\n        // Select first account if no current account set\n        this.currentAccountId = Array.from(this.accounts.keys())[0];\n      }\n    } catch (error) {\n      console.warn('Failed to load current account:', error);\n    }\n  }\n\n  private async saveCurrentAccount(): Promise<void> {\n    try {\n      if (this.currentAccountId) {\n        localStorage.setItem('yakkl:currentAccount', this.currentAccountId);\n      }\n    } catch (error) {\n      console.error('Failed to save current account:', error);\n    }\n  }\n\n  private async storePrivateKey(accountId: string, privateKey: string): Promise<void> {\n    // In production, this should be encrypted with user's password\n    // For now, store in localStorage (NOT SECURE - just for development)\n    try {\n      localStorage.setItem(`yakkl:pk:${accountId}`, privateKey);\n    } catch (error) {\n      console.error('Failed to store private key:', error);\n      throw error;\n    }\n  }\n\n  private async loadPrivateKey(accountId: string): Promise<string> {\n    try {\n      const privateKey = localStorage.getItem(`yakkl:pk:${accountId}`);\n      if (!privateKey) {\n        throw new Error('Private key not found');\n      }\n      return privateKey;\n    } catch (error) {\n      console.error('Failed to load private key:', error);\n      throw error;\n    }\n  }\n\n  private async removePrivateKey(accountId: string): Promise<void> {\n    try {\n      localStorage.removeItem(`yakkl:pk:${accountId}`);\n    } catch (error) {\n      console.error('Failed to remove private key:', error);\n    }\n  }\n\n  private ensureInitialized(): void {\n    if (!this.initialized) {\n      throw new Error('AccountManager not initialized');\n    }\n  }\n}","/**\n * NetworkManager - Manages blockchain networks and connections\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport { ethers } from 'ethers';\nimport type { WalletEngine } from './WalletEngine';\nimport type { Network, NetworkFeature } from './types';\n\nexport interface NetworkManagerEvents {\n  'network:added': (network: Network) => void;\n  'network:updated': (network: Network) => void;\n  'network:removed': (networkId: string) => void;\n  'network:switched': (network: Network) => void;\n  'network:connected': (network: Network) => void;\n  'network:disconnected': (network: Network) => void;\n}\n\nexport class NetworkManager extends EventEmitter<NetworkManagerEvents> {\n  private engine: WalletEngine;\n  private networks = new Map<string, Network>();\n  private providers = new Map<string, ethers.JsonRpcProvider>();\n  private currentNetworkId: string | null = null;\n  private initialized = false;\n\n  constructor(engine: WalletEngine) {\n    super();\n    this.engine = engine;\n  }\n\n  /**\n   * Initialize the network manager\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    try {\n      // Load default networks\n      await this.loadDefaultNetworks();\n      \n      // Load custom networks from storage\n      await this.loadCustomNetworks();\n      \n      // Load current network selection\n      await this.loadCurrentNetwork();\n      \n      this.initialized = true;\n    } catch (error) {\n      throw new Error(`Failed to initialize NetworkManager: ${error}`);\n    }\n  }\n\n  /**\n   * Get all supported networks\n   */\n  getSupported(): Network[] {\n    return Array.from(this.networks.values())\n      .sort((a, b) => {\n        // Sort by: mainnet first, then testnet, then custom\n        if (a.isMainnet && !b.isMainnet) return -1;\n        if (!a.isMainnet && b.isMainnet) return 1;\n        if (!a.isTestnet && b.isTestnet) return -1;\n        if (a.isTestnet && !b.isTestnet) return 1;\n        return a.name.localeCompare(b.name);\n      });\n  }\n\n  /**\n   * Get network by ID\n   */\n  get(networkId: string): Network | null {\n    return this.networks.get(networkId) || null;\n  }\n\n  /**\n   * Get current network\n   */\n  getCurrent(): Network | null {\n    if (!this.currentNetworkId) return null;\n    return this.networks.get(this.currentNetworkId) || null;\n  }\n\n  /**\n   * Switch to a different network\n   */\n  async switch(networkId: string): Promise<Network> {\n    this.ensureInitialized();\n\n    const network = this.networks.get(networkId);\n    if (!network) {\n      throw new Error('Network not found');\n    }\n\n    // Test connection to network\n    await this.testConnection(network);\n\n    // Update current network\n    this.currentNetworkId = networkId;\n    await this.saveCurrentNetwork();\n\n    this.emit('network:switched', network);\n    return network;\n  }\n\n  /**\n   * Add a custom network\n   */\n  async add(networkConfig: Omit<Network, 'id' | 'isCustom'>): Promise<Network> {\n    this.ensureInitialized();\n\n    // Validate network configuration\n    await this.validateNetworkConfig(networkConfig);\n\n    // Check if network already exists\n    const existing = Array.from(this.networks.values())\n      .find(n => n.chainId === networkConfig.chainId);\n    \n    if (existing) {\n      throw new Error('Network with this chain ID already exists');\n    }\n\n    // Create network\n    const network: Network = {\n      id: this.generateNetworkId(),\n      ...networkConfig,\n      isCustom: true\n    };\n\n    // Store network\n    this.networks.set(network.id, network);\n    await this.saveCustomNetworks();\n\n    this.emit('network:added', network);\n    return network;\n  }\n\n  /**\n   * Update a custom network\n   */\n  async update(networkId: string, updates: Partial<Network>): Promise<Network> {\n    this.ensureInitialized();\n\n    const network = this.networks.get(networkId);\n    if (!network) {\n      throw new Error('Network not found');\n    }\n\n    if (!network.isCustom) {\n      throw new Error('Cannot update built-in networks');\n    }\n\n    // Update network\n    const updatedNetwork = {\n      ...network,\n      ...updates,\n      id: network.id, // Prevent ID changes\n      isCustom: true // Ensure it stays custom\n    };\n\n    // Validate updated configuration\n    await this.validateNetworkConfig(updatedNetwork);\n\n    this.networks.set(networkId, updatedNetwork);\n    await this.saveCustomNetworks();\n\n    this.emit('network:updated', updatedNetwork);\n    return updatedNetwork;\n  }\n\n  /**\n   * Remove a custom network\n   */\n  async remove(networkId: string): Promise<void> {\n    this.ensureInitialized();\n\n    const network = this.networks.get(networkId);\n    if (!network) {\n      throw new Error('Network not found');\n    }\n\n    if (!network.isCustom) {\n      throw new Error('Cannot remove built-in networks');\n    }\n\n    // Remove provider if exists\n    const provider = this.providers.get(networkId);\n    if (provider) {\n      provider.destroy();\n      this.providers.delete(networkId);\n    }\n\n    // Remove network\n    this.networks.delete(networkId);\n    await this.saveCustomNetworks();\n\n    // Switch to default network if this was current\n    if (this.currentNetworkId === networkId) {\n      const defaultNetwork = Array.from(this.networks.values())\n        .find(n => n.isMainnet && !n.isCustom);\n      if (defaultNetwork) {\n        await this.switch(defaultNetwork.id);\n      }\n    }\n\n    this.emit('network:removed', networkId);\n  }\n\n  /**\n   * Get provider for network\n   */\n  getProvider(networkId?: string): ethers.JsonRpcProvider | null {\n    const id = networkId || this.currentNetworkId;\n    if (!id) return null;\n\n    // Return existing provider if available\n    if (this.providers.has(id)) {\n      return this.providers.get(id)!;\n    }\n\n    // Create new provider\n    const network = this.networks.get(id);\n    if (!network) return null;\n\n    try {\n      const provider = new ethers.JsonRpcProvider(network.rpcUrl);\n      this.providers.set(id, provider);\n      return provider;\n    } catch (error) {\n      console.error(`Failed to create provider for network ${id}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Test connection to a network\n   */\n  async testConnection(network: Network): Promise<boolean> {\n    try {\n      const provider = new ethers.JsonRpcProvider(network.rpcUrl);\n      const chainId = await provider.getNetwork();\n      \n      // Verify chain ID matches\n      if (Number(chainId.chainId) !== network.chainId) {\n        throw new Error('Chain ID mismatch');\n      }\n\n      return true;\n    } catch (error) {\n      throw new Error(`Network connection failed: ${error}`);\n    }\n  }\n\n  /**\n   * Get network statistics\n   */\n  async getNetworkStats(networkId?: string): Promise<{\n    blockNumber: number;\n    gasPrice: bigint;\n    chainId: number;\n  }> {\n    const provider = this.getProvider(networkId);\n    if (!provider) {\n      throw new Error('No provider available');\n    }\n\n    try {\n      const [blockNumber, feeData, network] = await Promise.all([\n        provider.getBlockNumber(),\n        provider.getFeeData(),\n        provider.getNetwork()\n      ]);\n\n      return {\n        blockNumber,\n        gasPrice: feeData.gasPrice || 0n,\n        chainId: Number(network.chainId)\n      };\n    } catch (error) {\n      throw new Error(`Failed to get network stats: ${error}`);\n    }\n  }\n\n  /**\n   * Destroy the network manager\n   */\n  async destroy(): Promise<void> {\n    // Destroy all providers\n    for (const provider of this.providers.values()) {\n      provider.destroy();\n    }\n    \n    this.networks.clear();\n    this.providers.clear();\n    this.currentNetworkId = null;\n    this.initialized = false;\n    this.removeAllListeners();\n  }\n\n  /**\n   * Private methods\n   */\n  private async loadDefaultNetworks(): Promise<void> {\n    const defaultNetworks: Network[] = [\n      // Ethereum Mainnet\n      {\n        id: 'ethereum',\n        name: 'Ethereum',\n        chainId: 1,\n        symbol: 'ETH',\n        rpcUrl: 'https://eth.llamarpc.com',\n        blockExplorerUrl: 'https://etherscan.io',\n        isTestnet: false,\n        isMainnet: true,\n        isCustom: false,\n        iconUrl: '/networks/ethereum.png',\n        gasToken: {\n          address: '0x0000000000000000000000000000000000000000',\n          symbol: 'ETH',\n          name: 'Ethereum',\n          decimals: 18,\n          chainId: 1,\n          isNative: true,\n          isStable: false\n        },\n        supportedFeatures: ['eip1559', 'eip2930', 'contracts', 'tokens', 'nft', 'defi', 'staking']\n      },\n      // Polygon\n      {\n        id: 'polygon',\n        name: 'Polygon',\n        chainId: 137,\n        symbol: 'MATIC',\n        rpcUrl: 'https://polygon-rpc.com',\n        blockExplorerUrl: 'https://polygonscan.com',\n        isTestnet: false,\n        isMainnet: true,\n        isCustom: false,\n        iconUrl: '/networks/polygon.png',\n        gasToken: {\n          address: '0x0000000000000000000000000000000000000000',\n          symbol: 'MATIC',\n          name: 'Polygon',\n          decimals: 18,\n          chainId: 137,\n          isNative: true,\n          isStable: false\n        },\n        supportedFeatures: ['eip1559', 'eip2930', 'contracts', 'tokens', 'nft', 'defi', 'bridges']\n      },\n      // Arbitrum One\n      {\n        id: 'arbitrum',\n        name: 'Arbitrum One',\n        chainId: 42161,\n        symbol: 'ETH',\n        rpcUrl: 'https://arb1.arbitrum.io/rpc',\n        blockExplorerUrl: 'https://arbiscan.io',\n        isTestnet: false,\n        isMainnet: true,\n        isCustom: false,\n        iconUrl: '/networks/arbitrum.png',\n        gasToken: {\n          address: '0x0000000000000000000000000000000000000000',\n          symbol: 'ETH',\n          name: 'Ethereum',\n          decimals: 18,\n          chainId: 42161,\n          isNative: true,\n          isStable: false\n        },\n        supportedFeatures: ['contracts', 'tokens', 'nft', 'defi', 'bridges']\n      },\n      // Sepolia Testnet\n      {\n        id: 'sepolia',\n        name: 'Sepolia',\n        chainId: 11155111,\n        symbol: 'ETH',\n        rpcUrl: 'https://rpc.sepolia.org',\n        blockExplorerUrl: 'https://sepolia.etherscan.io',\n        isTestnet: true,\n        isMainnet: false,\n        isCustom: false,\n        iconUrl: '/networks/ethereum.png',\n        gasToken: {\n          address: '0x0000000000000000000000000000000000000000',\n          symbol: 'ETH',\n          name: 'Ethereum',\n          decimals: 18,\n          chainId: 11155111,\n          isNative: true,\n          isStable: false\n        },\n        supportedFeatures: ['eip1559', 'eip2930', 'contracts', 'tokens', 'nft']\n      }\n    ];\n\n    for (const network of defaultNetworks) {\n      this.networks.set(network.id, network);\n    }\n  }\n\n  private async loadCustomNetworks(): Promise<void> {\n    try {\n      const stored = localStorage.getItem('yakkl:customNetworks');\n      if (stored) {\n        const customNetworks = JSON.parse(stored);\n        for (const network of customNetworks) {\n          this.networks.set(network.id, network);\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to load custom networks:', error);\n    }\n  }\n\n  private async saveCustomNetworks(): Promise<void> {\n    try {\n      const customNetworks = Array.from(this.networks.values())\n        .filter(n => n.isCustom);\n      localStorage.setItem('yakkl:customNetworks', JSON.stringify(customNetworks));\n    } catch (error) {\n      console.error('Failed to save custom networks:', error);\n      throw error;\n    }\n  }\n\n  private async loadCurrentNetwork(): Promise<void> {\n    try {\n      const stored = localStorage.getItem('yakkl:currentNetwork');\n      if (stored && this.networks.has(stored)) {\n        this.currentNetworkId = stored;\n      } else {\n        // Default to Ethereum mainnet\n        const ethereum = Array.from(this.networks.values())\n          .find(n => n.chainId === 1);\n        if (ethereum) {\n          this.currentNetworkId = ethereum.id;\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to load current network:', error);\n    }\n  }\n\n  private async saveCurrentNetwork(): Promise<void> {\n    try {\n      if (this.currentNetworkId) {\n        localStorage.setItem('yakkl:currentNetwork', this.currentNetworkId);\n      }\n    } catch (error) {\n      console.error('Failed to save current network:', error);\n    }\n  }\n\n  private async validateNetworkConfig(config: Partial<Network>): Promise<void> {\n    if (!config.name || !config.chainId || !config.rpcUrl) {\n      throw new Error('Network name, chainId, and rpcUrl are required');\n    }\n\n    if (config.chainId <= 0) {\n      throw new Error('Chain ID must be positive');\n    }\n\n    try {\n      new URL(config.rpcUrl);\n    } catch {\n      throw new Error('Invalid RPC URL');\n    }\n\n    if (config.blockExplorerUrl) {\n      try {\n        new URL(config.blockExplorerUrl);\n      } catch {\n        throw new Error('Invalid block explorer URL');\n      }\n    }\n  }\n\n  private generateNetworkId(): string {\n    return `net_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private ensureInitialized(): void {\n    if (!this.initialized) {\n      throw new Error('NetworkManager not initialized');\n    }\n  }\n}","/**\n * TransactionManager - Handles transaction signing, sending, and tracking\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport { ethers } from 'ethers';\nimport type { WalletEngine } from './WalletEngine';\nimport type { \n  Transaction, \n  SignedTransaction, \n  Balance, \n  TokenBalance, \n  NFTBalance,\n  TransactionHistory,\n  TransactionStatus,\n  TransactionHistoryType\n} from './types';\n\nexport interface TransactionManagerEvents {\n  'transaction:signed': (signedTx: SignedTransaction) => void;\n  'transaction:sent': (hash: string, transaction: Transaction) => void;\n  'transaction:confirmed': (hash: string, receipt: any) => void;\n  'transaction:failed': (hash: string, error: Error) => void;\n  'balance:updated': (address: string, balance: Balance) => void;\n}\n\nexport class TransactionManager extends EventEmitter<TransactionManagerEvents> {\n  private engine: WalletEngine;\n  private pendingTransactions = new Map<string, Transaction>();\n  private transactionHistory = new Map<string, TransactionHistory[]>();\n  private balanceCache = new Map<string, Balance>();\n  private initialized = false;\n\n  constructor(engine: WalletEngine) {\n    super();\n    this.engine = engine;\n  }\n\n  /**\n   * Initialize the transaction manager\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    try {\n      // Load transaction history from storage\n      await this.loadTransactionHistory();\n      \n      // Load pending transactions\n      await this.loadPendingTransactions();\n      \n      this.initialized = true;\n    } catch (error) {\n      throw new Error(`Failed to initialize TransactionManager: ${error}`);\n    }\n  }\n\n  /**\n   * Sign a transaction\n   */\n  async sign(transaction: Transaction): Promise<SignedTransaction> {\n    this.ensureInitialized();\n\n    try {\n      // Get current account\n      const currentAccount = this.engine.getCurrentAccount();\n      if (!currentAccount) {\n        throw new Error('No account selected');\n      }\n\n      // Get account private key\n      const privateKey = await this.engine.accounts.getPrivateKey(currentAccount.id);\n      const wallet = new ethers.Wallet(privateKey);\n\n      // Get current network provider\n      const provider = this.engine.networks.getProvider();\n      if (!provider) {\n        throw new Error('No network provider available');\n      }\n\n      const connectedWallet = wallet.connect(provider);\n\n      // Prepare transaction\n      const txRequest: ethers.TransactionRequest = {\n        to: transaction.to,\n        value: transaction.value,\n        data: transaction.data,\n        gasLimit: transaction.gasLimit,\n        gasPrice: transaction.gasPrice,\n        maxFeePerGas: transaction.maxFeePerGas,\n        maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,\n        nonce: transaction.nonce,\n        type: transaction.type\n      };\n\n      // Fill in missing fields\n      const populatedTx = await connectedWallet.populateTransaction(txRequest);\n\n      // Sign the transaction\n      const signedTxResponse = await connectedWallet.signTransaction(populatedTx);\n\n      // Parse the signed transaction\n      const parsedTx = ethers.Transaction.from(signedTxResponse);\n\n      const signedTransaction: SignedTransaction = {\n        transaction: {\n          ...transaction,\n          gasLimit: populatedTx.gasLimit?.toString(),\n          gasPrice: populatedTx.gasPrice?.toString(),\n          maxFeePerGas: populatedTx.maxFeePerGas?.toString(),\n          maxPriorityFeePerGas: populatedTx.maxPriorityFeePerGas?.toString(),\n          nonce: populatedTx.nonce || 0\n        },\n        signature: {\n          r: parsedTx.signature!.r,\n          s: parsedTx.signature!.s,\n          v: parsedTx.signature!.v || 0\n        },\n        hash: parsedTx.hash!,\n        serialized: signedTxResponse\n      };\n\n      this.emit('transaction:signed', signedTransaction);\n      return signedTransaction;\n    } catch (error) {\n      throw new Error(`Failed to sign transaction: ${error}`);\n    }\n  }\n\n  /**\n   * Send a transaction\n   */\n  async send(transaction: Transaction): Promise<string> {\n    this.ensureInitialized();\n\n    try {\n      // Sign the transaction first\n      const signedTx = await this.sign(transaction);\n\n      // Get provider\n      const provider = this.engine.networks.getProvider();\n      if (!provider) {\n        throw new Error('No network provider available');\n      }\n\n      // Send the transaction\n      const txResponse = await provider.broadcastTransaction(signedTx.serialized);\n      const hash = txResponse.hash;\n\n      // Store as pending\n      this.pendingTransactions.set(hash, transaction);\n      await this.savePendingTransactions();\n\n      // Start monitoring\n      this.monitorTransaction(hash, txResponse);\n\n      this.emit('transaction:sent', hash, transaction);\n      return hash;\n    } catch (error) {\n      throw new Error(`Failed to send transaction: ${error}`);\n    }\n  }\n\n  /**\n   * Get balance for an address\n   */\n  async getBalance(address: string): Promise<Balance> {\n    this.ensureInitialized();\n\n    try {\n      // Check cache first (with TTL)\n      const cached = this.balanceCache.get(address);\n      if (cached && this.isBalanceCacheValid(cached)) {\n        return cached;\n      }\n\n      // Get current network\n      const network = this.engine.networks.getCurrent();\n      if (!network) {\n        throw new Error('No network selected');\n      }\n\n      // Get provider\n      const provider = this.engine.networks.getProvider();\n      if (!provider) {\n        throw new Error('No network provider available');\n      }\n\n      // Get native balance\n      const nativeBalance = await provider.getBalance(address);\n\n      // Create balance object\n      const balance: Balance = {\n        address,\n        chainId: network.chainId,\n        native: {\n          token: network.gasToken,\n          balance: nativeBalance.toString(),\n          value: '0', // Would calculate USD value in production\n          price: '0'\n        },\n        tokens: [], // Would load ERC-20 tokens in production\n        nfts: [], // Would load NFTs in production\n        totalValue: '0', // Would calculate total USD value\n        lastUpdated: new Date()\n      };\n\n      // Cache the result\n      this.balanceCache.set(address, balance);\n\n      this.emit('balance:updated', address, balance);\n      return balance;\n    } catch (error) {\n      throw new Error(`Failed to get balance: ${error}`);\n    }\n  }\n\n  /**\n   * Get transaction history for an address\n   */\n  async getHistory(address: string, limit = 50): Promise<TransactionHistory[]> {\n    this.ensureInitialized();\n\n    const history = this.transactionHistory.get(address) || [];\n    return history.slice(0, limit);\n  }\n\n  /**\n   * Estimate gas for a transaction\n   */\n  async estimateGas(transaction: Partial<Transaction>): Promise<string> {\n    this.ensureInitialized();\n\n    try {\n      const provider = this.engine.networks.getProvider();\n      if (!provider) {\n        throw new Error('No network provider available');\n      }\n\n      const gasEstimate = await provider.estimateGas({\n        to: transaction.to,\n        value: transaction.value,\n        data: transaction.data\n      });\n\n      return gasEstimate.toString();\n    } catch (error) {\n      throw new Error(`Failed to estimate gas: ${error}`);\n    }\n  }\n\n  /**\n   * Get current gas prices\n   */\n  async getGasPrices(): Promise<{\n    slow: string;\n    standard: string;\n    fast: string;\n    maxFeePerGas?: string;\n    maxPriorityFeePerGas?: string;\n  }> {\n    this.ensureInitialized();\n\n    try {\n      const provider = this.engine.networks.getProvider();\n      if (!provider) {\n        throw new Error('No network provider available');\n      }\n\n      const feeData = await provider.getFeeData();\n\n      // For EIP-1559 networks\n      if (feeData.maxFeePerGas && feeData.maxPriorityFeePerGas) {\n        const baseFee = feeData.maxFeePerGas - feeData.maxPriorityFeePerGas;\n        const slowPriority = feeData.maxPriorityFeePerGas / 2n;\n        const fastPriority = feeData.maxPriorityFeePerGas * 2n;\n\n        return {\n          slow: (baseFee + slowPriority).toString(),\n          standard: feeData.maxFeePerGas.toString(),\n          fast: (baseFee + fastPriority).toString(),\n          maxFeePerGas: feeData.maxFeePerGas.toString(),\n          maxPriorityFeePerGas: feeData.maxPriorityFeePerGas.toString()\n        };\n      }\n\n      // For legacy networks\n      const gasPrice = feeData.gasPrice || 0n;\n      return {\n        slow: (gasPrice * 8n / 10n).toString(), // 80% of current\n        standard: gasPrice.toString(),\n        fast: (gasPrice * 12n / 10n).toString() // 120% of current\n      };\n    } catch (error) {\n      throw new Error(`Failed to get gas prices: ${error}`);\n    }\n  }\n\n  /**\n   * Refresh balance for an address\n   */\n  async refreshBalance(address: string): Promise<Balance> {\n    // Clear cache and fetch fresh balance\n    this.balanceCache.delete(address);\n    return this.getBalance(address);\n  }\n\n  /**\n   * Cancel a pending transaction (if possible)\n   */\n  async cancelTransaction(hash: string): Promise<string> {\n    this.ensureInitialized();\n\n    const pendingTx = this.pendingTransactions.get(hash);\n    if (!pendingTx) {\n      throw new Error('Transaction not found or already confirmed');\n    }\n\n    try {\n      // Create cancellation transaction (send 0 ETH to self with higher gas)\n      const currentAccount = this.engine.getCurrentAccount();\n      if (!currentAccount) {\n        throw new Error('No account selected');\n      }\n\n      const gasPrices = await this.getGasPrices();\n      const cancelTx: Transaction = {\n        to: currentAccount.address,\n        value: '0',\n        chainId: pendingTx.chainId,\n        nonce: pendingTx.nonce,\n        gasLimit: '21000',\n        // Use higher gas price to prioritize cancellation\n        gasPrice: (BigInt(gasPrices.fast) * 11n / 10n).toString() // 110% of fast\n      };\n\n      return this.send(cancelTx);\n    } catch (error) {\n      throw new Error(`Failed to cancel transaction: ${error}`);\n    }\n  }\n\n  /**\n   * Destroy the transaction manager\n   */\n  async destroy(): Promise<void> {\n    this.pendingTransactions.clear();\n    this.transactionHistory.clear();\n    this.balanceCache.clear();\n    this.initialized = false;\n    this.removeAllListeners();\n  }\n\n  /**\n   * Private methods\n   */\n  private async monitorTransaction(hash: string, txResponse: any): Promise<void> {\n    try {\n      const receipt = await txResponse.wait();\n      \n      // Remove from pending\n      this.pendingTransactions.delete(hash);\n      await this.savePendingTransactions();\n\n      // Add to history\n      await this.addToHistory(hash, receipt);\n\n      if (receipt.status === 1) {\n        this.emit('transaction:confirmed', hash, receipt);\n      } else {\n        this.emit('transaction:failed', hash, new Error('Transaction reverted'));\n      }\n    } catch (error) {\n      this.emit('transaction:failed', hash, error as Error);\n    }\n  }\n\n  private async addToHistory(hash: string, receipt: any): Promise<void> {\n    try {\n      const currentAccount = this.engine.getCurrentAccount();\n      if (!currentAccount) return;\n\n      const provider = this.engine.networks.getProvider();\n      if (!provider) return;\n\n      const tx = await provider.getTransaction(hash);\n      if (!tx) return;\n\n      const block = await provider.getBlock(receipt.blockNumber);\n      \n      const historyItem: TransactionHistory = {\n        hash: hash,\n        blockNumber: receipt.blockNumber,\n        timestamp: new Date(block!.timestamp * 1000),\n        from: tx.from || '',\n        to: tx.to || '',\n        value: tx.value.toString(),\n        gasUsed: receipt.gasUsed.toString(),\n        gasPrice: tx.gasPrice?.toString() || '0',\n        status: receipt.status === 1 ? 'confirmed' : 'failed',\n        type: this.determineTransactionType(tx),\n        metadata: {\n          blockHash: receipt.blockHash,\n          transactionIndex: receipt.transactionIndex,\n          logs: receipt.logs\n        }\n      };\n\n      // Add to history for the account\n      const address = currentAccount.address;\n      const existing = this.transactionHistory.get(address) || [];\n      existing.unshift(historyItem); // Add to beginning\n      \n      // Keep only last 1000 transactions\n      if (existing.length > 1000) {\n        existing.splice(1000);\n      }\n      \n      this.transactionHistory.set(address, existing);\n      await this.saveTransactionHistory();\n    } catch (error) {\n      console.error('Failed to add transaction to history:', error);\n    }\n  }\n\n  private determineTransactionType(tx: any): TransactionHistoryType {\n    if (tx.data && tx.data !== '0x') {\n      // Has data, likely a contract interaction\n      return 'contract';\n    }\n    \n    if (tx.value && BigInt(tx.value) > 0) {\n      // Has value, it's a transfer\n      return 'send'; // Could be 'receive' depending on perspective\n    }\n    \n    return 'send';\n  }\n\n  private isBalanceCacheValid(balance: Balance): boolean {\n    const now = new Date();\n    const age = now.getTime() - balance.lastUpdated.getTime();\n    return age < 30000; // 30 seconds cache\n  }\n\n  private async loadTransactionHistory(): Promise<void> {\n    try {\n      const stored = localStorage.getItem('yakkl:transactionHistory');\n      if (stored) {\n        const data = JSON.parse(stored);\n        for (const [address, history] of Object.entries(data)) {\n          // Convert date strings back to Date objects\n          const typedHistory = (history as any[]).map(item => ({\n            ...item,\n            timestamp: new Date(item.timestamp)\n          }));\n          this.transactionHistory.set(address, typedHistory);\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to load transaction history:', error);\n    }\n  }\n\n  private async saveTransactionHistory(): Promise<void> {\n    try {\n      const data = Object.fromEntries(this.transactionHistory);\n      localStorage.setItem('yakkl:transactionHistory', JSON.stringify(data));\n    } catch (error) {\n      console.error('Failed to save transaction history:', error);\n    }\n  }\n\n  private async loadPendingTransactions(): Promise<void> {\n    try {\n      const stored = localStorage.getItem('yakkl:pendingTransactions');\n      if (stored) {\n        const data = JSON.parse(stored);\n        this.pendingTransactions = new Map(Object.entries(data));\n      }\n    } catch (error) {\n      console.warn('Failed to load pending transactions:', error);\n    }\n  }\n\n  private async savePendingTransactions(): Promise<void> {\n    try {\n      const data = Object.fromEntries(this.pendingTransactions);\n      localStorage.setItem('yakkl:pendingTransactions', JSON.stringify(data));\n    } catch (error) {\n      console.error('Failed to save pending transactions:', error);\n    }\n  }\n\n  private ensureInitialized(): void {\n    if (!this.initialized) {\n      throw new Error('TransactionManager not initialized');\n    }\n  }\n}","/**\n * YAKKL Wallet Engine - Core wallet functionality\n * \n * This is the heart of all YAKKL products. Everything builds on this foundation.\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport { ModRegistry } from '../mods/ModRegistry';\nimport { DiscoveryProtocol } from '../mods/DiscoveryProtocol';\nimport { AccountManager } from './AccountManager';\nimport { NetworkManager } from './NetworkManager';\nimport { TransactionManager } from './TransactionManager';\nimport type { \n  WalletConfig, \n  Account, \n  Network, \n  Transaction, \n  SignedTransaction, \n  Balance \n} from './types';\nimport type { Mod } from '../mods/types';\n\nexport interface WalletEngineEvents {\n  'account:created': (account: Account) => void;\n  'account:selected': (account: Account) => void;\n  'transaction:signed': (tx: SignedTransaction) => void;\n  'mod:loaded': (mod: Mod) => void;\n  'mod:discovered': (mods: Mod[]) => void;\n  'network:changed': (network: Network) => void;\n}\n\nexport class WalletEngine extends EventEmitter<WalletEngineEvents> {\n  private config: WalletConfig;\n  private mods: ModRegistry;\n  private discovery: DiscoveryProtocol;\n  public accounts: AccountManager;\n  public networks: NetworkManager;\n  public transactions: TransactionManager;\n  private initialized = false;\n\n  constructor(config: Partial<WalletConfig> = {}) {\n    super();\n    \n    this.config = {\n      name: 'YAKKL Wallet',\n      version: '1.0.0',\n      embedded: false,\n      restrictions: [],\n      modDiscovery: true,\n      ...config\n    };\n\n    // Initialize core managers\n    this.accounts = new AccountManager(this);\n    this.networks = new NetworkManager(this);\n    this.transactions = new TransactionManager(this);\n    \n    // Initialize mod system\n    this.mods = new ModRegistry(this);\n    this.discovery = new DiscoveryProtocol(this);\n  }\n\n  /**\n   * Initialize the wallet engine\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    try {\n      // Initialize core systems\n      await this.accounts.initialize();\n      await this.networks.initialize();\n      await this.transactions.initialize();\n\n      // Initialize mod system\n      await this.mods.initialize();\n      \n      // Start discovery if enabled\n      if (this.config.modDiscovery) {\n        await this.discovery.start();\n      }\n\n      this.initialized = true;\n    } catch (error) {\n      throw new Error(`Failed to initialize wallet engine: ${error}`);\n    }\n  }\n\n  /**\n   * Get wallet configuration\n   */\n  getConfig(): WalletConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Core Account Management\n   */\n  async createAccount(name?: string): Promise<Account> {\n    this.ensureInitialized();\n    const account = await this.accounts.create(name);\n    this.emit('account:created', account);\n    return account;\n  }\n\n  async getAccounts(): Promise<Account[]> {\n    this.ensureInitialized();\n    return this.accounts.getAll();\n  }\n\n  async selectAccount(accountId: string): Promise<void> {\n    this.ensureInitialized();\n    const account = await this.accounts.select(accountId);\n    this.emit('account:selected', account);\n  }\n\n  getCurrentAccount(): Account | null {\n    return this.accounts.getCurrent();\n  }\n\n  /**\n   * Core Network Management\n   */\n  async getSupportedNetworks(): Promise<Network[]> {\n    this.ensureInitialized();\n    return this.networks.getSupported();\n  }\n\n  async switchNetwork(networkId: string): Promise<void> {\n    this.ensureInitialized();\n    const network = await this.networks.switch(networkId);\n    this.emit('network:changed', network);\n  }\n\n  getCurrentNetwork(): Network | null {\n    return this.networks.getCurrent();\n  }\n\n  /**\n   * Core Transaction Management\n   */\n  async signTransaction(transaction: Transaction): Promise<SignedTransaction> {\n    this.ensureInitialized();\n    const signedTx = await this.transactions.sign(transaction);\n    this.emit('transaction:signed', signedTx);\n    return signedTx;\n  }\n\n  async sendTransaction(transaction: Transaction): Promise<string> {\n    this.ensureInitialized();\n    return this.transactions.send(transaction);\n  }\n\n  async getBalance(address?: string): Promise<Balance> {\n    this.ensureInitialized();\n    const account = address ? \n      await this.accounts.getByAddress(address) : \n      this.getCurrentAccount();\n    \n    if (!account) {\n      throw new Error('No account specified or selected');\n    }\n\n    return this.transactions.getBalance(account.address);\n  }\n\n  /**\n   * Mod Management\n   */\n  async loadMod(id: string): Promise<Mod> {\n    this.ensureInitialized();\n    const mod = await this.mods.load(id);\n    this.emit('mod:loaded', mod);\n    return mod;\n  }\n\n  async getLoadedMods(): Promise<Mod[]> {\n    return this.mods.getLoaded();\n  }\n\n  async discoverMods(): Promise<Mod[]> {\n    this.ensureInitialized();\n    const discovered = await this.discovery.scan();\n    this.emit('mod:discovered', discovered);\n    return discovered;\n  }\n\n  /**\n   * Integration APIs\n   */\n  getEmbeddedAPI() {\n    // Will be implemented when we create the embedded API\n    return null;\n  }\n\n  getRemoteAPI() {\n    // Will be implemented when we create the remote API\n    return null;\n  }\n\n  /**\n   * Utility Methods\n   */\n  isInitialized(): boolean {\n    return this.initialized;\n  }\n\n  async destroy(): Promise<void> {\n    await this.discovery.stop();\n    await this.mods.destroy();\n    await this.transactions.destroy();\n    await this.networks.destroy();\n    await this.accounts.destroy();\n    \n    this.removeAllListeners();\n    this.initialized = false;\n  }\n\n  private ensureInitialized(): void {\n    if (!this.initialized) {\n      throw new Error('Wallet engine not initialized. Call initialize() first.');\n    }\n  }\n}","/**\n * EmbeddedAPI - API for embedded wallet implementations\n */\n\nimport { WalletEngine } from '../engine/WalletEngine';\nimport type { Account, Network, Transaction } from '../engine/types';\n\nexport class EmbeddedAPI {\n  private engine: WalletEngine;\n\n  constructor(engine: WalletEngine) {\n    this.engine = engine;\n  }\n\n  /**\n   * Get wallet information\n   */\n  async getWalletInfo() {\n    return {\n      version: '0.1.0',\n      accounts: this.engine.accounts.getAll().length,\n      currentNetwork: this.engine.networks.getCurrent()?.name,\n      isLocked: false // Would check actual lock state\n    };\n  }\n\n  /**\n   * Get current account\n   */\n  async getCurrentAccount(): Promise<Account | null> {\n    return this.engine.getCurrentAccount();\n  }\n\n  /**\n   * Get all accounts\n   */\n  async getAccounts(): Promise<Account[]> {\n    return this.engine.accounts.getAll();\n  }\n\n  /**\n   * Get current network\n   */\n  async getCurrentNetwork(): Promise<Network | null> {\n    return this.engine.networks.getCurrent();\n  }\n\n  /**\n   * Get supported networks\n   */\n  async getSupportedNetworks(): Promise<Network[]> {\n    return this.engine.networks.getSupported();\n  }\n\n  /**\n   * Request account connection\n   */\n  async connect(): Promise<Account[]> {\n    // In embedded mode, return current accounts\n    return this.engine.accounts.getAll();\n  }\n\n  /**\n   * Sign a transaction\n   */\n  async signTransaction(transaction: Transaction): Promise<string> {\n    const signed = await this.engine.transactions.sign(transaction);\n    return signed.serialized;\n  }\n\n  /**\n   * Send a transaction\n   */\n  async sendTransaction(transaction: Transaction): Promise<string> {\n    return this.engine.transactions.send(transaction);\n  }\n\n  /**\n   * Sign a message\n   */\n  async signMessage(message: string): Promise<string> {\n    const currentAccount = this.engine.getCurrentAccount();\n    if (!currentAccount) {\n      throw new Error('No account selected');\n    }\n\n    return this.engine.accounts.signMessage(currentAccount.id, message);\n  }\n}","/**\n * RemoteAPI - API for remote wallet connections\n */\n\nimport { EventEmitter } from 'eventemitter3';\n\nexport interface RemoteWalletEvents {\n  'connected': () => void;\n  'disconnected': () => void;\n  'accountsChanged': (accounts: string[]) => void;\n  'chainChanged': (chainId: string) => void;\n}\n\nexport class RemoteAPI extends EventEmitter<RemoteWalletEvents> {\n  private connected = false;\n  private accounts: string[] = [];\n  private chainId: string | null = null;\n\n  /**\n   * Connect to remote wallet\n   */\n  async connect(): Promise<string[]> {\n    // Simulate connection to external wallet\n    this.connected = true;\n    this.accounts = []; // Would get from remote wallet\n    this.emit('connected');\n    return this.accounts;\n  }\n\n  /**\n   * Disconnect from remote wallet\n   */\n  async disconnect(): Promise<void> {\n    this.connected = false;\n    this.accounts = [];\n    this.chainId = null;\n    this.emit('disconnected');\n  }\n\n  /**\n   * Check if connected\n   */\n  isConnected(): boolean {\n    return this.connected;\n  }\n\n  /**\n   * Get connected accounts\n   */\n  getAccounts(): string[] {\n    return this.accounts;\n  }\n\n  /**\n   * Get current chain ID\n   */\n  getChainId(): string | null {\n    return this.chainId;\n  }\n\n  /**\n   * Request account access\n   */\n  async requestAccounts(): Promise<string[]> {\n    if (!this.connected) {\n      throw new Error('Not connected to remote wallet');\n    }\n    \n    // Would request from remote wallet\n    return this.accounts;\n  }\n\n  /**\n   * Switch network\n   */\n  async switchNetwork(chainId: string): Promise<void> {\n    if (!this.connected) {\n      throw new Error('Not connected to remote wallet');\n    }\n\n    // Would request network switch from remote wallet\n    this.chainId = chainId;\n    this.emit('chainChanged', chainId);\n  }\n}","/**\n * IntegrationAPI - API for third-party integrations\n */\n\nimport { WalletEngine } from '../engine/WalletEngine';\nimport type { WalletConfig } from '../engine/types';\n\nexport interface IntegrationConfig {\n  apiKey?: string;\n  appName: string;\n  appVersion: string;\n  permissions: string[];\n}\n\nexport class IntegrationAPI {\n  private engine: WalletEngine | null = null;\n  private config: IntegrationConfig;\n\n  constructor(config: IntegrationConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Initialize the integration\n   */\n  async initialize(walletConfig?: Partial<WalletConfig>): Promise<void> {\n    const config: WalletConfig = {\n      name: 'YAKKL Integration',\n      version: '1.0.0',\n      embedded: true,\n      restrictions: [],\n      modDiscovery: false,\n      enableMods: true,\n      enableDiscovery: false, // Disable discovery for integrations\n      storagePrefix: `integration:${this.config.appName}`,\n      logLevel: 'warn',\n      ...walletConfig\n    };\n\n    this.engine = new WalletEngine(config);\n    await this.engine.initialize();\n  }\n\n  /**\n   * Get the wallet engine\n   */\n  getEngine(): WalletEngine {\n    if (!this.engine) {\n      throw new Error('Integration not initialized');\n    }\n    return this.engine;\n  }\n\n  /**\n   * Check if a permission is granted\n   */\n  hasPermission(permission: string): boolean {\n    return this.config.permissions.includes(permission);\n  }\n\n  /**\n   * Request additional permissions\n   */\n  async requestPermissions(permissions: string[]): Promise<boolean> {\n    // In a real implementation, this would show a permission dialog\n    // For now, just add to the config\n    for (const permission of permissions) {\n      if (!this.config.permissions.includes(permission)) {\n        this.config.permissions.push(permission);\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Get integration info\n   */\n  getInfo() {\n    return {\n      appName: this.config.appName,\n      appVersion: this.config.appVersion,\n      permissions: this.config.permissions,\n      isInitialized: this.engine !== null\n    };\n  }\n\n  /**\n   * Destroy the integration\n   */\n  async destroy(): Promise<void> {\n    if (this.engine) {\n      await this.engine.destroy();\n      this.engine = null;\n    }\n  }\n}"],"names":["AccountManager","EventEmitter","engine","error","name","wallet","ethers","account","privateKey","acc","address","accountId","updates","updatedAccount","firstAccount","a","b","normalizedAddress","message","stored","accountsData","NetworkManager","networkId","network","networkConfig","updatedNetwork","provider","defaultNetwork","n","id","chainId","blockNumber","feeData","defaultNetworks","customNetworks","ethereum","config","TransactionManager","transaction","currentAccount","connectedWallet","txRequest","populatedTx","signedTxResponse","parsedTx","signedTransaction","signedTx","txResponse","hash","cached","nativeBalance","balance","limit","baseFee","slowPriority","fastPriority","gasPrice","pendingTx","gasPrices","cancelTx","receipt","tx","block","historyItem","existing","data","history","typedHistory","item","WalletEngine","ModRegistry","DiscoveryProtocol","mod","discovered","EmbeddedAPI","RemoteAPI","IntegrationAPI","walletConfig","permission","permissions"],"mappings":"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"}