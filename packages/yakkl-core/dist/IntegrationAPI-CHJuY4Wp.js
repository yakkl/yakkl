"use strict";const l=require("eventemitter3"),g=require("./DiscoveryProtocol--RRJFQsX.js"),o=require("ethers");class y extends l.EventEmitter{constructor(t){super(),this.accounts=new Map,this.currentAccountId=null,this.initialized=!1,this.engine=t}async initialize(){if(!this.initialized)try{await this.loadAccounts(),await this.loadCurrentAccount(),this.initialized=!0}catch(t){throw new Error(`Failed to initialize AccountManager: ${t}`)}}async create(t){this.ensureInitialized();try{const e=o.ethers.Wallet.createRandom(),r={id:this.generateId(),address:e.address,name:t||`Account ${this.accounts.size+1}`,type:"eoa",publicKey:e.signingKey.publicKey,derivationPath:void 0,ens:void 0,username:void 0,avatar:void 0,createdAt:new Date,lastUsed:new Date,metadata:{isHardware:!1,isImported:!1,isWatchOnly:!1}};return this.accounts.set(r.id,r),await this.storePrivateKey(r.id,e.privateKey),await this.saveAccounts(),this.emit("account:created",r),this.accounts.size===1&&await this.select(r.id),r}catch(e){throw new Error(`Failed to create account: ${e}`)}}async importFromPrivateKey(t,e){this.ensureInitialized();try{const r=new o.ethers.Wallet(t);if(Array.from(this.accounts.values()).find(i=>i.address.toLowerCase()===r.address.toLowerCase()))throw new Error("Account already exists");const s={id:this.generateId(),address:r.address,name:e||"Imported Account",type:"eoa",publicKey:r.signingKey.publicKey,derivationPath:void 0,ens:void 0,username:void 0,avatar:void 0,createdAt:new Date,lastUsed:new Date,metadata:{isHardware:!1,isImported:!0,isWatchOnly:!1}};return this.accounts.set(s.id,s),await this.storePrivateKey(s.id,t),await this.saveAccounts(),this.emit("account:created",s),s}catch(r){throw new Error(`Failed to import account: ${r}`)}}async addWatchOnly(t,e){this.ensureInitialized();try{if(!o.ethers.isAddress(t))throw new Error("Invalid address");if(Array.from(this.accounts.values()).find(s=>s.address.toLowerCase()===t.toLowerCase()))throw new Error("Account already exists");const n={id:this.generateId(),address:o.ethers.getAddress(t),name:e||"Watch-Only Account",type:"watched",publicKey:"",derivationPath:void 0,ens:void 0,username:void 0,avatar:void 0,createdAt:new Date,lastUsed:new Date,metadata:{isHardware:!1,isImported:!1,isWatchOnly:!0}};return this.accounts.set(n.id,n),await this.saveAccounts(),this.emit("account:created",n),n}catch(r){throw new Error(`Failed to add watch-only account: ${r}`)}}async update(t,e){this.ensureInitialized();const r=this.accounts.get(t);if(!r)throw new Error("Account not found");const n={...r,...e,id:r.id,address:r.address,lastUsed:new Date};return this.accounts.set(t,n),await this.saveAccounts(),this.emit("account:updated",n),n}async remove(t){if(this.ensureInitialized(),!this.accounts.get(t))throw new Error("Account not found");if(this.accounts.size===1)throw new Error("Cannot remove the last account");if(this.accounts.delete(t),await this.removePrivateKey(t),await this.saveAccounts(),this.currentAccountId===t){const r=Array.from(this.accounts.values())[0];await this.select(r.id)}this.emit("account:removed",t)}async select(t){this.ensureInitialized();const e=this.accounts.get(t);if(!e)throw new Error("Account not found");const r={...e,lastUsed:new Date};return this.accounts.set(t,r),this.currentAccountId=t,await this.saveCurrentAccount(),await this.saveAccounts(),this.emit("account:selected",r),r}getAll(){return Array.from(this.accounts.values()).sort((t,e)=>e.lastUsed.getTime()-t.lastUsed.getTime())}get(t){return this.accounts.get(t)||null}async getByAddress(t){const e=t.toLowerCase();return Array.from(this.accounts.values()).find(r=>r.address.toLowerCase()===e)||null}getCurrent(){return this.currentAccountId&&this.accounts.get(this.currentAccountId)||null}async getPrivateKey(t){this.ensureInitialized();const e=this.accounts.get(t);if(!e)throw new Error("Account not found");if(e.type==="watched")throw new Error("Watch-only accounts have no private key");return this.loadPrivateKey(t)}async signMessage(t,e){const r=await this.getPrivateKey(t);return new o.ethers.Wallet(r).signMessage(e)}async destroy(){this.accounts.clear(),this.currentAccountId=null,this.initialized=!1,this.removeAllListeners()}generateId(){return`acc_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}async loadAccounts(){try{const t=localStorage.getItem("yakkl:accounts");if(t){const e=JSON.parse(t);for(const r of e)r.createdAt=new Date(r.createdAt),r.lastUsed=new Date(r.lastUsed),this.accounts.set(r.id,r)}}catch(t){console.warn("Failed to load accounts:",t)}}async saveAccounts(){try{const t=Array.from(this.accounts.values());localStorage.setItem("yakkl:accounts",JSON.stringify(t))}catch(t){throw console.error("Failed to save accounts:",t),t}}async loadCurrentAccount(){try{const t=localStorage.getItem("yakkl:currentAccount");t&&this.accounts.has(t)?this.currentAccountId=t:this.accounts.size>0&&(this.currentAccountId=Array.from(this.accounts.keys())[0])}catch(t){console.warn("Failed to load current account:",t)}}async saveCurrentAccount(){try{this.currentAccountId&&localStorage.setItem("yakkl:currentAccount",this.currentAccountId)}catch(t){console.error("Failed to save current account:",t)}}async storePrivateKey(t,e){try{localStorage.setItem(`yakkl:pk:${t}`,e)}catch(r){throw console.error("Failed to store private key:",r),r}}async loadPrivateKey(t){try{const e=localStorage.getItem(`yakkl:pk:${t}`);if(!e)throw new Error("Private key not found");return e}catch(e){throw console.error("Failed to load private key:",e),e}}async removePrivateKey(t){try{localStorage.removeItem(`yakkl:pk:${t}`)}catch(e){console.error("Failed to remove private key:",e)}}ensureInitialized(){if(!this.initialized)throw new Error("AccountManager not initialized")}}class m extends l.EventEmitter{constructor(t){super(),this.networks=new Map,this.providers=new Map,this.currentNetworkId=null,this.initialized=!1,this.engine=t}async initialize(){if(!this.initialized)try{await this.loadDefaultNetworks(),await this.loadCustomNetworks(),await this.loadCurrentNetwork(),this.initialized=!0}catch(t){throw new Error(`Failed to initialize NetworkManager: ${t}`)}}getSupported(){return Array.from(this.networks.values()).sort((t,e)=>t.isMainnet&&!e.isMainnet?-1:!t.isMainnet&&e.isMainnet?1:!t.isTestnet&&e.isTestnet?-1:t.isTestnet&&!e.isTestnet?1:t.name.localeCompare(e.name))}get(t){return this.networks.get(t)||null}getCurrent(){return this.currentNetworkId&&this.networks.get(this.currentNetworkId)||null}async switch(t){this.ensureInitialized();const e=this.networks.get(t);if(!e)throw new Error("Network not found");return await this.testConnection(e),this.currentNetworkId=t,await this.saveCurrentNetwork(),this.emit("network:switched",e),e}async add(t){if(this.ensureInitialized(),await this.validateNetworkConfig(t),Array.from(this.networks.values()).find(n=>n.chainId===t.chainId))throw new Error("Network with this chain ID already exists");const r={id:this.generateNetworkId(),...t,isCustom:!0};return this.networks.set(r.id,r),await this.saveCustomNetworks(),this.emit("network:added",r),r}async update(t,e){this.ensureInitialized();const r=this.networks.get(t);if(!r)throw new Error("Network not found");if(!r.isCustom)throw new Error("Cannot update built-in networks");const n={...r,...e,id:r.id,isCustom:!0};return await this.validateNetworkConfig(n),this.networks.set(t,n),await this.saveCustomNetworks(),this.emit("network:updated",n),n}async remove(t){this.ensureInitialized();const e=this.networks.get(t);if(!e)throw new Error("Network not found");if(!e.isCustom)throw new Error("Cannot remove built-in networks");const r=this.providers.get(t);if(r&&(r.destroy(),this.providers.delete(t)),this.networks.delete(t),await this.saveCustomNetworks(),this.currentNetworkId===t){const n=Array.from(this.networks.values()).find(s=>s.isMainnet&&!s.isCustom);n&&await this.switch(n.id)}this.emit("network:removed",t)}getProvider(t){const e=t||this.currentNetworkId;if(!e)return null;if(this.providers.has(e))return this.providers.get(e);const r=this.networks.get(e);if(!r)return null;try{const n=new o.ethers.JsonRpcProvider(r.rpcUrl);return this.providers.set(e,n),n}catch(n){return console.error(`Failed to create provider for network ${e}:`,n),null}}async testConnection(t){try{const r=await new o.ethers.JsonRpcProvider(t.rpcUrl).getNetwork();if(Number(r.chainId)!==t.chainId)throw new Error("Chain ID mismatch");return!0}catch(e){throw new Error(`Network connection failed: ${e}`)}}async getNetworkStats(t){const e=this.getProvider(t);if(!e)throw new Error("No provider available");try{const[r,n,s]=await Promise.all([e.getBlockNumber(),e.getFeeData(),e.getNetwork()]);return{blockNumber:r,gasPrice:n.gasPrice||0n,chainId:Number(s.chainId)}}catch(r){throw new Error(`Failed to get network stats: ${r}`)}}async destroy(){for(const t of this.providers.values())t.destroy();this.networks.clear(),this.providers.clear(),this.currentNetworkId=null,this.initialized=!1,this.removeAllListeners()}async loadDefaultNetworks(){const t=[{id:"ethereum",name:"Ethereum",chainId:1,symbol:"ETH",rpcUrl:"https://eth.llamarpc.com",blockExplorerUrl:"https://etherscan.io",isTestnet:!1,isMainnet:!0,isCustom:!1,iconUrl:"/networks/ethereum.png",gasToken:{address:"0x0000000000000000000000000000000000000000",symbol:"ETH",name:"Ethereum",decimals:18,chainId:1,isNative:!0,isStable:!1},supportedFeatures:["eip1559","eip2930","contracts","tokens","nft","defi","staking"]},{id:"polygon",name:"Polygon",chainId:137,symbol:"MATIC",rpcUrl:"https://polygon-rpc.com",blockExplorerUrl:"https://polygonscan.com",isTestnet:!1,isMainnet:!0,isCustom:!1,iconUrl:"/networks/polygon.png",gasToken:{address:"0x0000000000000000000000000000000000000000",symbol:"MATIC",name:"Polygon",decimals:18,chainId:137,isNative:!0,isStable:!1},supportedFeatures:["eip1559","eip2930","contracts","tokens","nft","defi","bridges"]},{id:"arbitrum",name:"Arbitrum One",chainId:42161,symbol:"ETH",rpcUrl:"https://arb1.arbitrum.io/rpc",blockExplorerUrl:"https://arbiscan.io",isTestnet:!1,isMainnet:!0,isCustom:!1,iconUrl:"/networks/arbitrum.png",gasToken:{address:"0x0000000000000000000000000000000000000000",symbol:"ETH",name:"Ethereum",decimals:18,chainId:42161,isNative:!0,isStable:!1},supportedFeatures:["contracts","tokens","nft","defi","bridges"]},{id:"sepolia",name:"Sepolia",chainId:11155111,symbol:"ETH",rpcUrl:"https://rpc.sepolia.org",blockExplorerUrl:"https://sepolia.etherscan.io",isTestnet:!0,isMainnet:!1,isCustom:!1,iconUrl:"/networks/ethereum.png",gasToken:{address:"0x0000000000000000000000000000000000000000",symbol:"ETH",name:"Ethereum",decimals:18,chainId:11155111,isNative:!0,isStable:!1},supportedFeatures:["eip1559","eip2930","contracts","tokens","nft"]}];for(const e of t)this.networks.set(e.id,e)}async loadCustomNetworks(){try{const t=localStorage.getItem("yakkl:customNetworks");if(t){const e=JSON.parse(t);for(const r of e)this.networks.set(r.id,r)}}catch(t){console.warn("Failed to load custom networks:",t)}}async saveCustomNetworks(){try{const t=Array.from(this.networks.values()).filter(e=>e.isCustom);localStorage.setItem("yakkl:customNetworks",JSON.stringify(t))}catch(t){throw console.error("Failed to save custom networks:",t),t}}async loadCurrentNetwork(){try{const t=localStorage.getItem("yakkl:currentNetwork");if(t&&this.networks.has(t))this.currentNetworkId=t;else{const e=Array.from(this.networks.values()).find(r=>r.chainId===1);e&&(this.currentNetworkId=e.id)}}catch(t){console.warn("Failed to load current network:",t)}}async saveCurrentNetwork(){try{this.currentNetworkId&&localStorage.setItem("yakkl:currentNetwork",this.currentNetworkId)}catch(t){console.error("Failed to save current network:",t)}}async validateNetworkConfig(t){if(!t.name||!t.chainId||!t.rpcUrl)throw new Error("Network name, chainId, and rpcUrl are required");if(t.chainId<=0)throw new Error("Chain ID must be positive");try{new URL(t.rpcUrl)}catch{throw new Error("Invalid RPC URL")}if(t.blockExplorerUrl)try{new URL(t.blockExplorerUrl)}catch{throw new Error("Invalid block explorer URL")}}generateNetworkId(){return`net_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}ensureInitialized(){if(!this.initialized)throw new Error("NetworkManager not initialized")}}class f extends l.EventEmitter{constructor(t){super(),this.pendingTransactions=new Map,this.transactionHistory=new Map,this.balanceCache=new Map,this.initialized=!1,this.engine=t}async initialize(){if(!this.initialized)try{await this.loadTransactionHistory(),await this.loadPendingTransactions(),this.initialized=!0}catch(t){throw new Error(`Failed to initialize TransactionManager: ${t}`)}}async sign(t){this.ensureInitialized();try{const e=this.engine.getCurrentAccount();if(!e)throw new Error("No account selected");const r=await this.engine.accounts.getPrivateKey(e.id),n=new o.ethers.Wallet(r),s=this.engine.networks.getProvider();if(!s)throw new Error("No network provider available");const i=n.connect(s),u={to:t.to,value:t.value,data:t.data,gasLimit:t.gasLimit,gasPrice:t.gasPrice,maxFeePerGas:t.maxFeePerGas,maxPriorityFeePerGas:t.maxPriorityFeePerGas,nonce:t.nonce,type:t.type},a=await i.populateTransaction(u),c=await i.signTransaction(a),h=o.ethers.Transaction.from(c),w={transaction:{...t,gasLimit:a.gasLimit?.toString(),gasPrice:a.gasPrice?.toString(),maxFeePerGas:a.maxFeePerGas?.toString(),maxPriorityFeePerGas:a.maxPriorityFeePerGas?.toString(),nonce:a.nonce||0},signature:{r:h.signature.r,s:h.signature.s,v:h.signature.v||0},hash:h.hash,serialized:c};return this.emit("transaction:signed",w),w}catch(e){throw new Error(`Failed to sign transaction: ${e}`)}}async send(t){this.ensureInitialized();try{const e=await this.sign(t),r=this.engine.networks.getProvider();if(!r)throw new Error("No network provider available");const n=await r.broadcastTransaction(e.serialized),s=n.hash;return this.pendingTransactions.set(s,t),await this.savePendingTransactions(),this.monitorTransaction(s,n),this.emit("transaction:sent",s,t),s}catch(e){throw new Error(`Failed to send transaction: ${e}`)}}async getBalance(t){this.ensureInitialized();try{const e=this.balanceCache.get(t);if(e&&this.isBalanceCacheValid(e))return e;const r=this.engine.networks.getCurrent();if(!r)throw new Error("No network selected");const n=this.engine.networks.getProvider();if(!n)throw new Error("No network provider available");const s=await n.getBalance(t),i={address:t,chainId:r.chainId,native:{token:r.gasToken,balance:s.toString(),value:"0",price:"0"},tokens:[],nfts:[],totalValue:"0",lastUpdated:new Date};return this.balanceCache.set(t,i),this.emit("balance:updated",t,i),i}catch(e){throw new Error(`Failed to get balance: ${e}`)}}async getHistory(t,e=50){return this.ensureInitialized(),(this.transactionHistory.get(t)||[]).slice(0,e)}async estimateGas(t){this.ensureInitialized();try{const e=this.engine.networks.getProvider();if(!e)throw new Error("No network provider available");return(await e.estimateGas({to:t.to,value:t.value,data:t.data})).toString()}catch(e){throw new Error(`Failed to estimate gas: ${e}`)}}async getGasPrices(){this.ensureInitialized();try{const t=this.engine.networks.getProvider();if(!t)throw new Error("No network provider available");const e=await t.getFeeData();if(e.maxFeePerGas&&e.maxPriorityFeePerGas){const n=e.maxFeePerGas-e.maxPriorityFeePerGas,s=e.maxPriorityFeePerGas/2n,i=e.maxPriorityFeePerGas*2n;return{slow:(n+s).toString(),standard:e.maxFeePerGas.toString(),fast:(n+i).toString(),maxFeePerGas:e.maxFeePerGas.toString(),maxPriorityFeePerGas:e.maxPriorityFeePerGas.toString()}}const r=e.gasPrice||0n;return{slow:(r*8n/10n).toString(),standard:r.toString(),fast:(r*12n/10n).toString()}}catch(t){throw new Error(`Failed to get gas prices: ${t}`)}}async refreshBalance(t){return this.balanceCache.delete(t),this.getBalance(t)}async cancelTransaction(t){this.ensureInitialized();const e=this.pendingTransactions.get(t);if(!e)throw new Error("Transaction not found or already confirmed");try{const r=this.engine.getCurrentAccount();if(!r)throw new Error("No account selected");const n=await this.getGasPrices(),s={to:r.address,value:"0",chainId:e.chainId,nonce:e.nonce,gasLimit:"21000",gasPrice:(BigInt(n.fast)*11n/10n).toString()};return this.send(s)}catch(r){throw new Error(`Failed to cancel transaction: ${r}`)}}async destroy(){this.pendingTransactions.clear(),this.transactionHistory.clear(),this.balanceCache.clear(),this.initialized=!1,this.removeAllListeners()}async monitorTransaction(t,e){try{const r=await e.wait();this.pendingTransactions.delete(t),await this.savePendingTransactions(),await this.addToHistory(t,r),r.status===1?this.emit("transaction:confirmed",t,r):this.emit("transaction:failed",t,new Error("Transaction reverted"))}catch(r){this.emit("transaction:failed",t,r)}}async addToHistory(t,e){try{const r=this.engine.getCurrentAccount();if(!r)return;const n=this.engine.networks.getProvider();if(!n)return;const s=await n.getTransaction(t);if(!s)return;const i=await n.getBlock(e.blockNumber),u={hash:t,blockNumber:e.blockNumber,timestamp:new Date(i.timestamp*1e3),from:s.from||"",to:s.to||"",value:s.value.toString(),gasUsed:e.gasUsed.toString(),gasPrice:s.gasPrice?.toString()||"0",status:e.status===1?"confirmed":"failed",type:this.determineTransactionType(s),metadata:{blockHash:e.blockHash,transactionIndex:e.transactionIndex,logs:e.logs}},a=r.address,c=this.transactionHistory.get(a)||[];c.unshift(u),c.length>1e3&&c.splice(1e3),this.transactionHistory.set(a,c),await this.saveTransactionHistory()}catch(r){console.error("Failed to add transaction to history:",r)}}determineTransactionType(t){return t.data&&t.data!=="0x"?"contract":(t.value&&BigInt(t.value)>0,"send")}isBalanceCacheValid(t){return new Date().getTime()-t.lastUpdated.getTime()<3e4}async loadTransactionHistory(){try{const t=localStorage.getItem("yakkl:transactionHistory");if(t){const e=JSON.parse(t);for(const[r,n]of Object.entries(e)){const s=n.map(i=>({...i,timestamp:new Date(i.timestamp)}));this.transactionHistory.set(r,s)}}}catch(t){console.warn("Failed to load transaction history:",t)}}async saveTransactionHistory(){try{const t=Object.fromEntries(this.transactionHistory);localStorage.setItem("yakkl:transactionHistory",JSON.stringify(t))}catch(t){console.error("Failed to save transaction history:",t)}}async loadPendingTransactions(){try{const t=localStorage.getItem("yakkl:pendingTransactions");if(t){const e=JSON.parse(t);this.pendingTransactions=new Map(Object.entries(e))}}catch(t){console.warn("Failed to load pending transactions:",t)}}async savePendingTransactions(){try{const t=Object.fromEntries(this.pendingTransactions);localStorage.setItem("yakkl:pendingTransactions",JSON.stringify(t))}catch(t){console.error("Failed to save pending transactions:",t)}}ensureInitialized(){if(!this.initialized)throw new Error("TransactionManager not initialized")}}class p extends l.EventEmitter{constructor(t={}){super(),this.initialized=!1,this.config={name:"YAKKL Wallet",version:"1.0.0",embedded:!1,restrictions:[],modDiscovery:!0,...t},this.accounts=new y(this),this.networks=new m(this),this.transactions=new f(this),this.mods=new g.ModRegistry(this),this.discovery=new g.DiscoveryProtocol(this)}async initialize(){if(!this.initialized)try{await this.accounts.initialize(),await this.networks.initialize(),await this.transactions.initialize(),await this.mods.initialize(),this.config.modDiscovery&&await this.discovery.start(),this.initialized=!0}catch(t){throw new Error(`Failed to initialize wallet engine: ${t}`)}}getConfig(){return{...this.config}}async createAccount(t){this.ensureInitialized();const e=await this.accounts.create(t);return this.emit("account:created",e),e}async getAccounts(){return this.ensureInitialized(),this.accounts.getAll()}async selectAccount(t){this.ensureInitialized();const e=await this.accounts.select(t);this.emit("account:selected",e)}getCurrentAccount(){return this.accounts.getCurrent()}async getSupportedNetworks(){return this.ensureInitialized(),this.networks.getSupported()}async switchNetwork(t){this.ensureInitialized();const e=await this.networks.switch(t);this.emit("network:changed",e)}getCurrentNetwork(){return this.networks.getCurrent()}async signTransaction(t){this.ensureInitialized();const e=await this.transactions.sign(t);return this.emit("transaction:signed",e),e}async sendTransaction(t){return this.ensureInitialized(),this.transactions.send(t)}async getBalance(t){this.ensureInitialized();const e=t?await this.accounts.getByAddress(t):this.getCurrentAccount();if(!e)throw new Error("No account specified or selected");return this.transactions.getBalance(e.address)}async loadMod(t){this.ensureInitialized();const e=await this.mods.load(t);return this.emit("mod:loaded",e),e}async getLoadedMods(){return this.mods.getLoaded()}async discoverMods(){this.ensureInitialized();const t=await this.discovery.scan();return this.emit("mod:discovered",t),t}getEmbeddedAPI(){return null}getRemoteAPI(){return null}isInitialized(){return this.initialized}async destroy(){await this.discovery.stop(),await this.mods.destroy(),await this.transactions.destroy(),await this.networks.destroy(),await this.accounts.destroy(),this.removeAllListeners(),this.initialized=!1}ensureInitialized(){if(!this.initialized)throw new Error("Wallet engine not initialized. Call initialize() first.")}}class k{constructor(t){this.engine=t}async getWalletInfo(){return{version:"0.1.0",accounts:this.engine.accounts.getAll().length,currentNetwork:this.engine.networks.getCurrent()?.name,isLocked:!1}}async getCurrentAccount(){return this.engine.getCurrentAccount()}async getAccounts(){return this.engine.accounts.getAll()}async getCurrentNetwork(){return this.engine.networks.getCurrent()}async getSupportedNetworks(){return this.engine.networks.getSupported()}async connect(){return this.engine.accounts.getAll()}async signTransaction(t){return(await this.engine.transactions.sign(t)).serialized}async sendTransaction(t){return this.engine.transactions.send(t)}async signMessage(t){const e=this.engine.getCurrentAccount();if(!e)throw new Error("No account selected");return this.engine.accounts.signMessage(e.id,t)}}class v extends l.EventEmitter{constructor(){super(...arguments),this.connected=!1,this.accounts=[],this.chainId=null}async connect(){return this.connected=!0,this.accounts=[],this.emit("connected"),this.accounts}async disconnect(){this.connected=!1,this.accounts=[],this.chainId=null,this.emit("disconnected")}isConnected(){return this.connected}getAccounts(){return this.accounts}getChainId(){return this.chainId}async requestAccounts(){if(!this.connected)throw new Error("Not connected to remote wallet");return this.accounts}async switchNetwork(t){if(!this.connected)throw new Error("Not connected to remote wallet");this.chainId=t,this.emit("chainChanged",t)}}class I{constructor(t){this.engine=null,this.config=t}async initialize(t){const e={name:"YAKKL Integration",version:"1.0.0",embedded:!0,restrictions:[],modDiscovery:!1,enableMods:!0,enableDiscovery:!1,storagePrefix:`integration:${this.config.appName}`,logLevel:"warn",...t};this.engine=new p(e),await this.engine.initialize()}getEngine(){if(!this.engine)throw new Error("Integration not initialized");return this.engine}hasPermission(t){return this.config.permissions.includes(t)}async requestPermissions(t){for(const e of t)this.config.permissions.includes(e)||this.config.permissions.push(e);return!0}getInfo(){return{appName:this.config.appName,appVersion:this.config.appVersion,permissions:this.config.permissions,isInitialized:this.engine!==null}}async destroy(){this.engine&&(await this.engine.destroy(),this.engine=null)}}exports.AccountManager=y;exports.EmbeddedAPI=k;exports.IntegrationAPI=I;exports.NetworkManager=m;exports.RemoteAPI=v;exports.TransactionManager=f;exports.WalletEngine=p;
//# sourceMappingURL=IntegrationAPI-CHJuY4Wp.js.map
