{"version":3,"file":"DiscoveryProtocol--RRJFQsX.js","sources":["../src/utils/Logger.ts","../src/mods/ModLoader.ts","../src/mods/ModRegistry.ts","../src/mods/DiscoveryProtocol.ts"],"sourcesContent":["/**\n * Logger utility for YAKKL Core\n */\n\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3\n}\n\nexport class Logger {\n  private context: string;\n  private level: LogLevel;\n\n  constructor(context: string, level: LogLevel = LogLevel.INFO) {\n    this.context = context;\n    this.level = level;\n  }\n\n  debug(message: string, ...args: any[]): void {\n    if (this.level <= LogLevel.DEBUG) {\n      console.debug(`[${this.context}] ${message}`, ...args);\n    }\n  }\n\n  info(message: string, ...args: any[]): void {\n    if (this.level <= LogLevel.INFO) {\n      console.info(`[${this.context}] ${message}`, ...args);\n    }\n  }\n\n  warn(message: string, error?: Error | any): void {\n    if (this.level <= LogLevel.WARN) {\n      if (error) {\n        console.warn(`[${this.context}] ${message}`, error);\n      } else {\n        console.warn(`[${this.context}] ${message}`);\n      }\n    }\n  }\n\n  error(message: string, error?: Error | any): void {\n    if (this.level <= LogLevel.ERROR) {\n      if (error) {\n        console.error(`[${this.context}] ${message}`, error);\n      } else {\n        console.error(`[${this.context}] ${message}`);\n      }\n    }\n  }\n\n  setLevel(level: LogLevel): void {\n    this.level = level;\n  }\n}","/**\n * ModLoader - Dynamically loads and instantiates mods\n */\n\nimport type { Mod, ModManifest } from './types';\nimport { Logger } from '../utils/Logger';\n\nexport interface ModSource {\n  type: 'local' | 'npm' | 'url' | 'system';\n  location: string;\n  verified: boolean;\n}\n\nexport class ModLoader {\n  private logger: Logger;\n  private loadedModules = new Map<string, any>();\n  private systemMods = new Map<string, () => Promise<any>>();\n\n  constructor() {\n    this.logger = new Logger('ModLoader');\n    this.registerSystemMods();\n  }\n\n  /**\n   * Load a mod by ID\n   */\n  async load(modId: string): Promise<Mod> {\n    this.logger.info(`Loading mod: ${modId}`);\n\n    try {\n      // Check if already loaded\n      if (this.loadedModules.has(modId)) {\n        const module = this.loadedModules.get(modId);\n        return this.instantiateMod(module);\n      }\n\n      // Try to load from different sources\n      const sources = await this.resolveModSources(modId);\n      \n      for (const source of sources) {\n        try {\n          const module = await this.loadFromSource(modId, source);\n          if (module) {\n            this.loadedModules.set(modId, module);\n            return this.instantiateMod(module);\n          }\n        } catch (error) {\n          this.logger.warn(`Failed to load from ${source.type}: ${source.location}`, error as Error);\n          continue;\n        }\n      }\n\n      throw new Error(`Mod ${modId} not found in any source`);\n    } catch (error) {\n      this.logger.error(`Failed to load mod ${modId}`, error as Error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get list of user-installed mods\n   */\n  async getUserMods(): Promise<string[]> {\n    try {\n      // Get from local storage or user directory\n      const stored = localStorage.getItem('yakkl:userMods');\n      if (stored) {\n        return JSON.parse(stored);\n      }\n      return [];\n    } catch (error) {\n      this.logger.warn('Failed to get user mods', error as Error);\n      return [];\n    }\n  }\n\n  /**\n   * Install a mod\n   */\n  async install(modId: string, source: ModSource): Promise<void> {\n    this.logger.info(`Installing mod: ${modId} from ${source.type}`);\n\n    try {\n      // Load and validate the mod\n      const module = await this.loadFromSource(modId, source);\n      if (!module) {\n        throw new Error('Failed to load mod module');\n      }\n\n      // Validate manifest\n      await this.validateMod(module);\n\n      // Add to user mods list\n      const userMods = await this.getUserMods();\n      if (!userMods.includes(modId)) {\n        userMods.push(modId);\n        localStorage.setItem('yakkl:userMods', JSON.stringify(userMods));\n      }\n\n      // Cache the module\n      this.loadedModules.set(modId, module);\n\n      this.logger.info(`Mod ${modId} installed successfully`);\n    } catch (error) {\n      this.logger.error(`Failed to install mod ${modId}`, error as Error);\n      throw error;\n    }\n  }\n\n  /**\n   * Uninstall a mod\n   */\n  async uninstall(modId: string): Promise<void> {\n    this.logger.info(`Uninstalling mod: ${modId}`);\n\n    try {\n      // Remove from user mods list\n      const userMods = await this.getUserMods();\n      const updated = userMods.filter(id => id !== modId);\n      localStorage.setItem('yakkl:userMods', JSON.stringify(updated));\n\n      // Remove from cache\n      this.loadedModules.delete(modId);\n\n      // Remove mod-specific storage\n      await this.cleanupModStorage(modId);\n\n      this.logger.info(`Mod ${modId} uninstalled successfully`);\n    } catch (error) {\n      this.logger.error(`Failed to uninstall mod ${modId}`, error as Error);\n      throw error;\n    }\n  }\n\n  /**\n   * Check if a mod is available\n   */\n  async isAvailable(modId: string): Promise<boolean> {\n    try {\n      const sources = await this.resolveModSources(modId);\n      return sources.length > 0;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get mod manifest without loading the mod\n   */\n  async getManifest(modId: string): Promise<ModManifest | null> {\n    try {\n      const sources = await this.resolveModSources(modId);\n      \n      for (const source of sources) {\n        try {\n          const manifest = await this.loadManifestFromSource(modId, source);\n          if (manifest) {\n            return manifest;\n          }\n        } catch {\n          continue;\n        }\n      }\n      \n      return null;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Private methods\n   */\n  private registerSystemMods(): void {\n    // Register built-in system mods\n    this.systemMods.set('basic-portfolio', async () => {\n      // System mod would be dynamically loaded or imported\n      // For now, return a mock implementation\n      throw new Error('System mod basic-portfolio not implemented');\n    });\n\n    // Add more system mods as they're created\n    this.systemMods.set('account-manager', async () => {\n      // Would import AccountManagerMod when created\n      throw new Error('System mod account-manager not implemented');\n    });\n\n    this.systemMods.set('network-manager', async () => {\n      // Would import NetworkManagerMod when created\n      throw new Error('System mod network-manager not implemented');\n    });\n  }\n\n  private async resolveModSources(modId: string): Promise<ModSource[]> {\n    const sources: ModSource[] = [];\n\n    // System mods (highest priority)\n    if (this.systemMods.has(modId)) {\n      sources.push({\n        type: 'system',\n        location: modId,\n        verified: true\n      });\n    }\n\n    // Local development mods\n    sources.push({\n      type: 'local',\n      location: `/src/routes/preview2/lib/mods/${modId}/index.ts`,\n      verified: true\n    });\n\n    // User-installed NPM mods\n    sources.push({\n      type: 'npm',\n      location: `@yakkl/mod-${modId}`,\n      verified: false\n    });\n\n    // Official YAKKL mods registry\n    sources.push({\n      type: 'url',\n      location: `https://registry.yakkl.com/mods/${modId}/latest.js`,\n      verified: true\n    });\n\n    return sources;\n  }\n\n  private async loadFromSource(modId: string, source: ModSource): Promise<any> {\n    switch (source.type) {\n      case 'system':\n        return this.loadSystemMod(modId);\n      \n      case 'local':\n        return this.loadLocalMod(source.location);\n      \n      case 'npm':\n        return this.loadNpmMod(source.location);\n      \n      case 'url':\n        return this.loadUrlMod(source.location);\n      \n      default:\n        throw new Error(`Unknown source type: ${source.type}`);\n    }\n  }\n\n  private async loadSystemMod(modId: string): Promise<any> {\n    const loader = this.systemMods.get(modId);\n    if (!loader) {\n      throw new Error(`System mod ${modId} not found`);\n    }\n\n    try {\n      return await loader();\n    } catch (error) {\n      // System mod might not be implemented yet\n      this.logger.warn(`System mod ${modId} not implemented`, error as Error);\n      return null;\n    }\n  }\n\n  private async loadLocalMod(location: string): Promise<any> {\n    try {\n      // Dynamic import for local development\n      return await import(/* @vite-ignore */ location);\n    } catch (error) {\n      throw new Error(`Failed to load local mod: ${error}`);\n    }\n  }\n\n  private async loadNpmMod(packageName: string): Promise<any> {\n    try {\n      // Dynamic import for NPM packages\n      return await import(/* @vite-ignore */ packageName);\n    } catch (error) {\n      throw new Error(`Failed to load NPM mod: ${error}`);\n    }\n  }\n\n  private async loadUrlMod(url: string): Promise<any> {\n    try {\n      // Fetch and evaluate remote mod (DANGEROUS - needs sandboxing)\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const code = await response.text();\n      \n      // Basic validation\n      if (!code.includes('export')) {\n        throw new Error('Invalid mod format - no exports found');\n      }\n\n      // Create a blob URL for the module\n      const blob = new Blob([code], { type: 'application/javascript' });\n      const moduleUrl = URL.createObjectURL(blob);\n\n      try {\n        const module = await import(/* @vite-ignore */ moduleUrl);\n        return module;\n      } finally {\n        URL.revokeObjectURL(moduleUrl);\n      }\n    } catch (error) {\n      throw new Error(`Failed to load remote mod: ${error}`);\n    }\n  }\n\n  private async loadManifestFromSource(modId: string, source: ModSource): Promise<ModManifest | null> {\n    try {\n      switch (source.type) {\n        case 'system':\n        case 'local':\n          // Load manifest.json from same directory\n          const manifestUrl = source.location.replace('/index.ts', '/manifest.json');\n          const response = await fetch(manifestUrl);\n          if (response.ok) {\n            return await response.json();\n          }\n          return null;\n\n        case 'npm':\n          // Load from NPM package\n          const module = await this.loadNpmMod(source.location);\n          return module?.manifest || null;\n\n        case 'url':\n          // Load manifest from registry\n          const registryUrl = source.location.replace('/latest.js', '/manifest.json');\n          const manifestResponse = await fetch(registryUrl);\n          if (manifestResponse.ok) {\n            return await manifestResponse.json();\n          }\n          return null;\n\n        default:\n          return null;\n      }\n    } catch {\n      return null;\n    }\n  }\n\n  private instantiateMod(module: any): Mod {\n    // Get the mod class (could be default export or named export)\n    const ModClass = module.default || module.Mod || Object.values(module)[0];\n    \n    if (!ModClass || typeof ModClass !== 'function') {\n      throw new Error('Invalid mod format - no mod class found');\n    }\n\n    // Instantiate the mod\n    return new ModClass();\n  }\n\n  private async validateMod(module: any): Promise<void> {\n    const mod = this.instantiateMod(module);\n\n    // Check required properties\n    if (!mod.manifest) {\n      throw new Error('Mod missing manifest');\n    }\n\n    if (!mod.manifest.id || !mod.manifest.name || !mod.manifest.version) {\n      throw new Error('Mod manifest missing required fields');\n    }\n\n    // Check required methods\n    const requiredMethods = ['initialize', 'destroy', 'isLoaded', 'isActive'];\n    for (const method of requiredMethods) {\n      if (typeof mod[method] !== 'function') {\n        throw new Error(`Mod missing required method: ${method}`);\n      }\n    }\n\n    this.logger.debug(`Mod ${mod.manifest.id} validation passed`);\n  }\n\n  private async cleanupModStorage(modId: string): Promise<void> {\n    try {\n      // Remove mod-specific localStorage entries\n      const prefix = `mod:${modId}:`;\n      const keys = Object.keys(localStorage).filter(k => k.startsWith(prefix));\n      keys.forEach(k => localStorage.removeItem(k));\n\n      this.logger.debug(`Cleaned up storage for mod ${modId}`);\n    } catch (error) {\n      this.logger.warn(`Failed to cleanup storage for mod ${modId}`, error as Error);\n    }\n  }\n}","/**\n * Mod Registry - Manages loading, lifecycle, and discovery of mods\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport type { WalletEngine } from '../engine/WalletEngine';\nimport type { \n  Mod, \n  ModManifest, \n  ModPermission,\n  Enhancement \n} from './types';\nimport { ModLoader } from './ModLoader';\nimport { Logger } from '../utils/Logger';\n\nexport interface ModRegistryEvents {\n  'mod:loaded': (mod: Mod) => void;\n  'mod:unloaded': (modId: string) => void;\n  'mod:error': (modId: string, error: Error) => void;\n  'enhancement:added': (enhancement: Enhancement) => void;\n  'enhancement:removed': (enhancement: Enhancement) => void;\n}\n\nexport class ModRegistry extends EventEmitter<ModRegistryEvents> {\n  private engine: WalletEngine;\n  private loader: ModLoader;\n  private logger: Logger;\n  \n  private loadedMods = new Map<string, Mod>();\n  private manifests = new Map<string, ModManifest>();\n  private enhancements = new Map<string, Enhancement[]>();\n  private permissions = new Map<string, ModPermission[]>();\n\n  constructor(engine: WalletEngine) {\n    super();\n    this.engine = engine;\n    this.loader = new ModLoader();\n    this.logger = new Logger('ModRegistry');\n  }\n\n  /**\n   * Initialize the registry\n   */\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing mod registry');\n    \n    try {\n      // Load system mods\n      await this.loadSystemMods();\n      \n      // Load user-installed mods\n      await this.loadUserMods();\n      \n      // Setup enhancement detection\n      await this.detectEnhancements();\n      \n      this.logger.info(`Registry initialized with ${this.loadedMods.size} mods`);\n    } catch (error) {\n      this.logger.error('Failed to initialize registry', error as Error);\n      throw error;\n    }\n  }\n\n  /**\n   * Load a mod by ID\n   */\n  async load(modId: string): Promise<Mod> {\n    // Check if already loaded\n    const existing = this.loadedMods.get(modId);\n    if (existing) {\n      return existing;\n    }\n\n    this.logger.info(`Loading mod: ${modId}`);\n\n    try {\n      // Load the mod\n      const mod = await this.loader.load(modId);\n      \n      // Validate permissions\n      await this.validatePermissions(mod);\n      \n      // Initialize the mod\n      await mod.initialize(this.engine);\n      \n      // Register the mod\n      this.loadedMods.set(modId, mod);\n      this.manifests.set(modId, mod.manifest);\n      this.permissions.set(modId, mod.manifest.permissions);\n      \n      // Check for enhancements\n      await this.checkEnhancements(mod);\n      \n      this.emit('mod:loaded', mod);\n      this.logger.info(`Mod loaded successfully: ${modId}`);\n      \n      return mod;\n    } catch (error) {\n      this.logger.error(`Failed to load mod: ${modId}`, error as Error);\n      this.emit('mod:error', modId, error as Error);\n      throw error;\n    }\n  }\n\n  /**\n   * Unload a mod\n   */\n  async unload(modId: string): Promise<void> {\n    const mod = this.loadedMods.get(modId);\n    if (!mod) {\n      return;\n    }\n\n    this.logger.info(`Unloading mod: ${modId}`);\n\n    try {\n      // Remove enhancements\n      this.removeEnhancements(modId);\n      \n      // Destroy the mod\n      await mod.destroy();\n      \n      // Remove from registry\n      this.loadedMods.delete(modId);\n      this.manifests.delete(modId);\n      this.permissions.delete(modId);\n      \n      this.emit('mod:unloaded', modId);\n      this.logger.info(`Mod unloaded: ${modId}`);\n    } catch (error) {\n      this.logger.error(`Failed to unload mod: ${modId}`, error as Error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get all loaded mods\n   */\n  getLoaded(): Mod[] {\n    return Array.from(this.loadedMods.values());\n  }\n\n  /**\n   * Get mod by ID\n   */\n  get(modId: string): Mod | null {\n    return this.loadedMods.get(modId) || null;\n  }\n\n  /**\n   * Check if mod is loaded\n   */\n  isLoaded(modId: string): boolean {\n    return this.loadedMods.has(modId);\n  }\n\n  /**\n   * Get mod manifest\n   */\n  getManifest(modId: string): ModManifest | null {\n    return this.manifests.get(modId) || null;\n  }\n\n  /**\n   * Get all manifests\n   */\n  getAllManifests(): ModManifest[] {\n    return Array.from(this.manifests.values());\n  }\n\n  /**\n   * Get mods by category\n   */\n  getByCategory(category: string): Mod[] {\n    return Array.from(this.loadedMods.values())\n      .filter(v => v.manifest.category === category);\n  }\n\n  /**\n   * Get mods by tier\n   */\n  getByTier(tier: string): Mod[] {\n    return Array.from(this.loadedMods.values())\n      .filter(v => v.manifest.tier === tier);\n  }\n\n  /**\n   * Get enhancements for a mod\n   */\n  getEnhancements(modId: string): Enhancement[] {\n    return this.enhancements.get(modId) || [];\n  }\n\n  /**\n   * Get all enhancements\n   */\n  getAllEnhancements(): Enhancement[] {\n    const all: Enhancement[] = [];\n    for (const enhancements of this.enhancements.values()) {\n      all.push(...enhancements);\n    }\n    return all;\n  }\n\n  /**\n   * Destroy the registry\n   */\n  async destroy(): Promise<void> {\n    this.logger.info('Destroying mod registry');\n    \n    // Unload all mods\n    const modIds = Array.from(this.loadedMods.keys());\n    await Promise.all(modIds.map(id => this.unload(id)));\n    \n    // Clear all data\n    this.loadedMods.clear();\n    this.manifests.clear();\n    this.enhancements.clear();\n    this.permissions.clear();\n    \n    this.removeAllListeners();\n  }\n\n  /**\n   * Load system mods (built-in)\n   */\n  private async loadSystemMods(): Promise<void> {\n    const systemMods = [\n      'basic-portfolio',\n      'send-receive', \n      'network-manager',\n      'account-manager'\n    ];\n\n    for (const modId of systemMods) {\n      try {\n        await this.load(modId);\n      } catch (error) {\n        this.logger.warn(`Failed to load system mod: ${modId}`, error as Error);\n      }\n    }\n  }\n\n  /**\n   * Load user-installed mods\n   */\n  private async loadUserMods(): Promise<void> {\n    try {\n      const userMods = await this.loader.getUserMods();\n      \n      for (const modId of userMods) {\n        try {\n          await this.load(modId);\n        } catch (error) {\n          this.logger.warn(`Failed to load user mod: ${modId}`, error as Error);\n        }\n      }\n    } catch (error) {\n      this.logger.warn('Failed to load user mods', error as Error);\n    }\n  }\n\n  /**\n   * Validate mod permissions\n   */\n  private async validatePermissions(mod: Mod): Promise<void> {\n    const manifest = mod.manifest;\n    const config = this.engine.getConfig();\n    \n    // Check if mod is allowed based on wallet restrictions\n    if (config.restrictions.includes('enterprise-only') && \n        manifest.tier !== 'enterprise') {\n      throw new Error(`Mod ${manifest.id} not allowed in enterprise-only mode`);\n    }\n    \n    // Validate individual permissions\n    for (const permission of manifest.permissions) {\n      if (!this.isPermissionGranted(permission, config)) {\n        throw new Error(`Permission ${permission} not granted for mod ${manifest.id}`);\n      }\n    }\n  }\n\n  /**\n   * Check if permission is granted\n   */\n  private isPermissionGranted(permission: ModPermission, config: any): boolean {\n    // For now, allow all permissions\n    // In production, this would check user permissions and wallet restrictions\n    return true;\n  }\n\n  /**\n   * Detect potential enhancements between mods\n   */\n  private async detectEnhancements(): Promise<void> {\n    const mods = Array.from(this.loadedMods.values());\n    \n    for (const mod of mods) {\n      await this.checkEnhancements(mod);\n    }\n  }\n\n  /**\n   * Check enhancements for a specific mod\n   */\n  private async checkEnhancements(mod: Mod): Promise<void> {\n    const manifest = mod.manifest;\n    \n    // Check if this mod enhances others\n    for (const targetId of manifest.enhances) {\n      const targetMod = this.loadedMods.get(targetId);\n      if (targetMod) {\n        const canEnhance = await mod.enhance(targetMod);\n        \n        if (canEnhance) {\n          const enhancement: Enhancement = {\n            sourceMod: manifest.id,\n            targetMod: targetId,\n            type: 'feature',\n            description: `${manifest.name} enhances ${targetMod.manifest.name}`,\n            active: true\n          };\n          \n          this.addEnhancement(enhancement);\n        }\n      }\n    }\n  }\n\n  /**\n   * Add an enhancement\n   */\n  private addEnhancement(enhancement: Enhancement): void {\n    const existing = this.enhancements.get(enhancement.targetMod) || [];\n    existing.push(enhancement);\n    this.enhancements.set(enhancement.targetMod, existing);\n    \n    this.emit('enhancement:added', enhancement);\n    this.logger.info(`Enhancement added: ${enhancement.sourceMod} → ${enhancement.targetMod}`);\n  }\n\n  /**\n   * Remove enhancements for a mod\n   */\n  private removeEnhancements(modId: string): void {\n    // Remove enhancements where this mod is the source\n    for (const [targetId, enhancements] of this.enhancements.entries()) {\n      const filtered = enhancements.filter(e => e.sourceMod !== modId);\n      \n      if (filtered.length !== enhancements.length) {\n        this.enhancements.set(targetId, filtered);\n        \n        // Emit removal events\n        const removed = enhancements.filter(e => e.sourceMod === modId);\n        removed.forEach(e => this.emit('enhancement:removed', e));\n      }\n    }\n    \n    // Remove enhancements where this mod is the target\n    this.enhancements.delete(modId);\n  }\n}","/**\n * DiscoveryProtocol - Discovers mods in the environment and enables cross-app enhancement\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport type { WalletEngine } from '../engine/WalletEngine';\nimport type { DiscoveredMod, DiscoverySource } from './types';\nimport { Logger } from '../utils/Logger';\n\nexport interface DiscoveryProtocolEvents {\n  'mod:discovered': (mods: DiscoveredMod[]) => void;\n  'mod:lost': (modId: string) => void;\n  'peer:detected': (peer: DiscoveredPeer) => void;\n}\n\nexport interface DiscoveredPeer {\n  id: string;\n  type: 'extension' | 'webapp' | 'desktop' | 'mobile';\n  version: string;\n  mods: string[];\n  capabilities: string[];\n}\n\nexport class DiscoveryProtocol extends EventEmitter<DiscoveryProtocolEvents> {\n  private engine: WalletEngine;\n  private logger: Logger;\n  private discoveredMods = new Map<string, DiscoveredMod>();\n  private discoveredPeers = new Map<string, DiscoveredPeer>();\n  private scanInterval: NodeJS.Timeout | null = null;\n  private running = false;\n\n  constructor(engine: WalletEngine) {\n    super();\n    this.engine = engine;\n    this.logger = new Logger('DiscoveryProtocol');\n  }\n\n  /**\n   * Start the discovery protocol\n   */\n  async start(): Promise<void> {\n    if (this.running) return;\n\n    this.logger.info('Starting mod discovery protocol');\n    \n    try {\n      // Initial scan\n      await this.scanEnvironment();\n      \n      // Setup periodic scanning\n      this.scanInterval = setInterval(() => {\n        this.scanEnvironment().catch(error => {\n          this.logger.warn('Discovery scan failed', error);\n        });\n      }, 30000); // Scan every 30 seconds\n      \n      // Setup peer detection\n      await this.setupPeerDetection();\n      \n      this.running = true;\n    } catch (error) {\n      this.logger.error('Failed to start discovery protocol', error as Error);\n      throw error;\n    }\n  }\n\n  /**\n   * Stop the discovery protocol\n   */\n  async stop(): Promise<void> {\n    if (!this.running) return;\n\n    this.logger.info('Stopping mod discovery protocol');\n    \n    if (this.scanInterval) {\n      clearInterval(this.scanInterval);\n      this.scanInterval = null;\n    }\n    \n    await this.teardownPeerDetection();\n    \n    this.discoveredMods.clear();\n    this.discoveredPeers.clear();\n    this.running = false;\n  }\n\n  /**\n   * Manually scan for mods\n   */\n  async scan(): Promise<DiscoveredMod[]> {\n    return this.scanEnvironment();\n  }\n\n  /**\n   * Get all discovered mods\n   */\n  getDiscoveredMods(): DiscoveredMod[] {\n    return Array.from(this.discoveredMods.values());\n  }\n\n  /**\n   * Get all discovered peers\n   */\n  getDiscoveredPeers(): DiscoveredPeer[] {\n    return Array.from(this.discoveredPeers.values());\n  }\n\n  /**\n   * Check if a specific mod is available in the environment\n   */\n  isModAvailable(modId: string): boolean {\n    return this.discoveredMods.has(modId);\n  }\n\n  /**\n   * Private methods\n   */\n  private async scanEnvironment(): Promise<DiscoveredMod[]> {\n    const discovered: DiscoveredMod[] = [];\n\n    try {\n      // Scan different sources\n      const sources: DiscoverySource[] = ['registry', 'local', 'environment', 'peer'];\n      \n      for (const source of sources) {\n        try {\n          const mods = await this.scanSource(source);\n          discovered.push(...mods);\n        } catch (error) {\n          this.logger.debug(`Failed to scan ${source}`, error as Error);\n        }\n      }\n\n      // Update discovered mods map\n      const newMods: DiscoveredMod[] = [];\n      for (const mod of discovered) {\n        if (!this.discoveredMods.has(mod.manifest.id)) {\n          newMods.push(mod);\n        }\n        this.discoveredMods.set(mod.manifest.id, mod);\n      }\n\n      // Emit discovery events\n      if (newMods.length > 0) {\n        this.emit('mod:discovered', newMods);\n        this.logger.info(`Discovered ${newMods.length} new mods`);\n      }\n\n      return discovered;\n    } catch (error) {\n      this.logger.error('Environment scan failed', error as Error);\n      return [];\n    }\n  }\n\n  private async scanSource(source: DiscoverySource): Promise<DiscoveredMod[]> {\n    switch (source) {\n      case 'registry':\n        return this.scanRegistry();\n      \n      case 'local':\n        return this.scanLocal();\n      \n      case 'environment':\n        return this.scanEnvironmentMods();\n      \n      case 'peer':\n        return this.scanPeerMods();\n      \n      default:\n        return [];\n    }\n  }\n\n  private async scanRegistry(): Promise<DiscoveredMod[]> {\n    try {\n      // Scan official YAKKL mod registry\n      const response = await fetch('https://registry.yakkl.com/api/mods/featured');\n      if (!response.ok) {\n        throw new Error(`Registry request failed: ${response.status}`);\n      }\n\n      const data = await response.json();\n      return data.mods.map((manifest: any) => ({\n        source: 'registry' as DiscoverySource,\n        manifest,\n        verified: true,\n        available: true,\n        installUrl: `https://registry.yakkl.com/mods/${manifest.id}/install`\n      }));\n    } catch (error) {\n      // Registry might not be available yet\n      this.logger.debug('Registry scan failed', error as Error);\n      return [];\n    }\n  }\n\n  private async scanLocal(): Promise<DiscoveredMod[]> {\n    try {\n      // Scan for local development mods\n      const localMods: DiscoveredMod[] = [];\n\n      // Check if we're in development mode\n      if (typeof import.meta !== 'undefined' && import.meta.env?.DEV) {\n        // Simulate finding local mods in development\n        const devMods = [\n          'basic-portfolio',\n          'advanced-analytics',\n          'secure-recovery'\n        ];\n\n        for (const modId of devMods) {\n          try {\n            // Try to load manifest\n            const manifestUrl = `/src/routes/preview2/lib/mods/${modId}/manifest.json`;\n            const response = await fetch(manifestUrl);\n            if (response.ok) {\n              const manifest = await response.json();\n              localMods.push({\n                source: 'local',\n                manifest,\n                verified: true,\n                available: true\n              });\n            }\n          } catch {\n            // Mod doesn't exist locally\n          }\n        }\n      }\n\n      return localMods;\n    } catch (error) {\n      this.logger.debug('Local scan failed', error as Error);\n      return [];\n    }\n  }\n\n  private async scanEnvironmentMods(): Promise<DiscoveredMod[]> {\n    try {\n      // Scan the current web page for embedded mods\n      const mods: DiscoveredMod[] = [];\n\n      // Look for YAKKL mod declarations in the page\n      const modElements = document.querySelectorAll('[data-yakkl-mod]');\n      \n      for (let i = 0; i < modElements.length; i++) {\n        const element = modElements[i];\n        try {\n          const modData = element.getAttribute('data-yakkl-mod');\n          if (modData) {\n            const manifest = JSON.parse(modData);\n            mods.push({\n              source: 'environment',\n              manifest,\n              verified: false,\n              available: true\n            });\n          }\n        } catch {\n          // Invalid mod data\n        }\n      }\n\n      // Check for postMessage announcements\n      this.setupPostMessageListener();\n\n      return mods;\n    } catch (error) {\n      this.logger.debug('Environment scan failed', error as Error);\n      return [];\n    }\n  }\n\n  private async scanPeerMods(): Promise<DiscoveredMod[]> {\n    const mods: DiscoveredMod[] = [];\n\n    // Collect mods from discovered peers\n    for (const peer of this.discoveredPeers.values()) {\n      for (const modId of peer.mods) {\n        mods.push({\n          source: 'peer',\n          manifest: { id: modId, name: modId, version: '1.0.0' } as any,\n          verified: false,\n          available: true\n        });\n      }\n    }\n\n    return mods;\n  }\n\n  private async setupPeerDetection(): Promise<void> {\n    // Setup cross-origin communication for peer detection\n    if (typeof window !== 'undefined') {\n      // Broadcast our presence\n      this.broadcastPresence().catch(error => {\n        this.logger.debug('Failed to broadcast initial presence', error);\n      });\n      \n      // Listen for other YAKKL instances\n      window.addEventListener('message', this.handlePeerMessage.bind(this));\n      \n      // Setup periodic presence broadcasting\n      setInterval(() => {\n        this.broadcastPresence().catch(error => {\n          this.logger.debug('Failed to broadcast periodic presence', error);\n        });\n      }, 60000); // Every minute\n    }\n  }\n\n  private async teardownPeerDetection(): Promise<void> {\n    if (typeof window !== 'undefined') {\n      window.removeEventListener('message', this.handlePeerMessage.bind(this));\n    }\n  }\n\n  private async broadcastPresence(): Promise<void> {\n    try {\n      const presence = {\n        type: 'yakkl:presence',\n        id: this.generatePeerId(),\n        version: '2.0.0',\n        mods: (await this.engine.getLoadedMods()).map((m: any) => m.manifest.id),\n        capabilities: ['mod-discovery', 'cross-enhancement'],\n        timestamp: Date.now()\n      };\n\n      // Broadcast to parent window (for iframes)\n      if (window.parent !== window) {\n        window.parent.postMessage(presence, '*');\n      }\n\n      // Broadcast to child frames\n      for (let i = 0; i < window.frames.length; i++) {\n        try {\n          window.frames[i].postMessage(presence, '*');\n        } catch {\n          // Cross-origin frame, ignore\n        }\n      }\n    } catch (error) {\n      this.logger.debug('Failed to broadcast presence', error as Error);\n    }\n  }\n\n  private handlePeerMessage(event: MessageEvent): void {\n    try {\n      const data = event.data;\n      \n      if (data.type === 'yakkl:presence') {\n        const peer: DiscoveredPeer = {\n          id: data.id,\n          type: 'webapp', // Assume webapp for now\n          version: data.version,\n          mods: data.mods || [],\n          capabilities: data.capabilities || []\n        };\n\n        // Update peer\n        this.discoveredPeers.set(peer.id, peer);\n        this.emit('peer:detected', peer);\n        \n        this.logger.debug(`Discovered peer: ${peer.id} with ${peer.mods.length} mods`);\n      }\n    } catch (error) {\n      this.logger.debug('Failed to handle peer message', error as Error);\n    }\n  }\n\n  private setupPostMessageListener(): void {\n    // Listen for mod announcements from the page\n    window.addEventListener('message', (event) => {\n      try {\n        const data = event.data;\n        \n        if (data.type === 'yakkl:mod-announcement') {\n          const discoveredMod: DiscoveredMod = {\n            source: 'environment',\n            manifest: data.manifest,\n            verified: data.verified || false,\n            available: true\n          };\n\n          this.discoveredMods.set(data.manifest.id, discoveredMod);\n          this.emit('mod:discovered', [discoveredMod]);\n        }\n      } catch {\n        // Invalid message format\n      }\n    });\n  }\n\n  private generatePeerId(): string {\n    // Generate a session-unique peer ID\n    if (!localStorage.getItem('yakkl:peerId')) {\n      const id = `peer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      localStorage.setItem('yakkl:peerId', id);\n    }\n    return localStorage.getItem('yakkl:peerId')!;\n  }\n}"],"names":["Logger","context","level","message","args","error","ModLoader","modId","module","sources","source","stored","userMods","updated","id","manifest","loader","location","packageName","url","response","code","blob","moduleUrl","manifestUrl","registryUrl","manifestResponse","ModClass","mod","requiredMethods","method","prefix","k","ModRegistry","EventEmitter","engine","existing","category","v","tier","all","enhancements","modIds","systemMods","config","permission","mods","targetId","targetMod","enhancement","filtered","e","DiscoveryProtocol","discovered","newMods","localMods","_documentCurrentScript","modElements","i","element","modData","peer","presence","m","event","data","discoveredMod"],"mappings":"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"}