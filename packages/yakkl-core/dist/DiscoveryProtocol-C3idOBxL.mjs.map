{"version":3,"file":"DiscoveryProtocol-C3idOBxL.mjs","sources":["../src/utils/Logger.ts","../src/mods/ModLoader.ts","../src/mods/ModRegistry.ts","../src/mods/DiscoveryProtocol.ts"],"sourcesContent":["/**\n * Logger utility for YAKKL Core\n */\n\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3\n}\n\nexport class Logger {\n  private context: string;\n  private level: LogLevel;\n\n  constructor(context: string, level: LogLevel = LogLevel.INFO) {\n    this.context = context;\n    this.level = level;\n  }\n\n  debug(message: string, ...args: any[]): void {\n    if (this.level <= LogLevel.DEBUG) {\n      console.debug(`[${this.context}] ${message}`, ...args);\n    }\n  }\n\n  info(message: string, ...args: any[]): void {\n    if (this.level <= LogLevel.INFO) {\n      console.info(`[${this.context}] ${message}`, ...args);\n    }\n  }\n\n  warn(message: string, error?: Error | any): void {\n    if (this.level <= LogLevel.WARN) {\n      if (error) {\n        console.warn(`[${this.context}] ${message}`, error);\n      } else {\n        console.warn(`[${this.context}] ${message}`);\n      }\n    }\n  }\n\n  error(message: string, error?: Error | any): void {\n    if (this.level <= LogLevel.ERROR) {\n      if (error) {\n        console.error(`[${this.context}] ${message}`, error);\n      } else {\n        console.error(`[${this.context}] ${message}`);\n      }\n    }\n  }\n\n  setLevel(level: LogLevel): void {\n    this.level = level;\n  }\n}","/**\n * ModLoader - Dynamically loads and instantiates mods\n */\n\nimport type { Mod, ModManifest } from './types';\nimport { Logger } from '../utils/Logger';\n\nexport interface ModSource {\n  type: 'local' | 'npm' | 'url' | 'system';\n  location: string;\n  verified: boolean;\n}\n\nexport class ModLoader {\n  private logger: Logger;\n  private loadedModules = new Map<string, any>();\n  private systemMods = new Map<string, () => Promise<any>>();\n\n  constructor() {\n    this.logger = new Logger('ModLoader');\n    this.registerSystemMods();\n  }\n\n  /**\n   * Load a mod by ID\n   */\n  async load(modId: string): Promise<Mod> {\n    this.logger.info(`Loading mod: ${modId}`);\n\n    try {\n      // Check if already loaded\n      if (this.loadedModules.has(modId)) {\n        const module = this.loadedModules.get(modId);\n        return this.instantiateMod(module);\n      }\n\n      // Try to load from different sources\n      const sources = await this.resolveModSources(modId);\n      \n      for (const source of sources) {\n        try {\n          const module = await this.loadFromSource(modId, source);\n          if (module) {\n            this.loadedModules.set(modId, module);\n            return this.instantiateMod(module);\n          }\n        } catch (error) {\n          this.logger.warn(`Failed to load from ${source.type}: ${source.location}`, error as Error);\n          continue;\n        }\n      }\n\n      throw new Error(`Mod ${modId} not found in any source`);\n    } catch (error) {\n      this.logger.error(`Failed to load mod ${modId}`, error as Error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get list of user-installed mods\n   */\n  async getUserMods(): Promise<string[]> {\n    try {\n      // Get from local storage or user directory\n      const stored = localStorage.getItem('yakkl:userMods');\n      if (stored) {\n        return JSON.parse(stored);\n      }\n      return [];\n    } catch (error) {\n      this.logger.warn('Failed to get user mods', error as Error);\n      return [];\n    }\n  }\n\n  /**\n   * Install a mod\n   */\n  async install(modId: string, source: ModSource): Promise<void> {\n    this.logger.info(`Installing mod: ${modId} from ${source.type}`);\n\n    try {\n      // Load and validate the mod\n      const module = await this.loadFromSource(modId, source);\n      if (!module) {\n        throw new Error('Failed to load mod module');\n      }\n\n      // Validate manifest\n      await this.validateMod(module);\n\n      // Add to user mods list\n      const userMods = await this.getUserMods();\n      if (!userMods.includes(modId)) {\n        userMods.push(modId);\n        localStorage.setItem('yakkl:userMods', JSON.stringify(userMods));\n      }\n\n      // Cache the module\n      this.loadedModules.set(modId, module);\n\n      this.logger.info(`Mod ${modId} installed successfully`);\n    } catch (error) {\n      this.logger.error(`Failed to install mod ${modId}`, error as Error);\n      throw error;\n    }\n  }\n\n  /**\n   * Uninstall a mod\n   */\n  async uninstall(modId: string): Promise<void> {\n    this.logger.info(`Uninstalling mod: ${modId}`);\n\n    try {\n      // Remove from user mods list\n      const userMods = await this.getUserMods();\n      const updated = userMods.filter(id => id !== modId);\n      localStorage.setItem('yakkl:userMods', JSON.stringify(updated));\n\n      // Remove from cache\n      this.loadedModules.delete(modId);\n\n      // Remove mod-specific storage\n      await this.cleanupModStorage(modId);\n\n      this.logger.info(`Mod ${modId} uninstalled successfully`);\n    } catch (error) {\n      this.logger.error(`Failed to uninstall mod ${modId}`, error as Error);\n      throw error;\n    }\n  }\n\n  /**\n   * Check if a mod is available\n   */\n  async isAvailable(modId: string): Promise<boolean> {\n    try {\n      const sources = await this.resolveModSources(modId);\n      return sources.length > 0;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get mod manifest without loading the mod\n   */\n  async getManifest(modId: string): Promise<ModManifest | null> {\n    try {\n      const sources = await this.resolveModSources(modId);\n      \n      for (const source of sources) {\n        try {\n          const manifest = await this.loadManifestFromSource(modId, source);\n          if (manifest) {\n            return manifest;\n          }\n        } catch {\n          continue;\n        }\n      }\n      \n      return null;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Private methods\n   */\n  private registerSystemMods(): void {\n    // Register built-in system mods\n    this.systemMods.set('basic-portfolio', async () => {\n      // System mod would be dynamically loaded or imported\n      // For now, return a mock implementation\n      throw new Error('System mod basic-portfolio not implemented');\n    });\n\n    // Add more system mods as they're created\n    this.systemMods.set('account-manager', async () => {\n      // Would import AccountManagerMod when created\n      throw new Error('System mod account-manager not implemented');\n    });\n\n    this.systemMods.set('network-manager', async () => {\n      // Would import NetworkManagerMod when created\n      throw new Error('System mod network-manager not implemented');\n    });\n  }\n\n  private async resolveModSources(modId: string): Promise<ModSource[]> {\n    const sources: ModSource[] = [];\n\n    // System mods (highest priority)\n    if (this.systemMods.has(modId)) {\n      sources.push({\n        type: 'system',\n        location: modId,\n        verified: true\n      });\n    }\n\n    // Local development mods\n    sources.push({\n      type: 'local',\n      location: `/src/routes/preview2/lib/mods/${modId}/index.ts`,\n      verified: true\n    });\n\n    // User-installed NPM mods\n    sources.push({\n      type: 'npm',\n      location: `@yakkl/mod-${modId}`,\n      verified: false\n    });\n\n    // Official YAKKL mods registry\n    sources.push({\n      type: 'url',\n      location: `https://registry.yakkl.com/mods/${modId}/latest.js`,\n      verified: true\n    });\n\n    return sources;\n  }\n\n  private async loadFromSource(modId: string, source: ModSource): Promise<any> {\n    switch (source.type) {\n      case 'system':\n        return this.loadSystemMod(modId);\n      \n      case 'local':\n        return this.loadLocalMod(source.location);\n      \n      case 'npm':\n        return this.loadNpmMod(source.location);\n      \n      case 'url':\n        return this.loadUrlMod(source.location);\n      \n      default:\n        throw new Error(`Unknown source type: ${source.type}`);\n    }\n  }\n\n  private async loadSystemMod(modId: string): Promise<any> {\n    const loader = this.systemMods.get(modId);\n    if (!loader) {\n      throw new Error(`System mod ${modId} not found`);\n    }\n\n    try {\n      return await loader();\n    } catch (error) {\n      // System mod might not be implemented yet\n      this.logger.warn(`System mod ${modId} not implemented`, error as Error);\n      return null;\n    }\n  }\n\n  private async loadLocalMod(location: string): Promise<any> {\n    try {\n      // Dynamic import for local development\n      return await import(/* @vite-ignore */ location);\n    } catch (error) {\n      throw new Error(`Failed to load local mod: ${error}`);\n    }\n  }\n\n  private async loadNpmMod(packageName: string): Promise<any> {\n    try {\n      // Dynamic import for NPM packages\n      return await import(/* @vite-ignore */ packageName);\n    } catch (error) {\n      throw new Error(`Failed to load NPM mod: ${error}`);\n    }\n  }\n\n  private async loadUrlMod(url: string): Promise<any> {\n    try {\n      // Fetch and evaluate remote mod (DANGEROUS - needs sandboxing)\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const code = await response.text();\n      \n      // Basic validation\n      if (!code.includes('export')) {\n        throw new Error('Invalid mod format - no exports found');\n      }\n\n      // Create a blob URL for the module\n      const blob = new Blob([code], { type: 'application/javascript' });\n      const moduleUrl = URL.createObjectURL(blob);\n\n      try {\n        const module = await import(/* @vite-ignore */ moduleUrl);\n        return module;\n      } finally {\n        URL.revokeObjectURL(moduleUrl);\n      }\n    } catch (error) {\n      throw new Error(`Failed to load remote mod: ${error}`);\n    }\n  }\n\n  private async loadManifestFromSource(modId: string, source: ModSource): Promise<ModManifest | null> {\n    try {\n      switch (source.type) {\n        case 'system':\n        case 'local':\n          // Load manifest.json from same directory\n          const manifestUrl = source.location.replace('/index.ts', '/manifest.json');\n          const response = await fetch(manifestUrl);\n          if (response.ok) {\n            return await response.json();\n          }\n          return null;\n\n        case 'npm':\n          // Load from NPM package\n          const module = await this.loadNpmMod(source.location);\n          return module?.manifest || null;\n\n        case 'url':\n          // Load manifest from registry\n          const registryUrl = source.location.replace('/latest.js', '/manifest.json');\n          const manifestResponse = await fetch(registryUrl);\n          if (manifestResponse.ok) {\n            return await manifestResponse.json();\n          }\n          return null;\n\n        default:\n          return null;\n      }\n    } catch {\n      return null;\n    }\n  }\n\n  private instantiateMod(module: any): Mod {\n    // Get the mod class (could be default export or named export)\n    const ModClass = module.default || module.Mod || Object.values(module)[0];\n    \n    if (!ModClass || typeof ModClass !== 'function') {\n      throw new Error('Invalid mod format - no mod class found');\n    }\n\n    // Instantiate the mod\n    return new ModClass();\n  }\n\n  private async validateMod(module: any): Promise<void> {\n    const mod = this.instantiateMod(module);\n\n    // Check required properties\n    if (!mod.manifest) {\n      throw new Error('Mod missing manifest');\n    }\n\n    if (!mod.manifest.id || !mod.manifest.name || !mod.manifest.version) {\n      throw new Error('Mod manifest missing required fields');\n    }\n\n    // Check required methods\n    const requiredMethods = ['initialize', 'destroy', 'isLoaded', 'isActive'];\n    for (const method of requiredMethods) {\n      if (typeof mod[method] !== 'function') {\n        throw new Error(`Mod missing required method: ${method}`);\n      }\n    }\n\n    this.logger.debug(`Mod ${mod.manifest.id} validation passed`);\n  }\n\n  private async cleanupModStorage(modId: string): Promise<void> {\n    try {\n      // Remove mod-specific localStorage entries\n      const prefix = `mod:${modId}:`;\n      const keys = Object.keys(localStorage).filter(k => k.startsWith(prefix));\n      keys.forEach(k => localStorage.removeItem(k));\n\n      this.logger.debug(`Cleaned up storage for mod ${modId}`);\n    } catch (error) {\n      this.logger.warn(`Failed to cleanup storage for mod ${modId}`, error as Error);\n    }\n  }\n}","/**\n * Mod Registry - Manages loading, lifecycle, and discovery of mods\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport type { WalletEngine } from '../engine/WalletEngine';\nimport type { \n  Mod, \n  ModManifest, \n  ModPermission,\n  Enhancement \n} from './types';\nimport { ModLoader } from './ModLoader';\nimport { Logger } from '../utils/Logger';\n\nexport interface ModRegistryEvents {\n  'mod:loaded': (mod: Mod) => void;\n  'mod:unloaded': (modId: string) => void;\n  'mod:error': (modId: string, error: Error) => void;\n  'enhancement:added': (enhancement: Enhancement) => void;\n  'enhancement:removed': (enhancement: Enhancement) => void;\n}\n\nexport class ModRegistry extends EventEmitter<ModRegistryEvents> {\n  private engine: WalletEngine;\n  private loader: ModLoader;\n  private logger: Logger;\n  \n  private loadedMods = new Map<string, Mod>();\n  private manifests = new Map<string, ModManifest>();\n  private enhancements = new Map<string, Enhancement[]>();\n  private permissions = new Map<string, ModPermission[]>();\n\n  constructor(engine: WalletEngine) {\n    super();\n    this.engine = engine;\n    this.loader = new ModLoader();\n    this.logger = new Logger('ModRegistry');\n  }\n\n  /**\n   * Initialize the registry\n   */\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing mod registry');\n    \n    try {\n      // Load system mods\n      await this.loadSystemMods();\n      \n      // Load user-installed mods\n      await this.loadUserMods();\n      \n      // Setup enhancement detection\n      await this.detectEnhancements();\n      \n      this.logger.info(`Registry initialized with ${this.loadedMods.size} mods`);\n    } catch (error) {\n      this.logger.error('Failed to initialize registry', error as Error);\n      throw error;\n    }\n  }\n\n  /**\n   * Load a mod by ID\n   */\n  async load(modId: string): Promise<Mod> {\n    // Check if already loaded\n    const existing = this.loadedMods.get(modId);\n    if (existing) {\n      return existing;\n    }\n\n    this.logger.info(`Loading mod: ${modId}`);\n\n    try {\n      // Load the mod\n      const mod = await this.loader.load(modId);\n      \n      // Validate permissions\n      await this.validatePermissions(mod);\n      \n      // Initialize the mod\n      await mod.initialize(this.engine);\n      \n      // Register the mod\n      this.loadedMods.set(modId, mod);\n      this.manifests.set(modId, mod.manifest);\n      this.permissions.set(modId, mod.manifest.permissions);\n      \n      // Check for enhancements\n      await this.checkEnhancements(mod);\n      \n      this.emit('mod:loaded', mod);\n      this.logger.info(`Mod loaded successfully: ${modId}`);\n      \n      return mod;\n    } catch (error) {\n      this.logger.error(`Failed to load mod: ${modId}`, error as Error);\n      this.emit('mod:error', modId, error as Error);\n      throw error;\n    }\n  }\n\n  /**\n   * Unload a mod\n   */\n  async unload(modId: string): Promise<void> {\n    const mod = this.loadedMods.get(modId);\n    if (!mod) {\n      return;\n    }\n\n    this.logger.info(`Unloading mod: ${modId}`);\n\n    try {\n      // Remove enhancements\n      this.removeEnhancements(modId);\n      \n      // Destroy the mod\n      await mod.destroy();\n      \n      // Remove from registry\n      this.loadedMods.delete(modId);\n      this.manifests.delete(modId);\n      this.permissions.delete(modId);\n      \n      this.emit('mod:unloaded', modId);\n      this.logger.info(`Mod unloaded: ${modId}`);\n    } catch (error) {\n      this.logger.error(`Failed to unload mod: ${modId}`, error as Error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get all loaded mods\n   */\n  getLoaded(): Mod[] {\n    return Array.from(this.loadedMods.values());\n  }\n\n  /**\n   * Get mod by ID\n   */\n  get(modId: string): Mod | null {\n    return this.loadedMods.get(modId) || null;\n  }\n\n  /**\n   * Check if mod is loaded\n   */\n  isLoaded(modId: string): boolean {\n    return this.loadedMods.has(modId);\n  }\n\n  /**\n   * Get mod manifest\n   */\n  getManifest(modId: string): ModManifest | null {\n    return this.manifests.get(modId) || null;\n  }\n\n  /**\n   * Get all manifests\n   */\n  getAllManifests(): ModManifest[] {\n    return Array.from(this.manifests.values());\n  }\n\n  /**\n   * Get mods by category\n   */\n  getByCategory(category: string): Mod[] {\n    return Array.from(this.loadedMods.values())\n      .filter(v => v.manifest.category === category);\n  }\n\n  /**\n   * Get mods by tier\n   */\n  getByTier(tier: string): Mod[] {\n    return Array.from(this.loadedMods.values())\n      .filter(v => v.manifest.tier === tier);\n  }\n\n  /**\n   * Get enhancements for a mod\n   */\n  getEnhancements(modId: string): Enhancement[] {\n    return this.enhancements.get(modId) || [];\n  }\n\n  /**\n   * Get all enhancements\n   */\n  getAllEnhancements(): Enhancement[] {\n    const all: Enhancement[] = [];\n    for (const enhancements of this.enhancements.values()) {\n      all.push(...enhancements);\n    }\n    return all;\n  }\n\n  /**\n   * Destroy the registry\n   */\n  async destroy(): Promise<void> {\n    this.logger.info('Destroying mod registry');\n    \n    // Unload all mods\n    const modIds = Array.from(this.loadedMods.keys());\n    await Promise.all(modIds.map(id => this.unload(id)));\n    \n    // Clear all data\n    this.loadedMods.clear();\n    this.manifests.clear();\n    this.enhancements.clear();\n    this.permissions.clear();\n    \n    this.removeAllListeners();\n  }\n\n  /**\n   * Load system mods (built-in)\n   */\n  private async loadSystemMods(): Promise<void> {\n    const systemMods = [\n      'basic-portfolio',\n      'send-receive', \n      'network-manager',\n      'account-manager'\n    ];\n\n    for (const modId of systemMods) {\n      try {\n        await this.load(modId);\n      } catch (error) {\n        this.logger.warn(`Failed to load system mod: ${modId}`, error as Error);\n      }\n    }\n  }\n\n  /**\n   * Load user-installed mods\n   */\n  private async loadUserMods(): Promise<void> {\n    try {\n      const userMods = await this.loader.getUserMods();\n      \n      for (const modId of userMods) {\n        try {\n          await this.load(modId);\n        } catch (error) {\n          this.logger.warn(`Failed to load user mod: ${modId}`, error as Error);\n        }\n      }\n    } catch (error) {\n      this.logger.warn('Failed to load user mods', error as Error);\n    }\n  }\n\n  /**\n   * Validate mod permissions\n   */\n  private async validatePermissions(mod: Mod): Promise<void> {\n    const manifest = mod.manifest;\n    const config = this.engine.getConfig();\n    \n    // Check if mod is allowed based on wallet restrictions\n    if (config.restrictions.includes('enterprise-only') && \n        manifest.tier !== 'enterprise') {\n      throw new Error(`Mod ${manifest.id} not allowed in enterprise-only mode`);\n    }\n    \n    // Validate individual permissions\n    for (const permission of manifest.permissions) {\n      if (!this.isPermissionGranted(permission, config)) {\n        throw new Error(`Permission ${permission} not granted for mod ${manifest.id}`);\n      }\n    }\n  }\n\n  /**\n   * Check if permission is granted\n   */\n  private isPermissionGranted(permission: ModPermission, config: any): boolean {\n    // For now, allow all permissions\n    // In production, this would check user permissions and wallet restrictions\n    return true;\n  }\n\n  /**\n   * Detect potential enhancements between mods\n   */\n  private async detectEnhancements(): Promise<void> {\n    const mods = Array.from(this.loadedMods.values());\n    \n    for (const mod of mods) {\n      await this.checkEnhancements(mod);\n    }\n  }\n\n  /**\n   * Check enhancements for a specific mod\n   */\n  private async checkEnhancements(mod: Mod): Promise<void> {\n    const manifest = mod.manifest;\n    \n    // Check if this mod enhances others\n    for (const targetId of manifest.enhances) {\n      const targetMod = this.loadedMods.get(targetId);\n      if (targetMod) {\n        const canEnhance = await mod.enhance(targetMod);\n        \n        if (canEnhance) {\n          const enhancement: Enhancement = {\n            sourceMod: manifest.id,\n            targetMod: targetId,\n            type: 'feature',\n            description: `${manifest.name} enhances ${targetMod.manifest.name}`,\n            active: true\n          };\n          \n          this.addEnhancement(enhancement);\n        }\n      }\n    }\n  }\n\n  /**\n   * Add an enhancement\n   */\n  private addEnhancement(enhancement: Enhancement): void {\n    const existing = this.enhancements.get(enhancement.targetMod) || [];\n    existing.push(enhancement);\n    this.enhancements.set(enhancement.targetMod, existing);\n    \n    this.emit('enhancement:added', enhancement);\n    this.logger.info(`Enhancement added: ${enhancement.sourceMod} â†’ ${enhancement.targetMod}`);\n  }\n\n  /**\n   * Remove enhancements for a mod\n   */\n  private removeEnhancements(modId: string): void {\n    // Remove enhancements where this mod is the source\n    for (const [targetId, enhancements] of this.enhancements.entries()) {\n      const filtered = enhancements.filter(e => e.sourceMod !== modId);\n      \n      if (filtered.length !== enhancements.length) {\n        this.enhancements.set(targetId, filtered);\n        \n        // Emit removal events\n        const removed = enhancements.filter(e => e.sourceMod === modId);\n        removed.forEach(e => this.emit('enhancement:removed', e));\n      }\n    }\n    \n    // Remove enhancements where this mod is the target\n    this.enhancements.delete(modId);\n  }\n}","/**\n * DiscoveryProtocol - Discovers mods in the environment and enables cross-app enhancement\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport type { WalletEngine } from '../engine/WalletEngine';\nimport type { DiscoveredMod, DiscoverySource } from './types';\nimport { Logger } from '../utils/Logger';\n\nexport interface DiscoveryProtocolEvents {\n  'mod:discovered': (mods: DiscoveredMod[]) => void;\n  'mod:lost': (modId: string) => void;\n  'peer:detected': (peer: DiscoveredPeer) => void;\n}\n\nexport interface DiscoveredPeer {\n  id: string;\n  type: 'extension' | 'webapp' | 'desktop' | 'mobile';\n  version: string;\n  mods: string[];\n  capabilities: string[];\n}\n\nexport class DiscoveryProtocol extends EventEmitter<DiscoveryProtocolEvents> {\n  private engine: WalletEngine;\n  private logger: Logger;\n  private discoveredMods = new Map<string, DiscoveredMod>();\n  private discoveredPeers = new Map<string, DiscoveredPeer>();\n  private scanInterval: NodeJS.Timeout | null = null;\n  private running = false;\n\n  constructor(engine: WalletEngine) {\n    super();\n    this.engine = engine;\n    this.logger = new Logger('DiscoveryProtocol');\n  }\n\n  /**\n   * Start the discovery protocol\n   */\n  async start(): Promise<void> {\n    if (this.running) return;\n\n    this.logger.info('Starting mod discovery protocol');\n    \n    try {\n      // Initial scan\n      await this.scanEnvironment();\n      \n      // Setup periodic scanning\n      this.scanInterval = setInterval(() => {\n        this.scanEnvironment().catch(error => {\n          this.logger.warn('Discovery scan failed', error);\n        });\n      }, 30000); // Scan every 30 seconds\n      \n      // Setup peer detection\n      await this.setupPeerDetection();\n      \n      this.running = true;\n    } catch (error) {\n      this.logger.error('Failed to start discovery protocol', error as Error);\n      throw error;\n    }\n  }\n\n  /**\n   * Stop the discovery protocol\n   */\n  async stop(): Promise<void> {\n    if (!this.running) return;\n\n    this.logger.info('Stopping mod discovery protocol');\n    \n    if (this.scanInterval) {\n      clearInterval(this.scanInterval);\n      this.scanInterval = null;\n    }\n    \n    await this.teardownPeerDetection();\n    \n    this.discoveredMods.clear();\n    this.discoveredPeers.clear();\n    this.running = false;\n  }\n\n  /**\n   * Manually scan for mods\n   */\n  async scan(): Promise<DiscoveredMod[]> {\n    return this.scanEnvironment();\n  }\n\n  /**\n   * Get all discovered mods\n   */\n  getDiscoveredMods(): DiscoveredMod[] {\n    return Array.from(this.discoveredMods.values());\n  }\n\n  /**\n   * Get all discovered peers\n   */\n  getDiscoveredPeers(): DiscoveredPeer[] {\n    return Array.from(this.discoveredPeers.values());\n  }\n\n  /**\n   * Check if a specific mod is available in the environment\n   */\n  isModAvailable(modId: string): boolean {\n    return this.discoveredMods.has(modId);\n  }\n\n  /**\n   * Private methods\n   */\n  private async scanEnvironment(): Promise<DiscoveredMod[]> {\n    const discovered: DiscoveredMod[] = [];\n\n    try {\n      // Scan different sources\n      const sources: DiscoverySource[] = ['registry', 'local', 'environment', 'peer'];\n      \n      for (const source of sources) {\n        try {\n          const mods = await this.scanSource(source);\n          discovered.push(...mods);\n        } catch (error) {\n          this.logger.debug(`Failed to scan ${source}`, error as Error);\n        }\n      }\n\n      // Update discovered mods map\n      const newMods: DiscoveredMod[] = [];\n      for (const mod of discovered) {\n        if (!this.discoveredMods.has(mod.manifest.id)) {\n          newMods.push(mod);\n        }\n        this.discoveredMods.set(mod.manifest.id, mod);\n      }\n\n      // Emit discovery events\n      if (newMods.length > 0) {\n        this.emit('mod:discovered', newMods);\n        this.logger.info(`Discovered ${newMods.length} new mods`);\n      }\n\n      return discovered;\n    } catch (error) {\n      this.logger.error('Environment scan failed', error as Error);\n      return [];\n    }\n  }\n\n  private async scanSource(source: DiscoverySource): Promise<DiscoveredMod[]> {\n    switch (source) {\n      case 'registry':\n        return this.scanRegistry();\n      \n      case 'local':\n        return this.scanLocal();\n      \n      case 'environment':\n        return this.scanEnvironmentMods();\n      \n      case 'peer':\n        return this.scanPeerMods();\n      \n      default:\n        return [];\n    }\n  }\n\n  private async scanRegistry(): Promise<DiscoveredMod[]> {\n    try {\n      // Scan official YAKKL mod registry\n      const response = await fetch('https://registry.yakkl.com/api/mods/featured');\n      if (!response.ok) {\n        throw new Error(`Registry request failed: ${response.status}`);\n      }\n\n      const data = await response.json();\n      return data.mods.map((manifest: any) => ({\n        source: 'registry' as DiscoverySource,\n        manifest,\n        verified: true,\n        available: true,\n        installUrl: `https://registry.yakkl.com/mods/${manifest.id}/install`\n      }));\n    } catch (error) {\n      // Registry might not be available yet\n      this.logger.debug('Registry scan failed', error as Error);\n      return [];\n    }\n  }\n\n  private async scanLocal(): Promise<DiscoveredMod[]> {\n    try {\n      // Scan for local development mods\n      const localMods: DiscoveredMod[] = [];\n\n      // Check if we're in development mode\n      if (typeof import.meta !== 'undefined' && import.meta.env?.DEV) {\n        // Simulate finding local mods in development\n        const devMods = [\n          'basic-portfolio',\n          'advanced-analytics',\n          'secure-recovery'\n        ];\n\n        for (const modId of devMods) {\n          try {\n            // Try to load manifest\n            const manifestUrl = `/src/routes/preview2/lib/mods/${modId}/manifest.json`;\n            const response = await fetch(manifestUrl);\n            if (response.ok) {\n              const manifest = await response.json();\n              localMods.push({\n                source: 'local',\n                manifest,\n                verified: true,\n                available: true\n              });\n            }\n          } catch {\n            // Mod doesn't exist locally\n          }\n        }\n      }\n\n      return localMods;\n    } catch (error) {\n      this.logger.debug('Local scan failed', error as Error);\n      return [];\n    }\n  }\n\n  private async scanEnvironmentMods(): Promise<DiscoveredMod[]> {\n    try {\n      // Scan the current web page for embedded mods\n      const mods: DiscoveredMod[] = [];\n\n      // Look for YAKKL mod declarations in the page\n      const modElements = document.querySelectorAll('[data-yakkl-mod]');\n      \n      for (let i = 0; i < modElements.length; i++) {\n        const element = modElements[i];\n        try {\n          const modData = element.getAttribute('data-yakkl-mod');\n          if (modData) {\n            const manifest = JSON.parse(modData);\n            mods.push({\n              source: 'environment',\n              manifest,\n              verified: false,\n              available: true\n            });\n          }\n        } catch {\n          // Invalid mod data\n        }\n      }\n\n      // Check for postMessage announcements\n      this.setupPostMessageListener();\n\n      return mods;\n    } catch (error) {\n      this.logger.debug('Environment scan failed', error as Error);\n      return [];\n    }\n  }\n\n  private async scanPeerMods(): Promise<DiscoveredMod[]> {\n    const mods: DiscoveredMod[] = [];\n\n    // Collect mods from discovered peers\n    for (const peer of this.discoveredPeers.values()) {\n      for (const modId of peer.mods) {\n        mods.push({\n          source: 'peer',\n          manifest: { id: modId, name: modId, version: '1.0.0' } as any,\n          verified: false,\n          available: true\n        });\n      }\n    }\n\n    return mods;\n  }\n\n  private async setupPeerDetection(): Promise<void> {\n    // Setup cross-origin communication for peer detection\n    if (typeof window !== 'undefined') {\n      // Broadcast our presence\n      this.broadcastPresence().catch(error => {\n        this.logger.debug('Failed to broadcast initial presence', error);\n      });\n      \n      // Listen for other YAKKL instances\n      window.addEventListener('message', this.handlePeerMessage.bind(this));\n      \n      // Setup periodic presence broadcasting\n      setInterval(() => {\n        this.broadcastPresence().catch(error => {\n          this.logger.debug('Failed to broadcast periodic presence', error);\n        });\n      }, 60000); // Every minute\n    }\n  }\n\n  private async teardownPeerDetection(): Promise<void> {\n    if (typeof window !== 'undefined') {\n      window.removeEventListener('message', this.handlePeerMessage.bind(this));\n    }\n  }\n\n  private async broadcastPresence(): Promise<void> {\n    try {\n      const presence = {\n        type: 'yakkl:presence',\n        id: this.generatePeerId(),\n        version: '2.0.0',\n        mods: (await this.engine.getLoadedMods()).map((m: any) => m.manifest.id),\n        capabilities: ['mod-discovery', 'cross-enhancement'],\n        timestamp: Date.now()\n      };\n\n      // Broadcast to parent window (for iframes)\n      if (window.parent !== window) {\n        window.parent.postMessage(presence, '*');\n      }\n\n      // Broadcast to child frames\n      for (let i = 0; i < window.frames.length; i++) {\n        try {\n          window.frames[i].postMessage(presence, '*');\n        } catch {\n          // Cross-origin frame, ignore\n        }\n      }\n    } catch (error) {\n      this.logger.debug('Failed to broadcast presence', error as Error);\n    }\n  }\n\n  private handlePeerMessage(event: MessageEvent): void {\n    try {\n      const data = event.data;\n      \n      if (data.type === 'yakkl:presence') {\n        const peer: DiscoveredPeer = {\n          id: data.id,\n          type: 'webapp', // Assume webapp for now\n          version: data.version,\n          mods: data.mods || [],\n          capabilities: data.capabilities || []\n        };\n\n        // Update peer\n        this.discoveredPeers.set(peer.id, peer);\n        this.emit('peer:detected', peer);\n        \n        this.logger.debug(`Discovered peer: ${peer.id} with ${peer.mods.length} mods`);\n      }\n    } catch (error) {\n      this.logger.debug('Failed to handle peer message', error as Error);\n    }\n  }\n\n  private setupPostMessageListener(): void {\n    // Listen for mod announcements from the page\n    window.addEventListener('message', (event) => {\n      try {\n        const data = event.data;\n        \n        if (data.type === 'yakkl:mod-announcement') {\n          const discoveredMod: DiscoveredMod = {\n            source: 'environment',\n            manifest: data.manifest,\n            verified: data.verified || false,\n            available: true\n          };\n\n          this.discoveredMods.set(data.manifest.id, discoveredMod);\n          this.emit('mod:discovered', [discoveredMod]);\n        }\n      } catch {\n        // Invalid message format\n      }\n    });\n  }\n\n  private generatePeerId(): string {\n    // Generate a session-unique peer ID\n    if (!localStorage.getItem('yakkl:peerId')) {\n      const id = `peer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      localStorage.setItem('yakkl:peerId', id);\n    }\n    return localStorage.getItem('yakkl:peerId')!;\n  }\n}"],"names":["Logger","context","level","message","args","error","ModLoader","modId","module","sources","source","stored","userMods","updated","id","manifest","loader","location","packageName","url","response","code","blob","moduleUrl","manifestUrl","registryUrl","manifestResponse","ModClass","mod","requiredMethods","method","prefix","k","ModRegistry","EventEmitter","engine","existing","category","v","tier","all","enhancements","modIds","systemMods","config","permission","mods","targetId","targetMod","enhancement","filtered","e","DiscoveryProtocol","discovered","newMods","localMods","modElements","i","element","modData","peer","presence","m","event","data","discoveredMod"],"mappings":"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"}