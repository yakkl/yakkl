"use strict";Object.defineProperties(exports,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}});const c=require("jose");class p{constructor(e={}){this.name="jwt",this.type="local",this.config={secret:e.secret||"default-secret-change-in-production",algorithm:e.algorithm||"HS256",issuer:e.issuer||"yakkl-auth",audience:e.audience||"yakkl-app",expiresIn:e.expiresIn||"1h"},this.secret=new TextEncoder().encode(this.config.secret)}async authenticate(e){try{if(!e.username&&!e.email)return{success:!1,error:"Username or email required"};const t=e.username||e.email||"unknown",s=await this.generateToken(t,e),r=await this.generateRefreshToken(t);return{success:!0,user:{id:t,email:e.email,username:e.username,displayName:e.username||e.email,createdAt:new Date,updatedAt:new Date},session:{id:crypto.randomUUID?crypto.randomUUID():Date.now().toString(),userId:t,token:s,refreshToken:r,expiresAt:new Date(Date.now()+this.getExpiryMs()),createdAt:new Date}}}catch(t){return{success:!1,error:t instanceof Error?t.message:"Authentication failed"}}}async verify(e){try{const{payload:t}=await c.jwtVerify(e,this.secret,{issuer:this.config.issuer,audience:this.config.audience});return!(t.exp&&t.exp*1e3<Date.now())}catch{return!1}}async refresh(e){try{const{payload:t}=await c.jwtVerify(e,this.secret,{issuer:this.config.issuer,audience:this.config.audience});if(!t.sub)return{success:!1,error:"Invalid refresh token"};const s=await this.generateToken(t.sub,{id:t.sub}),r=await this.generateRefreshToken(t.sub);return{success:!0,session:{id:crypto.randomUUID?crypto.randomUUID():Date.now().toString(),userId:t.sub,token:s,refreshToken:r,expiresAt:new Date(Date.now()+this.getExpiryMs()),createdAt:new Date}}}catch(t){return{success:!1,error:t instanceof Error?t.message:"Refresh failed"}}}async revoke(e){console.log("[JWTProvider] Token revoked (would be blacklisted in production)")}async generateToken(e,t={}){return await new c.SignJWT({...t,sub:e}).setProtectedHeader({alg:this.config.algorithm}).setIssuedAt().setIssuer(this.config.issuer).setAudience(this.config.audience).setExpirationTime(this.config.expiresIn).sign(this.secret)}async generateRefreshToken(e){return await new c.SignJWT({sub:e,type:"refresh"}).setProtectedHeader({alg:this.config.algorithm}).setIssuedAt().setIssuer(this.config.issuer).setAudience(this.config.audience).setExpirationTime("7d").sign(this.secret)}getExpiryMs(){const e=this.config.expiresIn;if(typeof e=="number")return e*1e3;const t=e?.toString().match(/^(\d+)([hdms])$/);if(!t)return 36e5;const[,s,r]=t,i=parseInt(s);switch(r){case"d":return i*24*60*60*1e3;case"h":return i*60*60*1e3;case"m":return i*60*1e3;case"s":return i*1e3;default:return 36e5}}}class w{constructor(){this.name="local",this.priority=1}canHandle(e){return!!((e.username||e.email)&&e.password)}async authenticate(e){const{PasswordProvider:t}=await Promise.resolve().then(()=>f);return new t({minLength:8,requireUppercase:!0,requireLowercase:!0,requireNumbers:!0}).authenticate(e)}async register(e){const{PasswordProvider:t}=await Promise.resolve().then(()=>f);return new t({minLength:8,requireUppercase:!0,requireLowercase:!0,requireNumbers:!0}).register({username:e.username,email:e.email,password:e.password,metadata:e.metadata})}}class m{constructor(){this.store=new Map}async get(e){return this.store.get(e)}async set(e,t){this.store.set(e,t)}async remove(e){this.store.delete(e)}async clear(){this.store.clear()}}class y{constructor(e={}){this.currentSession=null,this.config=this.mergeConfig(e),this.providers=new Map,this.strategies=e.strategies||[new w],this.storage=e.storage||new m,this.initializeProviders()}async authenticate(e){try{const t=[...this.strategies].sort((s,r)=>r.priority-s.priority);for(const s of t)if(s.canHandle(e)){const r=await s.authenticate(e);return r.success&&r.session&&(this.currentSession=r.session,await this.storage.set("session",r.session),await this.storage.set("user",r.user)),r}if(e.provider){const s=this.providers.get(e.provider);if(s){const r=await s.authenticate(e);return r.success&&r.session&&(this.currentSession=r.session,await this.storage.set("session",r.session),await this.storage.set("user",r.user)),r}}return{success:!1,error:"No authentication method available for provided credentials"}}catch(t){return console.error("[AuthManager] Authentication error:",t),{success:!1,error:t instanceof Error?t.message:"Authentication failed"}}}async verify(e){try{const t=e||this.currentSession?.token;if(!t)return!1;const s=this.providers.get("jwt");return s?await s.verify(t):this.currentSession?new Date<new Date(this.currentSession.expiresAt):!1}catch(t){return console.error("[AuthManager] Verification error:",t),!1}}async refresh(){try{if(!this.currentSession?.refreshToken)return{success:!1,error:"No refresh token available"};const e=this.providers.get("jwt");if(e?.refresh){const t=await e.refresh(this.currentSession.refreshToken);return t.success&&t.session&&(this.currentSession=t.session,await this.storage.set("session",t.session)),t}return{success:!1,error:"Refresh not supported"}}catch(e){return console.error("[AuthManager] Refresh error:",e),{success:!1,error:e instanceof Error?e.message:"Refresh failed"}}}async logout(){try{if(this.currentSession?.token){const e=this.providers.get("jwt");e?.revoke&&await e.revoke(this.currentSession.token)}this.currentSession=null,await this.storage.clear()}catch(e){console.error("[AuthManager] Logout error:",e)}}async getCurrentUser(){try{return await this.storage.get("user")}catch{return null}}getSession(){return this.currentSession}isAuthenticated(){return this.currentSession?new Date<new Date(this.currentSession.expiresAt):!1}addProvider(e){this.providers.set(e.name,e)}addStrategy(e){this.strategies.push(e),this.strategies.sort((t,s)=>s.priority-t.priority)}initializeProviders(){if(this.providers.has("jwt")||this.addProvider(new p({secret:process.env.JWT_SECRET||"default-secret-change-in-production"})),this.config.providers)for(const e of this.config.providers)this.addProvider(e)}mergeConfig(e){return{providers:[],strategies:[],sessionDuration:3600,refreshEnabled:!0,mfaEnabled:!1,securityLevel:"medium",...e}}}class A{constructor(e){this.name="web3",this.type="web3",this.config={message:"Sign this message to authenticate with YAKKL",verifySignature:!0,...e}}async authenticate(e){try{const{address:t,signature:s,message:r,nonce:i}=e;if(!t||!s)return{success:!1,error:"Wallet address and signature required"};if(this.config.verifySignature&&!await this.verifySignature(t,s,r||this.config.message))return{success:!1,error:"Invalid signature"};const a=this.generateSessionId(),o=await this.generateWeb3Token(t,i);return{success:!0,user:{id:t.toLowerCase(),username:t,displayName:`${t.slice(0,6)}...${t.slice(-4)}`,metadata:{chainId:this.config.chainId,walletType:e.walletType||"unknown"},createdAt:new Date,updatedAt:new Date},session:{id:a,userId:t.toLowerCase(),token:o,expiresAt:new Date(Date.now()+24*60*60*1e3),createdAt:new Date,metadata:{chainId:this.config.chainId}}}}catch(t){return{success:!1,error:t instanceof Error?t.message:"Web3 authentication failed"}}}async verify(e){try{const t=e.split(".");if(t.length!==3)return!1;const s=JSON.parse(atob(t[1]));return!(s.exp&&s.exp<Date.now()/1e3)}catch{return!1}}async verifySignature(e,t,s){try{return!(!t.startsWith("0x")||t.length!==132)}catch{return!1}}async generateWeb3Token(e,t){const s={alg:"ES256K",typ:"JWT"},r={sub:e.toLowerCase(),iat:Math.floor(Date.now()/1e3),exp:Math.floor(Date.now()/1e3)+86400,chainId:this.config.chainId,nonce:t},i=btoa(JSON.stringify(s)),a=btoa(JSON.stringify(r));return`${i}.${a}.mock-signature`}generateSessionId(){return`web3_${Date.now()}_${Math.random().toString(36).substring(2,15)}`}}class b{constructor(e){this.name="oauth",this.type="oauth",this.config=e,this.providers={google:{authEndpoint:"https://accounts.google.com/o/oauth2/v2/auth",tokenEndpoint:"https://oauth2.googleapis.com/token",userInfoEndpoint:"https://www.googleapis.com/oauth2/v2/userinfo",scopes:["openid","email","profile"]},github:{authEndpoint:"https://github.com/login/oauth/authorize",tokenEndpoint:"https://github.com/login/oauth/access_token",userInfoEndpoint:"https://api.github.com/user",scopes:["read:user","user:email"]},x:{authEndpoint:"https://twitter.com/i/oauth2/authorize",tokenEndpoint:"https://api.twitter.com/2/oauth2/token",userInfoEndpoint:"https://api.twitter.com/2/users/me",scopes:["users.read","tweet.read"]},meta:{authEndpoint:"https://www.facebook.com/v18.0/dialog/oauth",tokenEndpoint:"https://graph.facebook.com/v18.0/oauth/access_token",userInfoEndpoint:"https://graph.facebook.com/me",scopes:["email","public_profile"]},microsoft:{authEndpoint:"https://login.microsoftonline.com/common/oauth2/v2.0/authorize",tokenEndpoint:"https://login.microsoftonline.com/common/oauth2/v2.0/token",userInfoEndpoint:"https://graph.microsoft.com/v1.0/me",scopes:["openid","email","profile"]},apple:{authEndpoint:"https://appleid.apple.com/auth/authorize",tokenEndpoint:"https://appleid.apple.com/auth/token",userInfoEndpoint:null,scopes:["name","email"]}}}getAuthorizationUrl(e){const t=this.providers[this.config.provider],s=this.config.authEndpoint||t.authEndpoint,r=this.config.scopes||t.scopes,i=new URLSearchParams({client_id:this.config.clientId,redirect_uri:this.config.redirectUri,response_type:"code",scope:r.join(" "),state:e||this.generateState()});return this.config.provider==="google"?(i.set("access_type","offline"),i.set("prompt","consent")):this.config.provider==="apple"&&i.set("response_mode","form_post"),`${s}?${i.toString()}`}async exchangeCode(e){const t=this.providers[this.config.provider],s=this.config.tokenEndpoint||t.tokenEndpoint,r={grant_type:"authorization_code",code:e,redirect_uri:this.config.redirectUri,client_id:this.config.clientId};this.config.clientSecret&&(r.client_secret=this.config.clientSecret);const i=await fetch(s,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"},body:new URLSearchParams(r).toString()});if(!i.ok){const o=await i.text();throw new Error(`Token exchange failed: ${o}`)}const a=await i.json();return{accessToken:a.access_token,refreshToken:a.refresh_token,idToken:a.id_token}}async getUserInfo(e){const t=this.providers[this.config.provider],s=this.config.userInfoEndpoint||t.userInfoEndpoint;if(!s)return this.config.provider==="apple"?this.decodeIdToken(e):null;const r=await fetch(s,{headers:{Authorization:`Bearer ${e}`,Accept:"application/json"}});if(!r.ok)throw new Error(`Failed to fetch user info: ${r.statusText}`);return r.json()}async authenticate(e){try{if(!e.code)return{success:!1,error:"Authorization code required"};const t=await this.exchangeCode(e.code),s=await this.getUserInfo(t.accessToken),r=this.mapUserInfo(s),i=this.generateSessionId();return{success:!0,user:r,session:{id:i,userId:r.id,token:t.accessToken,refreshToken:t.refreshToken,expiresAt:new Date(Date.now()+36e5),createdAt:new Date,metadata:{provider:this.config.provider,idToken:t.idToken}}}}catch(t){return{success:!1,error:t.message||"OAuth authentication failed"}}}async verify(e){try{return!!await this.getUserInfo(e)}catch{return!1}}async refresh(e){const t=this.providers[this.config.provider],s=this.config.tokenEndpoint||t.tokenEndpoint,r={grant_type:"refresh_token",refresh_token:e,client_id:this.config.clientId};this.config.clientSecret&&(r.client_secret=this.config.clientSecret);try{const i=await fetch(s,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"},body:new URLSearchParams(r).toString()});if(!i.ok)throw new Error("Token refresh failed");const a=await i.json();return{success:!0,session:{id:this.generateSessionId(),userId:"",token:a.access_token,refreshToken:a.refresh_token||e,expiresAt:new Date(Date.now()+(a.expires_in||3600)*1e3),createdAt:new Date}}}catch(i){return{success:!1,error:i.message||"Token refresh failed"}}}async revoke(e){console.log(`[OAuthProvider] Token revoked for ${this.config.provider}`)}mapUserInfo(e){switch(this.config.provider){case"google":return{id:e.id,email:e.email,username:e.email,displayName:e.name,avatar:e.picture,metadata:{verified:e.verified_email},createdAt:new Date,updatedAt:new Date};case"github":return{id:e.id.toString(),email:e.email,username:e.login,displayName:e.name||e.login,avatar:e.avatar_url,metadata:{bio:e.bio,company:e.company},createdAt:new Date(e.created_at),updatedAt:new Date(e.updated_at)};case"x":return{id:e.id,email:e.email||`${e.username}@x.com`,username:e.username,displayName:e.name,avatar:e.profile_image_url,metadata:{verified:e.verified},createdAt:new Date(e.created_at),updatedAt:new Date};default:return{id:e.id||e.sub,email:e.email,username:e.username||e.email,displayName:e.name||e.email,avatar:e.picture||e.avatar,metadata:e,createdAt:new Date,updatedAt:new Date}}}generateState(){return Math.random().toString(36).substring(2,15)}generateSessionId(){return`oauth_${Date.now()}_${Math.random().toString(36).substring(2,15)}`}decodeIdToken(e){const t=e.split(".");if(t.length!==3)throw new Error("Invalid ID token");return JSON.parse(atob(t[1]))}}class S{constructor(e={}){this.name="password",this.type="local",this.users=new Map,this.attempts=new Map,this.lockouts=new Map,this.config={minLength:8,requireUppercase:!0,requireLowercase:!0,requireNumbers:!0,requireSpecialChars:!1,bcryptRounds:10,maxAttempts:5,lockoutDuration:15,...e}}async register(e){try{const t=e.username||e.email;if(!t)return{success:!1,error:"Username or email required"};if(this.users.has(t))return{success:!1,error:"User already exists"};const s=this.validatePassword(e.password);if(!s.valid)return{success:!1,error:s.errors.join(", ")};const r=await this.hashPassword(e.password),i={id:this.generateUserId(),username:e.username,email:e.email,password:r,metadata:e.metadata||{},createdAt:new Date,updatedAt:new Date};this.users.set(t,i);const a=this.generateSessionId();return{success:!0,user:this.sanitizeUser(i),session:{id:a,userId:i.id,token:this.generateToken(i.id),expiresAt:new Date(Date.now()+24*60*60*1e3),createdAt:new Date}}}catch(t){return{success:!1,error:t.message||"Registration failed"}}}async authenticate(e){try{const t=e.username||e.email;if(!t||!e.password)return{success:!1,error:"Username/email and password required"};if(this.isLockedOut(t)){const a=this.lockouts.get(t);return{success:!1,error:`Account locked. Try again in ${Math.ceil((a.getTime()-Date.now())/6e4)} minutes`}}const s=this.users.get(t);if(!s)return this.recordFailedAttempt(t),{success:!1,error:"Invalid credentials"};if(!await this.verifyPassword(e.password,s.password))return this.recordFailedAttempt(t),{success:!1,error:"Invalid credentials"};this.attempts.delete(t);const i=this.generateSessionId();return{success:!0,user:this.sanitizeUser(s),session:{id:i,userId:s.id,token:this.generateToken(s.id),expiresAt:new Date(Date.now()+24*60*60*1e3),createdAt:new Date}}}catch(t){return{success:!1,error:t.message||"Authentication failed"}}}async changePassword(e,t,s){try{let r,i;for(const[T,g]of this.users.entries())if(g.id===e){r=g,i=T;break}if(!r||!i)return{success:!1,error:"User not found"};if(!await this.verifyPassword(t,r.password))return{success:!1,error:"Current password is incorrect"};const o=this.validatePassword(s);if(!o.valid)return{success:!1,error:o.errors.join(", ")};const l=await this.hashPassword(s);return r.password=l,r.updatedAt=new Date,this.users.set(i,r),{success:!0}}catch(r){return{success:!1,error:r.message||"Password change failed"}}}async resetPassword(e,t){const s=this.validatePassword(t);return s.valid?{success:!0}:{success:!1,error:s.errors.join(", ")}}async verify(e){try{const t=this.parseToken(e);return!!t.userId&&Date.now()<t.exp}catch{return!1}}validatePassword(e){const t=[];return e.length<this.config.minLength&&t.push(`Password must be at least ${this.config.minLength} characters`),this.config.requireUppercase&&!/[A-Z]/.test(e)&&t.push("Password must contain uppercase letter"),this.config.requireLowercase&&!/[a-z]/.test(e)&&t.push("Password must contain lowercase letter"),this.config.requireNumbers&&!/[0-9]/.test(e)&&t.push("Password must contain number"),this.config.requireSpecialChars&&!/[!@#$%^&*(),.?":{}|<>]/.test(e)&&t.push("Password must contain special character"),{valid:t.length===0,errors:t}}async hashPassword(e){const s=new TextEncoder().encode(e+"salt"),r=await crypto.subtle.digest("SHA-256",s);return btoa(String.fromCharCode(...new Uint8Array(r)))}async verifyPassword(e,t){return await this.hashPassword(e)===t}recordFailedAttempt(e){const t=(this.attempts.get(e)||0)+1;if(this.attempts.set(e,t),t>=this.config.maxAttempts){const s=new Date(Date.now()+this.config.lockoutDuration*6e4);this.lockouts.set(e,s),this.attempts.delete(e)}}isLockedOut(e){const t=this.lockouts.get(e);return t?t.getTime()>Date.now()?!0:(this.lockouts.delete(e),!1):!1}sanitizeUser(e){const{password:t,...s}=e;return s}generateUserId(){return`user_${Date.now()}_${Math.random().toString(36).substring(2,15)}`}generateSessionId(){return`pwd_${Date.now()}_${Math.random().toString(36).substring(2,15)}`}generateToken(e){const t={alg:"HS256",typ:"JWT"},s={sub:e,iat:Math.floor(Date.now()/1e3),exp:Math.floor(Date.now()/1e3)+86400},r=btoa(JSON.stringify(t)),i=btoa(JSON.stringify(s));return`${r}.${i}.mock_signature`}parseToken(e){const t=e.split(".");if(t.length!==3)throw new Error("Invalid token");return JSON.parse(atob(t[1]))}}const f=Object.freeze(Object.defineProperty({__proto__:null,PasswordProvider:S},Symbol.toStringTag,{value:"Module"}));class u{constructor(e){this.name="passkey",this.type="passkey",this.credentials=new Map,this.config={userVerification:"preferred",timeout:6e4,attestation:"none",...e}}async startRegistration(e){const t=this.generateChallenge();return this.storeChallenge(e.id,t),{challenge:t,rp:{name:this.config.rpName,id:this.config.rpId},user:{id:this.stringToBuffer(e.id),name:e.name,displayName:e.displayName},pubKeyCredParams:[{alg:-7,type:"public-key"},{alg:-257,type:"public-key"},{alg:-8,type:"public-key"}],authenticatorSelection:{userVerification:this.config.userVerification,residentKey:"preferred",requireResidentKey:!1},timeout:this.config.timeout,attestation:this.config.attestation}}async completeRegistration(e,t){try{if(!await this.verifyRegistration(e,t))return{success:!1,credentialId:""};const r=this.bufferToBase64(t.rawId),i=t.response,a=i.getPublicKey?.();if(!a)throw new Error("Failed to extract public key from credential");const o={id:r,publicKey:this.extractPublicKey(a),algorithm:-7,transports:i.getTransports?.()||[],attestationObject:i.attestationObject,clientDataJSON:i.clientDataJSON};return this.credentials.set(r,o),await this.storeCredential(e,o),{success:!0,credentialId:r}}catch(s){return console.error("[PasskeyProvider] Registration failed:",s),{success:!1,credentialId:""}}}async startAuthentication(e){const t=this.generateChallenge();this.storeChallenge(e||"anonymous",t);const s={challenge:t,timeout:this.config.timeout,userVerification:this.config.userVerification,rpId:this.config.rpId};if(e){const r=await this.getUserCredentials(e);r.length>0&&(s.allowCredentials=r.map(i=>({id:this.base64ToBuffer(i.id),type:"public-key",transports:i.transports||["internal","hybrid"]})))}return s}async authenticate(e){try{if(!e.assertion)return{success:!1,error:"Passkey assertion required"};const t=e.assertion,s=t.response;if(!await this.verifyAssertion(t.id,s,e.userId))return{success:!1,error:"Passkey verification failed"};const i=await this.getUserFromCredential(t.id);if(!i)return{success:!1,error:"User not found"};const a=this.generateSessionId();return{success:!0,user:i,session:{id:a,userId:i.id,token:this.generateToken(i.id),expiresAt:new Date(Date.now()+24*60*60*1e3),createdAt:new Date,metadata:{authenticator:"passkey",credentialId:this.bufferToBase64(t.rawId)}}}}catch(t){return{success:!1,error:t.message||"Passkey authentication failed"}}}async verify(e){try{const t=this.parseToken(e);return!!t.userId&&Date.now()<t.exp}catch{return!1}}static isSupported(){return!!(window?.PublicKeyCredential&&window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable)}static async isConditionalUIAvailable(){if(!u.isSupported())return!1;try{return await window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()}catch{return!1}}async verifyRegistration(e,t){const s=this.getChallenge(e),r=t.response;if(!s)return!1;const i=JSON.parse(new TextDecoder().decode(r.clientDataJSON));return i.type==="webauthn.create"&&i.origin===this.config.origin&&this.bufferToBase64(new TextEncoder().encode(i.challenge))===this.bufferToBase64(s)}async verifyAssertion(e,t,s){if(!this.getChallenge(s||"anonymous"))return!1;const i=JSON.parse(new TextDecoder().decode(t.clientDataJSON));return i.type==="webauthn.get"&&i.origin===this.config.origin}generateChallenge(){const e=new Uint8Array(32);return crypto.getRandomValues(e),e.buffer}storeChallenge(e,t){const s=`challenge_${e}`;sessionStorage.setItem(s,this.bufferToBase64(t))}getChallenge(e){const t=`challenge_${e}`,s=sessionStorage.getItem(t);return s?(sessionStorage.removeItem(t),this.base64ToBuffer(s)):null}async storeCredential(e,t){const s=`passkey_${e}`;localStorage.setItem(s,JSON.stringify({...t,attestationObject:void 0,clientDataJSON:void 0}))}async getUserCredentials(e){const t=`passkey_${e}`,s=localStorage.getItem(t);return s?[JSON.parse(s)]:[]}async getUserFromCredential(e){return{id:"user_"+Date.now(),username:"passkey_user",displayName:"Passkey User",createdAt:new Date,updatedAt:new Date}}extractPublicKey(e){return e?this.bufferToBase64(e):"extracted_public_key"}generateToken(e){const t={alg:"HS256",typ:"JWT"},s={sub:e,iat:Math.floor(Date.now()/1e3),exp:Math.floor(Date.now()/1e3)+86400},r=btoa(JSON.stringify(t)),i=btoa(JSON.stringify(s));return`${r}.${i}.mock_signature`}parseToken(e){const t=e.split(".");if(t.length!==3)throw new Error("Invalid token");return JSON.parse(atob(t[1]))}generateSessionId(){return`passkey_${Date.now()}_${Math.random().toString(36).substring(2,15)}`}stringToBuffer(e){return new TextEncoder().encode(e).buffer}bufferToBase64(e){const t=new Uint8Array(e);let s="";for(let r=0;r<t.byteLength;r++)s+=String.fromCharCode(t[r]);return btoa(s)}base64ToBuffer(e){const t=atob(e),s=new Uint8Array(t.length);for(let r=0;r<t.length;r++)s[r]=t.charCodeAt(r);return s.buffer}}class x{constructor(e="yakkl_auth_"){this.prefix=e,this.store=new Map}async initialize(e){if(e&&typeof crypto<"u"){const t=new TextEncoder,s=await crypto.subtle.importKey("raw",t.encode(e),"PBKDF2",!1,["deriveBits","deriveKey"]);this.encryptionKey=await crypto.subtle.deriveKey({name:"PBKDF2",salt:t.encode("yakkl_salt"),iterations:1e5,hash:"SHA-256"},s,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}}async get(e){const t=`${this.prefix}${e}`;if(typeof localStorage<"u"){const s=localStorage.getItem(t);return s&&this.encryptionKey?this.decrypt(s):s?JSON.parse(s):null}return this.store.get(t)}async set(e,t){const s=`${this.prefix}${e}`,r=JSON.stringify(t);if(typeof localStorage<"u"){const i=this.encryptionKey?await this.encrypt(r):r;localStorage.setItem(s,i)}else this.store.set(s,t)}async remove(e){const t=`${this.prefix}${e}`;typeof localStorage<"u"?localStorage.removeItem(t):this.store.delete(t)}async clear(){typeof localStorage<"u"?Object.keys(localStorage).forEach(t=>{t.startsWith(this.prefix)&&localStorage.removeItem(t)}):this.store.clear()}async encrypt(e){if(!this.encryptionKey)return e;const t=new TextEncoder,s=crypto.getRandomValues(new Uint8Array(12)),r=await crypto.subtle.encrypt({name:"AES-GCM",iv:s},this.encryptionKey,t.encode(e)),i=new Uint8Array(s.length+r.byteLength);return i.set(s),i.set(new Uint8Array(r),s.length),btoa(String.fromCharCode(...i))}async decrypt(e){if(!this.encryptionKey)return JSON.parse(e);const t=new Uint8Array(atob(e).split("").map(o=>o.charCodeAt(0))),s=t.slice(0,12),r=t.slice(12),i=await crypto.subtle.decrypt({name:"AES-GCM",iv:s},this.encryptionKey,r),a=new TextDecoder;return JSON.parse(a.decode(i))}}class d{constructor(e,t){this.storage=e,this.onRefresh=t}async saveToken(e,t){await this.storage.set("auth_token",e),t&&(await this.storage.set("token_expiry",Date.now()+t*1e3),this.scheduleRefresh(t))}async getToken(){const e=await this.storage.get("auth_token"),t=await this.storage.get("token_expiry");return e&&t&&Date.now()>t?(await this.removeToken(),null):e}async saveRefreshToken(e){await this.storage.set("refresh_token",e)}async getRefreshToken(){return this.storage.get("refresh_token")}async removeToken(){this.clearRefreshTimer(),await this.storage.remove("auth_token"),await this.storage.remove("token_expiry")}async removeRefreshToken(){await this.storage.remove("refresh_token")}async clearAll(){this.clearRefreshTimer(),await this.removeToken(),await this.removeRefreshToken()}scheduleRefresh(e){this.clearRefreshTimer();const t=(e-300)*1e3;t>0&&this.onRefresh&&(this.refreshTimer=setTimeout(async()=>{try{const s=await this.getToken();if(s&&this.onRefresh){const r=await this.onRefresh(s);await this.saveToken(r,e)}}catch(s){console.error("[TokenManager] Failed to refresh token:",s)}},t))}clearRefreshTimer(){this.refreshTimer&&(clearTimeout(this.refreshTimer),this.refreshTimer=void 0)}static parseJWT(e){try{const t=e.split(".");if(t.length!==3)throw new Error("Invalid JWT format");const s=t[1],r=atob(s.replace(/-/g,"+").replace(/_/g,"/"));return JSON.parse(r)}catch(t){return console.error("[TokenManager] Failed to parse JWT:",t),null}}static isTokenExpired(e){const t=d.parseJWT(e);return!t||!t.exp?!0:Date.now()>=t.exp*1e3}}const D={timeoutMinutes:30,warningMinutes:2,maxInactivityMinutes:60,autoExtendOnActivity:!0,jwtExpirationMinutes:60};class E{constructor(e,t,s=console){this.config=D,this.sessionState=null,this.timeoutTimer=null,this.warningTimer=null,this.onSessionWarning=null,this.onSessionExpired=null,this.onSessionExtended=null,this.storage=e,this.jwtManager=t,this.logger=s,this.initializeFromStorage()}async startSession(e,t,s,r="explorer_member"){try{const i=await this.jwtManager.generateToken(e,t,s,r,this.config.jwtExpirationMinutes),a=Date.now(),o=this.generateSessionId();return this.sessionState={isActive:!0,userId:e,username:t,profileId:s,planLevel:r,sessionId:o,lastActivity:a,expiresAt:a+this.config.timeoutMinutes*60*1e3,jwtToken:i,warningShown:!1},await this.storage.save(this.sessionState),this.startActivityTracking(),this.scheduleWarning(),this.logger.debug("Session started",{userId:e,username:t,sessionId:o,expiresAt:new Date(this.sessionState.expiresAt)}),await this.onSessionStarted(this.sessionState),i}catch(i){throw this.logger.error("Failed to start session:",i),new Error("Session start failed")}}async extendSession(e=30){if(!this.sessionState||!this.sessionState.isActive)throw new Error("No active session to extend");try{const t=Date.now(),s=t+e*60*1e3;if(this.sessionState.jwtToken){const r=await this.jwtManager.refreshTokenIfNeeded(this.sessionState.jwtToken,10);r&&r!==this.sessionState.jwtToken&&(this.sessionState.jwtToken=r,this.logger.debug("JWT token refreshed during session extension"))}this.sessionState.lastActivity=t,this.sessionState.expiresAt=s,this.sessionState.warningShown=!1,await this.storage.save(this.sessionState),this.clearTimers(),this.scheduleWarning(),this.logger.debug("Session extended",{sessionId:this.sessionState.sessionId,additionalMinutes:e,newExpiresAt:new Date(s)}),this.onSessionExtended&&this.onSessionExtended(),await this.onSessionExtendedInternal(this.sessionState)}catch(t){throw this.logger.error("Failed to extend session:",t),new Error("Session extension failed")}}async endSession(){this.sessionState&&(this.logger.debug("Ending session",{sessionId:this.sessionState.sessionId}),await this.onSessionEnded(this.sessionState)),this.sessionState=null,this.clearTimers(),this.stopActivityTracking();try{await this.storage.clear()}catch(e){this.logger.warn("Failed to clear session storage:",e)}this.onSessionExpired&&this.onSessionExpired()}getSessionState(){return this.sessionState?{...this.sessionState}:null}getCurrentJWTToken(){return this.sessionState?.jwtToken||null}isSessionActive(){return!this.sessionState||!this.sessionState.isActive?!1:Date.now()>=this.sessionState.expiresAt?(this.endSession(),!1):!0}updateActivity(){if(!this.sessionState||!this.sessionState.isActive)return;const e=Date.now();if(this.sessionState.lastActivity=e,this.config.autoExtendOnActivity){const t=this.sessionState.expiresAt-e,s=this.config.warningMinutes*60*1e3;t<=s&&!this.sessionState.warningShown&&this.extendSession(this.config.timeoutMinutes)}this.storage.save(this.sessionState)}setCallbacks(e){this.onSessionWarning=e.onWarning||null,this.onSessionExpired=e.onExpired||null,this.onSessionExtended=e.onExtended||null}updateConfig(e){this.config={...this.config,...e},this.logger.debug("Session config updated",this.config)}async initializeFromStorage(){try{const e=await this.storage.load();if(e&&e.isActive){const t=Date.now();if(t<e.expiresAt){this.sessionState=e,this.startActivityTracking();const s=e.expiresAt-t,r=this.config.warningMinutes*60*1e3;if(s<=r){this.logger.debug("Restored session near expiry, auto-extending",{sessionId:e.sessionId,timeRemaining:Math.round(s/1e3)}),this.sessionState.warningShown=!1;try{await this.extendSession(this.config.timeoutMinutes),this.logger.info("Auto-extended restored session that was near expiry")}catch(i){this.logger.error("Failed to auto-extend restored session:",i),this.scheduleWarning()}}else this.scheduleWarning();this.logger.debug("Session restored from storage",{sessionId:e.sessionId,timeRemaining:Math.round((e.expiresAt-t)/1e3)})}else await this.storage.clear(),this.logger.debug("Expired session cleared from storage")}}catch(e){this.logger.warn("Failed to initialize session from storage:",e)}}scheduleWarning(){if(!this.sessionState)return;const e=Date.now(),t=this.sessionState.expiresAt-e-this.config.warningMinutes*60*1e3;t>0?this.warningTimer=setTimeout(()=>{this.showSessionWarning()},t):this.showSessionWarning()}showSessionWarning(){if(!this.sessionState||this.sessionState.warningShown)return;this.sessionState.warningShown=!0;const e=Date.now(),t=Math.max(0,Math.round((this.sessionState.expiresAt-e)/1e3));this.logger.debug("Showing session warning",{timeRemaining:t}),this.onSessionWarning&&this.onSessionWarning(t),this.timeoutTimer=setTimeout(()=>{this.endSession()},t*1e3)}clearTimers(){this.timeoutTimer&&(clearTimeout(this.timeoutTimer),this.timeoutTimer=null),this.warningTimer&&(clearTimeout(this.warningTimer),this.warningTimer=null)}generateSessionId(){const e=Date.now().toString(36),t=Math.random().toString(36).substring(2);return`session-${e}-${t}`}}async function k(n,e){const t=n.logger||console;try{const s=await n.storage.get("yakkl_settings");if(!s||!s.init)return{isValid:!1,reason:"Wallet not initialized"};if(!s.legal?.termsAgreed)return{isValid:!1,reason:"Legal terms not accepted"};if(!e||e.length===0)return{isValid:!1,reason:"No authentication digest"};const r=await n.storage.get("yakkl_profile");if(!r)return{isValid:!1,reason:"No user profile"};if(!r.data)return{isValid:!1,reason:"Profile data missing"};let i=!1;if(n.sessionManager?.isSessionActive()){const a=n.sessionManager.getCurrentJWTToken();if(a&&n.jwtManager)try{await n.jwtManager.verifyToken(a)&&(i=!0)}catch(o){t.warn("JWT token verification error",o)}}return/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i.test(r.id)?{isValid:!0,profile:r,hasValidSession:n.sessionManager?.isSessionActive(),hasValidJWT:i}:(t.warn("Authentication failed: Invalid profile ID format"),{isValid:!1,reason:"Invalid profile format"})}catch(s){return t.warn("Authentication validation error",s),{isValid:!1,reason:"Validation error"}}}async function _(n,e){try{const t=await n.storage.get("yakkl_settings");return!!(t&&t.isLocked===!1&&e&&e.length>0)}catch{return!1}}async function v(n,e,t){const s=n.logger||console;try{const r=await n.storage.get("yakkl_settings");r&&(r.isLocked=!0,await n.storage.set("yakkl_settings",r)),e();try{n.sessionManager?.isSessionActive()&&await n.sessionManager.endSession()}catch(i){s.warn("Error ending session during auth clear",i)}t&&t(),s.info("Authentication state cleared")}catch(r){s.warn("Error clearing authentication state",r)}}async function I(n,e,t,s){const r=n.logger||console;try{if(!(await k(n,e)).isValid)return await v(n,t,s),!1;if(n.sessionManager?.isSessionActive())try{await n.sessionManager.extendSession()}catch(a){r.warn("Failed to extend session during auth refresh",a)}return!0}catch(i){return r.warn("Error validating and refreshing auth",i),!1}}async function P(n,e={},t){const s=t||console;try{const r={event:n,timestamp:new Date().toISOString(),details:e,profileId:e.profileId||"unknown"};n==="validation_failed"||n==="unauthorized_access"?s.warn("Security audit event",r):s.debug("Security audit event",r)}catch(r){s.warn("Error auditing auth event",r)}}const h=new Map,M=5,C=15*60*1e3;function U(n){const e=Date.now(),t=h.get(n);return t?e-t.lastAttempt>C?(h.set(n,{attempts:1,lastAttempt:e}),!0):t.attempts>=M?!1:(t.attempts++,t.lastAttempt=e,!0):(h.set(n,{attempts:1,lastAttempt:e}),!0)}function R(n){h.delete(n)}exports.AuthManager=y;exports.JWTProvider=p;exports.LocalAuthStrategy=w;exports.MemoryStorage=m;exports.OAuthProvider=b;exports.PasskeyProvider=u;exports.PasswordProvider=S;exports.SecureStorage=x;exports.SessionManagerBase=E;exports.TokenManager=d;exports.Web3Provider=A;exports.auditAuthEvent=P;exports.checkAuthRateLimit=U;exports.clearAuthRateLimit=R;exports.clearAuthenticationState=v;exports.default=y;exports.quickAuthCheck=_;exports.validateAndRefreshAuth=I;exports.validateAuthentication=k;
//# sourceMappingURL=index.js.map
